{"text": [";\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by david on 15-7-21.\n */\npublic class Subject {\n\n    public static class SubjectDescObject implements Serializable, ISubjectRecommendObject {\n\n        public int id;\n        public String name;\n        public Integer speackers;\n        public int watchers;\n        public Integer count;\n        public String image_url;\n        public String description;\n        public boolean watched;\n        public long created_at;\n        public HotTweetDescObject hot_tweet;\n        public List<UserObject> user_list;\n\n        public SubjectDescObject(JSONObject json) throws JSONException {\n            created_at = json.optLong(\"created_at\");\n            id = json.optInt(\"id\");\n            watched = json.optBoolean(\"watched\");\n            speackers = json.optInt(\"speackers\");\n            if (speackers == 0)\n                speackers = json.optInt(\"speakers\");\n            watchers = json.optInt(\"watchers\");\n            count = json.optInt(\"count\");\n            image_url = json.optString(\"image_url\");\n            description = json.optString(\"description\");\n            name = json.optString(\"name\");\n            if (json.has(\"hot_tweet\"))\n                hot_tweet = new HotTweetDescObject(json.optJSONObject(\"hot_tweet\"));\n            JSONArray arr = json.optJSONArray(\"user_list\");\n            if (arr != null && arr.length() > 0) {\n                user_list = new ArrayList<UserObject>();\n                for (int i = 0; i < arr.length(); i++) {\n                    user_list.add(new UserObject(arr.optJSONObject(i)));\n                }\n            }\n        }\n\n        @Override\n        public String getName() {\n            return this.name;\n        }\n\n        @Override\n        public int getType() {\n            return 1;\n        }\n\n    }\n\n    public static class HotTweetDescObject implements Serializable {\n        public int id;\n        public int owner_id;\n        public UserObject owner;\n        public long created_at;\n        public int likes;\n        public int comments;\n        public List<BaseComment> comment_list;\n        public String device;\n        public String location;\n        public String coord;\n        public String address;\n        public String content;\n        public String path;\n        public int acitivity_id;\n        public boolean liked;\n        public List<UserObject> like_users;\n\n        public HotTweetDescObject(JSONObject json) {\n            id = json.optInt(\"id\");\n            owner_id = json.optInt(\"owner_id\");\n            owner = new UserObject(json.optJSONObject(\"owner\"));\n            created_at = json.optLong(\"created_at\");\n            likes = json.optInt(\"likes\");\n            comments = json.optInt(\"comments\");\n            device = json.optString(\"device\");\n            location = json.optString(\"location\");\n            device = json.optString(\"device\");\n            coord = json.optString(\"coord\");\n            device = json.optString(\"device\");\n            address = json.optString(\"address\");\n            content = json.optString(\"content\");\n            acitivity_id = json.optInt(\"acitivity_id\");\n            liked = json.optBoolean(\"liked\");\n            JSONArray arr = json.optJSONArray(\"like_users\");\n            if (arr != null && arr.length() > 0) {\n                like_users = new ArrayList<UserObject>();\n                for (int i = 0; i < arr.length(); i++) {\n                    like_users.add(new UserObject(arr.optJSONObject(i)));\n                }\n            }\n        }\n\n    }\n\n    public static class SubjectLastUsedObject implements Serializable, ISubjectRecommendObject {\n\n        public String name;\n\n        public SubjectLastUsedObject(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public int getType() {\n            return 0;\n        }\n    }\n\n}\n", "jector;\nimport com.google.template.soy.data.SoyData;\nimport com.google.template.soy.data.SoyMapData;\nimport com.google.template.soy.data.SoyValue;\nimport com.google.template.soy.data.restricted.IntegerData;\nimport com.google.template.soy.data.restricted.StringData;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slieb.soy.context.RendererFactoryContext;\nimport org.slieb.soy.context.SoyValueFactoryContext;\nimport org.slieb.soy.model.LongData;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.junit.Assert.*;\nimport static org.slieb.soy.Loader.getBasicInjector;\n\npublic class BasicLoaderTest {\n\n    private Injector injector;\n\n    @Before\n    public void setup() {\n        injector = getBasicInjector();\n    }\n\n    @Test\n    public void testBasicInjectorMakesSingletonContext() throws Exception {\n        assertSame(\"Singleton instance expected\",\n                   injector.getInstance(SoyValueFactoryContext.class),\n                   injector.getInstance(SoyValueFactoryContext.class));\n    }\n\n    @Test(expected = ConfigurationException.class)\n    public void testBasicInjectorCannotDeliverRenderer() {\n        injector.getInstance(RendererFactoryContext.class);\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertInteger() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        Integer integer = new Integer(102);\n        SoyValue data = context.apply(integer);\n        assertTrue(data instanceof IntegerData);\n        assertEquals(102, data.integerValue());\n        SoyValue data2 = context.apply(102);\n        assertTrue(data2 instanceof IntegerData);\n        assertEquals(data2, data);\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertLong() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        Long integer = new Long(102);\n        SoyValue data = context.apply(integer);\n        assertTrue(data instanceof LongData);\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertSoyData() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        SoyValue data = context.apply(1);\n        assertTrue(data instanceof IntegerData);\n        assertSame(data, context.apply(data));\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertString() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        SoyValue data = context.apply(\"string\");\n        assertTrue(data instanceof StringData);\n        assertEquals(\"string\", data.stringValue());\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertMap() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"strEntry\", \"string\");\n        map.put(\"intEntry\", 10);\n        map.put(\"longEntry\", 10L);\n        SoyValue data = context.apply(map);\n        assertTrue(data instanceof SoyMapData);\n        SoyData strEntryData = ((SoyMapData) data).get(\"strEntry\");\n        assertTrue(strEntryData instanceof StringData);\n        assertEquals(\"string\", strEntryData.stringValue());\n        SoyData intEntryData = ((SoyMapData) data).get(\"intEntry\");\n        assertTrue(intEntryData instanceof IntegerData);\n        assertEquals(10, intEntryData.integerValue());\n        SoyData longEntryData = ((SoyMapData) data).get(\"longEntry\");\n        assertTrue(longEntryData instanceof LongData);\n    }\n}\n", "eption;\nimport java.io.OutputStream;\n\nimport org.springframework.ws.transport.TransportOutputStream;\n\npublic class ByteArrayTransportOutputStream extends TransportOutputStream {\n\n  private static final String NEW_LINE = System.getProperty(\"line.separator\");\n\n  private ByteArrayOutputStream byteArrayOutputStream;\n\n  @Override\n  public void addHeader(String name, String value) throws IOException {\n    createOutputStream();\n    String header = name + \": \" + value + NEW_LINE;\n    byteArrayOutputStream.write(header.getBytes());\n  }\n\n  @Override\n  protected OutputStream createOutputStream() throws IOException {\n    if (byteArrayOutputStream == null) {\n      byteArrayOutputStream = new ByteArrayOutputStream();\n    }\n    return byteArrayOutputStream;\n  }\n\n  public byte[] toByteArray() {\n    return byteArrayOutputStream.toByteArray();\n  }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.network.v2018_08_01.implementation;\n\nimport com.microsoft.azure.management.network.v2018_08_01.VpnProfileResponse;\nimport com.microsoft.azure.arm.model.implementation.WrapperImpl;\n\nclass VpnProfileResponseImpl extends WrapperImpl<VpnProfileResponseInner> implements VpnProfileResponse {\n    private final NetworkManager manager;\n    VpnProfileResponseImpl(VpnProfileResponseInner inner, NetworkManager manager) {\n        super(inner);\n        this.manager = manager;\n    }\n\n    @Override\n    public NetworkManager manager() {\n        return this.manager;\n    }\n\n    @Override\n    public String profileUrl() {\n        return this.inner().profileUrl();\n    }\n\n}\n", " details.\n *\n * Creation date: Feb 21, 2007\n */\n\npackage vpc.core.types;\n\nimport cck.parser.AbstractToken;\nimport cck.parser.SourcePoint;\nimport cck.text.StringUtil;\nimport vpc.util.ArrayUtil;\nimport vpc.util.Cache;\n\nimport java.util.List;\n\n/**\n * The <code>VirgilTypeParam</code> class represents a type parameter and related\n * functionality with the compiler.\n * \n * @author Ben L. Titzer\n */\npublic class TypeParam {\n\n    public static final TypeParam[] NOTYPEPARAMS = new TypeParam[0];\n\n    public final String name;\n    public final SourcePoint point;\n\n    public final TypeCon typeCon;\n    public final IType type;\n\n    public TypeParam(AbstractToken tok) {\n        name = tok.image;\n        point = tok.getSourcePoint();\n        type = new IType(tok.image);\n        typeCon = new TypeCon.Singleton(type);\n    }\n\n    public static TypeParam[] toTypeParamArray(List<TypeParam> typeParams) {\n        if ( typeParams == null || typeParams.isEmpty() ) return NOTYPEPARAMS;\n        return typeParams.toArray(new TypeParam[typeParams.size()]);\n    }\n\n    public static <T extends TypeToken> String buildParameterizedName(String n, T[] et) {\n        if ( et.length > 0 ) {\n            StringBuffer buf = new StringBuffer(n);\n            buf.append('<');\n            StringUtil.commalist(et, buf);\n            buf.append('>');\n            return buf.toString();\n        }\n        return n;\n    }\n\n    public static <T extends TypeToken> String buildParameterizedName(String n, List<T> et) {\n        if (!et.isEmpty() ) {\n            StringBuffer buf = new StringBuffer(n);\n            buf.append('<');\n            StringUtil.commalist(et, buf);\n            buf.append('>');\n            return buf.toString();\n        }\n        return n;\n    }\n\n    public static class IType extends Type {\n        public boolean inMethod;\n        public int index;\n\n        public IType(String n) {\n            super(n);\n            index = -1;\n        }\n        public Type rebuild(Type[] elements) {\n            return this;\n        }\n    }\n\n    public static Type substitute(Cache<Type> cache, TypeParam[] p, Type[] t, Type expr) {\n        assert p.length == t.length;\n        if ( p.length == 0 ) return expr; // no substitution necessary\n        return ArrayUtil.substitute(cache, Type.class, toTypes(p), t, expr);\n    }\n\n    public static Type[] toTypes(TypeParam[] p) {\n        if ( p.length == 0 ) return Type.NOTYPES;\n        Type[] nt = new Type[p.length];\n        for ( int cntr = 0; cntr < nt.length; cntr++) nt[cntr] = p[cntr].type;\n        return nt;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public SourcePoint getSourcePoint() {\n        return point;\n    }\n\n    public TypeCon getTypeCon() {\n        return typeCon;\n    }\n\n    public IType getType() {\n        return type;\n    }\n\n}\n", "ncorrect behavior and will be lost if\n *     the code is regenerated.\n */\npackage com.mozu.api.contracts.commerceruntime.products;\n\nimport java.io.Serializable;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport org.joda.time.DateTime;\nimport com.mozu.api.contracts.commerceruntime.commerce.PackageMeasurements;\n\n/**\n *\tProperties of a component product in a product bundle. A product bundle can represent either a collection of multiple products sold as a single entity, or a collection of the same product sold as a package. For example, a 10-pack of socks or multiple parts and devices in a technology bundle for a computer.\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class BundledProduct implements Serializable\n{\n\t// Default Serial Version UID\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * The fully qualified name of the attribute, which is a user defined attribute identifier.\n\t */\n\tprotected String optionAttributeFQN;\n\n\tpublic String getOptionAttributeFQN() {\n\t\treturn this.optionAttributeFQN;\n\t}\n\n\tpublic void setOptionAttributeFQN(String optionAttributeFQN) {\n\t\tthis.optionAttributeFQN = optionAttributeFQN;\n\t}\n\n\t/**\n\t * Allocation ID associated with this product on this order.\n\t */\n\tprotected DateTime allocationExpiration;\n\n\tpublic DateTime getAllocationExpiration() {\n\t\treturn this.allocationExpiration;\n\t}\n\n\tpublic void setAllocationExpiration(DateTime allocationExpiration) {\n\t\tthis.allocationExpiration = allocationExpiration;\n\t}\n\n\t/**\n\t * Allocation ID associated with this product on this order.\n\t */\n\tprotected Integer allocationId;\n\n\tpublic Integer getAllocationId() {\n\t\treturn this.allocationId;\n\t}\n\n\tpublic void setAllocationId(Integer allocationId) {\n\t\tthis.allocationId = allocationId;\n\t}\n\n\t/**\n\t * The credit value of the product or bundled product. When the `goodsType `is `DigitalCredit`, this value is populated to indicate the value of the credit. This is used to create store credit in the fulfillment of gift cards.\n\t */\n\tprotected Double creditValue;\n\n\tpublic Double getCreditValue() {\n\t\treturn this.creditValue;\n\t}\n\n\tpublic void setCreditValue(Double creditValue) {\n\t\tthis.creditValue = creditValue;\n\t}\n\n\t/**\n\t * The localized description in text for the object, displayed per the locale code. For example, descriptions are used for product descriptions, attributes, and pre-authorization transaction types.\n\t */\n\tprotected String description;\n\n\tpublic String getDescription() {\n\t\treturn this.description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\t/**\n\t * Fulfillment status of the product.\n\t */\n\tprotected String fulfillmentStatus;\n\n\tpublic String getFulfillmentStatus() {\n\t\treturn this.fulfillmentStatus;\n\t}\n\n\tpublic void setFulfillmentStatus(String fulfillmentStatus) {\n\t\tthis.fulfillmentStatus = fulfillmentStatus;\n\t}\n\n\t/**\n\t * The type of goods in a bundled product. A bundled product is composed of products associated to sell together. Possible values include \u201cPhysical\u201d and \u201cDigitalCredit\u201d. This comes from the `productType `of the product. Products are defaulted to a Physical `goodsType`. Gift cards have a `goodsType `of DigitalCredit.\n\t */\n\tprotected String goodsType;\n\n\tpublic String getGoodsType() {\n\t\treturn this.goodsType;\n\t}\n\n\tpublic void setGoodsType(String goodsType) {\n\t\tthis.goodsType = goodsType;\n\t}\n\n\t/**\n\t * Indicates if the product must be shipped alone in a container. This is used for products and products within a bundle. If true, this product cannot be shipped in a package with other items and must ship in a package by itself.\n\t */\n\tprotected Boolean isPackagedStandAlone;\n\n\tpublic Boolean getIsPackagedStandAlone() {\n\t\treturn this.isPackagedStandAlone;\n\t}\n\n\tpublic void setIsPackagedStandAlone(Boolean isPackagedStandAlone) {\n\t\tthis.isPackagedStandAlone = isPackagedStandAlone;\n\t}\n\n\t/**\n\t * The display name of the source product property. For a product field it will be the display name of the field. For a product attribute it will be the Attribute Name.\n\t */\n\tprotected String name;\n\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * The value of the option attribute. These values are associated and used by product bundles and options.\n\t */\n\tprotected Object optionValue;\n\n\tpublic Object getOptionValue() {\n\t\treturn this.optionValue;\n\t}\n\n\tpublic void setOptionValue(Object optionValue) {\n\t\tthis.optionValue = optionValue;\n\t}\n\n\t/**\n\t * Merchant-created code that uniquely identifies the product such as a SKU or item number. Once created, the product code is read-only.\n\t */\n\tprotected String productCode;\n\n\tpublic String getProductCode() {\n\t\treturn this.productCode;\n\t}\n\n\tpublic void setProductCode(String productCode) {\n\t\tthis.productCode = productCode;\n\t}\n\n\t/**\n\t * Unique identifier of the product reservation associated with the component product in a product bundle or item in a cart/order. System-supplied and read only.\n\t */\n\tprotected Integer productReservationId;\n\n\tpublic Integer getProductReservationId() {\n\t\treturn this.productReservationId;\n\t}\n\n\tpublic void setProductReservationId(Integer productReservationId) {\n\t\tthis.productReservationId = productReservationId;\n\t}\n\n\t/**\n\t * The specified quantity of objects and items. This property is used for numerous object types including products, options, components within a product bundle, cart and order items, returned items, shipping line items, items in a digital product. and items associated with types and reservations.\n\t */\n\tprotected Integer quantity;\n\n\tpublic Integer getQuantity() {\n\t\treturn this.quantity;\n\t}\n\n\tpublic void setQuantity(Integer quantity) {\n\t\tthis.quantity = quantity;\n\t}\n\n\t/**\n\t * Dimensions of the packaged product.\n\t */\n\tprotected PackageMeasurements measurements;\n\n\tpublic PackageMeasurements getMeasurements() {\n\t\treturn this.measurements;\n\t}\n\n\tpublic void setMeasurements(PackageMeasurements measurements) {\n\t\tthis.measurements = measurements;\n\t}\n\n}\n", "l int CAPACITY = 1000;\n    private E[] data;\n    private int t = -1;\n    public ArrayStack() { this(CAPACITY); }\n    public ArrayStack(int capacity) {\n        data = (E[])new Object[capacity];\n    }\n    public int size() { return t + 1; }\n    public boolean isEmpty() { return t == -1; }\n    public void push(E e) throws IllegalStateException {\n        if (size() == data.length) throw new IllegalStateException(\"Stack is full\");\n        data[++t] = e;\n    }\n    public E top() {\n        if (isEmpty()) return null;\n        return data[t];\n    }\n    public E pop() {\n        if (isEmpty()) return null;\n        E answer = data[t];\n        data[t] = null;\n        t--;\n        return answer;\n    }\n}\n", "{\n    private final View layout;\n\n    public Screen(View layout)\n    {\n        this.layout = layout;\n    }\n\n    public void display()\n    {\n        this.layout.setVisibility(View.VISIBLE);\n    }\n\n    public void hide()\n    {\n        this.layout.setVisibility(View.GONE);\n    }\n}", "face IStatistics {\r\n    void putParam(StatisticKeys key, String value);\r\n    void putParam(StatisticKeys key, int value);\r\n    void putParam(StatisticKeys key, long value);\r\n\r\n    boolean contains(StatisticKeys key);\r\n\r\n    String getStrValue(StatisticKeys key);\r\n    int getIntValue(StatisticKeys key);\r\n    long getLongValue(StatisticKeys key);\r\n\r\n    Map<StatisticKeys, String> toMap();\r\n}\r\n", "sic.GuiAirshipMusicPg3;\nimport com.viesis.viescraft.common.entity.airshipcolors.EntityAirshipBaseVC;\nimport com.viesis.viescraft.network.packet.MessageBase;\n\nimport io.netty.buffer.ByteBuf;\nimport net.minecraft.entity.player.EntityPlayer;\n\npublic class MessageGuiSongHelperPage3 extends MessageBase<MessageGuiSongHelperPage3> {\n\t\n\tprivate int metaSong;\n\t\n\t@Override\n\tpublic void fromBytes(ByteBuf buf) \n\t{\n\t\tmetaSong = buf.readInt();\n\t}\n\t\n\t@Override\n\tpublic void toBytes(ByteBuf buf) \n\t{\n\t\tbuf.writeInt(GuiAirshipMusicPg3.metaInfo);\n\t}\n\t\n\t@Override\n\tpublic void handleClientSide(MessageGuiSongHelperPage3 message, EntityPlayer player) \n\t{\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void handleServerSide(MessageGuiSongHelperPage3 message, EntityPlayer player) \n\t{\n\t\tEntityAirshipBaseVC airship = (EntityAirshipBaseVC) player.getRidingEntity();\n\t\tairship.jukeboxSelectedSong = message.metaSong;\n\t}\n}\n", "mework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\n@Controller\r\n@RequestMapping(\"/deploy\")\r\npublic class DeployController {\r\n\r\n\tpublic DeployController() {\r\n\t\t// TODO Auto-generated constructor stub\r\n\t}\r\n\t\r\n\t@RequestMapping(\"/config\")\r\n\tpublic ModelAndView config() {\r\n\r\n\t\treturn new ModelAndView(\"deploy/config\");\r\n\r\n\t}\r\n\t\r\n\t@RequestMapping(\"/ant\")\r\n\tpublic ModelAndView ant() {\r\n\t\t\r\n\t\treturn new ModelAndView(\"deploy/ant\");\r\n\r\n\t}\r\n\t\r\n\t@RequestMapping(\"/manual\")\r\n\tpublic ModelAndView manual() {\r\n\t\t\r\n\t\treturn new ModelAndView(\"deploy/manual\");\r\n\r\n\t}\r\n}\r\n", "m, libre.fm etc).\n *\n * @author William Osler\n */\npublic class FMUser {\n    /*\n     * Regexes for validation outside this class\n     */\n    public static final String userRegex = \"^[a-zA-Z0-9][a-zA-Z0-9_-]{1,14}[a-zA-z0-9]$\";\n    public static final String domainRegex = \"^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?.)+[a-zA-Z]{2,6}$\";\n\n    /*\n     * The user's service username\n     */\n    private String username = \"\";\n\n    /*\n     * The domain name. For Last.fm, this is ws.audioscrobbler.com.\n     */\n    private String domain = \"\";\n\n    /*\n     * The IRC user's nick.\n     */\n    private String nick;\n\n    /*\n     * The IRC channel this user is broadcasting to, since this is a multi-channel enabled bot.\n     */\n    private String channel = \"\";\n\n    /*\n     * The last song the user was listening to.\n     */\n    private String lastListen = \"\";\n\n    /*\n     * Overrides\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        FMUser fmUser = (FMUser) o;\n\n        if (!channel.equals(fmUser.channel)) return false;\n        if (!domain.equals(fmUser.domain)) return false;\n        if (!username.equals(fmUser.username)) return false;\n        if (!nick.equals(fmUser.nick)) return false;\n\n        /*\n         * We don't consider the last listen for equality, since we don't have that info when we need to remove\n         * something from a collection which works on equality.\n         */\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return username.hashCode() ^ domain.hashCode() ^ nick.hashCode() ^ channel.hashCode() ^ lastListen.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return username + \"@\" + domain + \" registered to \" + nick + \" in \" + channel + \" listened to \" + lastListen;\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param username The FM service username\n     * @param domain The domain name where the account can be found\n     * @param channel\n     */\n    public FMUser (String username, String domain, String nick, String channel) {\n        this.username = username;\n\n        if (domain.equals(\"last.fm\")) {\n            this.domain = \"ws.audioscrobbler.com\";\n        } else {\n            this.domain = domain;\n        }\n\n        this.nick = nick;\n        this.channel = channel;\n    }\n\n    /**\n     * Constructor using a comma seperated string.\n     *\n     * @param data A comma separated string containing the username, domain, channel, nick,\n     *             and (optional) last listen (in that order).\n     */\n    public FMUser (String data) {\n        String[] strArr = data.split(\",\");\n\n        this.username = strArr[0];\n\n        if (strArr[1].equals(\"last.fm\")) {\n            this.domain = \"ws.audioscrobbler.com\";\n        } else {\n            this.domain = strArr[1];\n        }\n\n        this.nick = strArr[2];\n        this.channel = strArr[3];\n\n        // Check for a lastListen\n        if (strArr.length > 4) {\n            this.lastListen = strArr[4];\n        }\n    }\n\n    /**\n     * The FM service username\n     *\n     * @return username\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * The domain name where the account can be found\n     *\n     * @return domain\n     */\n    public String getDomain() {\n        return domain;\n    }\n\n    /**\n     * The IRC channel that this user will broadcast to\n     *\n     * @return channel\n     */\n    public String getChannel() {\n        return channel;\n    }\n\n    /**\n     * The IRC nick of the user\n     *\n     * @return nick\n     */\n    public String getNick() {\n        return nick;\n    }\n\n    /**\n     * The data of the track the user last listened to, mbid if from last.fm, or a combination of metadata otherwise.\n     *\n     * @return last listened info\n     */\n    public String getLastListen() {\n        return lastListen;\n    }\n\n    /**\n     * Sets the data of the track the user last listeend to.\n     *\n     * @param lastListen last listened info\n     */\n    public void setLastListen(String lastListen) {\n        this.lastListen = lastListen;\n    }\n\n    /**\n     * Returns a string of user data suitable to be written to a CSV. The output of this method is compatible with\n     * the String constructor for this object.\n     *\n     * @return a comma separated string of the fields of this object\n     */\n    public String toFileString() {\n        String result = username + \",\" + domain + \",\" + nick + \",\" + channel;\n\n        if (!lastListen.equals(\"\")) {\n            result += \",\" + lastListen;\n        }\n\n        return result;\n    }\n\n}\n", "g.apache.logging.log4j.Logger;\n\npublic class FooService {\n    private static final Logger log =\n            LogManager.getLogger(FooService.class);\n\n    public String getFooById(Long id) {\n        String myFoo = null;\n        if (id != null) {\n            myFoo = \"myFoo!\";\n        } else {\n            log.error(\"id cannot be null!\");\n        }\n\n        return myFoo;\n    }\n\n}\n", "mport com.rarchives.ripme.utils.Http;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RedgifsRipper extends AbstractHTMLRipper {\n\n    private static final String HOST = \"redgifs.com\";\n    private static final String HOST_2 = \"gifdeliverynetwork.com\";\n    String username = \"\";\n    String cursor = \"\";\n    String count = \"100\";\n\n    String searchText = \"\";\n    int searchCount = 150;\n    int searchStart = 0;\n\n    public RedgifsRipper(URL url) throws IOException {\n        super(new URL(url.toExternalForm().replace(\"thumbs.\", \"\")));\n    }\n\n    @Override\n    public String getDomain() { return \"redgifs.com\"; }\n\n    @Override\n    public String getHost() {\n        return \"redgifs\";\n    }\n\n    @Override\n    public boolean canRip(URL url) {\n        return url.getHost().endsWith(HOST) || url.getHost().endsWith(HOST_2);\n    }\n\n    @Override\n    public URL sanitizeURL(URL url) throws MalformedURLException {\n        String sUrl = url.toExternalForm();\n        sUrl = sUrl.replace(\"/gifs/detail\", \"\");\n        sUrl = sUrl.replace(\"/amp\", \"\");\n        sUrl = sUrl.replace(\"gifdeliverynetwork.com\", \"redgifs.com/watch\");\n        return new URL(sUrl);\n    }\n\n    public Matcher isProfile() {\n        Pattern p = Pattern.compile(\"^https?://[wm.]*redgifs\\\\.com/users/([a-zA-Z0-9_-]+).*$\");\n        return p.matcher(url.toExternalForm());\n    }\n\n    public Matcher isSearch() {\n        Pattern p = Pattern.compile(\"^https?://[wm.]*redgifs\\\\.com/gifs/browse/([a-zA-Z0-9_-]+).*$\");\n        return p.matcher(url.toExternalForm());\n    }\n\n    public Matcher isSingleton() {\n        Pattern p = Pattern.compile(\"^https?://[wm.]*redgifs\\\\.com/watch/([a-zA-Z0-9_-]+).*$\");\n        return p.matcher(url.toExternalForm());\n    }\n\n    @Override\n    public Document getFirstPage() throws IOException {\n        if (!isProfile().matches() && !isSearch().matches()) {\n            return Http.url(url).get();\n        } else if (isSearch().matches()) {\n            searchText = getGID(url).replace(\"-\", \" \");\n            return Http.url(\n                    new URL(\"https://napi.redgifs.com/v1/gfycats/search?search_text=\" + searchText + \"&count=\" + searchCount + \"&start=\" + searchStart*searchCount)).ignoreContentType().get();\n        } else {\n            username = getGID(url);\n            return Http.url(new URL(\"https://napi.redgifs.com/v1/users/\" +  username + \"/gfycats?count=\" + count))\n                       .ignoreContentType().get();\n        }\n    }\n\n    @Override\n    public void downloadURL(URL url, int index) {\n        addURLToDownload(url, getPrefix(index));\n    }\n\n    @Override\n    public String getGID(URL url) throws MalformedURLException {\n\n        Matcher m = isProfile();\n        if (m.matches()) {\n            return m.group(1);\n        }\n        m = isSearch();\n        if (m.matches()) {\n            return m.group(1);\n        }\n        m = isSingleton();\n        if (m.matches()) {\n            return m.group(1).split(\"-\")[0];\n        }\n        throw new MalformedURLException(\n                \"Expected redgifs.com format: \"\n                        + \"redgifs.com/id or \"\n                        + \"thumbs.redgifs.com/id.gif\"\n                        + \" Got: \" + url);\n    }\n\n    private String stripHTMLTags(String t) {\n        t = t.replaceAll(\"<html>\\n\" +\n                                 \" <head></head>\\n\" +\n                                 \" <body>\", \"\");\n        t = t.replaceAll(\"</body>\\n\" +\n                                 \"</html>\", \"\");\n        t = t.replaceAll(\"\\n\", \"\");\n        t = t.replaceAll(\"=\\\"\\\"\", \"\");\n        return t;\n    }\n\n    @Override\n    public Document getNextPage(Document doc) throws IOException {\n        if (isSearch().matches()) {\n            Document d = Http.url(\n                    new URL(\"https://napi.redgifs.com/v1/gfycats/search?search_text=\" + searchText\n                                    + \"&count=\" + searchCount + \"&start=\" + searchCount*++searchStart))\n                       .ignoreContentType().get();\n            return (hasURLs(d).isEmpty()) ? null : d;\n        } else {\n            if (cursor.equals(\"\")) {\n                return null;\n            } else {\n                Document d =  Http.url(new URL(\"https://napi.redgifs.com/v1/users/\" +  username + \"/gfycats?count=\" + count + \"&cursor=\" + cursor)).ignoreContentType().get();\n                return (hasURLs(d).isEmpty()) ? null : d;\n            }\n        }\n    }\n\n    @Override\n    public List<String> getURLsFromPage(Document doc) {\n        List<String> result = new ArrayList<>();\n        if (isProfile().matches() || isSearch().matches()) {\n            result = hasURLs(doc);\n        } else {\n            Elements videos = doc.select(\"script\");\n            for (Element el : videos) {\n                String json = el.html();\n                if (json.startsWith(\"{\")) {\n                    JSONObject page = new JSONObject(json);\n                    result.add(page.getJSONObject(\"video\").getString(\"contentUrl\"));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Helper method for retrieving URLs.\n     * @param doc Document of the URL page to look through\n     * @return List of URLs to download\n     */\n    public List<String> hasURLs(Document doc) {\n        List<String> result = new ArrayList<>();\n        JSONObject page = new JSONObject(stripHTMLTags(doc.html()));\n        JSONArray content = page.getJSONArray(\"gfycats\");\n        for (int i = 0; i < content.length(); i++) {\n            result.add(content.getJSONObject(i).getString(\"mp4Url\"));\n        }\n        cursor = page.getString(\"cursor\");\n        return result;\n    }\n\n    /**\n     * Helper method for retrieving video URLs.\n     * @param url URL to gfycat page\n     * @return URL to video\n     * @throws IOException\n     */\n    public static String getVideoURL(URL url) throws IOException {\n        LOGGER.info(\"Retrieving \" + url.toExternalForm());\n\n        //Sanitize the URL first\n        url = new URL(url.toExternalForm().replace(\"/gifs/detail\", \"\"));\n\n        Document doc = Http.url(url).get();\n        Elements videos = doc.select(\"script\");\n        for (Element el : videos) {\n            String json = el.html();\n            if (json.startsWith(\"{\")) {\n                JSONObject page = new JSONObject(json);\n                return page.getJSONObject(\"video\").getString(\"contentUrl\");\n            }\n        }\n        throw new IOException();\n    }\n\n}\n", "t javax.swing.JPanel;\n\nimport org.jivesoftware.smack.Chat;\n\nimport com.thang.tools.model.ChatInfo;\n\n/**\n * \u663e\u793a\u804a\u5929\u5185\u5bb9\n * @author gandilong\n *\n */\npublic class ChatPanel extends JPanel {\n\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate ShowPanel show=null;\n\tprivate InputPanel input=null; \n\t\n\tprivate ChatInfo chatInfo=null;\n\t\n\tpublic ChatPanel(ChatInfo info){\n\t\tthis.chatInfo=info;\n\t    init();\t\n\t}\n\t\n\tprivate void init(){\n\t\ttry {\n\t\t\tsetLayout(new BorderLayout());\n\t\t\tsetBorder(BorderFactory.createRaisedBevelBorder());\n\t\t\tsetSize(400, 470);\n\t\t\tinput=new InputPanel(this);\n\t\t\tshow=new ShowPanel(this);\n\t\t\tadd(input,BorderLayout.SOUTH);\n\t\t\tadd(show,BorderLayout.CENTER);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void show(String content){\n\t\tshow.addText(content);\n\t}\n\t\n\tpublic void setChat(Chat chat){\n\t\tinput.setChat(chat);\n\t}\n\t\n\tpublic ChatInfo getChatInfo(){\n\t\treturn chatInfo;\n\t}\n\n}\n", "loud.BaseTestClass;\nimport org.squirrelframework.cloud.resource.database.BoneCPDataSourceConfig;\nimport org.squirrelframework.cloud.utils.CloudConfigCommon;\nimport org.squirrelframework.cloud.utils.InetAddressHelper;\n\nimport javax.validation.Validation;\nimport javax.validation.Validator;\nimport javax.validation.ValidatorFactory;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\n/**\n * Created by kailianghe on 11/9/15.\n */\npublic class SimpleResourceConfigFactoryBeanTest extends BaseTestClass {\n\n    @Override\n    protected void prepare() throws Exception {\n        String generalDatabaseConfig = \"{\\n\" +\n                \"    \\\"__type__\\\" : \\\"org.squirrelframework.cloud.resource.database.BoneCPDataSourceConfig\\\",\\n\" +\n                \"    \\\"driverClassName\\\" : \\\"com.mysql.jdbc.Driver\\\",\\n\" +\n                \"    \\\"idleMaxAgeInMinutes\\\" : 240,\\n\" +\n                \"    \\\"idleConnectionTestPeriodInMinutes\\\" : 60,\\n\" +\n                \"    \\\"maxConnectionsPerPartition\\\" : 10,\\n\" +\n                \"    \\\"minConnectionsPerPartition\\\" : 1,\\n\" +\n                \"    \\\"partitionCount\\\" : 2,\\n\" +\n                \"    \\\"acquireIncrement\\\" : 5,\\n\" +\n                \"    \\\"statementsCacheSize\\\" : 100\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database\", generalDatabaseConfig.getBytes());\n\n        String bcpBaseConfig = \"{\\n\" +\n                \"    \\\"userName\\\" : \\\"root\\\",\\n\" +\n                \"    \\\"password\\\" : \\\"1111\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp\", bcpBaseConfig.getBytes());\n\n        String devConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/dev\", devConfig.getBytes());\n\n        String prodConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/prod_bcp01?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/prod\", prodConfig.getBytes());\n\n        String hheConfig = \"{\\n\" +\n                \"    \\\"userName\\\" : \\\"hhe\\\",\\n\" +\n                \"    \\\"password\\\" : \\\"1234\\\",\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/hhe_bcp01?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/hhe\", hheConfig.getBytes());\n\n        String errPartitionCount = \"{\\\"partitionCount\\\" : 0}\";\n        zkConfigClient.create().forPath(\"/database/bcp/errPartitionCount\", errPartitionCount.getBytes());\n    }\n\n    private void basicVerifyResult(BoneCPDataSourceConfig result, boolean verifyUserAndPassword) {\n        assertThat(result, notNullValue());\n        assertThat(result.getDriverClassName(), is(\"com.mysql.jdbc.Driver\"));\n        assertThat(result.getIdleMaxAgeInMinutes(), is(240));\n        assertThat(result.getIdleConnectionTestPeriodInMinutes(), is(60));\n        assertThat(result.getMaxConnectionsPerPartition(), is(10));\n        assertThat(result.getMinConnectionsPerPartition(), is(1));\n        assertThat(result.getPartitionCount(), is(2));\n        assertThat(result.getAcquireIncrement(), is(5));\n        assertThat(result.getStatementsCacheSize(), is(100));\n\n        if(verifyUserAndPassword) {\n            assertThat(result.getUserName(), is(\"root\"));\n            assertThat(result.getPassword(), is(\"1111\"));\n        }\n    }\n\n    private BoneCPDataSourceConfig createBean() throws Exception {\n        SimpleResourceConfigFactoryBean<BoneCPDataSourceConfig> factoryBean = new SimpleResourceConfigFactoryBean<>();\n        factoryBean.setClient(zkRootClient);\n        factoryBean.setPath(\"/database/bcp\");\n        factoryBean.setResourceType(BoneCPDataSourceConfig.class);\n        factoryBean.setAutoReload(true);\n\n        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n        Validator validator = factory.getValidator();\n        factoryBean.setValidator(validator);\n\n        factoryBean.afterPropertiesSet();\n        return factoryBean.getObject();\n    }\n\n    @Test\n    public void testCreateDataSourceConfigWithDefaultProfile() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test\n    public void testCreateDataSourceConfigWithProdProfile() throws Exception {\n        System.setProperty(CloudConfigCommon.CONFIG_PROFILE_KEY, \"prod\");\n\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/prod_bcp01?useUnicode=true\"));\n    }\n\n    @Test\n    public void testCreateDataSourceConfigWithMultipleProfiles() throws Exception {\n        System.setProperty(CloudConfigCommon.CONFIG_PROFILE_KEY, \"prod, hhe\");\n\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, false);\n        assertThat(result.getUserName(), is(\"hhe\"));\n        assertThat(result.getPassword(), is(\"1234\"));\n        assertThat(result.getJdbcUrl(),  is(\"jdbc:mysql://127.0.0.1:3306/hhe_bcp01?useUnicode=true\"));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCreateDataSourceConfigWithValidationFailure() throws Exception {\n        System.setProperty(CloudConfigCommon.CONFIG_PROFILE_KEY, \"errPartitionCount\");\n        createBean();\n    }\n\n    @Test(timeout = 10000L)\n    public void testCreateDataSourceConfigWithReload() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        final AtomicBoolean reloadInvoked = new AtomicBoolean(false);\n        final CountDownLatch latch = new CountDownLatch(1);\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                reloadInvoked.set(true);\n                latch.countDown();\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.setData().forPath(\"/database/bcp/dev\", newDevConfig.getBytes());\n\n        latch.await();\n        assertThat(reloadInvoked.get(), is(Boolean.TRUE));\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testCreateDataSourceConfigWithNoReload() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                throw new RuntimeException(\"Should not be invoked.\");\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        // change prod profile should not affect dev profile\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/prod_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.setData().forPath(\"/database/bcp/prod\", newDevConfig.getBytes());\n\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test\n    public void testMachineSpecificDataSourceConfig() throws Exception {\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/&\"+ InetAddressHelper.localIpAddress.get(0)+\"@dev\", newDevConfig.getBytes());\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testMachineSpecificDataSourceConfigWithReloadAndRemove() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        final AtomicBoolean reloadInvoked = new AtomicBoolean(false);\n        final AtomicBoolean removeInvoked = new AtomicBoolean(false);\n        final CountDownLatch reLoadLatch = new CountDownLatch(1);\n        final CountDownLatch removeLatch = new CountDownLatch(1);\n\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                if(reLoadLatch.getCount()==1) {\n                    reloadInvoked.set(true);\n                    reLoadLatch.countDown();\n                } else if(reLoadLatch.getCount()==0) {\n                    removeInvoked.set(true);\n                    removeLatch.countDown();\n                }\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        String newNodeName = \"/database/bcp/&\"+ InetAddressHelper.localIpAddress.get(0)+\":255@dev\";\n        zkConfigClient.create().forPath(newNodeName, newDevConfig.getBytes());\n\n        reLoadLatch.await();\n        assertThat(reloadInvoked.get(), is(Boolean.TRUE));\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\"));\n\n        zkConfigClient.delete().deletingChildrenIfNeeded().forPath(newNodeName);\n        removeLatch.await();\n        assertThat(removeInvoked.get(), is(Boolean.TRUE));\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testMachineSpecificDataSourceConfigWithNoReload() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                throw new RuntimeException(\"Should not be invoked.\");\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/&1.1.1.1:255@dev\", newDevConfig.getBytes());\n\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testMachineSpecificDataSourceConfigWithNoReload2() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                throw new RuntimeException(\"Should not be invoked.\");\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/&\"+InetAddressHelper.localIpAddress.get(0)+\"@prod\", newDevConfig.getBytes());\n\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n}\n", "\r\nimport cs2ts6.client.ChatPanel;\r\nimport cs2ts6.client.DrawingPanel.DrawType;\r\nimport cs2ts6.packets.*;\r\n\r\n/**\r\n * \r\n * @author Stephen\r\n *\r\n */\r\npublic class Server {\r\n\t\r\n\tprivate ArrayList<Packet> packets; //FIFO queue of packets awaiting broadcast\r\n\tprivate ChatPanel logWindow; // Used if in Thread mode, to write to the chat window\r\n\t\r\n\tServer(ChatPanel cp) {\r\n\t\tpackets = new ArrayList<Packet>();\r\n\t\tpackets.add(new PointPacket(1, 1, 1, 1, Color.WHITE, 1, DrawType.FULL_CLEAR));\r\n\t\tlogWindow = cp;\r\n\t}\r\n\t/**\r\n\t * USed to get a packet top broadcast (Used by the ServerUDPThread)\r\n\t * @return The packet to be transmitted\r\n\t */\r\n\tpublic Packet getForBroadcast() {\r\n\t\tPacket bcast;\r\n\t\t//Keep taking first element while element exists\r\n\t\tif (packets.size() > 0) {\r\n\t\t\tbcast = packets.get(0);\r\n\t\t\tpackets.remove(0);\r\n\t\t\treturn bcast; // Return a packet\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// USed if no packets on queue to keep broadcast alive - used for client auto connect\r\n\t\t\ttry {\r\n\t\t\t\tThread.sleep(10); //pause for 10ms\r\n\t\t\t} catch (InterruptedException e) {}\r\n\t\t\treturn new ChatPacket(\"KEEPALIVE\",\"\"); // Ensures clients can connect\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Used to write logging messages, either to chat windows or to cli server\r\n\t * @param message\r\n\t */\r\n\tpublic void writeServerMessage(String message) {\r\n\t\tif(logWindow == null) { //Am in CLI mode - direct and not thread from GUI\r\n\t\t\tSystem.out.println(message);\r\n\t\t} else {\r\n\t\t\tlogWindow.drawMessage(new ChatPacket(\"SERVER\",message));\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param pkt Packet to be added to the packet queue, not sent immediately.\r\n\t */\r\n\tpublic void addToBroadcast(Packet pkt) {\r\n\t\tpackets.add(pkt);\r\n\t}\r\n\t/**\r\n\t * Sets up a server\r\n\t * @param args\r\n\t * @throws IOException\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException{\r\n\t\tSystem.out.println(\"Launching Server\");\r\n\t\tServer srv = new Server(null); // Pass null as log window, so will use System.out\r\n\t\tnew CollectorServer(srv).start(); //starts receives from client - to recieve packets\r\n\t\tnew ServerUDPThread(srv).start(); //starts broadcast thread -  to send packets\r\n\t}\r\n}\r\n", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.data.type;\n\nimport org.spongepowered.api.data.type.MatterType;\n\npublic final class SpongeMatterType implements MatterType {\n}\n", "kage com.azure.core.util.serializer;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.IOException;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link DateTimeDeserializer}.\n */\npublic class DateTimeDeserializerTests {\n    @ParameterizedTest\n    @MethodSource(\"deserializeOffsetDateTimeSupplier\")\n    public void deserializeJson(String offsetDateTimeString, OffsetDateTime expected) throws IOException {\n        JsonParser parser = mock(JsonParser.class);\n        when(parser.getValueAsString()).thenReturn(offsetDateTimeString);\n\n        assertEquals(expected, new DateTimeDeserializer().deserialize(parser, null));\n    }\n\n    private static Stream<Arguments> deserializeOffsetDateTimeSupplier() {\n        OffsetDateTime minValue = OffsetDateTime.of(1, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);\n        OffsetDateTime unixEpoch = OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);\n\n        return Stream.of(\n            Arguments.of(\"0001-01-01T00:00:00\", minValue),\n            Arguments.of(\"0001-01-01T00:00:00Z\", minValue),\n            Arguments.of(\"1970-01-01T00:00:00\", unixEpoch),\n            Arguments.of(\"1970-01-01T00:00:00Z\", unixEpoch)\n        );\n    }\n}\n", "GsonUtil.Constants.PROP_ID;\nimport static com.github.messenger4j.internal.gson.GsonUtil.Constants.PROP_RECIPIENT;\nimport static com.github.messenger4j.internal.gson.GsonUtil.Constants.PROP_SENDER;\nimport static com.github.messenger4j.internal.gson.GsonUtil.Constants.PROP_TIMESTAMP;\nimport static com.github.messenger4j.internal.gson.GsonUtil.getPropertyAsInstant;\nimport static com.github.messenger4j.internal.gson.GsonUtil.getPropertyAsString;\n\nimport com.github.messenger4j.internal.Lists;\nimport com.github.messenger4j.webhook.Event;\nimport com.github.messenger4j.webhook.event.FallbackEvent;\nimport com.google.gson.JsonObject;\nimport java.time.Instant;\nimport java.util.List;\n\n/**\n * @author Max Grabenhorst\n * @since 1.0.0\n */\npublic final class EventFactory {\n\n  private static final List<BaseEventFactory> FACTORIES =\n      Lists.immutableList(\n          new TextMessageEventFactory(),\n          new AttachmentMessageEventFactory(),\n          new QuickReplyMessageEventFactory(),\n          new PostbackEventFactory(),\n          new ReferralEventFactory(),\n          new OptInEventFactory(),\n          new MessageEchoEventFactory(),\n          new MessageDeliveredEventFactory(),\n          new MessageReadEventFactory(),\n          new AccountLinkingEventFactory(),\n          new InstantGameEventFactory());\n\n  private EventFactory() {}\n\n  public static Event createEvent(JsonObject messagingEvent) {\n    for (BaseEventFactory factory : FACTORIES) {\n      if (factory.isResponsible(messagingEvent)) {\n        return new Event(factory.createEventFromJson(messagingEvent));\n      }\n    }\n    final String senderId =\n        getPropertyAsString(messagingEvent, PROP_SENDER, PROP_ID)\n            .orElseThrow(IllegalArgumentException::new);\n    final String recipientId =\n        getPropertyAsString(messagingEvent, PROP_RECIPIENT, PROP_ID)\n            .orElseThrow(IllegalArgumentException::new);\n    final Instant timestamp =\n        getPropertyAsInstant(messagingEvent, PROP_TIMESTAMP).orElse(Instant.now());\n    return new Event(new FallbackEvent(senderId, recipientId, timestamp));\n  }\n}\n", "org.innovateuk.ifs.user.resource.ProfileRole;\nimport org.innovateuk.ifs.user.resource.RoleProfileStatusResource;\nimport org.junit.Test;\nimport org.springframework.core.ParameterizedTypeReference;\n\nimport java.util.List;\n\nimport static java.lang.String.format;\nimport static org.innovateuk.ifs.user.builder.RoleProfileStatusResourceBuilder.newRoleProfileStatusResource;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n\npublic class RoleProfileStatusRestServiceTest extends BaseRestServiceUnitTest<RoleProfileStatusRestServiceImpl> {\n\n    private String restUrl = \"/user/%d/role-profile-status\";\n\n    @Override\n    protected RoleProfileStatusRestServiceImpl registerRestServiceUnderTest() {\n        return new RoleProfileStatusRestServiceImpl();\n    }\n\n    @Test\n    public void updateUserStatus() {\n        long userId = 1L;\n        RoleProfileStatusResource resource = new RoleProfileStatusResource();\n\n        setupPutWithRestResultExpectations(format(restUrl, userId), resource);\n\n        assertTrue(service.updateUserStatus(userId, resource).isSuccess());\n    }\n\n    @Test\n    public void findByUserId() {\n        long userId = 1L;\n        List<RoleProfileStatusResource> resources = newRoleProfileStatusResource().build(1);\n\n        setupGetWithRestResultExpectations(format(restUrl, userId), new ParameterizedTypeReference<List<RoleProfileStatusResource>>() {}, resources);\n\n        assertEquals(resources, service.findByUserId(userId).getSuccess());\n    }\n\n    @Test\n    public void findByUserIdAndProfileRole() {\n        long userId = 1L;\n        ProfileRole role = ProfileRole.ASSESSOR;\n        RoleProfileStatusResource resource = newRoleProfileStatusResource().build();\n\n        setupGetWithRestResultExpectations(format(restUrl, userId) + \"/\" + role.name(), RoleProfileStatusResource.class, resource);\n\n        assertEquals(resource, service.findByUserIdAndProfileRole(userId, role).getSuccess());\n    }\n}", "lic interface HasPattern {\n\n\t/** Get pattern from constraint. */\n\tString getPattern();\n\n}\n", "mport android.graphics.Paint;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n/**\n * Description\n *\n * @author liupeng502\n * @data 2017/9/7\n */\n\npublic class ListIndicator4 extends View {\n\n    private Paint mPaint;\n    private String[] text={\"\u6982\u51b5\",\"\u75c5\u56e0\",\"\u68c0\u67e5\",\"\u68c0\u67e5\",\"\u4e34\u5e8a\",\"\u8868\u73b0\",\"\u89e3\u51b3\u529e\u6cd5\",\"\u6ce8\u610f\"};\n    private int measuredWidth;\n    private int sectionHeight;\n    private int measuredHeight;\n    private float downY;\n    private OnTouchListner mTouchListner;\n    private int selectedPosition=0;\n\n    public ListIndicator4(Context context) {\n        this(context,null);\n    }\n\n    public ListIndicator4(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs,0);\n    }\n\n    public ListIndicator4(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(getResources().getColor(R.color.color_353535));\n        mPaint.setTextSize(60);\n        mPaint.setTextAlign(Paint.Align.CENTER);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        measuredWidth = getMeasuredWidth();\n        measuredHeight = getMeasuredHeight();\n        sectionHeight = measuredHeight / text.length;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        Paint.FontMetricsInt fm = mPaint.getFontMetricsInt();\n        int ascent = fm.ascent;\n\n        for (int i = 0; i < text.length; i++) {\n            canvas.drawLine(0,sectionHeight*i,measuredWidth,sectionHeight*i,mPaint);\n            //int textY = sectionHeight / 2 + i * sectionHeight - ascent/2;\n            int textY = (sectionHeight -ascent) / 2 + i * sectionHeight;\n            if (selectedPosition == i) {\n                mPaint.setColor(getResources().getColor(R.color.color_ff6602));\n            }else{\n                mPaint.setColor(getResources().getColor(R.color.color_353535));\n            }\n            canvas.drawText(text[i],measuredWidth/2,textY,mPaint);\n\n        }\n        canvas.drawLine(0,measuredHeight,measuredWidth,measuredHeight,mPaint);\n    }\n\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        switch(event.getAction()){\n            case MotionEvent.ACTION_DOWN:\n                downY = event.getY();\n                int position = (int) (downY / sectionHeight);\n                selectedPosition = position;\n                Log.d(\"tag\", \"position=\"+position);\n                if (mTouchListner != null) {\n                    mTouchListner.onTouch(position);\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                float moveY = event.getY();\n                int movePosition = (int) (moveY / sectionHeight);\n                selectedPosition=movePosition;\n                Log.d(\"tag\", \"position=\"+movePosition);\n                if (mTouchListner != null) {\n                    mTouchListner.onTouch(movePosition);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n\n                break;\n            default:\n        }\n        invalidate();\n        return true;\n    }\n\n    public void setSelectedPosition(int position){\n        selectedPosition=position;\n        invalidate();\n    }\n\n    interface OnTouchListner{\n        void onTouch(int position);\n    }\n    public void setOnTouchListner(OnTouchListner touchListner){\n        mTouchListner = touchListner;\n    }\n}\n", ".crcs.ectester.data.EC_Store;\n\nimport java.security.*;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.AlgorithmParameters;\nimport java.security.spec.ECGenParameterSpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\n\n/**\n * @author Jan Jancar johny@neuromancer.sk\n */\npublic abstract class NativeKeyPairGeneratorSpi extends KeyPairGeneratorSpi {\n    private int keysize;\n    private SecureRandom random;\n    private AlgorithmParameterSpec params;\n    private boolean useKeysize;\n    private boolean useParams;\n\n    public static final int DEFAULT_KEYSIZE = 256;\n\n    @Override\n    public void initialize(int keysize, SecureRandom random) {\n        if (!keysizeSupported(keysize)) {\n            throw new InvalidParameterException(\"Keysize \" + keysize + \" not supported.\");\n        }\n        this.keysize = keysize;\n        this.random = random;\n        this.useKeysize = true;\n        this.useParams = false;\n    }\n\n    @Override\n    public void initialize(AlgorithmParameterSpec params, SecureRandom random) throws InvalidAlgorithmParameterException {\n        if (!paramsSupported(params)) {\n            throw new InvalidAlgorithmParameterException(\"Not supported.\");\n        }\n        this.params = params;\n        this.random = random;\n        this.useParams = true;\n        this.useKeysize = false;\n    }\n\n    @Override\n    public KeyPair generateKeyPair() {\n        if (!useKeysize && !useParams) {\n            if (keysizeSupported(DEFAULT_KEYSIZE)) {\n                initialize(DEFAULT_KEYSIZE, new SecureRandom());\n            }\n        }\n\n        if (useKeysize) {\n            return generate(keysize, random);\n        } else if (useParams) {\n            return generate(params, random);\n        } else {\n            throw new IllegalStateException(\"Uninitialized KeyPair.\");\n        }\n    }\n\n    abstract boolean keysizeSupported(int keysize);\n\n    abstract boolean paramsSupported(AlgorithmParameterSpec params);\n\n    abstract KeyPair generate(int keysize, SecureRandom random);\n\n    abstract KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n\n\n    public static class TomCrypt extends NativeKeyPairGeneratorSpi {\n\n        public TomCrypt() {\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static abstract class Botan extends NativeKeyPairGeneratorSpi {\n        private String type;\n\n        public Botan(String type) {\n            this.type = type;\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class BotanECDH extends Botan {\n\n        public BotanECDH() {\n            super(\"ECDH\");\n        }\n    }\n\n    public static class BotanECDSA extends Botan {\n\n        public BotanECDSA() {\n            super(\"ECDSA\");\n        }\n    }\n\n    public static class BotanECKCDSA extends Botan {\n\n        public BotanECKCDSA() {\n            super(\"ECKCDSA\");\n        }\n    }\n\n    public static class BotanECGDSA extends Botan {\n\n        public BotanECGDSA() {\n            super(\"ECGDSA\");\n        }\n    }\n\n    public static abstract class Cryptopp extends NativeKeyPairGeneratorSpi {\n        private String type;\n\n        public Cryptopp(String type) {\n            this.type = type;\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class CryptoppECDH extends Cryptopp {\n\n        public CryptoppECDH() {\n            super(\"ECDH\");\n        }\n    }\n\n    public static class CryptoppECDSA extends Cryptopp {\n\n        public CryptoppECDSA() {\n            super(\"ECDSA\");\n        }\n    }\n\n    public static class Openssl extends NativeKeyPairGeneratorSpi {\n        public Openssl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Boringssl extends NativeKeyPairGeneratorSpi {\n        public Boringssl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Gcrypt extends NativeKeyPairGeneratorSpi {\n\n        public Gcrypt() {\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static abstract class Mscng extends NativeKeyPairGeneratorSpi {\n        private String type;\n\n        public Mscng(String type) {\n            this.type = type;\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class MscngECDH extends Mscng {\n\n        public MscngECDH() {\n            super(\"ECDH\");\n        }\n    }\n\n    public static class MscngECDSA extends Mscng {\n\n        public MscngECDSA() {\n            super(\"ECDSA\");\n        }\n    }\n\n    public static class MbedTLS extends NativeKeyPairGeneratorSpi {\n\n        public MbedTLS() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Ippcp extends NativeKeyPairGeneratorSpi {\n\n        public Ippcp() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Matrixssl extends NativeKeyPairGeneratorSpi {\n\n        public Matrixssl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n  \n    public static class Libressl extends NativeKeyPairGeneratorSpi {\n\n        public Libressl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Nettle extends NativeKeyPairGeneratorSpi {\n        public Nettle() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        KeyPair generate(AlgorithmParameterSpec params, SecureRandom random) {\n            if (params instanceof ECGenParameterSpec) {\n                    String curveName = ((ECGenParameterSpec) params).getName();\n                    if (curveName.contains(\"secp\")) {\n                        curveName = \"secg/\" + curveName;\n                    }\n                    EC_Curve curve = EC_Store.getInstance().getObject(EC_Curve.class, curveName);\n                    ECParameterSpec spec = curve.toSpec();\n                    return generate(params, random, spec);\n            }\n            return null;\n        }\n\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random, AlgorithmParameterSpec spec);\n    }\n}\n", "not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://opensource.org/licenses/mit-license.php\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.dogecoin.core;\n\nimport java.io.File;\nimport java.util.List;\n\nimport com.google.dogecoin.store.BlockStore;\nimport com.google.dogecoin.store.BlockStoreException;\nimport com.google.dogecoin.store.SPVBlockStore;\n\n/**\n * Extension of bitcoinj BlockChain for use with block chain replay.\n */\npublic class MultiBitBlockChain extends BlockChain {\n\n    public MultiBitBlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore) throws BlockStoreException {\n        super(params, wallet, blockStore);\n    }\n\n    public MultiBitBlockChain(NetworkParameters params, BlockStore blockStore) throws BlockStoreException {\n        super(params, blockStore);\n    }\n\n    public MultiBitBlockChain(NetworkParameters params, List<BlockChainListener> wallets, BlockStore blockStore) throws BlockStoreException {\n        super(params, wallets, blockStore);\n    }\n    \n    /**\n     * Set the chainhead, clear any cached blocks and truncate the blockchain .\n     * (Used for blockchain replay).\n     * @param chainHead\n     * @throws BlockStoreException\n     */\n    public void setChainHeadClearCachesAndTruncateBlockStore(StoredBlock chainHead, String blockStoreFilename) throws BlockStoreException {\n        if (blockStore instanceof SPVBlockStore) {\n            // Delete the blockstore and recreate it.\n            ((SPVBlockStore) blockStore).close();\n\n            File blockStoreFile = new File(blockStoreFilename);\n            blockStoreFile.delete();\n        } else {\n            blockStore.setChainHead(chainHead);\n            super.setChainHead(chainHead);\n        }\n    }\n}\n", "playMetrics;\nimport android.view.WindowManager;\n\npublic class UiUtils {\n\n    static public int getScreenWidthPixels(Context context) {\n        DisplayMetrics dm = new DisplayMetrics();\n        ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay()\n                .getMetrics(dm);\n        return dm.widthPixels;\n    }\n\n    static public int dipToPx(Context context, int dip) {\n        return (int) (dip * getScreenDensity(context) + 0.5f);\n    }\n\n    static public float getScreenDensity(Context context) {\n        try {\n            DisplayMetrics dm = new DisplayMetrics();\n            ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay()\n                    .getMetrics(dm);\n            return dm.density;\n        } catch (Exception e) {\n            return DisplayMetrics.DENSITY_DEFAULT;\n        }\n    }\n\n}\n", "avax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * \n * @author Colin Bundervoet\n *\n */\npublic abstract class RenderFile implements ActionResult {\n\n\t@Override\n\tpublic void handle(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t\n\t\tresponse.setCharacterEncoding(\"utf-8\");\n\t\t\n\t\tString login = (String) request.getSession().getAttribute(\"login.username\");\n\t\tString name = (String) request.getSession().getAttribute(\"login.name\");\n\t\tString admin = (String) request.getSession().getAttribute(\"login.admin\");\n\t\t\n\t\tif (login != null && name != null && admin != null) {\n\t\t\tSystem.out.println(\"Login found for \" + login);\n\t\t\trequest.setAttribute(\"username\", login);\n\t\t\trequest.setAttribute(\"name\", name);\n\t\t\trequest.setAttribute(\"admin\", admin.equals(\"true\"));\n\t\t}\n\t\t\n\t}\n\n}\n", "sion;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\n/**\n * \u041f\u0440\u043e\u0441\u0442\u043e\u0439 \u043f\u0440\u0438\u043c\u0435\u0440 \u0434\u043b\u044f \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u0438\n *\n * @author ASaburov\n */\npublic class HibernateManyToMany {\n\n    private static final Logger log = LoggerFactory.getLogger(HibernateManyToMany.class);\n\n    private static SessionFactory sessionFactory;\n    private static ServiceRegistry serviceRegistry;\n\n    private static void init() {\n        Configuration configuration = new Configuration();\n        configuration.configure(\"hibernate.cfg.xml\");\n        serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();\n        sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n    }\n\n    private static void destroy() {\n        StandardServiceRegistryBuilder.destroy(serviceRegistry);\n    }\n\n    public static void main(String[] args) {\n        init();\n\n        Session s = sessionFactory.getCurrentSession();\n        s.beginTransaction();\n\n        Author oldAuthor = new Author();\n        oldAuthor.setAuthorName(\"New Author 0\");\n        s.save(oldAuthor);\n\n        saveBook(oldAuthor, s);\n\n        List<Book> bookList = s.createCriteria(Book.class).list();\n        for (Book book : bookList) {\n            log.debug(\"\");\n            log.debug(\"Book: {}\", book);\n            for (Author author : book.getAuthorList()) {\n                log.debug(\"Author: {}\", author);\n            }\n        }\n\n        oldAuthor = bookList.get(0).getAuthorList().iterator().next();\n        Book oldBook = bookList.get(0);\n\n        saveBook(oldAuthor, s);\n        // saveAuthor(oldBook, s);\n\n        // \u0415\u0441\u043b\u0438 \u043d\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044c - \u0442\u043e \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0430\n        s.getTransaction().commit();\n\n        s = sessionFactory.getCurrentSession();\n        s.beginTransaction();\n\n        bookList = s.createCriteria(Book.class).list();\n        for (Book book : bookList) {\n            log.debug(\"\");\n            log.debug(\"Book: {}\", book);\n            for (Author author : book.getAuthorList()) {\n                log.debug(\"Author: {}\", author);\n            }\n        }\n\n        s.getTransaction().commit();\n\n        log.debug(\"Transaction committed\");\n\n        destroy();\n    }\n\n    private static void saveBook(Author oldAuthor, Session s) throws HibernateException {\n        Book newBook = new Book();\n        newBook.setBookName(\"New book 1\");\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0438 \u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0435\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430\n        newBook.addAuthor(oldAuthor);\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430 \u043a \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0435\n        Author newAuthor = new Author();\n        newAuthor.setAuthorName(\"New Author 1\");\n        // \u041d\u0435\u0442 \u043d\u0430\u0434\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u043a\u043d\u0438\u0433\u0443 \u043a \u0430\u0432\u0442\u043e\u0440\u0443\n        // \u0415\u0441\u043b\u0438 \u0441\u0432\u044f\u0437\u044c \u043e\u0434\u043d\u043e\u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u0430\u044f - \u0442\u043e \u043d\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430. \u0418\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0437\u0430\u0431\u0430\u0432\u043d\u044b\u0439 \u044d\u0444\u0444\u0435\u043a\u0442\n        //newAuthor.addBook(newBook);\n\n        newBook.addAuthor(newAuthor);\n        s.save(newAuthor);\n\n\n        s.save(newBook);\n    }\n\n    private void saveAuthor(Book oldBook, Session s) throws HibernateException {\n        Author newAuthor = new Author();\n        newAuthor.setAuthorName(\"New Author 2\");\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0438 \u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0435\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430\n        newAuthor.addBook(oldBook);\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430 \u043a \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0435\n        Book newBook = new Book();\n        newBook.setBookName(\"New Book 2\");\n        // \u041d\u0435\u0442 \u043d\u0430\u0434\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0430\u0432\u0442\u043e\u0440\u0430 \u043a \u043a\u043d\u0438\u0433\u0435\n        // \u0415\u0441\u043b\u0438 \u0441\u0432\u044f\u0437\u044c \u043e\u0434\u043d\u043e\u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u0430\u044f - \u0442\u043e \u043d\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430. \u0418\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0437\u0430\u0431\u0430\u0432\u043d\u044b\u0439 \u044d\u0444\u0444\u0435\u043a\u0442\n        //newBook.addAuthor(newAuthor);\n        newAuthor.addBook(newBook);\n        s.save(newBook);\n\n        s.save(newAuthor);\n    }\n\n\n    private SessionFactory getSessionFactory() {\n\n        Configuration configuration = new Configuration().configure();\n        SessionFactory sessionFactory = configuration.buildSessionFactory(\n                new StandardServiceRegistryBuilder()\n                        .applySettings(configuration.getProperties())\n                        .build()\n        );\n        return sessionFactory;\n\n    }\n}\n", "e.layout.AnchorPane;\nimport javafx.stage.Stage;\nimport seedu.stask.MainApp;\n\n/**\n * A utility class to load UiParts from FXML files.\n */\npublic class UiPartLoader {\n    private final static String FXML_FILE_FOLDER = \"/view/\";\n\n    public static <T extends UiPart> T loadUiPart(Stage primaryStage, T controllerSeed) {\n        return loadUiPart(primaryStage, null, controllerSeed);\n    }\n\n    /**\n     * Returns the ui class for a specific UI Part.\n     *\n     * @param primaryStage The primary stage for the view.\n     * @param placeholder The placeholder where the loaded Ui Part is added.\n     * @param sampleUiPart The sample of the expected UiPart class.\n     * @param <T> The type of the UiPart\n     */\n    public static <T extends UiPart> T loadUiPart(Stage primaryStage, AnchorPane placeholder, T sampleUiPart) {\n        FXMLLoader loader = new FXMLLoader();\n        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + sampleUiPart.getFxmlPath()));\n        Node mainNode = loadLoader(loader, sampleUiPart.getFxmlPath());\n        UiPart controller = loader.getController();\n        controller.setStage(primaryStage);\n        controller.setPlaceholder(placeholder);\n        controller.setNode(mainNode);\n        return (T)controller;\n    }\n\n    /**\n     * Returns the ui class for a specific UI Part.\n     *\n     * @param seedUiPart The UiPart object to be used as the ui.\n     * @param <T> The type of the UiPart\n     */\n\n    public static <T extends UiPart> T loadUiPart(T seedUiPart) {\n        FXMLLoader loader = new FXMLLoader();\n        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + seedUiPart.getFxmlPath()));\n        loader.setController(seedUiPart);\n        loadLoader(loader, seedUiPart.getFxmlPath());\n        return seedUiPart;\n    }\n\n\n    private static Node loadLoader(FXMLLoader loader, String fxmlFileName) {\n        try {\n            return loader.load();\n        } catch (Exception e) {\n            String errorMessage = \"FXML Load Error for \" + fxmlFileName;\n            throw new RuntimeException(errorMessage, e);\n        }\n    }\n\n}\n", "r data fully carried over to a ServerMessage.\n * @author Nillus\n *\n */\npublic interface SerializableObject\n{\n\t/**\n\t * Serializes the object to a ServerMessage.\n\t * @param msg The ServerMessage object to serialize this SerializableObject to.\n\t */\n\tpublic void serialize(ServerMessage msg);\n}\n", "annotation.JsonProperty;\n\n/**\n * \n * @author Johannes Hiemer. \n *\n */\npublic class ServicePlan {\n\n\t@JsonProperty(\"name\")\n    private String name;\n    \n\t@JsonProperty(\"free\")\n    private boolean free;\n    \n\t@JsonProperty(\"description\")\n    private String description;\n    \n\t@JsonProperty(\"service_guid\")\t\n    private UUID serviceGuid;\n    \n\t@JsonProperty(\"extra\")\n    private Object extra;\n    \n\t@JsonProperty(\"unique_id\")\n    private String uniqueId;\n    \n\t@JsonProperty(\"public\")\n    private boolean pub;\n    \n\t@JsonProperty(\"service_url\")\n    private String serviceUrl;\n    \n\t@JsonProperty(\"service_instances_url\")\n    private String serviceInstanceUrl;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic boolean isFree() {\n\t\treturn free;\n\t}\n\n\tpublic void setFree(boolean free) {\n\t\tthis.free = free;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic UUID getServiceGuid() {\n\t\treturn serviceGuid;\n\t}\n\n\tpublic void setServiceGuid(UUID serviceGuid) {\n\t\tthis.serviceGuid = serviceGuid;\n\t}\n\n\tpublic Object getExtra() {\n\t\treturn extra;\n\t}\n\n\tpublic void setExtra(Object extra) {\n\t\tthis.extra = extra;\n\t}\n\n\tpublic String getUniqueId() {\n\t\treturn uniqueId;\n\t}\n\n\tpublic void setUniqueId(String uniqueId) {\n\t\tthis.uniqueId = uniqueId;\n\t}\n\n\tpublic boolean isPub() {\n\t\treturn pub;\n\t}\n\n\tpublic void setPub(boolean pub) {\n\t\tthis.pub = pub;\n\t}\n\n\tpublic String getServiceUrl() {\n\t\treturn serviceUrl;\n\t}\n\n\tpublic void setServiceUrl(String serviceUrl) {\n\t\tthis.serviceUrl = serviceUrl;\n\t}\n\n\tpublic String getServiceInstanceUrl() {\n\t\treturn serviceInstanceUrl;\n\t}\n\n\tpublic void setServiceInstanceUrl(String serviceInstanceUrl) {\n\t\tthis.serviceInstanceUrl = serviceInstanceUrl;\n\t}\n\t\n}\n", "t android.os.Build;\nimport android.support.annotation.DrawableRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\n\nimport org.tndata.android.compass.databinding.CardGoalBinding;\nimport org.tndata.android.compass.util.ImageLoader;\n\n\n/**\n * Single goal view holder.\n *\n * @author Ismael Alonso\n * @version 1.0.0\n */\npublic class GoalCardHolder extends RecyclerView.ViewHolder implements View.OnClickListener{\n    private CardGoalBinding mBinding;\n    private Listener mListener;\n\n\n    /**\n     * Constructor.\n     *\n     * @param binding the binding object\n     */\n    public GoalCardHolder(@NonNull CardGoalBinding binding, @Nullable Listener listener){\n        super(binding.getRoot());\n        mBinding = binding;\n        mListener = listener;\n        itemView.setOnClickListener(this);\n    }\n\n    /**\n     * Sets the color of the goal's icon container.\n     *\n     * @param color the color of the icon container.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void setColor(int color){\n        GradientDrawable gradientDrawable = (GradientDrawable)mBinding.goalIconContainer.getBackground();\n        gradientDrawable.setColor(color);\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN){\n            mBinding.goalIconContainer.setBackgroundDrawable(gradientDrawable);\n        }\n        else{\n            mBinding.goalIconContainer.setBackground(gradientDrawable);\n        }\n        mBinding.goalHeader.setBackgroundColor(color);\n    }\n\n    /**\n     * Loads the icon in the provided URL into the goal icon view.\n     *\n     * @param url the URL to fetch the icon from.\n     */\n    public void setIcon(@NonNull String url){\n        ImageLoader.loadBitmap(mBinding.goalIcon, url);\n    }\n\n    /**\n     * Sets a drawable resource as the goal icon.\n     *\n     * @param resourceId the id of the drawable.\n     */\n    public void setIcon(@DrawableRes int resourceId){\n        mBinding.goalIconContainer.setBackgroundResource(resourceId);\n    }\n\n    /**\n     * Sets the title of the goal.\n     *\n     * @param title the title of the goal.\n     */\n    public void setTitle(@NonNull String title){\n        mBinding.goalTitle.setText(title);\n    }\n\n    @Override\n    public void onClick(View v){\n        mListener.onGoalCardClick();\n    }\n\n\n    /**\n     * Listener interface for GoalCardHolder.\n     *\n     * @author Ismael Alonso\n     * @version 1.0.0\n     */\n    public interface Listener{\n        /**\n         * Called when the card is tapped.\n         */\n        void onGoalCardClick();\n    }\n}\n", "terface.ReturnsResponse;\nimport org.organet.michael.CommandLineInterface.ScansForAdhocNetworks;\n\nimport java.util.*;\n\npublic class IwlistScan extends CommandBase implements ScansForAdhocNetworks, ReturnsResponse {\n  public IwlistScan(String adhocInterfaceName) {\n    super(\"/sbin/iwlist\", Arrays.asList(adhocInterfaceName, \"scan\"));\n  }\n\n  // TODO Search for \"integration\" in the project \"wireless\" and move the lines from there to here\n  @Override\n  public Object getResponse() {\n    // Run the command\n    Object response = this.run();\n    if (response == null) {\n      return false;\n    }\n\n    String responseString = String.valueOf(response);\n\n    // Parse the output\n    List<Map<String, String>> networks = new ArrayList<>();\n    String[] splitted = responseString.split(\"Cell \\\\d\\\\d - \");\n    for (int i = 1, len = splitted.length; i < len; i++) {\n      // Address, ESSID, Protocol, Mode, Frequency\n      Map<String, String> network = new HashMap<>(5);\n      String[] lines = splitted[i].split(\"\\n\");\n\n      for (int j = 0, linesCount = lines.length; j < linesCount; j++) {\n        String line = lines[j].trim();\n        if (!line.contains(\":\")) {\n          continue;\n        }\n\n        String[] keyValue = line.split(\":\", 2);\n        if (\"address, essid, protocol, mode, frequency\".contains(keyValue[0].toLowerCase())) {\n          network.put(keyValue[0].toLowerCase(), keyValue[1]);\n        }\n      }\n\n      if (network.get(\"mode\").toLowerCase().equals(\"ad-hoc\")) {\n        networks.add(network);\n      }\n    }\n\n    // Return meaningful response\n    return networks;\n  }\n}\n", "ee AUTHORS)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage eu.verdelhan.ta4j.analysis.criteria;\n\nimport eu.verdelhan.ta4j.AnalysisCriterion;\nimport eu.verdelhan.ta4j.Strategy;\nimport eu.verdelhan.ta4j.TimeSeries;\nimport java.util.List;\n\n/**\n * An abstract analysis criterion.\n */\npublic abstract class AbstractAnalysisCriterion implements AnalysisCriterion {\n\n    @Override\n    public Strategy chooseBest(TimeSeries series, List<Strategy> strategies) {\n        Strategy bestStrategy = strategies.get(0);\n        double bestCriterionValue = calculate(series, series.run(bestStrategy));\n\n        for (int i = 1; i < strategies.size(); i++) {\n            Strategy currentStrategy = strategies.get(i);\n            double currentCriterionValue = calculate(series, series.run(currentStrategy));\n\n            if (betterThan(currentCriterionValue, bestCriterionValue)) {\n                bestStrategy = currentStrategy;\n                bestCriterionValue = currentCriterionValue;\n            }\n        }\n        return bestStrategy;\n    }\n\n    @Override\n    public String toString() {\n        String[] tokens = getClass().getSimpleName().split(\"(?=\\\\p{Lu})\", -1);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < tokens.length - 1; i++) {\n            sb.append(tokens[i]).append(' ');\n        }\n        return sb.toString().trim();\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * @test\n * @bug 6916074\n * @summary Add support for TLS 1.2\n * @run main/othervm X509ExtendedTMEnabled\n *\n *     SunJSSE does not support dynamic system properties, no way to re-use\n *     system properties in samevm/agentvm mode.\n *\n * Ensure that the SunJSSE provider enables the X509ExtendedTrustManager.\n */\n\nimport java.io.*;\nimport java.net.*;\nimport javax.net.ssl.*;\nimport java.security.cert.*;\nimport java.security.*;\n\npublic class X509ExtendedTMEnabled {\n\n    /*\n     * =============================================================\n     * Set the various variables needed for the tests, then\n     * specify what tests to run on each side.\n     */\n\n    /*\n     * Should we run the client or server in a separate thread?\n     * Both sides can throw exceptions, but do you have a preference\n     * as to which side should be the main thread.\n     */\n    static boolean separateServerThread = true;\n\n    /*\n     * Where do we find the keystores?\n     */\n    static String pathToStores = \"../../../../../../../etc\";\n    static String keyStoreFile = \"keystore\";\n    static String trustStoreFile = \"truststore\";\n    static String passwd = \"passphrase\";\n    private final static char[] cpasswd = \"passphrase\".toCharArray();\n\n    /*\n     * Is the server ready to serve?\n     */\n    volatile static boolean serverReady = false;\n\n    /*\n     * Turn on SSL debugging?\n     */\n    static boolean debug = false;\n\n    /*\n     * If the client or server is doing some kind of object creation\n     * that the other side depends on, and that thread prematurely\n     * exits, you may experience a hang.  The test harness will\n     * terminate all hung threads after its timeout has expired,\n     * currently 3 minutes by default, but you might try to be\n     * smart about it....\n     */\n\n    /*\n     * Define the server side of the test.\n     *\n     * If the server prematurely exits, serverReady will be set to true\n     * to avoid infinite hangs.\n     */\n    void doServerSide() throws Exception {\n        SSLServerSocketFactory sslssf =\n                                getContext(true).getServerSocketFactory();\n        SSLServerSocket sslServerSocket =\n            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n        serverPort = sslServerSocket.getLocalPort();\n\n        // enable endpoint identification\n        // ignore, we may test the feature when known how to parse client\n        // hostname\n        //SSLParameters params = sslServerSocket.getSSLParameters();\n        //params.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        //sslServerSocket.setSSLParameters(params);\n\n        /*\n         * Signal Client, we're ready for his connect.\n         */\n        serverReady = true;\n\n        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n        sslSocket.setNeedClientAuth(true);\n        InputStream sslIS = sslSocket.getInputStream();\n        OutputStream sslOS = sslSocket.getOutputStream();\n\n        sslIS.read();\n        sslOS.write(85);\n        sslOS.flush();\n\n        sslSocket.close();\n\n        if (!serverTM.wasServerChecked() && serverTM.wasClientChecked()) {\n            System.out.println(\"SERVER TEST PASSED!\");\n        } else {\n            throw new Exception(\"SERVER TEST FAILED!  \" +\n                !serverTM.wasServerChecked() + \" \" +\n                serverTM.wasClientChecked());\n        }\n    }\n\n    /*\n     * Define the client side of the test.\n     *\n     * If the server prematurely exits, serverReady will be set to true\n     * to avoid infinite hangs.\n     */\n    void doClientSide() throws Exception {\n\n        /*\n         * Wait for server to get started.\n         */\n        while (!serverReady) {\n            Thread.sleep(50);\n        }\n\n        SSLSocketFactory sslsf = getContext(false).getSocketFactory();\n        SSLSocket sslSocket = (SSLSocket)\n            sslsf.createSocket(\"localhost\", serverPort);\n\n        // enable endpoint identification\n        SSLParameters params = sslSocket.getSSLParameters();\n        params.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        sslSocket.setSSLParameters(params);\n\n        InputStream sslIS = sslSocket.getInputStream();\n        OutputStream sslOS = sslSocket.getOutputStream();\n\n        sslOS.write(280);\n        sslOS.flush();\n        sslIS.read();\n\n        sslSocket.close();\n\n        if (clientTM.wasServerChecked() && !clientTM.wasClientChecked()) {\n            System.out.println(\"CLIENT TEST PASSED!\");\n        } else {\n            throw new Exception(\"CLIENT TEST FAILED!  \" +\n                clientTM.wasServerChecked() + \" \" +\n                !clientTM.wasClientChecked());\n        }\n    }\n\n    MyExtendedX509TM serverTM;\n    MyExtendedX509TM clientTM;\n\n    private SSLContext getContext(boolean server) throws Exception {\n        String keyFilename =\n            System.getProperty(\"test.src\", \"./\") + \"/\" + pathToStores +\n                \"/\" + keyStoreFile;\n        String trustFilename =\n            System.getProperty(\"test.src\", \"./\") + \"/\" + pathToStores +\n                \"/\" + trustStoreFile;\n\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        ks.load(new FileInputStream(keyFilename), cpasswd);\n        kmf.init(ks, cpasswd);\n\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        KeyStore ts = KeyStore.getInstance(\"JKS\");\n        ts.load(new FileInputStream(trustFilename), cpasswd);\n        tmf.init(ts);\n\n        TrustManager tms[] = tmf.getTrustManagers();\n        if (tms == null || tms.length == 0) {\n            throw new Exception(\"unexpected trust manager implementation\");\n        } else {\n           if (!(tms[0] instanceof X509TrustManager)) {\n            throw new Exception(\"unexpected trust manager implementation: \"\n                                + tms[0].getClass().getCanonicalName());\n           }\n        }\n\n        if (server) {\n            serverTM = new MyExtendedX509TM((X509TrustManager)tms[0]);\n\n            tms = new TrustManager[] {serverTM};\n        } else {\n            clientTM = new MyExtendedX509TM((X509TrustManager)tms[0]);\n\n            tms = new TrustManager[] {clientTM};\n        }\n\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n        ctx.init(kmf.getKeyManagers(), tms, null);\n\n        return ctx;\n    }\n\n    static class MyExtendedX509TM extends X509ExtendedTrustManager\n            implements X509TrustManager {\n\n        X509TrustManager tm;\n\n        boolean clientChecked;\n        boolean serverChecked;\n\n        MyExtendedX509TM(X509TrustManager tm) {\n            clientChecked = false;\n            serverChecked = false;\n\n            this.tm = tm;\n        }\n\n        public boolean wasClientChecked() {\n            return clientChecked;\n        }\n\n        public boolean wasServerChecked() {\n            return serverChecked;\n        }\n\n\n        public void checkClientTrusted(X509Certificate chain[], String authType)\n                throws CertificateException {\n            tm.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate chain[], String authType)\n                throws CertificateException {\n            tm.checkServerTrusted(chain, authType);\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return tm.getAcceptedIssuers();\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType,\n                Socket socket) throws CertificateException {\n            clientChecked = true;\n            tm.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType,\n                Socket socket) throws CertificateException {\n            serverChecked = true;\n            tm.checkServerTrusted(chain, authType);\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType,\n            SSLEngine engine) throws CertificateException {\n            clientChecked = true;\n            tm.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType,\n            SSLEngine engine) throws CertificateException {\n            serverChecked = true;\n            tm.checkServerTrusted(chain, authType);\n        }\n    }\n\n    /*\n     * =============================================================\n     * The remainder is just support stuff\n     */\n\n    // use any free port by default\n    volatile int serverPort = 0;\n\n    volatile Exception serverException = null;\n    volatile Exception clientException = null;\n\n    public static void main(String[] args) throws Exception {\n\n        if (debug)\n            System.setProperty(\"javax.net.debug\", \"all\");\n\n        /*\n         * Start the tests.\n         */\n        new X509ExtendedTMEnabled();\n    }\n\n    Thread clientThread = null;\n    Thread serverThread = null;\n\n    /*\n     * Primary constructor, used to drive remainder of the test.\n     *\n     * Fork off the other side, then do your work.\n     */\n    X509ExtendedTMEnabled() throws Exception {\n        if (separateServerThread) {\n            startServer(true);\n            startClient(false);\n        } else {\n            startClient(true);\n            startServer(false);\n        }\n\n        /*\n         * Wait for other side to close down.\n         */\n        if (separateServerThread) {\n            serverThread.join();\n        } else {\n            clientThread.join();\n        }\n\n        /*\n         * When we get here, the test is pretty much over.\n         *\n         * If the main thread excepted, that propagates back\n         * immediately.  If the other thread threw an exception, we\n         * should report back.\n         */\n        if (serverException != null)\n            throw serverException;\n        if (clientException != null)\n            throw clientException;\n    }\n\n    void startServer(boolean newThread) throws Exception {\n        if (newThread) {\n            serverThread = new Thread() {\n                public void run() {\n                    try {\n                        doServerSide();\n                    } catch (Exception e) {\n                        /*\n                         * Our server thread just died.\n                         *\n                         * Release the client, if not active already...\n                         */\n                        System.err.println(\"Server died...\");\n                        serverReady = true;\n                        serverException = e;\n                    }\n                }\n            };\n            serverThread.start();\n        } else {\n            doServerSide();\n        }\n    }\n\n    void startClient(boolean newThread) throws Exception {\n        if (newThread) {\n            clientThread = new Thread() {\n                public void run() {\n                    try {\n                        doClientSide();\n                    } catch (Exception e) {\n                        /*\n              * Our client thread just died.\n                         */\n                        System.err.println(\"Client died...\");\n                        clientException = e;\n                    }\n                }\n            };\n            clientThread.start();\n        } else {\n            doClientSide();\n        }\n    }\n}\n\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.netapp.v2019_11_01;\n\nimport java.util.Collection;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.microsoft.rest.ExpandableStringEnum;\n\n/**\n * Defines values for InAvailabilityReasonType.\n */\npublic final class InAvailabilityReasonType extends ExpandableStringEnum<InAvailabilityReasonType> {\n    /** Static value Invalid for InAvailabilityReasonType. */\n    public static final InAvailabilityReasonType INVALID = fromString(\"Invalid\");\n\n    /** Static value AlreadyExists for InAvailabilityReasonType. */\n    public static final InAvailabilityReasonType ALREADY_EXISTS = fromString(\"AlreadyExists\");\n\n    /**\n     * Creates or finds a InAvailabilityReasonType from its string representation.\n     * @param name a name to look for\n     * @return the corresponding InAvailabilityReasonType\n     */\n    @JsonCreator\n    public static InAvailabilityReasonType fromString(String name) {\n        return fromString(name, InAvailabilityReasonType.class);\n    }\n\n    /**\n     * @return known InAvailabilityReasonType values\n     */\n    public static Collection<InAvailabilityReasonType> values() {\n        return values(InAvailabilityReasonType.class);\n    }\n}\n", ";\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\n\r\nimport play.db.jpa.Model;\r\n\r\n@Entity\r\npublic class OrderForm extends Model{\r\n\t\r\n\tpublic Date dateOfOrder;\r\n\t\r\n\tpublic int numberOfOrder;\r\n\t\r\n\t@ManyToOne\r\n\tpublic Company company;\r\n\t\r\n\t@ManyToOne\r\n\tpublic BusinessYear businessYear;\r\n\t\r\n\t@ManyToOne\r\n\tpublic BusinessPartner businessPartner;\r\n\t\r\n\t@OneToMany(mappedBy = \"orderForm\")\r\n\tpublic List<OrderFormItem> orderFormItems;\r\n\t\r\n\tpublic OrderForm(Date dateOfOrder, int numberOfOrder) {\r\n\t\tthis.dateOfOrder = dateOfOrder;\r\n\t\tthis.numberOfOrder = numberOfOrder;\r\n\t}\r\n}\r\n", " * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage net.telestream.cloud.qc;\n\nimport java.util.Objects;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonWriter;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport java.io.IOException;\n\n/**\n * Proxy\n */\n\npublic class Proxy {\n  @SerializedName(\"status\")\n  private String status = null;\n\n  @SerializedName(\"progress\")\n  private Integer progress = null;\n\n  @SerializedName(\"url\")\n  private String url = null;\n\n  @SerializedName(\"id\")\n  private String id = null;\n\n  @SerializedName(\"updated_at\")\n  private String updatedAt = null;\n\n  public Proxy status(String status) {\n    this.status = status;\n    return this;\n  }\n\n   /**\n   * Get status\n   * @return status\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getStatus() {\n    return status;\n  }\n\n  public void setStatus(String status) {\n    this.status = status;\n  }\n\n  public Proxy progress(Integer progress) {\n    this.progress = progress;\n    return this;\n  }\n\n   /**\n   * Get progress\n   * @return progress\n  **/\n  @ApiModelProperty(value = \"\")\n  public Integer getProgress() {\n    return progress;\n  }\n\n  public void setProgress(Integer progress) {\n    this.progress = progress;\n  }\n\n  public Proxy url(String url) {\n    this.url = url;\n    return this;\n  }\n\n   /**\n   * Get url\n   * @return url\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getUrl() {\n    return url;\n  }\n\n  public void setUrl(String url) {\n    this.url = url;\n  }\n\n  public Proxy id(String id) {\n    this.id = id;\n    return this;\n  }\n\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public Proxy updatedAt(String updatedAt) {\n    this.updatedAt = updatedAt;\n    return this;\n  }\n\n   /**\n   * Get updatedAt\n   * @return updatedAt\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getUpdatedAt() {\n    return updatedAt;\n  }\n\n  public void setUpdatedAt(String updatedAt) {\n    this.updatedAt = updatedAt;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Proxy proxy = (Proxy) o;\n    return Objects.equals(this.status, proxy.status) &&\n        Objects.equals(this.progress, proxy.progress) &&\n        Objects.equals(this.url, proxy.url) &&\n        Objects.equals(this.id, proxy.id) &&\n        Objects.equals(this.updatedAt, proxy.updatedAt);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(status, progress, url, id, updatedAt);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Proxy {\\n\");\n    \n    sb.append(\"    status: \").append(toIndentedString(status)).append(\"\\n\");\n    sb.append(\"    progress: \").append(toIndentedString(progress)).append(\"\\n\");\n    sb.append(\"    url: \").append(toIndentedString(url)).append(\"\\n\");\n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    updatedAt: \").append(toIndentedString(updatedAt)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}\n\n", "erary;\nimport UI.Commands.Command;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * This is the class that is used to represent an individual Session\n * This class has two states Connected and NotConnected which changes the systems behavior\n * Language: Java 1.8 Level 8\n * Created: 11/4/17\n * Revisited: 11/5/17\n * Revisited: 11/6/17\n * @author : Stephen Cook(sjc5897@g.rit.edu)\n */\npublic class Session\n{\n    private static HashMap<Integer, Session> connectionHashMap= new HashMap<>();\n    private int connectionID;\n    private ArrayList<Itinerary> lastQueried;\n    private int looper;\n    private State currentState;\n    private Stack<Command> undoStack;\n    private Stack<Command> redoStack;\n\n    /**\n     * The constructor for the Connection\n     * @param ID            The Connection ID\n     * @param connection    The Connection State\n     */\n    private Session(Integer ID, State connection){\n        this.connectionID =ID;\n        this.lastQueried = new ArrayList<>();\n        this.looper = 0;\n        this.currentState = connection;\n        this.undoStack = new Stack<>();\n        this.redoStack = new Stack<>();\n    }\n\n    /**\n     * Changes the current state of the session\n     * @param connection The new state of the session\n     */\n    public void setCurrentState(State connection){\n        this.currentState = connection;\n    }\n\n    /**\n     * This calls the current states flight query method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] FlightQuery(String[] args){\n        return this.currentState.FlightQuery(args);\n    }\n\n    /**\n     * This sets the last queried to the new last queried by the session\n     * @param q The new flight query object\n     */\n    public void setQuery(FlightQuery q){\n        this. lastQueried = q.getItineraries();\n    }\n\n    /**\n     * This gets the last query\n     * @return The last query\n     */\n    public ArrayList<Itinerary> getLastQueried(){\n        return this.lastQueried;\n    }\n\n    /**\n     * This calls the current states create reservation method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] createReservation(String [] args){\n        return this.currentState.createReservation(args);\n    }\n\n    /**\n     * This calls the current states delete reservation method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] deleteReservation(String[] args){\n        return this.currentState.deleteReservation(args);\n    }\n\n    /**\n     * This calls the current states retrieve reservation method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] retrieveReservation(String[] args){\n        return this.currentState.retrieveReservation(args);\n    }\n\n    /**\n     * This calls the current states airport info method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] airportInformation(String[] args){return this.currentState.airportInfo(args);}\n\n    /**\n     * This calls the current states airport server method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] airportServer(String[] args){\n        return this.currentState.airportServer(args);\n    }\n\n    /**\n     * This calls the current states disconnect method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] disconnect(String [] args){return this.currentState.disconnect(args);}\n\n    /**\n     * This method adds a new connection to the connection hash map\n     * @param connectionID  The connection Id\n     * @param connection    The connection state\n     */\n    public static void addConnection(Integer connectionID, State connection){\n        Session Session = new Session(connectionID,connection);\n        connectionHashMap.put(connectionID, Session);\n    }\n\n    /**\n     * Gets the connection hash map\n     * @return the connection hash map\n     */\n    public static HashMap<Integer, Session> getConnectionHashMap(){\n        return connectionHashMap;\n    }\n\n    /**\n     *\n     * @return\n     */\n    public Stack<Command> getUndoStack() {return undoStack;}\n    public Stack<Command> getRedoStack() {return redoStack;}\n\n    /**\n     * This calls the current states flight query method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] undo(String args[]) {return this.currentState.undo(args);}\n\n    /**\n     * This calls the current states flight query method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] redo(String[] args) {\n        return this.currentState.redo(args);\n    }\n\n\n    /**\n     * Gets the looper value for this session\n     * @return The looper value\n     */\n    public int getLooper(){return this.looper;}\n\n    /**\n     * Adds one to the looper\n     */\n    public void addLooper(){this.looper = this.looper+1;}\n\n    /**\n     * Saves the current reservation list on disconnect\n     */\n    public void saveState(){this.currentState.saveState();}\n\n}\n", "e are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Igor Bukanov\n *   Bob Jervis\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\npublic class ScriptOrFnNode extends Node {\n\n    private static final long serialVersionUID = 1L;\n\n    public ScriptOrFnNode(int nodeType) {\n        callSuper(nodeType);\n    }\n\n    public ScriptOrFnNode(int nodeType, int lineno, int charno) {\n        callSuper(nodeType, lineno, charno);\n    }\n\n    public final String getSourceName() { return sourceName; }\n\n    public final void setSourceName(String sourceName) {\n        this.sourceName = sourceName;\n    }\n\n    public final int getEncodedSourceStart() { return encodedSourceStart; }\n\n    public final int getEncodedSourceEnd() { return encodedSourceEnd; }\n\n    public final void setEncodedSourceBounds(int start, int end) {\n        this.encodedSourceStart = start;\n        this.encodedSourceEnd = end;\n    }\n\n    public final int getBaseLineno() { return baseLineno; }\n\n    public final void setBaseLineno(int lineno) {\n        // One time action\n        if (lineno < 0 || baseLineno >= 0) Kit.codeBug();\n        baseLineno = lineno;\n    }\n\n    public final int getEndLineno() { return endLineno; }\n\n    public final void setEndLineno(int lineno) {\n        // One time action\n        if (lineno < 0 || endLineno >= 0) Kit.codeBug();\n        endLineno = lineno;\n    }\n\n    public final int getFunctionCount() {\n        if (functions == null) { return 0; }\n        return functions.size();\n    }\n\n    public final FunctionNode getFunctionNode(int i) {\n        return (FunctionNode)functions.get(i);\n    }\n\n    public final int addFunction(FunctionNode fnNode) {\n        if (fnNode == null) Kit.codeBug();\n        if (functions == null) { functions = new ObjArray(); }\n        functions.add(fnNode);\n        return functions.size() - 1;\n    }\n\n    public final int getRegexpCount() {\n        if (regexps == null) { return 0; }\n        return regexps.size() / 2;\n    }\n\n    public final String getRegexpString(int index) {\n        return (String)regexps.get(index * 2);\n    }\n\n    public final String getRegexpFlags(int index) {\n        return (String)regexps.get(index * 2 + 1);\n    }\n\n    public final int addRegexp(String string, String flags) {\n        if (string == null) Kit.codeBug();\n        if (regexps == null) { regexps = new ObjArray(); }\n        regexps.add(string);\n        regexps.add(flags);\n        return regexps.size() / 2 - 1;\n    }\n\n    public final boolean hasParamOrVar(String name) {\n        return itsVariableNames.has(name);\n    }\n\n    public final int getParamOrVarIndex(String name) {\n        return itsVariableNames.get(name, -1);\n    }\n\n    public final String getParamOrVarName(int index) {\n        return (String)itsVariables.get(index);\n    }\n\n    public final int getParamCount() {\n        return varStart;\n    }\n\n    public final int getParamAndVarCount() {\n        return itsVariables.size();\n    }\n\n    public final String[] getParamAndVarNames() {\n        int N = itsVariables.size();\n        if (N == 0) {\n            return ScriptRuntime.emptyStrings;\n        }\n        String[] array = new String[N];\n        itsVariables.toArray(array);\n        return array;\n    }\n\n    public final boolean[] getParamAndVarConst() {\n        int N = itsVariables.size();\n        boolean[] array = new boolean[N];\n        for (int i = 0; i < N; i++)\n            if (itsConst.get(i) != null)\n                array[i] = true;\n        return array;\n    }\n\n    public final void addParam(String name) {\n        // Check addparam is not called after addLocal\n        if (varStart != itsVariables.size()) Kit.codeBug();\n        // Allow non-unique parameter names: use the last occurrence (parser\n        // will warn about dups)\n        int index = varStart++;\n        itsVariables.add(name);\n        itsConst.add(null);\n        itsVariableNames.put(name, index);\n    }\n\n    public static final int NO_DUPLICATE = 1;\n    public static final int DUPLICATE_VAR = 0;\n    public static final int DUPLICATE_PARAMETER = -1;\n    public static final int DUPLICATE_CONST = -2;\n\n    /**\n     * This function adds a variable to the set of var declarations for a\n     * function (or script).  This returns an indicator of a duplicate that\n     * overrides a formal parameter (false if this dups a parameter).\n     * @param name variable name\n     * @return 1 if the name is not any form of duplicate, 0 if it duplicates a\n     * non-parameter, -1 if it duplicates a parameter and -2 if it duplicates a\n     * const.\n     */\n    public final int addVar(String name) {\n        int vIndex = itsVariableNames.get(name, -1);\n        if (vIndex != -1) {\n            // There's already a variable or parameter with this name.\n            if (vIndex >= varStart) {\n                Object v = itsConst.get(vIndex);\n                if (v != null)\n                    return DUPLICATE_CONST;\n                else\n                    return DUPLICATE_VAR;\n            } else\n                return DUPLICATE_PARAMETER;\n        }\n        int index = itsVariables.size();\n        itsVariables.add(name);\n        itsConst.add(null);\n        itsVariableNames.put(name, index);\n        return NO_DUPLICATE;\n    }\n\n    public final boolean addConst(String name) {\n        int vIndex = itsVariableNames.get(name, -1);\n        if (vIndex != -1) {\n            // There's already a variable or parameter with this name.\n            return false;\n        }\n        int index = itsVariables.size();\n        itsVariables.add(name);\n        itsConst.add(name);\n        itsVariableNames.put(name, index);\n        return true;\n    }\n\n    public final void removeParamOrVar(String name) {\n        int i = itsVariableNames.get(name, -1);\n        if (i != -1) {\n            itsVariables.remove(i);\n            itsVariableNames.remove(name);\n            ObjToIntMap.Iterator iter = itsVariableNames.newIterator();\n            for (iter.start(); !iter.done(); iter.next()) {\n                int v = iter.getValue();\n                if (v > i) {\n                    iter.setValue(v - 1);\n                }\n            }\n        }\n    }\n\n    public final Object getCompilerData()\n    {\n        return compilerData;\n    }\n\n    public final void setCompilerData(Object data)\n    {\n        if (data == null) throw new IllegalArgumentException();\n        // Can only call once\n        if (compilerData != null) throw new IllegalStateException();\n        compilerData = data;\n    }\n\n    private int encodedSourceStart;\n    private int encodedSourceEnd;\n    private String sourceName;\n    private int baseLineno = -1;\n    private int endLineno = -1;\n\n    private ObjArray functions;\n\n    private ObjArray regexps;\n\n    // a list of the formal parameters and local variables\n    private ObjArray itsVariables = new ObjArray();\n    private ObjArray itsConst = new ObjArray();\n\n    // mapping from name to index in list\n    private ObjToIntMap itsVariableNames = new ObjToIntMap(11);\n\n    private int varStart;               // index in list of first variable\n\n    private Object compilerData;\n}\n", "s.dialogs.BADialog.BADialogResponse;\nimport wallettemplate.utils.dialogs.BADialog.BADialogResponseListner;\n\npublic class DialogFactory {\n\tstatic BADialog infoDialog(Class<?> resourceClass, String title, String desc) {\n\t\tBADialog ret = new BADialog();\n\t\tret.setViewPath(\"utils/dialogs/infoDialog.fxml\")\n\t\t\t.setResourceClass(resourceClass)\n\t\t\t.setWindowTitle(\"info\")\n\t\t\t.setTitle(title)\n\t\t\t.setDesc(desc);\n\t\treturn ret;\n\t}\n\t\n\tstatic BADialog confirmDialog(Class<?> resourceClass, BADialogResponseListner response, String title, String desc) {\n\t\tBADialog ret = new BADialog();\n\t\tret.setViewPath(\"utils/dialogs/confirmDialog.fxml\")\n\t\t\t.setResourceClass(resourceClass)\n\t\t\t.setWindowTitle(\"Confirm\")\n\t\t\t.setTitle(title)\n\t\t\t.setDesc(desc)\n\t\t\t.setResponseListener(response);\n\t\treturn ret;\n\t}\n\t\n\tstatic BADialog inputDialog(Class<?> resourceClass, BADialogResponseListner response, String title, String desc) {\n\t\tBADialog ret = new BADialog();\n\t\tret.setViewPath(\"utils/dialogs/inputDialog.fxml\")\n\t\t\t.setResourceClass(resourceClass)\n\t\t\t.setWindowTitle(\"Please Complete\")\n\t\t\t.setTitle(title)\n\t\t\t.setDesc(desc)\n\t\t\t.setResponseListener(response);\n\t\treturn ret;\n\t}\n}\n", "droid.support.v4.app.ListFragment;\nimport android.view.View;\nimport android.widget.ArrayAdapter;\nimport android.widget.ListView;\n\n/**\n * A list fragment representing a list of Cars. This fragment\n * also supports tablet devices by allowing list items to be given an\n * 'activated' state upon selection. This helps indicate which item is\n * currently being viewed in a {@link CarDetailFragment}.\n * <p>\n * Activities containing this fragment MUST implement the {@link Callbacks}\n * interface.\n */\npublic class CarListFragment extends ListFragment {\n\n    /**\n     * The serialization (saved instance state) Bundle key representing the\n     * activated item position. Only used on tablets.\n     */\n    private static final String STATE_ACTIVATED_POSITION = \"activated_position\";\n\n    /**\n     * The fragment's current callback object, which is notified of list item\n     * clicks.\n     */\n    private Callbacks mCallbacks = sDummyCallbacks;\n\n    /**\n     * The current activated item position. Only used on tablets.\n     */\n    private int mActivatedPosition = ListView.INVALID_POSITION;\n\n    private CarDatabase database;\n\n    /**\n     * A callback interface that all activities containing this fragment must\n     * implement. This mechanism allows activities to be notified of item\n     * selections.\n     */\n    public interface Callbacks {\n        /**\n         * Callback for when an item has been selected.\n         */\n        public void onItemSelected(Integer id);\n    }\n\n    /**\n     * A dummy implementation of the {@link Callbacks} interface that does\n     * nothing. Used only when this fragment is not attached to an activity.\n     */\n    private static Callbacks sDummyCallbacks = new Callbacks() {\n        @Override\n        public void onItemSelected(Integer id) {\n        }\n    };\n\n    /**\n     * Mandatory empty constructor for the fragment manager to instantiate the\n     * fragment (e.g. upon screen orientation changes).\n     */\n    public CarListFragment() {\n        database = new CarDatabase();\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getActivity().getActionBar().setDisplayHomeAsUpEnabled(false);\n\n        // TODO: replace with a real list adapter.\n        setListAdapter(new CarsArrayAdapter(getActivity(), database.findAll()));\n    }\n\n    @Override\n    public void onViewCreated(View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        // Restore the previously serialized activated item position.\n        if (savedInstanceState != null\n                && savedInstanceState.containsKey(STATE_ACTIVATED_POSITION)) {\n            setActivatedPosition(savedInstanceState.getInt(STATE_ACTIVATED_POSITION));\n        }\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n\n        // Activities containing this fragment must implement its callbacks.\n        if (!(activity instanceof Callbacks)) {\n            throw new IllegalStateException(\"Activity must implement fragment's callbacks.\");\n        }\n\n        mCallbacks = (Callbacks) activity;\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n\n        // Reset the active callbacks interface to the dummy implementation.\n        mCallbacks = sDummyCallbacks;\n    }\n\n    @Override\n    public void onListItemClick(ListView listView, View view, int position, long id) {\n        super.onListItemClick(listView, view, position, id);\n\n        // Notify the active callbacks interface (the activity, if the\n        // fragment is attached to one) that an item has been selected.\n        mCallbacks.onItemSelected(database.findAll().get(position).getId());\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        if (mActivatedPosition != ListView.INVALID_POSITION) {\n            // Serialize and persist the activated item position.\n            outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);\n        }\n    }\n\n    /**\n     * Turns on activate-on-click mode. When this mode is on, list items will be\n     * given the 'activated' state when touched.\n     */\n    public void setActivateOnItemClick(boolean activateOnItemClick) {\n        // When setting CHOICE_MODE_SINGLE, ListView will automatically\n        // give items the 'activated' state when touched.\n        getListView().setChoiceMode(activateOnItemClick\n                ? ListView.CHOICE_MODE_SINGLE\n                : ListView.CHOICE_MODE_NONE);\n    }\n\n    private void setActivatedPosition(int position) {\n        if (position == ListView.INVALID_POSITION) {\n            getListView().setItemChecked(mActivatedPosition, false);\n        } else {\n            getListView().setItemChecked(position, true);\n        }\n\n        mActivatedPosition = position;\n    }\n}\n", "de available under the MIT License.\n\nCopyright (c) 2012 The Multiverse Foundation\n\nPermission is hereby granted, free of charge, to any person \nobtaining a copy of this software and associated documentation \nfiles (the \"Software\"), to deal in the Software without restriction, \nincluding without limitation the rights to use, copy, modify, \nmerge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software \nis furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be \nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE \nOR OTHER DEALINGS IN THE SOFTWARE.\n\n*********************************************************************/\n\npackage multiverse.server.engine;\n\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class PropertyMatcher implements Matcher\n{\n    public PropertyMatcher(SearchClause query)\n    {\n        queryProps = ((PropertySearch)query).getProperties();\n    }\n\n    public boolean match(Object object)\n    {\n        Map target = (Map) object;\n        if (target == null) {\n            if (queryProps.size() == 0)\n                return true;\n            else\n                return false;\n        }\n\n        for (Map.Entry queryProp : (Set<Map.Entry>) queryProps.entrySet()) {\n            Object queryKey = queryProp.getKey();\n            Object queryValue = queryProp.getValue();\n            Object targetValue = target.get(queryKey);\n            if (targetValue == null) {\n                if (! target.containsKey(queryKey) || queryValue != null)\n                    return false;\n            }\n            if (queryValue == null)\n                return false;\n            if (! targetValue.equals(queryValue))\n                return false;\n        }\n        return true;\n    }\n\n    public static class Factory implements MatcherFactory\n    {\n        public Factory()\n        {\n        }\n        \n        public Matcher createMatcher(SearchClause query)\n        {\n            return new PropertyMatcher(query);\n        }\n    }\n\n    private Map queryProps;\n}\n\n", ", The Pistoia Alliance\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n ******************************************************************************/\npackage org.helm.notation.demo.tools;\n\nimport org.helm.notation.tools.*;\n\n/**\n * \n * @author zhangtianhong\n */\npublic class PeptideSequenceParserSample {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString notation = PeptideSequenceParser.getNotation(\"AGG   seC   \");\n\t\t\tSystem.out.println(notation);\n\n\t\t\tnotation = PeptideSequenceParser\n\t\t\t\t\t.getNotation(\"AGG.seC.GGG.seC\", \".\");\n\t\t\tSystem.out.println(notation);\n\n\t\t\tnotation = PeptideSequenceParser.getNotation(\"AGG seC.seC.GGG.seC\",\n\t\t\t\t\t\".\");\n\t\t\tSystem.out.println(notation);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n", "", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.sql.v2014_04_01.implementation;\n\nimport com.microsoft.azure.arm.collection.InnerSupportsGet;\nimport com.microsoft.azure.arm.collection.InnerSupportsDelete;\nimport com.microsoft.azure.arm.collection.InnerSupportsListing;\nimport retrofit2.Retrofit;\nimport com.google.common.reflect.TypeToken;\nimport com.microsoft.azure.CloudException;\nimport com.microsoft.azure.management.sql.v2014_04_01.CheckNameAvailabilityRequest;\nimport com.microsoft.azure.management.sql.v2014_04_01.ServerUpdate;\nimport com.microsoft.azure.Page;\nimport com.microsoft.azure.PagedList;\nimport com.microsoft.rest.ServiceCallback;\nimport com.microsoft.rest.ServiceFuture;\nimport com.microsoft.rest.ServiceResponse;\nimport com.microsoft.rest.Validator;\nimport java.io.IOException;\nimport java.util.List;\nimport okhttp3.ResponseBody;\nimport retrofit2.http.Body;\nimport retrofit2.http.GET;\nimport retrofit2.http.Header;\nimport retrofit2.http.Headers;\nimport retrofit2.http.HTTP;\nimport retrofit2.http.PATCH;\nimport retrofit2.http.Path;\nimport retrofit2.http.POST;\nimport retrofit2.http.PUT;\nimport retrofit2.http.Query;\nimport retrofit2.Response;\nimport rx.functions.Func1;\nimport rx.Observable;\n\n/**\n * An instance of this class provides access to all the operations defined\n * in Servers.\n */\npublic class ServersInner implements InnerSupportsGet<ServerInner>, InnerSupportsDelete<Void>, InnerSupportsListing<ServerInner> {\n    /** The Retrofit service to perform REST calls. */\n    private ServersService service;\n    /** The service client containing this operation class. */\n    private SqlManagementClientImpl client;\n\n    /**\n     * Initializes an instance of ServersInner.\n     *\n     * @param retrofit the Retrofit instance built from a Retrofit Builder.\n     * @param client the instance of the service client containing this operation class.\n     */\n    public ServersInner(Retrofit retrofit, SqlManagementClientImpl client) {\n        this.service = retrofit.create(ServersService.class);\n        this.client = client;\n    }\n\n    /**\n     * The interface defining all the services for Servers to be\n     * used by Retrofit to perform actually REST calls.\n     */\n    interface ServersService {\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers checkNameAvailability\" })\n        @POST(\"subscriptions/{subscriptionId}/providers/Microsoft.Sql/checkNameAvailability\")\n        Observable<Response<ResponseBody>> checkNameAvailability(@Path(\"subscriptionId\") String subscriptionId, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Body CheckNameAvailabilityRequest parameters, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers list\" })\n        @GET(\"subscriptions/{subscriptionId}/providers/Microsoft.Sql/servers\")\n        Observable<Response<ResponseBody>> list(@Path(\"subscriptionId\") String subscriptionId, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers createOrUpdate\" })\n        @PUT(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\")\n        Observable<Response<ResponseBody>> createOrUpdate(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Body ServerInner parameters, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers update\" })\n        @PATCH(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\")\n        Observable<Response<ResponseBody>> update(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Body ServerUpdate parameters, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers delete\" })\n        @HTTP(path = \"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\", method = \"DELETE\", hasBody = true)\n        Observable<Response<ResponseBody>> delete(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers getByResourceGroup\" })\n        @GET(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\")\n        Observable<Response<ResponseBody>> getByResourceGroup(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers listByResourceGroup\" })\n        @GET(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers\")\n        Observable<Response<ResponseBody>> listByResourceGroup(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the CheckNameAvailabilityResponseInner object if successful.\n     */\n    public CheckNameAvailabilityResponseInner checkNameAvailability(String name) {\n        return checkNameAvailabilityWithServiceResponseAsync(name).toBlocking().single().body();\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<CheckNameAvailabilityResponseInner> checkNameAvailabilityAsync(String name, final ServiceCallback<CheckNameAvailabilityResponseInner> serviceCallback) {\n        return ServiceFuture.fromResponse(checkNameAvailabilityWithServiceResponseAsync(name), serviceCallback);\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the CheckNameAvailabilityResponseInner object\n     */\n    public Observable<CheckNameAvailabilityResponseInner> checkNameAvailabilityAsync(String name) {\n        return checkNameAvailabilityWithServiceResponseAsync(name).map(new Func1<ServiceResponse<CheckNameAvailabilityResponseInner>, CheckNameAvailabilityResponseInner>() {\n            @Override\n            public CheckNameAvailabilityResponseInner call(ServiceResponse<CheckNameAvailabilityResponseInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the CheckNameAvailabilityResponseInner object\n     */\n    public Observable<ServiceResponse<CheckNameAvailabilityResponseInner>> checkNameAvailabilityWithServiceResponseAsync(String name) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"Parameter name is required and cannot be null.\");\n        }\n        CheckNameAvailabilityRequest parameters = new CheckNameAvailabilityRequest();\n        parameters.withName(name);\n        return service.checkNameAvailability(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), parameters, this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CheckNameAvailabilityResponseInner>>>() {\n                @Override\n                public Observable<ServiceResponse<CheckNameAvailabilityResponseInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<CheckNameAvailabilityResponseInner> clientResponse = checkNameAvailabilityDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<CheckNameAvailabilityResponseInner> checkNameAvailabilityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<CheckNameAvailabilityResponseInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<CheckNameAvailabilityResponseInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @return the PagedList<ServerInner> object if successful.\n     */\n    public PagedList<ServerInner> list() {\n        PageImpl<ServerInner> page = new PageImpl<>();\n        page.setItems(listWithServiceResponseAsync().toBlocking().single().body());\n        page.setNextPageLink(null);\n        return new PagedList<ServerInner>(page) {\n            @Override\n            public Page<ServerInner> nextPage(String nextPageLink) {\n                return null;\n            }\n        };\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<List<ServerInner>> listAsync(final ServiceCallback<List<ServerInner>> serviceCallback) {\n        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<Page<ServerInner>> listAsync() {\n        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ServerInner>>, Page<ServerInner>>() {\n            @Override\n            public Page<ServerInner> call(ServiceResponse<List<ServerInner>> response) {\n                PageImpl<ServerInner> page = new PageImpl<>();\n                page.setItems(response.body());\n                return page;\n            }\n        });\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<ServiceResponse<List<ServerInner>>> listWithServiceResponseAsync() {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServerInner>>>>() {\n                @Override\n                public Observable<ServiceResponse<List<ServerInner>>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<PageImpl<ServerInner>> result = listDelegate(response);\n                        List<ServerInner> items = null;\n                        if (result.body() != null) {\n                            items = result.body().items();\n                        }\n                        ServiceResponse<List<ServerInner>> clientResponse = new ServiceResponse<List<ServerInner>>(items, result.response());\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<PageImpl<ServerInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<PageImpl<ServerInner>, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<PageImpl<ServerInner>>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the ServerInner object if successful.\n     */\n    public ServerInner createOrUpdate(String resourceGroupName, String serverName, ServerInner parameters) {\n        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters).toBlocking().single().body();\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<ServerInner> createOrUpdateAsync(String resourceGroupName, String serverName, ServerInner parameters, final ServiceCallback<ServerInner> serviceCallback) {\n        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters), serviceCallback);\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServerInner> createOrUpdateAsync(String resourceGroupName, String serverName, ServerInner parameters) {\n        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters).map(new Func1<ServiceResponse<ServerInner>, ServerInner>() {\n            @Override\n            public ServerInner call(ServiceResponse<ServerInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServiceResponse<ServerInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String serverName, ServerInner parameters) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        if (parameters == null) {\n            throw new IllegalArgumentException(\"Parameter parameters is required and cannot be null.\");\n        }\n        Validator.validate(parameters);\n        return service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServerInner>>>() {\n                @Override\n                public Observable<ServiceResponse<ServerInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<ServerInner> clientResponse = createOrUpdateDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<ServerInner> createOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<ServerInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<ServerInner>() { }.getType())\n                .register(201, new TypeToken<ServerInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the ServerInner object if successful.\n     */\n    public ServerInner update(String resourceGroupName, String serverName, ServerUpdate parameters) {\n        return updateWithServiceResponseAsync(resourceGroupName, serverName, parameters).toBlocking().single().body();\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<ServerInner> updateAsync(String resourceGroupName, String serverName, ServerUpdate parameters, final ServiceCallback<ServerInner> serviceCallback) {\n        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, serverName, parameters), serviceCallback);\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServerInner> updateAsync(String resourceGroupName, String serverName, ServerUpdate parameters) {\n        return updateWithServiceResponseAsync(resourceGroupName, serverName, parameters).map(new Func1<ServiceResponse<ServerInner>, ServerInner>() {\n            @Override\n            public ServerInner call(ServiceResponse<ServerInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServiceResponse<ServerInner>> updateWithServiceResponseAsync(String resourceGroupName, String serverName, ServerUpdate parameters) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        if (parameters == null) {\n            throw new IllegalArgumentException(\"Parameter parameters is required and cannot be null.\");\n        }\n        Validator.validate(parameters);\n        return service.update(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServerInner>>>() {\n                @Override\n                public Observable<ServiceResponse<ServerInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<ServerInner> clientResponse = updateDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<ServerInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<ServerInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<ServerInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     */\n    public void delete(String resourceGroupName, String serverName) {\n        deleteWithServiceResponseAsync(resourceGroupName, serverName).toBlocking().single().body();\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String serverName, final ServiceCallback<Void> serviceCallback) {\n        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, serverName), serviceCallback);\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceResponse} object if successful.\n     */\n    public Observable<Void> deleteAsync(String resourceGroupName, String serverName) {\n        return deleteWithServiceResponseAsync(resourceGroupName, serverName).map(new Func1<ServiceResponse<Void>, Void>() {\n            @Override\n            public Void call(ServiceResponse<Void> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceResponse} object if successful.\n     */\n    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String serverName) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.delete(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {\n                @Override\n                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<Void> clientResponse = deleteDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<Void>() { }.getType())\n                .register(204, new TypeToken<Void>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the ServerInner object if successful.\n     */\n    public ServerInner getByResourceGroup(String resourceGroupName, String serverName) {\n        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, serverName).toBlocking().single().body();\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<ServerInner> getByResourceGroupAsync(String resourceGroupName, String serverName, final ServiceCallback<ServerInner> serviceCallback) {\n        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, serverName), serviceCallback);\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServerInner> getByResourceGroupAsync(String resourceGroupName, String serverName) {\n        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, serverName).map(new Func1<ServiceResponse<ServerInner>, ServerInner>() {\n            @Override\n            public ServerInner call(ServiceResponse<ServerInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServiceResponse<ServerInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String serverName) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServerInner>>>() {\n                @Override\n                public Observable<ServiceResponse<ServerInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<ServerInner> clientResponse = getByResourceGroupDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<ServerInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<ServerInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<ServerInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @return the PagedList<ServerInner> object if successful.\n     */\n    public PagedList<ServerInner> listByResourceGroup(String resourceGroupName) {\n        PageImpl<ServerInner> page = new PageImpl<>();\n        page.setItems(listByResourceGroupWithServiceResponseAsync(resourceGroupName).toBlocking().single().body());\n        page.setNextPageLink(null);\n        return new PagedList<ServerInner>(page) {\n            @Override\n            public Page<ServerInner> nextPage(String nextPageLink) {\n                return null;\n            }\n        };\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<List<ServerInner>> listByResourceGroupAsync(String resourceGroupName, final ServiceCallback<List<ServerInner>> serviceCallback) {\n        return ServiceFuture.fromResponse(listByResourceGroupWithServiceResponseAsync(resourceGroupName), serviceCallback);\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<Page<ServerInner>> listByResourceGroupAsync(String resourceGroupName) {\n        return listByResourceGroupWithServiceResponseAsync(resourceGroupName).map(new Func1<ServiceResponse<List<ServerInner>>, Page<ServerInner>>() {\n            @Override\n            public Page<ServerInner> call(ServiceResponse<List<ServerInner>> response) {\n                PageImpl<ServerInner> page = new PageImpl<>();\n                page.setItems(response.body());\n                return page;\n            }\n        });\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<ServiceResponse<List<ServerInner>>> listByResourceGroupWithServiceResponseAsync(String resourceGroupName) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.listByResourceGroup(this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServerInner>>>>() {\n                @Override\n                public Observable<ServiceResponse<List<ServerInner>>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<PageImpl<ServerInner>> result = listByResourceGroupDelegate(response);\n                        List<ServerInner> items = null;\n                        if (result.body() != null) {\n                            items = result.body().items();\n                        }\n                        ServiceResponse<List<ServerInner>> clientResponse = new ServiceResponse<List<ServerInner>>(items, result.response());\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<PageImpl<ServerInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<PageImpl<ServerInner>, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<PageImpl<ServerInner>>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n}\n", "pe;\nimport javax.persistence.Enumerated;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\n\nimport se.ifkgoteborg.stat.model.enums.MinorHorizontalAlignment;\nimport se.ifkgoteborg.stat.model.enums.MinorVerticalAlignment;\nimport se.ifkgoteborg.stat.model.enums.Side;\n\n@Entity\n@Table(name=\"position\")\npublic class Position {\n\t\n\t@Id\n\t@GeneratedValue\n\tprivate Long id;\n\n\tprivate String name;\n\t\n\tprivate String code;\n\t\n\t@Enumerated(value=EnumType.STRING)\n\tprivate Side side;\n\n\t@ManyToOne\n\tprivate PositionType positionType;\n\n\t@Enumerated(value=EnumType.STRING)\n\tprivate MinorVerticalAlignment minorVerticalAlignment = MinorVerticalAlignment.NEUTRAL;\n\n\t@Enumerated(value=EnumType.STRING)\n\tprivate MinorHorizontalAlignment minorHorizontalAlignment = MinorHorizontalAlignment.NEUTRAL;\n\t\n\tpublic Position() {}\n\t\n\tpublic Position(String name, String code, Side side, PositionType positionType) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t}\n\t\n\tpublic Position(String name, String code, Side side, PositionType positionType, MinorVerticalAlignment minorVerticalAlignment) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t\tthis.minorVerticalAlignment = minorVerticalAlignment;\n\t}\n\n\tpublic Position(String name, String code, Side side, PositionType positionType, MinorHorizontalAlignment minorHorizontalAlignment) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t\tthis.minorHorizontalAlignment = minorHorizontalAlignment;\n\t}\n\n\tpublic Position(String name, String code, Side side, PositionType positionType, MinorVerticalAlignment minorVerticalAlignment, MinorHorizontalAlignment minorHorizontalAlignment) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t\tthis.minorVerticalAlignment = minorVerticalAlignment;\n\t\tthis.minorHorizontalAlignment = minorHorizontalAlignment;\n\t}\n\n\tpublic Long getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(Long id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\tpublic Side getSide() {\n\t\treturn side;\n\t}\n\tpublic void setSide(Side side) {\n\t\tthis.side = side;\n\t}\n\n\tpublic PositionType getPositionType() {\n\t\treturn positionType;\n\t}\n\n\tpublic void setPositionType(PositionType positionType) {\n\t\tthis.positionType = positionType;\n\t}\n\t\n\t\n\n\tpublic MinorVerticalAlignment getMinorVerticalAlignment() {\n\t\treturn minorVerticalAlignment;\n\t}\n\n\tpublic void setMinorVerticalAlignment(\n\t\t\tMinorVerticalAlignment minorVerticalAlignment) {\n\t\tthis.minorVerticalAlignment = minorVerticalAlignment;\n\t}\n\n\tpublic MinorHorizontalAlignment getMinorHorizontalAlignment() {\n\t\treturn minorHorizontalAlignment;\n\t}\n\n\tpublic void setMinorHorizontalAlignment(\n\t\t\tMinorHorizontalAlignment minorHorizontalAlignment) {\n\t\tthis.minorHorizontalAlignment = minorHorizontalAlignment;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((id == null) ? 0 : id.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPosition other = (Position) obj;\n\t\tif (id == null) {\n\t\t\tif (other.id != null)\n\t\t\t\treturn false;\n\t\t} else if (!id.equals(other.id))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.name;\n\t}\n\t\n\t\n\t\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.apimanagement.v2019_12_01.implementation;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Network Status in the Location.\n */\npublic class NetworkStatusContractByLocationInner {\n    /**\n     * Location of service.\n     */\n    @JsonProperty(value = \"location\")\n    private String location;\n\n    /**\n     * Network status in Location.\n     */\n    @JsonProperty(value = \"networkStatus\")\n    private NetworkStatusContractInner networkStatus;\n\n    /**\n     * Get location of service.\n     *\n     * @return the location value\n     */\n    public String location() {\n        return this.location;\n    }\n\n    /**\n     * Set location of service.\n     *\n     * @param location the location value to set\n     * @return the NetworkStatusContractByLocationInner object itself.\n     */\n    public NetworkStatusContractByLocationInner withLocation(String location) {\n        this.location = location;\n        return this;\n    }\n\n    /**\n     * Get network status in Location.\n     *\n     * @return the networkStatus value\n     */\n    public NetworkStatusContractInner networkStatus() {\n        return this.networkStatus;\n    }\n\n    /**\n     * Set network status in Location.\n     *\n     * @param networkStatus the networkStatus value to set\n     * @return the NetworkStatusContractByLocationInner object itself.\n     */\n    public NetworkStatusContractByLocationInner withNetworkStatus(NetworkStatusContractInner networkStatus) {\n        this.networkStatus = networkStatus;\n        return this;\n    }\n\n}\n", "NonNull;\nimport androidx.annotation.Nullable;\n\nimport com.bukhmastov.cdoitmo.model.JsonEntity;\nimport com.bukhmastov.cdoitmo.network.handlers.RestResponseHandler;\nimport com.bukhmastov.cdoitmo.network.model.Client;\nimport com.bukhmastov.cdoitmo.network.model.DeIfmo;\n\nimport java.util.Map;\n\npublic abstract class DeIfmoRestClient extends DeIfmo {\n\n    public DeIfmoRestClient() {\n        super();\n    }\n\n    public abstract <T extends JsonEntity> void get(@NonNull Context context, @NonNull String url,\n                            @Nullable Map<String, String> query, @NonNull RestResponseHandler<T> handler);\n\n    public abstract <T extends JsonEntity> void get(@NonNull Context context,\n                            @NonNull @Client.Protocol String protocol, @NonNull String url,\n                            @Nullable Map<String, String> query, @NonNull RestResponseHandler<T> handler);\n}\n", "ing[] args) \r\n\t{\r\n\t\tController controller = new Controller();\r\n\t\t\r\n\t\t//if command line arg has -a\r\n\t\tcontroller.ArchiveData();\r\n\t\t\r\n\t\t//if command line arg has -b\r\n\t\tcontroller.BuildDatabase();\r\n\t\t\r\n\t\t//if command line arg has -p\r\n\t\tcontroller.ProcessNeuralNetworks();\r\n\t}\r\n}\r\n", "ork.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\nimport java.util.List;\nimport java.util.Optional;\nimport java.time.Instant;\n\n/**\n * Spring Data JPA repository for the User entity.\n */\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    Optional<User> findOneByActivationKey(String activationKey);\n\n    List<User> findAllByActivatedIsFalseAndCreatedDateBefore(Instant dateTime);\n\n    Optional<User> findOneByResetKey(String resetKey);\n\n    Optional<User> findOneByEmail(String email);\n\n    Optional<User> findOneByLogin(String login);\n\n    @EntityGraph(attributePaths = \"authorities\")\n    User findOneWithAuthoritiesById(Long id);\n\n    @EntityGraph(attributePaths = \"authorities\")\n    Optional<User> findOneWithAuthoritiesByLogin(String login);\n\n    Page<User> findAllByLoginNot(Pageable pageable, String login);\n}\n", "public class ComputerPrice {\n\n\n    public void displayStoreComputerPrice() {\n\n        //int computerPrice [] = new int[5];\n\n        int[] computerPrices = {50, 100, 900, 1500, 600};\n\n        for (int StorePrice : computerPrices) {\n            System.out.println(StorePrice);\n\n        }\n\n\n    }public void displayOnlineComputerPrice() {\n            double [] price = {100.00, 200.00, 375.00, 1600.75, 655.99};\n            System.out.println(price[3]);\n            double[] price1 = price.clone();\n            double[] price2 = Arrays.copyOf(price, 3);\n\n    }\n\n\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\nimport java.nio.channels.spi.AsynchronousChannelProvider;\n\npublic class CheckProvider {\n    public static void main(String[] args) {\n        Class<?> c = AsynchronousChannelProvider.provider().getClass();\n\n        String expected = args[0];\n        String actual = c.getName();\n\n        if (!actual.equals(expected))\n            throw new RuntimeException(\"Provider is of type '\" + actual +\n                \"', expected '\" + expected + \"'\");\n\n    }\n}\n", "ft.util.math.Vec3d;\nimport net.minecraft.world.DimensionType;\nimport net.minecraft.world.WorldProvider;\nimport net.minecraft.world.biome.BiomeProviderSingle;\nimport net.minecraft.world.gen.IChunkGenerator;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\nimport sblectric.lightningcraft.init.LCBiomes;\nimport sblectric.lightningcraft.init.LCDimensions;\n\n/** The Underworld world provider */\npublic class LCWorldProviderUnderworld extends WorldProvider {\n\t\n\tpublic static final Vec3d skyFogColor = new Vec3d(0.085D, 0.085D, 0.085D);\n\t\n\t@Override\n\tpublic void init() {\n\t\tthis.biomeProvider = new BiomeProviderSingle(LCBiomes.underworld);\n\t\tthis.setDimension(LCDimensions.underworldID);\n\t\tthis.hasSkyLight = false;\n\t\t//this.isHellWorld = false; // place some water bruh\n\t}\n\t\n\t@Override\n\tpublic IChunkGenerator createChunkGenerator() {\n\t\treturn new ChunkProviderUnderworld(this.world, this.world.getSeed());\n\t}\n\t\n\t@Override\n\tpublic int getActualHeight() {\n        return ChunkProviderUnderworld.chunkHeight;\n    }\n\t\n\t/** Preload 3x3 chunks on player arrival */\n//\t@Override\n//    public void onPlayerAdded(EntityPlayerMP p) {\n//\t\tint cx = ((int)p.posX) >> 4;\n//\t\tint cz = ((int)p.posZ) >> 4;\n//\t\tfor(int x = cx - 1; x <= cx + 1; x++) {\n//\t\t\tfor(int z = cz - 1; z <= cz + 1; z++) {\n//\t\t\t\tthis.worldObj.getChunkProvider().provideChunk(x, z);\n//\t\t\t}\n//\t\t}\n//    }\n\t\n\t/**\n\t * Sky color: dark\n\t */\n\t@Override\n\t@SideOnly(Side.CLIENT)\n    public Vec3d getSkyColor(Entity cameraEntity, float partialTicks) {\n\t\treturn skyFogColor;\n    }\n\t\n\t/**\n     * Biome fog color: dark\n     */\n    @Override\n\t@SideOnly(Side.CLIENT)\n    public Vec3d getFogColor(float par1, float par2) {\n    \treturn skyFogColor;\n    }\n\n    /**\n     * Creates the light to brightness table\n     */\n    @Override\n    protected void generateLightBrightnessTable() {\n        float f = 0.1F;\n\n        for (int i = 0; i <= 15; ++i)\n        {\n            float f1 = 1.0F - i / 15.0F;\n            this.lightBrightnessTable[i] = (1.0F - f1) / (f1 * 3.0F + 1.0F) * (1.0F - f) + f;\n        }\n    }\n\t\n    /**\n     * Returns 'true' if in the \"main surface world\", but 'false' if in the Nether or End dimensions.\n     */\n    @Override\n    public boolean isSurfaceWorld() {\n        return false;\n    }\n    \n    /**\n     * Calculates the angle of sun and moon in the sky relative to a specified time (usually worldTime)\n     */\n    @Override\n    public float calculateCelestialAngle(long par1, float par3) {\n        return 0.5F;\n    }\n\n    /**\n     * True if the player can respawn in this dimension (true = overworld, false = nether).\n     */\n    @Override\n    public boolean canRespawnHere() {\n        return false;\n    }\n\n    /**\n     * Returns true if the given X,Z coordinate should show environmental fog.\n     */\n    @SideOnly(Side.CLIENT)\n    @Override\n    public boolean doesXZShowFog(int par1, int par2) {\n        return true;\n    }\n\n\t@Override\n\tpublic DimensionType getDimensionType() {\n\t\treturn LCDimensions.UNDERWORLD_TYPE;\n\t}\t\n\t\n}\n", "ult[] = rowSums(arr2d);\n\t\tprintRow(result);\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tfor (int j = i+1; j < result.length; j++) {\n\t\t\t\tif (result[i] == result[j])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static int arraySum(int[] arr1) {\n\t\tint rv = 0;\n\t\tfor (int i = 0; i < arr1.length; i++) {\n\t\t\trv += arr1[i];\n\t\t}\n\t\treturn rv;\n\t}\n\n\tpublic static int[] rowSums(int arr2D[][]) {\n\t\tint [] rv = new int[arr2D.length];\n\t\tfor (int i = 0; i < arr2D.length; i++) {\n\t\t\trv[i] = arraySum(arr2D[i]);\n\t\t}\n\t\treturn rv;\n\t}\n\n\tpublic static void solveExamProblem() {\n\t\tint arr1[] = {1, 3, 2, 7, 3};\n\t\tSystem.out.println(arraySum(arr1));\n\t\tint arr2D[][] = {\n\t\t\t\t{1, 3, 2, 7, 3},\n\t\t\t\t{10, 10, 4, 6, 2},\n\t\t\t\t{5, 3, 5, 9, 6},\n\t\t\t\t{7, 6, 4, 2, 1}\n\t\t};\n\t\tint result[] = rowSums(arr2D);\n\t\tprintRow(result);\n\t\tif (isDiverse(arr2D)) {\n\t\t\tSystem.out.println(\"Array is diverse\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Array is NOT diverse\");\n\t\t}\n\n\t\tint mat2[][] = {\n\t\t\t\t{1, 1, 5, 3, 4},\n\t\t\t\t{12, 7, 6, 1, 9},\n\t\t\t\t{8, 11, 10, 2, 5},\n\t\t\t\t{3, 2, 3, 0, 6}\n\t\t};\n\t\tif (isDiverse(mat2)) {\n\t\t\tSystem.out.println(\"Array is diverse\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Array is NOT diverse\");\n\t\t}\n\n\t}\n\n\tpublic static void printRow(int b[]) {\n\t\tSystem.out.print(\"|\");\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tSystem.out.print(String.format(\"%4d |\", b[i]));\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n\tpublic static void printArray(int b[][]) {\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tprintRow(b[i]);\n\t\t}\n\t}\n    public static void main(String[] args) {\n\t\tif (false) {\n\t\t\tint a[] = new int[10];\n\t\t\tSystem.out.println(a.length);\n\n\t\t\tint b[][] = new int[10][10];\n\t\t\tSystem.out.println(\"Dimensions are \" + b.length + \"x\" + b[0].length);\n\t\t\tfor (int row = 0; row < b.length; row++) {\n\t\t\t\tfor (int col = 0; col < b[row].length; col++) {\n\t\t\t\t\tb[row][col] = (row + 1) * (col + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintArray(b);\n\t\t}\n\t\tif (false)\n\t\t    solveExamProblem();\n\n\t\tPerson p = new Person(\"Shivani\", \"Shimpi\");\n\t\tSystem.out.println(p);\n\t\tPerson[][] people = new Person[2][4];\n\t\tpeople[0][0] = new Person(\"Shashank\", \"Shimpi\");\n\t\tpeople[0][1] = new Person(\"Deepali\", \"Shimpi\");\n\t\tpeople[0][2] = p;\n\t\tpeople[0][3] = new Person(\"Shivam\", \"Shimpi\");\n\n\t\tpeople[1][0] = new Person(\"Prasad\", \"Gharpure\");\n\t\tpeople[1][1] = new Person(\"Geeta\", \"Agashe\");\n\t\tpeople[1][2] = new Person(\"Akshay\", \"Gharpure\");\n\t\tpeople[1][3] = new Person(\"Shreeya\", people[1][0].getLastname());\n\n\t\tfor (int family=0; family < people.length; family ++) {\n            System.out.println(\"The \" + people[family][0].getLastname() + \" Family\");\n            System.out.println(\"--------------------------------------\");\n\t\t    for (int i = 0; i < people[family].length; i++) {\n                System.out.println(\"\\t\" + people[family][i].toString());\n            }\n            System.out.println(\"--------------------------------------\\n\");\n        }\n\n    }\n}\n", ";\n\nimport javax.persistence.Embeddable;\n\n/**\n * Note that we have {@code @Embeddable} annotation here and NO id element.\n * This means that new table will not be created in DB\n *\n * Take note that we must implement hashCode/equals for for Ingredient and Pizza in order to allow hibernate\n * to determine what exactly ingredients should be deleted.\n */\n@Embeddable\npublic class Ingredient {\n    private String name;\n\n    @Parent\n    private Pizza pizza;\n\n    public Ingredient() {}\n    public Ingredient(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Pizza getPizza() {\n        return pizza;\n    }\n\n    public void setPizza(Pizza pizza) {\n        this.pizza = pizza;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Ingredient)) return false;\n\n        Ingredient that = (Ingredient) o;\n\n        if (name != null ? !name.equals(that.name) : that.name != null) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = name != null ? name.hashCode() : 0;\n        result = 31 * result;\n        return result;\n    }\n\n}\n", "\n/*\n * EDACCResultCodeDlg.java\n *\n * Created on 03.12.2012, 17:17:48\n */\n\npackage edacc;\n\nimport edacc.manageDB.ManageDBResultCodes;\nimport java.sql.SQLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JOptionPane;\n\n/**\n *\n * @author dgall\n */\npublic class EDACCResultCodeDlg extends javax.swing.JDialog {\n\n    /** Creates new form EDACCResultCodeDlg */\n    public EDACCResultCodeDlg(java.awt.Frame parent, boolean modal) {\n        super(parent, modal);\n        initComponents();\n        setLocationRelativeTo(parent);\n    }\n\n    /** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        lResultCode = new javax.swing.JLabel();\n        lDescription = new javax.swing.JLabel();\n        tfDescription = new javax.swing.JTextField();\n        bSave = new javax.swing.JButton();\n        bCancel = new javax.swing.JButton();\n        tfResultCode = new javax.swing.JTextField();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(edacc.EDACCApp.class).getContext().getResourceMap(EDACCResultCodeDlg.class);\n        setTitle(resourceMap.getString(\"ResultCodeDlg.title\")); // NOI18N\n        setName(\"ResultCodeDlg\"); // NOI18N\n\n        lResultCode.setText(resourceMap.getString(\"lResultCode.text\")); // NOI18N\n        lResultCode.setName(\"lResultCode\"); // NOI18N\n\n        lDescription.setText(resourceMap.getString(\"lDescription.text\")); // NOI18N\n        lDescription.setName(\"lDescription\"); // NOI18N\n\n        tfDescription.setText(resourceMap.getString(\"tfDescription.text\")); // NOI18N\n        tfDescription.setName(\"tfDescription\"); // NOI18N\n        tfDescription.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                tfDescriptionActionPerformed(evt);\n            }\n        });\n\n        bSave.setLabel(resourceMap.getString(\"bSave.label\")); // NOI18N\n        bSave.setName(\"bSave\"); // NOI18N\n        bSave.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                bSaveActionPerformed(evt);\n            }\n        });\n\n        bCancel.setLabel(resourceMap.getString(\"bCancel.label\")); // NOI18N\n        bCancel.setName(\"bCancel\"); // NOI18N\n        bCancel.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                bCancelActionPerformed(evt);\n            }\n        });\n\n        tfResultCode.setText(resourceMap.getString(\"tfResultCode.text\")); // NOI18N\n        tfResultCode.setName(\"tfResultCode\"); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(lResultCode)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(tfResultCode, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(lDescription)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(tfDescription, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(bSave)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(bCancel)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lResultCode)\n                    .addComponent(tfResultCode, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lDescription)\n                    .addComponent(tfDescription, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(bCancel)\n                    .addComponent(bSave))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void bSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bSaveActionPerformed\n        try {\n            int code = Integer.parseInt(tfResultCode.getText());\n            String description = tfDescription.getText();\n            ManageDBResultCodes.getInstance().saveNewCode(code, description);\n            dispose();\n        } catch (SQLException ex) {\n            JOptionPane.showMessageDialog(this,\n                    \"Error while saving ResultCode to DB: \" + ex.getMessage(),\n                    \"Error while saving\", JOptionPane.ERROR_MESSAGE);\n        } catch (NumberFormatException ex) {\n            JOptionPane.showMessageDialog(this,\n                    \"Error while saving ResultCode to DB: ResultCode must be a \"\n                    + \"number!\",\n                    \"Error while saving\", JOptionPane.ERROR_MESSAGE);\n            tfResultCode.selectAll();\n            tfResultCode.requestFocusInWindow();\n        } catch (Exception ex) {\n            JOptionPane.showMessageDialog(this,\n                    \"Error while saving ResultCode: \" + ex.getMessage(),\n                    \"Error while saving\", JOptionPane.ERROR_MESSAGE);\n        } \n    }//GEN-LAST:event_bSaveActionPerformed\n\n    private void bCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bCancelActionPerformed\n        this.dispose();\n    }//GEN-LAST:event_bCancelActionPerformed\n\n    private void tfDescriptionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tfDescriptionActionPerformed\n        bSaveActionPerformed(evt);\n    }//GEN-LAST:event_tfDescriptionActionPerformed\n\n    @Override\n    public void setVisible(boolean v) {\n        super.setVisible(v);\n        clearForm();\n    }\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JButton bCancel;\n    private javax.swing.JButton bSave;\n    private javax.swing.JLabel lDescription;\n    private javax.swing.JLabel lResultCode;\n    private javax.swing.JTextField tfDescription;\n    private javax.swing.JTextField tfResultCode;\n    // End of variables declaration//GEN-END:variables\n\n    private void clearForm() {\n        tfResultCode.setText(\"\");\n        tfDescription.setText(\"\");\n    }\n\n}\n", "pl.jena.rdf.model.*;\n\n\npublic class EMAILRDF {\n\t//Create a default model\n    private static Model m = ModelFactory.createDefaultModel();\n    \n    //Subject of the mail\n    public static final Property MSGID = m.createProperty(\"MESSAGEID:\" );\n    public static final Property MAILID = m.createProperty(\"MAILID:\" );\n    public static final Property SUBJECT = m.createProperty(\"SUB:\" );\n\t//Sender of the mail\n\tpublic static final Property FROM = m.createProperty(\"FROM:\" );\n\tpublic static final Property FROMFULL = m.createProperty(\"FROMFULL:\" );\n\tpublic static final Property TOFULL = m.createProperty(\"TOFULL:\" );\n\tpublic static final Property EMAILID = m.createProperty(\"EMAILID:\" );\n\t//Receiver of the mail\n\tpublic static final Property TO  = m.createProperty(\"TO:\" );\n\t//Return path\n\tpublic static final Property RETURN_PATH = m.createProperty(\"RETURNPATH:\" );\n\t//main contents of the mail\n\tpublic static final Property CONTENT = m.createProperty(\"CONTENT:\" );\n\t//format of the mail\n\tpublic static final Property FORMAT = m.createProperty(\"FORMAT:\" );\t\n\t//content type like html etc\n\tpublic static final Property CONTENT_TYPE = m.createProperty(\"CONTENTTYPE:\" );\n\t//encoding in bits\n\tpublic static final Property ENCODING = m.createProperty(\"ENCODING:\" );\n\t//date of the email\n\tpublic static final Property DATE = m.createProperty(\"DATE:\" );   \t \n\t//CC of email\t\n\tpublic static final Property CC = m.createProperty(\"CC:\" ); \n\t//BCC of email\t\n\tpublic static final Property BCC = m.createProperty(\"BCC:\" ); \n\t//NAME OF THE SENDER\n\tpublic static final Property ATTACHEMENT_NAME = m.createProperty(\"ATTACHEMENTNAME:\" );\n\tpublic static final Property ATTACHEMENT_NO = m.createProperty(\"ATTACHEMENTNO:\" );   \n\t//SIZE OF MAIL\t\n\tpublic static final Property MAIL_SIZE = m.createProperty(\"MAILSIZE:\" );   \n\t//SIZE OF THE ATTACHEMENT of email\t\n\tpublic static final Property ATTACHEMENT_SIZE = m.createProperty(\"ATTACHEMENTSIZE:\" );   \n\t//MAIL TO WHICH PARTICULAR MAIL HAVE REPLIED \t\n\tpublic static final Property IN_REPLYTO = m.createProperty(\"REPLIEDTO:\" );\n\tpublic static final Property IN_REPLYTONAME = m.createProperty(\"REPLIEDTONAME:\" );\n\t//FOLDER IN WHICH email EXISTS\t\n\tpublic static final Property FOLDER_NAME = m.createProperty(\"FOLDERNAME:\" );   \n\t//UID of email\t\n\tpublic static final Property UID = m.createProperty(\"UID:\" );   \n   //name os receiver of email\t\n\tpublic static final Property REC_NAME = m.createProperty(\"RECIEVERS_NAME:\" );   \n   //name of sender of email\t\n\tpublic static final Property SEND_NAME = m.createProperty(\"SENDERNAME:\" );   \n   \n    \n\n\n\n   }\n   \n", "\tprivate typeEnum type;\n\tpublic static enum typeEnum {\n\t    Chat, //indicates that there is \n\t    EntityUpdated,\n\t    error\n\t}\n\t\n\t/**\n\t * Construct a new Message object from the b64 encoded response from the server. Must have already been split. \n\t * First character will indicate the Type, and the rest will be stored as the content.\n\t * @param rawReceived\n\t */\n\tMessage(String rawReceived)\n\t{\n\t\t\n\t\tswitch(stringToType(rawReceived))\n\t\t{\n\t\tcase Chat:\n\t\t\ttype = Message.typeEnum.Chat;\n\t\t\tcontent = rawReceived.substring(1);//char 1 to the end\n\t\t\tbreak;\n\t\tcase EntityUpdated:\n\t\t\ttype = Message.typeEnum.EntityUpdated;\n\t\t\tcontent = rawReceived.substring(1);//char 1 to the end\n\t\t\tbreak;\n\t\tcase error:\n\t\tdefault:\n\t\t\tbreak;//error!\n\t\t}\n\t}\n\t\n\t/**\n\t * Construct a new Message object to be sent from a b64 encoded content string and a typeEnum. \n\t * First character will indicate the Type, and the rest will be stored as the content.\n\t * @param rawReceived\n\t */\n\tMessage(typeEnum t, String c)\n\t{\n\t\tthis.type = t;\n\t\tthis.content = c;\n\t}\n\t\n\t\n\tpublic typeEnum getType()\n\t{\n\t\treturn type;\n\t}\n\t\n\tpublic String getStringContentFromB64()\n\t{\n\t\treturn Base64Coder.decodeString(content);\n\t}\n\t\n\tpublic byte[] getBytesContentFromB64()\n\t{\n\t\treturn Base64Coder.decode(content);\n\t}\n\t\n\t/**\n\t * Use toString to generate the string to send to the server.\n\t */\n\tpublic String toString()\n\t{\n\t\treturn typeToString(type)+content;\n\t}\n\t\n\t/**\n\t * Convert a 1-long string to a typeEnum\n\t * @param s\n\t * @return\n\t */\n\tprivate static typeEnum stringToType(String s)\n\t{\n\t\treturn charToType(s.charAt(0));\n\t}\n\t\n\t/**\n\t * Convert a char string to a typeEnum\n\t * @param s\n\t * @return\n\t */\n\tprivate static typeEnum charToType(char c)\n\t{\n\t\tswitch(c)\n\t\t{\n\t\tcase 'c':\n\t\t\treturn Message.typeEnum.Chat;\n\t\tcase 'e':\n\t\t\treturn Message.typeEnum.EntityUpdated;\n\t\tdefault:\n\t\t\t//error!!!!\n\t\t\tSystem.out.println(\"Invalid Message type. Received: '\"+c+\"'\");\n\t\t\treturn Message.typeEnum.error;\n\t\t}\n\t}\n\t\n\t/**\n\t * convert a typeEnum to it's string equivalent\n\t * @param t\n\t * @return\n\t */\n\tprivate static String typeToString(typeEnum t)\n\t{\n\t\tswitch(t)\n\t\t{\n\t\tcase Chat:\n\t\t\treturn \"c\";\n\t\tcase EntityUpdated:\n\t\t\treturn \"e\";\n\t\tdefault:\n\t\t\t//error!!!!\n\t\t\tSystem.out.println(\"Invalid Message type. Received: '\"+t+\"'\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic static Message MessageFactoryStringToB64(typeEnum t, String real)\n\t{\n\t\treturn new Message(t, Base64Coder.encodeString(real));\n\t}\n\t\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/** Java interface \"ContactInfoListIterator.java\" generated from Poseidon for UML.\n *  Poseidon for UML is developed by <A HREF=\"http://www.gentleware.com\">Gentleware</A>.\n *  Generated with <A HREF=\"http://jakarta.apache.org/velocity/\">velocity</A> template engine.\n */\npackage com.sun.pept.ept;\n\nimport java.util.*;\n\n/**\n * <p>\n *\n * @author Dr. Harold Carr\n * </p>\n */\npublic interface ContactInfoListIterator {\n\n  ///////////////////////////////////////\n  // operations\n\n/**\n * <p>\n * Does ...\n * </p><p>\n *\n * @return a boolean with ...\n * </p>\n */\n    public boolean hasNext();\n/**\n * <p>\n * Does ...\n * </p><p>\n *\n * @return a ContactInfo with ...\n * </p>\n */\n    public ContactInfo next();\n\n} // end ContactInfoListIterator\n", "fr.afcepf.al29.groupem.entities.Coupon;\r\n\r\npublic interface CouponDaoApi {\r\n\r\n    \r\n    Coupon createCoupon(Coupon paramCoupon);\r\n    Coupon updateCoupon(Coupon coupon);\r\n    boolean destroyCoupon(Coupon coupon);\r\n    \r\n    \r\n    Coupon getCouponById(int paramCouponId);\r\n    List<Coupon> getCouponByCode(String code);\r\n    \r\n    List<Coupon> getAllCoupons();\r\n    \r\n    List<Coupon> getCouponsByCatId(int catId);\r\n    \r\n    List<Coupon> getCouponsStartinBefore(Date date);\r\n    List<Coupon> getCouponsStartingAfter(Date date);\r\n    List<Coupon> getCouponsStartingOn(Date date);\r\n    \r\n    List<Coupon> getCouponsEndingBefore(Date date);\r\n    List<Coupon> getCouponsEndingAfter(Date date);\r\n    List<Coupon> getCouponsEndingOn(Date date);\r\n    \r\n    List<Coupon> getCouponsByRebateLesserThan(float rebate);\r\n    List<Coupon> getCouponsByRebateGreaterThan(float rebate);\r\n    List<Coupon> getCouponsByRebateEquals(float rebate);\r\n    \r\n    \r\n\r\n}\r\n", "gePowered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.api.data.type;\n\n/**\n * A utility class for getting all available {@link Career}s.\n */\npublic final class Careers {\n\n    public static final Career FARMER = null;\n    public static final Career FISHERMAN = null;\n    public static final Career SHEPHERD = null;\n    public static final Career FLETCHER = null;\n    public static final Career LIBRARIAN = null;\n    public static final Career CLERIC = null;\n    public static final Career ARMORER = null;\n    public static final Career WEAPON_SMITH = null;\n    public static final Career TOOL_SMITH = null;\n    public static final Career BUTCHER = null;\n    public static final Career LEATHERWORKER = null;\n\n    private Careers() {\n\n    }\n}\n", "ava API\n Copyright (c) Microsoft Corporation\n All rights reserved.\n MIT License\n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n **************************************************************************/\n\npackage microsoft.exchange.webservices.data;\n\n/**\n * Represents an error that occurs when an operation on a property fails.\n */\npublic class PropertyException extends ServiceLocalException {\n\n  /**\n   * Constant serialized ID used for compatibility.\n   */\n  private static final long serialVersionUID = 1L;\n\n  /**\n   * The name.\n   */\n  private String name;\n\n  /**\n   * Instantiates a new property exception.\n   */\n  public PropertyException() {\n    super();\n  }\n\n  /**\n   * Instantiates a new property exception.\n   *\n   * @param name the name\n   */\n  public PropertyException(String name) {\n    super();\n    this.name = name;\n  }\n\n  /**\n   * Instantiates a new property exception.\n   *\n   * @param message the message\n   * @param name    the name\n   */\n  public PropertyException(String message, String name) {\n    super(message);\n    this.name = name;\n  }\n\n  /**\n   * Instantiates a new property exception.\n   *\n   * @param message        the message\n   * @param name           the name\n   * @param innerException the inner exception\n   */\n  public PropertyException(String message, String name,\n      Exception innerException) {\n    super(message, innerException);\n    this.name = name;\n  }\n\n  /**\n   * Gets the name.\n   *\n   * @return the name\n   */\n  public String getName() {\n    return name;\n  }\n\n}\n", "9 Oliver Stanley\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage pw.ollie.dzlib.function;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\n/**\n * Various utility methods for creation of {@link FunctionalInterface} types\n * which have a specific function.\n */\npublic final class Functions {\n    /**\n     * Transforms the given {@link Collection} into the given {@link Map}, where\n     * the keys are the value returned by applying the given {@link Function} to\n     * the value they are mapped to. The values are the elements contained in\n     * the given Collection.\n     *\n     * @param collection the {@link Collection} to map\n     * @param function the {@link Function} to use to determine keys\n     * @param <A> the type of key for the map\n     * @param <B> the type of value for the map\n     * @return a {@link Map} of {@code function}-determined keys to given values\n     */\n    public static <A, B> Map<A, B> map(Collection<B> collection, Map<A, B> map, Function<B, A> function) {\n        collection.forEach((l) -> map.put(function.apply(l), l));\n        return map;\n    }\n\n    /**\n     * Transforms the given {@link Collection} into a new {@link Map}, where\n     * the keys are the value returned by applying the given {@link Function} to\n     * the value they are mapped to. The values are the elements contained in\n     * the given Collection.\n     *\n     * This is equivalent to calling {@link #map(Collection, Map, Function)}\n     * with {@code new HashMap<>} provided for the {@link Map} argument.\n     *\n     * @param collection the {@link Collection} to map\n     * @param function the {@link Function} to use to determine keys\n     * @param <A> the type of key for the map\n     * @param <B> the type of value for the map\n     * @return a {@link Map} of {@code function}-determined keys to given values\n     */\n    public static <A, B> Map<A, B> map(Collection<B> collection, Function<B, A> function) {\n        return map(collection, new HashMap<>(), function);\n    }\n\n    /**\n     * Creates a new {@link Predicate} to check that the accepted {@link T} is\n     * of the given {@link Class} type.\n     *\n     * @param clazz the class to check the accepted object is an instance of\n     * @param <T> the type of object to accept in the {@link Predicate}\n     * @return a Predicate to check that accepted objects are of the given type\n     */\n    public static <T> Predicate<T> isInstance(Class<? extends T> clazz) {\n        return clazz::isInstance;\n    }\n\n    /**\n     * Creates a new {@link Predicate} to check that the accepted {@link T} is\n     * not of the given {@link Class} type.\n     *\n     * @param clazz the class to check the accepted object isn't an instance of\n     * @param <T> the type of object to accept in the {@link Predicate}\n     * @return a Predicate to check that accepted objects aren't of given type\n     */\n    public static <T> Predicate<T> notInstance(Class<? extends T> clazz) {\n        return (e) -> !clazz.isInstance(e);\n    }\n\n    /**\n     * Gets a {@link BiPredicate} which checks for the two given objects being\n     * equal to each other, classing two {@code null} objects as equal.\n     *\n     * @param <T> the type of object to compare\n     * @return a BiPredicate checking for two given objects being equal\n     * @see {@link #areEqual()}\n     */\n    public static <T> BiPredicate<T, T> areEqualNullable() {\n        return EQUAL_NULLABLE_PREDICATE;\n    }\n\n    /**\n     * Gets a {@link Consumer} which does nothing every time.\n     *\n     * @param <T> the type of object to consume\n     * @return a Consumer which does nothing every time\n     */\n    public static <T> Consumer<T> voidConsumer() {\n        return VOID_CONSUMER;\n    }\n\n    /**\n     * Gets a {@link BiConsumer} which does nothing every time.\n     *\n     * @param <T> the first type of object to consume\n     * @param <U> the second type of object to consume\n     * @return a BiConsumer which does nothing every time\n     */\n    public static <T, U> BiConsumer<T, U> voidBiConsumer() {\n        return VOID_BICONSUMER;\n    }\n\n    /**\n     * Gets a {@link Supplier} which returns {@code null} every time.\n     *\n     * @param <T> the type for the Supplier to return\n     * @return a Supplier which returns {@code null} every time\n     */\n    public static <T> Supplier<T> nullSupplier() {\n        return NULL_SUPPLIER;\n    }\n\n    /**\n     * Gets a {@link Supplier} which returns {@code value} every time.\n     *\n     * @param <T> the type for the Supplier to return\n     * @return a Supplier which returns {@code value} every time\n     */\n    public static <T> Supplier<T> constantSupplier(T value) {\n        return () -> value;\n    }\n\n    /**\n     * Gets a {@link Predicate} which returns {@code true} every time.\n     *\n     * @param <T> the type for the Predicate to accept\n     * @return a Predicate which returns {@code true} every time\n     */\n    public static <T> Predicate<T> truePredicate() {\n        return TRUE_PREDICATE;\n    }\n\n    /**\n     * Gets a {@link Predicate} which returns {@code false} every time.\n     *\n     * @param <T> the type for the Predicate to accept\n     * @return a Predicate which returns {@code false} every time\n     */\n    public static <T> Predicate<T> falsePredicate() {\n        return FALSE_PREDICATE;\n    }\n\n    // Various FunctionalInterface implementations\n\n    private static final Consumer VOID_CONSUMER = (e) -> {\n    };\n    private static final BiConsumer VOID_BICONSUMER = (a, b) -> {\n    };\n    private static final Supplier NULL_SUPPLIER = () -> null;\n    private static final Predicate TRUE_PREDICATE = (e) -> true;\n    private static final Predicate FALSE_PREDICATE = (e) -> false;\n    private static final BiPredicate EQUAL_NULLABLE_PREDICATE = (a, b) -> {\n        if (a == null || b == null) {\n            return a == null && b == null;\n        } else {\n            return a.equals(b);\n        }\n    };\n\n    private Functions() {\n    }\n}\n", ".Point;\nimport java.awt.Rectangle;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Stack;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\nimport com.polydes.scenelink.data.Link;\nimport com.polydes.scenelink.ui.Reflect;\nimport com.polydes.scenelink.util.ColorUtil;\n\nimport stencyl.sw.util.FileHelper;\n\npublic class XML\n{\n\tprivate static class XMLState\n\t{\n\t\tpublic Element e;\n\t\tpublic ArrayList<Element> layer;\n\t\tpublic int layerIndex;\n\t}\n\n\tpublic static void saveState()\n\t{\n\t\tXMLState s = new XMLState();\n\t\ts.e = e;\n\t\ts.layer = layer;\n\t\ts.layerIndex = layerIndex;\n\t\tstates.push(s);\n\t}\n\t\n\tpublic static void restoreState()\n\t{\n\t\tXMLState s = states.pop();\n\t\te = s.e;\n\t\tlayer = s.layer;\n\t\tlayerIndex = s.layerIndex;\n\t}\n\t\n\tprivate static Element e = null;\n\tprivate static ArrayList<Element> layer = null;\n\tprivate static int layerIndex = -1;\n\t\n\tprivate static Stack<XMLState> states = new Stack<XMLState>();\n\n\tpublic static Document createDocument()\n\t{\n\t\tDocumentBuilder builder = null;\n\t\ttry\n\t\t{\n\t\t\tbuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t}\n\t\tcatch (ParserConfigurationException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn builder.newDocument();\n\t}\n\t\n\tpublic static void writeDocument(Document d, String url)\n\t{\n\t\ttry\n\t\t{\n\t\t\tOutputStream out = new FileOutputStream(url);\n\t\t\t\n\t\t\tResult result = new StreamResult(new OutputStreamWriter(out, \"utf-8\"));\n\t\t\tDOMSource source = new DOMSource(d);\n\t\t\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer xformer = factory.newTransformer();\n\t\t\txformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\t\t\txformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\t\t\txformer.transform(source, result);\n\t\t\tout.close();\n\t\t}\n\t\tcatch(IllegalArgumentException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (FileNotFoundException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (UnsupportedEncodingException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (TransformerConfigurationException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (TransformerException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static Element getElement()\n\t{\n\t\treturn e;\n\t}\n\n\tpublic static void setElement(Element e)\n\t{\n\t\tXML.e = e;\n\t}\n\t\n\tpublic static void setFile(String url)\n\t{\n\t\tString s = \"\";\n\t\ttry\n\t\t{\n\t\t\ts = new File(url).toURI().toURL().toString();\n\t\t\tXML.e = FileHelper.readXMLFromFile(s).getDocumentElement();\n\t\t}\n\t\tcatch (MalformedURLException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static void descend()\n\t{\n\t\tsaveState();\n\t\t\n\t\tNodeList itemList = e.getChildNodes();\n\t\tlayer = new ArrayList<Element>();\n\t\tlayerIndex = -1;\n\t\t\n\t\tfor(int i = 0; i < itemList.getLength(); i++) \n\t\t{\n\t\t\tif(itemList.item(i) instanceof Element)\n\t\t\t{\n\t\t\t\tlayer.add((Element) itemList.item(i));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void ascend()\n\t{\n\t\trestoreState();\n\t}\n\t\n\tpublic static boolean hasNext()\n\t{\n\t\treturn (layerIndex + 1) < layer.size();\n\t}\n\t\n\tpublic static void next()\n\t{\n\t\te = layer.get(++layerIndex);\n\t}\n\t\n\tpublic static boolean elementNameIs(String name)\n\t{\n\t\treturn e.getTagName().equals(name);\n\t}\n\t\n\tpublic static int rint(String name)\n\t{\n\t\treturn rint(name, 0);\n\t}\n\t\n\tpublic static int rint(String name, int defReturn)\n\t{\n\t\tString s = e.getAttribute(name);\n\t\tif(s.equals(\"\"))\n\t\t\treturn defReturn;\n\t\treturn Integer.parseInt(s);\n\t}\n\t\n\tpublic static Integer rInteger(String name)\n\t{\n\t\treturn rint(name, 0);\n\t}\n\t\n\tpublic static void wrint(String name, int i)\n\t{\n\t\te.setAttribute(name, \"\"+i);\n\t}\n\t\n\tpublic static boolean rboolean(String name)\n\t{\n\t\treturn Boolean.parseBoolean(e.getAttribute(name));\n\t}\n\t\n\tpublic static Boolean rBoolean(String name)\n\t{\n\t\treturn Boolean.parseBoolean(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrboolean(String name, boolean b)\n\t{\n\t\te.setAttribute(name, b ? \"true\" : \"false\");\n\t}\n\t\n\tpublic static void wrBoolean(String name, Boolean b)\n\t{\n\t\te.setAttribute(name, b ? \"true\" : \"false\");\n\t}\n\t\n\tpublic static String rString(String name)\n\t{\n\t\treturn e.getAttribute(name);\n\t}\n\t\n\tpublic static void wrString(String name, String s)\n\t{\n\t\te.setAttribute(name, s);\n\t}\n\t\n\tpublic static Color rColor(String name)\n\t{\n\t\treturn ColorUtil.decode(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrColor(String name, Color c)\n\t{\n\t\te.setAttribute(name, ColorUtil.encode(c));\n\t}\n\t\n\tpublic static Float rFloat(String name)\n\t{\n\t\treturn Float.parseFloat(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrFloat(String name, Float f)\n\t{\n\t\te.setAttribute(name, \"\" + f);\n\t}\n\t\n\tpublic static float rfloat(String name)\n\t{\n\t\treturn Float.parseFloat(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrfloat(String name, float f)\n\t{\n\t\te.setAttribute(name, \"\" + f);\n\t}\n\t\n//\tpublic static BufferedImage rImage(String name)\n//\t{\n//\t\treturn Resources.readImage(e.getAttribute(name));\n//\t}\n\t\n\tpublic static Point rPoint(String name)\n\t{\n\t\tint[] ints = getInts(e.getAttribute(name));\n\t\tif(ints == null)\n\t\t\treturn new Point(0, 0);\n\t\t\n\t\treturn new Point(ints[0], ints[1]);\n\t}\n\t\n\tpublic static void wrPoint(String name, Point p)\n\t{\n\t\te.setAttribute(name, p.x + \", \" + p.y);\n\t}\n\t\n\tpublic static Dimension rDimension(String name)\n\t{\n\t\tint[] ints = getInts(e.getAttribute(name));\n\t\tif(ints == null)\n\t\t\treturn new Dimension(0, 0);\n\t\t\n\t\treturn new Dimension(ints[0], ints[1]);\n\t}\n\t\n\tpublic static void wrDimension(String name, Dimension d)\n\t{\n\t\te.setAttribute(name, d.width + \", \" + d.height);\n\t}\n\t\n\tpublic static Rectangle rRectangle(String name)\n\t{\n\t\tint[] ints = getInts(e.getAttribute(name));\n\t\tif(ints == null)\n\t\t\treturn new Rectangle(0, 0, 0, 0);\n\t\t\n\t\treturn new Rectangle(ints[0], ints[1], ints[2], ints[3]);\n\t}\n\t\n\tpublic static void wrRectangle(String name, Rectangle r)\n\t{\n\t\te.setAttribute(name, r.x + \", \" + r.y + \", \" + r.width + \", \" + r.height);\n\t}\n\t\n\tpublic static int[] getInts(String fromString)\n\t{\n\t\tif(fromString.length() == 0)\n\t\t\treturn null;\n\t\t\n\t\tString[] splitString = fromString.split(\",\");\n\t\tint[] toReturn = new int[splitString.length];\n\t\tfor(int i = 0; i < splitString.length; ++i)\n\t\t\ttoReturn[i] = Integer.parseInt(splitString[i].trim());\n\t\treturn toReturn;\n\t}\n\t\n\tpublic static Link rLink(String name)\n\t{\n\t\tString linkText = e.getAttribute(name);\n\t\tif(linkText.equals(\"\"))\n\t\t\treturn Link.createBlank();\n\t\t\n\t\tString[] s = linkText.split(\" \");\n\t\treturn Link.create(s[0], Integer.parseInt(s[1]));\n\t}\n\t\n\tpublic static void wrLink(String name, Link l)\n\t{\n\t\te.setAttribute(name, Link.getStringRef(l));\n\t}\n\n\tpublic static Element wrElement(Document d, String name, Object o, String[] attrs)\n\t{\n\t\tElement e2 = e;\n\t\te = d.createElement(name);\n\t\tif(o != null && attrs.length > 0)\n\t\t{\n\t\t\tField[] fields = Reflect.getFields(o, attrs);\n\t\t\tObject[] vals = Reflect.getValues(o, attrs);\n\t\t\tfor(int i = 0; i < attrs.length; ++i)\n\t\t\t{\n\t\t\t\tMethod writer = Reflect.getMethod(XML.class, \"wr\" + fields[i].getType().getSimpleName(), String.class, fields[i].getType());\n\t\t\t\tReflect.invoke(writer, null, attrs[i], vals[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tElement toReturn = e;\n\t\te = e2;\n\t\treturn toReturn;\n\t}\n\t\n\tpublic static void wrObjectToFile(String url, Object o)\n\t{\n\t\tXML.saveState();\n\t\t\n\t\tDocument d = XML.createDocument();\n\t\tElement root = XML.wrObjectToElement(d, o);\n\t\td.appendChild(root);\n\t\t\n\t\tXML.writeDocument(d, url);\n\t\t\n\t\tXML.restoreState();\n\t}\n\t\n\tpublic static Element wrObjectToElement(Document d, Object o)\n\t{\n\t\tString name = o.getClass().getSimpleName();\n\t\tname = name.toLowerCase();\n\t\tif(name.endsWith(\"model\"))\n\t\t\tname = name.substring(0, name.length() - 5);\n\t\t\n\t\tElement e2 = e;\n\t\te = d.createElement(name);\n\t\t\n\t\tHashMap<String, Field> fieldMap = Reflect.getDeclaredFieldMap(o);\n\t\t\n\t\tfor(String k : fieldMap.keySet().toArray(new String[]{}))\n\t\t{\n\t\t\tField f = fieldMap.get(k);\n\t\t\tClass<?> type = f.getType();\n\t\t\t\n\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t{\n\t\t\t\tMethod writer = Reflect.getMethod(XML.class, \"wr\" + f.getType().getSimpleName(), String.class, f.getType());\n\t\t\t\tReflect.invoke(writer, null, f.getName(), Reflect.getFieldValue(f, o));\n\t\t\t\tfieldMap.remove(k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(String k : fieldMap.keySet().toArray(new String[]{}))\n\t\t{\n\t\t\tField f = fieldMap.get(k);\n\t\t\tClass<?> type = f.getType();\n\t\t\t\n\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tElement listElement = wrListElement(d, o, f);\n\t\t\tfieldMap.remove(k);\n\t\t\te.appendChild(listElement);\n\t\t}\n\t\t\n\t\tElement toReturn = e;\n\t\te = e2;\n\t\treturn toReturn;\n\t}\n\t\n\tpublic static Element wrListElement(Document d, Object o, Field f)\n\t{\n\t\tElement top = d.createElement(f.getName());\n\t\t\n\t\tCollection<?> c = null;\n\t\tif(f.getType() == ArrayList.class)\n\t\t\tc = (ArrayList<?>) Reflect.getFieldValue(f, o);\n\t\telse if(f.getType() == HashMap.class)\n\t\t\tc = ((HashMap<?, ?>) Reflect.getFieldValue(f, o)).values();\n\t\t\n\t\tif(c != null)\n\t\t{\n\t\t\tfor(Object item : c)\n\t\t\t{\n\t\t\t\tElement toAdd = wrObjectToElement(d, item);\n\t\t\t\ttop.appendChild(toAdd);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn top;\n\t}\n\t\n\tpublic static Object rObjectFromFile(String url, Class<?> cls)\n\t{\n\t\tsaveState();\n\t\tsetFile(url);\n\t\t\n\t\tObject toReturn = rObjectFromElement(cls);\n\t\t\n\t\trestoreState();\n\t\t\n\t\treturn toReturn;\n\t}\n\t\n\t/*\n\t * Read an object from an element.\n\t * Basic fields are read from the object representing tags attributes.\n\t * HashMap<?, ?> is read from an element with a list of subelements, with the \"id\" field being used as a storage key\n\t * ArrayList<?> is read from an element with a list of subelements\n\t */\n\tpublic static Object rObjectFromElement(Class<?> cls)\n\t{\n\t\tObject o = Reflect.newInstance(cls);\n\t\t\n\t\tHashMap<String, Field> fieldMap = Reflect.getDeclaredFieldMap(cls);\n\t\t\n\t\tfor(String k : fieldMap.keySet().toArray(new String[]{}))\n\t\t{\n\t\t\tField f = fieldMap.get(k);\n\t\t\tClass<?> type = f.getType();\n\t\t\t\n\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t{\n\t\t\t\tMethod reader = Reflect.getMethod(XML.class, \"r\" + type.getSimpleName(), String.class);\n\t\t\t\tObject value = Reflect.invoke(reader, null, k);\n\t\t\t\tReflect.setField(f, o, value);\n\t\t\t\tfieldMap.remove(k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!fieldMap.isEmpty())\n\t\t{\n\t\t\tXML.descend();\n\t\t\twhile(XML.hasNext())\n\t\t\t{\n\t\t\t\tXML.next();\n\t\t\t\tField f = fieldMap.get(e.getTagName());\n\t\t\t\tif(f == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tClass<?> type = f.getType();\n\t\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(type == HashMap.class)\n\t\t\t\t{\n\t\t\t\t\tClass<?>[] classes = Reflect.getGenericTypes(f);\n\t\t\t\t\tObject value = rHashMap(classes[0], classes[1]);\n\t\t\t\t\tReflect.setField(f, o, value);\n\t\t\t\t\tfieldMap.remove(e.getTagName());\n\t\t\t\t}\n\t\t\t\telse if(type == ArrayList.class)\n\t\t\t\t{\n\t\t\t\t\tClass<?>[] classes = Reflect.getGenericTypes(f);\n\t\t\t\t\tObject value = rArrayList(classes[0]);\n\t\t\t\t\tReflect.setField(f, o, value);\n\t\t\t\t\tfieldMap.remove(e.getTagName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tXML.ascend();\n\t\t}\n\t\t\n\t\treturn o;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T, U> HashMap<T, U> rHashMap(Class<?> keyCls, Class<?> valCls)\n\t{\n\t\tHashMap<T, U> toReturn = new HashMap<T, U>();\n\t\t\n\t\tMethod keyReader = Reflect.getMethod(XML.class, \"r\" + keyCls.getSimpleName(), String.class);\n\t\t\n\t\tXML.descend();\n\t\twhile(XML.hasNext())\n\t\t{\n\t\t\tXML.next();\n\t\t\tT keyValue = (T) Reflect.invoke(keyReader, null, \"id\");\n\t\t\tU value = (U) rObjectFromElement(valCls);\n\t\t\ttoReturn.put(keyValue, value);\n\t\t}\n\t\tXML.ascend();\n\t\t\n\t\treturn toReturn;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> ArrayList<T> rArrayList(Class<?> gen)\n\t{\n\t\tArrayList<T> toReturn = new ArrayList<T>();\n\t\t\n\t\tXML.descend();\n\t\twhile(XML.hasNext())\n\t\t{\n\t\t\tXML.next();\n\t\t\tT val = (T) rObjectFromElement(gen);\n\t\t\ttoReturn.add(val);\n\t\t}\n\t\tXML.ascend();\n\t\t\n\t\treturn toReturn;\n\t}\n}\n", "age};\n\nimport org.junit.Test;\n\npublic class ApplicationTest {\n\n\t@Test\n\tpublic void testSetup() {\n\t\n\t}\n}\n", "t org.apache.tapestry5.annotations.Persist;\nimport org.apache.tapestry5.annotations.Property;\nimport org.apache.tapestry5.annotations.SetupRender;\nimport org.apache.tapestry5.ioc.annotations.Inject;\nimport org.arnolf.tapestry.mongo.services.MongoConnection;\n\nimport com.mongodb.BasicDBObject;\nimport com.mongodb.DB;\nimport com.mongodb.DBObject;\n\n@Import(stack = { \"boostrap\" })\npublic class Index {\n\n\t@Inject\n\tprivate MongoConnection mongoConnection;\n\t\n\t@Property\n\t@Persist\n\tprivate DBObject document;\n\t\n\t@Property\n\tprivate boolean separateShipTo;\n\t\n\t@Property\n\tprivate int index;\n\t\n\tprivate long userId;\n\t\n\tpublic void onActivate(long userId) {\n\t\tthis.userId = userId;\n\t}\n\t\n\tpublic long onPassivate() {\n\t\treturn this.userId;\n\t}\n\t\n\t@SetupRender\n\tpublic void init() {\n\t\tDB db = this.mongoConnection.getDB();\n\t\tthis.document = db.getCollection(\"person\").\n\t\t\t\tfindAndModify(new BasicDBObject(\"_id\", userId), null, null, false, new BasicDBObject(\"$set\", new BasicDBObject(\"_id\", userId)), true, true);\n\t}\n\t\n\tpublic void onSubmit() {\n\t\tthis.mongoConnection.getDB().getCollection(\"person\").save(document);\n\t}\n}\n", " Hat, Inc., Victor Glushenkov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.maven;\n\nimport hudson.AbortException;\nimport hudson.FilePath;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.EnvVars;\nimport hudson.scm.ChangeLogSet;\nimport hudson.FilePath.FileCallable;\nimport hudson.maven.MavenBuild.ProxyImpl2;\nimport hudson.maven.reporters.MavenFingerprinter;\nimport hudson.maven.reporters.MavenMailer;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.Build;\nimport hudson.model.BuildListener;\nimport hudson.model.Environment;\nimport hudson.model.Fingerprint;\nimport hudson.model.Hudson;\nimport hudson.model.ParametersAction;\nimport hudson.model.Result;\nimport hudson.model.Computer;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.Cause.UpstreamCause;\nimport hudson.remoting.Channel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.MailSender;\nimport hudson.tasks.Maven.MavenInstallation;\nimport hudson.util.ArgumentListBuilder;\nimport hudson.util.StreamTaskListener;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.io.InterruptedIOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.Map.Entry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.maven.BuildFailureException;\nimport org.apache.maven.embedder.MavenEmbedderException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.execution.ReactorManager;\nimport org.apache.maven.lifecycle.LifecycleExecutionException;\nimport org.apache.maven.monitor.event.EventDispatcher;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport static hudson.model.Result.FAILURE;\n\n/**\n * {@link Build} for {@link MavenModuleSet}.\n *\n * <p>\n * A \"build\" of {@link MavenModuleSet} consists of:\n *\n * <ol>\n * <li>Update the workspace.\n * <li>Parse POMs\n * <li>Trigger module builds.\n * </ol>\n *\n * This object remembers the changelog and what {@link MavenBuild}s are done\n * on this.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class MavenModuleSetBuild extends AbstractMavenBuild<MavenModuleSet,MavenModuleSetBuild> {\n    /**\n     * {@link MavenReporter}s that will contribute project actions.\n     * Can be null if there's none.\n     */\n    /*package*/ List<MavenReporter> projectActionReporters;\n\n    public MavenModuleSetBuild(MavenModuleSet job) throws IOException {\n        super(job);\n    }\n\n    public MavenModuleSetBuild(MavenModuleSet project, File buildDir) throws IOException {\n        super(project, buildDir);\n    }\n\n    /**\n     * Exposes {@code MAVEN_OPTS} to forked processes.\n     *\n     * When we fork Maven, we do so directly by executing Java, thus this environment variable\n     * is pointless (we have to tweak JVM launch option correctly instead, which can be seen in\n     * {@link MavenProcessFactory}), but setting the environment variable explicitly is still\n     * useful in case this Maven forks other Maven processes via normal way. See HUDSON-3644.\n     */\n    @Override\n    public EnvVars getEnvironment(TaskListener log) throws IOException, InterruptedException {\n        EnvVars envs = super.getEnvironment(log);\n        String opts = project.getMavenOpts();\n        if(opts!=null)\n            envs.put(\"MAVEN_OPTS\", opts);\n        return envs;\n    }\n\n    /**\n     * Displays the combined status of all modules.\n     * <p>\n     * More precisely, this picks up the status of this build itself,\n     * plus all the latest builds of the modules that belongs to this build.\n     */\n    @Override\n    public Result getResult() {\n        Result r = super.getResult();\n\n        for (MavenBuild b : getModuleLastBuilds().values()) {\n            Result br = b.getResult();\n            if(r==null)\n                r = br;\n            else\n            if(br==Result.NOT_BUILT)\n                continue;   // UGLY: when computing combined status, ignore the modules that were not built\n            else\n            if(br!=null)\n                r = r.combine(br);\n        }\n\n        return r;\n    }\n\n    /**\n     * Returns the filtered changeset entries that match the given module.\n     */\n    /*package*/ List<ChangeLogSet.Entry> getChangeSetFor(final MavenModule mod) {\n        return new ArrayList<ChangeLogSet.Entry>() {\n            {\n                // modules that are under 'mod'. lazily computed\n                List<MavenModule> subsidiaries = null;\n\n                for (ChangeLogSet.Entry e : getChangeSet()) {\n                    if(isDescendantOf(e, mod)) {\n                        if(subsidiaries==null)\n                            subsidiaries = mod.getSubsidiaries();\n\n                        // make sure at least one change belongs to this module proper,\n                        // and not its subsidiary module\n                        if (notInSubsidiary(subsidiaries, e))\n                            add(e);\n                    }\n                }\n            }\n\n            private boolean notInSubsidiary(List<MavenModule> subsidiaries, ChangeLogSet.Entry e) {\n                for (String path : e.getAffectedPaths())\n                    if(!belongsToSubsidiary(subsidiaries, path))\n                        return true;\n                return false;\n            }\n\n            private boolean belongsToSubsidiary(List<MavenModule> subsidiaries, String path) {\n                for (MavenModule sub : subsidiaries)\n                    if(path.startsWith(sub.getRelativePath()))\n                        return true;\n                return false;\n            }\n\n            /**\n             * Does this change happen somewhere in the given module or its descendants?\n             */\n            private boolean isDescendantOf(ChangeLogSet.Entry e, MavenModule mod) {\n                for (String path : e.getAffectedPaths())\n                    if(path.startsWith(mod.getRelativePath()))\n                        return true;\n                return false;\n            }\n        };\n    }\n\n    /**\n     * Computes the module builds that correspond to this build.\n     * <p>\n     * A module may be built multiple times (by the user action),\n     * so the value is a list.\n     */\n    public Map<MavenModule,List<MavenBuild>> getModuleBuilds() {\n        Collection<MavenModule> mods = getParent().getModules();\n\n        // identify the build number range. [start,end)\n        MavenModuleSetBuild nb = getNextBuild();\n        int end = nb!=null ? nb.getNumber() : Integer.MAX_VALUE;\n\n        // preserve the order by using LinkedHashMap\n        Map<MavenModule,List<MavenBuild>> r = new LinkedHashMap<MavenModule,List<MavenBuild>>(mods.size());\n\n        for (MavenModule m : mods) {\n            List<MavenBuild> builds = new ArrayList<MavenBuild>();\n            MavenBuild b = m.getNearestBuild(number);\n            while(b!=null && b.getNumber()<end) {\n                builds.add(b);\n                b = b.getNextBuild();\n            }\n            r.put(m,builds);\n        }\n\n        return r;\n    }\n\n    @Override\n    public Object getDynamic(String token, StaplerRequest req, StaplerResponse rsp) {\n        // map corresponding module build under this object\n        if(token.indexOf('$')>0) {\n            MavenModule m = getProject().getModule(token);\n            if(m!=null) return m.getBuildByNumber(getNumber());\n        }\n        return super.getDynamic(token,req,rsp);\n    }\n\n    /**\n     * Computes the latest module builds that correspond to this build.\n     */\n    public Map<MavenModule,MavenBuild> getModuleLastBuilds() {\n        Collection<MavenModule> mods = getParent().getModules();\n\n        // identify the build number range. [start,end)\n        MavenModuleSetBuild nb = getNextBuild();\n        int end = nb!=null ? nb.getNumber() : Integer.MAX_VALUE;\n\n        // preserve the order by using LinkedHashMap\n        Map<MavenModule,MavenBuild> r = new LinkedHashMap<MavenModule,MavenBuild>(mods.size());\n\n        for (MavenModule m : mods) {\n            MavenBuild b = m.getNearestOldBuild(end - 1);\n            if(b!=null && b.getNumber()>=getNumber())\n                r.put(m,b);\n        }\n\n        return r;\n    }\n\n    public void registerAsProjectAction(MavenReporter reporter) {\n        if(projectActionReporters==null)\n            projectActionReporters = new ArrayList<MavenReporter>();\n        projectActionReporters.add(reporter);\n    }\n\n    /**\n     * Finds {@link Action}s from all the module builds that belong to this\n     * {@link MavenModuleSetBuild}. One action per one {@link MavenModule},\n     * and newer ones take precedence over older ones.\n     */\n    public <T extends Action> List<T> findModuleBuildActions(Class<T> action) {\n        Collection<MavenModule> mods = getParent().getModules();\n        List<T> r = new ArrayList<T>(mods.size());\n\n        // identify the build number range. [start,end)\n        MavenModuleSetBuild nb = getNextBuild();\n        int end = nb!=null ? nb.getNumber()-1 : Integer.MAX_VALUE;\n\n        for (MavenModule m : mods) {\n            MavenBuild b = m.getNearestOldBuild(end);\n            while(b!=null && b.getNumber()>=number) {\n                T a = b.getAction(action);\n                if(a!=null) {\n                    r.add(a);\n                    break;\n                }\n                b = b.getPreviousBuild();\n            }\n        }\n\n        return r;\n    }\n\n    public void run() {\n        run(new RunnerImpl());\n        getProject().updateTransientActions();\n    }\n\n    @Override\n    public Fingerprint.RangeSet getDownstreamRelationship(AbstractProject that) {\n        Fingerprint.RangeSet rs = super.getDownstreamRelationship(that);\n        for(List<MavenBuild> builds : getModuleBuilds().values())\n            for (MavenBuild b : builds)\n                rs.add(b.getDownstreamRelationship(that));\n        return rs;\n    }\n\n    /**\n     * Called when a module build that corresponds to this module set build\n     * has completed.\n     */\n    /*package*/ void notifyModuleBuild(MavenBuild newBuild) {\n        try {\n            // update module set build number\n            getParent().updateNextBuildNumber();\n\n            // update actions\n            Map<MavenModule, List<MavenBuild>> moduleBuilds = getModuleBuilds();\n\n            // actions need to be replaced atomically especially\n            // given that two builds might complete simultaneously.\n            synchronized(this) {\n                boolean modified = false;\n\n                List<Action> actions = getActions();\n                Set<Class<? extends AggregatableAction>> individuals = new HashSet<Class<? extends AggregatableAction>>();\n                for (Action a : actions) {\n                    if(a instanceof MavenAggregatedReport) {\n                        MavenAggregatedReport mar = (MavenAggregatedReport) a;\n                        mar.update(moduleBuilds,newBuild);\n                        individuals.add(mar.getIndividualActionType());\n                        modified = true;\n                    }\n                }\n\n                // see if the new build has any new aggregatable action that we haven't seen.\n                for (AggregatableAction aa : newBuild.getActions(AggregatableAction.class)) {\n                    if(individuals.add(aa.getClass())) {\n                        // new AggregatableAction\n                        MavenAggregatedReport mar = aa.createAggregatedAction(this, moduleBuilds);\n                        mar.update(moduleBuilds,newBuild);\n                        actions.add(mar);\n                        modified = true;\n                    }\n                }\n\n                if(modified) {\n                    save();\n                    getProject().updateTransientActions();\n                }\n            }\n\n            // symlink to this module build\n            String moduleFsName = newBuild.getProject().getModuleName().toFileSystemName();\n            Util.createSymlink(getRootDir(),\n                    \"../../modules/\"+ moduleFsName +\"/builds/\"+newBuild.getId() /*ugly!*/,\n                    moduleFsName, StreamTaskListener.NULL);\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING,\"Failed to update \"+this,e);\n        } catch (InterruptedException e) {\n            LOGGER.log(Level.WARNING,\"Failed to update \"+this,e);\n        }\n    }\n\n    /**\n     * The sole job of the {@link MavenModuleSet} build is to update SCM\n     * and triggers module builds.\n     */\n    private class RunnerImpl extends AbstractRunner {\n        private Map<ModuleName,MavenBuild.ProxyImpl2> proxies;\n\n        protected Result doRun(final BuildListener listener) throws Exception {\n            PrintStream logger = listener.getLogger();\n            try {\n                EnvVars envVars = getEnvironment(listener);\n                MavenInstallation mvn = project.getMaven();\n                if(mvn==null)\n                    throw new AbortException(\"A Maven installation needs to be available for this project to be built.\\n\"+\n                                             \"Either your server has no Maven installations defined, or the requested Maven version does not exist.\");\n                \n                mvn = mvn.forEnvironment(envVars).forNode(Computer.currentComputer().getNode(), listener);\n\n                if(!project.isAggregatorStyleBuild()) {\n                    parsePoms(listener, logger, envVars, mvn);\n                    // start module builds\n                    logger.println(\"Triggering \"+project.getRootModule().getModuleName());\n                    project.getRootModule().scheduleBuild(new UpstreamCause((Run<?,?>)MavenModuleSetBuild.this));\n                } else {\n                    // do builds here\n                    try {\n                        List<BuildWrapper> wrappers = new ArrayList<BuildWrapper>();\n                        for (BuildWrapper w : project.getBuildWrappersList())\n                            wrappers.add(w);\n                        ParametersAction parameters = getAction(ParametersAction.class);\n                        if (parameters != null)\n                            parameters.createBuildWrappers(MavenModuleSetBuild.this,wrappers);\n\n                        for( BuildWrapper w : wrappers) {\n                            Environment e = w.setUp(MavenModuleSetBuild.this, launcher, listener);\n                            if(e==null)\n                                return Result.FAILURE;\n                            buildEnvironments.add(e);\n                            e.buildEnvVars(envVars); // #3502: too late for getEnvironment to do this\n                        }\n\n                        if(!preBuild(listener, project.getPublishers()))\n                            return Result.FAILURE;\n\n                        parsePoms(listener, logger, envVars, mvn); // #5428 : do pre-build *before* parsing pom\n                        SplittableBuildListener slistener = new SplittableBuildListener(listener);\n                        proxies = new HashMap<ModuleName, ProxyImpl2>();\n                        List<String> changedModules = new ArrayList<String>();\n\n                        for (MavenModule m : project.sortedActiveModules) {\n                            MavenBuild mb = m.newBuild();\n                            \n                            // Check if incrementalBuild is selected and that there are changes -\n                            // we act as if incrementalBuild is not set if there are no changes.\n                            if (!MavenModuleSetBuild.this.getChangeSet().isEmptySet()\n                                && project.isIncrementalBuild()) {\n\t\t\t\t// If there are changes for this module, add it.\n\t\t\t\t// Also add it if we've never seen this module before,\n\t\t\t\t// or if the previous build of this module failed or was unstable.\n                                if ((mb.getPreviousBuiltBuild() == null) ||\n                                    (!getChangeSetFor(m).isEmpty()) \n                                    || (mb.getPreviousBuiltBuild().getResult().isWorseThan(Result.SUCCESS))) {\n                                    changedModules.add(m.getModuleName().toString());\n                                }\n                            }\n\n                            mb.setWorkspace(getModuleRoot().child(m.getRelativePath()));\n                            proxies.put(m.getModuleName(), mb.new ProxyImpl2(MavenModuleSetBuild.this,slistener));\n                        }\n\n                        // run the complete build here\n\n                        // figure out the root POM location.\n                        // choice of module root ('ws' in this method) is somewhat arbitrary\n                        // when multiple CVS/SVN modules are checked out, so also check\n                        // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                        String rootPOM = project.getRootPOM();\n                        FilePath pom = getModuleRoot().child(rootPOM);\n                        FilePath parentLoc = getWorkspace().child(rootPOM);\n                        if(!pom.exists() && parentLoc.exists())\n                            pom = parentLoc;\n\n                        ProcessCache.MavenProcess process = MavenBuild.mavenProcessCache.get(launcher.getChannel(), slistener,\n                            new MavenProcessFactory(project,launcher,envVars,pom.getParent()));\n\n                        ArgumentListBuilder margs = new ArgumentListBuilder().add(\"-B\").add(\"-f\", pom.getRemote());\n                        if(project.usesPrivateRepository())\n                            margs.add(\"-Dmaven.repo.local=\"+getWorkspace().child(\".repository\"));\n                        // If incrementalBuild is set, and we're on Maven 2.1 or later, *and* there's at least one module\n                        // listed in changedModules, do the Maven incremental build commands - if there are no changed modules,\n                        // We're building everything anyway.\n                        if (project.isIncrementalBuild() && mvn.isMaven2_1(launcher) && !changedModules.isEmpty()) {\n                            margs.add(\"-amd\");\n                            margs.add(\"-pl\", Util.join(changedModules, \",\"));\n                        }\n\n                        if (project.getAlternateSettings() != null) {\n                            margs.add(\"-s\").add(getWorkspace().child(project.getAlternateSettings()));\n                        }\n\n                        margs.addTokenized(envVars.expand(project.getGoals()));\n\n                        Builder builder = new Builder(slistener, proxies, project.sortedActiveModules, margs.toList(), envVars);\n                        MavenProbeAction mpa=null;\n                        try {\n                            mpa = new MavenProbeAction(project,process.channel);\n                            addAction(mpa);\n                            return process.call(builder);\n                        } finally {\n                            builder.end(launcher);\n                            getActions().remove(mpa);\n                            process.discard();\n                        }\n                    } finally {\n                        // tear down in reverse order\n                        boolean failed=false;\n                        for( int i=buildEnvironments.size()-1; i>=0; i-- ) {\n                            if (!buildEnvironments.get(i).tearDown(MavenModuleSetBuild.this,listener)) {\n                                failed=true;\n                            }                    \n                        }\n                        buildEnvironments = null;\n                        // WARNING The return in the finally clause will trump any return before\n                        if (failed) return Result.FAILURE;\n                    }\n                }\n                \n                return null;\n            } catch (AbortException e) {\n                if(e.getMessage()!=null)\n                    listener.error(e.getMessage());\n                return Result.FAILURE;\n            } catch (InterruptedIOException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedIOException\"));\n                return Result.ABORTED;\n            } catch (InterruptedException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedException\"));\n                return Result.ABORTED;\n            } catch (IOException e) {\n                e.printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                return Result.FAILURE;\n            } catch (RunnerAbortedException e) {\n                return Result.FAILURE;\n            } catch (RuntimeException e) {\n                // bug in the code.\n                e.printStackTrace(listener.error(\"Processing failed due to a bug in the code. Please report this to users@hudson.dev.java.net\"));\n                logger.println(\"project=\"+project);\n                logger.println(\"project.getModules()=\"+project.getModules());\n                logger.println(\"project.getRootModule()=\"+project.getRootModule());\n                throw e;\n            }\n        }\n\n        private void parsePoms(BuildListener listener, PrintStream logger, EnvVars envVars, MavenInstallation mvn) throws IOException, InterruptedException {\n            logger.println(\"Parsing POMs\");\n\n            List<PomInfo> poms;\n            try {\n                poms = getModuleRoot().act(new PomParser(listener, mvn, project));\n            } catch (IOException e) {\n                if (e.getCause() instanceof AbortException)\n                    throw (AbortException) e.getCause();\n                throw e;\n            } catch (MavenExecutionException e) {\n                // Maven failed to parse POM\n                e.getCause().printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                throw new AbortException();\n            }\n\n            // update the module list\n            Map<ModuleName,MavenModule> modules = project.modules;\n            synchronized(modules) {\n                Map<ModuleName,MavenModule> old = new HashMap<ModuleName, MavenModule>(modules);\n                List<MavenModule> sortedModules = new ArrayList<MavenModule>();\n\n                modules.clear();\n                if(debug)\n                    logger.println(\"Root POM is \"+poms.get(0).name);\n                project.reconfigure(poms.get(0));\n                for (PomInfo pom : poms) {\n                    MavenModule mm = old.get(pom.name);\n                    if(mm!=null) {// found an existing matching module\n                        if(debug)\n                            logger.println(\"Reconfiguring \"+mm);\n                        mm.reconfigure(pom);\n                        modules.put(pom.name,mm);\n                    } else {// this looks like a new module\n                        logger.println(Messages.MavenModuleSetBuild_DiscoveredModule(pom.name,pom.displayName));\n                        mm = new MavenModule(project,pom,getNumber());\n                        modules.put(mm.getModuleName(),mm);\n                    }\n                    sortedModules.add(mm);\n                    mm.save();\n                }\n                // at this point the list contains all the live modules\n                project.sortedActiveModules = sortedModules;\n\n                // remaining modules are no longer active.\n                old.keySet().removeAll(modules.keySet());\n                for (MavenModule om : old.values()) {\n                    if(debug)\n                        logger.println(\"Disabling \"+om);\n                    om.makeDisabled(true);\n                }\n                modules.putAll(old);\n            }\n\n            // we might have added new modules\n            Hudson.getInstance().rebuildDependencyGraph();\n\n            // module builds must start with this build's number\n            for (MavenModule m : modules.values())\n                m.updateNextBuildNumber(getNumber());\n        }\n\n        protected void post2(BuildListener listener) throws Exception {\n            // asynchronous executions from the build might have left some unsaved state,\n            // so just to be safe, save them all.\n            for (MavenBuild b : getModuleLastBuilds().values())\n                b.save();\n\n            // at this point the result is all set, so ignore the return value\n            if (!performAllBuildSteps(listener, project.getPublishers(), true))\n                setResult(FAILURE);\n            if (!performAllBuildSteps(listener, project.getProperties(), true))\n                setResult(FAILURE);\n\n            // aggregate all module fingerprints to us,\n            // so that dependencies between module builds can be understood as\n            // dependencies between module set builds.\n            // TODO: we really want to implement this as a publisher,\n            // but we don't want to ask for a user configuration, nor should it\n            // show up in the persisted record.\n            MavenFingerprinter.aggregate(MavenModuleSetBuild.this);\n        }\n\n        @Override\n        public void cleanUp(BuildListener listener) throws Exception {\n            if(project.isAggregatorStyleBuild()) {\n                // schedule downstream builds. for non aggregator style builds,\n                // this is done by each module\n                scheduleDownstreamBuilds(listener);\n            }\n\n            MavenMailer mailer = project.getReporters().get(MavenMailer.class);\n            if (mailer != null) {\n                new MailSender(mailer.recipients,\n                        mailer.dontNotifyEveryUnstableBuild,\n                        mailer.sendToIndividuals).execute(MavenModuleSetBuild.this, listener);\n            }\n\n            // too late to set the build result at this point. so ignore failures.\n            performAllBuildSteps(listener, project.getPublishers(), false);\n            performAllBuildSteps(listener, project.getProperties(), false);\n        }\n\n    }\n\n    /**\n     * Runs Maven and builds the project.\n     *\n     * This is only used for\n     * {@link MavenModuleSet#isAggregatorStyleBuild() the aggregator style build}.\n     */\n    private static final class Builder extends MavenBuilder {\n        private final Map<ModuleName,MavenBuildProxy2> proxies;\n        private final Map<ModuleName,List<MavenReporter>> reporters = new HashMap<ModuleName,List<MavenReporter>>();\n        private final Map<ModuleName,List<ExecutedMojo>> executedMojos = new HashMap<ModuleName,List<ExecutedMojo>>();\n        private long mojoStartTime;\n\n        private MavenBuildProxy2 lastProxy;\n\n        /**\n         * Kept so that we can finalize them in the end method.\n         */\n        private final transient Map<ModuleName,ProxyImpl2> sourceProxies;\n\n        public Builder(BuildListener listener,Map<ModuleName,ProxyImpl2> proxies, Collection<MavenModule> modules, List<String> goals, Map<String,String> systemProps) {\n            super(listener,goals,systemProps);\n            this.sourceProxies = proxies;\n            this.proxies = new HashMap<ModuleName, MavenBuildProxy2>(proxies);\n            for (Entry<ModuleName,MavenBuildProxy2> e : this.proxies.entrySet())\n                e.setValue(new FilterImpl(e.getValue()));\n\n            for (MavenModule m : modules)\n                reporters.put(m.getModuleName(),m.createReporters());\n        }\n\n        private class FilterImpl extends MavenBuildProxy2.Filter<MavenBuildProxy2> implements Serializable {\n            public FilterImpl(MavenBuildProxy2 core) {\n                super(core);\n            }\n\n            @Override\n            public void executeAsync(final BuildCallable<?,?> program) throws IOException {\n                futures.add(Channel.current().callAsync(new AsyncInvoker(core,program)));\n            }\n\n            private static final long serialVersionUID = 1L;\n        }\n\n        /**\n         * Invoked after the maven has finished running, and in the master, not in the maven process.\n         */\n        void end(Launcher launcher) throws IOException, InterruptedException {\n            for (Map.Entry<ModuleName,ProxyImpl2> e : sourceProxies.entrySet()) {\n                ProxyImpl2 p = e.getValue();\n                for (MavenReporter r : reporters.get(e.getKey())) {\n                    // we'd love to do this when the module build ends, but doing so requires\n                    // we know how many task segments are in the current build.\n                    r.end(p.owner(),launcher,listener);\n                    p.appendLastLog();\n                }\n                p.close();\n            }\n        }\n\n        @Override\n        public Result call() throws IOException {\n            try {\n                return super.call();\n            } finally {\n                if(lastProxy!=null)\n                    lastProxy.appendLastLog();\n            }\n        }\n\n        void preBuild(MavenSession session, ReactorManager rm, EventDispatcher dispatcher) throws BuildFailureException, LifecycleExecutionException, IOException, InterruptedException {\n            // TODO\n        }\n\n        void postBuild(MavenSession session, ReactorManager rm, EventDispatcher dispatcher) throws BuildFailureException, LifecycleExecutionException, IOException, InterruptedException {\n            // TODO\n        }\n\n        void preModule(MavenProject project) throws InterruptedException, IOException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy2 proxy = proxies.get(name);\n            listener.getLogger().flush();   // make sure the data until here are all written\n            proxy.start();\n            for (MavenReporter r : reporters.get(name))\n                if(!r.preBuild(proxy,project,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n        }\n\n        void postModule(MavenProject project) throws InterruptedException, IOException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy2 proxy = proxies.get(name);\n            List<MavenReporter> rs = reporters.get(name);\n            if(rs==null) { // probe for issue #906\n                throw new AssertionError(\"reporters.get(\"+name+\")==null. reporters=\"+reporters+\" proxies=\"+proxies);\n            }\n            for (MavenReporter r : rs)\n                if(!r.postBuild(proxy,project,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n            proxy.setExecutedMojos(executedMojos.get(name));\n            listener.getLogger().flush();   // make sure the data until here are all written\n            proxy.end();\n            lastProxy = proxy;\n        }\n\n        void preExecute(MavenProject project, MojoInfo mojoInfo) throws IOException, InterruptedException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy proxy = proxies.get(name);\n            for (MavenReporter r : reporters.get(name))\n                if(!r.preExecute(proxy,project,mojoInfo,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n\n            mojoStartTime = System.currentTimeMillis();\n        }\n\n        void postExecute(MavenProject project, MojoInfo mojoInfo, Exception exception) throws IOException, InterruptedException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n\n            List<ExecutedMojo> mojoList = executedMojos.get(name);\n            if(mojoList==null)\n                executedMojos.put(name,mojoList=new ArrayList<ExecutedMojo>());\n            mojoList.add(new ExecutedMojo(mojoInfo,System.currentTimeMillis()-mojoStartTime));\n\n            MavenBuildProxy2 proxy = proxies.get(name);\n            for (MavenReporter r : reporters.get(name))\n                if(!r.postExecute(proxy,project,mojoInfo,listener,exception))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n            if(exception!=null)\n                proxy.setResult(Result.FAILURE);\n        }\n\n        void onReportGenerated(MavenProject project, MavenReportInfo report) throws IOException, InterruptedException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy proxy = proxies.get(name);\n            for (MavenReporter r : reporters.get(name))\n                if(!r.reportGenerated(proxy,project,report,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Used to tunnel exception from Maven through remoting.\n     */\n    private static final class MavenExecutionException extends RuntimeException {\n        private MavenExecutionException(Exception cause) {\n            super(cause);\n        }\n\n        @Override\n        public Exception getCause() {\n            return (Exception)super.getCause();\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Executed on the slave to parse POM and extract information into {@link PomInfo},\n     * which will be then brought back to the master.\n     */\n    private static final class PomParser implements FileCallable<List<PomInfo>> {\n        private final BuildListener listener;\n        private final String rootPOM;\n        /**\n         * Capture the value of the static field so that the debug flag\n         * takes an effect even when {@link PomParser} runs in a slave.\n         */\n        private final boolean verbose = debug;\n        private final MavenInstallation mavenHome;\n        private final String profiles;\n        private final Properties properties;\n        private final String privateRepository;\n        private final String alternateSettings;\n        private final boolean nonRecursive;\n        // We're called against the module root, not the workspace, which can cause a lot of confusion.\n        private final String workspaceProper;\n        \n        public PomParser(BuildListener listener, MavenInstallation mavenHome, MavenModuleSet project) {\n            // project cannot be shipped to the remote JVM, so all the relevant properties need to be captured now.\n            this.listener = listener;\n            this.mavenHome = mavenHome;\n            this.rootPOM = project.getRootPOM();\n            this.profiles = project.getProfiles();\n            this.properties = project.getMavenProperties();\n            this.nonRecursive = project.isNonRecursive();\n            this.workspaceProper = project.getLastBuild().getWorkspace().getRemote();\n            if (project.usesPrivateRepository()) {\n                this.privateRepository = project.getLastBuild().getWorkspace().child(\".repository\").getRemote();\n            } else {\n                this.privateRepository = null;\n            }\n            this.alternateSettings = project.getAlternateSettings();\n        }\n\n        /**\n         * Computes the path of {@link #rootPOM}.\n         *\n         * Returns \"abc\" if rootPOM=\"abc/pom.xml\"\n         * If rootPOM=\"pom.xml\", this method returns \"\".\n         */\n        private String getRootPath() {\n            int idx = Math.max(rootPOM.lastIndexOf('/'), rootPOM.lastIndexOf('\\\\'));\n            if(idx==-1) return \"\";\n            return rootPOM.substring(0,idx);\n        }\n\n        public List<PomInfo> invoke(File ws, VirtualChannel channel) throws IOException {\n            File pom = new File(ws,rootPOM);\n\n            PrintStream logger = listener.getLogger();\n\n            // choice of module root ('ws' in this method) is somewhat arbitrary\n            // when multiple CVS/SVN modules are checked out, so also check\n            // the path against the workspace root if that seems like what the user meant (see issue #1293)\n            File parentLoc = new File(ws.getParentFile(),rootPOM);\n            if(!pom.exists() && parentLoc.exists())\n                pom = parentLoc;\n\n            if(!pom.exists())\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchPOMFile(pom));\n\n            if(verbose)\n                logger.println(\"Parsing \"\n\t\t\t       + (nonRecursive ? \"non-recursively \" : \"recursively \")\n\t\t\t       + pom);\n\t    \n            File settingsLoc = (alternateSettings == null) ? null \n                : new File(workspaceProper, alternateSettings);\n\n            if ((settingsLoc != null) && (!settingsLoc.exists())) {\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchAlternateSettings(settingsLoc.getAbsolutePath()));\n            }\n\n            try {\n                MavenEmbedder embedder = MavenUtil.\n                        createEmbedder(listener, mavenHome.getHomeDir(), profiles,\n                                       properties, privateRepository, settingsLoc);\n                MavenProject mp = embedder.readProject(pom);\n                Map<MavenProject,String> relPath = new HashMap<MavenProject,String>();\n                MavenUtil.resolveModules(embedder,mp,getRootPath(),relPath,listener,nonRecursive);\n\n                if(verbose) {\n                    for (Entry<MavenProject, String> e : relPath.entrySet())\n                        logger.printf(\"Discovered %s at %s\\n\",e.getKey().getId(),e.getValue());\n                }\n\n                List<PomInfo> infos = new ArrayList<PomInfo>();\n                toPomInfo(mp,null,relPath,infos);\n\n                for (PomInfo pi : infos)\n                    pi.cutCycle();\n\n                embedder.stop();\n                return infos;\n            } catch (MavenEmbedderException e) {\n                throw new MavenExecutionException(e);\n            } catch (ProjectBuildingException e) {\n                throw new MavenExecutionException(e);\n            }\n        }\n\n        private void toPomInfo(MavenProject mp, PomInfo parent, Map<MavenProject,String> relPath, List<PomInfo> infos) {\n            PomInfo pi = new PomInfo(mp, parent, relPath.get(mp));\n            infos.add(pi);\n            for (MavenProject child : (List<MavenProject>)mp.getCollectedProjects())\n                toPomInfo(child,pi,relPath,infos);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(MavenModuleSetBuild.class.getName());\n\n    /**\n     * Extra verbose debug switch.\n     */\n    public static boolean debug = false;\n    \n    @Override\n    public MavenModuleSet getParent() {// don't know why, but javac wants this\n        return super.getParent();\n    }\n}\n", " TODO Auto-generated method stub\r\n\t\tPurse purse = new Purse();\r\n\t\tpurse.addCoin(\"Dime\");\r\n\t\tpurse.addCoin(\"Quarter\");\r\n\t\tpurse.addCoin(\"Penny\");\r\n\t\tpurse.addCoin(\"Nickel\");\r\n\t\tPurse pursec = new Purse();\r\n\t\tpursec.addCoin(\"Dime\");\r\n\t\tpursec.addCoin(\"Quarter\");\r\n\t\tpursec.addCoin(\"Penny\");\r\n\t\tpursec.addCoin(\"Nickel\");\r\n\t\tSystem.out.println(pursec.sameContents(purse));\r\n\t\tSystem.out.println(pursec.sameCoins(purse));\t\r\n\t\tSystem.out.println(purse);\r\n\t\tpurse.reverse();\r\n\t\tSystem.out.println(pursec.sameCoins(purse));\r\n\t\tSystem.out.println(pursec.sameContents(purse));\r\n\t\tSystem.out.println(purse);\r\n\t\tPurse purseb = new Purse();\r\n\t\tpurseb.addCoin(\"Half-Dollar\");\r\n\t\tpurseb.addCoin(\"Dollar Coin\");\r\n\t\tSystem.out.println(pursec.sameCoins(purseb));\r\n\t\tSystem.out.println(purseb);\r\n\t\tpurse.transfer(purseb);\r\n\t\tSystem.out.println(purse);\r\n\t\tSystem.out.println(purseb);\r\n\t}\r\n\r\n}\r\n", " * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.security;\n\nimport org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.Authentication;\nimport org.apache.commons.codec.digest.DigestUtils;\n\n/**\n * {@link TokenBasedRememberMeServices} with modification so as not to rely\n * on the user password being available.\n *\n * <p>\n * This allows remember-me to work with security realms where the password\n * is never available in clear text.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class TokenBasedRememberMeServices2 extends TokenBasedRememberMeServices {\n    @Override\n    protected String makeTokenSignature(long tokenExpiryTime, UserDetails userDetails) {\n        String expectedTokenSignature = DigestUtils.md5Hex(userDetails.getUsername() + \":\" + tokenExpiryTime + \":\"\n                + \"N/A\" + \":\" + getKey());\n        return expectedTokenSignature;\n    }\n\n    @Override\n    protected String retrievePassword(Authentication successfulAuthentication) {\n        return \"N/A\";\n    }\n}\n", "ull text.\n *\n * Copyright (c) 2014, Gluu\n */\n\npackage org.xdi.oxauth.model.error;\n\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlElementWrapper;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n/**\n * @author Yuriy Zabrovarnyy\n * @version 0.9, 26/12/2012\n */\n@XmlRootElement(name = \"errors\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class ErrorMessages {\n\n    @XmlElementWrapper(name = \"authorize\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> authorize;\n    @XmlElementWrapper(name = \"client-info\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> clientInfo;\n    @XmlElementWrapper(name = \"end-session\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> endSession;\n    @XmlElementWrapper(name = \"federation\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> federation;\n    @XmlElementWrapper(name = \"register\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> register;\n    @XmlElementWrapper(name = \"token\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> token;\n    @XmlElementWrapper(name = \"uma\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> uma;\n    @XmlElementWrapper(name = \"user-info\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> userInfo;\n    @XmlElementWrapper(name = \"validate-token\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> validateToken;\n\n    @XmlElementWrapper(name = \"fido\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> fido;\n\n    public List<ErrorMessage> getAuthorize() {\n        return authorize;\n    }\n\n    public void setAuthorize(List<ErrorMessage> p_authorize) {\n        authorize = p_authorize;\n    }\n\n    public List<ErrorMessage> getClientInfo() {\n        return clientInfo;\n    }\n\n    public void setClientInfo(List<ErrorMessage> p_clientInfo) {\n        clientInfo = p_clientInfo;\n    }\n\n    public List<ErrorMessage> getEndSession() {\n        return endSession;\n    }\n\n    public void setEndSession(List<ErrorMessage> p_endSession) {\n        endSession = p_endSession;\n    }\n\n    public List<ErrorMessage> getFederation() {\n        return federation;\n    }\n\n    public void setFederation(List<ErrorMessage> p_federation) {\n        federation = p_federation;\n    }\n\n    public List<ErrorMessage> getRegister() {\n        return register;\n    }\n\n    public void setRegister(List<ErrorMessage> p_register) {\n        register = p_register;\n    }\n\n    public List<ErrorMessage> getToken() {\n        return token;\n    }\n\n    public void setToken(List<ErrorMessage> p_token) {\n        token = p_token;\n    }\n\n    public List<ErrorMessage> getUma() {\n        return uma;\n    }\n\n    public void setUma(List<ErrorMessage> p_uma) {\n        uma = p_uma;\n    }\n\n    public List<ErrorMessage> getUserInfo() {\n        return userInfo;\n    }\n\n    public void setUserInfo(List<ErrorMessage> p_userInfo) {\n        userInfo = p_userInfo;\n    }\n\n    public List<ErrorMessage> getValidateToken() {\n        return validateToken;\n    }\n\n    public void setValidateToken(List<ErrorMessage> p_validateToken) {\n        validateToken = p_validateToken;\n    }\n\n\tpublic List<ErrorMessage> getFido() {\n\t\treturn fido;\n\t}\n\n\tpublic void setFido(List<ErrorMessage> fido) {\n\t\tthis.fido = fido;\n\t}\n\n}", "rt java.util.Map;\nimport java.util.Set;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.conf.Configured;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.util.Tool;\nimport org.apache.hadoop.util.ToolRunner;\n\nimport edu.jhu.thrax.hadoop.features.annotation.AnnotationFeature;\nimport edu.jhu.thrax.hadoop.features.annotation.AnnotationFeatureFactory;\nimport edu.jhu.thrax.hadoop.features.annotation.AnnotationFeatureJob;\nimport edu.jhu.thrax.hadoop.features.mapred.MapReduceFeature;\nimport edu.jhu.thrax.hadoop.features.mapred.MapReduceFeatureFactory;\nimport edu.jhu.thrax.hadoop.features.pivot.PivotedFeature;\nimport edu.jhu.thrax.hadoop.features.pivot.PivotedFeatureFactory;\nimport edu.jhu.thrax.hadoop.jobs.DistributionalContextExtractionJob;\nimport edu.jhu.thrax.hadoop.jobs.DistributionalContextSortingJob;\nimport edu.jhu.thrax.hadoop.jobs.ExtractionJob;\nimport edu.jhu.thrax.hadoop.jobs.FeatureCollectionJob;\nimport edu.jhu.thrax.hadoop.jobs.JobState;\nimport edu.jhu.thrax.hadoop.jobs.OutputJob;\nimport edu.jhu.thrax.hadoop.jobs.ParaphraseAggregationJob;\nimport edu.jhu.thrax.hadoop.jobs.ParaphrasePivotingJob;\nimport edu.jhu.thrax.hadoop.jobs.Scheduler;\nimport edu.jhu.thrax.hadoop.jobs.SchedulerException;\nimport edu.jhu.thrax.hadoop.jobs.ThraxJob;\nimport edu.jhu.thrax.hadoop.jobs.VocabularyJob;\nimport edu.jhu.thrax.util.BackwardsCompatibility;\nimport edu.jhu.thrax.util.ConfFileParser;\n\npublic class Thrax extends Configured implements Tool {\n  private Scheduler scheduler;\n  private Configuration conf;\n\n  public synchronized int run(String[] argv) throws Exception {\n    if (argv.length < 1) {\n      System.err.println(\"usage: Thrax <conf file> [output path]\");\n      return 1;\n    }\n    // do some setup of configuration\n    conf = getConf();\n    Map<String, String> options = ConfFileParser.parse(argv[0]);\n    for (String opt : options.keySet())\n      conf.set(\"thrax.\" + opt, options.get(opt));\n    String date = (new Date()).toString().replaceAll(\"\\\\s+\", \"_\").replaceAll(\":\", \"_\");\n\n    String workDir = \"thrax_run_\" + date + Path.SEPARATOR;\n\n    if (argv.length > 1) {\n      workDir = argv[1];\n      if (!workDir.endsWith(Path.SEPARATOR)) workDir += Path.SEPARATOR;\n    }\n\n    conf.set(\"thrax.work-dir\", workDir);\n    conf.set(\"thrax.outputPath\", workDir + \"final\");\n\n    if (options.containsKey(\"timeout\")) {\n      conf.setInt(\"mapreduce.task.timeout\", Integer.parseInt(options.get(\"timeout\")));\n      conf.setInt(\"mapred.task.timeout\", Integer.parseInt(options.get(\"timeout\")));\n    }\n\n    scheduleJobs();\n\n    do {\n      for (Class<? extends ThraxJob> c : scheduler.getClassesByState(JobState.READY)) {\n        scheduler.setState(c, JobState.RUNNING);\n        (new Thread(new ThraxJobWorker(this, c, conf))).start();\n      }\n      wait();\n    } while (scheduler.notFinished());\n    System.err.print(scheduler);\n    if (scheduler.getClassesByState(JobState.SUCCESS).size() == scheduler.numJobs()) {\n      System.err.println(\"Work directory was \" + workDir);\n      System.err.println(\"To retrieve grammar:\");\n      System.err.println(\"hadoop fs -getmerge \" + conf.get(\"thrax.outputPath\", \"\")\n          + \" <destination>\");\n    }\n    return 0;\n  }\n\n  // Schedule all the jobs required for grammar extraction. We\n  // currently distinguish three modes: translation grammar extraction,\n  // paraphrase grammar extraction, and collection of distributional signatures.\n  private synchronized void scheduleJobs() throws SchedulerException {\n    scheduler = new Scheduler(conf);\n\n    String type = conf.get(\"thrax.type\", \"translation\");\n    String features = BackwardsCompatibility.equivalent(conf.get(\"thrax.features\", \"\"));\n\n    System.err.println(\"Running in mode: \" + type);\n\n    scheduler.schedule(VocabularyJob.class);\n\n    // Translation grammar mode.\n    if (\"translation\".equals(type)) {\n      // Schedule rule extraction job.\n      scheduler.schedule(ExtractionJob.class);\n      // Create feature map-reduces.\n      for (MapReduceFeature f : MapReduceFeatureFactory.getAll(features)) {\n        scheduler.schedule(f.getClass());\n        OutputJob.addPrerequisite(f.getClass());\n      }\n      // Set up annotation-level feature & prerequisites.\n      List<AnnotationFeature> annotation_features = AnnotationFeatureFactory.getAll(features);\n      for (AnnotationFeature f : annotation_features)\n        AnnotationFeatureJob.addPrerequisites(f.getPrerequisites());\n      if (!annotation_features.isEmpty()) {\n        scheduler.schedule(AnnotationFeatureJob.class);\n        OutputJob.addPrerequisite(AnnotationFeatureJob.class);\n      }\n      scheduler.schedule(OutputJob.class);\n\n      scheduler.percolate(OutputJob.class);\n\n      // Paraphrase grammar mode.\n    } else if (\"paraphrasing\".equals(type)) {\n      // Schedule rule extraction job.\n      scheduler.schedule(ExtractionJob.class);\n      // Collect the translation grammar features required to compute\n      // the requested paraphrasing features.\n      Set<String> prereq_features = new HashSet<String>();\n      List<PivotedFeature> pivoted_features = PivotedFeatureFactory.getAll(features);\n      for (PivotedFeature pf : pivoted_features) {\n        prereq_features.addAll(pf.getPrerequisites());\n      }\n      // Next, schedule translation features and register with feature\n      // collection job.\n      boolean annotation_features = false;\n      for (String f_name : prereq_features) {\n        MapReduceFeature mf = MapReduceFeatureFactory.get(f_name);\n        if (mf != null) {\n          scheduler.schedule(mf.getClass());\n          FeatureCollectionJob.addPrerequisite(mf.getClass());\n        } else {\n          AnnotationFeature af = AnnotationFeatureFactory.get(f_name);\n          if (af != null) {\n            AnnotationFeatureJob.addPrerequisites(af.getPrerequisites());\n            annotation_features = true;\n          }\n        }\n      }\n      if (annotation_features) {\n        scheduler.schedule(AnnotationFeatureJob.class);\n        FeatureCollectionJob.addPrerequisite(AnnotationFeatureJob.class);\n      }\n      scheduler.schedule(FeatureCollectionJob.class);\n      // Schedule pivoting and pivoted feature computation job.\n      scheduler.schedule(ParaphrasePivotingJob.class);\n      // Schedule aggregation and output job.\n      scheduler.schedule(ParaphraseAggregationJob.class);\n      scheduler.percolate(ParaphraseAggregationJob.class);\n    } else if (\"distributional\".equals(type)) {\n      scheduler.schedule(DistributionalContextExtractionJob.class);\n      scheduler.schedule(DistributionalContextSortingJob.class);\n      scheduler.percolate(DistributionalContextSortingJob.class);\n    } else {\n      System.err.println(\"Unknown grammar type. No jobs scheduled.\");\n    }\n  }\n\n  public static void main(String[] argv) throws Exception {\n    ToolRunner.run(null, new Thrax(), argv);\n    return;\n  }\n\n  protected synchronized void workerDone(Class<? extends ThraxJob> theClass, boolean success) {\n    try {\n      scheduler.setState(theClass, success ? JobState.SUCCESS : JobState.FAILED);\n    } catch (SchedulerException e) {\n      System.err.println(e.getMessage());\n    }\n    notify();\n    return;\n  }\n\n  public class ThraxJobWorker implements Runnable {\n    private Thrax thrax;\n    private Class<? extends ThraxJob> theClass;\n\n    public ThraxJobWorker(Thrax t, Class<? extends ThraxJob> c, Configuration conf) {\n      thrax = t;\n      theClass = c;\n    }\n\n    public void run() {\n      try {\n        ThraxJob thraxJob = theClass.newInstance();\n        Job job = thraxJob.getJob(conf);\n        job.waitForCompletion(false);\n        thrax.workerDone(theClass, job.isSuccessful());\n      } catch (Exception e) {\n        e.printStackTrace();\n        thrax.workerDone(theClass, false);\n      }\n      return;\n    }\n  }\n}\n", "s NonRetryableNakadiException extends NakadiException {\n\n  /**\n   * @param problem the Problem detail\n   */\n  public NonRetryableNakadiException(Problem problem) {\n    super(problem);\n  }\n\n  /**\n   * @param problem the Problem detail\n   * @param cause the cause\n   */\n  public NonRetryableNakadiException(Problem problem, Throwable cause) {\n    super(problem, cause);\n  }\n\n}\n", "or4j.parser.Email;\n\npublic class WarningsNotAllowed implements ValidationStrategy {\n    @Override\n    public Boolean isValid(String email, Email parser) {\n        return parser.getWarnings().size() == 0;\n    }\n}\n", "ted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage fredboat.util;\n\n/**\n * Created by napster on 25.09.17.\n */\npublic class Emojis {\n\n    public static final String EXCLAMATION = \"\u2757\";\n    public static final String OK = \"\u2705\";\n    public static final String BAD = \"\u274c\";\n    public static final String PENCIL = \"\ud83d\udcdd\";\n    public static final String DOOR = \"\ud83d\udeaa\";\n\n}\n", "al.artofsoul.ndihma.Artist.VizatoKatrorTexRot;\nimport static al.artofsoul.ndihma.Ora.Delta;\n\nimport java.util.ArrayList;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.newdawn.slick.opengl.Texture;\n\npublic abstract class Tower implements Entity {\n\t\n\tprivate float x, y, timeSinceLastShot, firingSpeed, angle;\n\tprivate int width, height, range, cost;\n\tpublic Armiku target;\n\tprivate Texture[] textures;\n\tprivate CopyOnWriteArrayList<Armiku> armiqt;\n\tprivate boolean targeted;\n\tpublic ArrayList<Projectile> projectiles;\n\tpublic TowerType type;\n\n\tpublic Tower(TowerType type, Pllaka filloPllaka, CopyOnWriteArrayList<Armiku> armiqt) {\n\t\tthis.type = type;\n\t\tthis.textures = type.textures;\n\t\tthis.range = type.range;\n\t\tthis.cost = type.cost;\n\t\tthis.x = filloPllaka.getX();\n\t\tthis.y = filloPllaka.getY();\n\t\tthis.width = filloPllaka.getWidth();\n\t\tthis.height = filloPllaka.getHeight();\n\t\tthis.armiqt = armiqt;\n\t\tthis.targeted = false;\n\t\tthis.timeSinceLastShot = 0f;\n\t\tthis.projectiles = new ArrayList<Projectile>();\n\t\tthis.firingSpeed = type.firingSpeed;\n\t\tthis.angle = 0f;\n\t}\n\t\n\tprivate Armiku acquireTarget() {\n\t\tArmiku closest = null;\n\t\t// arbitrary distance (Larger than map), to help with sorting Enemy distances\n\t\tfloat closestDistance = 1000;\n\t\t// Go thought each Enemy in 'Armiku' and return nearest one\n\t\tfor (Armiku e: armiqt) {\n\t\t\tif (isInRange(e) && findDistance(e) < closestDistance && e.isAlive()) {//e.getHiddenHealth() > 0) {\n\t\t\t\tclosestDistance = findDistance(e);\n\t\t\t\tclosest = e;\n\t\t\t}\n\t\t}\n\t\t// if an enemy exists an is returned, targeted == true\n\t\tif (closest != null)\n\t\t\ttargeted = true;\n\t\treturn closest;\n\t}\n\t\n\tprivate boolean isInRange(Armiku e) {\n\t\tfloat xDistance = Math.abs(e.getX() - x);\n\t\tfloat yDistance = Math.abs(e.getY() - y);\n\t\tif (xDistance < range && yDistance < range)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\t\n\tprivate float findDistance(Armiku e) {\n\t\tfloat xDistance = Math.abs(e.getX() - x);\n\t\tfloat yDistance = Math.abs(e.getY() - y);\n\t\treturn xDistance + yDistance;\n\t}\n\t\n\tprivate float calculateAngle () {\n\t\tdouble angleTemp = Math.atan2(target.getY() - y, target.getX() - x);\n\t\treturn (float) Math.toDegrees(angleTemp) - 90;\t\n\t}\n\t//abstarct method for 'shoot', must be override in subclasses\n\tpublic abstract void shoot (Armiku target);\n\t\n\tpublic void updateEnemyLists(CopyOnWriteArrayList<Armiku> newList) {\n\t\tarmiqt = newList;\n\t}\n\t\n\tpublic void update(){\n\t\tif (!targeted ) { //|| target.getHiddenHealth() < 0 ) {\n\t\t\ttarget = acquireTarget();\n\t\t} else {\n\t\t\tangle = calculateAngle();\n\t\t\tif (timeSinceLastShot > firingSpeed) {\n\t\t\t\tshoot(target);\n\t\t\t\ttimeSinceLastShot = 0;\n\t\t\t}\n\t\t}\n\t\tif (target == null || target.isAlive() == false)\n\t\t\ttargeted = false;\n\t\t\n\t\ttimeSinceLastShot += Delta();\n\t\t\n\t\tfor (Projectile p: projectiles)\n\t\t\tp.update();\n\t\t\n\t\tdraw();\n\t}\n\n\tpublic void draw() {\n\t\tVizatoKatrorTex(textures[0], x, y, width, height);\n\t\tif (textures.length > 1)\n\t\t\tfor(int i = 1; i < textures.length; i++)\n\t\t\t\tVizatoKatrorTexRot(textures[i], x, y, width, height, angle);\n\t}\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setX(float x) {\n\t\tthis.x = x;\t\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\t\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\t\n\t}\n\t\n\tpublic Armiku getTarget() {\n\t\treturn target;\n\t}\n\tpublic int getCost() {\n\t\treturn cost;\n\t}\n}\n", "ls.XKOS;\nimport org.apache.jena.rdf.model.*;\nimport org.apache.jena.sparql.vocabulary.FOAF;\nimport org.apache.jena.vocabulary.DC;\nimport org.apache.jena.vocabulary.DCTerms;\nimport org.apache.jena.vocabulary.RDFS;\nimport org.apache.jena.vocabulary.SKOS;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.WorkbookFactory;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Iterator;\n\n/**\n * The <code>SBIModelMaker</code> class creates and saves the Jena model corresponding to the Dutch SBI 2008 classification.\n * \n * @author Franck Cotton\n */\npublic class SBIModelMaker {\n\n\t/** Base local folder for reading and writing files */\n\tpublic static String LOCAL_FOLDER = \"src/main/resources/data/\";\n\n\t/** File name of the spreadsheet containing the SBI structure */\n\tpublic static String SBI_FILE = \"sbi 2008 versie 2016 engels.xls\";\n\n\t/** Base URI for the RDF resources belonging to NAICS */\n\tpublic final static String BASE_URI = \"http://stamina-project.org/codes/sbi2008/\";\n\n\t/** Base URI for the RDF resources belonging to the NACE-SBI correspondence */\n\tpublic final static String NACE_SBI_BASE_URI = \"http://stamina-project.org/codes/nacer2-sbi2008/\";\n\n\t/** Log4J2 logger */ // This must be before the configuration initialization\n\tprivate static final Logger logger = LogManager.getLogger(SBIModelMaker.class);\n\n\t/** Current Jena model */\n\tprivate Model model = null;\n\n\t/** RDF resource corresponding to the classification scheme */\n\tResource scheme = null;\n\n\t/** List of RDF resources corresponding to the classification levels */\n\tRDFList levelList = null;\n\n\t/**\n\t * Main method: reads the spreadsheet and creates the triplets in the model.\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tSBIModelMaker modelMaker = new SBIModelMaker();\n\t\t// Creation of the classification and its levels\n\t\tmodelMaker.initializeModel();\n\t\tmodelMaker.createClassificationAndLevels();\n\t\tmodelMaker.populateScheme();\n\t\tmodelMaker.writeModel(LOCAL_FOLDER + \"sbi2008.ttl\");\n\t\tmodelMaker.initializeModel();\n\t\tmodelMaker.createNACESBIHierarchy();\n\t\tmodelMaker.writeModel(LOCAL_FOLDER + \"nacer2-sbi2008.ttl\");\n\t}\n\n\t/**\n\t * Creates the statements corresponding to the classification items.\n\t * \n\t * @throws Exception In case of problem.\n\t */\n\tprivate void populateScheme() throws Exception {\n\n\t\t// Read the Excel file and create the classification items\n\t\tInputStream sourceFile = new FileInputStream(LOCAL_FOLDER + SBI_FILE);\n\t\tSheet items = WorkbookFactory.create(sourceFile).getSheetAt(0);\n\t\ttry {sourceFile.close();} catch(Exception ignored) {}\n\n\t\tIterator<Row> rows = items.rowIterator ();\n\t\twhile (rows.hasNext() && rows.next().getRowNum() < 2); // Skip the header lines\n\t\twhile (rows.hasNext()) {\n\t\t\tRow row = rows.next();\n\n\t\t\t// The code and label are in the first cell, separated by the first space\n\t\t\tString line = row.getCell(0, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK).toString();\n\n\t\t\t// Skip empty lines\n\t\t\tif (line == null) continue;\n\n\t\t\tint firstSpace = line.indexOf(' ');\n\t\t\tString itemCode = line.substring(0, firstSpace);\n\t\t\tString itemLabel = line.substring(firstSpace + 1).trim();\n\t\t\tint level = getItemLevelDepth(itemCode);\n\n\t\t\t// Create the resource representing the classification item (skos:Concept), with its code and label\n\t\t\tResource itemResource = model.createResource(getItemURI(itemCode), SKOS.Concept);\n\t\t\titemResource.addProperty(SKOS.notation, itemCode);\n\t\t\titemResource.addProperty(SKOS.prefLabel, itemLabel, \"en\");\n\n\t\t\t// Attach the item to its level\n\t\t\tResource levelResource = (Resource) levelList.get(level - 1);\n\t\t\tlevelResource.addProperty(SKOS.member, itemResource);\n\t\t\t\n\t\t\t// Attach the item to its classification\n\t\t\titemResource.addProperty(SKOS.inScheme, scheme);\n\t\t\tif (level == 1) {\n\t\t\t\tscheme.addProperty(SKOS.hasTopConcept, itemResource);\n\t\t\t\titemResource.addProperty(SKOS.topConceptOf, scheme);\t\t\t\t\n\t\t\t}\n\n\t\t\t// Attach the item to its parent item (for level > 1)\n\t\t\tif (level > 1) {\n\t\t\t\tResource parentResource = model.createResource(getItemURI(getParentCode(itemCode)));\n\t\t\t\tparentResource.addProperty(SKOS.narrower, itemResource);\n\t\t\t\titemResource.addProperty(SKOS.broader, parentResource);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a model containing the resources representing the correspondence between NACE and SBI.\n\t */\n\tprivate void createNACESBIHierarchy() throws Exception {\n\n\t\t// Read the Excel file and create the classification items\n\t\tInputStream sourceFile = new FileInputStream(SBI_FILE);\n\t\tSheet items = WorkbookFactory.create(sourceFile).getSheetAt(0);\n\t\ttry {sourceFile.close();} catch(Exception ignored) {}\n\n\t\t// Creation of the correspondence table resource\n\t\tResource table = model.createResource(NACE_SBI_BASE_URI + \"correspondence\", XKOS.Correspondence);\n\t\ttable.addProperty(SKOS.definition, \"Correspondence table between NACE Rev. 2 and SBI 2008\");\n\t\ttable.addProperty(XKOS.compares, model.createResource(Names.getCSURI(\"NACE\", \"2\")));\n\t\ttable.addProperty(XKOS.compares, model.createResource(BASE_URI + \"sbi\"));\n\n\t\tIterator<Row> rows = items.rowIterator ();\n\t\twhile (rows.hasNext() && rows.next().getRowNum() < 2); // Skip the header lines\n\t\twhile (rows.hasNext()) {\n\t\t\tRow row = rows.next();\n\t\t\tString line = row.getCell(0, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK).toString();\n\n\t\t\tif (line == null) continue;\n\t\t\tint firstSpace = line.indexOf(' ');\n\t\t\tString sbiCode = line.substring(0, firstSpace);\n\n\t\t\tString naceCode = sbiToNACECode(sbiCode);\n\n\t\t\tResource association = model.createResource(NACE_SBI_BASE_URI + \"association/\" + naceCode + \"-\" + sbiCode, XKOS.ConceptAssociation);\n\t\t\tassociation.addProperty(RDFS.label, \"NACE Rev.2 \" + naceCode + \" - SBI 2008 \" + sbiCode);\n\t\t\tResource naceItemResource = model.createResource(Names.getItemURI(naceCode, \"NACE\", \"2\"));\n\t\t\tResource sbiItemResource = model.createResource(getItemURI(sbiCode));\n\t\t\tassociation.addProperty(XKOS.sourceConcept, naceItemResource);\t\n\t\t\tassociation.addProperty(XKOS.targetConcept, sbiItemResource);\n\t\t\t// TODO When is it exact match?\n\t\t\tnaceItemResource.addProperty(SKOS.narrowMatch, sbiItemResource);\n\t\t\tsbiItemResource.addProperty(SKOS.broadMatch, naceItemResource);\n\t\t\ttable.addProperty(XKOS.madeOf, association);\n\t\t}\n\t}\n\n\t/**\n\t * Creates in the model the resources representing the classification and its levels.\n\t */\n \tpublic void createClassificationAndLevels() {\n\n\t\t// Create the resource representing the classification (skos:ConceptScheme)\n\t\tscheme = model.createResource(BASE_URI + \"sbi\", SKOS.ConceptScheme);\n\t\tscheme.addProperty(SKOS.prefLabel, model.createLiteral(\"Dutch Standaard Bedrijfsindeling (SBI) 2008\", \"en\")); // TODO Not really English\n\t\tscheme.addProperty(SKOS.notation, \"SBI 2008\"); // TODO What distinguishes annual versions?\n\t\tscheme.addProperty(SKOS.definition, model.createLiteral(\"The Standard Industrial Classification is a classification of economic activities designed by the Central Bureau of Statistics of the Netherlands (CBS) that aims to provide a uniform classification of the economy for the benefit of detailed economic analyzes and statistics.\", \"en\"));\n\t\tscheme.addProperty(DC.publisher, model.createResource(\"http://www.cbs.nl\"));\n\t\tscheme.addProperty(DCTerms.issued, model.createTypedLiteral(\"2008-01-01\", \"http://www.w3.org/2001/XMLSchema#date\"));\n\t\tscheme.addProperty(DCTerms.modified, model.createTypedLiteral(\"2016-01-01\", \"http://www.w3.org/2001/XMLSchema#date\"));\n\t\tscheme.addProperty(FOAF.homepage, model.createResource(\"https://www.cbs.nl/en-gb/our-services/methods/classifications/activiteiten/standard-industrial-classifications--dutch-sbi-2008-nace-and-isic--\"));\n\t\tscheme.addProperty(XKOS.covers, model.createResource(\"http://eurovoc.europa.eu/5992\"));\n\t\tscheme.addProperty(XKOS.numberOfLevels, model.createTypedLiteral(5));\n\n\t\t// Create the resources representing the levels (xkos:ClassificationLevel)\n\t\tResource level1 = model.createResource(BASE_URI + \"/sections\", XKOS.ClassificationLevel);\n\t\tlevel1.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 1 - Sections\", \"en\"));\n\t\tlevel1.addProperty(XKOS.depth, model.createTypedLiteral(1));\n\t\tlevel1.addProperty(XKOS.notationPattern, \"[A-U]\");\n\t\tlevel1.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/section\"));\n\n\t\tResource level2 = model.createResource(BASE_URI + \"/divisions\", XKOS.ClassificationLevel);\n\t\tlevel2.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 2 - Divisions\", \"en\"));\n\t\tlevel2.addProperty(XKOS.depth, model.createTypedLiteral(2));\n\t\tlevel2.addProperty(XKOS.notationPattern, \"[0-9]{2}\");\n\t\tlevel2.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/division\"));\n\n\t\tResource level3 = model.createResource(BASE_URI + \"/groups\", XKOS.ClassificationLevel);\n\t\tlevel3.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 3 - Groups\", \"en\"));\n\t\tlevel3.addProperty(XKOS.depth, model.createTypedLiteral(3));\n\t\tlevel3.addProperty(XKOS.notationPattern, \"[0-9]{3}\");\n\t\tlevel3.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/group\"));\n\n\t\tResource level4 = model.createResource(BASE_URI + \"/classes\", XKOS.ClassificationLevel);\n\t\tlevel4.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 4 - Classes\", \"en\"));\n\t\tlevel4.addProperty(XKOS.depth, model.createTypedLiteral(4));\n\t\tlevel4.addProperty(XKOS.notationPattern, \"[0-9]{4}\");\n\t\tlevel4.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/class\"));\n\n\t\tResource level5 = model.createResource(BASE_URI + \"/subclasses\", XKOS.ClassificationLevel);\n\t\tlevel5.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 5 - Subclasses\", \"en\"));\n\t\tlevel5.addProperty(XKOS.depth, model.createTypedLiteral(5));\n\t\tlevel5.addProperty(XKOS.notationPattern, \"[0-9]{5}\");\n\t\tlevel5.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/subclass\"));\n\n\t\t// Attach the level list to the classification\n\t\tlevelList = model.createList(level1, level2, level3, level4, level5);\n\t\tscheme.addProperty(XKOS.levels, levelList);\n\t}\n\n\t/**\n\t * Initializes the Jena model and adds standard prefixes.\n\t */\n\tprivate void initializeModel() {\n\n\t\ttry {\n\t\t\tif (model != null) model.close(); // Just in case\n\t\t} catch (Exception ignored) {}\n\n\t\tmodel = ModelFactory.createDefaultModel();\n\t\tmodel.setNsPrefix(\"rdfs\", RDFS.getURI());\n\t\tmodel.setNsPrefix(\"skos\", SKOS.getURI());\n\t\tmodel.setNsPrefix(\"xkos\", XKOS.getURI());\n\n\t\tlogger.debug(\"Jena model initialized\");\n\n\t}\n\n\t/**\n\t * Writes the model to the output Turtle file.\n\t * \n\t * @throws IOException In case of problem writing the file\n\t */\n\tprivate void writeModel(String fileName) throws IOException {\n\n\t\tmodel.write(new FileOutputStream(fileName), \"TTL\");\n\t\t// Close the model\n\t\tmodel.close();\n\t}\n\n\t\n\t/**\n\t * Computes the parent code for one given SBI code.\n\t */\n\tprivate static String getParentCode(String code) {\n\n\t\tif ((code.length() == 1) || (code.length() > 5)) return null;\n\n\t\tif (code.length() == 2) return Names.getNACESectionForDivision(code);\n\n\t\t// For codes of length 3 to 5, parent code is the child code truncated on the right\n\t\treturn code.substring(0, code.length() - 1);\n\t}\n\n\t/**\n\t * Computes the NACE code corresponding to a SBI code.\n\t * \n\t * @param sbiCode A SBI code.\n\t * @return The NACE code corresponding to the SBI code.\n\t */\n\tpublic static String sbiToNACECode(String sbiCode) {\n\n\t\t// TODO\n\t\treturn sbiCode;\n\t}\n\n\t/**\n\t * Computes the URI of a SBI classification item.\n\t * \n\t * @param code The item code.\n\t * @return The item URI.\n\t */\n\tprivate static String getItemURI(String code) {\n\n\t\tint level = getItemLevelDepth(code);\n\n\t\tif (level == 1) return BASE_URI + \"section/\" + code;\n\t\tif (level == 2) return BASE_URI + \"division/\" + code;\n\t\tif (level == 3) return BASE_URI + \"group/\" + code;\n\t\tif (level == 4) return BASE_URI + \"class/\" + code;\n\t\tif (level == 5) return BASE_URI + \"subclass/\" + code; // TODO Check this\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the depth of the level to which an item belongs.\n\t * \n\t * @param code The item code.\n\t * @return The depth of the level.\n\t */\n\tpublic static int getItemLevelDepth(String code) {\n\n\t\treturn code.length();\n\t}\n}\n", "fcr.wwwinfo.ares.xml_doc.schemas.ares.ares_datatypes.v_1_0.AresDotazTyp2;\nimport cz.mfcr.wwwinfo.ares.xml_doc.schemas.ares.ares_datatypes.v_1_0.VystupFormat2;\nimport cz.mfcr.wwwinfo.ares.xml_doc.schemas.ares.ares_request.v_1_0.AresDotazy;\nimport cz.mfcr.wwwinfo.ares.xml_doc.schemas.ares.ares_request.v_1_0.Dotaz;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class StandardRequestTemplateTest {\n\n    @Test\n    public void testQueryCounter() {\n        StandardRequestTemplate requestTemplate = new StandardRequestTemplate();\n        Assert.assertEquals(\"Counter is NOT initialized to zero.\", 0, requestTemplate.getRequest().getDotazPocet());\n        Assert.assertEquals(\"List of queries is NOT empty.\", 0, requestTemplate.getRequest().getDotaz().size());\n\n        requestTemplate.addQuery(new Dotaz());\n        Assert.assertEquals(\"Counter wasn't incremented.\", 1, requestTemplate.getRequest().getDotazPocet());\n        Assert.assertEquals(\"Size of queries list is NOT 1.\", 1, requestTemplate.getRequest().getDotaz().size());\n\n        requestTemplate.addQuery(new Dotaz());\n        requestTemplate.addQuery(new Dotaz());\n        Assert.assertEquals(\"Counter is NOT 3.\", 3, requestTemplate.getRequest().getDotazPocet());\n        Assert.assertEquals(\"Size of queries list is NOT 3.\", 3, requestTemplate.getRequest().getDotaz().size());\n    }\n\n    @Test\n    public void testStandardSettings() {\n        StandardRequestTemplate requestTemplate = new StandardRequestTemplate();\n        AresDotazy request = requestTemplate.getRequest();\n\n        Assert.assertEquals(\"Type of request is NOT set.\", AresDotazTyp2.STANDARD, request.getDotazTyp());\n        Assert.assertEquals(\"ID of request is NOT set.\", \"ares_dotaz\", request.getId());\n        Assert.assertEquals(\"Output format of request is NOT set.\", VystupFormat2.XML, request.getVystupFormat());\n    }\n}", "ion;\nimport java.io.RandomAccessFile;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport backend.disk.Directory;\nimport backend.disk.Disk;\nimport backend.disk.Inode;\n\npublic class User {\n\tprivate String username;\n\tprivate String grpName;\n\t\n\tprivate int userId;\n\tprivate int grpId;\n\tprivate int homeDirInodeNum;\n\t\n\tprivate static final String pswdFilePath = Disk.transDisk.toString() + \"/pswd\";\n\tprivate static final String grpListPath = Disk.transDisk.toString() + \"/groupList\";\n\t\n\tprivate User(String username, String grpName, int userId, int grpId) {\n\t\tthis.username = username;\n\t\tthis.grpName = grpName;\n\t\tthis.userId = userId;\n\t\tthis.grpId = grpId;\n\t}\n\t\n\tpublic static User createNewUser(String newUsername, String password, String grpName) {\n\t\tUser newUser = null;\n\t\tboolean noProblem = true;\n\t\tint entriesRead = 1;\n\t\ttry {\n\t\t\tRandomAccessFile pswdF = new RandomAccessFile(User.pswdFilePath, \"rw\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = pswdF.readLine()) != null ) {\n\t\t\t\tentriesRead++;\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[0].compareTo(newUsername) == 0) {\n\t\t\t\t\tnoProblem = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(noProblem) {\n\t\t\t\tint grpId = calculateGrpId(grpName);\n\t\t\t\tnewUser = new User(newUsername, grpName, entriesRead, grpId);\n\t\t\t\tTransSystem.setUser(newUser);\n\t\t\t\tDirectory.godMode = true;\n\t\t\t\tDirectory rootDir = new Directory(2);\n\t\t\t\tInode homeDirInode;\n\t\t\t\ttry {\n\t\t\t\t\thomeDirInode = rootDir.makeDir(newUsername);\n\t\t\t\t\tnewUser.homeDirInodeNum = homeDirInode.getInodeNum();\n\t\t\t\t} catch (PermissionDeniedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tDirectory.godMode = false;\n\t\t\t\t\n\t\t\t\tpswdF.writeBytes(newUsername + \"\\t\" + User.hashIt(password) + \"\\t\" + entriesRead + \"\\t\" + grpId + \"\\t\" + newUser.homeDirInodeNum +\"\\n\");\n\t\t\t}\n\t\t\tpswdF.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn newUser;\n\t}\n\t\n\tprivate static int calculateGrpId(String grpName) {\n\t\tint grpId = 0, entriesRead = 1;\n\t\ttry {\n\t\t\tRandomAccessFile grpListFile = new RandomAccessFile(User.grpListPath, \"rw\");\n\t\t\tString buffer;\n\t\t\tboolean found = false;\n\t\t\twhile(!found && (buffer = grpListFile.readLine()) != null) {\n\t\t\t\tentriesRead++;\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[1].compareTo(grpName) == 0) {\n\t\t\t\t\tgrpId = Integer.parseInt(splitBuffer[0]);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) {\n\t\t\t\tgrpListFile.writeBytes(entriesRead + \"\\t\" + grpName + \"\\n\");\n\t\t\t\tgrpId = entriesRead;\n\t\t\t}\n\t\t\tgrpListFile.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn grpId;\n\t}\n\n\tpublic static String hashIt(String input) {\n\t\tMessageDigest m = null;\n\t\ttry {\n\t\t\tm = MessageDigest.getInstance(\"MD5\");\n\t\t} catch (NoSuchAlgorithmException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tm.reset();\n\t\tm.update(input.getBytes());\n\t\tbyte[] digest = m.digest();\n\t\tBigInteger bigInt = new BigInteger(1,digest);\n\t\tString hashtext = bigInt.toString(16);\n\t\t// Now we need to zero pad it if you actually want the full 32 chars.\n\t\twhile(hashtext.length() < 32 ){\n\t\t  hashtext = \"0\"+hashtext;\n\t\t}\n\t\treturn hashtext;\n\t}\n\n\tpublic String getUsername() {\n\t\treturn this.username;\n\t}\n\tpublic String getGrpName() {\n\t\treturn this.grpName;\n\t}\n\tpublic int getUserId() {\n\t\treturn this.userId;\n\t}\n\tpublic int getGrpId() {\n\t\treturn this.grpId;\n\t}\n\t\n\tpublic static void initUserMgnt() {\n\t\tFile pswdFile = new File(User.pswdFilePath);\n\t\tFile grpListFile = new File(User.grpListPath);\n\t\ttry {\n\t\t\tif(!pswdFile.exists())\n\t\t\t\tpswdFile.createNewFile();\n\t\t\t\n\t\t\tif(!grpListFile.exists())\n\t\t\t\tgrpListFile.createNewFile();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static User authenticate(String username, String pswd) {\n\t\tUser authenticatedUser = null;\n\t\tboolean authenticated = false;\n\t\ttry {\n\t\t\tRandomAccessFile pswdFile = new RandomAccessFile(User.pswdFilePath, \"r\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = pswdFile.readLine()) != null && !authenticated) {\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[0].compareTo(username) == 0) {\n\t\t\t\t\tif(splitBuffer[1].compareTo(User.hashIt(pswd)) == 0) {\n\t\t\t\t\t\tauthenticatedUser = new User(username, User.getGrpName(splitBuffer[3]), Integer.parseInt(splitBuffer[2]), Integer.parseInt(splitBuffer[3]));\n\t\t\t\t\t\tauthenticated = true;\n\t\t\t\t\t\tauthenticatedUser.homeDirInodeNum = Integer.parseInt(splitBuffer[4]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\t\t\t\t\t// wrong password\n\t\t\t\t}\n\t\t\t}\n\t\t\tpswdFile.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn authenticatedUser;\n\t}\n\n\tprivate static String getGrpName(String grpId) {\n\t\tboolean done = false;\n\t\tString grpName = null;\n\t\ttry {\n\t\t\tRandomAccessFile grpList = new RandomAccessFile(User.grpListPath, \"r\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = grpList.readLine()) != null && !done) {\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[1].compareTo(grpId) == 0) {\n\t\t\t\t\tgrpName = splitBuffer[0];\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrpList.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t\treturn grpName;\n\t}\n\tpublic static int getUserId(String name) {\n\t\tboolean done = false;\n\t\tint userId = 0;\n\t\ttry {\n\t\t\tRandomAccessFile pswdF = new RandomAccessFile(User.pswdFilePath, \"r\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = pswdF.readLine()) != null && !done) {\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[0].compareTo(name) == 0) {\n\t\t\t\t\tuserId = Integer.parseInt(splitBuffer[2]);\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpswdF.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn userId;\n\t}\n\n\tpublic int getHomeDirInodeNum() {\n\t\treturn this.homeDirInodeNum;\n\t}\n}\n", "ta;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n/**\n * Created by mjordan on 2/4/17.\n */\n\npublic class XyzIjStrategy extends TangoUpdateListenerBase {\n\n    public static final String TAG = XyzIjStrategy.class.toString();\n\n    @Override\n    public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\n        byte[] buffer = new byte[xyzIj.xyzCount * 3 * 4];\n        FileInputStream fileStream = new FileInputStream(\n            xyzIj.xyzParcelFileDescriptor.getFileDescriptor());\n        try {\n            fileStream.read(buffer,\n                            xyzIj.xyzParcelFileDescriptorOffset, buffer.length);\n            fileStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // Do not process the buffer inside the callback because\n        // you will not receive any new data while it processes\n    }\n}\n", ".model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.BuildListener;\nimport hudson.model.Result;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildStepMonitor;\nimport hudson.tasks.Publisher;\nimport hudson.tasks.Recorder;\nimport hudson.util.FormValidation;\nimport hudson.util.ListBoxModel;\nimport hudson.util.Messages;\nimport hudson.util.Secret;\nimport io.walti.api.Plugin;\nimport io.walti.api.Scan;\nimport io.walti.api.Target;\nimport io.walti.api.WaltiApi;\nimport io.walti.api.exceptions.WaltiApiException;\nimport net.sf.json.JSONArray;\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.util.*;\n\n/**\n * Call Walti API to execute security scan\n *\n * @author Sho Matsumoto\n */\npublic class WaltiScanner extends Recorder implements Serializable {\n\n    private static final int POLLING_INTERVAL = 10;\n\n    private final String key;\n    private final Secret secret;\n    private final String target;\n    private final List<String> selectedPlugins;\n    private final boolean noWait;\n    private final boolean unstablePreferred;\n\n    @DataBoundConstructor\n    public WaltiScanner(String key, String secret, String target, JSONArray plugins, boolean noWait, boolean unstablePreferred) {\n        this.key = key;\n        this.secret = Secret.fromString(secret);\n        this.target = target;\n        this.selectedPlugins = new ArrayList<String>();\n        Collection<String> col = JSONArray.toCollection(plugins, ArrayList.class);\n        this.selectedPlugins.addAll(col);\n        this.noWait = noWait;\n        this.unstablePreferred = unstablePreferred;\n    }\n\n    /**\n     * Get API key\n     *\n     * @return API key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     * Get API Secret\n     *\n     * @return API secret\n     */\n    public Secret getSecret() {\n        return secret;\n    }\n\n    /**\n     * Get target name\n     *\n     * @return target name\n     */\n    public String getTarget() { return target; }\n\n    /**\n     * Whether wait until queued scans are completed\n     *\n     * @return return true if it is not necessary to wait\n     */\n    public boolean isNoWait() { return noWait; }\n\n\n    /**\n     * Whether regard build result as UNSTABLE instead of FAILURE when scan result is not OK\n     *\n     * @return return true if build result is regarded as UNSTABLE\n     */\n    public boolean isUnstablePreferred() { return unstablePreferred; }\n\n    /**\n     * Get plugin names to execute\n     *\n     * @return plugin names\n     */\n    public List<String> getSelectedPlugins() { return selectedPlugins; }\n\n    public String getSelectedPluginsString() {\n        List<String> pluginList = getSelectedPlugins();\n        return StringUtils.join(pluginList, ',');\n    }\n\n    @Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException {\n        PrintStream logger = listener.getLogger();\n        WaltiApi api = WaltiApi.createInstance(key, secret.getPlainText());\n        Set<String> selectedPlugins = new HashSet<String>(getSelectedPlugins());\n\n        Scan.QueueResult queueResult = Scan.QueueResult.UNDEFINED;\n        for (String plugin : getSelectedPlugins()) {\n            try {\n                queueResult = Scan.queue(api, target, plugin);\n            } catch (WaltiApiException e) {\n                build.setResult(Result.FAILURE);\n                logger.println(plugin + \"\u306e\u30ad\u30e5\u30fc\u767b\u9332\u306b\u5931\u6557\u3057\u307e\u3057\u305f\");\n                e.printStackTrace(logger);\n                logger.close();\n                return true;\n            }\n\n            switch (queueResult) {\n                case SUCCESS:\n                    logger.println(plugin + \"\u306e\u30ad\u30e5\u30fc\u3092\u767b\u9332\u3057\u307e\u3057\u305f\");\n                    break;\n                case SKIPPED:\n                    selectedPlugins.remove(plugin);\n                    build.setResult(Result.UNSTABLE);\n                    logger.format(\"\u6c7a\u6e08\u60c5\u5831\u304c\u767b\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u304b\u3001\u3059\u3067\u306b\u30b9\u30ad\u30e3\u30f3\u5b9f\u884c\u4e2d\u306e\u305f\u3081%s\u306e\u30ad\u30e5\u30fc\u767b\u9332\u3092\u30b9\u30ad\u30c3\u30d7\u3057\u307e\u3059\\n\", plugin);\n                    break;\n                default:\n                    build.setResult(Result.FAILURE);\n                    logger.println(\"\u30b9\u30ad\u30e3\u30f3\u30ad\u30e5\u30fc\u306e\u767b\u9332\u306b\u5931\u6557\");\n                    break;\n            }\n        }\n\n        if (selectedPlugins.isEmpty()) {\n            logger.println(\"\u30ad\u30e5\u30fc\u767b\u9332\u304c\u3059\u3079\u3066\u30b9\u30ad\u30c3\u30d7\u3055\u308c\u307e\u3057\u305f\");\n            logger.close();\n            return true;\n        }\n\n        if (isNoWait()) {\n            logger.println(\"\u30b9\u30ad\u30e3\u30f3\u306e\u5b8c\u4e86\u3092\u5f85\u305f\u306a\u3044\u8a2d\u5b9a\u306e\u305f\u3081\u7d50\u679c\u53d6\u5f97\u3092\u30b9\u30ad\u30c3\u30d7\u3057\u307e\u3057\u305f\");\n            logger.close();\n            return true;\n        }\n\n        logger.println(\"\u30b9\u30ad\u30e3\u30f3\u7d50\u679c\u3092\u30dd\u30fc\u30ea\u30f3\u30b0\u3057\u3066\u3044\u307e\u3059\");\n\n        int i = 0;\n        while (!selectedPlugins.isEmpty()) {\n            if (shouldOutputPolling(i)) {\n                logger.println(\".\");\n            }\n            i++;\n            Target targetObj = null;\n            try {\n                targetObj = Target.find(api, target);\n            } catch (WaltiApiException e) {\n                build.setResult(Result.FAILURE);\n                logger.println(\"\u30b9\u30ad\u30e3\u30f3\u7d50\u679c\u30dd\u30fc\u30ea\u30f3\u30b0\u6642\u306e\u5fdc\u7b54\u304c\u7570\u5e38\");\n                e.printStackTrace(logger);\n                logger.close();\n                return true;\n            }\n\n            for (Plugin pluginObj : targetObj.getPlugins()) {\n                if (pluginObj.isQueued() || !selectedPlugins.contains(pluginObj.getName())) {\n                    // \u30b9\u30ad\u30e3\u30f3\u304c\u307e\u3060\u7d42\u308f\u3063\u3066\u3044\u306a\u3044\u3082\u3057\u304f\u306f\u9078\u629e\u3055\u308c\u3066\u3044\u306a\u3044\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u7d50\u679c\u8868\u793a\u306f\u4e0d\u8981\n                    continue;\n                }\n                selectedPlugins.remove(pluginObj.getName());\n\n                try {\n                    Scan scan = pluginObj.getScan();\n                    switch (scan.getResultStatus()) {\n                        case Scan.RESULT_OK:\n                            logger.println(pluginObj.getName() + \"\u306e\u30b9\u30ad\u30e3\u30f3\u304c\u5b8c\u4e86\u3057\u307e\u3057\u305f\u3002\u7d50\u679c:\" + scan.getStatus() + \" \u30e1\u30c3\u30bb\u30fc\u30b8:\" + scan.getMessage());\n                            logger.println(targetObj.getResultURL(pluginObj.getName()));\n                            build.setResult(judgeResult(scan.getStatusColor()));\n                            break;\n                        default:\n                            logger.println(pluginObj.getName() + \"\u306e\u30b9\u30ad\u30e3\u30f3\u304c\u4e2d\u65ad\u3055\u308c\u307e\u3057\u305f\u3002\u4ee5\u4e0b\u306eURL\u304b\u3089\u8a73\u7d30\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\");\n                            logger.println(targetObj.getResultURL(pluginObj.getName()));\n                            build.setResult(Result.FAILURE);\n                            logger.close();\n                            return true;\n                    }\n                } catch (WaltiApiException e) {\n                    build.setResult(Result.FAILURE);\n                    logger.println(\"\u30b9\u30ad\u30e3\u30f3\u7d50\u679cURL\u306e\u53d6\u5f97\u306b\u5931\u6557\");\n                    e.printStackTrace(logger);\n                    logger.close();\n                    return true;\n                }\n            }\n            try {\n                Thread.sleep(POLLING_INTERVAL * 1000);\n            } catch (InterruptedException e) {\n                build.setResult(Result.ABORTED);\n                logger.println(\"\u7d50\u679c\u306e\u30dd\u30fc\u30ea\u30f3\u30b0\u3092\u4e2d\u6b62\u3057\u307e\u3059\u3002\u30b9\u30ad\u30e3\u30f3\u81ea\u4f53\u306e\u30ad\u30e3\u30f3\u30bb\u30eb\u306fWalti.io\u306e\u30bf\u30fc\u30b2\u30c3\u30c8\u753b\u9762\u304b\u3089\u884c\u3063\u3066\u304f\u3060\u3055\u3044\");\n                logger.close();\n                return true;\n            }\n        }\n        logger.close();\n        return true;\n    }\n\n    /**\n     * Judge if polling progress should be outputted\n     *\n     * @param count\n     * @return\n     */\n    private boolean shouldOutputPolling(int count) {\n        int outputInterval = (int)Math.ceil(60.0 / POLLING_INTERVAL);\n        return count % outputInterval == 0;\n    }\n\n    /**\n     * Judge build result from scan status color\n     *\n     * @param statusColor\n     * @return build result\n     */\n    private Result judgeResult(String statusColor) {\n        if (Scan.STATUS_COLOR_GREEN.equals(statusColor)) {\n            return Result.SUCCESS;\n        }\n        if (Scan.STATUS_COLOR_GREY.equals(statusColor)) {\n            return Result.UNSTABLE;\n        }\n        if (isUnstablePreferred()) {\n            return Result.UNSTABLE;\n        }\n        return Result.FAILURE;\n    }\n\n    // Overridden for better type safety.\n    // If your plugin doesn't really define any property on Descriptor,\n    // you don't have to do this.\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl)super.getDescriptor();\n    }\n\n    @Override\n    public BuildStepMonitor getRequiredMonitorService() {\n        return BuildStepMonitor.BUILD;\n    }\n\n    @Extension // This indicates to Jenkins that this is an implementation of an extension point.\n    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {\n        public boolean isApplicable(Class<? extends AbstractProject> jobType) {\n            return true;\n        }\n\n        public String getDisplayName() {\n            return \"Walti\u3067\u30b9\u30ad\u30e3\u30f3\u3092\u5b9f\u884c\";\n        }\n\n        public FormValidation doCheckKey(@QueryParameter String key, @QueryParameter String secret) {\n            if (key.isEmpty()) {\n                return FormValidation.error(Messages.FormValidation_ValidateRequired());\n            }\n            if (secret.isEmpty()) {\n                return FormValidation.ok();  // \u307e\u3060API\u30ad\u30fc\u304c\u5165\u529b\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n            }\n            return FormValidation.ok();\n        }\n\n        public FormValidation doCheckSecret(@QueryParameter String key, @QueryParameter String secret) {\n            if (secret.isEmpty()) {\n                return FormValidation.error(Messages.FormValidation_ValidateRequired());\n            }\n            if (key.isEmpty()) {\n                return FormValidation.ok();  // \u307e\u3060API\u30ad\u30fc\u304c\u5165\u529b\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n            }\n\n            WaltiApi api = WaltiApi.createInstance(key, Secret.fromString(secret).getPlainText());\n            try {\n                if (!api.isValidCredentials()) {\n                    return FormValidation.error(\"API\u30ad\u30fc\u307e\u305f\u306f\u30b7\u30fc\u30af\u30ec\u30c3\u30c8\u304c\u6b63\u3057\u304f\u3042\u308a\u307e\u305b\u3093\u3002\");\n                }\n                return FormValidation.ok();\n            } catch (WaltiApiException e) {\n                e.printStackTrace();\n                return FormValidation.error(\"\u4e88\u671f\u305b\u306c\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u307e\u3057\u305f \" + e.getMessage());\n            }\n        }\n\n        public ListBoxModel doFillTargetItems(@QueryParameter String key, @QueryParameter String secret) {\n            ListBoxModel m = new ListBoxModel();\n            if (key.isEmpty() || secret.isEmpty()) {\n                // \u30ad\u30fc\u304b\u30b7\u30fc\u30af\u30ec\u30c3\u30c8\u304c\u7a7a\u306e\u5834\u5408\u306f\u7a7a\u30ea\u30b9\u30c8\n                return m;\n            }\n\n            WaltiApi api = WaltiApi.createInstance(key, Secret.fromString(secret).getPlainText());\n            try {\n                List<Target> targets = Target.getAll(api);\n                for (Target target : targets) {\n                    m.add(target.getName(), target.getName());\n                }\n            } catch (WaltiApiException e) {\n                // do nothing\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return m;\n        }\n\n        public CheckBoxModel doFillPluginsItems(@QueryParameter String key, @QueryParameter String secret, @QueryParameter String target) {\n            // \u30bf\u30fc\u30b2\u30c3\u30c8\u60c5\u5831\n            WaltiApi api = WaltiApi.createInstance(key, Secret.fromString(secret).getPlainText());\n            CheckBoxModel model = new CheckBoxModel();\n\n            if (target.isEmpty()) {\n                return model;\n            }\n\n            try {\n                Target targetObj = Target.find(api, target);\n                for (Plugin plugin : targetObj.getPlugins()) {\n                    model.add(new CheckBoxModel.Item(plugin.getName()));\n                }\n                return model;\n            } catch (WaltiApiException e) {\n                // do nothing\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return model;\n        }\n    }\n}\n", "eeMap;\n\nimport edu.georgetown.library.fileAnalyzer.filetest.iiif.IIIFEnums.IIIFLookupEnum;\n\npublic abstract class FolderProjectTranslate extends DefaultManifestProjectTranslate {\n        File root;\n        TreeMap<String,RangePath> dirPaths = new TreeMap<>();\n        RangePath top;\n        \n        @Override\n        public void initProjectRanges(IIIFManifest manifest, File root, RangePath top) {\n                this.root = root;\n                this.top = top;\n        }\n        @Override\n        public boolean showFolderRanges() {\n                return true;\n        }\n        \n        public String getRelPath(File f) {\n                return f.getAbsolutePath().substring(root.getAbsolutePath().length()).replaceAll(\"[\\\\\\\\\\\\/]\", \"_\");\n        }\n        \n        public abstract RangePath makeRangePath(IIIFManifest manifest, File f);\n        \n        @Override\n        public RangePath getPrimaryRangePath(IIIFManifest manifest, String key, File f, MetadataInputFile itemMeta) {\n                if (dirPaths.containsKey(f.getAbsolutePath())) {\n                        return dirPaths.get(f.getAbsolutePath());\n                }\n                RangePath rp = makeRangePath(manifest, f);\n                if (!manifest.isCollectionManifest() && manifest.getManifestProjectTranslate().isOneItemPerRange()) {\n                        rp.setDisplayPath(itemMeta.getValue(IIIFLookupEnum.Title.getLookup(), rp.displayPath));\n                }\n                dirPaths.put(f.getAbsolutePath(), rp);\n                return rp;\n        }\n\n}\n", "harge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage me.lucko.luckperms.commands.group.subcommands;\n\nimport me.lucko.luckperms.LuckPermsPlugin;\nimport me.lucko.luckperms.commands.CommandResult;\nimport me.lucko.luckperms.commands.Predicate;\nimport me.lucko.luckperms.commands.Sender;\nimport me.lucko.luckperms.commands.SubCommand;\nimport me.lucko.luckperms.constants.Message;\nimport me.lucko.luckperms.constants.Permission;\nimport me.lucko.luckperms.data.LogEntry;\nimport me.lucko.luckperms.groups.Group;\n\nimport java.util.List;\n\npublic class GroupClear extends SubCommand<Group> {\n    public GroupClear() {\n        super(\"clear\", \"Clears a groups permissions\", \"/%s group <group> clear\", Permission.GROUP_CLEAR,\n                Predicate.alwaysFalse());\n    }\n\n    @Override\n    public CommandResult execute(LuckPermsPlugin plugin, Sender sender, Group group, List<String> args, String label) {\n        group.clearNodes();\n        Message.CLEAR_SUCCESS.send(sender, group.getName());\n        LogEntry.build().actor(sender).acted(group).action(\"clear\").build().submit(plugin, sender);\n        save(group, sender, plugin);\n        return CommandResult.SUCCESS;\n    }\n}\n", "SONObject;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.lpw.ranch.audit.Audit;\nimport org.lpw.ranch.recycle.Recycle;\nimport org.lpw.tephra.ctrl.validate.Validators;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author lpw\n */\npublic class QueryByOwnerTest extends TestSupport {\n    @Test\n    public void queryByOwner() {\n        String[] owners = new String[]{generator.uuid(), generator.uuid()};\n        List<CommentModel> list = new ArrayList<>();\n        for (int i = 0; i < 20; i++)\n            list.add(create(i, owners[i % owners.length], \"author \" + i, Audit.values()[i % 3], Recycle.No));\n        CommentModel child = create(101, list.get(1).getId(), \"author 1\", Audit.Pass, Recycle.No);\n\n        mockHelper.reset();\n        mockHelper.mock(\"/comment/query-by-owner\");\n        JSONObject object = mockHelper.getResponse().asJson();\n        Assert.assertEquals(1303, object.getIntValue(\"code\"));\n        Assert.assertEquals(message.get(Validators.PREFIX + \"illegal-id\", message.get(CommentModel.NAME + \".owner\")), object.getString(\"message\"));\n\n        mockHelper.reset();\n        mockHelper.getRequest().addParameter(\"owner\", \"owner id\");\n        mockHelper.mock(\"/comment/query-by-owner\");\n        object = mockHelper.getResponse().asJson();\n        Assert.assertEquals(1303, object.getIntValue(\"code\"));\n        Assert.assertEquals(message.get(Validators.PREFIX + \"illegal-id\", message.get(CommentModel.NAME + \".owner\")), object.getString(\"message\"));\n\n        mockCarousel.reset();\n        mockUser.register();\n        mockHelper.reset();\n        mockHelper.getRequest().addParameter(\"owner\", owners[0]);\n        mockHelper.getRequest().addParameter(\"pageSize\", \"20\");\n        mockHelper.getRequest().addParameter(\"pageNum\", \"0\");\n        sign.put(mockHelper.getRequest().getMap(), null);\n        mockHelper.mock(\"/comment/query-by-owner\");\n        object = mockHelper.getResponse().asJson();\n        Assert.assertEquals(0, object.getIntValue(\"code\"));\n        JSONObject data = object.getJSONObject(\"data\");\n        pageTester.assertCountSizeNumber(3, 20, 1, data);\n        JSONArray array = data.getJSONArray(\"list\");\n        Assert.assertEquals(3, array.size());\n        for (int i = 0; i < array.size(); i++)\n            equals(list.get(6 * (i + 1) - 2), array.getJSONObject(i), 6 * (i + 1) - 2, child);\n\n        for (Audit audit : Audit.values()) {\n            mockHelper.reset();\n            mockHelper.getRequest().addParameter(\"owner\", owners[1]);\n            mockHelper.getRequest().addParameter(\"audit\", \"\" + audit.getValue());\n            mockHelper.getRequest().addParameter(\"pageSize\", \"20\");\n            mockHelper.getRequest().addParameter(\"pageNum\", \"0\");\n            sign.put(mockHelper.getRequest().getMap(), null);\n            mockHelper.mock(\"/comment/query-by-owner\");\n            object = mockHelper.getResponse().asJson();\n            Assert.assertEquals(0, object.getIntValue(\"code\"));\n            data = object.getJSONObject(\"data\");\n            pageTester.assertCountSizeNumber(4, 20, 1, data);\n            array = data.getJSONArray(\"list\");\n            Assert.assertEquals(4, array.size());\n            for (int i = 0; i < array.size(); i++)\n                equals(list.get(6 * (i + 1) - 5), array.getJSONObject(i), 6 * (i + 1) - 5, child);\n        }\n    }\n\n    private void equals(CommentModel comment, JSONObject obj, int i, CommentModel child) {\n        Assert.assertEquals(comment.getId(), obj.getString(\"id\"));\n        Assert.assertFalse(obj.containsKey(\"key\"));\n        Assert.assertFalse(obj.containsKey(\"owner\"));\n        mockUser.verify(obj.getJSONObject(\"author\"), comment.getAuthor());\n        Assert.assertEquals(comment.getSubject(), obj.getString(\"subject\"));\n        Assert.assertEquals(comment.getLabel(), obj.getString(\"label\"));\n        Assert.assertEquals(comment.getContent(), obj.getString(\"content\"));\n        Assert.assertEquals(comment.getScore(), obj.getIntValue(\"score\"));\n        Assert.assertFalse(obj.containsKey(\"audit\"));\n        Assert.assertEquals(converter.toString(comment.getTime()), obj.getString(\"time\"));\n        if (i == 1) {\n            JSONArray children = obj.getJSONArray(\"children\");\n            Assert.assertEquals(1, children.size());\n            equals(child, children.getJSONObject(0), 101, null);\n        } else\n            Assert.assertFalse(obj.containsKey(\"children\"));\n    }\n}\n", "port java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class TaxonRankEnumTest {\n\t\n\t@Test\n\tpublic void testComparator(){\n\t\tList<TaxonRankEnum> rankList = new ArrayList<TaxonRankEnum>();\n\t\trankList.add(TaxonRankEnum.VARIETY);\n\t\trankList.add(TaxonRankEnum.GENUS);\n\t\trankList.add(TaxonRankEnum.CLASS);\n\t\t\n\t\tCollections.sort(rankList, new TaxonRankEnum.TaxonRankEnumComparator());\n\t\t\n\t\tassertEquals(TaxonRankEnum.CLASS,rankList.get(0));\n\t\tassertEquals(TaxonRankEnum.GENUS,rankList.get(1));\n\t\tassertEquals(TaxonRankEnum.VARIETY,rankList.get(2));\n\t}\n\n}\n", "g.springframework.data.annotation.Id;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class FrequentItemSet {\r\n\r\n    @Id\r\n    @JsonIgnore\r\n    private String id;\r\n\r\n    private ArrayList<String> items;\r\n    private int support;\r\n\r\n    public int getSupport() { return support; }\r\n    public void setSupport(int support) { this.support = support; }\r\n\r\n    public void setItems(ArrayList<String> items) { this.items = items; }\r\n    public ArrayList<String> getItems() { return items; }\r\n\r\n}\r\n", "com/\n * support@verifalia.com\n *\n * Copyright (c) 2005-2020 Cobisi Research\n *\n * Cobisi Research\n * Via Prima Strada, 35\n * 35129, Padova\n * Italy - European Union\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.verifalia.api.common;\n\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.NonNull;\nimport lombok.experimental.SuperBuilder;\n\n/**\n * Base class for listing operations against the Verifalia API.\n */\n@Getter\n@SuperBuilder\n@NoArgsConstructor\npublic class ListingOptions {\n    /**\n     * The maximum number of items to return with a listing request. The Verifalia API may choose to override the specified\n     * limit if it is either too small or too big. Note: a single listing operation may automatically perform different\n     * listing requests to the Verifalia API: this value limits the number of items returned by *each* API request, not\n     * the overall total number of returned items.\n     */\n    private Integer limit;\n\n    /**\n     * The direction of the listing.\n     */\n    @Builder.Default\n    private Direction direction = Direction.Forward;\n\n    public void setLimit(final Integer limit) {\n        if (limit != null && limit < 0) {\n            throw new IllegalArgumentException(\"Limit must be 0 (meaning no limit will be enforced) or greater.\");\n        }\n\n        this.limit = limit;\n    }\n\n    public void setDirection(@NonNull final Direction direction) {\n        this.direction = direction;\n    }\n}", "ogle.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ListMultimap;\nimport elasta.commons.Utils;\nimport elasta.composer.Headers;\nimport elasta.composer.ex.AppContextException;\nimport elasta.pipeline.converter.Converter;\n\nimport java.util.*;\n\n/**\n * Created by sohan on 5/12/2017.\n */\nfinal public class HeadersImpl implements Headers {\n    final ListMultimap<String, String> multimap;\n    final Map<Class, Converter> convertersMap;\n\n    public HeadersImpl(ListMultimap<String, String> multimap, Map<Class, Converter> convertersMap) {\n        Objects.requireNonNull(multimap);\n        Objects.requireNonNull(convertersMap);\n        this.multimap = multimap;\n        this.convertersMap = ImmutableMap.copyOf(\n            checkConvertersMap(convertersMap)\n        );\n    }\n\n    @Override\n    public boolean containsKey(String key) {\n        return multimap.containsKey(key);\n    }\n\n    @Override\n    public Set<String> keySet() {\n        return multimap.keySet();\n    }\n\n    @Override\n    public Optional<Integer> getInt(String key) {\n        return get(key).map(s -> convert(Integer.class, s));\n    }\n\n    @Override\n    public Optional<Long> getLong(String key) {\n        return get(key).map(s -> convert(Long.class, s));\n    }\n\n    @Override\n    public Optional<Float> getFloat(String key) {\n        return get(key).map(s -> convert(Float.class, s));\n    }\n\n    @Override\n    public Optional<Double> getDouble(String key) {\n        return get(key).map(s -> convert(Double.class, s));\n    }\n\n    @Override\n    public Optional<String> get(String key) {\n        return getValue(key);\n    }\n\n    @Override\n    public Optional<Date> getDate(String key) {\n        return get(key).map(s -> convert(Date.class, s));\n    }\n\n    @Override\n    public List<String> getAll(String key) {\n        return multimap.get(key);\n    }\n\n    @Override\n    public ListMultimap<String, String> getMultimap() {\n        return multimap;\n    }\n\n    @Override\n    public Headers addAll(ListMultimap<String, String> multimap) {\n        return new HeadersImpl(\n            ImmutableListMultimap.<String, String>builder().putAll(multimap).build(),\n            convertersMap\n        );\n    }\n\n    @Override\n    public Headers addAll(Map<String, String> map) {\n        return new HeadersImpl(\n            ImmutableListMultimap.<String, String>builder().putAll(\n                map.entrySet()\n            ).build(),\n            convertersMap\n        );\n    }\n\n    public Map<Class, Converter> getConvertersMap() {\n        return convertersMap;\n    }\n\n    private <T> T convert(Class<T> tClass, String value) {\n        return (T) convertersMap.get(tClass).convert(value);\n    }\n\n    private Optional<String> getValue(String key) {\n\n        List<String> strings = multimap.get(key);\n\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(strings.get(0));\n    }\n\n    private Map<Class, Converter> checkConvertersMap(Map<Class, Converter> convertersMap) {\n        ImmutableSet.of(\n            Integer.class, Long.class, Float.class, Double.class, Boolean.class, Date.class\n        ).forEach(aClass -> {\n            if (Utils.not(convertersMap.containsKey(aClass))) {\n                throw new AppContextException(\"ConvertersMap does not contains converter for type '\" + aClass + \"'\");\n            }\n        });\n        return convertersMap;\n    }\n}\n", "on.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.Resources;\nimport org.codarama.diet.bundle.JarMaker;\nimport org.codarama.diet.model.ClassStream;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport java.util.Enumeration;\nimport java.util.Set;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\n\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Tests {@link StreamJarMaker}.\n *\n * Created by Ayld on 6/28/15.\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\"classpath:META-INF/test-contexts/testStreamJarMakerContext.xml\"})\npublic class TestStreamJarMaker {\n\n    private static final Set<String> CORRECT_ZIPPED_ENTRY_NAMES = ImmutableSet.of(\n            \"net\" + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\", \"diet\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\", \"diet\", \"model\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\", \"diet\", \"model\", \"ClassName.class\"),\n            \"org\" + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"primefaces\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"primefaces\", \"context\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"primefaces\", \"context\", \"PrimePartialViewContext.class\"),\n            Joiner.on(File.separator).join(\"org\", \"apache\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"apache\", \"commons\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"apache\", \"commons\", \"lang3\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"apache\", \"commons\", \"lang3\", \"CharRange$1.class\")\n    );\n\n    @Autowired\n    private String workDir;\n\n    @Autowired\n    private JarMaker<ClassStream> jarMaker;\n\n    @Before\n    public void prepare() throws IOException {\n        cleanDir(new File(workDir));\n    }\n\n    @Test\n    public void makeJar() throws URISyntaxException, IOException {\n        final Set<ClassStream> filesToZip = ImmutableSet.of(\n                ClassStream.fromStream(\n                        new FileInputStream(new File(Resources.getResource(\"test-classes/ClassName.class\").toURI()))\n                ),\n                ClassStream.fromStream(\n                        new FileInputStream(new File(Resources.getResource(\"test-classes/PrimePartialViewContext.class\").toURI()))\n                ),\n                ClassStream.fromStream(\n                        new FileInputStream(new File(Resources.getResource(\"test-classes/CharRange$1.class\").toURI()))\n                )\n        );\n\n        final JarFile jar = jarMaker.zip(filesToZip);\n\n        assertTrue(\"zipped jar is null\", jar != null);\n\n        final Enumeration<JarEntry> entries = jar.entries();\n        while (entries.hasMoreElements()) {\n\n            final JarEntry entry = entries.nextElement();\n\n            assertTrue(\"invalid entry: \" + entry, CORRECT_ZIPPED_ENTRY_NAMES.contains(entry.getName()));\n        }\n\n        final File zipDir = new File(workDir);\n        final Set<File> zipDirFiles = Sets.newHashSet(zipDir.listFiles());\n\n        assertTrue(jar.getName() + \", missing\", zipDirFiles.contains(new File(jar.getName())));\n    }\n\n    private static void cleanDir(File file) throws IOException {\n        if (file == null || !file.exists()) {\n            return;\n        }\n        if (file.isDirectory()) {\n            final File[] files = file.listFiles();\n            if (files == null) {\n                return;\n            }\n            for (File sub : files) {\n                cleanDir(sub);\n            }\n        }\n        if (!file.delete()) {\n            throw new IOException(\"failed to deleteRecursive: \" + file);\n        }\n    }\n}\n", " edu.lognet.reputation.model.experience.Credibility;\nimport edu.lognet.reputation.model.service.Service;\nimport edu.lognet.reputation.model.user.IConsumer;\nimport edu.lognet.reputation.model.user.IProvider;\nimport edu.lognet.reputation.model.user.IRater;\n\n/**\n * Represent a reputation system\n * @author Laurent Vanni, Thao Nguyen\n *\n */\npublic interface IReputationSystem {\n\n\t/**\n\t * \n\t * @param service\n\t * @param provider\n\t * @param raters\n\t * @param consumer\n\t * @param credibilityOfRaterMap\n\t * @return\n\t */\n\tpublic double getReputation(Service service, IProvider provider,\n\t\t\tList<IRater> raters, IConsumer consumer,\n\t\t\tMap<IProvider, Map<IRater, Credibility>> credibilityOfRaterMap, int personalWeight);\n\n\t/**\n\t * \n\t * @param consumer\n\t * @param service\n\t * @param provider\n\t * @param credibilityOfRater\n\t */\n\tpublic void updateUsefulFactor(IConsumer consumer, Service service,\n\t\t\tIProvider provider, Map<IRater, Credibility> credibilityOfRater, double feedback);\n\n}\n", "   Scanner scanner=new Scanner(System.in);\n        while(scanner.hasNext()){\n            System.out.println(revStr(scanner.nextLine()));\n        }\n    }\n    \n    private static String revStr(String str){\n\t\tif(str==null){\n            return null;\n        }\n        char[] array=str.toCharArray();\n        int start=0;\n        int end=array.length-1;\n        while(start<end){\n            swap(array,start,end);\n            start++;\n            end--;\n        }\n        return new String(array);\n    }\n    \n    private static void swap(char[] array,int i,int j){\n        /*char temp=array[i];\n        array[i]=array[j];\n        array[j]=temp;*/\n        //\u6216\u8005\u4e0d\u4f7f\u7528\u4e34\u65f6\u53d8\u91cf\n        array[i] = (char)(array[i]^array[j]);\n        array[j] = (char)(array[i]^array[j]);\n        array[i] = (char)(array[i]^array[j]);\n    }\n}", "DependencyException(String string) {\n\t\tsuper(string);\n\t}\n\n\tprivate static final long serialVersionUID = -6975243982936880193L;\n\n}\n", "ft.bingads.v10.api.test.entities.campaign_product_scope.BulkCampaignProductScopeTest;\nimport com.microsoft.bingads.v10.bulk.entities.BulkCampaignProductScope;\nimport com.microsoft.bingads.v10.bulk.entities.Status;\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameter;\nimport org.junit.runners.Parameterized.Parameters;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\n@RunWith(Parameterized.class)\npublic class ReadStatusTest extends BulkCampaignProductScopeTest {\n\n    @Parameter(value = 1)\n    public Status expectedResult;\n\n    @Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(\n                new Object[][]{\n                        {\"\", null},\n                        {null, null},\n                        {\"Active\", Status.ACTIVE},\n                        {\"Deleted\", Status.DELETED}\n                }\n        );\n    }\n\n    @Test\n    public void testRead() {\n        testReadProperty(\n                \"Status\",\n                datum,\n                expectedResult,\n                new Function<BulkCampaignProductScope, Status>() {\n                    @Override\n                    public Status apply(BulkCampaignProductScope c) {\n                        return c.getStatus();\n                    }\n                }\n        );\n    }\n}\n", " class LoggingListener implements TweetListener {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggingListener.class);\n\n    @Override\n    public void message(String author, String message) {\n        LOGGER.info(author + \": \" + message);\n    }\n}\n", " i=0; i<array.length; i++){\n\t\t\ttotal += array[i];\n\t\t}\n\n\t\tSystem.out.println(\"Total is: \" + total);\n\t}\n\t\n\tpublic static void main (String args[]){\n\t\tdouble[] num = {1.2,3.4,5.6,7.8, 9.01};\n\t\tadd(num);\n\t}\n\t*/\n\t\n\tpublic static void main (String args[]){\n\t\t\n\t\tString [][] names = {\n\t\t\t{\"Mr.\", \"Mrs.\", \"Ms.\"},\n\t\t\t{\"Smith\", \"Jones\"}\n\t\t};\n\t\t\n\t\tfor(int i=0; i<names[0].length; i++){\n\t\t\tfor(int j=0; j<names[1].length; j++){\n\t\t\t\tSystem.out.println(\"i is:\" + i + \" & \" + \"j is:\" + j);\n\t\t\t\tSystem.out.println(names[0][i] + names[1][j]);\n\t\t\t}\n\t\t};\n\t}\n\n}", "---------------------------\n// Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.  See License in the project root for license information.\n// ------------------------------------------------------------------------------\n\npackage com.microsoft.graph.requests;\nimport com.microsoft.graph.models.ReportRoot;\nimport com.microsoft.graph.requests.ReportRootGetTeamsUserActivityUserDetailRequest;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.Nonnull;\nimport com.microsoft.graph.http.BaseRequest;\nimport com.microsoft.graph.http.HttpMethod;\nimport com.microsoft.graph.core.ClientException;\nimport com.microsoft.graph.core.IBaseClient;\nimport com.microsoft.graph.models.ReportRootGetTeamsUserActivityUserDetailParameterSet;\n\n// **NOTE** This file was generated by a tool and any changes will be overwritten.\n\n/**\n * The class for the Report Root Get Teams User Activity User Detail Request.\n */\npublic class ReportRootGetTeamsUserActivityUserDetailRequest extends BaseRequest<java.io.InputStream> {\n    /**\n     * The request for this ReportRootGetTeamsUserActivityUserDetail\n     *\n     * @param requestUrl     the request URL\n     * @param client         the service client\n     * @param requestOptions the options for this request\n     */\n    public ReportRootGetTeamsUserActivityUserDetailRequest(@Nonnull final String requestUrl, @Nonnull final IBaseClient<?> client, @Nullable final java.util.List<? extends com.microsoft.graph.options.Option> requestOptions) {\n        super(requestUrl, client, requestOptions, java.io.InputStream.class);\n    }\n\n    /**\n     * Gets the java.io.InputStream\n     *\n     * @return a future with the result\n     */\n    @Nonnull\n    public java.util.concurrent.CompletableFuture<java.io.InputStream> getAsync() {\n        return sendAsync(HttpMethod.GET, null);\n    }\n\n    /**\n     * Gets the java.io.InputStream\n     *\n     * @return the java.io.InputStream\n     * @throws ClientException an exception occurs if there was an error while the request was sent\n     */\n    @Nullable\n    public java.io.InputStream get() throws ClientException {\n       return send(HttpMethod.GET, null);\n    }\n\n    /**\n     * Sets the select clause for the request\n     *\n     * @param value the select clause\n     * @return the updated request\n     */\n    @Nonnull\n    public ReportRootGetTeamsUserActivityUserDetailRequest select(@Nonnull final String value) {\n        addSelectOption(value);\n        return this;\n    }\n\n    /**\n     * Sets the expand clause for the request\n     *\n     * @param value the expand clause\n     * @return the updated request\n     */\n    @Nonnull\n    public ReportRootGetTeamsUserActivityUserDetailRequest expand(@Nonnull final String value) {\n        addExpandOption(value);\n        return this;\n    }\n\n}\n", "4 cocos2d-java.org\n * \n *   http://www.cocos2d-java.org\n *   \n *   The MIT License (MIT)\n *      \n *Permission is hereby granted, free of charge, to any person obtaining a copy\n *of this software and associated documentation files (the \"Software\"), to deal\n *in the Software without restriction, including without limitation the rights\n *to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *copies of the Software, and to permit persons to whom the Software is\n *furnished to do so, subject to the following conditions:\n\n *The above copyright notice and this permission notice shall be included in\n *all copies or substantial portions of the Software.\n\n *THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *THE SOFTWARE.\n *******************************************************************************/\n\npackage cocos2d.layers_scenes_transitions_nodes;\n\nimport cocos2d.predefine.CCTypes;\nimport cocos2d.predefine.ICCRGBAProtocol;\nimport cocos2d.predefine.CCColor3B;\n\npublic class CCLayerRGBA extends CCLayer implements ICCRGBAProtocol\n{\n    protected int _displayedOpacity;\n    protected int _realOpacity;\n    protected CCColor3B _displayedColor;\n    protected CCColor3B _realColor;\n    protected boolean _cascadeColorEnabled;\n    protected boolean _cascadeOpacityEnabled;\n\n    public CCColor3B getColor()\n    {\n        return new CCColor3B(_realColor);\n    }\n\n    public void setColor(CCColor3B value)\n    {\n        _displayedColor = new CCColor3B(value);\n        _realColor = new CCColor3B(value);\n\n        if (_cascadeColorEnabled)\n        {\n        \tCCColor3B parentColor = new CCColor3B(CCTypes.CCWhite);\n            //var parent = m_pParent as ICCRGBAProtocol;\n        \tICCRGBAProtocol parent = null;\n        \tif (m_pParent instanceof ICCRGBAProtocol)\n        \t{\n        \t\tparent = (ICCRGBAProtocol)m_pParent;\n        \t}\n            if (parent != null && parent.getCascadeColorEnabled())\n            {\n                parentColor = new CCColor3B(parent.getDisplayedColor());\n            }\n\n            updateDisplayedColor(parentColor);\n        } \n    }\n    \n    @Override\n    public  CCColor3B getDisplayedColor()\n    {\n        return _displayedColor;\n    }\n\n    @Override\n    public int getOpacity()\n    {\n        return _realOpacity;\n    }\n\n    @Override\n    public void setOpacity(int value)\n    { \n        _displayedOpacity = _realOpacity = value;\n\n        if (_cascadeOpacityEnabled)\n        {\n            int parentOpacity = 255;\n            ICCRGBAProtocol pParent = null;\n            if (m_pParent instanceof ICCRGBAProtocol)\n            {\n            \tpParent = (ICCRGBAProtocol)m_pParent;\n            }\n            if (pParent != null && pParent.getCascadeOpacityEnabled())\n            {\n                parentOpacity = pParent.getDisplayedOpacity();\n            }\n            updateDisplayedOpacity(parentOpacity);\n        }\n    }\n    \n    @Override\n    public int getDisplayedOpacity()\n    {\n        return _displayedOpacity;\n    }\n\n    @Override\n    public boolean getIsOpacityModifyRGB()\n    {\n        return false;\n    }\n       \n    @Override\n    public void setIsOpacityModifyRGB(boolean value)\n    {\n        \n    }\n    \n    @Override\n    public boolean getCascadeColorEnabled()\n    {\n        return _cascadeColorEnabled;\n    }\n\n    @Override\n    public void setCascadeColorEnabled(boolean value)\n    {\n        _cascadeColorEnabled = value;\n    }\n  \n    @Override\n    public boolean getCascadeOpacityEnabled()\n    {\n        return _cascadeOpacityEnabled;\n    }\n\n    @Override\n    public void setCascadeOpacityEnabled(boolean value)\n    {\n        _cascadeOpacityEnabled = value;\n    }\n    \n    public CCLayerRGBA()\n    {\n        _displayedOpacity = 255;\n        _realOpacity = 255;\n        _displayedColor = new CCColor3B(CCTypes.CCWhite);\n        _realColor = new CCColor3B(CCTypes.CCWhite);\n        \n        _cascadeColorEnabled = false;\n        _cascadeOpacityEnabled = false;\n    }\n\n    @Override\n    public boolean init()\n    {\n        super.init();\n\n        _displayedOpacity = _realOpacity = 255;\n        _displayedColor = new CCColor3B(CCTypes.CCWhite);\n        _realColor = new CCColor3B(CCTypes.CCWhite);\n        setCascadeOpacityEnabled(false);\n        setCascadeColorEnabled(false);\n\n        return true;\n    }\n\n    public void updateDisplayedColor(CCColor3B parentColor)\n    {\n        _displayedColor.R = (int) (_realColor.R * parentColor.R / 255.0f);\n        _displayedColor.G = (int) (_realColor.G * parentColor.G / 255.0f);\n        _displayedColor.B = (int) (_realColor.B * parentColor.B / 255.0f);\n\n        if (_cascadeColorEnabled)\n        {\n            if (_cascadeOpacityEnabled && m_pChildren != null)\n            {\n                for (int i = 0, count = m_pChildren.size; i < count; i++)\n                {\n                    //var item = m_pChildren.Elements[i] as ICCRGBAProtocol;\n                \tICCRGBAProtocol item = null;\n                \tif (m_pChildren.get(i) instanceof ICCRGBAProtocol)\n                \t{\n                \t\titem = (ICCRGBAProtocol)(m_pChildren.get(i));\n                \t}\n                    if (item != null)\n                    {\n                        item.updateDisplayedColor(_displayedColor);\n                    }\n                }\n            }\n        }\n    }\n\n    public void updateDisplayedOpacity(int parentOpacity)\n    {\n        _displayedOpacity = (int) (_realOpacity * parentOpacity / 255.0f);\n\n        if (_cascadeOpacityEnabled && m_pChildren != null)\n        {\n            for (int i = 0, count = m_pChildren.size; i < count; i++)\n            {\n            \tICCRGBAProtocol item = null;\n            \tif (m_pChildren.get(i) instanceof ICCRGBAProtocol)\n            \t{\n            \t\titem = (ICCRGBAProtocol)(m_pChildren.get(i));\n            \t}\n                if (item != null)\n                {\n                    item.updateDisplayedOpacity(_displayedOpacity);\n                }\n            }\n        }\n    }\n\n\t\n}", "minecraft.client.renderer.BufferBuilder;\nimport net.minecraft.client.renderer.GLAllocation;\nimport net.minecraft.client.renderer.GlStateManager;\nimport net.minecraft.client.renderer.Tessellator;\nimport net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;\nimport net.minecraft.client.renderer.vertex.DefaultVertexFormats;\nimport net.minecraft.util.ResourceLocation;\nimport tamaized.voidcraft.common.blocks.TileEntityNoBreak;\n\nimport java.nio.FloatBuffer;\nimport java.util.Random;\n\npublic class RenderNoBreak extends TileEntitySpecialRenderer<TileEntityNoBreak> {\n\n\tprivate static final ResourceLocation END_SKY_TEXTURE = new ResourceLocation(\"textures/environment/end_sky.png\");\n\tprivate static final ResourceLocation END_PORTAL_TEXTURE = new ResourceLocation(\"textures/entity/end_portal.png\");\n\tprivate static final Random RANDOM = new Random(31100L);\n\tprivate static final FloatBuffer MODELVIEW = GLAllocation.createDirectFloatBuffer(16);\n\tprivate static final FloatBuffer PROJECTION = GLAllocation.createDirectFloatBuffer(16);\n\tFloatBuffer buffer = GLAllocation.createDirectFloatBuffer(16);\n\n\t@Override\n\tpublic void render(TileEntityNoBreak te, double x, double y, double z, float partialTicks, int destroyStage, float p_192841_10_) {\n\t\tGlStateManager.disableLighting();\n\t\tRANDOM.setSeed(31100L);\n\t\tGlStateManager.getFloat(2982, MODELVIEW);\n\t\tGlStateManager.getFloat(2983, PROJECTION);\n\t\tdouble d0 = x * x + y * y + z * z;\n\t\tint i = this.getPasses(d0);\n\t\tfloat f = this.getOffset();\n\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tGlStateManager.pushMatrix();\n\t\t\tfloat f1 = 2.0F / (float) (18 - j);\n\n\t\t\tif (j == 0) {\n\t\t\t\tthis.bindTexture(END_SKY_TEXTURE);\n\t\t\t\tf1 = 0.15F;\n\t\t\t\tGlStateManager.enableBlend();\n\t\t\t\tGlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\n\t\t\tif (j >= 1) {\n\t\t\t\tthis.bindTexture(END_PORTAL_TEXTURE);\n\t\t\t}\n\n\t\t\tif (j == 1) {\n\t\t\t\tGlStateManager.enableBlend();\n\t\t\t\tGlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);\n\t\t\t}\n\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.S, 9216);\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.T, 9216);\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.R, 9216);\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.S, 9474, this.getBuffer(1.0F, 0.0F, 0.0F, 0.0F));\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.T, 9474, this.getBuffer(0.0F, 1.0F, 0.0F, 0.0F));\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.R, 9474, this.getBuffer(0.0F, 0.0F, 1.0F, 0.0F));\n\t\t\tGlStateManager.enableTexGenCoord(GlStateManager.TexGen.S);\n\t\t\tGlStateManager.enableTexGenCoord(GlStateManager.TexGen.T);\n\t\t\tGlStateManager.enableTexGenCoord(GlStateManager.TexGen.R);\n\t\t\tGlStateManager.popMatrix();\n\t\t\tGlStateManager.matrixMode(5890);\n\t\t\tGlStateManager.pushMatrix();\n\t\t\tGlStateManager.loadIdentity();\n\t\t\tGlStateManager.translate(0.5F, 0.5F, 0.0F);\n\t\t\tGlStateManager.scale(0.5F, 0.5F, 1.0F);\n\t\t\tfloat f2 = (float) (j + 1);\n\t\t\tGlStateManager.translate(17.0F / f2, (2.0F + f2 / 1.5F) * ((float) Minecraft.getSystemTime() % 800000.0F / 800000.0F), 0.0F);\n\t\t\tGlStateManager.rotate((f2 * f2 * 4321.0F + f2 * 9.0F) * 2.0F, 0.0F, 0.0F, 1.0F);\n\t\t\tGlStateManager.scale(4.5F - f2 / 4.0F, 4.5F - f2 / 4.0F, 1.0F);\n\t\t\tGlStateManager.multMatrix(PROJECTION);\n\t\t\tGlStateManager.multMatrix(MODELVIEW);\n\t\t\tTessellator tessellator = Tessellator.getInstance();\n\t\t\tBufferBuilder vertexbuffer = tessellator.getBuffer();\n\t\t\tvertexbuffer.begin(7, DefaultVertexFormats.POSITION_COLOR);\n\t\t\tfloat f3 = (RANDOM.nextFloat() * 0.5F + 0.1F) * f1;\n\t\t\tfloat f4 = (RANDOM.nextFloat() * 0.5F + 0.4F) * f1;\n\t\t\tfloat f5 = (RANDOM.nextFloat() * 0.5F + 0.5F) * f1;\n\n\t\t\tvertexbuffer.pos(x, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y + (double) f, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + (double) f, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + (double) f, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + (double) f, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\ttessellator.draw();\n\t\t\tGlStateManager.popMatrix();\n\t\t\tGlStateManager.matrixMode(5888);\n\t\t\tthis.bindTexture(END_SKY_TEXTURE);\n\t\t}\n\n\t\tGlStateManager.disableBlend();\n\t\tGlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);\n\t\tGlStateManager.disableTexGenCoord(GlStateManager.TexGen.T);\n\t\tGlStateManager.disableTexGenCoord(GlStateManager.TexGen.R);\n\t\tGlStateManager.enableLighting();\n\t}\n\n\tprotected int getPasses(double p_191286_1_) {\n\t\tint i;\n\n\t\tif (p_191286_1_ > 36864.0D) {\n\t\t\ti = 1;\n\t\t} else if (p_191286_1_ > 25600.0D) {\n\t\t\ti = 3;\n\t\t} else if (p_191286_1_ > 16384.0D) {\n\t\t\ti = 5;\n\t\t} else if (p_191286_1_ > 9216.0D) {\n\t\t\ti = 7;\n\t\t} else if (p_191286_1_ > 4096.0D) {\n\t\t\ti = 9;\n\t\t} else if (p_191286_1_ > 1024.0D) {\n\t\t\ti = 11;\n\t\t} else if (p_191286_1_ > 576.0D) {\n\t\t\ti = 13;\n\t\t} else if (p_191286_1_ > 256.0D) {\n\t\t\ti = 14;\n\t\t} else {\n\t\t\ti = 15;\n\t\t}\n\n\t\treturn i;\n\t}\n\n\tprotected float getOffset() {\n\t\treturn 1.0F;\n\t}\n\n\tprivate FloatBuffer getBuffer(float p_188193_1_, float p_188193_2_, float p_188193_3_, float p_188193_4_) {\n\t\tthis.buffer.clear();\n\t\tthis.buffer.put(p_188193_1_).put(p_188193_2_).put(p_188193_3_).put(p_188193_4_);\n\t\tthis.buffer.flip();\n\t\treturn this.buffer;\n\t}\n\n}\n", "nications AB.\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.sonymobile.gitlab.api;\n\nimport com.github.tomakehurst.wiremock.junit.WireMockRule;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Parent for all test classes testing the GitLab API client.\n *\n * @author Emil Nilsson\n */\npublic abstract class AbstractClientTest {\n    /** The port to run WireMock on. */\n    private static final int WIREMOCK_PORT = parseInt(System.getProperty(\"com.sonymobile.gitlab.api.wiremock.port\",\n            \"6789\"));\n\n    /** The URL of the GitLab API WireMock is faking. */\n    protected static final String SERVER_URL = \"http://localhost:\" + WIREMOCK_PORT;\n\n    /** The private token of the GitLab API WireMock is faking. */\n    protected static final String PRIVATE_TOKEN = \"0123456789abcdef\";\n\n    /** A rule for setting up a mock server for every test. */\n    @Rule\n    public WireMockRule serverRule = new WireMockRule(WIREMOCK_PORT);\n\n    /** A rule for catching expected exceptions. */\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    /** The GitLab API client to test against. */\n    protected GitLabApiClient client;\n\n    /**\n     * Set up the GitLab API client.\n     */\n    @Before\n    public void setUp() {\n        client = new GitLabApiClient(SERVER_URL, PRIVATE_TOKEN);\n    }\n}\n", "pp.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\n\n/**\n * A simple {@link Fragment} subclass.\n */\npublic class NewestFragment extends Fragment {\n\n\n    public NewestFragment() {\n        // Required empty public constructor\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_newest, container, false);\n    }\n\n\n}\n", "String\npublic final class Material<T extends MaterialMeta> {\n\n  public static final Material<MaterialMeta> ACACIA_BOAT =\n          new Material<>(447, \"acacia_boat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ACACIA_DOOR =\n          new Material<>(430, \"acacia_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ACACIA_DOOR_BLOCK =\n          new Material<>(196, \"acacia_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ACACIA_FENCE =\n          new Material<>(192, \"acacia_fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ACACIA_FENCE_GATE =\n          new Material<>(187, \"acacia_fence_gate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ACACIA_STAIRS =\n          new Material<>(163, \"acacia_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ACTIVATOR_RAIL =\n          new Material<>(157, \"activator_rail\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> AIR =\n          new Material<>(0, \"air\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ANVIL =\n          new Material<>(145, \"anvil\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> APPLE =\n          new Material<>(260, \"apple\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ARMOR_STAND =\n          new Material<>(416, \"armor_stand\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ARROW =\n          new Material<>(262, \"arrow\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BAKED_POTATO =\n          new Material<>(393, \"baked_potato\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BANNER =\n          new Material<>(425, \"banner\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BARRIER =\n          new Material<>(166, \"barrier\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEACON =\n          new Material<>(138, \"beacon\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BED =\n          new Material<>(355, \"bed\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEDROCK =\n          new Material<>(7, \"bedrock\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BED_BLOCK =\n          new Material<>(26, \"bed\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEEF =\n          new Material<>(363, \"beef\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEETROOT =\n          new Material<>(434, \"beetroot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEETROOTS =\n          new Material<>(207, \"beetroots\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEETROOT_SEEDS =\n          new Material<>(435, \"beetroot_seeds\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BEETROOT_SOUP =\n          new Material<>(436, \"beetroot_soup\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BIRCH_BOAT =\n          new Material<>(445, \"birch_boat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BIRCH_DOOR =\n          new Material<>(428, \"birch_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BIRCH_DOOR_BLOCK =\n          new Material<>(194, \"birch_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BIRCH_FENCE =\n          new Material<>(189, \"birch_fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BIRCH_FENCE_GATE =\n          new Material<>(184, \"birch_fence_gate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BIRCH_STAIRS =\n          new Material<>(135, \"birch_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BLAZE_POWDER =\n          new Material<>(377, \"blaze_powder\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BLAZE_ROD =\n          new Material<>(369, \"blaze_rod\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BOAT =\n          new Material<>(333, \"boat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BONE =\n          new Material<>(352, \"bone\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BOOK =\n          new Material<>(340, \"book\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BOOKSHELF =\n          new Material<>(47, \"bookshelf\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BOW =\n          new Material<>(261, \"bow\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BOWL =\n          new Material<>(281, \"bowl\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BREAD =\n          new Material<>(297, \"bread\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BREWING_STAND =\n          new Material<>(379, \"brewing_stand\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BREWING_STAND_BLOCK =\n          new Material<>(117, \"brewing_stand\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BRICK =\n          new Material<>(336, \"brick\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> BRICK_BLOCK =\n          new Material<>(45, \"brick_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BRICK_STAIRS =\n          new Material<>(108, \"brick_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BROWN_MUSHROOM =\n          new Material<>(39, \"brown_mushroom\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BROWN_MUSHROOM_BLOCK =\n          new Material<>(99, \"brown_mushroom_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> BUCKET =\n          new Material<>(325, \"bucket\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CACTUS =\n          new Material<>(81, \"cactus\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CAKE =\n          new Material<>(354, \"cake\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CAKE_BLOCK =\n          new Material<>(92, \"cake\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CARPET =\n          new Material<>(171, \"carpet\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CARROT =\n          new Material<>(391, \"carrot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CARROTS =\n          new Material<>(141, \"carrots\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CARROT_ON_A_STICK =\n          new Material<>(398, \"carrot_on_a_stick\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CAULDRON =\n          new Material<>(380, \"cauldron\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CAULDRON_BLOCK =\n          new Material<>(118, \"cauldron\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHAINMAIL_BOOTS =\n          new Material<>(305, \"chainmail_boots\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHAINMAIL_CHESTPLATE =\n          new Material<>(303, \"chainmail_chestplate\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHAINMAIL_HELMET =\n          new Material<>(302, \"chainmail_helmet\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHAINMAIL_LEGGINGS =\n          new Material<>(304, \"chainmail_leggings\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHAIN_COMMAND_BLOCK =\n          new Material<>(211, \"chain_command_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHEST =\n          new Material<>(54, \"chest\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHEST_MINECART =\n          new Material<>(342, \"chest_minecart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHICKEN =\n          new Material<>(365, \"chicken\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHORUS_FLOWER =\n          new Material<>(200, \"chorus_flower\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHORUS_FRUIT =\n          new Material<>(432, \"chorus_fruit\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHORUS_FRUIT_POPPED =\n          new Material<>(433, \"chorus_fruit_popped\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CHORUS_PLANT =\n          new Material<>(199, \"chorus_plant\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CLAY =\n          new Material<>(82, \"clay\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> CLAY_BALL =\n          new Material<>(337, \"clay_ball\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CLOCK =\n          new Material<>(347, \"clock\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COAL =\n          new Material<>(263, \"coal\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COAL_BLOCK =\n          new Material<>(173, \"coal_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> COAL_ORE =\n          new Material<>(16, \"coal_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> COBBLESTONE =\n          new Material<>(4, \"cobblestone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> COBBLESTONE_WALL =\n          new Material<>(139, \"cobblestone_wall\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> COCOA =\n          new Material<>(127, \"cocoa\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> COMMAND_BLOCK =\n          new Material<>(137, \"command_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> COMMAND_BLOCK_MINECART =\n          new Material<>(422, \"command_block_minecart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COMPARATOR =\n          new Material<>(404, \"comparator\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COMPASS =\n          new Material<>(345, \"compass\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKED_BEEF =\n          new Material<>(364, \"cooked_beef\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKED_CHICKEN =\n          new Material<>(366, \"cooked_chicken\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKED_FISHED =\n          new Material<>(350, \"cooked_fished\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKED_MUTTON =\n          new Material<>(424, \"cooked_mutton\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKED_PORKCHOP =\n          new Material<>(320, \"cooked_porkchop\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKED_RABBIT =\n          new Material<>(412, \"cooked_rabbit\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> COOKIE =\n          new Material<>(357, \"cookie\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> CRAFTING_TABLE =\n          new Material<>(58, \"crafting_table\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DARK_OAK_BOAT =\n          new Material<>(448, \"dark_oak_boat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DARK_OAK_DOOR =\n          new Material<>(431, \"dark_oak_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DARK_OAK_DOOR_BLOCK =\n          new Material<>(197, \"dark_oak_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DARK_OAK_FENCE =\n          new Material<>(191, \"dark_oak_fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DARK_OAK_FENCE_GATE =\n          new Material<>(186, \"dark_oak_fence_gate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DARK_OAK_STAIRS =\n          new Material<>(164, \"dark_oak_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DAYLIGHT_DETECTOR =\n          new Material<>(151, \"daylight_detector\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DAYLIGHT_DETECTOR_INVERTED =\n          new Material<>(178, \"daylight_detector_inverted\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DEADBUSH =\n          new Material<>(32, \"deadbush\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DETECTOR_RAIL =\n          new Material<>(28, \"detector_rail\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND =\n          new Material<>(264, \"diamond\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_AXE =\n          new Material<>(279, \"diamond_axe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_BLOCK =\n          new Material<>(57, \"diamond_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_BOOTS =\n          new Material<>(313, \"diamond_boots\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_CHESTPLATE =\n          new Material<>(311, \"diamond_chestplate\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_HELMET =\n          new Material<>(310, \"diamond_helmet\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_HOE =\n          new Material<>(293, \"diamond_hoe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_HORSE_ARMOR =\n          new Material<>(419, \"diamond_horse_armor\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_LEGGINGS =\n          new Material<>(312, \"diamond_leggings\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_ORE =\n          new Material<>(56, \"diamond_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_PICKAXE =\n          new Material<>(278, \"diamond_pickaxe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_SHOVEL =\n          new Material<>(277, \"diamond_shovel\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIAMOND_SWORD =\n          new Material<>(276, \"diamond_sword\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DIRT =\n          new Material<>(3, \"dirt\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DISPENSER =\n          new Material<>(23, \"dispenser\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DOUBLE_PLANT =\n          new Material<>(175, \"double_plant\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DOUBLE_STONE_SLAB =\n          new Material<>(43, \"double_stone_slab\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DOUBLE_STONE_SLAB2 =\n          new Material<>(181, \"double_stone_slab2\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DOUBLE_WOODEN_SLAB =\n          new Material<>(125, \"double_wooden_slab\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DRAGON_BREATH =\n          new Material<>(437, \"dragon_breath\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> DRAGON_EGG =\n          new Material<>(122, \"dragon_egg\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DROPPER =\n          new Material<>(158, \"dropper\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> DYE =\n          new Material<>(351, \"dye\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> EGG =\n          new Material<>(344, \"egg\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ELYTRA =\n          new Material<>(443, \"elytra\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> EMERALD =\n          new Material<>(388, \"emerald\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> EMERALD_BLOCK =\n          new Material<>(133, \"emerald_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> EMERALD_ORE =\n          new Material<>(129, \"emerald_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ENCHANTED_BOOK =\n          new Material<>(403, \"enchanted_book\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ENCHANTING_TABLE =\n          new Material<>(116, \"enchanting_table\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ENDER_CHEST =\n          new Material<>(130, \"ender_chest\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ENDER_EYE =\n          new Material<>(381, \"ender_eye\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ENDER_PEARL =\n          new Material<>(368, \"ender_pearl\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_BRICKS =\n          new Material<>(206, \"end_bricks\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_CRYSTAL =\n          new Material<>(426, \"end_crystal\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_GATEWAY =\n          new Material<>(209, \"end_gateway\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_PORTAL =\n          new Material<>(119, \"end_portal\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_PORTAL_FRAME =\n          new Material<>(120, \"end_portal_frame\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_ROD =\n          new Material<>(198, \"end_rod\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> END_STONE =\n          new Material<>(121, \"end_stone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> EXPERIENCE_BOTTLE =\n          new Material<>(384, \"experience_bottle\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FARMLAND =\n          new Material<>(60, \"farmland\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FEATHER =\n          new Material<>(288, \"feather\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FENCE =\n          new Material<>(85, \"fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FENCE_GATE =\n          new Material<>(107, \"fence_gate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FERMENTED_SPIDER_EYE =\n          new Material<>(376, \"fermented_spider_eye\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FILLED_MAP =\n          new Material<>(358, \"filled_map\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FIRE =\n          new Material<>(51, \"fire\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FIREWORKS =\n          new Material<>(401, \"fireworks\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FIREWORK_CHARGE =\n          new Material<>(402, \"firework_charge\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FIRE_CHARGE =\n          new Material<>(385, \"fire_charge\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FISH =\n          new Material<>(349, \"fish\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FISHING_ROD =\n          new Material<>(346, \"fishing_rod\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FLINT =\n          new Material<>(318, \"flint\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FLINT_AND_STEEL =\n          new Material<>(259, \"flint_and_steel\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FLOWER_POT =\n          new Material<>(390, \"flower_pot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> FLOWER_POT_BLOCK =\n          new Material<>(140, \"flower_pot\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FLOWING_LAVA =\n          new Material<>(10, \"flowing_lava\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FLOWING_WATER =\n          new Material<>(8, \"flowing_water\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FROSTED_ICE =\n          new Material<>(212, \"frosted_ice\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FURNACE =\n          new Material<>(61, \"furnace\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> FURNACE_MINECART =\n          new Material<>(343, \"furnace_minecart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GHAST_TEAR =\n          new Material<>(370, \"ghast_tear\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GLASS =\n          new Material<>(20, \"glass\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GLASS_BOTTLE =\n          new Material<>(374, \"glass_bottle\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GLASS_PANE =\n          new Material<>(102, \"glass_pane\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GLOWSTONE =\n          new Material<>(89, \"glowstone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GLOWSTONE_DUST =\n          new Material<>(348, \"glowstone_dust\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_APPLE =\n          new Material<>(322, \"golden_apple\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_AXE =\n          new Material<>(286, \"golden_axe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_BOOTS =\n          new Material<>(317, \"golden_boots\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_CARROT =\n          new Material<>(396, \"golden_carrot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_CHESTPLATE =\n          new Material<>(315, \"golden_chestplate\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_HELMET =\n          new Material<>(314, \"golden_helmet\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_HOE =\n          new Material<>(294, \"golden_hoe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_HORSE_ARMOR =\n          new Material<>(418, \"golden_horse_armor\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_LEGGINGS =\n          new Material<>(316, \"golden_leggings\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_PICKAXE =\n          new Material<>(285, \"golden_pickaxe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_RAIL =\n          new Material<>(27, \"golden_rail\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_SHOVEL =\n          new Material<>(284, \"golden_shovel\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLDEN_SWORD =\n          new Material<>(283, \"golden_sword\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLD_BLOCK =\n          new Material<>(41, \"gold_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLD_INGOT =\n          new Material<>(266, \"gold_ingot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLD_NUGGET =\n          new Material<>(371, \"gold_nugget\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> GOLD_ORE =\n          new Material<>(14, \"gold_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GRASS =\n          new Material<>(2, \"grass\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GRASS_PATH =\n          new Material<>(208, \"grass_path\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GRAVEL =\n          new Material<>(13, \"gravel\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> GUNPOWDER =\n          new Material<>(289, \"gunpowder\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> HARDENED_CLAY =\n          new Material<>(172, \"hardened_clay\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> HAY_BLOCK =\n          new Material<>(170, \"hay_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> HEAVY_WEIGHTED_PRESSURE_PLATE =\n          new Material<>(148, \"heavy_weighted_pressure_plate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> HOPPER =\n          new Material<>(154, \"hopper\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> HOPPER_MINECART =\n          new Material<>(408, \"hopper_minecart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> ICE =\n          new Material<>(79, \"ice\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_AXE =\n          new Material<>(258, \"iron_axe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_BARS =\n          new Material<>(101, \"iron_bars\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_BLOCK =\n          new Material<>(42, \"iron_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_BOOTS =\n          new Material<>(309, \"iron_boots\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_CHESTPLATE =\n          new Material<>(307, \"iron_chestplate\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_DOOR =\n          new Material<>(330, \"iron_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_DOOR_BLOCK =\n          new Material<>(71, \"iron_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_HELMET =\n          new Material<>(306, \"iron_helmet\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_HOE =\n          new Material<>(292, \"iron_hoe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_HORSE_ARMOR =\n          new Material<>(417, \"iron_horse_armor\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_INGOT =\n          new Material<>(265, \"iron_ingot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_LEGGINGS =\n          new Material<>(308, \"iron_leggings\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_ORE =\n          new Material<>(15, \"iron_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_PICKAXE =\n          new Material<>(257, \"iron_pickaxe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_SHOVEL =\n          new Material<>(256, \"iron_shovel\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_SWORD =\n          new Material<>(267, \"iron_sword\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> IRON_TRAPDOOR =\n          new Material<>(167, \"iron_trapdoor\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ITEM_FRAME =\n          new Material<>(389, \"item_frame\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUKEBOX =\n          new Material<>(84, \"jukebox\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUNGLE_BOAT =\n          new Material<>(446, \"jungle_boat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUNGLE_DOOR =\n          new Material<>(429, \"jungle_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUNGLE_DOOR_BLOCK =\n          new Material<>(195, \"jungle_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUNGLE_FENCE =\n          new Material<>(190, \"jungle_fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUNGLE_FENCE_GATE =\n          new Material<>(185, \"jungle_fence_gate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> JUNGLE_STAIRS =\n          new Material<>(136, \"jungle_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LADDER =\n          new Material<>(65, \"ladder\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LAPIS_BLOCK =\n          new Material<>(22, \"lapis_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LAPIS_ORE =\n          new Material<>(21, \"lapis_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LAVA =\n          new Material<>(11, \"lava\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LAVA_BUCKET =\n          new Material<>(327, \"lava_bucket\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEAD =\n          new Material<>(420, \"lead\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEATHER =\n          new Material<>(334, \"leather\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEATHER_BOOTS =\n          new Material<>(301, \"leather_boots\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEATHER_CHESTPLATE =\n          new Material<>(299, \"leather_chestplate\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEATHER_HELMET =\n          new Material<>(298, \"leather_helmet\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEATHER_LEGGINGS =\n          new Material<>(300, \"leather_leggings\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEAVES =\n          new Material<>(18, \"leaves\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEAVES2 =\n          new Material<>(161, \"leaves2\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LEVER =\n          new Material<>(69, \"lever\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LIGHT_WEIGHTED_PRESSURE_PLATE =\n          new Material<>(147, \"light_weighted_pressure_plate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LINGERING_POTION =\n          new Material<>(441, \"lingering_potion\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> LIT_FURNACE =\n          new Material<>(62, \"lit_furnace\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LIT_PUMPKIN =\n          new Material<>(91, \"lit_pumpkin\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LIT_REDSTONE_LAMP =\n          new Material<>(124, \"lit_redstone_lamp\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LIT_REDSTONE_ORE =\n          new Material<>(74, \"lit_redstone_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LOG =\n          new Material<>(17, \"log\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> LOG2 =\n          new Material<>(162, \"log2\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> MAGMA_CREAM =\n          new Material<>(378, \"magma_cream\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MAP =\n          new Material<>(395, \"map\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MELON =\n          new Material<>(360, \"melon\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MELON_BLOCK =\n          new Material<>(103, \"melon_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> MELON_SEEDS =\n          new Material<>(362, \"melon_seeds\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MELON_STEM =\n          new Material<>(105, \"melon_stem\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> MILK_BUCKET =\n          new Material<>(335, \"milk_bucket\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MINECART =\n          new Material<>(328, \"minecart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MOB_SPAWNER =\n          new Material<>(52, \"mob_spawner\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> MONSTER_EGG =\n          new Material<>(97, \"monster_egg\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> MOSSY_COBBLESTONE =\n          new Material<>(48, \"mossy_cobblestone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> MUSHROOM_STEW =\n          new Material<>(282, \"mushroom_stew\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MUTTON =\n          new Material<>(423, \"mutton\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> MYCELIUM =\n          new Material<>(110, \"mycelium\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> NAME_TAG =\n          new Material<>(421, \"name_tag\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHERBRICK =\n          new Material<>(405, \"netherbrick\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHERRACK =\n          new Material<>(87, \"netherrack\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHER_BRICK =\n          new Material<>(112, \"nether_brick\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHER_BRICK_FENCE =\n          new Material<>(113, \"nether_brick_fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHER_BRICK_STAIRS =\n          new Material<>(114, \"nether_brick_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHER_STAR =\n          new Material<>(399, \"nether_star\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHER_WART =\n          new Material<>(372, \"nether_wart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> NETHER_WART_BLOCK =\n          new Material<>(214, \"nether_wart\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> NOTEBLOCK =\n          new Material<>(25, \"noteblock\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> OAK_STAIRS =\n          new Material<>(53, \"oak_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> OBSIDIAN =\n          new Material<>(49, \"obsidian\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PACKED_ICE =\n          new Material<>(174, \"packed_ice\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PAINTING =\n          new Material<>(321, \"painting\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PAPER =\n          new Material<>(339, \"paper\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PISTON =\n          new Material<>(33, \"piston\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PISTON_EXTENSION =\n          new Material<>(36, \"piston_extension\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PISTON_HEAD =\n          new Material<>(34, \"piston_head\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PLANKS =\n          new Material<>(5, \"planks\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> POISONOUS_POTATO =\n          new Material<>(394, \"poisonous_potato\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PORKCHOP =\n          new Material<>(319, \"porkchop\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PORTAL =\n          new Material<>(90, \"portal\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> POTATO =\n          new Material<>(392, \"potato\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> POTATOES =\n          new Material<>(142, \"potatoes\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> POTION =\n          new Material<>(373, \"potion\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> POWERED_COMPARATOR =\n          new Material<>(150, \"powered_comparator\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> POWERED_REPEATER =\n          new Material<>(94, \"powered_repeater\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PRISMARINE =\n          new Material<>(168, \"prismarine\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PRISMARINE_CRYSTALS =\n          new Material<>(410, \"prismarine_crystals\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PRISMARINE_SHARD =\n          new Material<>(409, \"prismarine_shard\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PUMPKIN =\n          new Material<>(86, \"pumpkin\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PUMPKIN_PIE =\n          new Material<>(400, \"pumpkin_pie\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PUMPKIN_SEEDS =\n          new Material<>(361, \"pumpkin_seeds\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> PUMPKIN_STEM =\n          new Material<>(104, \"pumpkin_stem\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PURPUR_BLOCK =\n          new Material<>(201, \"purpur_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PURPUR_DOUBLE_SLAB =\n          new Material<>(204, \"purpur_double_slab\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PURPUR_PILLAR =\n          new Material<>(202, \"purpur_pillar\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PURPUR_SLAB =\n          new Material<>(205, \"purpur_slab\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> PURPUR_STAIRS =\n          new Material<>(203, \"purpur_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> QUARTZ =\n          new Material<>(406, \"quartz\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> QUARTZ_BLOCK =\n          new Material<>(155, \"quartz_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> QUARTZ_ORE =\n          new Material<>(153, \"quartz_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> QUARTZ_STAIRS =\n          new Material<>(156, \"quartz_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RABBIT =\n          new Material<>(411, \"rabbit\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RABBIT_FOOT =\n          new Material<>(414, \"rabbit_foot\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RABBIT_HIDE =\n          new Material<>(415, \"rabbit_hide\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RABBIT_STEW =\n          new Material<>(413, \"rabbit_stew\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RAIL =\n          new Material<>(66, \"rail\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_11 =\n          new Material<>(2266, \"record_11\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_13 =\n          new Material<>(2256, \"record_13\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_BLOCKS =\n          new Material<>(2258, \"record_blocks\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_CAT =\n          new Material<>(2257, \"record_cat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_CHIRP =\n          new Material<>(2259, \"record_chirp\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_FAR =\n          new Material<>(2260, \"record_far\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_MALL =\n          new Material<>(2261, \"record_mall\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_MELLOHI =\n          new Material<>(2262, \"record_mellohi\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_STAL =\n          new Material<>(2263, \"record_stal\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_STRAD =\n          new Material<>(2264, \"record_strad\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_WAIT =\n          new Material<>(2267, \"record_wait\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> RECORD_WARD =\n          new Material<>(2265, \"record_ward\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> REDSTONE =\n          new Material<>(331, \"redstone\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> REDSTONE_BLOCK =\n          new Material<>(152, \"redstone_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> REDSTONE_LAMP =\n          new Material<>(123, \"redstone_lamp\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> REDSTONE_ORE =\n          new Material<>(73, \"redstone_ore\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> REDSTONE_TORCH =\n          new Material<>(76, \"redstone_torch\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> REDSTONE_WIRE =\n          new Material<>(55, \"redstone_wire\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RED_FLOWER =\n          new Material<>(38, \"red_flower\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RED_MUSHROOM =\n          new Material<>(40, \"red_mushroom\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RED_MUSHROOM_BLOCK =\n          new Material<>(100, \"red_mushroom_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RED_SANDSTONE =\n          new Material<>(179, \"red_sandstone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> RED_SANDSTONE_STAIRS =\n          new Material<>(180, \"red_sandstone_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> REEDS =\n          new Material<>(338, \"reeds\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> REEDS_BLOCK =\n          new Material<>(83, \"reeds\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> REPEATER =\n          new Material<>(356, \"repeater\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> REPEATING_COMMAND_BLOCK =\n          new Material<>(210, \"repeating_command_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> ROTTEN_FLESH =\n          new Material<>(367, \"rotten_flesh\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SADDLE =\n          new Material<>(329, \"saddle\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SAND =\n          new Material<>(12, \"sand\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SANDSTONE =\n          new Material<>(24, \"sandstone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SANDSTONE_STAIRS =\n          new Material<>(128, \"sandstone_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SAPLING =\n          new Material<>(6, \"sapling\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SEA_LANTERN =\n          new Material<>(169, \"sea_lantern\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SHEARS =\n          new Material<>(359, \"shears\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SHIELD =\n          new Material<>(442, \"shield\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SIGN =\n          new Material<>(323, \"sign\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SKULL =\n          new Material<>(397, \"skull\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SKULL_BLOCK =\n          new Material<>(144, \"skull\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SLIME =\n          new Material<>(165, \"slime\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SLIME_BALL =\n          new Material<>(341, \"slime_ball\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SNOW =\n          new Material<>(80, \"snow\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SNOWBALL =\n          new Material<>(332, \"snowball\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SNOW_LAYER =\n          new Material<>(78, \"snow_layer\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SOUL_SAND =\n          new Material<>(88, \"soul_sand\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPAWN_EGG =\n          new Material<>(383, \"spawn_egg\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPECKLED_MELON =\n          new Material<>(382, \"speckled_melon\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPECTRAL_ARROW =\n          new Material<>(439, \"spectral_arrow\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPIDER_EYE =\n          new Material<>(375, \"spider_eye\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPLASH_POTION =\n          new Material<>(438, \"splash_potion\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPONGE =\n          new Material<>(19, \"sponge\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPRUCE_BOAT =\n          new Material<>(444, \"spruce_boat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPRUCE_DOOR =\n          new Material<>(427, \"spruce_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPRUCE_DOOR_BLOCK =\n          new Material<>(193, \"spruce_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPRUCE_FENCE =\n          new Material<>(188, \"spruce_fence\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPRUCE_FENCE_GATE =\n          new Material<>(183, \"spruce_fence_gate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SPRUCE_STAIRS =\n          new Material<>(134, \"spruce_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STAINED_GLASS =\n          new Material<>(95, \"stained_glass\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STAINED_GLASS_PANE =\n          new Material<>(160, \"stained_glass_pane\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STAINED_HARDENED_CLAY =\n          new Material<>(159, \"stained_hardened_clay\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STANDING_BANNER =\n          new Material<>(176, \"standing_banner\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STANDING_SIGN =\n          new Material<>(63, \"standing_sign\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STICK =\n          new Material<>(280, \"stick\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STICKY_PISTON =\n          new Material<>(29, \"sticky_piston\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE =\n          new Material<>(1, \"stone\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONEBRICK =\n          new Material<>(98, \"stonebrick\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_AXE =\n          new Material<>(275, \"stone_axe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_BRICK_STAIRS =\n          new Material<>(109, \"stone_brick_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_BUTTON =\n          new Material<>(77, \"stone_button\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_HOE =\n          new Material<>(291, \"stone_hoe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_PICKAXE =\n          new Material<>(274, \"stone_pickaxe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_PRESSURE_PLATE =\n          new Material<>(70, \"stone_pressure_plate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_SHOVEL =\n          new Material<>(273, \"stone_shovel\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_SLAB =\n          new Material<>(44, \"stone_slab\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_SLAB2 =\n          new Material<>(182, \"stone_slab2\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_STAIRS =\n          new Material<>(67, \"stone_stairs\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> STONE_SWORD =\n          new Material<>(272, \"stone_sword\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STRING =\n          new Material<>(287, \"string\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> STRUCTURE_BLOCK =\n          new Material<>(255, \"structure_block\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> SUGAR =\n          new Material<>(353, \"sugar\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> TALLGRASS =\n          new Material<>(31, \"tallgrass\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> TIPPED_ARROW =\n          new Material<>(440, \"tipped_arrow\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> TNT =\n          new Material<>(46, \"tnt\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> TNT_MINECART =\n          new Material<>(407, \"tnt_minecart\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> TORCH =\n          new Material<>(50, \"torch\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> TRAPDOOR =\n          new Material<>(96, \"trapdoor\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> TRAPPED_CHEST =\n          new Material<>(146, \"trapped_chest\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> TRIPWIRE =\n          new Material<>(132, \"tripwire\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> TRIPWIRE_HOOK =\n          new Material<>(131, \"tripwire_hook\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> UNLIT_REDSTONE_TORCH =\n          new Material<>(75, \"unlit_redstone_torch\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> UNPOWERED_COMPARATOR =\n          new Material<>(149, \"unpowered_comparator\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> UNPOWERED_REPEATER =\n          new Material<>(93, \"unpowered_repeater\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> VINE =\n          new Material<>(106, \"vine\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WALL_BANNER =\n          new Material<>(177, \"wall_banner\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WALL_SIGN =\n          new Material<>(68, \"wall_sign\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WATER =\n          new Material<>(9, \"water\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WATERLILY =\n          new Material<>(111, \"waterlily\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WATER_BUCKET =\n          new Material<>(326, \"water_bucket\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WEB =\n          new Material<>(30, \"web\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WHEAT =\n          new Material<>(296, \"wheat\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WHEAT_BLOCK =\n          new Material<>(59, \"wheat\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WHEAT_SEEDS =\n          new Material<>(295, \"wheat_seeds\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_AXE =\n          new Material<>(271, \"wooden_axe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_BUTTON =\n          new Material<>(143, \"wooden_button\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_DOOR =\n          new Material<>(324, \"wooden_door\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_DOOR_BLOCK =\n          new Material<>(64, \"wooden_door\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_HOE =\n          new Material<>(290, \"wooden_hoe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_PICKAXE =\n          new Material<>(270, \"wooden_pickaxe\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_PRESSURE_PLATE =\n          new Material<>(72, \"wooden_pressure_plate\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_SHOVEL =\n          new Material<>(269, \"wooden_shovel\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_SLAB =\n          new Material<>(126, \"wooden_slab\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOODEN_SWORD =\n          new Material<>(268, \"wooden_sword\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WOOL =\n          new Material<>(35, \"wool\", true, MaterialMeta.class);\n  public static final Material<MaterialMeta> WRITABLE_BOOK =\n          new Material<>(386, \"writable_book\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> WRITTEN_BOOK =\n          new Material<>(387, \"written_book\", false, MaterialMeta.class);\n  public static final Material<MaterialMeta> YELLOW_FLOWER =\n          new Material<>(37, \"yellow_flower\", true, MaterialMeta.class);\n\n  private final int id;\n  private final String idName;\n  private final boolean block;\n  private final Class<T> metaClass;\n  private final int maxStackSize;\n\n  Material(int id, String idName, boolean block, Class<T> metaClass) {\n    this(id, idName, block, metaClass, 64);\n  }\n\n  public Material(int id, String idName, boolean block, Class<T> metaClass, int maxStackSize) {\n    this.id = id;\n    this.idName = idName;\n    this.block = block;\n    this.metaClass = metaClass;\n    this.maxStackSize = maxStackSize;\n  }\n}\n", "ase;\n\n/**\n * <a href=\"http://d.android.com/tools/testing/testing_android.html\">Testing Fundamentals</a>\n */\npublic class ApplicationTest extends ApplicationTestCase<Application> {\n    public ApplicationTest() {\n        super(Application.class);\n    }\n}", "URL;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.util.Observable;\nimport javax.swing.SwingWorker;\nimport application.State;\nimport util.DownloaderUtils;\n\n\n/**\n * Observable Class that represents the download Task\n * \n * @author c.timpert\n * \n */\npublic class DownloadTask extends Observable {\n\n\t// Max size of download buffer.\n\tprivate static final int MAX_BUFFER_SIZE = 1024;\n\n\tprivate final URL url;\n\tprivate final String saveDirectory;\n\tprivate double percentage = 0;\n\tprivate double downloadSize = 0;\n\tprivate double downloaded = 0;\n\tprivate Task workerThread;\n\tprivate State state;\n\n\tpublic DownloadTask(URL url, String saveDirectory) throws IOException {\n\t\tthis.url = url;\n\t\tthis.saveDirectory = saveDirectory;\n\t\tthis.downloadSize = DownloaderUtils.getFileSize(url);\n\t}\n\n\t/**\n\t * Updates the percentage already downloaded and notifies all observers its state has changed\n\t * \n\t * @param newPercentage\n\t */\n\tprivate void updatePercentage(double newPercentage) {\n\t\tpercentage = newPercentage;\n\t\tsetChanged();\n\t\tnotifyObservers(Double.valueOf(percentage));\n\t}\n\n\t/**\n\t * Starts the download process\n\t * \n\t * @throws Exception\n\t */\n\tpublic synchronized void start() throws Exception {\n\t\tif (workerThread == null) {\n\t\t\tworkerThread = new Task();\n\t\t}\n\t\tworkerThread.execute();\n\t}\n\n\tprivate synchronized void changeState(State state) {\n\t\tthis.state = state;\n\t}\n\n\tpublic synchronized State getState() {\n\t\treturn state;\n\t}\n\n\tprivate class Task extends SwingWorker<Void, Void> {\n\n\t\t@Override\n\t\tprotected Void doInBackground() {\n\t\t\tchangeState(State.RUNNING);\n\n\t\t\ttry (InputStream stream = DownloaderUtils.downloadFile(url)) {\n\n\t\t\t\twhile (state == State.RUNNING) {\n\t\t\t\t\tbyte buffer[];\n\t\t\t\t\tif (downloadSize - downloaded > MAX_BUFFER_SIZE) {\n\t\t\t\t\t\tbuffer = new byte[MAX_BUFFER_SIZE];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbuffer = new byte[(int) (downloadSize - downloaded)];\n\t\t\t\t\t}\n\n\t\t\t\t\t// Read from server into buffer.\n\t\t\t\t\tint read = stream.read(buffer);\n\t\t\t\t\tif (read == -1) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// Write buffer to file.\n\t\t\t\t\tFiles.write(Paths.get(DownloaderUtils.getFileName(saveDirectory, url)), buffer, StandardOpenOption.CREATE, StandardOpenOption.APPEND);\n\t\t\t\t\tdownloaded += read;\n\n\t\t\t\t\tupdatePercentage((downloaded / downloadSize) * 100);\n\t\t\t\t}\n\n\t\t\t\tif (state == State.RUNNING) {\n\t\t\t\t\tupdatePercentage(downloaded / downloadSize * 100);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t\tchangeState(State.ERROR);\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t@Override\n\t\tprotected void done() {\n\t\t\tchangeState(State.FINISHED);\n\t\t}\n\t}\n}\n", ".commons.lang3.builder.ToStringBuilder;\nimport org.apache.commons.lang3.builder.ToStringStyle;\n\nimport org.diorite.impl.connection.EnumProtocol;\nimport org.diorite.impl.connection.EnumProtocolDirection;\nimport org.diorite.impl.connection.packets.PacketClass;\nimport org.diorite.impl.connection.packets.PacketDataSerializer;\nimport org.diorite.impl.connection.packets.play.PacketPlayInListener;\n\n@PacketClass(id = 0x00, protocol = EnumProtocol.PLAY, direction = EnumProtocolDirection.SERVERBOUND)\npublic class PacketPlayInKeepAlive extends PacketPlayIn\n{\n    private int id;\n\n    public PacketPlayInKeepAlive()\n    {\n    }\n\n    public PacketPlayInKeepAlive(final int id)\n    {\n        this.id = id;\n    }\n\n    @Override\n    public void readPacket(final PacketDataSerializer data) throws IOException\n    {\n        this.id = data.readVarInt();\n    }\n\n    @Override\n    public void writeFields(final PacketDataSerializer data) throws IOException\n    {\n        data.writeVarInt(this.id);\n    }\n\n    @Override\n    public void handle(final PacketPlayInListener listener)\n    {\n        listener.handle(this);\n    }\n\n    public int getId()\n    {\n        return this.id;\n    }\n\n    public void setId(final int id)\n    {\n        this.id = id;\n    }\n\n    @Override\n    public String toString()\n    {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE).appendSuper(super.toString()).append(\"id\", this.id).toString();\n    }\n}\n", "rt android.os.Bundle;\nimport android.support.v7.app.AppCompatActivity;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\n\nimport org.shredzone.flattr4j.exception.FlattrException;\n\nimport de.danoeh.antennapod.BuildConfig;\nimport de.danoeh.antennapod.R;\nimport de.danoeh.antennapod.core.preferences.UserPreferences;\nimport de.danoeh.antennapod.core.util.flattr.FlattrUtils;\n\n/** Guides the user through the authentication process */\n\npublic class FlattrAuthActivity extends AppCompatActivity {\n\tprivate static final String TAG = \"FlattrAuthActivity\";\n\n\tprivate TextView txtvExplanation;\n\tprivate Button butAuthenticate;\n\tprivate Button butReturn;\n\t\n\tprivate boolean authSuccessful;\n\t\n\tprivate static FlattrAuthActivity singleton;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsetTheme(UserPreferences.getTheme());\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsingleton = this;\n\t\tauthSuccessful = false;\n\t\tif (BuildConfig.DEBUG) Log.d(TAG, \"Activity created\");\n\t\tgetSupportActionBar().setDisplayHomeAsUpEnabled(true);\n\t\tsetContentView(R.layout.flattr_auth);\n\t\ttxtvExplanation = (TextView) findViewById(R.id.txtvExplanation);\n\t\tbutAuthenticate = (Button) findViewById(R.id.but_authenticate);\n\t\tbutReturn = (Button) findViewById(R.id.but_return_home);\n\n\t\tbutReturn.setOnClickListener(v -> {\n            Intent intent = new Intent(FlattrAuthActivity.this, MainActivity.class);\n            intent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n            startActivity(intent);\n        });\n\t\t\n\t\tbutAuthenticate.setOnClickListener(v -> {\n            try {\n                FlattrUtils.startAuthProcess(FlattrAuthActivity.this);\n            } catch (FlattrException e) {\n                e.printStackTrace();\n            }\n        });\n\t}\n\t\n\tpublic static FlattrAuthActivity getInstance() {\n\t\treturn singleton;\n\t}\n\n\t@Override\n\tprotected void onResume() {\n\t\tsuper.onResume();\n\t\tif (BuildConfig.DEBUG) Log.d(TAG, \"Activity resumed\");\n\t\tUri uri = getIntent().getData();\n\t\tif (uri != null) {\n\t\t\tif (BuildConfig.DEBUG) Log.d(TAG, \"Received uri\");\n\t\t\tFlattrUtils.handleCallback(this, uri);\n\t\t}\n\t}\n\n\tpublic void handleAuthenticationSuccess() {\n\t\tauthSuccessful = true;\n\t\ttxtvExplanation.setText(R.string.flattr_auth_success);\n\t\tbutAuthenticate.setEnabled(false);\n\t\tbutReturn.setVisibility(View.VISIBLE);\n\t}\n\n\t@Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n        super.onCreateOptionsMenu(menu);\n\t\treturn true;\n\t}\n\t\n\t\n\n\t@Override\n\tprotected void onPause() {\n\t\tsuper.onPause();\n\t\tif (authSuccessful) {\n\t\t\tfinish();\n\t\t}\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tswitch (item.getItemId()) {\n\t\tcase android.R.id.home:\n\t\t\tif (authSuccessful) {\n\t\t\t\tIntent intent = new Intent(this, PreferenceActivity.class);\n\t\t\t\tintent.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);\n\t\t\t\tstartActivity(intent);\n\t\t\t} else {\n\t\t\t\tfinish();\n\t\t\t}\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\n}\n", " template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage sisdistrab1_grupo_rmi.RMI.Teste;\n\nimport java.net.DatagramPacket;\nimport java.net.InetAddress;\nimport java.net.MulticastSocket;\n\n/**\n *\n * @author Daniel\n */\npublic class ServerGrupo {\n    \n    public static void main(String[] args) throws Exception{\n        MulticastSocket ms = new MulticastSocket(1010);\n\n        ms.joinGroup(InetAddress.getByName(\"224.0.0.1\"));\n\n\n        boolean saida = false;\n\n        byte[] buffer = new byte[1024];\n        buffer = new String(\"Server do Grupo Online\").getBytes();\n        DatagramPacket pacote = new DatagramPacket(buffer, buffer.length, InetAddress.getByName(\"224.0.0.1\"), 1010);\n        ms.send(pacote);\n\n        while(true){\n            //if(id == 0){\n\n            //}else{\n                buffer = new byte[1024];\n                pacote = new DatagramPacket(buffer, buffer.length,  InetAddress.getByName(\"224.0.0.1\"), 1010);\n                ms.receive(pacote);\n\n                String teste = new String(pacote.getData(),0,pacote.getLength());\n                System.out.println(teste);\n\n            //}\n\n            if (saida)\n                break;\n        }\n\n        ms.leaveGroup(InetAddress.getByName(\"224.0.0.1\"));\n        ms.close();\n\n    }\n    \n}\n", "k.react.ReactApplication;\nimport com.facebook.react.ReactInstanceManager;\nimport com.facebook.react.ReactNativeHost;\nimport com.facebook.react.ReactPackage;\nimport com.facebook.react.shell.MainReactPackage;\nimport com.facebook.soloader.SoLoader;\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class MainApplication extends Application implements ReactApplication {\n\n  private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {\n    @Override\n    protected boolean getUseDeveloperSupport() {\n      return BuildConfig.DEBUG;\n    }\n\n    @Override\n    protected List<ReactPackage> getPackages() {\n      return Arrays.<ReactPackage>asList(\n          new MainReactPackage()\n      );\n    }\n  };\n\n  @Override\n  public ReactNativeHost getReactNativeHost() {\n    return mReactNativeHost;\n  }\n\n  @Override\n  public void onCreate() {\n    super.onCreate();\n    SoLoader.init(this, /* native exopackage */ false);\n  }\n}\n", "ublic SugarDialog() {\r\n\t\tsuper(\"Sugarscape\");\r\n\t}\r\n\r\n\t@Override\r\n\tprotected void addTexts() {\r\n\t\tsuper.addTexts();\r\n\r\n\t\taddTextField(\"vision\", \"Agent Vision:\", \"5\", \"Agent vision\", \"Positive Integer\");\r\n\t\taddTextField(\"metabolism\", \"Metabolism:\", \"5\", \"Metabolism\", \"Positive Integer\");\r\n\t\taddTextField(\"sugarGrowBackRate\", \"Sugar Grow Back Rate:\", \"1\", \"Sugar Grow Back Rate\", \"Positive Integer\");\r\n\t\taddTextField(\"sugarGrowBackInterval\", \"Sugar Grow Back Interval:\", \"1\", \"Sugar Grow Back Interval\",\r\n\t\t\t\t\"Positive Integer\");\r\n\t\taddTextField(\"maxSugar\", \"Max Possible Sugar on Grid:\", \"10\", \"Max Possible Sugar on Grid\", \"Positive Integer\");\r\n\t\taddTextField(\"numAgent\", \"Number of Agents:\", \"10\", \"Number of Agents\", \"Cannot exceed grid size\");\r\n\t\taddTextField(\"initialAgentSugar\", \"Agent Initial Sugar:\", \"10\", \"Agent Initial Sugar\", \"Positive Integer\");\r\n\t};\r\n\r\n\t@Override\r\n\tprotected boolean validate() {\r\n\t\ttry {\r\n\t\t\tint width = Integer.parseInt(myTexts.get(\"width\").getText().trim());\r\n\t\t\tint height = Integer.parseInt(myTexts.get(\"height\").getText().trim());\r\n\t\t\tint vision = Integer.parseInt(myTexts.get(\"vision\").getText().trim());\r\n\t\t\tint meta = Integer.parseInt(myTexts.get(\"metabolism\").getText().trim());\r\n\t\t\tint growRate = Integer.parseInt(myTexts.get(\"sugarGrowBackRate\").getText().trim());\r\n\t\t\tint growIntvl = Integer.parseInt(myTexts.get(\"sugarGrowBackInterval\").getText().trim());\r\n\t\t\tint maxSugar = Integer.parseInt(myTexts.get(\"maxSugar\").getText().trim());\r\n\t\t\tint numAgent = Integer.parseInt(myTexts.get(\"numAgent\").getText().trim());\r\n\t\t\tint initSugar = Integer.parseInt(myTexts.get(\"initialAgentSugar\").getText().trim());\r\n\t\t\treturn width <= 100 && width > 0 && height <= 100 && height > 0 && vision > 0 && meta > 0 && growRate > 0\r\n\t\t\t\t\t&& growIntvl > 0 && maxSugar > 0 && initSugar > 0 && numAgent <= width * height;\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tprotected String getName() {\r\n\t\treturn \"SugarModel\";\r\n\t}\r\n\r\n}\r\n", "s PostPokeRequest extends KlyphQuery\n{\n\t@Override\n\tpublic boolean isFQL()\n\t{\n\t\treturn false;\n\t}\n\t\n\t@Override\n\tpublic String getQuery(String id, String offset)\n\t{\n\t\treturn \"/\" + id + \"/pokes\";\n\t}\n\t\n\t@Override\n\tpublic HttpMethod getHttpMethod()\n\t{\n\t\treturn HttpMethod.POST;\n\t}\n}\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage controllers;\n\nimport javax.inject.Inject;\nimport javax.inject.Named;\nimport javax.inject.Singleton;\nimport javax.persistence.PersistenceException;\n\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.google.gson.Gson;\n\nimport models.Dataset;\nimport models.DatasetLog;\nimport models.DatasetLogRepository;\nimport models.DatasetRepository;\nimport play.mvc.*;\n\n@Named\n@Singleton\npublic class DatasetLogController extends Controller {\n\t\n\tprivate final DatasetLogRepository datasetLogRepository;\n\tprivate final DatasetRepository datasetRepository;\n\t\n\t@Inject\n\tpublic DatasetLogController(DatasetRepository datasetRepository, \n\t\t\tDatasetLogRepository datasetLogRepository) {\n\t\tthis.datasetLogRepository = datasetLogRepository;\n\t\tthis.datasetRepository = datasetRepository;\n\t}\n\t\n\tpublic Result addDatasetLog() {\n\t\tJsonNode json = request().body().asJson();\n    \tif (json == null) {\n    \t\tSystem.out.println(\"DatasetLog not saved, expecting Json data\");\n\t\t\treturn badRequest(\"DatasetLog not saved, expecting Json data\");\n    \t}\n    \t\n    \tString plotUrl = json.findPath(\"plotUrl\").asText();\n    \tString dataUrl = json.findPath(\"dataUrl\").asText();\n    \tlong originalDatasetId = json.findPath(\"originalDatasetId\").asLong();\n    \tlong outputDatasetId = json.findPath(\"outputDatasetId\").asLong();\n    \tlong serviceExecutionLogId = json.findPath(\"serviceExecutionLogId\").asLong();\n    \tlong datasetId = json.findPath(\"datasetId\").asLong();\n    \t\n    \ttry {\n\t\t\tDataset originalDataset = datasetRepository.findOne(originalDatasetId);\n\t\t\tDataset outputDataset = datasetRepository.findOne(outputDatasetId);\n\t\t\tDataset dataset = datasetRepository.findOne(datasetId);\n\t\t\tDatasetLog datasetLog = new DatasetLog(dataset, plotUrl, dataUrl, originalDataset, outputDataset);\n\t\t\tDatasetLog saveddatasetLog = datasetLogRepository.save(datasetLog);\n\t\t\tSystem.out.println(\"DatasetLog saved: \"+ saveddatasetLog.getId());\n\t\t\treturn created(new Gson().toJson(datasetLog.getId()));\n\t\t} catch (PersistenceException pe) {\n\t\t\tpe.printStackTrace();\n\t\t\tSystem.out.println(\"DatasetLog not created\");\n\t\t\treturn badRequest(\"DatasetLog Configuration not created\");\n\t\t}\n    \t\n\t}\n\t\n    public Result updateDatasetLogById(long id) {\n\t    JsonNode json = request().body().asJson();\n\t\tif (json == null) {\n\t\t\tSystem.out.println(\"DatasetLog not saved, expecting Json data\");\n\t\t\treturn badRequest(\"DatasetLog Configuration not saved, expecting Json data\");\n\t\t}\n\t\t\n    \tString plotUrl = json.findPath(\"plotUrl\").asText();\n    \tString dataUrl = json.findPath(\"dataUrl\").asText();\n    \tlong originalDatasetId = json.findPath(\"originalDatasetId\").asLong();\n    \tlong outputDatasetId = json.findPath(\"outputDatasetId\").asLong();\n    \tlong serviceExecutionLogId = json.findPath(\"serviceExecutionLogId\").asLong();\n    \tlong datasetId = json.findPath(\"datasetId\").asLong();\n\n\t\ttry {\n\t\t\tDataset originalDataset = datasetRepository.findOne(originalDatasetId);\n\t\t\tDataset outputDataset = datasetRepository.findOne(outputDatasetId);\n\t\t\tDataset dataset = datasetRepository.findOne(datasetId);\n\t\t\tDatasetLog datasetLog = datasetLogRepository.findOne(id);\n\t\t\tdatasetLog.setDataSet(dataset);\n\t\t\tdatasetLog.setDataUrl(dataUrl);\n\t\t\tdatasetLog.setOriginalDataset(originalDataset);\n\t\t\tdatasetLog.setOutputDataset(outputDataset);\n\t\t\tdatasetLog.setPlotUrl(plotUrl);\n\t\t\tDatasetLog savedDatasetLog = datasetLogRepository.save(datasetLog);\n\t\t\t\n\t\t\tSystem.out.println(\"DatasetLog updated: \"+ savedDatasetLog.getId());\n\t\t\treturn created(\"DatasetLog updated: \"+ savedDatasetLog.getId());\n\t\t} catch (PersistenceException pe) {\n\t\t\tpe.printStackTrace();\n\t\t\tSystem.out.println(\"DatasetLog not saved: \"+id);\n\t\t\treturn badRequest(\"DatasetLog not saved: \"+id);\n\t\t}\t\t\t\n    }\n\n\t\n    public Result deleteDatasetLog(long id) {\n    \tDatasetLog datasetLog = datasetLogRepository.findOne(id);\n    \tif (datasetLog == null) {\n    \t\tSystem.out.println(\"DatasetLog not found with id: \" + id);\n\t\t\treturn notFound(\"DatasetLog not found with id: \" + id);\n    \t}\n    \t\n    \tdatasetLogRepository.delete(datasetLog);\n    \tSystem.out.println(\"DatasetLog is deleted: \" + id);\n\t\treturn ok(\"DatasetLog is deleted: \" + id);\n    }\n    \n    public Result getDatasetLog(long id, String format) {\n    \tDatasetLog datasetLog = datasetLogRepository.findOne(id);\n    \tif (datasetLog == null) {\n    \t\tSystem.out.println(\"DatasetLog not found with name: \" + id);\n\t\t\treturn notFound(\"DatasetLog not found with name: \" + id);\n    \t}\n    \t\n    \tString result = new String();\n    \tif (format.equals(\"json\")) {\n    \t\tresult = new Gson().toJson(datasetLog);\n    \t}\n    \t\n    \treturn ok(result);\n    }\n\n    public Result getAllDatasetLogs(String format) {\n    \ttry {\n    \t\tIterable<DatasetLog>datasetLogs =  datasetLogRepository.findAll();\n    \t\tString result = new String();\n    \t\tresult = new Gson().toJson(datasetLogs);\n    \t\treturn ok(result);\n    \t} catch (Exception e) {\n    \t\treturn badRequest(\"DatasetLog not found\");\n    \t}\n    }\n\t\n}", "nt.res.Resources;\nimport android.graphics.Color;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.widget.Button;\n\npublic class MainActivity extends Activity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        \n        // colors.xml\u0082\u00a9\u0082\u00e7\u0090F\u0082\u00f0\u008e\u00e6\u0093\u00be\u0082\u00b5\u0082\u00c4, Button\u0082\u00cc\u0094w\u008ci\u0082\u00c9\u0083Z\u0083b\u0083g.\n        Resources res = getResources();\t// getResources\u0082\u00c5res\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        int red = res.getColor(R.color.red);\t// res.getColor\u0082\u00c5R.color.red\u0082\u00cc\u0090F\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        Button button1 = (Button)findViewById(R.id.button1);\t// button1\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        button1.setBackgroundColor(red);\t// setBackgroundColor\u0082\u00c5red\u0082\u00f0\u0083Z\u0083b\u0083g.\n        int green = res.getColor(R.color.green);\t// res.getColor\u0082\u00c5R.color.green\u0082\u00cc\u0090F\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        Button button2 = (Button)findViewById(R.id.button2);\t// button2\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        button2.setBackgroundColor(green);\t// setBackgroundColor\u0082\u00c5green\u0082\u00f0\u0083Z\u0083b\u0083g.\n        int blue = res.getColor(R.color.blue);\t// res.getColor\u0082\u00c5R.color.blue\u0082\u00cc\u0090F\u008f\u00ee\u0095\u00f1\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        Button button3 = (Button)findViewById(R.id.button3);\t// button3\u0082\u00f0\u008e\u00e6\u0093\u00be.\n        button3.setBackgroundColor(blue);\t// setBackgroundColor\u0082\u00c5blue\u0082\u00f0\u0083Z\u0083b\u0083g.       \n    }\n}\n", "05, 2011 IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *     IBM Corporation - initial API and implementation\n *******************************************************************************/\npackage org.eclipse.jdt.internal.corext.refactoring.scripting;\n\nimport java.util.Map;\n\nimport org.eclipse.core.runtime.CoreException;\n\nimport org.eclipse.ltk.core.refactoring.Refactoring;\nimport org.eclipse.ltk.core.refactoring.RefactoringDescriptor;\nimport org.eclipse.ltk.core.refactoring.RefactoringStatus;\n\nimport org.eclipse.jdt.core.refactoring.descriptors.JavaRefactoringDescriptor;\n\nimport org.eclipse.jdt.internal.core.refactoring.descriptors.RefactoringSignatureDescriptorFactory;\nimport org.eclipse.jdt.internal.corext.refactoring.JavaRefactoringArguments;\nimport org.eclipse.jdt.internal.corext.refactoring.generics.InferTypeArgumentsRefactoring;\n\n/**\n * Refactoring contribution for the infer typearguments refactoring.\n *\n * @since 3.2\n */\npublic final class InferTypeArgumentsRefactoringContribution extends JavaUIRefactoringContribution {\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\t@Override\n\tpublic final Refactoring createRefactoring(JavaRefactoringDescriptor descriptor, RefactoringStatus status) throws CoreException {\n\t\tJavaRefactoringArguments arguments= new JavaRefactoringArguments(descriptor.getProject(), retrieveArgumentMap(descriptor));\n\t\treturn new InferTypeArgumentsRefactoring(arguments, status);\n\t}\n\n\t@Override\n\tpublic RefactoringDescriptor createDescriptor() {\n\t\treturn RefactoringSignatureDescriptorFactory.createInferTypeArgumentsDescriptor();\n\t}\n\n\t@Override\n\tpublic RefactoringDescriptor createDescriptor(String id, String project, String description, String comment, Map arguments, int flags) {\n\t\treturn RefactoringSignatureDescriptorFactory.createInferTypeArgumentsDescriptor(project, description, comment, arguments, flags);\n\t}\n}\n", "ation.EntityInformation;\nimport com.mygdx.game.utils.Assets;\n\npublic class BasicLaserTurret extends EntityInformation {\n\t\n\tpublic BasicLaserTurret() {\n\t\tsetDamage(20d);\n\t\tsetFireRate(1.5d);\n\t\tsetRange(150d);\n\t\tsetAnimationStateData(Assets.laserTowerAnimationState.getData());\n\t\tsetSkeleton(Assets.laserTowerSkeleton);\n\t\tsetCost(30d);\n\t\tsetMaxTargets(1);\n\t\tsetDescription(\"The Laser Turret fires quickly but with low damage.\\n\\nCan only fire at ground targets.\");\n\t\tsetName(\"Laser Turret\");\n\t\tsetOffsetX(0);\n\t\tsetOffsetY(0);\n\t}\n}\n", "port java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Random;\n\npublic class PermutationsAlternative {\n  // @include\n  public static List<List<Integer>> permutations(List<Integer> A) {\n    List<List<Integer>> result = new ArrayList<>();\n    directedPermutations(0, A, result);\n    return result;\n  }\n\n  private static void directedPermutations(int i, List<Integer> A,\n                                           List<List<Integer>> result) {\n    if (i == A.size() - 1) {\n      result.add(new ArrayList<>(A));\n      return;\n    }\n\n    // Try every possibility for A[i].\n    for (int j = i; j < A.size(); ++j) {\n      Collections.swap(A, i, j);\n      // Generate all permutations for A.subList(i + 1, A.size()).\n      directedPermutations(i + 1, A, result);\n      Collections.swap(A, i, j);\n    }\n  }\n  // @exclude\n\n  private static void smallTest() {\n    List<Integer> A = Arrays.asList(0, 1, 2);\n    List<List<Integer>> result = permutations(A);\n    assert(result.size() == 6);\n    List<List<Integer>> goldenResult = Arrays.asList(\n        Arrays.asList(0, 1, 2), Arrays.asList(0, 2, 1), Arrays.asList(1, 0, 2),\n        Arrays.asList(1, 2, 0), Arrays.asList(2, 1, 0), Arrays.asList(2, 0, 1));\n    assert(result.equals(goldenResult));\n  }\n\n  public static void main(String[] args) {\n    smallTest();\n    Random r = new Random();\n    int n;\n    if (args.length == 1) {\n      n = Integer.parseInt(args[0]);\n    } else {\n      n = r.nextInt(8) + 1;\n    }\n    List<Integer> A = new ArrayList<>(n);\n    int val = 0;\n    for (int i = 0; i < n; i++) {\n      A.add(val++);\n    }\n    List<List<Integer>> result = permutations(A);\n    System.out.println(\"n = \" + n);\n    for (List<Integer> vec : result) {\n      System.out.println(vec);\n    }\n  }\n}\n", "  TEXT, XML, JSON\n}\n", " = age;\n\t}\n\n\tpublic int compareTo(Person other)\n\t{\n\t\treturn this.age - other.age;\n\t}\n\n\tpublic String toString()\n\t{\n\t\treturn String.format(\"Person(%d)\", age);\n\t}\n}", "sc.config.Configs;\nimport com.thexfactor117.lsc.util.misc.Reference;\n\nimport net.minecraft.client.Minecraft;\nimport net.minecraft.client.gui.Gui;\nimport net.minecraft.client.gui.ScaledResolution;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.util.ResourceLocation;\nimport net.minecraftforge.client.GuiIngameForge;\nimport net.minecraftforge.client.event.RenderGameOverlayEvent;\nimport net.minecraftforge.client.event.RenderGameOverlayEvent.ElementType;\nimport net.minecraftforge.fml.common.eventhandler.SubscribeEvent;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\n\n/**\n * \n * @author TheXFactor117\n *\n */\n@SideOnly(Side.CLIENT)\npublic class GuiHealth extends Gui\n{\n\tprivate static ResourceLocation location = new ResourceLocation(Reference.MODID, \"textures/gui/mana.png\");\n\tprivate Minecraft mc = Minecraft.getMinecraft();\n\t\n\tpublic GuiHealth()\n\t{\n\t\tsuper();\n\t}\n\t\n\t@SubscribeEvent\n\tpublic void onRenderOverlay(RenderGameOverlayEvent.Pre event)\n\t{\t\n\t\tif (Configs.renderingCategory.renderCustomHealthbar)\n\t\t{\n\t\t\tif (event.getType() == ElementType.HEALTH)\n\t\t\t{\n\t\t\t\tevent.setCanceled(true);\n\t\t\t}\n\t\t\t\n\t\t\t/*\n\t\t\t * Repositions other Gui elements. \n\t\t\t */\n\t\t\t\n\t\t\tif (event.getType() == ElementType.ARMOR)\n\t\t\t{\n\t\t\t\tevent.setCanceled(true);\n\t\t\t\t//GuiIngameForge.left_height = 49;\n\t\t\t}\n\t\t\t\n\t\t\tif (event.getType() == ElementType.FOOD)\n\t\t\t{\n\t\t\t\tGuiIngameForge.right_height = 49;\n\t\t\t}\n\t\t\t\n\t\t\tif (event.getType() == ElementType.AIR)\n\t\t\t{\n\t\t\t\tGuiIngameForge.right_height = 59;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@SubscribeEvent\n\tpublic void onRenderOverlay(RenderGameOverlayEvent.Post event)\n\t{\t\n\t\tif (Configs.renderingCategory.renderCustomHealthbar)\n\t\t{\n\t\t\tif (event.getType() != ElementType.EXPERIENCE) return;\n\t\t\telse\n\t\t\t{\t\n\t\t\t\tScaledResolution sr = event.getResolution();\n\t\t\t\tEntityPlayer player = Minecraft.getMinecraft().player;\n\t\t\t\t\n\t\t\t\tif (!player.capabilities.isCreativeMode)\n\t\t\t\t{\n\t\t\t\t\tdouble healthBarWidth = (double) player.getHealth() / player.getMaxHealth() * 81.0;\n\t\t\t\t\tint xPos = sr.getScaledWidth() / 2 - 91;\n\t\t\t\t\tint yPos = sr.getScaledHeight() - 39;\n\t\t\t\t\t\n\t\t\t\t\tmc.renderEngine.bindTexture(location);\n\t\t\t\t\t\n\t\t\t\t\tthis.drawTexturedModalRect(xPos, yPos, 0, 0, 81, 9);\n\t\t\t\t\tthis.drawTexturedModalRect(xPos, yPos, 0, 9, (int) healthBarWidth, 8);\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@SubscribeEvent\n\tpublic void onRenderOverlayText(RenderGameOverlayEvent.Text event)\n\t{\n\t\tif (Configs.renderingCategory.renderCustomHealthbar)\n\t\t{\n\t\t\tScaledResolution sr = event.getResolution();\n\t\t\tEntityPlayer player = Minecraft.getMinecraft().player;\n\t\t\t\n\t\t\tif (!player.capabilities.isCreativeMode)\n\t\t\t{\n\t\t\t\tString health = (int) player.getHealth() + \" / \" + (int) player.getMaxHealth();\n\t\t\t\t\n\t\t\t\tGL11.glPushMatrix();\n\t\t\t\tGL11.glScalef(0.5F, 0.5F, 0.5F);\n\t\t\t\tMinecraft.getMinecraft().fontRenderer.drawStringWithShadow(health, (sr.getScaledWidth() / 2 - 60) * 2, (sr.getScaledHeight() - 36) * 2, 0xFFFFFF);\n\t\t\t\tGL11.glPopMatrix();\n\t\t\t}\n\t\t}\n\t}\n}\n", "reated with Android Studio.\n * User: ryan@xisue.com\n * Date: 10/3/14\n * Time: 11:12 AM\n * Desc: CropParams\n * Revision:\n * - 11:00 2014/10/03 Encapsulate the crop params.\n * - 13:20 2014/10/03 Put the initialization into constructor method.\n * - 14:00 2014/10/03 Make the crop as String instead of Boolean.\n * - 14:30 2014/10/03 Increase the default output size from 200 to 300.\n * - 12:20 2014/10/04 Add \"scaleUpIfNeeded\" crop options for scaling up cropped images if the size is too small.\n */\npublic class CropParams {\n\n    public static final String CROP_TYPE = \"image/*\";//ACTION_GET_CONTENT\u7684\u7c7b\u578b\n    public static final String OUTPUT_FORMAT = Bitmap.CompressFormat.JPEG.toString();\n\n    public static final int DEFAULT_ASPECT = 1;\n    public static final int DEFAULT_OUTPUT = 800;//\u56fe\u7247\u5206\u8fa8\u7387\n\n    public Uri uri;\n\n    public String type;\n    public String outputFormat;\n    public String crop;\n\n    public boolean scale;\n    public boolean returnData;\n    public boolean noFaceDetection;\n    public boolean scaleUpIfNeeded;\n\n    public int aspectX;\n    public int aspectY;\n\n    public int outputX;\n    public int outputY;\n    \n    public CropParams() {\n        uri = CropHelper.buildUri();\n        type = CROP_TYPE;\n        outputFormat = OUTPUT_FORMAT;\n        crop = \"true\";\n        scale = true;\n        returnData = false;\n        noFaceDetection = true;\n        scaleUpIfNeeded = true;\n        aspectX = DEFAULT_ASPECT;\n        aspectY = DEFAULT_ASPECT;\n        outputX = DEFAULT_OUTPUT;\n        outputY = DEFAULT_OUTPUT;\n    }\n}\n", "AssociationMultiplicity {\n\t\n\tprivate int mMinMultiplicity;\n\tprivate int mMaxMultiplicity;\n\tprivate String mMultiplicity;\n\t\n\tpublic AssociationMultiplicity(String multiplicity){\n\t\tthis.mMultiplicity = multiplicity;\n\t\t\n\t\tswitch(mMultiplicity){\n\t\t\tcase IAssociationEnd.MULTIPLICITY_ONE:\n\t\t\tcase IAssociationEnd.MULTIPLICITY_UNSPECIFIED:\n\t\t\t\tthis.mMinMultiplicity = 1;\n\t\t\t\tthis.mMaxMultiplicity = 1;\n\t\t\t\tbreak;\n\t\t\tcase IAssociationEnd.MULTIPLICITY_ONE_TO_MANY:\n\t\t\t\tthis.mMinMultiplicity = 1;\n\t\t\t\tthis.mMaxMultiplicity = -1;\n\t\t\t\tbreak;\n\t\t\tcase IAssociationEnd.MULTIPLICITY_ZERO_TO_MANY:\n\t\t\t\tthis.mMinMultiplicity = 0;\n\t\t\t\tthis.mMaxMultiplicity = -1;\n\t\t\t\tbreak;\n\t\t\tcase IAssociationEnd.MULTIPLICITY_ZERO_TO_ONE:\n\t\t\t\tthis.mMinMultiplicity = 0;\n\t\t\t\tthis.mMaxMultiplicity = 1;\n\t\t\t\tbreak;\n\t\t\tcase IAssociationEnd.MULTIPLICITY_MANY:\n\t\t\t\tthis.mMinMultiplicity = -1;\n\t\t\t\tthis.mMaxMultiplicity = -1;\n\t\t\tdefault:\n\t\t\t\tString[] multStr = multiplicity.split(\"[.]+\");\n\t\t\t\tthis.mMinMultiplicity = multStr[0].equals(\"*\") ? \n\t\t\t\t\t\t\t\t\t\t\t-1 : \n\t\t\t\t\t\t\t\t\t\t\tInteger.valueOf(multStr[0]);\n\t\t\t\tthis.mMaxMultiplicity = multStr.length == 2 ?\n\t\t\t\t\t\t\t\t\t\t(multStr[1].equals(\"*\") ? \n\t\t\t\t\t\t\t\t\t\t\t-1 : \n\t\t\t\t\t\t\t\t\t\t\tInteger.valueOf(multStr[1])) :\n\t\t\t\t\t\t\t\t\t\t(multStr[0].equals(\"*\") ? \n\t\t\t\t\t\t\t\t\t\t\t-1 : \n\t\t\t\t\t\t\t\t\t\t\tInteger.valueOf(multStr[0]));\t\t\n\t\t\t\t\n\t\t}\n\t\t\n\t}\n\t\n\tpublic AssociationMultiplicity(int min, int max){\n\t\tthis.mMinMultiplicity = min;\n\t\tthis.mMaxMultiplicity = max;\n\t\tthis.mMultiplicity = buildMultiplicityString(min, max);\n\t}\n\t\n\tprivate static String buildMultiplicityString(int min, int max){\n\t\tif(min != max){\n\t\t\treturn min + \"..\" + (max == -1 ? \"*\" : max);\n\t\t}\n\t\treturn min == -1 ? \"*\" : Integer.toString(min);\n\t}\n\t\n\tpublic int getMinMultiplicity(){\n\t\treturn mMinMultiplicity;\n\t}\n\t\n\tpublic int getMaxMultiplicity(){\n\t\treturn mMaxMultiplicity;\n\t}\n\t\n\tpublic String getMultiplicityString(){\n\t\treturn mMultiplicity;\n\t}\n\n}", "java.util.Map;\nimport java.util.Set;\n\nimport org.apache.commons.logging.Log;\nimport org.apache.commons.logging.LogFactory;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.cfg.NamingStrategy;\nimport org.hibernate.util.StringHelper;\n\n/**\n * \n * @author daniel.joppi\n *\n */\npublic class SafeNamingStrategy implements NamingStrategy {\n\n\t@SuppressWarnings(\"unused\")\n\tprivate static final Log logger = LogFactory.getLog(SafeNamingStrategy.class);\n\n\tpublic static final SafeNamingStrategy INSTANCE = new SafeNamingStrategy();\n\n\t/**\n\t * Return a table name for an entity class\n\t * \n\t * @param className the fully-qualified class name\n\t * @return a table name\n\t */\n\tpublic String classToTableName(String className) {\n\t\treturn safeName(StringHelper.unqualify(className));\n\t}\n\n\t/**\n\t * Return a column name for a property path expression\n\t * \n\t * @param propertyName a property path\n\t * @return a column name\n\t */\n\tpublic String propertyToColumnName(String propertyName) {\n\t\treturn safeName(StringHelper.unqualify(propertyName));\n\t}\n\n\t/**\n\t * Alter the table name given in the mapping document\n\t * \n\t * @param tableName a table name\n\t * @return a table name\n\t */\n\tpublic String tableName(String tableName) {\n\t\treturn safeName(StringHelper.unqualify(tableName));\n\t}\n\n\t/**\n\t * Alter the column name given in the mapping document\n\t * \n\t * @param columnName a column name\n\t * @return a column name\n\t */\n\tpublic String columnName(String columnName) {\n\t\treturn safeName(StringHelper.unqualify(columnName));\n\t}\n\n\t// FIXME Isso n\u00e3o deve ser static! Verificar como obter o NamingStrategy a partir do Configuration\n\tprivate static Map<String, String> oldTableMap = new HashMap<String, String>();\n\n\tpublic static Map<String, String> getOldTableMap() {\n\t\treturn oldTableMap;\n\t}\n\n\tpublic static String getOldTableName(String newTableName) {\n\t\treturn oldTableMap.get(newTableName);\n\t}\n\n\t/**\n\t * Return a collection table name ie an association having a join table\n\t * \n\t * @param ownerEntity\n\t * @param ownerEntityTable owner side table name\n\t * @param associatedEntity\n\t * @param associatedEntityTable reverse side table name if any\n\t * @param propertyName collection role\n\t */\n\tpublic String collectionTableName(String ownerEntity, String ownerEntityTable, String associatedEntity, String associatedEntityTable, String propertyName) {\n\t\tString unsafeName = new StringBuilder(ownerEntityTable).append(\"_\").append(\n\t\t\t\tassociatedEntityTable != null ? associatedEntityTable : StringHelper.unqualify(propertyName)).toString();\n\t\tString safeName = tableName(new StringBuilder(ownerEntityTable).append(\"_\").append(StringHelper.unqualify(propertyName)).toString());\n\n\t\tif (!safeName.equals(unsafeName))\n\t\t\toldTableMap.put(safeName, unsafeName);\n\n\t\treturn safeName;\n\t}\n\n\t/**\n\t * Return the join key column name ie a FK column used in a JOINED strategy\n\t * or for a secondary table\n\t * \n\t * @param joinedColumn joined column name (logical one) used to join with\n\t * @param joinedTable joined table name (ie the referenced table) used to join with\n\t */\n\tpublic String joinKeyColumnName(String joinedColumn, String joinedTable) {\n\t\treturn columnName(joinedColumn);\n\t}\n\n\t/**\n\t * Return the foreign key column name for the given parameters\n\t * \n\t * @param propertyName the property name involved\n\t * @param propertyEntityName\n\t * @param propertyTableName the property table name involved (logical one)\n\t * @param referencedColumnName the referenced column name involved (logical one)\n\t */\n\tpublic String foreignKeyColumnName(String propertyName, String propertyEntityName, String propertyTableName, String referencedColumnName) {\n\t\tString header = propertyName != null ? StringHelper.unqualify(propertyName) : propertyTableName;\n\t\tif (header == null)\n\t\t\tthrow new AssertionFailure(\"NamingStrategy not properly filled\");\n\t\treturn columnName(header + \"_\" + referencedColumnName);\n\t}\n\n\t/**\n\t * Return the logical column name used to refer to a column in the metadata\n\t * (like index, unique constraints etc) A full bijection is required between\n\t * logicalNames and physical ones logicalName have to be case insersitively\n\t * unique for a given table\n\t * \n\t * @param columnName given column name if any\n\t * @param propertyName property name of this column\n\t */\n\tpublic String logicalColumnName(String columnName, String propertyName) {\n\t\treturn StringHelper.isNotEmpty(columnName) ? columnName : StringHelper.unqualify(propertyName);\n\t}\n\n\t/**\n\t * Returns the logical collection table name used to refer to a table in the\n\t * mapping metadata\n\t * \n\t * @param tableName the metadata explicit name\n\t * @param ownerEntityTable owner table entity table name (logical one)\n\t * @param associatedEntityTable reverse side table name if any (logical one)\n\t * @param propertyName collection role\n\t */\n\tpublic String logicalCollectionTableName(String tableName, String ownerEntityTable, String associatedEntityTable, String propertyName) {\n\t\tif (tableName != null) {\n\t\t\treturn tableName;\n\t\t} else {\n\t\t\t// use of a stringbuffer to workaround a JDK bug\n\t\t\treturn safeName(new StringBuffer(ownerEntityTable).append(\"_\").append(associatedEntityTable != null ? associatedEntityTable : StringHelper.unqualify(propertyName)).toString());\n\t\t}\n\t}\n\n\t/**\n\t * Returns the logical foreign key column name used to refer to this column\n\t * in the mapping metadata\n\t * \n\t * @param columnName given column name in the metadata if any\n\t * @param propertyName property name\n\t * @param referencedColumn referenced column name (logical one) in the join\n\t */\n\tpublic String logicalCollectionColumnName(String columnName, String propertyName, String referencedColumn) {\n\t\treturn StringHelper.isNotEmpty(columnName) ? columnName : safeName(StringHelper.unqualify(propertyName) + \"_\" + referencedColumn);\n\t}\n\n\tprivate static final Set<String> keywordSet = new HashSet<String>();\n\tstatic {\n\t\tkeywordSet.add(\"date\");\n\t\tkeywordSet.add(\"time\");\n\t\tkeywordSet.add(\"level\");\n\t\tkeywordSet.add(\"order\");\n\t\tkeywordSet.add(\"key\");\n\t\tkeywordSet.add(\"asc\");\n\t\tkeywordSet.add(\"read\");\n\t\tkeywordSet.add(\"join\");\n\t\tkeywordSet.add(\"left\");\n\t\tkeywordSet.add(\"inner\");\n\t\tkeywordSet.add(\"outer\");\n\t\tkeywordSet.add(\"full\");\n\t\tkeywordSet.add(\"outer\");\n\t\tkeywordSet.add(\"select\");\n\t\tkeywordSet.add(\"update\");\n\t\tkeywordSet.add(\"insert\");\n\t\tkeywordSet.add(\"option\");\n\t\tkeywordSet.add(\"trigger\");\n\t\tkeywordSet.add(\"unique\");\n\t\t// Enable this just for oracle\n\t\t// keywordSet.add(\"scale\");\n\t\t// keywordSet.add(\"size\");\n\t}\n\n\tprotected Set<String> getKeywordSet() {\n\t\treturn keywordSet;\n\t}\n\n\tprivate final static int MAX_TABLE_NAME = 54;\n\n\tprotected int getMaxTableName() {\n\t\treturn MAX_TABLE_NAME;\n\t}\n\n\tprivate final static String VOWELS = \"aeiou_\";\n\n\tpublic final String safeName(String code) {\n\t\tcode = code.replace('.', '_');\n\t\tif (code.startsWith(\"_\"))\n\t\t\tcode = \"n\" + code;\n\t\telse if (getKeywordSet().contains(code.toLowerCase()))\n\t\t\tcode = \"n\" + code;\n\n\t\t// Remove vowels\n\t\tif (code.length() > getMaxTableName())\n\t\t\tcode = cleanVowels(code);\n\n\t\t// Compress\n\t\tif (code.length() > getMaxTableName())\n\t\t\tcode = compress(code);\n\n\t\treturn code;\n\t}\n\n\tprivate static String cleanVowels(String code) {\n\t\tStringBuffer bufferCode = new StringBuffer(30);\n\t\tint hash = 0x4242;\n\t\tchar c[] = code.toCharArray();\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\tint vPos = VOWELS.indexOf(c[i]);\n\t\t\tif (i > 0 && vPos != -1 && (i > 1 || c[i] != '_')) {\n\t\t\t\thash ^= ((hash << vPos) ^ (hash >> i)) + c[i];\n\t\t\t} else {\n\t\t\t\tbufferCode.append(c[i]);\n\t\t\t}\n\t\t}\n\t\thash = hash & 0xffff;\n\t\treturn bufferCode.append(Integer.toHexString(hash)).toString();\n\t}\n\n\tprivate static String compress(String code) {\n\t\tint hash = 0x42424242;\n\t\tchar c[] = code.substring(20).toCharArray();\n\t\tfor (int i = 0; i < c.length; i++) {\n\t\t\thash ^= ((hash << 5) + ~hash) ^ (c[i] << i) + c[i];\n\t\t}\n\t\tString num = Integer.toHexString(hash & 0xffffffff);\n\t\treturn code.substring(0, 20) + num;\n\t}\n}", "idGCF myGCF = new EuclidGCF();\n\tSystem.out.println(myGCF.gcfParish(350, 452));\n\t}\n}\n", "import java.io.OutputStream;\n\nimport javax.servlet.ServletResponse;\nimport javax.servlet.http.HttpServletResponse;\n\nimport com.otogami.web.InstanceFactory;\nimport com.otogami.web.JsonRenderer;\nimport com.otogami.web.view.DirectWrite;\nimport com.otogami.web.view.TemplateView;\n\npublic class ResultDispatcher implements ResultVisitor {\n\n\tprivate InstanceFactory injector;\n\tprivate HttpServletResponse response;\n\n\tpublic ResultDispatcher(InstanceFactory injector, ServletResponse response){\n\t\tthis.injector=injector;\n\t\tthis.response=(HttpServletResponse) response;\n\t}\n\n\t@Override\n\tpublic void visit(Ok result) throws IOException{\n\t\tresponse.setContentType(\"text/html\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\tif (result.getStatus()!=null){\n\t\t\tresponse.setStatus(result.getStatus());\n\t\t}\n\t\tTemplateView templateView=injector.getInstance(TemplateView.class);\n\t\ttemplateView.render(result.getModelAndView(),response.getWriter());\n\t}\n\n\t@Override\n\tpublic void visit(OKJson result) throws IOException{\n\t\tresponse.setContentType(\"application/json\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\tif (result.getStatus()!=null){\n\t\t\tresponse.setStatus(result.getStatus());\n\t\t}\n\t\tJsonRenderer renderer = injector.getInstance(JsonRenderer.class);\n\t\trenderer.writeTo(result.getModel(), response.getOutputStream());\n\t}\n\n\t@Override\n\tpublic void visit(OKJsonp result) throws IOException{\n\t\tresponse.setContentType(\"text/javascript\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\tif (result.getStatus()!=null){\n\t\t\tresponse.setStatus(result.getStatus());\n\t\t}\n\t\tOutputStream os=response.getOutputStream();\n\t\tByteArrayOutputStream baos=new ByteArrayOutputStream();\n\t\tos.write((result.getCallback()+\"(\").getBytes());\n\t\tJsonRenderer renderer = injector.getInstance(JsonRenderer.class);\n\t\trenderer.writeTo(result.getModel(), baos);\n\t\tos.write(baos.toByteArray());\n\t\tos.write(\")\".getBytes());\n\t}\n\n\t@Override\n\tpublic void visit(OkWithContent result) throws IOException{\n\t\tresponse.setContentType(\"text/html\");\n\t\tresponse.setCharacterEncoding(\"UTF-8\");\n\t\tDirectWrite.process(result, response);\n\t}\n\n\t@Override\n\tpublic void visit(OkWithBinary result) throws IOException{\n\t\tDirectWrite.process(result, response);\n\t}\n\n\t@Override\n\tpublic void visit(OkWithInputStream result) throws IOException{\n\t\tDirectWrite.process(result, response);\n\t}\n\n\t@Override\n\tpublic void visit(Redirect result) throws IOException{\n\t\tDirectWrite.process(result, response);\n\t}\n\n}\n", "t;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\nimport static org.testng.Assert.assertEquals;\nimport static org.testng.Assert.assertTrue;\nimport static org.testng.Assert.fail;\n\n\n/**\n * Project: Maxifier\n * Date: 09.11.2009\n * Time: 11:45:15\n * <p/>\n * Copyright (c) 1999-2009 Magenta Corporation Ltd. All Rights Reserved.\n * Magenta Technology proprietary and confidential.\n * Use is subject to license terms.\n *\n * @author Aleksey Didik\n */\npublic class DecoratorTest {\n\n    @Test\n    public void testFullWrapper() {\n        Module module = new AbstractModule() {\n            @Override\n            protected void configure() {\n\n                bind(Service.class).to(GoogleService.class);\n\n                new Decorator(binder())\n                        .bind(HelloService.class)\n                        .to(WowDecorator.class)\n                        .decorate(ServiceDecorator.class)\n                        .decorate(HelloRealization.class);\n            }\n        };\n\n        Injector injector = Guice.createInjector(module);\n        final HelloService helloService = injector.getInstance(HelloService.class);\n        final String testResult = helloService.hello();\n        final String waited = HelloRealization.HELLO + GoogleService.NAME + WowDecorator.WOW;\n        assertEquals(testResult, waited);\n    }\n\n    @Test\n    public void testWithoutDecoration() {\n        Module module = new AbstractModule() {\n            @Override\n            protected void configure() {\n                new Decorator(binder())\n                        .bind(HelloService.class)\n                        .to(HelloRealization.class);\n            }\n        };\n\n        Injector injector = Guice.createInjector(module);\n        final HelloService helloService = injector.getInstance(HelloService.class);\n        final String testResult = helloService.hello();\n        final String waited = HelloRealization.HELLO;\n        assertEquals(testResult, waited);\n    }\n\n    @Test\n    public void testEqualBindAndTo() {\n        try {\n            Guice.createInjector(Stage.TOOL, new AbstractModule() {\n                @Override\n                protected void configure() {\n                    new Decorator(binder())\n                            .bind(HelloService.class)\n                            .to(HelloService.class);\n                }\n            });\n            fail(\"CreationException with DuplicateMemberException should be here\");\n        } catch (CreationException e) {\n            assertTrue(e.getCause() instanceof DuplicateMemberException);\n        }\n    }\n\n    @Test\n    public void testEqualToAndDecorated() {\n        try {\n            Guice.createInjector(Stage.TOOL, new AbstractModule() {\n                @Override\n                protected void configure() {\n                    new Decorator(binder())\n                            .bind(HelloService.class)\n                            .to(HelloRealization.class)\n                            .decorate(ServiceDecorator.class)\n                            .decorate(HelloRealization.class);\n                }\n            });\n            fail(\"CreationException with DuplicateMemberException should be here\");\n        } catch (CreationException e) {\n            assertTrue(e.getCause() instanceof DuplicateMemberException);\n        }\n    }\n\n    @Test\n    public void testWithAnnotation() {\n        Module module = new AbstractModule() {\n            @Override\n            protected void configure() {\n\n                bind(Service.class).to(GoogleService.class);\n\n                new Decorator(binder())\n                        .bind(HelloService.class)\n                        .annotatedWith(TestAnnotation.class)\n                        .to(WowDecorator.class)\n                        .decorate(ServiceDecorator.class)\n                        .decorate(HelloRealization.class);\n            }\n        };\n\n        Injector inj = Guice.createInjector(module);\n        final HelloService helloService = inj.getInstance(Key.get(HelloService.class, TestAnnotation.class));\n        final String testResult = helloService.hello();\n        final String waited = HelloRealization.HELLO + GoogleService.NAME + WowDecorator.WOW;\n        assertEquals(testResult, waited);\n    }\n\n    @Test\n    public void testDecorateInstance() {\n        Module module = new AbstractModule() {\n            @Override\n            protected void configure() {\n\n                bind(Service.class).to(GoogleService.class);\n\n                new Decorator(binder())\n                        .bind(HelloService.class)\n                        .annotatedWith(TestAnnotation.class)\n                        .to(WowDecorator.class)\n                        .decorate(ServiceDecorator.class)\n                        .decorate(new HelloRealization());\n            }\n        };\n\n        Injector inj = Guice.createInjector(module);\n        final HelloService helloService = inj.getInstance(Key.get(HelloService.class, TestAnnotation.class));\n        final String testResult = helloService.hello();\n        final String waited = HelloRealization.HELLO + GoogleService.NAME + WowDecorator.WOW;\n        assertEquals(testResult, waited);\n    }\n\n    static boolean eagerFlag = false;\n\n    @Test\n    public void testEagerSingleton() {\n        eagerFlag = false;\n        Module module = new AbstractModule() {\n            @Override\n            protected void configure() {\n\n                bind(Service.class).to(GoogleService.class);\n\n                new Decorator(binder())\n                        .bind(HelloService.class)\n                        .asEagerSingleton()\n                        .to(EagerService.class);\n            }\n        };\n\n        Guice.createInjector(module);\n        assertTrue(eagerFlag);\n        eagerFlag = false;\n    }\n\n    static class EagerService implements HelloService {\n\n        EagerService() {\n            DecoratorTest.eagerFlag = true;\n        }\n\n        @Override\n        public String hello() {\n            return \"eager\";\n        }\n    }\n\n\n    @Test\n    public void testSingletonScope() {\n        Module module = new AbstractModule() {\n            @Override\n            protected void configure() {\n\n                bind(Service.class).to(GoogleService.class);\n\n                new Decorator(binder())\n                        .bind(HelloService.class)\n                        .in(Scopes.SINGLETON)\n                        .to(SingletonService.class);\n            }\n        };\n\n        Injector inj = Guice.createInjector(module);\n        HelloService hs1 = inj.getInstance(HelloService.class);\n        HelloService hs2 = inj.getInstance(HelloService.class);\n        assertEquals(hs1, hs2);\n    }\n\n    static class SingletonService implements HelloService {\n\n        @Override\n        public String hello() {\n            return \"singleton\";\n        }\n    }\n\n\n    interface Service {\n        String serviceName();\n    }\n\n    static class GoogleService implements Service {\n\n        public static final String NAME = \"Google\";\n\n\n        public String serviceName() {\n            return NAME;\n        }\n    }\n\n    @Retention(RetentionPolicy.RUNTIME)\n    @Target({ElementType.METHOD, ElementType.PARAMETER, ElementType.FIELD})\n    @BindingAnnotation\n    @interface TestAnnotation {\n    }\n\n    static class HelloRealization implements HelloService {\n\n        public static final String HELLO = \"Hello \";\n\n        public String hello() {\n            return HELLO;\n        }\n    }\n\n    static interface HelloService {\n\n        String hello();\n    }\n\n    static class ServiceDecorator implements HelloService {\n\n        private HelloService decorated;\n        private final Service justService;\n\n        @Inject\n        public ServiceDecorator(@Decorated HelloService decorated, Service justService) {\n            this.decorated = decorated;\n            this.justService = justService;\n        }\n\n        public String hello() {\n            return decorated.hello() + justService.serviceName();\n        }\n    }\n\n    static class WowDecorator implements HelloService {\n\n        private HelloService decorated;\n        public static final String WOW = \"!\";\n\n        @Inject\n        public WowDecorator(@Decorated HelloService decorated) {\n            this.decorated = decorated;\n        }\n\n        public String hello() {\n            return decorated.hello() + WOW;\n        }\n    }\n}\n\n", "ditor;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class RotateMapAction implements Action {\n\n\tprivate static Logger log = LogManager.getLogger(RotateMapAction.class);\n\n\tprivate MapEditor map;\n\n\tpublic RotateMapAction(final MapEditor map) {\n\t\tthis.map = map;\n\t}\n\n\t@Override\n\tpublic void execute() {\n\t\tlog.debug(\"Redoing rotation of map '\" + map + \"'.\");\n\t\tmap.rotateMapClockwise();\n\t}\n\n\t@Override\n\tpublic void undo() {\n\t\tlog.debug(\"Undoing rotation of map '\" + map + \"'.\");\n\t\tmap.rotateMapClockwise();\n\t\tmap.rotateMapClockwise();\n\t\tmap.rotateMapClockwise();\n\t}\n\n}\n", "List;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport io.linuxserver.davos.transfer.ftp.FTPFile;\n\npublic class ReferentialFileFilter implements FileFilter {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ReferentialFileFilter.class);\n\n    private List<String> filesToCompareWith = new ArrayList<>();\n\n    public ReferentialFileFilter(List<String> files) {\n        filesToCompareWith = files;\n    }\n\n    @Override\n    public List<FTPFile> filter(List<FTPFile> allFiles) {\n\n        if (filesToCompareWith.isEmpty()) {\n            LOGGER.debug(\"No files in last scan. Using all files in this scan for filtering\");\n            return allFiles;\n        }\n\n        LOGGER.debug(\"Files in last scan {}\", filesToCompareWith);\n        LOGGER.debug(\"Files in this scan {}\", allFiles.stream().map(f -> f.getName()).collect(toList()));\n        \n        LOGGER.debug(\"Checking this scan for new files - comparing with files from last scan\");\n        List<FTPFile> collectedFiles = allFiles.stream().filter(f -> !filesToCompareWith.contains(f.getName())).collect(toList());\n        LOGGER.debug(\"New files {}\", collectedFiles.stream().map(f -> f.getName()).collect(toList()));\n        \n        return collectedFiles;\n    }\n}\n", "rce.local.TwitchLocalDataSource;\nimport com.home.rxtwitch.data.twitch.TwitchServiceImpl;\nimport com.home.rxtwitch.ui.widget.EmoticonHandler;\nimport com.home.rxtwitch.util.ObservableUtil;\nimport com.home.rxtwitch.util.TwitchOauthUtil;\nimport com.home.rxtwitch.util.db.Emoticon;\n\nimport java.util.List;\n\nimport javax.inject.Inject;\n\nimport rx.Subscription;\nimport rx.subscriptions.CompositeSubscription;\n\n/**\n * Created by xmax on 6/18/16.\n */\n\nfinal class CommonEmoticonPresenter implements CommonEmoticonContract.Presenter{\n\n    private static final String TAG = CommonEmoticonPresenter.class.getName();\n    private final TwitchOauthUtil mTwitchOauthUtil;\n    private final TwitchServiceImpl mTwitchService;\n    private final TwitchLocalDataSource mTwitchLocalDataSource;\n    private final CommonEmoticonContract.View mCEView;\n\n    private CompositeSubscription mSubscriptions;\n    @Inject\n    CommonEmoticonPresenter(TwitchOauthUtil twitchOauthUtil,\n                            TwitchServiceImpl twitchService,\n                            TwitchLocalDataSource twitchLocalDataSource,\n                            CommonEmoticonContract.View cEView) {\n        this.mTwitchOauthUtil = twitchOauthUtil;\n        this.mTwitchService = twitchService;\n        this.mTwitchLocalDataSource = twitchLocalDataSource;\n        this.mCEView = cEView;\n        mSubscriptions = new CompositeSubscription();\n    }\n\n    @Inject\n    void setupListener() {\n        mCEView.setPresenter(this);\n    }\n\n    @Override\n    public void subscribe() {\n        loadAllEmoticons();\n    }\n\n    @Override\n    public void loadAllEmoticons() {\n        //fetch emoticons from db first, if not exist, fetch from internet.\n        if (mTwitchLocalDataSource.isEmoticonExist()) {\n            List<Emoticon> emoticons = mTwitchLocalDataSource.getAllEmoticons();\n            mCEView.showAllEmoticons(emoticons);\n            EmoticonHandler.setEmoticons(emoticons);\n            return;\n        }\n\n        Subscription subscription =\n                ObservableUtil.getChannelEmotionsObservable(mTwitchService, mTwitchOauthUtil.getUserName())\n                .subscribe(\n                        twitchEmoticons -> {\n                            if (!mTwitchLocalDataSource.isEmoticonExist())\n                                mTwitchLocalDataSource.saveEmoticons(twitchEmoticons);\n                            mCEView.showAllEmoticons(twitchEmoticons);\n                            EmoticonHandler.setEmoticons(twitchEmoticons);\n\n                        },\n                        error -> {\n                        },\n                        () -> {}\n                );\n        mSubscriptions.add(subscription);\n    }\n\n    @Override\n    public void inputEmoticon(Emoticon emoticon) {\n        mCEView.showEmoticon(emoticon);\n    }\n\n    @Override\n    public void unsubscribe() {\n\n    }\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.edgeorder.models;\n\nimport com.azure.core.annotation.Immutable;\nimport com.azure.core.util.logging.ClientLogger;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/** Reverse shipment details. */\n@Immutable\npublic final class ReverseShippingDetails {\n    @JsonIgnore private final ClientLogger logger = new ClientLogger(ReverseShippingDetails.class);\n\n    /*\n     * SAS key to download the reverse shipment label of the package.\n     */\n    @JsonProperty(value = \"sasKeyForLabel\", access = JsonProperty.Access.WRITE_ONLY)\n    private String sasKeyForLabel;\n\n    /*\n     * Name of the carrier.\n     */\n    @JsonProperty(value = \"carrierName\", access = JsonProperty.Access.WRITE_ONLY)\n    private String carrierName;\n\n    /*\n     * Carrier Name for display purpose. Not to be used for any processing.\n     */\n    @JsonProperty(value = \"carrierDisplayName\", access = JsonProperty.Access.WRITE_ONLY)\n    private String carrierDisplayName;\n\n    /*\n     * TrackingId of the package\n     */\n    @JsonProperty(value = \"trackingId\", access = JsonProperty.Access.WRITE_ONLY)\n    private String trackingId;\n\n    /*\n     * TrackingUrl of the package.\n     */\n    @JsonProperty(value = \"trackingUrl\", access = JsonProperty.Access.WRITE_ONLY)\n    private String trackingUrl;\n\n    /**\n     * Get the sasKeyForLabel property: SAS key to download the reverse shipment label of the package.\n     *\n     * @return the sasKeyForLabel value.\n     */\n    public String sasKeyForLabel() {\n        return this.sasKeyForLabel;\n    }\n\n    /**\n     * Get the carrierName property: Name of the carrier.\n     *\n     * @return the carrierName value.\n     */\n    public String carrierName() {\n        return this.carrierName;\n    }\n\n    /**\n     * Get the carrierDisplayName property: Carrier Name for display purpose. Not to be used for any processing.\n     *\n     * @return the carrierDisplayName value.\n     */\n    public String carrierDisplayName() {\n        return this.carrierDisplayName;\n    }\n\n    /**\n     * Get the trackingId property: TrackingId of the package.\n     *\n     * @return the trackingId value.\n     */\n    public String trackingId() {\n        return this.trackingId;\n    }\n\n    /**\n     * Get the trackingUrl property: TrackingUrl of the package.\n     *\n     * @return the trackingUrl value.\n     */\n    public String trackingUrl() {\n        return this.trackingUrl;\n    }\n\n    /**\n     * Validates the instance.\n     *\n     * @throws IllegalArgumentException thrown if the instance is not valid.\n     */\n    public void validate() {\n    }\n}\n", "View;\nimport android.widget.ImageView;\n\n\npublic class image extends Activity{\n\n    String url = \"192.168.88.143/im/uploadedimages/hhjgbyjkhby.png\";\n    ImageView imageView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.img);\n        imageView = (ImageView) findViewById(R.id.imgView);\n    }\n\n    public void uploadImage(View view) {\n    }\n}", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.logic.fluent;\n\nimport com.azure.core.annotation.ReturnType;\nimport com.azure.core.annotation.ServiceMethod;\nimport com.azure.core.http.rest.PagedIterable;\nimport com.azure.core.http.rest.Response;\nimport com.azure.core.management.polling.PollResult;\nimport com.azure.core.util.Context;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.resourcemanager.logic.fluent.models.ManagedApiInner;\n\n/**\n * An instance of this class provides access to all the operations defined in\n * IntegrationServiceEnvironmentManagedApisClient.\n */\npublic interface IntegrationServiceEnvironmentManagedApisClient {\n    /**\n     * Gets the integration service environment managed Apis.\n     *\n     * @param resourceGroup The resource group.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the integration service environment managed Apis.\n     */\n    @ServiceMethod(returns = ReturnType.COLLECTION)\n    PagedIterable<ManagedApiInner> list(String resourceGroup, String integrationServiceEnvironmentName);\n\n    /**\n     * Gets the integration service environment managed Apis.\n     *\n     * @param resourceGroup The resource group.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the integration service environment managed Apis.\n     */\n    @ServiceMethod(returns = ReturnType.COLLECTION)\n    PagedIterable<ManagedApiInner> list(\n        String resourceGroup, String integrationServiceEnvironmentName, Context context);\n\n    /**\n     * Gets the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group name.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the integration service environment managed Api.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    ManagedApiInner get(String resourceGroup, String integrationServiceEnvironmentName, String apiName);\n\n    /**\n     * Gets the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group name.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the integration service environment managed Api.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    Response<ManagedApiInner> getWithResponse(\n        String resourceGroup, String integrationServiceEnvironmentName, String apiName, Context context);\n\n    /**\n     * Puts the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group name.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the managed api definition.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    SyncPoller<PollResult<ManagedApiInner>, ManagedApiInner> beginPut(\n        String resourceGroup, String integrationServiceEnvironmentName, String apiName);\n\n    /**\n     * Puts the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group name.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the managed api definition.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    SyncPoller<PollResult<ManagedApiInner>, ManagedApiInner> beginPut(\n        String resourceGroup, String integrationServiceEnvironmentName, String apiName, Context context);\n\n    /**\n     * Puts the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group name.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the managed api definition.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    ManagedApiInner put(String resourceGroup, String integrationServiceEnvironmentName, String apiName);\n\n    /**\n     * Puts the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group name.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the managed api definition.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    ManagedApiInner put(\n        String resourceGroup, String integrationServiceEnvironmentName, String apiName, Context context);\n\n    /**\n     * Deletes the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the completion.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    SyncPoller<PollResult<Void>, Void> beginDelete(\n        String resourceGroup, String integrationServiceEnvironmentName, String apiName);\n\n    /**\n     * Deletes the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the completion.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    SyncPoller<PollResult<Void>, Void> beginDelete(\n        String resourceGroup, String integrationServiceEnvironmentName, String apiName, Context context);\n\n    /**\n     * Deletes the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    void delete(String resourceGroup, String integrationServiceEnvironmentName, String apiName);\n\n    /**\n     * Deletes the integration service environment managed Api.\n     *\n     * @param resourceGroup The resource group.\n     * @param integrationServiceEnvironmentName The integration service environment name.\n     * @param apiName The api name.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws com.azure.core.management.exception.ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    void delete(String resourceGroup, String integrationServiceEnvironmentName, String apiName, Context context);\n}\n", "\n     * Default constructor\n     */\n    public Repertoire() {\n    }\n\n\n\n    public Repertoire(String nom) {\n\t\tthis.name = nom;\n\t}\n\n\n\n\tpublic List<Node> getNodes() {\n\t\treturn nodes;\n\t}\n\n\n\n\tpublic void setNodes(List<Node> nodes) {\n\t\tthis.nodes = nodes;\n\t}\n\n\n\n\t/**\n     * \n     */\n    private List<Node> nodes = new ArrayList<>();\n\n    /**\n     * \n     */\n    public void addNode(Node node) {\n        nodes.add(node);\n    }\n\n    /**\n     * @param node \n     * \n     */\n    public void removeNode(Node node) {\n    \t nodes.remove(node);\n    }\n\n    @Override\n   public void accepteVisitor(IVisitor visitor){\n\t\tthis.visitor = visitor;\n\t\tfor(Node n : nodes){\n\t\t\tn.accepteVisitor(visitor);\n\t\t}\n\t}\n}", "rg.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.TestRunners;\nimport org.robolectric.annotation.internal.DoNotInstrument;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n@DoNotInstrument\n@RunWith(TestRunners.WithDefaults.class)\npublic class RoboWebSettingsTest {\n\n  private RoboWebSettings webSettings;\n\n  private boolean[] trueAndFalse = {true, false};\n\n  @Before\n  public void setUp() throws Exception {\n    webSettings = new RoboWebSettings();\n  }\n\n  @Test\n  public void testDefaults() {\n    assertThat(webSettings.getAllowContentAccess()).isTrue();\n    assertThat(webSettings.getAllowFileAccess()).isTrue();\n    assertThat(webSettings.getAppCacheEnabled()).isFalse();\n    assertThat(webSettings.getBlockNetworkImage()).isFalse();\n    assertThat(webSettings.getBlockNetworkLoads()).isFalse();\n    assertThat(webSettings.getBuiltInZoomControls()).isTrue();\n    assertThat(webSettings.getDatabaseEnabled()).isFalse();\n    assertThat(webSettings.getDomStorageEnabled()).isFalse();\n    assertThat(webSettings.getGeolocationEnabled()).isFalse();\n    assertThat(webSettings.getJavaScriptEnabled()).isFalse();\n    assertThat(webSettings.getLightTouchEnabled()).isFalse();\n    assertThat(webSettings.getLoadWithOverviewMode()).isFalse();\n    assertThat(webSettings.getMediaPlaybackRequiresUserGesture()).isTrue();\n    assertThat(webSettings.getPluginState()).isEqualTo(WebSettings.PluginState.OFF);\n    assertThat(webSettings.getSaveFormData()).isFalse();\n    assertThat(webSettings.getTextZoom()).isEqualTo(100);\n\n    // deprecated methods\n    assertThat(webSettings.getPluginsEnabled()).isFalse();\n\n    // obsoleted methods\n    assertThat(webSettings.getNeedInitialFocus()).isFalse();\n    assertThat(webSettings.getSupportMultipleWindows()).isFalse();\n    assertThat(webSettings.getSupportZoom()).isTrue();\n  }\n\n  @Test\n  public void testAllowContentAccess() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setAllowContentAccess(value);\n      assertThat(webSettings.getAllowContentAccess()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testAllowFileAccess() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setAllowFileAccess(value);\n      assertThat(webSettings.getAllowFileAccess()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testAllowFileAccessFromFileURLs() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setAllowFileAccessFromFileURLs(value);\n      assertThat(webSettings.getAllowFileAccessFromFileURLs()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testAllowUniversalAccessFromFileURLs() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setAllowUniversalAccessFromFileURLs(value);\n      assertThat(webSettings.getAllowUniversalAccessFromFileURLs()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testBlockNetworkImage() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setBlockNetworkImage(value);\n      assertThat(webSettings.getBlockNetworkImage()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testBlockNetworkLoads() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setBlockNetworkLoads(value);\n      assertThat(webSettings.getBlockNetworkLoads()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testBuiltInZoomControls() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setBuiltInZoomControls(value);\n      assertThat(webSettings.getBuiltInZoomControls()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testDatabaseEnabled() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setDatabaseEnabled(value);\n      assertThat(webSettings.getDatabaseEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testDomStorageEnabled() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setDomStorageEnabled(value);\n      assertThat(webSettings.getDomStorageEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testJavaScriptEnabled() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setJavaScriptEnabled(value);\n      assertThat(webSettings.getJavaScriptEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testLightTouchEnabled() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setLightTouchEnabled(value);\n      assertThat(webSettings.getLightTouchEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testLoadWithOverviewMode() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setLoadWithOverviewMode(value);\n      assertThat(webSettings.getLoadWithOverviewMode()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testMediaPlaybackRequiresUserGesture() throws Exception {\n    for (boolean value : trueAndFalse) {\n      webSettings.setMediaPlaybackRequiresUserGesture(value);\n      assertThat(webSettings.getMediaPlaybackRequiresUserGesture()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testNeedInitialFocus() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setNeedInitialFocus(value);\n      assertThat(webSettings.getNeedInitialFocus()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testPluginsEnabled() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setPluginsEnabled(value);\n      assertThat(webSettings.getPluginsEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testPluginState() {\n\n    for (WebSettings.PluginState state : WebSettings.PluginState.values()) {\n      webSettings.setPluginState(state);\n      assertThat(webSettings.getPluginState()).isEqualTo(state);\n    }\n  }\n\n  @Test\n  public void testSupportMultipleWindows() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setSupportMultipleWindows(value);\n      assertThat(webSettings.getSupportMultipleWindows()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testSupportZoom() {\n    for (boolean value : trueAndFalse) {\n      webSettings.setSupportZoom(value);\n      assertThat(webSettings.getSupportZoom()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testSetCacheMode() throws Exception {\n    webSettings.setCacheMode(7);\n    assertThat(webSettings.getCacheMode()).isEqualTo(7);\n  }\n\n  @Test\n  public void testSetUseWideViewPort() throws Exception {\n    for (boolean value : trueAndFalse) {\n      webSettings.setUseWideViewPort(value);\n      assertThat(webSettings.getUseWideViewPort()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testSetAppCacheEnabled() throws Exception {\n    for (boolean value : trueAndFalse) {\n      webSettings.setAppCacheEnabled(value);\n      assertThat(webSettings.getAppCacheEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testSetGeolocationEnabled() throws Exception {\n    for (boolean value : trueAndFalse) {\n      webSettings.setGeolocationEnabled(value);\n      assertThat(webSettings.getGeolocationEnabled()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testSetSaveFormData() throws Exception {\n    for (boolean value : trueAndFalse) {\n      webSettings.setSaveFormData(value);\n      assertThat(webSettings.getSaveFormData()).isEqualTo(value);\n    }\n  }\n\n  @Test\n  public void testSetDatabasePath() throws Exception {\n    webSettings.setDatabasePath(\"new_path\");\n    assertThat(webSettings.getDatabasePath()).isEqualTo(\"new_path\");\n  }\n\n  @Test\n  public void testSetRenderPriority() throws Exception {\n    webSettings.setRenderPriority(WebSettings.RenderPriority.HIGH);\n    assertThat(webSettings.getRenderPriority()).isEqualTo(WebSettings.RenderPriority.HIGH);\n  }\n\n  @Test\n  public void testSetAppCachePath() throws Exception {\n    webSettings.setAppCachePath(\"new_path\");\n    assertThat(webSettings.getAppCachePath()).isEqualTo(\"new_path\");\n  }\n\n  @Test\n  public void testSetAppCacheMaxSize() throws Exception {\n    webSettings.setAppCacheMaxSize(100);\n    assertThat(webSettings.getAppCacheMaxSize()).isEqualTo(100);\n  }\n\n  @Test\n  public void testSetGeolocationDatabasePath() throws Exception {\n    webSettings.setGeolocationDatabasePath(\"new_path\");\n    assertThat(webSettings.getGeolocationDatabasePath()).isEqualTo(\"new_path\");\n  }\n\n  @Test\n  public void testSetJavascriptCanOpenWindowsAutomaticallyIsTrue() throws Exception {\n    webSettings.setJavaScriptCanOpenWindowsAutomatically(true);\n    assertThat(webSettings.getJavaScriptCanOpenWindowsAutomatically()).isTrue();\n  }\n\n  @Test\n  public void testSetJavascriptCanOpenWindowsAutomaticallyIsFalse() throws Exception {\n    webSettings.setJavaScriptCanOpenWindowsAutomatically(false);\n    assertThat(webSettings.getJavaScriptCanOpenWindowsAutomatically()).isFalse();\n  }\n\n  @Test\n  public void testSetTextZoom() throws Exception {\n    webSettings.setTextZoom(50);\n    assertThat(webSettings.getTextZoom()).isEqualTo(50);\n  }\n}\n", "t java.io.IOException;\nimport java.util.ArrayList;\n\n/**\n * Created by Micha\u0142 on 2016-11-24.\n */\npublic class KnowledgeBase {\n\n    private ArrayList<Word> knowledge;\n\n    public KnowledgeBase (String source) {\n        knowledge = new ArrayList<Word>(0);\n\n        File file = new File(source);\n        try {\n            FileReader reader = new FileReader(file);\n            BufferedReader bufferedReader = new BufferedReader(reader);\n            String line = bufferedReader.readLine();\n            while (line != null) {\n                String[] tokens = line.split(\", \");\n                Word tmp = new Word(tokens[0], tokens[1]);\n                knowledge.add(tmp);\n                line = bufferedReader.readLine();\n            }\n        } catch (IOException ex) {\n            System.out.println(\"B\u0142\u0105d w czytaniu!\");\n        }\n    }\n\n    public ArrayList<Word> getKnowledge() {\n        return knowledge;\n    }\n\n}\n", "See License.txt in the project root for\n * license information.\n */\n\npackage com.microsoft.azure.management.resources.fluentcore.dag;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Type represents a node in a {@link Graph}.\n *\n * @param <DataT> the type of the data stored in the node\n * @param <NodeT> the type of the node\n */\npublic class Node<DataT, NodeT extends Node<DataT, NodeT>> {\n    /**\n     * The graph that owns this node.\n     */\n    private Graph<DataT, NodeT> ownerGraph;\n    /**\n     * A key that uniquely identifies this node in the owner graph {@link this#ownerGraph}.\n     */\n    private final String key;\n    /**\n     * reference to the data stored in the node.\n     */\n    private final DataT data;\n    /**\n     * the collection of child node keys.\n     */\n    private List<String> children;\n\n    /**\n     * Creates a graph node.\n     *\n     * @param key unique id of the node\n     * @param data data to be stored in the node\n     */\n    public Node(final String key, final DataT data) {\n        this.key = key;\n        this.data = data;\n        this.children = new ArrayList<>();\n    }\n\n    /**\n     * @return this node's unique id\n     */\n    public String key() {\n        return this.key;\n    }\n\n    /**\n     * @return data stored in this node\n     */\n    public DataT data() {\n        return data;\n    }\n\n    /**\n     * @return <tt>true</tt> if this node has any children\n     */\n    public boolean hasChildren() {\n        return !this.children.isEmpty();\n    }\n\n    /**\n     * @return children (neighbours) of this node\n     */\n    public List<String> children() {\n        return Collections.unmodifiableList(this.children);\n    }\n\n    /**\n     * @param childKey add a child (neighbour) of this node\n     */\n    public void addChild(String childKey) {\n        this.children.add(childKey);\n    }\n\n    /**\n     * Sets reference to the graph owning this node.\n     *\n     * @param ownerGraph the owning graph\n     */\n    public void setOwner(Graph<DataT, NodeT> ownerGraph) {\n        if (this.ownerGraph != null) {\n            throw new RuntimeException(\"Changing owner graph is not allowed\");\n        }\n        this.ownerGraph = ownerGraph;\n    }\n\n    /**\n     * @return the owner (container) graph of this node.\n     */\n    public Graph<DataT, NodeT> owner() {\n        if (this.ownerGraph == null) {\n            throw new RuntimeException(\"Required owner graph is not set\");\n        }\n        return this.ownerGraph;\n    }\n}\n", "ing a copy\n\tof this software and associated documentation files (the \"Software\"), to deal\n\tin the Software without restriction, including without limitation the rights\n\tto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n\tcopies of the Software, and to permit persons to whom the Software is\n\tfurnished to do so, subject to the following conditions:\n\n\tThe above copyright notice and this permission notice shall be included in all\n\tcopies or substantial portions of the Software.\n\n\tTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n\tIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n\tFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n\tAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n\tLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n\tOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n\tSOFTWARE.\n */\npackage ductive.console.config;\n\nimport org.springframework.beans.factory.config.RuntimeBeanReference;\nimport org.springframework.beans.factory.support.BeanDefinitionRegistry;\nimport org.springframework.beans.factory.support.RootBeanDefinition;\nimport org.springframework.context.annotation.ImportBeanDefinitionRegistrar;\nimport org.springframework.core.annotation.AnnotationAttributes;\nimport org.springframework.core.type.AnnotationMetadata;\n\nimport ductive.console.annotations.EnableDefaultCommands;\nimport ductive.console.commands.lib.GroovyCommands;\nimport ductive.console.commands.lib.HelpCommands;\nimport ductive.console.commands.lib.LogCommands;\nimport ductive.console.commands.lib.StatsCommands;\nimport ductive.console.shell.EmbeddedGroovyInterpreter;\nimport ductive.console.shell.EmbeddedGroovyShell;\n\npublic class DefaultCommandsRegistrar implements ImportBeanDefinitionRegistrar {\n\n\t@Override\n\tpublic void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) {\n\t\tAnnotationAttributes attr = AnnotationAttributes.fromMap(importingClassMetadata.getAnnotationAttributes(EnableDefaultCommands.class.getName()));\n\n\t\tconditionallyRegister(attr,registry,\"groovyShell\",\"groovyShellCommands\",GroovyCommands.class);\n\t\tconditionallyRegister(attr,registry,\"help\",\"helpShellCommands\",HelpCommands.class);\n\t\tconditionallyRegister(attr,registry,\"log\",\"logShellCommands\",LogCommands.class);\n\t\tconditionallyRegister(attr,registry,\"stats\",\"statsShellCommands\",StatsCommands.class);\n\n\t\t{\n\t\t\tRootBeanDefinition beanDefinition = new RootBeanDefinition(EmbeddedGroovyShell.class);\n\t\t\tbeanDefinition.setScope(\"prototype\");\n\t\t\tbeanDefinition.getPropertyValues().add(\"historyProvider\",new RuntimeBeanReference(attr.getString(\"historyProviderBean\")));\n\t\t\tregistry.registerBeanDefinition(\"groovyShell\",beanDefinition);\n\t\t}\n\n\t\t{\n\t\t\tRootBeanDefinition beanDefinition = new RootBeanDefinition(EmbeddedGroovyInterpreter.class);\n\t\t\tbeanDefinition.setScope(\"prototype\");\n\t\t\tregistry.registerBeanDefinition(\"groovyInterpreter\",beanDefinition);\n\t\t}\n\t}\n\n\tprivate void conditionallyRegister(AnnotationAttributes attr, BeanDefinitionRegistry registry, String attribute, String beanName, Class<?> clazz) {\n\t\tif(!attr.getBoolean(attribute))\n\t\t\treturn;\n\n\t\tRootBeanDefinition beanDefinition = new RootBeanDefinition(clazz);\n\t\tbeanDefinition.setSource(null);\n\t\tregistry.registerBeanDefinition(beanName, beanDefinition);\n\t}\n\n}\n", "ontainer (remove?)\n\tBLANK,\n\tRAW_TEXT,\n\tNUMBER,\n\t\n\tCONST_E,\n\tCONST_PI,\n\n\tADD,\n\tSUBTRACT,\n\tMULTIPLY,\n\tDIVIDE,\n\tNEGATIVE,\n\tABS,\n\t\n\tPOWER,\n\tSQRT,\n\tLN,\n\tLOG10,\n\t\n\tSINE,\n\tCOSINE,\n\tTANGENT,\n\tARCSINE,\n\tARCCOSINE,\n\tARCTANGENT,\n\n\tHYPSINE,\n\tHYPCOSINE,\n\tHYPTANGENT,\n\tARHYPSINE,\n\tARHYPCOSINE,\n\tARHYPTANGENT,\n\t\n\tFACTORIAL,\n\tNCK,\n\tNPK,\n\t\n\tREMAINDER,\n\tGCD,\n\tLCM,\n\t;\n}\n", "port taskDo.CategoryList;\nimport taskDo.SearchType;\nimport taskDo.Task;\nimport commandFactory.CommandType;\nimport commonClasses.Constants;\nimport commonClasses.SummaryReport;\n/**\n * This class is used to interpret the main commands that are available for Task.Do\n */\npublic class MainCommandInterpreter extends CommandInterpreter {\n\n\t// @author  A0111936J\n\t// Members\n\tprivate CommandType currentCommand;\n\n\tpublic CommandType getCommand() {\n\t\treturn this.currentCommand;\n\t}\n\n\tpublic void identifyAndSetCommand(String command)\n\t\t\tthrows InvalidParameterException {\n\t\tswitch (command) {\n\t\t\tcase Constants.COMMAND_STRING_NEW:\n\t\t\tcase Constants.COMMAND_STRING_CREATE:\n\t\t\tcase Constants.COMMAND_STRING_ADD:\n\t\t\t\tcurrentCommand = CommandType.ADD;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_SHOW:\n\t\t\tcase Constants.COMMAND_STRING_VIEW:\n\t\t\tcase Constants.COMMAND_STRING_DISPLAY:\n\t\t\t\tcurrentCommand = CommandType.DISPLAY;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_DEL:\n\t\t\tcase Constants.COMMAND_STRING_REMOVE:\n\t\t\tcase Constants.COMMAND_STRING_DELETE:\n\t\t\t\tcurrentCommand = CommandType.DELETE;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_MOD:\n\t\t\tcase Constants.COMMAND_STRING_EDIT:\n\t\t\t\tcurrentCommand = CommandType.EDIT;\n\t\t\t\tbreak;\n\t\t\tcase Constants.COMMAND_STRING_UNDO:\n\t\t\t\tcurrentCommand = CommandType.UNDO;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_SEARCH:\n\t\t\t\tcurrentCommand = CommandType.SEARCH;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_TICK:\n\t\t\tcase Constants.COMMAND_STRING_DONE:\n\t\t\tcase Constants.COMMAND_STRING_COMPLETE:\n\t\t\t\tcurrentCommand = CommandType.COMPLETED;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_REDO:\n\t\t\t\tcurrentCommand = CommandType.REDO;\n\t\t\t\tbreak;\n\n\t\t\tcase Constants.COMMAND_STRING_QUIT:\n\t\t\tcase Constants.COMMAND_STRING_EXIT:\n\t\t\t\tcurrentCommand = CommandType.EXIT;\n\t\t\t\tbreak;\n\n\t\t\tdefault:\n\t\t\t\tSummaryReport.setFeedBackMsg(Constants.MESSAGE_INVALID_COMMAND);\n\t\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\t\tConstants.MESSAGE_INVALID_COMMAND);\n\t\t}\n\t}\n\n\tpublic String removeCommandWord(String input) {\n\t\tif (input.indexOf(Constants.CHAR_SPACING) == -1) {\n\t\t\tSummaryReport.setFeedBackMsg(Constants.MESSAGE_MISSING_PARAM);\n\t\t\tthrow new InvalidParameterException(Constants.MESSAGE_MISSING_PARAM);\n\t\t}\n\t\treturn input.substring(input.indexOf(Constants.CHAR_SPACING) + 1);\n\t}\n\n\tpublic ParsedResult updateResults(ParsedResult result, String commandParam)\n\t\t\tthrows InvalidParameterException {\n\t\tresult.setCommandType(currentCommand);\n\t\tTask task = result.getTaskDetails();\n\t\tswitch (currentCommand) {\n\n\t\t\tcase ADD:\n\t\t\t\ttask.setTitle(commandParam);\n\t\t\t\tbreak;\n\n\t\t\tcase DELETE:\n\t\t\t\tupdateForDeleteCase(result, commandParam);\n\t\t\t\tbreak;\n\n\t\t\tcase EDIT:\n\t\t\t\tupdateForEditCase(result, commandParam);\n\t\t\t\tbreak;\n\n\t\t\tcase DISPLAY:\n\t\t\t\tupdateDisplayCase(result, commandParam);\n\t\t\t\tbreak;\n\n\t\t\tcase UNDO:\n\t\t\t\t// do nothing\n\t\t\t\tbreak;\n\n\t\t\tcase COMPLETED:\n\t\t\t\tupdateCompleteCase(result, commandParam);\n\t\t\t\tbreak;\n\n\t\t\tcase SEARCH:\n\t\t\t\tupdateSearchCase(result, commandParam);\n\n\t\t\tdefault:\n\t\t\t\t// do nothing\n\n\t\t}\n\t\treturn result;\n\t}\n\n\tprivate void updateSearchCase(ParsedResult result, String commandParam) {\n\t\tresult.getTaskDetails().setTitle(commandParam);\n\t\tresult.setSearchMode(SearchType.KEYWORD);\n\t}\n\n\tprivate void updateCompleteCase(ParsedResult result, String commandParam) {\n\t\tif (CommonInterpreterMethods.isValidSelection(commandParam)) {\n\t\t\tint selection = getSelection(commandParam);\n\t\t\tresult.setTask(SummaryReport.getDisplayList().get(selection));\n\t\t\tresult.setSelectedItem(selection);\n\t\t\tif (result.getTaskDetails().isCompleted()) {\n\t\t\t\tSummaryReport\n\t\t\t\t\t\t.setFeedBackMsg(Constants.MESSAGE_TASK_ALREADY_COMPLETED);\n\t\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\t\tConstants.MESSAGE_TASK_ALREADY_COMPLETED);\n\t\t\t}\n\t\t} else {\n\t\t\tSummaryReport.setFeedBackMsg(Constants.MESSAGE_INVALID_SELECTION);\n\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\tConstants.MESSAGE_INVALID_SELECTION);\n\t\t}\n\t}\n\n\tprivate int getSelection(String commandParam) {\n\t\treturn Integer.valueOf(commandParam) - 1;\n\t}\n\n\tprivate void copyTaskParamToParsedResult(ParsedResult result, int selection) {\n\t\tTask selectedTask = new Task();\n\n\t\tselectedTask = SummaryReport.getDisplayList().get(selection);\n\n\t\tresult.getTaskDetails().setId(selectedTask.getId());\n\t\tresult.getTaskDetails().setTitle(selectedTask.getTitle());\n\t\tresult.getTaskDetails().setCategory(selectedTask.getCategory());\n\t\tresult.getTaskDetails().setStartDate(selectedTask.getStartDate());\n\t\tresult.getTaskDetails().setDueDate(selectedTask.getDueDate());\n\t\tresult.getTaskDetails().setCompleted(selectedTask.isCompleted());\n\t\tresult.getTaskDetails().setImportant(selectedTask.isImportant());\n\t\tresult.getTaskDetails().setTaskType(selectedTask.getTaskType());\n\t\tresult.getTaskDetails().setNote(selectedTask.getNote());\n\t}\n\n\tprivate void updateDisplayCase(ParsedResult result, String commandParam) {\n\t\tTask task = result.getTaskDetails();\n\n\t\tif (CategoryList.isExistingCategory(commandParam)) {\n\t\t\ttask.setCategory(commandParam);\n\t\t\tresult.setSearchMode(SearchType.CATEGORY);\n\t\t} else if (CommonInterpreterMethods.noDeadLine(commandParam)) {\n\t\t\ttask.setDueDate(Constants.SOMEDAY);\n\t\t\ttask.setStartDate(null);\n\t\t\tresult.setSearchMode(SearchType.DATE);\n\t\t} else if (commandParam.toLowerCase().equals(Constants.DISPLAY_ALL)) {\n\t\t\tresult.setSearchMode(SearchType.ALL);\n\t\t} else if (commandParam.toLowerCase().equals(\n\t\t\t\tConstants.DISPLAY_COMPLETED)) {\n\t\t\tresult.setSearchMode(SearchType.COMPLETED);\n\t\t} else if (commandParam.toLowerCase().equals(Constants.DISPLAY_OVERDUE)) {\n\t\t\tresult.setSearchMode(SearchType.OVERDUE);\n\t\t} else {\n\t\t\tDateTime date;\n\t\t\ttry {\n\t\t\t\tdate = CommonInterpreterMethods.getDate(commandParam);\n\t\t\t} catch (Exception e) {\n\t\t\t\tSummaryReport.setFeedBackMsg(Constants.MESSAGE_DATE_HAS_PASSED);\n\t\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\t\tConstants.MESSAGE_DATE_HAS_PASSED);\n\t\t\t}\n\t\t\tif (CommonInterpreterMethods.isInvalidDate(date)) {\n\t\t\t\tSummaryReport\n\t\t\t\t\t\t.setFeedBackMsg(Constants.MESSAGE_INVALID_DISPLAY_SELECTION);\n\t\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\t\tConstants.MESSAGE_INVALID_DISPLAY_SELECTION);\n\t\t\t} else {\n\t\t\t\ttask.setDueDate(date);\n\t\t\t\tresult.setSearchMode(SearchType.DATE);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void updateForEditCase(ParsedResult result, String commandParam) {\n\t\tif (CommonInterpreterMethods.isValidSelection(commandParam)) {\n\t\t\tint selection = getSelection(commandParam);\n\t\t\tcopyTaskParamToParsedResult(result, selection);\n\t\t\tresult.setSelectedItem(selection);\n\t\t} else {\n\t\t\tSummaryReport.setFeedBackMsg(Constants.MESSAGE_INVALID_SELECTION);\n\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\tConstants.MESSAGE_INVALID_SELECTION);\n\t\t}\n\t}\n\n\tprivate void updateForDeleteCase(ParsedResult result, String commandParam) {\n\t\tif (CommonInterpreterMethods.isValidSelection(commandParam)) {\n\t\t\tint selection = getSelection(commandParam);\n\t\t\tresult.setTask(SummaryReport.getDisplayList().get(selection));\n\t\t\tresult.setSelectedItem(selection);\n\t\t} else {\n\t\t\tSummaryReport.setFeedBackMsg(Constants.MESSAGE_INVALID_SELECTION);\n\t\t\tthrow new InvalidParameterException(\n\t\t\t\t\tConstants.MESSAGE_INVALID_SELECTION);\n\t\t}\n\t}\n\n\tpublic boolean commandDoesNotRequireParam() {\n\n\t\tif (currentCommand == CommandType.UNDO\n\t\t\t\t|| currentCommand == CommandType.REDO\n\t\t\t\t|| currentCommand == CommandType.EXIT)\n\t\t\treturn true;\n\n\t\treturn false;\n\n\t}\n\n}\n", "eBase;\n\npublic class CommentTest extends RmlParsingTestCase {\n  public void test_constant() {\n    FileBase psiFile = parseCode(\"/* */\");\n    assertInstanceOf(firstElement(psiFile), PsiComment.class);\n  }\n\n  public void test_constant2() {\n    FileBase psiFile = parseCode(\"/* \\\"this is a string */\\\" */\");\n    assertInstanceOf(firstElement(psiFile), PsiComment.class);\n    assertEquals(1, childrenCount(psiFile));\n  }\n}\n", "al String OC_ResLoc = \"opencomputers\"; // Resource domain for OpenComputers\n\tpublic static final String OC_Namespace = \"oc:\"; // Namespace for OpenComputers NBT Data\n\t\n\tpublic static float OC_SoundVolume;\n\tpublic static double OC_IC2PWR;\n\tpublic static double OC_SuckDelay;\n\tpublic static double OC_DropDelay;\n\t\n\tpublic static int ComputerCartBaseCost; //Config Value -> basecost\n\tpublic static int ComputerCartComplexityCost; //Config Value -> costmultiplier\n\tpublic static int ComputerCartEnergyCap; //Config Value -> energystore\n\tpublic static double ComputerCartEnergyUse; //Config Value -> energyuse\n\tpublic static int ComputerCartCreateEnergy; //Config Value -> newenergy\n\tpublic static double ComputerCartEngineUse; //Config Value -> engineuse\n\tpublic static double ComputerCartETrackLoad; //Config Value -> maxtrackcharge\n\tpublic static double ComputerCartETrackBuf; //Config Value -> maxtrackcharge\n\tpublic static double ComputerCartETrackLoss; //Config Value -> maxtrackcharge\n\t\n\tpublic static int NetRailPowerTransfer; //Config Value -> transferspeed\n\t\n\tpublic static double LinkingLinkDelay;\n\tpublic static double LinkingLinkCost;\n\tpublic static double LinkingUnlinkDelay;\n\tpublic static double LinkingUnlinkCost;\n\tpublic static int[] RemoteRange;\n\t\n\tpublic static boolean GeneralFixCartBox; //Config Value -> cartboxfix\n\t\n\t\n\tpublic static void init(){\n\t\tOCMinecart.config.load();\n\t\tconfComments();\n\t\tconfValues();\n\t\tconfOrder();\n\t\tOCMinecart.config.save();\n\t\t\n\t\tocValues();\n\t}\n\t\n\tprivate static void ocValues(){\t//Get the settings from OpenCOmputers\n\t\tOC_SoundVolume = li.cil.oc.Settings.get().soundVolume();\n\t\tOC_IC2PWR = li.cil.oc.Settings.get().ratioIndustrialCraft2();\n\t\tOC_SuckDelay = li.cil.oc.Settings.get().suckDelay();\n\t\tOC_DropDelay = li.cil.oc.Settings.get().dropDelay();\n\t}\n\t\n\tprivate static void confValues(){\n\t\t// computercart\n\t\tComputerCartBaseCost = OCMinecart.config.get(\"computercart\", \"basecost\", 50000 , \"Energy cost for a ComputerCart with Complexity 0 [default: 50000]\").getInt(50000);\n\t\tComputerCartComplexityCost = OCMinecart.config.get(\"computercart\", \"costmultiplier\", 10000 , \"Energy - Complexity multiplier [default: 10000]\").getInt(10000);\n\t\tComputerCartEnergyCap = OCMinecart.config.get(\"computercart\", \"energystore\", 20000 , \"Energy a Computer cart can store [default: 20000]\").getInt(20000);\n\t\tComputerCartEnergyUse = OCMinecart.config.get(\"computercart\", \"energyuse\", 0.25 , \"Energy a Computer cart consume every tick [default: 0.25]\").getDouble(0.25);\n\t\tComputerCartCreateEnergy= OCMinecart.config.get(\"computercart\", \"newenergy\", 20000 , \"Energy new a Computer cart has stored [default: 20000]\").getInt(20000);\n\t\tComputerCartEngineUse = OCMinecart.config.get(\"computercart\", \"engineuse\", 2 , \"Energy multiplier for the Engine. Speed times Value [default: 2]\").getDouble(2);\n\t\tComputerCartETrackBuf = OCMinecart.config.get(\"computercart\", \"trackchargebuffer\", 1000 , \"[Railcraft] Charge buffer for the computer cart (EU) [default: 1000]\").getDouble(1000);\n\t\tComputerCartETrackLoss = OCMinecart.config.get(\"computercart\", \"chargebufferloss\", 0.1 , \"[Railcraft] Charge buffer loss per tick (EU) [default: 0.1]\").getDouble(0.1);\n\t\tComputerCartETrackLoad = OCMinecart.config.get(\"computercart\", \"maxtrackcharge\", 16 , \"[Railcraft] Max. Energy a cart can take from the charge buffer per tick (EU) [default: 16]\").getDouble(16);\n\t\t\t\t\n\t\t// networkrail\n\t\tNetRailPowerTransfer= OCMinecart.config.get(\"networkrail\", \"transferspeed\",150 , \"Energy that a network rail can transfer per tick [default: 100]\").getInt(150);\n\t\t\n\t\t// general\n\t\tGeneralFixCartBox = OCMinecart.config.get(\"general\", \"cartboxfix\", true, \"Fix the computer cart bounding box if railcraft is installed [default:true]\").getBoolean(true);\n\t\t\n\t\t//upgrades\n\t\tLinkingLinkDelay= OCMinecart.config.get(\"upgrades\", \"linkingdelay\", 0.2 , \"Pause time when linking two carts with a Linking Upgrade (also when unsuccessful). in seconds [default: 0.5]\").getDouble(0.5);\n\t\tLinkingLinkCost= OCMinecart.config.get(\"upgrades\", \"linkingcost\", 0.5 , \"Energy the Linking Upgrade will take when linked successful [default: 0.5]\").getDouble(0.5);\n\t\tLinkingUnlinkDelay= OCMinecart.config.get(\"upgrades\", \"unlinkdelay\", 0.2 , \"Pause time when unlinklink two carts with a Linking Upgrade (also when unsuccessful). in seconds [default: 0.3]\").getDouble(0.3);\n\t\tLinkingLinkDelay= OCMinecart.config.get(\"upgrades\", \"unlinkcost\", 0.5 , \"Energy the Linking Upgrade will take when unlinked successful [default: 0.4]\").getDouble(0.4);\n\t\t\n\t\tRemoteRange = OCMinecart.config.get(\"upgrades\", \"remoterange\", new int[]{4,64,256}, \"Wireless range for the remote modules (Tier 1,2,3) [default: {4,64,256}]\").getIntList();\n\t}\n\t\n\tprivate static void confComments(){\n\t\tOCMinecart.config.addCustomCategoryComment(\"computercart\", \"Settings for the computer cart\\n\"\n\t\t\t\t+ \"[Railcraft] <= This settings are useless if Railcraft is not installed. \");\n\t\t\n\t\tOCMinecart.config.addCustomCategoryComment(\"networkrail\", \"Settings for the network rail\");\n\t\tOCMinecart.config.addCustomCategoryComment(\"general\", \"Some general settings for the mod\");\n\t\tOCMinecart.config.addCustomCategoryComment(\"upgrades\", \"Some general settings for upgrades\");\n\t}\n\t\n\tprivate static void confOrder(){\n\t\tArrayList<String> computercart = new ArrayList<String>();\n\t\tcomputercart.add(\"basecost\");\n\t\tcomputercart.add(\"costmultiplier\");\n\t\tcomputercart.add(\"newenergy\");\n\t\tcomputercart.add(\"energystore\");\n\t\tcomputercart.add(\"energyuse\");\n\t\tcomputercart.add(\"engineuse\");\n\t\tcomputercart.add(\"maxtrackcharge\");\n\t\tcomputercart.add(\"trackchargebuffer\");\n\t\tcomputercart.add(\"chargebufferloss\");\n\t\tOCMinecart.config.setCategoryPropertyOrder(\"computercart\", computercart);\n\t\t\n\t\tArrayList<String> upgrades = new ArrayList<String>();\n\t\tupgrades.add(\"remoterange\");\n\t\tupgrades.add(\"linkingdelay\");\n\t\tupgrades.add(\"linkingcost\");\n\t\tupgrades.add(\"unlinkdelay\");\n\t\tupgrades.add(\"unlinkcost\");\n\t\tOCMinecart.config.setCategoryPropertyOrder(\"upgrades\", upgrades);\n\t}\n}\n", "port com.crubier.lil.lil.InteractorEntityActor;\nimport com.crubier.lil.lil.LilPackage;\n\nimport org.eclipse.emf.common.notify.Notification;\n\nimport org.eclipse.emf.ecore.EClass;\nimport org.eclipse.emf.ecore.InternalEObject;\n\nimport org.eclipse.emf.ecore.impl.ENotificationImpl;\n\n/**\n * <!-- begin-user-doc -->\n * An implementation of the model object '<em><b>Interactor Entity Actor</b></em>'.\n * <!-- end-user-doc -->\n * <p>\n * The following features are implemented:\n * <ul>\n *   <li>{@link com.crubier.lil.lil.impl.InteractorEntityActorImpl#getEntity <em>Entity</em>}</li>\n * </ul>\n * </p>\n *\n * @generated\n */\npublic class InteractorEntityActorImpl extends InteractorEntityImpl implements InteractorEntityActor\n{\n  /**\n   * The cached value of the '{@link #getEntity() <em>Entity</em>}' reference.\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @see #getEntity()\n   * @generated\n   * @ordered\n   */\n  protected InteractorActorDeclaration entity;\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  protected InteractorEntityActorImpl()\n  {\n    super();\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  @Override\n  protected EClass eStaticClass()\n  {\n    return LilPackage.Literals.INTERACTOR_ENTITY_ACTOR;\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  public InteractorActorDeclaration getEntity()\n  {\n    if (entity != null && entity.eIsProxy())\n    {\n      InternalEObject oldEntity = (InternalEObject)entity;\n      entity = (InteractorActorDeclaration)eResolveProxy(oldEntity);\n      if (entity != oldEntity)\n      {\n        if (eNotificationRequired())\n          eNotify(new ENotificationImpl(this, Notification.RESOLVE, LilPackage.INTERACTOR_ENTITY_ACTOR__ENTITY, oldEntity, entity));\n      }\n    }\n    return entity;\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  public InteractorActorDeclaration basicGetEntity()\n  {\n    return entity;\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  public void setEntity(InteractorActorDeclaration newEntity)\n  {\n    InteractorActorDeclaration oldEntity = entity;\n    entity = newEntity;\n    if (eNotificationRequired())\n      eNotify(new ENotificationImpl(this, Notification.SET, LilPackage.INTERACTOR_ENTITY_ACTOR__ENTITY, oldEntity, entity));\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  @Override\n  public Object eGet(int featureID, boolean resolve, boolean coreType)\n  {\n    switch (featureID)\n    {\n      case LilPackage.INTERACTOR_ENTITY_ACTOR__ENTITY:\n        if (resolve) return getEntity();\n        return basicGetEntity();\n    }\n    return super.eGet(featureID, resolve, coreType);\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  @Override\n  public void eSet(int featureID, Object newValue)\n  {\n    switch (featureID)\n    {\n      case LilPackage.INTERACTOR_ENTITY_ACTOR__ENTITY:\n        setEntity((InteractorActorDeclaration)newValue);\n        return;\n    }\n    super.eSet(featureID, newValue);\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  @Override\n  public void eUnset(int featureID)\n  {\n    switch (featureID)\n    {\n      case LilPackage.INTERACTOR_ENTITY_ACTOR__ENTITY:\n        setEntity((InteractorActorDeclaration)null);\n        return;\n    }\n    super.eUnset(featureID);\n  }\n\n  /**\n   * <!-- begin-user-doc -->\n   * <!-- end-user-doc -->\n   * @generated\n   */\n  @Override\n  public boolean eIsSet(int featureID)\n  {\n    switch (featureID)\n    {\n      case LilPackage.INTERACTOR_ENTITY_ACTOR__ENTITY:\n        return entity != null;\n    }\n    return super.eIsSet(featureID);\n  }\n\n} //InteractorEntityActorImpl\n", "t;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.TimeUnit;\n\nimport javax.websocket.Session;\n\nimport org.apache.log4j.Logger;\nimport org.nextrtc.server.dao.Conversations;\nimport org.nextrtc.server.dao.Members;\nimport org.nextrtc.server.domain.signal.DefaultSignal;\nimport org.nextrtc.server.domain.signal.SenderRequest;\nimport org.nextrtc.server.domain.signal.SignalResponse;\nimport org.nextrtc.server.exception.MemberNotFoundException;\nimport org.nextrtc.server.exception.SessionCloseException;\nimport org.nextrtc.server.factory.ConversationFactoryResolver;\nimport org.nextrtc.server.factory.MemberFactory;\nimport org.nextrtc.server.service.MessageSender;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n\nimport com.google.common.base.Optional;\nimport com.google.common.collect.BiMap;\nimport com.google.common.collect.HashBiMap;\nimport com.google.common.collect.Maps;\n\n@Component\n@Scope(\"singleton\")\npublic class NextRTCServer {\n\tprivate static final Logger log = Logger.getLogger(NextRTCServer.class);\n\n\t@Autowired\n\tprivate Members members;\n\n\t@Autowired\n\tprivate Conversations conversations;\n\n\t@Autowired\n\tprivate MessageSender messageSender;\n\n\t@Autowired\n\tprivate ConversationFactoryResolver conversationFactoryResolver;\n\n\t@Autowired\n\tprivate MemberFactory memberFactory;\n\n\tprivate final ScheduledExecutorService scheduler = Executors.newScheduledThreadPool(5);\n\n\tprivate final BiMap<Session, String> memberSession = Maps.synchronizedBiMap(//\n\t\t\tHashBiMap.<Session, String> create());\n\n\tpublic void register(Session session) {\n\t\tbindSessionToMember(session, memberFactory.create());\n\t}\n\n\tpublic synchronized void handle(Message message, Session session) {\n\t\tMember member = getMemberBy(session);\n\n\t\tSignalResponse messages = execute(message, member);\n\n\t\tmessageSender.send(transform(messages));\n\t}\n\n\tpublic void unregister(Session session) {\n\t\tboolean sessionBoundToMember = memberSession.get(session) != null;\n\t\tif (sessionBoundToMember) {\n\t\t\tOptional<Member> member = disconnectMemberFromConversation(session);\n\t\t\tif (member.isPresent()) {\n\t\t\t\tremoveMember(member.get());\n\t\t\t}\n\n\t\t\tunbindSession(session);\n\n\t\t\ttryToCloseSession(session);\n\t\t}\n\t}\n\n\tprivate Member getMemberBy(Session session) {\n\t\tfor (Member member : members.findBy(memberSession.get(session)).asSet()) {\n\t\t\treturn member;\n\t\t}\n\t\tthrow new MemberNotFoundException();\n\t}\n\n\tprivate static class Ping implements Runnable {\n\n\t\tprivate MessageSender sender;\n\t\tprivate SenderRequest req;\n\n\t\tprivate Ping(MessageSender sender, SenderRequest req) {\n\t\t\tthis.sender = sender;\n\t\t\tthis.req = req;\n\t\t}\n\n\t\t@Override\n\t\tpublic void run() {\n\t\t\tsender.send(req);\n\t\t}\n\t}\n\n\tprivate void bindSessionToMember(Session session, Member member) {\n\t\tmembers.save(member);\n\t\tlog.debug(\"New member: \" + member + \" has been created and bind to session: \" + session.getId());\n\t\tsession.setMaxIdleTimeout(1000 * 6);\n\t\tmemberSession.put(session, member.getId());\n\t\tSenderRequest req = new SenderRequest();\n\t\treq.add(Message.createWith(DefaultSignal.ping).build(), session);\n\t\tscheduler.scheduleAtFixedRate(new Ping(messageSender, req), 5, 5, TimeUnit.SECONDS);\n\t}\n\n\tprivate SignalResponse execute(Message message, Member member) {\n\t\tlog.debug(\"RECV: \" + message + \" FROM: \" + memberSession.inverse().get(member.getId()).getId());\n\t\tSignalResponse messages = message.getSignal().execute(//\n\t\t\t\tmember,//\n\t\t\t\tmessage,//\n\t\t\t\tnew RequestContext(conversations, members, conversationFactoryResolver)//\n\t\t\t\t);\n\t\treturn messages;\n\t}\n\n\tprivate SenderRequest transform(SignalResponse response) {\n\t\tSenderRequest request = new SenderRequest();\n\t\tMap<Message, List<Member>> recipients = response.getRecipients();\n\t\tfor (Message message : recipients.keySet()) {\n\t\t\tfor (Member recipient : recipients.get(message)) {\n\t\t\t\trequest.add(message, memberSession.inverse().get(recipient.getId()));\n\t\t\t}\n\t\t}\n\t\treturn request;\n\t}\n\n\tprivate Optional<Member> disconnectMemberFromConversation(Session session) {\n\t\tOptional<Member> member = members.findBy(memberSession.get(session));\n\n\t\tboolean existsConversationWithMember = member.isPresent() && conversations.findBy(member.get()).isPresent();\n\n\t\tif (existsConversationWithMember) {\n\t\t\thandle(Message.createWith(left).build(), session);\n\t\t}\n\n\t\treturn member;\n\t}\n\n\tprivate void removeMember(Member member) {\n\t\tmembers.remove(member);\n\t}\n\n\tprivate void unbindSession(Session session) {\n\t\tmemberSession.remove(session);\n\t}\n\n\tprivate void tryToCloseSession(Session session) {\n\t\ttry {\n\t\t\tsession.close();\n\t\t} catch (IOException e) {\n\t\t\tnew SessionCloseException(e);\n\t\t}\n\t}\n\n}\n", "dle;\nimport android.support.v4.app.ListFragment;\nimport android.support.v4.view.MenuItemCompat;\nimport android.util.Log;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.ListView;\n\nimport java.util.List;\n\nimport de.danoeh.antennapod.R;\nimport de.danoeh.antennapod.adapter.DownloadLogAdapter;\nimport de.danoeh.antennapod.core.feed.EventDistributor;\nimport de.danoeh.antennapod.core.service.download.DownloadStatus;\nimport de.danoeh.antennapod.core.storage.DBReader;\nimport de.danoeh.antennapod.core.storage.DBWriter;\nimport rx.Observable;\nimport rx.Subscription;\nimport rx.android.schedulers.AndroidSchedulers;\nimport rx.schedulers.Schedulers;\n\n/**\n * Shows the download log\n */\npublic class DownloadLogFragment extends ListFragment {\n\n    private static final String TAG = \"DownloadLogFragment\";\n\n    private List<DownloadStatus> downloadLog;\n    private DownloadLogAdapter adapter;\n\n    private boolean viewsCreated = false;\n    private boolean itemsLoaded = false;\n\n    private Subscription subscription;\n\n    @Override\n    public void onStart() {\n        super.onStart();\n        setHasOptionsMenu(true);\n        EventDistributor.getInstance().register(contentUpdate);\n        loadItems();\n    }\n\n    @Override\n    public void onStop() {\n        super.onStop();\n        EventDistributor.getInstance().unregister(contentUpdate);\n        if(subscription != null) {\n            subscription.unsubscribe();\n        }\n    }\n\n    @Override\n    public void onViewCreated(View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        // add padding\n        final ListView lv = getListView();\n        lv.setClipToPadding(false);\n        final int vertPadding = getResources().getDimensionPixelSize(R.dimen.list_vertical_padding);\n        lv.setPadding(0, vertPadding, 0, vertPadding);\n\n        viewsCreated = true;\n        if (itemsLoaded) {\n            onFragmentLoaded();\n        }\n    }\n\n    private void onFragmentLoaded() {\n        if (adapter == null) {\n            adapter = new DownloadLogAdapter(getActivity(), itemAccess);\n            setListAdapter(adapter);\n        }\n        setListShown(true);\n        adapter.notifyDataSetChanged();\n        getActivity().supportInvalidateOptionsMenu();\n    }\n\n    private DownloadLogAdapter.ItemAccess itemAccess = new DownloadLogAdapter.ItemAccess() {\n\n        @Override\n        public int getCount() {\n            return (downloadLog != null) ? downloadLog.size() : 0;\n        }\n\n        @Override\n        public DownloadStatus getItem(int position) {\n            return (downloadLog != null) ? downloadLog.get(position) : null;\n        }\n    };\n\n    private EventDistributor.EventListener contentUpdate = new EventDistributor.EventListener() {\n\n        @Override\n        public void update(EventDistributor eventDistributor, Integer arg) {\n            if ((arg & EventDistributor.DOWNLOADLOG_UPDATE) != 0) {\n                loadItems();\n            }\n        }\n    };\n\n    @Override\n    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {\n        super.onCreateOptionsMenu(menu, inflater);\n        if (itemsLoaded) {\n            MenuItem clearHistory = menu.add(Menu.NONE, R.id.clear_history_item, Menu.CATEGORY_CONTAINER, R.string.clear_history_label);\n            MenuItemCompat.setShowAsAction(clearHistory, MenuItemCompat.SHOW_AS_ACTION_IF_ROOM);\n            TypedArray drawables = getActivity().obtainStyledAttributes(new int[]{R.attr.content_discard});\n            clearHistory.setIcon(drawables.getDrawable(0));\n            drawables.recycle();\n        }\n    }\n\n    @Override\n    public void onPrepareOptionsMenu(Menu menu) {\n        super.onPrepareOptionsMenu(menu);\n        if (itemsLoaded) {\n            MenuItem menuItem = menu.findItem(R.id.clear_history_item);\n            if(menuItem != null) {\n                menuItem.setVisible(downloadLog != null && !downloadLog.isEmpty());\n            }\n        }\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (!super.onOptionsItemSelected(item)) {\n            switch (item.getItemId()) {\n                case R.id.clear_history_item:\n                    DBWriter.clearDownloadLog();\n                    return true;\n                default:\n                    return false;\n            }\n        } else {\n            return true;\n        }\n    }\n\n    private void loadItems() {\n        if(subscription != null) {\n            subscription.unsubscribe();\n        }\n        subscription = Observable.defer(() -> Observable.just(DBReader.getDownloadLog()))\n                .subscribeOn(Schedulers.newThread())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(result -> {\n                    if (result != null) {\n                        downloadLog = result;\n                        itemsLoaded = true;\n                        if (viewsCreated) {\n                            onFragmentLoaded();\n                        }\n                    }\n                }, error -> {\n                    Log.e(TAG, Log.getStackTraceString(error));\n                });\n    }\n\n}\n", "rt java.io.IOException;\n\n/**\n * Remove comments and tokenize a .jack file.\n * \n * @author David Owen\n */\npublic class JackTokenizer {\n\n    private final BufferedReader input;\n    private char nextCharacter;\n    private TokenType tokenType;\n    private KeyWord keyWord;\n    private String currentToken;\n    \n    /**\n     * Create tokenizer (to remove comments and tokenize a .jack file).\n     * \n     * @param inputFilename Input file name.\n     * @throws FileNotFoundException If input file can't be found.\n     */\n    public JackTokenizer(String inputFilename) throws FileNotFoundException {\n        input = new BufferedReader(new FileReader(inputFilename));\n        readNextCharacter(); // Set up for call to advance.\n        advance(); // Read first token (into currentToken field).\n    }\n    \n    private void readNextCharacter() {\n        \n        try {\n            nextCharacter = (char) input.read();\n            \n        } catch (IOException e) {\n            System.err.println(\"Problem reading file :(\");\n            System.exit(0);\n        }\n    }\n    \n    /**\n     * Do we have more tokens in the input?\n     * \n     * @return true if we do, false otherwise.\n     */\n    public boolean hasMoreTokens() {\n        return (nextCharacter != 65535 /* EOF */);\n    }\n    \n    /**\n     * Gets the next token from the input and makes it the current token.\n     * This method should be called only if hasMoreTokens returns true.\n     * Initially there is no current token.\n     */\n    public void advance() {\n        \n        if (nextCharacter == '/') {\n            readNextCharacter();\n            commentOrDivisionOperator();\n            \n        } else if (Character.isWhitespace(nextCharacter)) {\n            readNextCharacter();\n            advance();  // Skip ahead to next token after whitespace.\n            \n        } else if (nextCharacter == '_' ||\n                Character.isLetter(nextCharacter)) {\n            currentToken = \"\" + nextCharacter;\n            readNextCharacter();\n            keywordOrIdentifier();\n            \n        } else if (Character.isDigit(nextCharacter)) {\n            currentToken = \"\" + nextCharacter;\n            readNextCharacter();\n            integerConstant();\n        \n        } else if (nextCharacter == '\"') {\n            currentToken = \"\";   // Don't start token with nextCharacter (the\n                                 // quote), since starting quote is not to be\n                                 // included in the String value eventually\n                                 // returned to CompilationEngine by the\n                                 // stringVal method below.\n            readNextCharacter();\n            stringConstant();\n            \n        } else /* if (nextCharacter == '{' || nextCharacter == '}' ||\n                nextCharacter == ',' || nextCharacter == ';' ||\n                nextCharacter == '(' || nextCharacter == ')' ||\n                nextCharacter == '=' || nextCharacter == '.' ||\n                nextCharacter == '-' || nextCharacter == '~' ||\n                nextCharacter == '+' || nextCharacter == '*' ||\n                nextCharacter == '&' || nextCharacter == '|' ||\n                nextCharacter == '<' || nextCharacter == '>' ||\n                nextCharacter == '[' || nextCharacter == ']') */ {\n            tokenType = TokenType.SYMBOL;\n            currentToken = \"\" + nextCharacter;\n            readNextCharacter();  // Prepare for next call to advance.\n        }\n    }\n    \n    private void commentOrDivisionOperator() {\n        \n        if (nextCharacter == '/') {\n            readNextCharacter();\n            singleLineComment();\n        \n        } else if (nextCharacter == '*') {\n            readNextCharacter();\n            multiLineComment();\n            \n        } else {\n            tokenType = TokenType.SYMBOL;\n            currentToken = \"/\";\n            // Don't need to call readNextCharacter to prepare for next call\n            // to advance, since the character after the / has already been\n            // read.\n        }\n    }\n\n    private void singleLineComment() {\n\n        if (nextCharacter == '\\n') {\n            readNextCharacter();\n            advance();  // Skip ahead to next token after comment.\n        \n        } else {\n            readNextCharacter();\n            singleLineComment();\n        }\n    }\n    \n    private void multiLineComment() {\n        \n        if (nextCharacter == '*') {\n            readNextCharacter();\n            multiLineCommentAfterStar();\n            \n        } else {\n            readNextCharacter();\n            multiLineComment();\n        }\n    }\n    \n    private void multiLineCommentAfterStar() {\n        \n        if (nextCharacter == '/') {\n            readNextCharacter();\n            advance();  // Skip ahead to next token after comment.\n            \n        } else {\n            readNextCharacter();\n            multiLineComment();\n        }\n    }\n    \n    private void keywordOrIdentifier() {\n        \n        if (nextCharacter == '_' ||\n                Character.isLetterOrDigit(nextCharacter)) {\n            currentToken += nextCharacter;\n            readNextCharacter();\n            keywordOrIdentifier();\n            \n        } else if (currentToken.equals(\"class\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.CLASS;\n            // Don't need to call readNextCharacter to prepare for advance,\n            // since the character after the keyword has already been read.\n        \n        } else if (currentToken.equals(\"static\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.STATIC;\n            // Don't need to call readNextCharacter...\n            \n        } else if (currentToken.equals(\"int\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.INT;\n            \n        } else if (currentToken.equals(\"field\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.FIELD;\n            \n        } else if (currentToken.equals(\"char\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.CHAR;\n            \n        } else if (currentToken.equals(\"boolean\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.BOOLEAN;\n           \n        } else if (currentToken.equals(\"constructor\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.CONSTRUCTOR;\n         \n        } else if (currentToken.equals(\"function\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.FUNCTION;\n         \n        } else if (currentToken.equals(\"method\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.METHOD;\n         \n        } else if (currentToken.equals(\"void\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.VOID;\n         \n        } else if (currentToken.equals(\"var\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.VAR;\n            \n        } else if (currentToken.equals(\"let\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.LET;\n            \n        } else if (currentToken.equals(\"if\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.IF;\n            \n        } else if (currentToken.equals(\"while\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.WHILE;\n            \n        } else if (currentToken.equals(\"do\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.DO;\n            \n        } else if (currentToken.equals(\"return\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.RETURN;\n            \n        } else if (currentToken.equals(\"else\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.ELSE;\n            \n        } else if (currentToken.equals(\"this\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.THIS;\n            \n        } else if (currentToken.equals(\"true\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.TRUE;\n            \n        } else if (currentToken.equals(\"false\")) {\n            tokenType = TokenType.KEYWORD;\n            keyWord = KeyWord.FALSE;\n            \n        } else {\n            tokenType = TokenType.IDENTIFIER;\n        }\n    }\n    \n    private void integerConstant() {\n        \n        if (Character.isDigit(nextCharacter)) {\n            currentToken += nextCharacter;\n            readNextCharacter();\n            integerConstant();\n            \n        } else {\n            tokenType = TokenType.INT_CONST;\n        }\n    }\n    \n    private void stringConstant() {\n        \n        if (nextCharacter == '\"') {\n            // Don't update currentToken here, since ending quote is not to be\n            // included in String returned to compilation engine by stringVal.\n            readNextCharacter();\n            tokenType = TokenType.STRING_CONST;\n        \n        } else {\n            currentToken += nextCharacter;\n            readNextCharacter();\n            stringConstant();\n        }\n    }\n    \n    /**\n     * Returns the type of the current token.\n     * \n     * @return Type of current token (e.g., TokenType.KEYWORD).\n     */\n    public TokenType tokenType() {\n        return tokenType;\n    }\n    \n    /**\n     * Returns the keyword which is the current token.  Should be called\n     * only when tokenType returns TokenType.KEYWORD.\n     * \n     * @return The current token (e.g., KeyWord.CLASS).\n     */\n    public KeyWord keyWord() {\n        return keyWord;\n    }\n    \n    /**\n     * Returns the character which is the current token.  Should be called\n     * only when tokenType returns TokenType.SYMBOL.\n     * \n     * @return The current token (a single-character symbol, e.g., '{').\n     */\n    public char symbol() {\n        return currentToken.charAt(0);\n    }\n    \n    /**\n     * Returns the identifier which is the current token.  Should be called\n     * only when tokenType returns TokenType.IDENTIFIER.\n     * \n     * @return The current token (an identifier).\n     */\n    public String identifier() {\n        return currentToken;\n    }\n    \n    /**\n     * Returns the integer value of the current token.  Should be called\n     * only when tokenType() returns TokenType.INT_CONST.\n     * \n     * @return The current token (an integer).\n     */\n    public int intVal() {\n        return Integer.parseInt(currentToken);\n    }\n    \n    /**\n     * Returns the string value of the current token.  Should be called \n     * only when tokenType() returns TokenType.STRING_CONST.\n     * \n     * @return The current token (a String).\n     */\n    public String stringVal() {\n        return currentToken;\n    }\n\n    /**\n     * Close the input file.\n     * \n     * @throws IOException If there's a problem closing the input file.\n     */\n    public void close() throws IOException {\n        input.close();\n    }\n}\n", "ons.lang.StringUtils;\r\n\r\nimport hudson.Extension;\r\n\r\nimport hudson.plugins.analysis.util.model.Priority;\r\n\r\n/**\r\n * A parser for the GHS Multi compiler warnings.\r\n *\r\n * @author Joseph Boulos\r\n */\r\n@Extension\r\npublic class GhsMultiParser extends RegexpDocumentParser {\r\n    private static final long serialVersionUID = 8149238560432255036L;\r\n    private static final String GHS_MULTI_WARNING_PATTERN = \"\\\\.(.*)\\\\,\\\\s*line\\\\s*(\\\\d+):\\\\s*(warning|error)\\\\s*([^:]+):\\\\s*(?m)([^\\\\^]*)\\\\s*\\\\^\";\r\n\r\n    /**\r\n     * Creates a new instance of {@link GhsMultiParser}.\r\n     */\r\n    public GhsMultiParser() {\r\n        super(Messages._Warnings_ghs_ParserName(),\r\n                Messages._Warnings_ghs_LinkName(),\r\n                Messages._Warnings_ghs_TrendName(),\r\n                GHS_MULTI_WARNING_PATTERN, true);\r\n    }\r\n\r\n    @Override\r\n    protected Warning createWarning(final Matcher matcher) {\r\n        String fileName = matcher.group(1);\r\n        int lineNumber = getLineNumber(matcher.group(2));\r\n        String type = StringUtils.capitalize(matcher.group(3));\r\n        String category = matcher.group(4);\r\n        String message = matcher.group(5);\r\n        Priority priority;\r\n        if (\"warning\".equalsIgnoreCase(type)) {\r\n            priority = Priority.NORMAL;\r\n        }\r\n        else {\r\n            priority = Priority.HIGH;\r\n        }\r\n        return createWarning(fileName, lineNumber, category, message, priority);\r\n    }\r\n}\r\n\r\n", " Name : com.lee.example.sh <br>\n * Create Time : Sep 9, 2016 <br>\n * Create by : jimmyblylee@126.com <br>\n * Copyright \u00a9 2006, 2016, Jimmybly Lee. All rights reserved.\n */\n/**\n * ClassName : package-info <br>\n * Description : example for spring + hibernate<br>\n * Create Time : Sep 9, 2016 <br>\n * Create by : jimmyblylee@126.com <br>\n *\n */\npackage com.lee.example.sh;", "s.getSimpleName();\n\n    public static boolean shouldLoadInApp(String url) {\n        if (url.matches(\"^(https?://)?((w{3}|preview.)?ello.(co|ninja)|(ello-webapp-epic|ello-webapp-rainbow|ello-fg-stage1|ello-fg-stage2).herokuapp.com)/?\\\\S*$\")) {\n            return true;\n        }\n        else if (url.matches(\"/\\\\S*$\")) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.apimanagement.fluent.models;\n\nimport com.azure.core.annotation.Fluent;\nimport com.azure.core.management.ProxyResource;\nimport com.azure.core.util.logging.ClientLogger;\nimport com.azure.resourcemanager.apimanagement.models.BackendCredentialsContract;\nimport com.azure.resourcemanager.apimanagement.models.BackendProperties;\nimport com.azure.resourcemanager.apimanagement.models.BackendProtocol;\nimport com.azure.resourcemanager.apimanagement.models.BackendProxyContract;\nimport com.azure.resourcemanager.apimanagement.models.BackendTlsProperties;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/** Backend details. */\n@Fluent\npublic final class BackendContractInner extends ProxyResource {\n    @JsonIgnore private final ClientLogger logger = new ClientLogger(BackendContractInner.class);\n\n    /*\n     * Backend entity contract properties.\n     */\n    @JsonProperty(value = \"properties\")\n    private BackendContractProperties innerProperties;\n\n    /**\n     * Get the innerProperties property: Backend entity contract properties.\n     *\n     * @return the innerProperties value.\n     */\n    private BackendContractProperties innerProperties() {\n        return this.innerProperties;\n    }\n\n    /**\n     * Get the url property: Runtime Url of the Backend.\n     *\n     * @return the url value.\n     */\n    public String url() {\n        return this.innerProperties() == null ? null : this.innerProperties().url();\n    }\n\n    /**\n     * Set the url property: Runtime Url of the Backend.\n     *\n     * @param url the url value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withUrl(String url) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withUrl(url);\n        return this;\n    }\n\n    /**\n     * Get the protocol property: Backend communication protocol.\n     *\n     * @return the protocol value.\n     */\n    public BackendProtocol protocol() {\n        return this.innerProperties() == null ? null : this.innerProperties().protocol();\n    }\n\n    /**\n     * Set the protocol property: Backend communication protocol.\n     *\n     * @param protocol the protocol value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withProtocol(BackendProtocol protocol) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withProtocol(protocol);\n        return this;\n    }\n\n    /**\n     * Get the title property: Backend Title.\n     *\n     * @return the title value.\n     */\n    public String title() {\n        return this.innerProperties() == null ? null : this.innerProperties().title();\n    }\n\n    /**\n     * Set the title property: Backend Title.\n     *\n     * @param title the title value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withTitle(String title) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withTitle(title);\n        return this;\n    }\n\n    /**\n     * Get the description property: Backend Description.\n     *\n     * @return the description value.\n     */\n    public String description() {\n        return this.innerProperties() == null ? null : this.innerProperties().description();\n    }\n\n    /**\n     * Set the description property: Backend Description.\n     *\n     * @param description the description value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withDescription(String description) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withDescription(description);\n        return this;\n    }\n\n    /**\n     * Get the resourceId property: Management Uri of the Resource in External System. This url can be the Arm Resource\n     * Id of Logic Apps, Function Apps or Api Apps.\n     *\n     * @return the resourceId value.\n     */\n    public String resourceId() {\n        return this.innerProperties() == null ? null : this.innerProperties().resourceId();\n    }\n\n    /**\n     * Set the resourceId property: Management Uri of the Resource in External System. This url can be the Arm Resource\n     * Id of Logic Apps, Function Apps or Api Apps.\n     *\n     * @param resourceId the resourceId value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withResourceId(String resourceId) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withResourceId(resourceId);\n        return this;\n    }\n\n    /**\n     * Get the properties property: Backend Properties contract.\n     *\n     * @return the properties value.\n     */\n    public BackendProperties properties() {\n        return this.innerProperties() == null ? null : this.innerProperties().properties();\n    }\n\n    /**\n     * Set the properties property: Backend Properties contract.\n     *\n     * @param properties the properties value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withProperties(BackendProperties properties) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withProperties(properties);\n        return this;\n    }\n\n    /**\n     * Get the credentials property: Backend Credentials Contract Properties.\n     *\n     * @return the credentials value.\n     */\n    public BackendCredentialsContract credentials() {\n        return this.innerProperties() == null ? null : this.innerProperties().credentials();\n    }\n\n    /**\n     * Set the credentials property: Backend Credentials Contract Properties.\n     *\n     * @param credentials the credentials value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withCredentials(BackendCredentialsContract credentials) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withCredentials(credentials);\n        return this;\n    }\n\n    /**\n     * Get the proxy property: Backend Proxy Contract Properties.\n     *\n     * @return the proxy value.\n     */\n    public BackendProxyContract proxy() {\n        return this.innerProperties() == null ? null : this.innerProperties().proxy();\n    }\n\n    /**\n     * Set the proxy property: Backend Proxy Contract Properties.\n     *\n     * @param proxy the proxy value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withProxy(BackendProxyContract proxy) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withProxy(proxy);\n        return this;\n    }\n\n    /**\n     * Get the tls property: Backend TLS Properties.\n     *\n     * @return the tls value.\n     */\n    public BackendTlsProperties tls() {\n        return this.innerProperties() == null ? null : this.innerProperties().tls();\n    }\n\n    /**\n     * Set the tls property: Backend TLS Properties.\n     *\n     * @param tls the tls value to set.\n     * @return the BackendContractInner object itself.\n     */\n    public BackendContractInner withTls(BackendTlsProperties tls) {\n        if (this.innerProperties() == null) {\n            this.innerProperties = new BackendContractProperties();\n        }\n        this.innerProperties().withTls(tls);\n        return this;\n    }\n\n    /**\n     * Validates the instance.\n     *\n     * @throws IllegalArgumentException thrown if the instance is not valid.\n     */\n    public void validate() {\n        if (innerProperties() != null) {\n            innerProperties().validate();\n        }\n    }\n}\n", "andom = new Random();\n\n\tpublic static String generateUniqueString(int length) {\n\t\treturn \"\" + generateRandomBetween(0, length + 1);\n\t}\n\n\tpublic static int generateRandomBetween(int min, int max) {\n\t\tint randomNumber = random.nextInt(max - min + 1);\n\t\trandomNumber += min;\n\t\treturn randomNumber;\n\t}\n}", "ons;\nimport java.util.Comparator;\n\n/**\n * Created by simonarneson on 2017-05-06.\n */\n\npublic class SortedList<E> extends ArrayList<E> {\n    private Comparator<E> sortingComparator;\n\n    public SortedList(Comparator<E> sortingComparator) {\n        this.sortingComparator = sortingComparator;\n    }\n\n    @Override\n    public boolean add(E e) {\n        if (contains(e)) {\n            remove(e);\n        }\n        Boolean res = super.add(e);\n        Collections.sort(this, sortingComparator);\n        return res;\n    }\n\n}\n", "<ArrayList<Integer>> arrayDePares){\n       \n       ArrayList<Integer> vetorProdutos = new ArrayList<Integer>();\n       ArrayList<Integer> vetorMmc = new ArrayList<Integer>();\n       ArrayList<Integer> diferenca = new ArrayList<Integer>();\n       int j = 0;\n       int soma = 0;\n       \n       //C\u00e1lculo dos produtos\n       for(int i = 0; i < arrayDePares.size(); i++){\n           vetorProdutos.add(arrayDePares.get(i).get(0) * arrayDePares.get(i).get(1));\n        }\n       \n       //C\u00e1lculo dos mmcs\n       for(int i = 0; i < arrayDePares.size(); i++){\n           Integer mmc = arrayDePares.get(i).get(0);\n           while(((mmc % arrayDePares.get(i).get(0)) + (mmc % arrayDePares.get(i).get(1))) != 0){\n             mmc++;   \n            }\n            vetorMmc.add(mmc);\n        }\n        \n        //C\u00e1lculo da diferen\u00e7a    \n       for(int i = 0; i < arrayDePares.size(); i++){\n            diferenca.add(vetorProdutos.get(i) - vetorMmc.get(i));\n        }\n        \n       //C\u00e1lculo da soma da diferen\u00e7a\n       while(j != diferenca.size()){\n           soma += diferenca.get(j);\n           j++;\n       }\n       \n       return soma;\n    }\n    \n  /*  public int obterMaiorMultiploDeTresAte(int numero) {\n  ArrayList<Integer> multiplos = new ArrayList<>(Arrays.asList(0)); // N\u00e3o tem porque fazer um ArrayList se o objetivo \u00e9 retornar apenas um valor\n\n  for (int i = 1; i <= limite; i++) {\n      if (i % 3 == 0) {\n          multiplos.add(i);\n          continue; \n        }\n    }\n\n    return multiplos;\n} */\n    \n    public int obterMaiorMultiploDeTresAte(int numero){\n        int maiorMultiplo = 1;\n        if(numero == 0){\n            maiorMultiplo = 0;\n        }else{\n        for(int i = numero; i >= 1; i--){\n            if(i % 3 == 0){\n                maiorMultiplo = i;\n                break;\n        }\n    }\n}\n    return maiorMultiplo;\n}\n\n    public ArrayList<Integer> obterMultiplosDeTresAte(int numero) {\n        ArrayList<Integer> multiplos = new ArrayList<Integer>(); // N\u00e3o declarou <Integer> depois do sinal de atribui\u00e7\u00e3o\n       for (int i = 1; i <= numero; i++) { // A vari\u00e1vel limite at\u00e9 ent\u00e3o era inexistente, j\u00e1 que o nome do par\u00e2metro \u00e9 numero\n            if(i % 3 == 0){ \n               // N\u00e3o tinha porque ter um break no c\u00f3digo, afinal, n\u00e3o h\u00e1 porque interromper o andamento dele.\n          multiplos.add(i);\n       }\n  }\n  return multiplos;\n}\n\n}\n", " org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\npublic class WeekTest {\n\n    @Test\n    public void week() throws IOException {\n        UnixStream<String> stream = UnixStream.week();\n\n        List<String> strings = stream.collect(Collectors.toList());\n        assertThat(strings).hasSize(1);\n        int week = Integer.parseInt(strings.get(0));\n\n        assertThat(week).isBetween(1, 52);\n    }\n}\n", "mport java.util.Properties;\n\n/**\n * @author Boilit\n * @see\n */\npublic interface IEngine {\n//    public abstract String getName();\n//\n//    public abstract String getVersion();\n//\n//    public abstract String getSite();\n\n    public abstract void init(String engineName,Properties properties) throws Exception;\n\n    public abstract void work(Map<String, Object> model, Writer writer) throws Exception;\n\n    public abstract void work(Map<String, Object> model, OutputStream outputStream) throws Exception;\n\n    public abstract boolean isSupportByteStream();\n\n    public abstract boolean isSupportCharStream();\n\n    public abstract void shutdown() throws Exception;\n}\n", "x.inject.Named;\nimport javax.transaction.Transactional;\n\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.data.repository.query.Param;\n\nimport com.example.crud.entity.Foo;\n\n@Named\npublic interface FooRepository extends JpaRepository<Foo, Long> {\n\tList<Foo> findByName(String name);\n\tOptional<Foo> findById(Long id);\n\tpublic List<Foo> findByNameLike(@Param(\"name\") String name);\n\tpublic List<Foo> findAll();\n\t\n\t@Transactional\n\tLong deleteFooById(Long id);\n}\n", "http://opensource.org/licenses/mit-license.php\n */\npackage org.deviceconnect.android.manager.receiver;\n\nimport org.deviceconnect.android.manager.DConnectService;\n\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\n\n/**\n * apk\u306e\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u3068\u30a2\u30f3\u30a4\u30f3\u30b9\u30c8\u30fc\u30eb\u306e\u30d6\u30ed\u30fc\u30c9\u30ad\u30e3\u30b9\u30c8\u3092\u53d7\u3051\u53d6\u308b\u30ec\u30b7\u30fc\u30d0\u30fc.\n * @author NTT DOCOMO, INC.\n */\npublic class PackageManageReceiver extends BroadcastReceiver {\n    /**\n     * DConnectService\u306b\u4f1d\u3048\u308b.\n     * @param context \u30b3\u30f3\u30c6\u30ad\u30b9\u30c8\n     * @param intent \u30ea\u30af\u30a8\u30b9\u30c8\n     */\n    @Override\n    public void onReceive(final Context context, final Intent intent) {\n        Intent service = new Intent(intent);\n        service.setClass(context, DConnectService.class);\n        context.startService(service);\n    }\n}\n", "ebaran.proxy.Variant;\nimport com.aldebaran.proxy.ALProxy;\n\npublic class ALSoundDetectionProxy extends ALProxy {\n \tstatic {\n\t  System.loadLibrary(\"jnaoqi\");\n\t}\n\n \tpublic ALProxy proxy;\n\n\t/// <summary>\n\t/// Default Constructor.\n\t/// </summary>\n\tpublic ALSoundDetectionProxy(String ip, int port) {\n\t\tsuper(\"ALSoundDetection\", ip, port);\n\t}\n    /// <summary>\n    /// Exits and unregisters the module.\n    /// </summary>\n\n    public void exit()\n    {\n\tVariant result = call(\"exit\" );\n\t\t// no return value\n    }\n    /// <summary>\n    /// Gets the name of the parent broker.\n    /// </summary>\n    /// <returns> The name of the parent broker. </returns>\n\n    public String getBrokerName()\n    {\n\tVariant result = call(\"getBrokerName\" );\n\t    \treturn  result.toString();\n    }\n    /// <summary>\n    /// Gets the current period.\n    /// </summary>\n    /// <returns> Refresh period (in milliseconds). </returns>\n\n    public int getCurrentPeriod()\n    {\n\tVariant result = call(\"getCurrentPeriod\" );\n\t    \treturn  result.toInt();\n    }\n    /// <summary>\n    /// Gets the current precision.\n    /// </summary>\n    /// <returns> Precision of the extractor. </returns>\n\n    public float getCurrentPrecision()\n    {\n\tVariant result = call(\"getCurrentPrecision\" );\n\t    \treturn  result.toFloat();\n    }\n    /// <summary>\n    /// DEPRECATED - Get description of events\n    /// </summary>\n    /// <param name=\"type\"> Name of detector. For now only one detector is available : \\\"soundDetection/SoundDetector\\\". </param>\n    /// <param name=\"nameDesc\"> Name of the description : 'default' if not defined </param>\n    /// <returns> Return description for all detections </returns>\n\n    \n    \n    \n    \n    public Variant getDescription( String type,  String nameDesc)\n    {\n\tVariant vtype;\n\tvtype = new Variant(type);\n\tVariant vnameDesc;\n\tvnameDesc = new Variant(nameDesc);\n\tVariant result = call(\"getDescription\" ,vtype, vnameDesc);\n\t    \treturn  result;\n    }\n    /// <summary>\n    /// DEPRECATED - Get index of events detected\n    /// </summary>\n    /// <param name=\"type\"> Name of detector. For now only one detector is available : \\\"soundDetection/SoundDetector\\\". </param>\n    /// <returns> Return index of all detections of the current audio buffer </returns>\n\n    \n    \n    public Variant getEvents( String type)\n    {\n\tVariant vtype;\n\tvtype = new Variant(type);\n\tVariant result = call(\"getEvents\" ,vtype);\n\t    \treturn  result;\n    }\n    /// <summary>\n    /// Retrieves a method's description.\n    /// </summary>\n    /// <param name=\"methodName\"> The name of the method. </param>\n    /// <returns> A structure containing the method's description. </returns>\n\n    \n    \n    public Variant getMethodHelp( String methodName)\n    {\n\tVariant vmethodName;\n\tvmethodName = new Variant(methodName);\n\tVariant result = call(\"getMethodHelp\" ,vmethodName);\n\t    \treturn  result;\n    }\n    /// <summary>\n    /// Retrieves the module's method list.\n    /// </summary>\n    /// <returns> An array of method names. </returns>\n\n    public String[] getMethodList()\n    {\n\tVariant result = call(\"getMethodList\" );\n\t    \treturn (String[]) result.toStringArray();\n    }\n    /// <summary>\n    /// Retrieves the module's description.\n    /// </summary>\n    /// <returns> A structure describing the module. </returns>\n\n    public Variant getModuleHelp()\n    {\n\tVariant result = call(\"getModuleHelp\" );\n\t    \treturn  result;\n    }\n    /// <summary>\n    /// Gets the period for a specific subscription.\n    /// </summary>\n    /// <param name=\"name\"> Name of the module which has subscribed. </param>\n    /// <returns> Refresh period (in milliseconds). </returns>\n\n    \n    \n    public int getMyPeriod( String name)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant result = call(\"getMyPeriod\" ,vname);\n\t    \treturn  result.toInt();\n    }\n    /// <summary>\n    /// Gets the precision for a specific subscription.\n    /// </summary>\n    /// <param name=\"name\"> name of the module which has subscribed </param>\n    /// <returns> precision of the extractor </returns>\n\n    \n    \n    public float getMyPrecision( String name)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant result = call(\"getMyPrecision\" ,vname);\n\t    \treturn  result.toFloat();\n    }\n    /// <summary>\n    /// Get the list of values updated in ALMemory.\n    /// </summary>\n    /// <returns> Array of values updated by this extractor in ALMemory </returns>\n\n    public String[] getOutputNames()\n    {\n\tVariant result = call(\"getOutputNames\" );\n\t    \treturn (String[]) result.toStringArray();\n    }\n    /// <summary>\n    /// Gets the parameters given by the module.\n    /// </summary>\n    /// <returns> Array of names and parameters of all subscribers. </returns>\n\n    public Variant getSubscribersInfo()\n    {\n\tVariant result = call(\"getSubscribersInfo\" );\n\t    \treturn  result;\n    }\n    /// <summary>\n    /// Gets the method usage string. This summarises how to use the method.\n    /// </summary>\n    /// <param name=\"name\"> The name of the method. </param>\n    /// <returns> A string that summarises the usage of the method. </returns>\n\n    \n    \n    public String getUsage( String name)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant result = call(\"getUsage\" ,vname);\n\t    \treturn  result.toString();\n    }\n    /// <summary>\n    /// Returns true if the method is currently running.\n    /// </summary>\n    /// <param name=\"id\"> The ID of the method that was returned when calling the method using 'post' </param>\n    /// <returns> True if the method is currently running </returns>\n\n    \n    \n    public Boolean isRunning( int id)\n    {\n\tVariant vid;\n\tvid = new Variant(id);\n\tVariant result = call(\"isRunning\" ,vid);\n\t    \treturn  result.toBoolean();\n    }\n    /// <summary>\n    /// Just a ping. Always returns true\n    /// </summary>\n    /// <returns> returns true </returns>\n\n    public Boolean ping()\n    {\n\tVariant result = call(\"ping\" );\n\t    \treturn  result.toBoolean();\n    }\n    /// <summary>\n    /// enable/disable the printing of some debug information\n    /// </summary>\n    /// <param name=\"nbOfChannels\"> Provides the number of channels of the buffer. </param>\n    /// <param name=\"nbOfSamplesByChannel\"> Provides the number of samples by channel. </param>\n    /// <param name=\"timestamp\"> Provides the timestamp of the buffer. </param>\n    /// <param name=\"buffer\"> Provides the audio buffer as an ALValue. </param>\n\n    \n    \n    \n    \n    \n    \n    \n    \n    public void processRemote( int nbOfChannels,  int nbOfSamplesByChannel,  Variant timestamp,  Variant buffer)\n    {\n\tVariant vnbOfChannels;\n\tvnbOfChannels = new Variant(nbOfChannels);\n\tVariant vnbOfSamplesByChannel;\n\tvnbOfSamplesByChannel = new Variant(nbOfSamplesByChannel);\n\tVariant vtimestamp;\n\tvtimestamp = new Variant(timestamp);\n\tVariant vbuffer;\n\tvbuffer = new Variant(buffer);\n\tVariant result = call(\"processRemote\" ,vnbOfChannels, vnbOfSamplesByChannel, vtimestamp, vbuffer);\n\t\t// no return value\n    }\n    /// <summary>\n    /// enable/disable the printing of some debug information\n    /// </summary>\n    /// <param name=\"nbOfChannels\"> Provides the number of channels of the buffer. </param>\n    /// <param name=\"nbOfSamplesByChannel\"> Provides the number of samples by channel. </param>\n    /// <param name=\"buffer\"> Provides the audio buffer as an ALValue. </param>\n\n    \n    \n    \n    \n    \n    \n    public void processSoundRemote( int nbOfChannels,  int nbOfSamplesByChannel,  Variant buffer)\n    {\n\tVariant vnbOfChannels;\n\tvnbOfChannels = new Variant(nbOfChannels);\n\tVariant vnbOfSamplesByChannel;\n\tvnbOfSamplesByChannel = new Variant(nbOfSamplesByChannel);\n\tVariant vbuffer;\n\tvbuffer = new Variant(buffer);\n\tVariant result = call(\"processSoundRemote\" ,vnbOfChannels, vnbOfSamplesByChannel, vbuffer);\n\t\t// no return value\n    }\n    /// <summary>\n    /// enable/disable the printing of some debug information\n    /// </summary>\n    /// <param name=\"bSetOrUnset\"> enable the functionnality when true. </param>\n\n    \n    \n    public void setDebugMode( Boolean bSetOrUnset)\n    {\n\tVariant vbSetOrUnset;\n\tvbSetOrUnset = new Variant(bSetOrUnset);\n\tVariant result = call(\"setDebugMode\" ,vbSetOrUnset);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Set detection parameters\n    /// </summary>\n    /// <param name=\"paraDetect\"> Name of the parameter. Please refer to the example below for the available parameters. </param>\n    /// <param name=\"param\"> Value of the parameter. </param>\n\n    \n    \n    \n    \n    public void setParameter( String paraDetect,  float param)\n    {\n\tVariant vparaDetect;\n\tvparaDetect = new Variant(paraDetect);\n\tVariant vparam;\n\tvparam = new Variant(param);\n\tVariant result = call(\"setParameter\" ,vparaDetect, vparam);\n\t\t// no return value\n    }\n    /// <summary>\n    /// DEPRECATED - Set detection parameters\n    /// </summary>\n    /// <param name=\"type\"> Name of detector. For now only one detector is available : \\\"soundDetection/SoundDetector\\\". </param>\n    /// <param name=\"paraDetect\"> Name of the parameter. Please refer to the example below for the available parameters. </param>\n    /// <param name=\"param\"> Value of the parameter. </param>\n\n    \n    \n    \n    \n    \n    \n    public void setParameter( String type,  String paraDetect,  float param)\n    {\n\tVariant vtype;\n\tvtype = new Variant(type);\n\tVariant vparaDetect;\n\tvparaDetect = new Variant(paraDetect);\n\tVariant vparam;\n\tvparam = new Variant(param);\n\tVariant result = call(\"setParameter\" ,vtype, vparaDetect, vparam);\n\t\t// no return value\n    }\n    /// <summary>\n    /// returns true if the method is currently running\n    /// </summary>\n    /// <param name=\"id\"> the ID of the method to wait for </param>\n\n    \n    \n    public void stop( int id)\n    {\n\tVariant vid;\n\tvid = new Variant(id);\n\tVariant result = call(\"stop\" ,vid);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Subscribes to the extractor. This causes the extractor to start writing information to memory using the keys described by getOutputNames(). These can be accessed in memory using ALMemory.getData(\\\"keyName\\\"). In many cases you can avoid calling subscribe on the extractor by just calling ALMemory.subscribeToEvent() supplying a callback method. This will automatically subscribe to the extractor for you.\n    /// </summary>\n    /// <param name=\"name\"> Name of the module which subscribes. </param>\n    /// <param name=\"period\"> Refresh period (in milliseconds) if relevant. </param>\n    /// <param name=\"precision\"> Precision of the extractor if relevant. </param>\n\n    \n    \n    \n    \n    \n    \n    public void subscribe( String name,  int period,  float precision)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant vperiod;\n\tvperiod = new Variant(period);\n\tVariant vprecision;\n\tvprecision = new Variant(precision);\n\tVariant result = call(\"subscribe\" ,vname, vperiod, vprecision);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Subscribes to the extractor. This causes the extractor to start writing information to memory using the keys described by getOutputNames(). These can be accessed in memory using ALMemory.getData(\\\"keyName\\\"). In many cases you can avoid calling subscribe on the extractor by just calling ALMemory.subscribeToEvent() supplying a callback method. This will automatically subscribe to the extractor for you.\n    /// </summary>\n    /// <param name=\"name\"> Name of the module which subscribes. </param>\n\n    \n    \n    public void subscribe( String name)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant result = call(\"subscribe\" ,vname);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Unsubscribes from the extractor.\n    /// </summary>\n    /// <param name=\"name\"> Name of the module which had subscribed. </param>\n\n    \n    \n    public void unsubscribe( String name)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant result = call(\"unsubscribe\" ,vname);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Updates the period if relevant.\n    /// </summary>\n    /// <param name=\"name\"> Name of the module which has subscribed. </param>\n    /// <param name=\"period\"> Refresh period (in milliseconds). </param>\n\n    \n    \n    \n    \n    public void updatePeriod( String name,  int period)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant vperiod;\n\tvperiod = new Variant(period);\n\tVariant result = call(\"updatePeriod\" ,vname, vperiod);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Updates the precision if relevant.\n    /// </summary>\n    /// <param name=\"name\"> Name of the module which has subscribed. </param>\n    /// <param name=\"precision\"> Precision of the extractor. </param>\n\n    \n    \n    \n    \n    public void updatePrecision( String name,  float precision)\n    {\n\tVariant vname;\n\tvname = new Variant(name);\n\tVariant vprecision;\n\tvprecision = new Variant(precision);\n\tVariant result = call(\"updatePrecision\" ,vname, vprecision);\n\t\t// no return value\n    }\n    /// <summary>\n    /// Returns the version of the module.\n    /// </summary>\n    /// <returns> A string containing the version of the module. </returns>\n\n    public String version()\n    {\n\tVariant result = call(\"version\" );\n\t    \treturn  result.toString();\n    }\n    /// <summary>\n    /// Wait for the end of a long running method that was called using 'post'\n    /// </summary>\n    /// <param name=\"id\"> The ID of the method that was returned when calling the method using 'post' </param>\n    /// <param name=\"timeoutPeriod\"> The timeout period in ms. To wait indefinately, use a timeoutPeriod of zero. </param>\n    /// <returns> True if the timeout period terminated. False if the method returned. </returns>\n\n    \n    \n    \n    \n    public Boolean wait( int id,  int timeoutPeriod)\n    {\n\tVariant vid;\n\tvid = new Variant(id);\n\tVariant vtimeoutPeriod;\n\tvtimeoutPeriod = new Variant(timeoutPeriod);\n\tVariant result = call(\"wait\" ,vid, vtimeoutPeriod);\n\t    \treturn  result.toBoolean();\n    }\n}\n\n\n", "TransferPOJO {\n\n  private String coin;\n\n  private BigDecimal size;\n\n  private String source;\n\n  private String destination;\n\n  public FtxSubAccountTransferPOJO(\n      String coin, BigDecimal size, String source, String destination) {\n    this.coin = coin;\n    this.size = size;\n    this.source = source;\n    this.destination = destination;\n  }\n\n  public String getCoin() {\n    return coin;\n  }\n\n  public void setCoin(String coin) {\n    this.coin = coin;\n  }\n\n  public BigDecimal getSize() {\n    return size;\n  }\n\n  public void setSize(BigDecimal size) {\n    this.size = size;\n  }\n\n  public String getSource() {\n    return source;\n  }\n\n  public void setSource(String source) {\n    this.source = source;\n  }\n\n  public String getDestination() {\n    return destination;\n  }\n\n  public void setDestination(String destination) {\n    this.destination = destination;\n  }\n\n  @Override\n  public String toString() {\n    return \"FtxSubAccountTransferPOJO{\"\n        + \"coin='\"\n        + coin\n        + '\\''\n        + \", size=\"\n        + size\n        + \", source='\"\n        + source\n        + '\\''\n        + \", destination='\"\n        + destination\n        + '\\''\n        + '}';\n  }\n}\n", "ine.impl.test.PluggableActivitiTestCase;\nimport org.activiti.engine.runtime.ProcessInstance;\nimport org.activiti.engine.task.Task;\nimport org.activiti.engine.test.Deployment;\n\npublic class ActivitiDynamicExternalFormTest extends PluggableActivitiTestCase {\n\t@Deployment(resources = { \"test/FormKey.bpmn20.xml\",\n\t\t\t\"test/start.form\", \"test/first-step.form\",\n\t\t\t\"test/second-step.form\" })\n\tpublic void testTaskFormsWithVacationRequestProcess() {\n\n\t\t// Get start form\n\t\tString procDefId = repositoryService.createProcessDefinitionQuery()\n\t\t\t\t.singleResult().getId();\n\t\tObject startForm = formService.getRenderedStartForm(procDefId);\n\t\tassertNotNull(startForm);\n\n\t\tassertEquals(\"<input id=\\\"start-name\\\" />\", startForm);\n\n\t\tMap<String, String> formProperties = new HashMap<String, String>();\n\t\tformProperties.put(\"startName\", \"yangboz\");\n\t\tProcessInstance processInstance = formService.submitStartFormData(\n\t\t\t\tprocDefId, formProperties);\n\t\tassertNotNull(processInstance);\n\n\t\tTask task = taskService.createTaskQuery().taskAssignee(\"user1\")\n\t\t\t\t.singleResult();\n\t\tObject renderedTaskForm = formService.getRenderedTaskForm(task.getId());\n\t\tassertEquals(\n\t\t\t\t\"<input id=\\\"start-name\\\" value=\\\"yangboz\\\" />\\n<input id=\\\"first-name\\\" />\",\n\t\t\t\trenderedTaskForm);\n\n\t\tformProperties = new HashMap<String, String>();\n\t\tformProperties.put(\"firstName\", \"yangboz\");\n\t\tformService.submitTaskFormData(task.getId(), formProperties);\n\n\t\ttask = taskService.createTaskQuery().taskAssignee(\"user2\")\n\t\t\t\t.singleResult();\n\t\tassertNotNull(task);\n\t\trenderedTaskForm = formService.getRenderedTaskForm(task.getId());\n\t\tassertEquals(\"<input id=\\\"first-name\\\" value=\\\"yangboz\\\" />\",\n\t\t\t\trenderedTaskForm);\n\t}\n\n}\n", "badlogic.gdx.math.Interpolation;\nimport com.badlogic.gdx.scenes.scene2d.actions.Actions;\n\n\npublic abstract class Mushroom extends MovingActor {\n\n\tpublic Mushroom(World world, float x, float y, float max_velocity) {\n\t\tsuper(world, x, y, max_velocity);\n\t}\n\n\tpublic void appear() {\n\t\tthis.setVisible(true);\n\t\tthis.addAction(Actions.sequence(Actions.moveTo(this.getX(), this.getY() + this.getHeight(),\n\t\t\t\t0.3f, Interpolation.linear), MoveableActions.startMovingAction(this)));\n\t}\n\t\n\tpublic abstract void dispose();\n\n}\n", "nterface SupplierDetailsMapper {\n\tList<SupplierDetails> all();\n\n\tint delById(Integer id);\n\n\tint update(SupplierDetails supplierDetails);\n\n\tint add(SupplierDetails supplierDetails);\n\n\tSupplierDetails selectById(Integer id);\n\n\tList<SupplierDetails> selectTab();\n}\n", "g from\n * Hewlett-Packard Company (now HP Inc.) and Hewlett Packard Enterprise Company.  As of September 1, 2017,\n * the Material is now offered by Micro Focus, a separately owned and operated company.  Any reference to the HP\n * and Hewlett Packard Enterprise/HPE marks is historical in nature, and the HP and Hewlett Packard Enterprise/HPE\n * marks are the property of their respective owners.\n * __________________________________________________________________\n * MIT License\n *\n * (c) Copyright 2012-2019 Micro Focus or one of its affiliates.\n *\n * The only warranties for products and services of Micro Focus and its affiliates\n * and licensors (\"Micro Focus\") are set forth in the express warranty statements\n * accompanying such products and services. Nothing herein should be construed as\n * constituting an additional warranty. Micro Focus shall not be liable for technical\n * or editorial errors or omissions contained herein.\n * The information contained herein is subject to change without notice.\n * ___________________________________________________________________\n */\n\npackage com.microfocus.application.automation.tools.pc;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.HttpVersion;\nimport org.apache.http.client.ClientProtocolException;\nimport org.apache.http.client.methods.HttpRequestBase;\nimport org.apache.http.entity.StringEntity;\nimport org.apache.http.message.BasicHttpResponse;\n\nimport com.microfocus.adm.performancecenter.plugins.common.pcentities.*;\n\nimport com.microfocus.adm.performancecenter.plugins.common.rest.PcRestProxy;\n\nimport static com.microfocus.adm.performancecenter.plugins.common.pcentities.RunState.*;\n\npublic class MockPcRestProxyBadResponses extends PcRestProxy {\n    \n    private static Iterator<RunState> runState = initializeRunStateIterator();\n    \n    public MockPcRestProxyBadResponses(String webProtocol, String pcServerName, String almDomain, String almProject,PrintStream logger) throws PcException {\n        super(webProtocol, pcServerName, almDomain, almProject,null,null,null);\n    }\n\n    @Override\n    protected HttpResponse executeRequest(HttpRequestBase request) throws PcException, ClientProtocolException,\n            IOException {\n        HttpResponse response = null;\n        String requestUrl = request.getURI().toString();\n        if (requestUrl.equals(String.format(AUTHENTICATION_LOGIN_URL, PcTestBase.WEB_PROTOCOL, PcTestBase.PC_SERVER_NAME))) {\n            throw new PcException(PcTestBase.pcAuthenticationFailureMessage);\n        } else if (requestUrl.equals(String.format(getBaseURL() + \"/%s\", RUNS_RESOURCE_NAME))){\n            throw new PcException(PcTestBase.pcNoTimeslotExceptionMessage);\n        } else if (requestUrl.equals(String.format(getBaseURL() + \"/%s/%s\", RUNS_RESOURCE_NAME, PcTestBase.RUN_ID_WAIT))) {\n            response = getOkResponse();\n            response.setEntity(new StringEntity(PcTestBase.runResponseEntity.replace(\"*\", runState.next().value())));\n            if (!runState.hasNext())\n                runState = initializeRunStateIterator();\n        } else if (requestUrl.equals(String.format(getBaseURL() + \"/%s/%s/%s\", RUNS_RESOURCE_NAME, PcTestBase.RUN_ID,\n            RESULTS_RESOURCE_NAME))) {\n            response = getOkResponse();\n            response.setEntity(new StringEntity(PcTestBase.emptyResultsEntity));\n        } else if (requestUrl.equals(String.format(getBaseURL() + \"/%s/%s/%s\", RUNS_RESOURCE_NAME, PcTestBase.RUN_ID, PcTestBase.STOP_MODE))) {\n            throw new PcException(PcTestBase.pcStopNonExistRunFailureMessage);\n        }\n        if (response == null)\n            throw new PcException(String.format(\"%s %s is not recognized by PC Rest Proxy\", request.getMethod(), requestUrl));\n        return response;\n    }\n    \n    private HttpResponse getOkResponse(){\n        \n        return new BasicHttpResponse(HttpVersion.HTTP_1_1, HttpStatus.SC_OK, \"OK\");\n    }\n    \n    private static Iterator<RunState> initializeRunStateIterator() {\n\n        return Arrays.asList(INITIALIZING, RUNNING, RUN_FAILURE).iterator();\n    }\n}\n", "\r\n}\r\n", "h.hppc.LongOpenHashSet;\nimport com.carrotsearch.hppc.cursors.LongObjectCursor;\nimport com.google.common.io.Files;\nimport net.jpountz.lz4.LZ4BlockInputStream;\nimport net.jpountz.lz4.LZ4BlockOutputStream;\n\nimport java.io.*;\nimport java.nio.ByteBuffer;\nimport java.nio.LongBuffer;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Comparator;\n\n/**\n * Created by Saeed on 8/8/14.\n */\npublic class Graph {\n    LongOpenHashSet vertex_set = new LongOpenHashSet();\n    public long[] vertices;\n    LongObjectOpenHashMap<long[]> adjArray = new LongObjectOpenHashMap<long[]>(1024, 0.5f);\n\n    LongObjectOpenHashMap<LongOpenHashSet> adjSet = new LongObjectOpenHashMap<LongOpenHashSet>(1024, 0.5f);\n\n    private void Graph() {\n    }\n\n    private void addEdge(long v, long w) {\n        vertex_set.add(v, w);\n\n        adjSet.putIfAbsent(v, new LongOpenHashSet());\n        adjSet.putIfAbsent(w, new LongOpenHashSet());\n\n        adjSet.get(v).add(w);\n        adjSet.get(w).add(v);\n    }\n\n    private void update() {\n        System.out.println(\"Optimizing graph structure.\");\n        adjArray = new LongObjectOpenHashMap<long[]>(adjSet.size());\n        vertices = vertex_set.toArray();\n        Arrays.sort(vertices);\n        for (long cursor : vertices) {\n            adjArray.put(cursor, adjSet.get(cursor).toArray());\n            Arrays.sort(adjArray.get(cursor));\n            adjSet.remove(cursor);\n        }\n    }\n\n    public long[] getNeighbors(long v) {\n        return adjArray.get(v);\n    }\n\n    public static Graph buildFromEdgeListFile(String path) throws IOException {\n        Graph g = new Graph();\n        BufferedReader br = new BufferedReader(new FileReader(path));\n        String line;\n        while ((line = br.readLine()) != null) {\n            if (line.isEmpty())\n                continue;\n            if (line.startsWith(\"#\")) {\n                System.err.printf(\"Skipped a line: [%s]\\n\", line);\n                continue;\n            }\n            String[] tokens = line.split(\"\\\\s+\");\n            if (tokens.length < 2) {\n                System.err.printf(\"Skipped a line: [%s]\\n\", line);\n                continue;\n            }\n            long src = Long.parseLong(tokens[0]);\n            long dest = Long.parseLong(tokens[1]);\n            g.addEdge(src, dest);\n        }\n        g.update();\n        br.close();\n        return g;\n    }\n\n    public String getInfo() {\n        String info = \"#Nodes: \" + String.format(\"%,d\", vertices.length) + \"\\n\";\n        long edges = 0;\n        for (LongObjectCursor<long[]> x : adjArray)\n            edges += x.value.length;\n        info += \"#Edges: \" + String.format(\"%,d\", edges) + \"\\n\";\n        double mean_degree = edges / (double) vertices.length;\n        info += \"AVG(degree): \" + String.format(\"%.2f\\n\", mean_degree);\n        double variance = 0;\n        for (LongObjectCursor<long[]> x : adjArray)\n            variance += (mean_degree - x.value.length) * (mean_degree - x.value.length);\n        info += \"STD(degree): \" + String.format(\"%.2f\\n\", Math.sqrt(variance / vertices.length));\n        return info;\n    }\n\n    public double getAverageDegree() {\n        long edges = 0;\n        for (LongObjectCursor<long[]> x : adjArray)\n            edges += x.value.length;\n        return edges / (double) vertices.length;\n    }\n\n    public void writeToStream(OutputStream ostream) throws IOException {\n        LZ4BlockOutputStream lzs = new LZ4BlockOutputStream(ostream);\n        DataOutputStream dstream = new DataOutputStream(lzs);\n        dstream.writeInt(vertices.length);\n        for (long v : vertices) {\n            dstream.writeLong(v);\n            dstream.writeInt(getNeighbors(v).length);\n            for (long l : getNeighbors(v))\n                dstream.writeLong(l);\n        }\n        dstream.close();\n        lzs.close();\n        ostream.flush();\n    }\n\n    public static Graph readFromStream(InputStream istream) throws IOException {\n        LZ4BlockInputStream lzs = new LZ4BlockInputStream(istream);\n        DataInputStream stream = new DataInputStream(lzs);\n        int size = stream.readInt();//(int) lb.get();\n        Graph g = new Graph();\n        for (int i = 0; i < size; i++) {\n            long v = stream.readLong();//lb.get();\n            g.vertex_set.add(v);\n            long[] arr = new long[stream.readInt()];\n            for (int x = 0; x < arr.length; x++)\n                arr[x] = stream.readLong();\n            g.adjArray.put(v, arr);\n        }\n        g.vertices = g.vertex_set.toArray();\n        return g;\n    }\n\n    public byte[] toBytes() throws IOException {\n        ByteArrayOutputStream bos = new ByteArrayOutputStream(1024 * 1024);\n        writeToStream(bos);\n        bos.close();\n        return bos.toByteArray();\n    }\n\n    public static Graph fromBytes(byte[] bytes) throws IOException {\n        ByteArrayInputStream bis = new ByteArrayInputStream(bytes);\n        return readFromStream(bis);\n    }\n\n    public static void layEdgeListToDisk(String in_path, String out_dir, int bucket_count) throws IOException {\n        //clear the directory\n        if (new File(out_dir).exists())\n            Util.deleteDirectory(new File(out_dir));\n        new File(out_dir).mkdir();\n        new File(out_dir + \"/tmp/\").mkdir();\n        new File(out_dir + \"/graph/\").mkdir();\n\n        DataOutputStream[] ostreams = new DataOutputStream[bucket_count];\n        for (int i = 0; i < bucket_count; i++)\n            ostreams[i] = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(out_dir + \"/tmp/\" + String.valueOf(i) + \".bin\"), 512 * 1024));\n\n        BufferedReader br = new BufferedReader(new FileReader(in_path));\n        String line;\n        while ((line = br.readLine()) != null) {\n            if (line.isEmpty())\n                continue;\n            if (line.startsWith(\"#\")) {\n                System.err.printf(\"Skipped a line: [%s]\\n\", line);\n                continue;\n            }\n            String[] tokens = line.split(\"\\\\s+\");\n            if (tokens.length < 2) {\n                System.err.printf(\"Skipped a line: [%s]\\n\", line);\n                continue;\n            }\n            long src = Long.parseLong(tokens[0]);\n            long dest = Long.parseLong(tokens[1]);\n\n            int bucket = Util.longToBucket(src, bucket_count);\n            if (bucket < 0) {\n                System.out.printf(\"%d %d\\n\", src, bucket);\n                Util.longToBucket(src, bucket_count);\n            }\n            ostreams[bucket].writeLong(src);\n            ostreams[bucket].writeLong(dest);\n        }\n\n        for (DataOutputStream s : ostreams)\n            s.close();\n\n        for (int i = 0; i < bucket_count; i++)\n            ostreams[i] = new DataOutputStream(new BufferedOutputStream(new FileOutputStream(out_dir + \"/graph/\" + String.valueOf(i) + \".gseg\"), 512 * 1024));\n\n\n        for (int i = 0; i < bucket_count; i++) {\n            byte[] bb = Files.toByteArray(new File(out_dir + \"/tmp/\" + String.valueOf(i) + \".bin\"));\n            LongBuffer buffer = ByteBuffer.wrap(bb).asLongBuffer();\n            Graph g = new Graph();\n            while (buffer.hasRemaining()) {\n                long src = buffer.get();\n                long dest = buffer.get();\n                g.vertex_set.add(src);\n                if (!g.adjSet.containsKey(src))\n                    g.adjSet.put(src, new LongOpenHashSet());\n                g.adjSet.get(src).add(dest);\n            }\n            g.update();\n            for (LongObjectCursor<long[]> cur : g.adjArray) {\n                ostreams[i].writeLong(cur.key);\n                ostreams[i].writeInt(cur.value.length);\n                for (long l : cur.value)\n                    ostreams[i].writeLong(l);\n            }\n            ostreams[i].close();\n            System.out.println(\"Done: \" + out_dir + \"/graph/\" + String.valueOf(i) + \".gseg\");\n            new File(out_dir + \"/tmp/\" + String.valueOf(i) + \".bin\").delete();\n        }\n    }\n\n    public static Graph loadFromSegment(String root_dir, int number) throws IOException {\n        Graph g = new Graph();\n        byte[] bb = Files.toByteArray(new File(root_dir + \"/graph/\" + String.valueOf(number) + \".gseg\"));\n        ByteBuffer buffer = ByteBuffer.wrap(bb);\n        while (buffer.hasRemaining()) {\n            long src = buffer.getLong();\n            int count = buffer.getInt();\n            g.vertex_set.add(src);\n            long[] array = new long[count];\n            for (int i = 0; i < count; i++)\n                array[i] = buffer.getLong();\n            g.adjArray.put(src, array);\n        }\n        g.vertices = g.vertex_set.toArray();\n        Arrays.sort(g.vertices);\n        return g;\n    }\n\n    class VComparer implements Comparator<Long> {\n        public int compare(Long l1, Long l2) {\n            return getNeighbors(l2).length - getNeighbors(l1).length;\n        }\n    }\n\n    public ArrayList<Long> getVerticesSortedByDegree() {\n        ArrayList<Long> longs = new ArrayList<Long>();\n        for (long l : vertices)\n            longs.add(l);\n        Collections.sort(longs, new VComparer());\n        return longs;\n    }\n\n\n}\n", "on 2.0 (the \"License\"); you may not\n * use this file except in compliance with the License. You may obtain a copy of\n * the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations under\n * the License.\n */\npackage cc.tinker.entry.encrypt;\n\n/**\n * <p>\n * \u7b97\u6cd5\u7c7b\u578b\u679a\u4e3e\u7c7b\n * </p>\n *\n */\npublic enum Algorithm {\n\tDES(\"DES\", \"DES encrypt\"), AES(\"AES\", \"AES encrypt\"), BLOWFISH(\"BLOWFISH\", \"Blowfish encrypt\"), RC2(\"RC2\",\n\t\t\t\"RC2 encrypt\"), RC4(\"RC4\", \"RC4 encrypt\");\n\n\t/** \u4e3b\u952e */\n\tprivate final String key;\n\n\t/** \u63cf\u8ff0 */\n\tprivate final String desc;\n\n\tAlgorithm(final String key, final String desc) {\n\t\tthis.key = key;\n\t\tthis.desc = desc;\n\t}\n\n\tpublic String getKey() {\n\t\treturn this.key;\n\t}\n\n\tpublic String getDesc() {\n\t\treturn this.desc;\n\t}\n\n\tpublic static Algorithm convert(String encryptAlgorithm) {\n\t\tAlgorithm algorithm = Algorithm.RC4;\n\t\tif (null != encryptAlgorithm) {\n\t\t\tAlgorithm[] algs = Algorithm.values();\n\t\t\tfor (Algorithm alg : algs) {\n\t\t\t\tif (alg.getKey().equals(encryptAlgorithm)) {\n\t\t\t\t\talgorithm = alg;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn algorithm;\n\t}\n\n}\n", "est;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.web.client.RestTemplateBuilder;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.springframework.http.HttpHeaders.CONTENT_TYPE;\n\n@Order(4)\nclass EmbeddedSchemaRegistryTest extends AbstractEmbeddedKafkaTest {\n\n    @Value(\"${embedded.kafka.schema-registry.host}\")\n    private String host;\n\n    @Value(\"${embedded.kafka.schema-registry.port}\")\n    private Integer port;\n\n    @Test\n    void schemasTopicAvailable() throws Exception {\n        assertThatTopicExists(\"_schemas\");\n    }\n\n    @Test\n    void schemaCreation() {\n        TestRestTemplate restTemplate = new TestRestTemplate(new RestTemplateBuilder()\n                .rootUri(String.format(\"http://%s:%d\", host, port)));\n\n        HttpHeaders headers = new HttpHeaders();\n        headers.set(CONTENT_TYPE, \"application/vnd.schemaregistry.v1+json\");\n\n        HttpEntity<String> request = new HttpEntity<>(\"{\\\"schema\\\": \\\"{\\\\\\\"type\\\\\\\": \\\\\\\"string\\\\\\\"}\\\"}\", headers);\n\n        ResponseEntity<String> response = restTemplate.postForEntity(\"/subjects/test-subject/versions\", request, String.class);\n\n        assertThat(response)\n                .extracting(ResponseEntity::getStatusCode, ResponseEntity::getBody)\n                .contains(HttpStatus.OK, \"{\\\"id\\\":1}\");\n    }\n}\n", "s.com/kpdus/jad.html\n// Decompiler options: braces fieldsfirst space lnc \n\npackage android.support.v4.content.res;\n\nimport android.content.res.TypedArray;\nimport android.graphics.drawable.Drawable;\n\npublic class TypedArrayUtils\n{\n\n    public TypedArrayUtils()\n    {\n    }\n\n    public static boolean getBoolean(TypedArray typedarray, int i, int j, boolean flag)\n    {\n        return typedarray.getBoolean(i, typedarray.getBoolean(j, flag));\n    }\n\n    public static Drawable getDrawable(TypedArray typedarray, int i, int j)\n    {\n        Drawable drawable1 = typedarray.getDrawable(i);\n        Drawable drawable = drawable1;\n        if (drawable1 == null)\n        {\n            drawable = typedarray.getDrawable(j);\n        }\n        return drawable;\n    }\n\n    public static int getInt(TypedArray typedarray, int i, int j, int k)\n    {\n        return typedarray.getInt(i, typedarray.getInt(j, k));\n    }\n\n    public static int getResourceId(TypedArray typedarray, int i, int j, int k)\n    {\n        return typedarray.getResourceId(i, typedarray.getResourceId(j, k));\n    }\n\n    public static String getString(TypedArray typedarray, int i, int j)\n    {\n        String s1 = typedarray.getString(i);\n        String s = s1;\n        if (s1 == null)\n        {\n            s = typedarray.getString(j);\n        }\n        return s;\n    }\n\n    public static CharSequence[] getTextArray(TypedArray typedarray, int i, int j)\n    {\n        CharSequence acharsequence1[] = typedarray.getTextArray(i);\n        CharSequence acharsequence[] = acharsequence1;\n        if (acharsequence1 == null)\n        {\n            acharsequence = typedarray.getTextArray(j);\n        }\n        return acharsequence;\n    }\n}\n", "til.Random;\n\npublic class Generator {\n\tprivate static Random rnd = new Random(System.currentTimeMillis());\n\n\tpublic static void main(String[] args) {\n\t\tgenerateSmallInputFile();\n\t\tgenerateLargeInputFile();\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tgenerateRandomInputFile(i);\n\t}\n\n\tprivate static void generateSmallInputFile() {\n\t\tFile file = new File(\"20-small.in\");\n\t\ttry {\n\t\t\tPrintStream stream = new PrintStream(file);\n\t\t\tint n = 10;\n\t\t\tstream.println(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgenerateSmallTestCase(stream);\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate static void generateLargeInputFile() {\n\t\tFile file = new File(\"21-large.in\");\n\t\ttry {\n\t\t\tPrintStream stream = new PrintStream(file);\n\t\t\tint n = 100;\n\t\t\tstream.println(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgenerateLargeTestCase(stream);\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate static void generateRandomInputFile(int index) {\n\t\tFile file = new File((50 + index) + \"-random\" + index + \".in\");\n\t\ttry {\n\t\t\tPrintStream stream = new PrintStream(file);\n\t\t\tint n = generateRandomNum(1, 100);\n\t\t\tstream.println(n);\n\t\t\tfor (int i = 0; i < n; i++) {\n\t\t\t\tgenerateLargeTestCase(stream);\n\t\t\t}\n\t\t} catch (FileNotFoundException e) {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tprivate static void generateSmallTestCase(PrintStream stream) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = generateRandomNum(1, 20);\n\t\tsb.append(n).append(\" \");\n\t\tint len = generateRandomNum(1, 10);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tint t = generateRandomNum(0, 2);\n\t\t\tif (t == 0)\n\t\t\t\tsb.append('c');\n\t\t\telse\n\t\t\t\tsb.append('w');\n\t\t}\n\t\tstream.println(sb.toString());\n\t}\n\n\tprivate static void generateLargeTestCase(PrintStream stream) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tint n = generateRandomNum(1, 100);\n\t\tsb.append(n).append(\" \");\n\t\tint len = generateRandomNum(1, 100);\n\t\tfor (int i = 0; i < len; i++) {\n\t\t\tint t = generateRandomNum(0, 2);\n\t\t\tif (t == 0)\n\t\t\t\tsb.append('c');\n\t\t\telse\n\t\t\t\tsb.append('w');\n\t\t}\n\t\tstream.println(sb.toString());\n\t}\n\n\tprivate static int generateRandomNum(int min, int max) {\n\t\tint len = max - min + 1;\n\t\treturn rnd.nextInt(len) + min;\n\t}\n\n}\n", "ss UserInfo {\r\n    private String id;\r\n\r\n    private String userId;\r\n\r\n    private String userName;\r\n\r\n    private String idCard;\r\n\r\n    private String sex;\r\n\r\n    private Date birthday;\r\n\r\n    private BigDecimal age;\r\n\r\n    private String nativePlace;\r\n\r\n    private String nation;\r\n\r\n    private BigDecimal homePhone;\r\n\r\n    private BigDecimal officePhone;\r\n\r\n    private BigDecimal mobile;\r\n\r\n    private String companyMail;\r\n\r\n    private String personalMail;\r\n\r\n    private String company;\r\n\r\n    private String departId;\r\n\r\n    private String postId;\r\n\r\n    private String university;\r\n\r\n    private Date graduationDate;\r\n\r\n    private String degreeId;\r\n\r\n    private String majorId;\r\n\r\n    private String jobtitleId;\r\n\r\n    private String address;\r\n\r\n    private String postcode;\r\n\r\n    private String bankId;\r\n\r\n    private BigDecimal bankCode;\r\n\r\n    private String maritalStatus;\r\n\r\n    private String reserveCode;\r\n\r\n    private String photo;\r\n\r\n    private String accessory;\r\n\r\n    private Date createTime;\r\n\r\n    private String createPeopleId;\r\n\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(String id) {\r\n        this.id = id;\r\n    }\r\n\r\n    public String getUserId() {\r\n        return userId;\r\n    }\r\n\r\n    public void setUserId(String userId) {\r\n        this.userId = userId;\r\n    }\r\n\r\n    public String getUserName() {\r\n        return userName;\r\n    }\r\n\r\n    public void setUserName(String userName) {\r\n        this.userName = userName;\r\n    }\r\n\r\n    public String getIdCard() {\r\n        return idCard;\r\n    }\r\n\r\n    public void setIdCard(String idCard) {\r\n        this.idCard = idCard;\r\n    }\r\n\r\n    public String getSex() {\r\n        return sex;\r\n    }\r\n\r\n    public void setSex(String sex) {\r\n        this.sex = sex;\r\n    }\r\n\r\n    public Date getBirthday() {\r\n        return birthday;\r\n    }\r\n\r\n    public void setBirthday(Date birthday) {\r\n        this.birthday = birthday;\r\n    }\r\n\r\n    public BigDecimal getAge() {\r\n        return age;\r\n    }\r\n\r\n    public void setAge(BigDecimal age) {\r\n        this.age = age;\r\n    }\r\n\r\n    public String getNativePlace() {\r\n        return nativePlace;\r\n    }\r\n\r\n    public void setNativePlace(String nativePlace) {\r\n        this.nativePlace = nativePlace;\r\n    }\r\n\r\n    public String getNation() {\r\n        return nation;\r\n    }\r\n\r\n    public void setNation(String nation) {\r\n        this.nation = nation;\r\n    }\r\n\r\n    public BigDecimal getHomePhone() {\r\n        return homePhone;\r\n    }\r\n\r\n    public void setHomePhone(BigDecimal homePhone) {\r\n        this.homePhone = homePhone;\r\n    }\r\n\r\n    public BigDecimal getOfficePhone() {\r\n        return officePhone;\r\n    }\r\n\r\n    public void setOfficePhone(BigDecimal officePhone) {\r\n        this.officePhone = officePhone;\r\n    }\r\n\r\n    public BigDecimal getMobile() {\r\n        return mobile;\r\n    }\r\n\r\n    public void setMobile(BigDecimal mobile) {\r\n        this.mobile = mobile;\r\n    }\r\n\r\n    public String getCompanyMail() {\r\n        return companyMail;\r\n    }\r\n\r\n    public void setCompanyMail(String companyMail) {\r\n        this.companyMail = companyMail;\r\n    }\r\n\r\n    public String getPersonalMail() {\r\n        return personalMail;\r\n    }\r\n\r\n    public void setPersonalMail(String personalMail) {\r\n        this.personalMail = personalMail;\r\n    }\r\n\r\n    public String getCompany() {\r\n        return company;\r\n    }\r\n\r\n    public void setCompany(String company) {\r\n        this.company = company;\r\n    }\r\n\r\n    public String getDepartId() {\r\n        return departId;\r\n    }\r\n\r\n    public void setDepartId(String departId) {\r\n        this.departId = departId;\r\n    }\r\n\r\n    public String getPostId() {\r\n        return postId;\r\n    }\r\n\r\n    public void setPostId(String postId) {\r\n        this.postId = postId;\r\n    }\r\n\r\n    public String getUniversity() {\r\n        return university;\r\n    }\r\n\r\n    public void setUniversity(String university) {\r\n        this.university = university;\r\n    }\r\n\r\n    public Date getGraduationDate() {\r\n        return graduationDate;\r\n    }\r\n\r\n    public void setGraduationDate(Date graduationDate) {\r\n        this.graduationDate = graduationDate;\r\n    }\r\n\r\n    public String getDegreeId() {\r\n        return degreeId;\r\n    }\r\n\r\n    public void setDegreeId(String degreeId) {\r\n        this.degreeId = degreeId;\r\n    }\r\n\r\n    public String getMajorId() {\r\n        return majorId;\r\n    }\r\n\r\n    public void setMajorId(String majorId) {\r\n        this.majorId = majorId;\r\n    }\r\n\r\n    public String getJobtitleId() {\r\n        return jobtitleId;\r\n    }\r\n\r\n    public void setJobtitleId(String jobtitleId) {\r\n        this.jobtitleId = jobtitleId;\r\n    }\r\n\r\n    public String getAddress() {\r\n        return address;\r\n    }\r\n\r\n    public void setAddress(String address) {\r\n        this.address = address;\r\n    }\r\n\r\n    public String getPostcode() {\r\n        return postcode;\r\n    }\r\n\r\n    public void setPostcode(String postcode) {\r\n        this.postcode = postcode;\r\n    }\r\n\r\n    public String getBankId() {\r\n        return bankId;\r\n    }\r\n\r\n    public void setBankId(String bankId) {\r\n        this.bankId = bankId;\r\n    }\r\n\r\n    public BigDecimal getBankCode() {\r\n        return bankCode;\r\n    }\r\n\r\n    public void setBankCode(BigDecimal bankCode) {\r\n        this.bankCode = bankCode;\r\n    }\r\n\r\n    public String getMaritalStatus() {\r\n        return maritalStatus;\r\n    }\r\n\r\n    public void setMaritalStatus(String maritalStatus) {\r\n        this.maritalStatus = maritalStatus;\r\n    }\r\n\r\n    public String getReserveCode() {\r\n        return reserveCode;\r\n    }\r\n\r\n    public void setReserveCode(String reserveCode) {\r\n        this.reserveCode = reserveCode;\r\n    }\r\n\r\n    public String getPhoto() {\r\n        return photo;\r\n    }\r\n\r\n    public void setPhoto(String photo) {\r\n        this.photo = photo;\r\n    }\r\n\r\n    public String getAccessory() {\r\n        return accessory;\r\n    }\r\n\r\n    public void setAccessory(String accessory) {\r\n        this.accessory = accessory;\r\n    }\r\n\r\n    public Date getCreateTime() {\r\n        return createTime;\r\n    }\r\n\r\n    public void setCreateTime(Date createTime) {\r\n        this.createTime = createTime;\r\n    }\r\n\r\n    public String getCreatePeopleId() {\r\n        return createPeopleId;\r\n    }\r\n\r\n    public void setCreatePeopleId(String createPeopleId) {\r\n        this.createPeopleId = createPeopleId;\r\n    }\r\n}", "a.io.ObjectInput;\nimport java.io.ObjectOutput;\n\nimport swarm.server.data.blob.U_Serialization;\nimport swarm.shared.entities.E_CodeSafetyLevel;\nimport swarm.shared.entities.E_CodeType;\nimport swarm.shared.json.A_JsonFactory;\nimport swarm.shared.json.I_JsonObject;\nimport swarm.shared.structs.Code;\n\npublic class ServerCode extends Code implements Externalizable\n{\n\tprivate static final int EXTERNAL_VERSION = 2;\n\t\n\t/**\n\t * Constructor only for use by externalizable.\n\t */\n\tpublic ServerCode()\n\t{\n\t\t//--- DRK > Super will complain if we don't provide stand-in types,\n\t\t//---\t\tso we give it all of them.  They'll be overwritten anyway by readExternal().\n\t\tsuper((String)null, E_CodeType.values());\n\t}\n\t\n\tpublic ServerCode(A_JsonFactory jsonFactory, I_JsonObject json, E_CodeType ... standInTypes)\n\t{\n\t\tsuper(jsonFactory, json, standInTypes);\n\t}\n\t\n\tpublic ServerCode(String rawCode, E_CodeType ... standInTypes)\n\t{\n\t\tsuper(rawCode, standInTypes);\n\t}\n\n\t@Override\n\tpublic void writeExternal(ObjectOutput out) throws IOException\n\t{\n\t\tout.writeInt(EXTERNAL_VERSION);\n\t\t\n\t\tout.writeInt(this.m_standInFlags);\n\t\tU_Serialization.writeNullableString(m_rawCode, out);\n\t\tU_Serialization.writeNullableEnum(m_safetyLevel, out);\n\t}\n\n\t@Override\n\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException\n\t{\n\t\tint externalVersion = in.readInt();\n\t\t\n\t\tm_standInFlags = in.readInt();\n\t\tif( externalVersion == 1 )\n\t\t{\n\t\t\t//--- DRK > Should do an admin bulk recompile of cells, which should be the only time this case is hit.\n\t\t\t//---\t\tCan remove sometime in future.\n\t\t\tString[] codeParts = U_Serialization.readJavaArray(String.class, in);\n\t\t\tif( codeParts != null && codeParts.length > 0 )\n\t\t\t{\n\t\t\t\tm_rawCode = codeParts[0];\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tm_rawCode = U_Serialization.readNullableString(in);\n\t\t}\n\t\t\n\t\tm_safetyLevel = U_Serialization.readNullableEnum(E_CodeSafetyLevel.values(), in);\n\t}\n}\n", "e String switchId;\n    private boolean value;\n\n    public SwitchAction(String id, boolean value){\n        switchId = id;\n        this.value = value;\n    }\n\n    public void execute(Core core){\n        core.setSwitch(switchId, value);\n    }\n\n}\n", "dings.Multibinder;\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.CompilationLevel;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport slieb.jspackage.api.OptionsHandler;\n\nimport static com.google.javascript.jscomp.CheckEventfulObjectDisposal.DisposalCheckingPolicy.AGGRESSIVE;\n\npublic class CompileModule extends AbstractModule {\n    @Override\n    protected void configure() {\n        Multibinder.newSetBinder(binder(), OptionsHandler.class)\n                .addBinding()\n                .to(CustomOptionsHandler.class);\n    }\n}\n\n\nclass CustomOptionsHandler implements OptionsHandler {\n    public void handle(CompilerOptions compilerOptions) {\n        compilerOptions.setCheckEventfulObjectDisposalPolicy(AGGRESSIVE);\n        compilerOptions.assumeStrictThis();\n        compilerOptions.setCheckMissingReturn(CheckLevel.ERROR);\n        compilerOptions.setAggressiveVarCheck(CheckLevel.ERROR);\n        compilerOptions.setCheckDeterminism(true);\n        compilerOptions.setBrokenClosureRequiresLevel(CheckLevel.ERROR);\n        compilerOptions.setCheckTypes(true);\n        compilerOptions.setInferConst(true);\n        CompilationLevel.ADVANCED_OPTIMIZATIONS.setOptionsForCompilationLevel(compilerOptions);\n        CompilationLevel.ADVANCED_OPTIMIZATIONS.setTypeBasedOptimizationOptions(compilerOptions);\n    }\n}", "w.ViewGroup\n\timplements\n\t\tmono.android.IGCUserPeer\n{\n\tstatic final String __md_methods;\n\tstatic {\n\t\t__md_methods = \n\t\t\t\"n_onMeasure:(II)V:GetOnMeasure_IIHandler\\n\" +\n\t\t\t\"n_onLayout:(ZIIII)V:GetOnLayout_ZIIIIHandler\\n\" +\n\t\t\t\"\";\n\t\tmono.android.Runtime.register (\"Xamarin.Forms.Platform.Android.ScrollViewContainer, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", ScrollViewContainer.class, __md_methods);\n\t}\n\n\n\tpublic ScrollViewContainer (android.content.Context p0) throws java.lang.Throwable\n\t{\n\t\tsuper (p0);\n\t\tif (getClass () == ScrollViewContainer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.ScrollViewContainer, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0 });\n\t}\n\n\n\tpublic ScrollViewContainer (android.content.Context p0, android.util.AttributeSet p1) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1);\n\t\tif (getClass () == ScrollViewContainer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.ScrollViewContainer, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0, p1 });\n\t}\n\n\n\tpublic ScrollViewContainer (android.content.Context p0, android.util.AttributeSet p1, int p2) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1, p2);\n\t\tif (getClass () == ScrollViewContainer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.ScrollViewContainer, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:System.Int32, mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\", this, new java.lang.Object[] { p0, p1, p2 });\n\t}\n\n\n\tpublic void onMeasure (int p0, int p1)\n\t{\n\t\tn_onMeasure (p0, p1);\n\t}\n\n\tprivate native void n_onMeasure (int p0, int p1);\n\n\n\tpublic void onLayout (boolean p0, int p1, int p2, int p3, int p4)\n\t{\n\t\tn_onLayout (p0, p1, p2, p3, p4);\n\t}\n\n\tprivate native void n_onLayout (boolean p0, int p1, int p2, int p3, int p4);\n\n\tjava.util.ArrayList refList;\n\tpublic void monodroidAddReference (java.lang.Object obj)\n\t{\n\t\tif (refList == null)\n\t\t\trefList = new java.util.ArrayList ();\n\t\trefList.add (obj);\n\t}\n\n\tpublic void monodroidClearReferences ()\n\t{\n\t\tif (refList != null)\n\t\t\trefList.clear ();\n\t}\n}\n", "--------------------------------\n// Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.  See License in the project root for license information.\n// ------------------------------------------------------------------------------\n\npackage com.microsoft.graph.models;\n\n\nimport com.google.gson.annotations.Expose;\nimport com.google.gson.annotations.SerializedName;\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport com.google.gson.JsonObject;\nimport java.util.EnumSet;\nimport java.util.ArrayList;\n\n// **NOTE** This file was generated by a tool and any changes will be overwritten.\n\n/**\n * The class for the Service Update Message Unarchive Parameter Set.\n */\npublic class ServiceUpdateMessageUnarchiveParameterSet {\n    /**\n     * The message Ids.\n     * \n     */\n    @SerializedName(value = \"messageIds\", alternate = {\"MessageIds\"})\n    @Expose\r\n\t@Nullable\n    public java.util.List<String> messageIds;\n\n\n    /**\n     * Instiaciates a new ServiceUpdateMessageUnarchiveParameterSet\n     */\n    public ServiceUpdateMessageUnarchiveParameterSet() {}\n    /**\n     * Instiaciates a new ServiceUpdateMessageUnarchiveParameterSet\n     * @param builder builder bearing the parameters to initialize from\n     */\n    protected ServiceUpdateMessageUnarchiveParameterSet(@Nonnull final ServiceUpdateMessageUnarchiveParameterSetBuilder builder) {\n        this.messageIds = builder.messageIds;\n    }\n    /**\n     * Gets a new builder for the body\n     * @return a new builder\n     */\n    @Nonnull\n    public static ServiceUpdateMessageUnarchiveParameterSetBuilder newBuilder() {\n        return new ServiceUpdateMessageUnarchiveParameterSetBuilder();\n    }\n    /**\n     * Fluent builder for the ServiceUpdateMessageUnarchiveParameterSet\n     */\n    public static final class ServiceUpdateMessageUnarchiveParameterSetBuilder {\n        /**\n         * The messageIds parameter value\n         */\n        @Nullable\n        protected java.util.List<String> messageIds;\n        /**\n         * Sets the MessageIds\n         * @param val the value to set it to\n         * @return the current builder object\n         */\n        @Nonnull\n        public ServiceUpdateMessageUnarchiveParameterSetBuilder withMessageIds(@Nullable final java.util.List<String> val) {\n            this.messageIds = val;\n            return this;\n        }\n        /**\n         * Instanciates a new ServiceUpdateMessageUnarchiveParameterSetBuilder\n         */\n        @Nullable\n        protected ServiceUpdateMessageUnarchiveParameterSetBuilder(){}\n        /**\n         * Buils the resulting body object to be passed to the request\n         * @return the body object to pass to the request\n         */\n        @Nonnull\n        public ServiceUpdateMessageUnarchiveParameterSet build() {\n            return new ServiceUpdateMessageUnarchiveParameterSet(this);\n        }\n    }\n    /**\n     * Gets the functions options from the properties that have been set\n     * @return a list of function options for the request\n     */\n    @Nonnull\n    public java.util.List<com.microsoft.graph.options.FunctionOption> getFunctionOptions() {\n        final ArrayList<com.microsoft.graph.options.FunctionOption> result = new ArrayList<>();\n        if(this.messageIds != null) {\n            result.add(new com.microsoft.graph.options.FunctionOption(\"messageIds\", messageIds));\n        }\n        return result;\n    }\n}\n", "dSetter<T> implements ByteSetter<T> {\r\n\r\n\tprivate final Field field;\r\n\t\r\n\tpublic ByteFieldSetter(final Field field) {\r\n\t\tthis.field = field;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void setByte(final T target, final byte value) throws IllegalArgumentException, IllegalAccessException {\r\n\t\tfield.setByte(target, value);\r\n\t}\r\n\r\n    @Override\r\n    public String toString() {\r\n        return \"ByteFieldSetter{\" +\r\n                \"field=\" + field +\r\n                '}';\r\n    }\r\n}\r\n", ";\n\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Map;\n\nimport static org.hamcrest.CoreMatchers.startsWith;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.core.Is.is;\nimport static org.junit.jupiter.api.Assertions.assertThrows;\n\nclass JavaDefaultParameterTransformerDefinitionTest {\n\n    private final Lookup lookup = new Lookup() {\n\n        @Override\n        @SuppressWarnings(\"unchecked\")\n        public <T> T getInstance(Class<T> glueClass) {\n            return (T) JavaDefaultParameterTransformerDefinitionTest.this;\n        }\n    };\n\n    @Test\n    void can_transform_string_to_type() throws Throwable {\n        Method method = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"transform_string_to_type\",\n            String.class, Type.class);\n        JavaDefaultParameterTransformerDefinition definition = new JavaDefaultParameterTransformerDefinition(method,\n            lookup);\n        Object transformed = definition.parameterByTypeTransformer().transform(\"something\", String.class);\n        assertThat(transformed, is(\"transform_string_to_type\"));\n    }\n\n    public Object transform_string_to_type(String fromValue, Type toValueType) {\n        return \"transform_string_to_type\";\n    }\n\n    @Test\n    void can_transform_object_to_type() throws Throwable {\n        Method method = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"transform_object_to_type\",\n            Object.class, Type.class);\n        JavaDefaultParameterTransformerDefinition definition = new JavaDefaultParameterTransformerDefinition(method,\n            lookup);\n        String transformed = (String) definition.parameterByTypeTransformer().transform(\"something\", String.class);\n        assertThat(transformed, is(\"transform_object_to_type\"));\n    }\n\n    public Object transform_object_to_type(Object fromValue, Type toValueType) {\n        return \"transform_object_to_type\";\n    }\n\n    @Test\n    void must_have_non_void_return() throws Throwable {\n        Method method = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"transforms_string_to_void\",\n            String.class, Type.class);\n        InvalidMethodSignatureException exception = assertThrows(InvalidMethodSignatureException.class,\n            () -> new JavaDefaultParameterTransformerDefinition(method, lookup));\n        assertThat(exception.getMessage(), startsWith(\"\" +\n                \"A @DefaultParameterTransformer annotated method must have one of these signatures:\\n\" +\n                \" * public Object defaultDataTableEntry(String fromValue, Type toValueType)\\n\" +\n                \" * public Object defaultDataTableEntry(Object fromValue, Type toValueType)\\n\" +\n                \"at io.cucumber.java.JavaDefaultParameterTransformerDefinitionTest.transforms_string_to_void(java.lang.String,java.lang.reflect.Type)\"));\n    }\n\n    public void transforms_string_to_void(String fromValue, Type toValueType) {\n    }\n\n    @Test\n    void must_have_two_arguments() throws Throwable {\n        Method oneArg = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"one_argument\", String.class);\n        assertThrows(InvalidMethodSignatureException.class,\n            () -> new JavaDefaultParameterTransformerDefinition(oneArg, lookup));\n        Method threeArg = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"three_arguments\", String.class,\n            Type.class, Object.class);\n        assertThrows(InvalidMethodSignatureException.class,\n            () -> new JavaDefaultParameterTransformerDefinition(threeArg, lookup));\n    }\n\n    public Object one_argument(String fromValue) {\n        return \"one_arguments\";\n    }\n\n    public Object three_arguments(String fromValue, Type toValueType, Object extra) {\n        return \"three_arguments\";\n    }\n\n    @Test\n    void must_have_string_or_object_as_from_value() throws Throwable {\n        Method threeArg = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"map_as_from_value\", Map.class,\n            Type.class);\n        assertThrows(InvalidMethodSignatureException.class,\n            () -> new JavaDefaultParameterTransformerDefinition(threeArg, lookup));\n    }\n\n    public Object map_as_from_value(Map<String, String> fromValue, Type toValueType) {\n        return \"map_as_from_value\";\n    }\n\n    @Test\n    void must_have_type_as_to_value_type() throws Throwable {\n        Method threeArg = JavaDefaultParameterTransformerDefinitionTest.class.getMethod(\"object_as_to_value_type\",\n            String.class, Object.class);\n        assertThrows(InvalidMethodSignatureException.class,\n            () -> new JavaDefaultParameterTransformerDefinition(threeArg, lookup));\n    }\n\n    public Object object_as_to_value_type(String fromValue, Object toValueType) {\n        return \"object_as_to_value_type\";\n    }\n\n}\n", "rt com.xmomen.framework.mybatis.page.Page;\nimport com.xmomen.framework.web.exceptions.ArgumentValidException;\nimport com.xmomen.module.base.mapper.ItemDetailMapper;\nimport com.xmomen.module.base.mapper.ItemMapper;\nimport com.xmomen.module.base.model.*;\nimport com.xmomen.module.base.service.ItemDetailService;\nimport com.xmomen.module.base.service.ItemService;\nimport com.xmomen.module.logger.Log;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.*;\n\nimport javax.validation.Valid;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n@RestController\npublic class ItemDetailController {\n    @Autowired\n    ItemDetailService itemDetailService;\n    @Autowired\n    ItemDetailMapper itemDetailMapper;\n    @Autowired\n    MybatisDao mybatisDao;\n\n    /**\n     * \u65b0\u589e\u4ea7\u54c1\u8be6\u60c5\n     *\n     * @param createItemDetail\n     * @param bindingResult\n     * @throws ArgumentValidException\n     */\n    @RequestMapping(value = \"/itemDetail\", method = RequestMethod.POST)\n    @Log(actionName = \"\u65b0\u589e\u4ea7\u54c1\")\n    public void createItemDeatil(@RequestBody @Valid CreateItemDetail createItemDetail, BindingResult bindingResult) throws ArgumentValidException {\n        if (bindingResult != null && bindingResult.hasErrors()) {\n            throw new ArgumentValidException(bindingResult);\n        }\n        itemDetailService.createItemDetail(createItemDetail);\n    }\n\n    /**\n     * \u4fee\u6539\u4ea7\u54c1\u8be6\u60c5\n     *\n     * @param id\n     */\n    @RequestMapping(value = \"/itemDetail/{id}\", method = RequestMethod.PUT)\n    @Log(actionName = \"\u4fee\u6539\u4ea7\u54c1\u8be6\u60c5\")\n    public void updateItemDetail(@PathVariable(value = \"id\") Integer id,\n                                 @RequestBody @Valid UpdateItemDetail updateItemDetail, BindingResult bindingResult) throws ArgumentValidException {\n        if (bindingResult != null && bindingResult.hasErrors()) {\n            throw new ArgumentValidException(bindingResult);\n        }\n        itemDetailService.updateItemDetail(id, updateItemDetail);\n    }\n\n    /**\n     * \u5220\u9664\u5546\u54c1\u8be6\u60c5\n     *\n     * @param id\n     */\n    @RequestMapping(value = \"/itemDetail/{id}\", method = RequestMethod.DELETE)\n    @Log(actionName = \"\u5220\u9664\u4ea7\u54c1\u8be6\u60c5\u4fe1\u606f\")\n    public void deleteItemDetail(@PathVariable(value = \"id\") Integer id) {\n        itemDetailService.delete(id);\n    }\n}\n", "Document;\nimport org.w3c.dom.Text;\n\nimport javax.xml.XMLConstants;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\nimport java.io.StringWriter;\n\nimport static javax.xml.transform.OutputKeys.OMIT_XML_DECLARATION;\n\nclass Util {\n    private Util() {}\n\n    static String escapeXml(String target) {\n        try {\n            DocumentBuilderFactory df = DocumentBuilderFactory.newInstance();\n            df.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            df.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n            Document document = df.newDocumentBuilder().newDocument();\n            Text text = document.createTextNode(target);\n            TransformerFactory factory = TransformerFactory.newInstance();\n            // https://cheatsheetseries.owasp.org/cheatsheets/XML_External_Entity_Prevention_Cheat_Sheet.html#transformerfactory\n            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n            factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, \"\");\n            Transformer transformer = factory.newTransformer();\n            DOMSource source = new DOMSource(text);\n            StringWriter writer = new StringWriter();\n            StreamResult result = new StreamResult(writer);\n            transformer.setOutputProperty(OMIT_XML_DECLARATION, \"yes\");\n            transformer.transform(source, result);\n            return writer.toString();\n        } catch (ParserConfigurationException | TransformerException e) {\n            throw new MailgunException(\"Problem escaping XML\", e);\n        }\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file, and Oracle licenses the original version of this file under the BSD\n * license:\n */\n/*\n   Copyright 2009-2013 Attila Szegedi\n\n   Licensed under both the Apache License, Version 2.0 (the \"Apache License\")\n   and the BSD License (the \"BSD License\"), with licensee being free to\n   choose either of the two at their discretion.\n\n   You may not use this file except in compliance with either the Apache\n   License or the BSD License.\n\n   If you choose to use this file in compliance with the Apache License, the\n   following notice applies to you:\n\n       You may obtain a copy of the Apache License at\n\n           http://www.apache.org/licenses/LICENSE-2.0\n\n       Unless required by applicable law or agreed to in writing, software\n       distributed under the License is distributed on an \"AS IS\" BASIS,\n       WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n       implied. See the License for the specific language governing\n       permissions and limitations under the License.\n\n   If you choose to use this file in compliance with the BSD License, the\n   following notice applies to you:\n\n       Redistribution and use in source and binary forms, with or without\n       modification, are permitted provided that the following conditions are\n       met:\n       * Redistributions of source code must retain the above copyright\n         notice, this list of conditions and the following disclaimer.\n       * Redistributions in binary form must reproduce the above copyright\n         notice, this list of conditions and the following disclaimer in the\n         documentation and/or other materials provided with the distribution.\n       * Neither the name of the copyright holder nor the names of\n         contributors may be used to endorse or promote products derived from\n         this software without specific prior written permission.\n\n       THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS\n       IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED\n       TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A\n       PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDER\n       BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n       CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n       SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR\n       BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n       WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR\n       OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n       ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\npackage jdk.internal.dynalink;\n\nimport java.lang.invoke.MethodHandle;\nimport java.lang.invoke.MethodHandles;\nimport java.util.Iterator;\nimport java.util.LinkedList;\nimport java.util.concurrent.atomic.AtomicReference;\nimport jdk.internal.dynalink.linker.GuardedInvocation;\nimport jdk.internal.dynalink.support.AbstractRelinkableCallSite;\nimport jdk.internal.dynalink.support.Lookup;\n\n/**\n * A relinkable call site that maintains a chain of linked method handles. In the default implementation, up to 8 method\n * handles can be chained, cascading from one to the other through\n * {@link MethodHandles#guardWithTest(MethodHandle, MethodHandle, MethodHandle)}. When this call site has to link a new\n * method handle and the length of the chain is already at the maximum, it will throw away the oldest method handle.\n * Switchpoint-invalidated handles in the chain are removed eagerly (on each linking request, and whenever a\n * switchpoint-invalidated method handle is traversed during invocation). There is currently no profiling\n * attached to the handles in the chain, so they are never reordered based on usage; the most recently linked method\n * handle is always at the start of the chain.\n */\npublic class ChainedCallSite extends AbstractRelinkableCallSite {\n    private static final MethodHandle PRUNE = Lookup.findOwnSpecial(MethodHandles.lookup(), \"prune\", MethodHandle.class,\n            MethodHandle.class);\n\n    private final AtomicReference<LinkedList<GuardedInvocation>> invocations = new AtomicReference<>();\n\n    /**\n     * Creates a new chained call site.\n     * @param descriptor the descriptor for the call site.\n     */\n    public ChainedCallSite(CallSiteDescriptor descriptor) {\n        super(descriptor);\n    }\n\n    /**\n     * The maximum number of method handles in the chain. Defaults to 8. You can override it in a subclass if you need\n     * to change the value. If your override returns a value less than 1, the code will break.\n     * @return the maximum number of method handles in the chain.\n     */\n    protected int getMaxChainLength() {\n        return 8;\n    }\n\n    @Override\n    public void relink(GuardedInvocation guardedInvocation, MethodHandle fallback) {\n        relinkInternal(guardedInvocation, fallback, false);\n    }\n\n    @Override\n    public void resetAndRelink(GuardedInvocation guardedInvocation, MethodHandle fallback) {\n        relinkInternal(guardedInvocation, fallback, true);\n    }\n\n    private MethodHandle relinkInternal(GuardedInvocation invocation, MethodHandle relink, boolean reset) {\n        final LinkedList<GuardedInvocation> currentInvocations = invocations.get();\n        @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n        final LinkedList<GuardedInvocation> newInvocations =\n            currentInvocations == null || reset ? new LinkedList<>() : (LinkedList)currentInvocations.clone();\n\n        // First, prune the chain of invalidated switchpoints.\n        for(Iterator<GuardedInvocation> it = newInvocations.iterator(); it.hasNext();) {\n            if(it.next().hasBeenInvalidated()) {\n                it.remove();\n            }\n        }\n\n        // prune() is allowed to invoke this method with invocation == null meaning we're just pruning the chain and not\n        // adding any new invocations to it.\n        if(invocation != null) {\n            // Remove oldest entry if we're at max length\n            if(newInvocations.size() == getMaxChainLength()) {\n                newInvocations.removeFirst();\n            }\n            newInvocations.addLast(invocation);\n        }\n\n        // prune-and-invoke is used as the fallback for invalidated switchpoints. If a switchpoint gets invalidated, we\n        // rebuild the chain and get rid of all invalidated switchpoints instead of letting them linger.\n        final MethodHandle pruneAndInvoke = makePruneAndInvokeMethod(relink);\n\n        // Fold the new chain\n        MethodHandle target = relink;\n        for(GuardedInvocation inv: newInvocations) {\n            target = inv.compose(pruneAndInvoke, target);\n        }\n\n        // If nobody else updated the call site while we were rebuilding the chain, set the target to our chain. In case\n        // we lost the race for multithreaded update, just do nothing. Either the other thread installed the same thing\n        // we wanted to install, or otherwise, we'll be asked to relink again.\n        if(invocations.compareAndSet(currentInvocations, newInvocations)) {\n            setTarget(target);\n        }\n        return target;\n    }\n\n    /**\n     * Creates a method that rebuilds our call chain, pruning it of any invalidated switchpoints, and then invokes that\n     * chain.\n     * @param relink the ultimate fallback for the chain (the {@code DynamicLinker}'s relink).\n     * @return a method handle for prune-and-invoke\n     */\n    private MethodHandle makePruneAndInvokeMethod(MethodHandle relink) {\n        // Bind prune to (this, relink)\n        final MethodHandle boundPrune = MethodHandles.insertArguments(PRUNE, 0, this, relink);\n        // Make it ignore all incoming arguments\n        final MethodHandle ignoreArgsPrune = MethodHandles.dropArguments(boundPrune, 0, type().parameterList());\n        // Invoke prune, then invoke the call site target with original arguments\n        return MethodHandles.foldArguments(MethodHandles.exactInvoker(type()), ignoreArgsPrune);\n    }\n\n    @SuppressWarnings(\"unused\")\n    private MethodHandle prune(MethodHandle relink) {\n        return relinkInternal(null, relink, false);\n    }\n}\n", "lieb.throwables.ObjLongConsumerWithThrowable.aObjLongConsumerThatUnsafelyThrowsUnchecked;\n@java.lang.SuppressWarnings({\"CodeBlock2Expr\"})\npublic class ObjLongConsumerWithThrowableRethrowTest {\n\n\n  @Test\n  public void testThrowCheckedException() {\n    IOException expected = new IOException(\"EXPECTED ERROR\");\n    IOException actual = null;\n    try {\n      aObjLongConsumerThatUnsafelyThrowsUnchecked((v1, v2) -> {\n        throw expected;\n      }).accept(null, 0);\n      org.junit.Assert.fail(\"Exception should have been thrown\");\n    } catch (IOException e) {\n      actual=e;\n    }\n    org.junit.Assert.assertEquals(expected, actual);\n  }\n\n\n  @Test\n  public void testNormalOperation() {\n    try {\n      aObjLongConsumerThatUnsafelyThrowsUnchecked((v1, v2) -> {\n        if(false) throw new IOException();\n      }).accept(null, 0);\n    } catch (IOException ignored) {\n      org.junit.Assert.fail(\"\");\n    }\n  }\n\n\n}\n", "a.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\npublic class RoleUtils {\n\n    public static final String IS_ADMIN_ROLE_NAME = \"IS Admin\";\n    public static final String IS_ADMIN_ROLE_DESCRIPTION = \"An admin of the whole system, with full permissions over the system.\";\n    public static final String DATA_OWNER_ROLE_NAME = \"Data Owner\";\n    public static final String DATA_OWNER_ROLE_DESCRIPTION = \"An admin of a specific vault, with full permissions over that vault.\";\n\n    private RoleUtils() {}\n\n    public static boolean isReservedRoleName(String roleName) {\n        return IS_ADMIN_ROLE_NAME.equalsIgnoreCase(roleName) || DATA_OWNER_ROLE_NAME.equalsIgnoreCase(roleName);\n    }\n\n    public static boolean isDataOwner(RoleAssignment roleAssignment) {\n        return DATA_OWNER_ROLE_NAME.equals(roleAssignment.getRole().getName());\n    }\n\n    public static boolean isISAdmin(RoleAssignment roleAssignment) {\n        return IS_ADMIN_ROLE_NAME.equals(roleAssignment.getRole().getName());\n    }\n\n    public static boolean isRoleOfName(RoleAssignment roleAssignment, String roleName) {\n        return roleName.equals(roleAssignment.getRole().getName());\n    }\n\n    public static boolean isRoleInVault(RoleAssignment roleAssignment, String vaultId) {\n        return roleAssignment.getVaultId() != null && roleAssignment.getVaultId().equals(vaultId);\n    }\n\n    public static boolean isRoleInSchool(RoleAssignment roleAssignment, String schoolId) {\n        return roleAssignment.getSchoolId() != null && roleAssignment.getSchoolId().equals(schoolId);\n    }\n\n    public static boolean hasPermission(RoleAssignment roleAssignment, Permission permission) {\n        return roleAssignment.getRole().getPermissions().stream()\n                .anyMatch(permissionModel -> permission == permissionModel.getPermission());\n    }\n\n    public static boolean hasReducedPermissions(Collection<PermissionModel> originalPermissions,\n                                                Collection<PermissionModel> newPermissions) {\n        Set<Permission> original = originalPermissions.stream()\n                .map(PermissionModel::getPermission)\n                .collect(Collectors.toSet());\n        Set<Permission> updated = newPermissions.stream()\n                .map(PermissionModel::getPermission)\n                .collect(Collectors.toSet());\n        return !updated.containsAll(original);\n    }\n\n    public static List<RoleModel> getAssignableRoles(List<RoleAssignment> roleAssignmentsForUser, List<RoleModel> vaultRoles) {\n        //get users highest vault role status\n        // find out the highest status vault role the user has for this vault\n        // lower is highest!\n        String highestStatus = null;\n        boolean admin = false;\n        for (RoleAssignment ra : roleAssignmentsForUser) {\n            RoleModel rm = ra.getRole();\n            if (rm.getType().equals(RoleType.VAULT)) {\n                String roleStatus = rm.getStatus();\n                if (highestStatus == null) {\n                    highestStatus = roleStatus;\n                } else if (Integer.parseInt(highestStatus) > Integer.parseInt(roleStatus)) {\n                    highestStatus = roleStatus;\n                }\n            }\n            if (rm.getType().equals(RoleType.ADMIN)) {\n                admin = true;\n            }\n            if (rm.getType().equals(RoleType.SCHOOL)) {\n                admin = true;\n            }\n        }\n\n        // iterate over the roles and remove any with a higher or equal status\n        List<RoleModel> validRoles = new ArrayList<>();\n        for (RoleModel role : vaultRoles) {\n            if (admin || (highestStatus != null && Integer.parseInt(highestStatus) < Integer.parseInt(role.getStatus()))) {\n                validRoles.add(role);\n            }\n        }\n        return validRoles;\n    }\n}\n", "er {\n\n    private TokenValueDtoMother() {\n    }\n\n    public static TokenValueDto.TokenValueDtoBuilder FND() {\n        return TokenValueDto.builder()\n                            .tokenAddress(\"0x9f88c5cc76148d41a5db8d0a7e581481efc9667b\")\n                            .tokenSymbol(\"FND\")\n                            .totalAmount(new BigDecimal(\"50.33\"));\n    }\n\n    public static TokenValueDto.TokenValueDtoBuilder ZRX() {\n        return TokenValueDto.builder()\n                            .tokenAddress(\"0x6ff6c0ff1d68b964901f986d4c9fa3ac68346570\")\n                            .tokenSymbol(\"ZRX\")\n                            .totalAmount(new BigDecimal(\"5\"));\n    }\n}\n", "rge.net\n *\n *This program is free software; you can redistribute it and/or\n *modify it under the terms of the GNU General Public License\n *as published by the Free Software Foundation; either version 2\n *of the License, or (at your option) any later version.\n *\n *This program is distributed in the hope that it will be useful,\n *but WITHOUT ANY WARRANTY; without even the implied warranty of\n *MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n *GNU General Public License for more details.\n *\n *You should have received a copy of the GNU General Public License\n *along with this program; if not, write to the Free Software\n *Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.*/\n/*\n * InfoTable.java\n *\n * Created on May 16, 2005, 7:22 PM\n */\n\npackage net.giantsystem.sf;\nimport javax.swing.table.TableColumn;\n/**\n * Provide custom <CODE>JTable</CODE> for displaying invariants\n * @author karve\n */\npublic class InfoTable extends javax.swing.JTable {\n    /**\n     * Index of column in which the name of an invariant is found\n     */\n    public static final int NAME_COL = 0;\n    /**\n     * Index of column in which the value of an invariant is found\n     */\n    public static final int VAL_COL = 1;\n    /**\n     * Index of column in which the <I>variable</I> name of an invariant is found\n     */\n    public final static int VAR_COL = 2;    //auto variable names go here\n    /**\n     * Width of the name column\n     */\n    public final static int NAME_COL_WID = 120;\n    /**\n     * Width of the variable column\n     */\n    public final static int VAR_COL_WID = 50;\n    /**\n     * Width of the value column\n     */\n    public final static int VAL_COL_WID = 200;\n    /**\n     * Column widths for tables with 2 columns\n     */\n    public static final int[] COL_WIDS2 = {NAME_COL_WID, VAL_COL_WID};\n    /**\n     * Column widths for tables with 3 columns\n     */\n    public static final int[] COL_WIDS3 = {NAME_COL_WID, VAL_COL_WID, VAR_COL_WID};\n    \n    /**\n     * Text informing the user to double-click for a calculation\n     */\n    public final static String DOUBLE_CLICK_CALC = KASHTerm.enclose(\"double-click to calculate\");\n    /**\n     * Default titles for columns (currently all empty)\n     */\n    public final static String[] COL_TITLES = {\"\",\"\",\"\"};\n\n\n    \n    /**\n     * Creates new form BeanForm\n     * @param data 2D array containing data that will populate the table\n     */\n    public InfoTable(final Object[][] data) {\n\t\tinitComponents();\n        //cross-platform; want to be sure unicode math chars are present\n\t\t//removesetFont(new java.awt.Font(\"Lucida Grande\", 0, 12));\n\t\t\n\t\tsetModel(new javax.swing.table.DefaultTableModel(data, COL_TITLES) {\n            public boolean isCellEditable(int rowIndex, int columnIndex) {\n                return false;\n            }\n        });\n        \n        final int cols = getModel().getColumnCount();\n        final int[] wids = cols == 2 ? COL_WIDS2 : COL_WIDS3;\n        \n        if(cols > wids.length)\n            throw new AssertionError(cols + \"columns, but only \" + wids.length + \" column widths\");\n\n        for(int i = 0; i < cols; i++){\n            TableColumn column = getColumnModel().getColumn(i);\n            column.setPreferredWidth(wids[i]);\n        }\n    }\n    \n    /**\n     * Called when a user double-click is detected\n     * @param evt mouse click\n     */\n    protected void doubleClickHandler(java.awt.event.MouseEvent evt){\n        return;\n    }\n    /** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    // <editor-fold defaultstate=\"collapsed\" desc=\" Generated Code \">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        setBackground(javax.swing.UIManager.getDefaults().getColor(\"InternalFrame.background\"));\n        setDragEnabled(true);\n        setGridColor(new java.awt.Color(153, 153, 153));\n        setShowVerticalLines(false);\n        addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                formMouseClicked(evt);\n            }\n        });\n\n    }\n    // </editor-fold>//GEN-END:initComponents\n\n    /**\n     * First receiver for mouse clicks; any double-clicks will be dispatched to \n     * <CODE>doubleClickHandler()</CODE>\n     * @param evt mouse click\n     * @see #doubleClickHandler\n     */\n    private void formMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_formMouseClicked\n        if(evt.getClickCount()==2)\n            doubleClickHandler(evt);\n    }//GEN-LAST:event_formMouseClicked\n    \n    \n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    // End of variables declaration//GEN-END:variables\n    \n}", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.core.convert.support;\n\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\n\nimport org.springframework.core.CollectionFactory;\nimport org.springframework.core.convert.ConversionService;\nimport org.springframework.core.convert.TypeDescriptor;\nimport org.springframework.core.convert.converter.ConditionalGenericConverter;\n\n/**\n * Converts a Map to another Map.\n *\n * <p>First, creates a new Map of the requested targetType with a size equal to the\n * size of the source Map. Then copies each element in the source map to the target map.\n * Will perform a conversion from the source maps's parameterized K,V types to the target\n * map's parameterized types K,V if necessary.\n *\n * @author Keith Donald\n * @author Juergen Hoeller\n * @since 3.0\n */\nfinal class MapToMapConverter implements ConditionalGenericConverter {\n\n\tprivate final ConversionService conversionService;\n\n\n\tpublic MapToMapConverter(ConversionService conversionService) {\n\t\tthis.conversionService = conversionService;\n\t}\n\n\n\t@Override\n\tpublic Set<ConvertiblePair> getConvertibleTypes() {\n\t\treturn Collections.singleton(new ConvertiblePair(Map.class, Map.class));\n\t}\n\n\t@Override\n\tpublic boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn canConvertKey(sourceType, targetType) && canConvertValue(sourceType, targetType);\n\t}\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (source == null) {\n\t\t\treturn null;\n\t\t}\n\t\tMap<Object, Object> sourceMap = (Map<Object, Object>) source;\n\n\t\t// Shortcut if possible...\n\t\tboolean copyRequired = !targetType.getType().isInstance(source);\n\t\tif (!copyRequired && sourceMap.isEmpty()) {\n\t\t\treturn sourceMap;\n\t\t}\n\t\tTypeDescriptor keyDesc = targetType.getMapKeyTypeDescriptor();\n\t\tTypeDescriptor valueDesc = targetType.getMapValueTypeDescriptor();\n\n\t\tList<MapEntry> targetEntries = new ArrayList<>(sourceMap.size());\n\t\tfor (Map.Entry<Object, Object> entry : sourceMap.entrySet()) {\n\t\t\tObject sourceKey = entry.getKey();\n\t\t\tObject sourceValue = entry.getValue();\n\t\t\tObject targetKey = convertKey(sourceKey, sourceType, keyDesc);\n\t\t\tObject targetValue = convertValue(sourceValue, sourceType, valueDesc);\n\t\t\ttargetEntries.add(new MapEntry(targetKey, targetValue));\n\t\t\tif (sourceKey != targetKey || sourceValue != targetValue) {\n\t\t\t\tcopyRequired = true;\n\t\t\t}\n\t\t}\n\t\tif (!copyRequired) {\n\t\t\treturn sourceMap;\n\t\t}\n\n\t\tMap<Object, Object> targetMap = CollectionFactory.createMap(targetType.getType(),\n\t\t\t\t(keyDesc != null ? keyDesc.getType() : null), sourceMap.size());\n\n\t\tfor (MapEntry entry : targetEntries) {\n\t\t\tentry.addToMap(targetMap);\n\t\t}\n\t\treturn targetMap;\n\t}\n\n\n\t// internal helpers\n\n\tprivate boolean canConvertKey(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn ConversionUtils.canConvertElements(sourceType.getMapKeyTypeDescriptor(),\n\t\t\t\ttargetType.getMapKeyTypeDescriptor(), this.conversionService);\n\t}\n\n\tprivate boolean canConvertValue(TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\treturn ConversionUtils.canConvertElements(sourceType.getMapValueTypeDescriptor(),\n\t\t\t\ttargetType.getMapValueTypeDescriptor(), this.conversionService);\n\t}\n\n\tprivate Object convertKey(Object sourceKey, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn sourceKey;\n\t\t}\n\t\treturn this.conversionService.convert(sourceKey, sourceType.getMapKeyTypeDescriptor(sourceKey), targetType);\n\t}\n\n\tprivate Object convertValue(Object sourceValue, TypeDescriptor sourceType, TypeDescriptor targetType) {\n\t\tif (targetType == null) {\n\t\t\treturn sourceValue;\n\t\t}\n\t\treturn this.conversionService.convert(sourceValue, sourceType.getMapValueTypeDescriptor(sourceValue), targetType);\n\t}\n\n\n\tprivate static class MapEntry {\n\n\t\tprivate final Object key;\n\n\t\tprivate final Object value;\n\n\t\tpublic MapEntry(Object key, Object value) {\n\t\t\tthis.key = key;\n\t\t\tthis.value = value;\n\t\t}\n\n\t\tpublic void addToMap(Map<Object, Object> map) {\n\t\t\tmap.put(this.key, this.value);\n\t\t}\n\t}\n\n}\n", "AllocatePublicIpAddressRequest extends Request {\n\tprivate String InstanceId;\n\n\tpublic AllocatePublicIpAddressRequest(String instanceId) {\n\t\tInstanceId = instanceId;\n\t}\n\n\tpublic String getInstanceId() {\n\t\treturn InstanceId;\n\t}\n\n\tpublic void setInstanceId(String instanceId) {\n\t\tInstanceId = instanceId;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"AllocatePublicIpAddressRequest [InstanceId=\" + InstanceId + \"]\";\n\t}\n\n}\n", "ream;\r\nimport java.io.OutputStreamWriter;\r\nimport java.io.Reader;\r\nimport java.io.Serializable;\r\nimport java.io.StringReader;\r\nimport java.io.Writer;\r\nimport java.nio.charset.Charset;\r\nimport java.sql.Clob;\r\nimport java.sql.NClob;\r\nimport java.sql.SQLException;\r\n\r\npublic class MySQLClob extends MySQLBlob implements Clob, NClob, Serializable {\r\n\tprivate static final long serialVersionUID = -2006825230517923067L;\r\n\r\n\tpublic String toString() {\r\n      try {\r\n        return new String(blobContent, \"UTF-8\");\r\n      }\r\n      catch(Exception e) {\r\n          throw new AssertionError(e);\r\n      }\r\n    }\r\n\r\n    public MySQLClob(byte[] bytes) {\r\n        super(bytes);\r\n    }\r\n    public MySQLClob() {\r\n        super();\r\n    }\r\n\r\n    public String getSubString(long pos, int length) throws SQLException {\r\n        try {\r\n            return toString().substring((int) pos - 1, (int) pos - 1 + length);\r\n        }\r\n        catch(Exception e) {\r\n            throw new SQLException(e);\r\n        }\r\n    }\r\n\r\n    public Reader getCharacterStream() throws SQLException {\r\n        return new StringReader(toString());\r\n    }\r\n\r\n    public InputStream getAsciiStream() throws SQLException {\r\n        return getBinaryStream();\r\n    }\r\n\r\n    public long position(String searchstr, long start) throws SQLException {\r\n        return toString().indexOf(searchstr, (int)start -1);\r\n    }\r\n\r\n    /**\r\n     * Convert character position into byte position in UTF8 byte array.\r\n     * @param charPosition\r\n     * @return byte position\r\n     */\r\n    private int UTF8position(int charPosition) {\r\n        int pos = 0;\r\n        for(int i = 0; i < charPosition; i++)  {\r\n            int c = blobContent[pos] & 0xff;\r\n            if(c < 0x80) {\r\n                pos += 1;\r\n            }\r\n            else if((c & 0xC0) == 0xC0) {\r\n                pos += 2;\r\n            }\r\n            else if ((c & 0xE0) == 0xE0) {\r\n                pos += 3;\r\n            }\r\n            else if ((c & 0xF0) == 0xF0) {\r\n                pos += 4;\r\n            }\r\n            else {\r\n                throw new AssertionError(\"invalid UTF8\");\r\n            }\r\n        }\r\n        return pos;\r\n    }\r\n\r\n    public long position(Clob searchstr, long start) throws SQLException {\r\n        return position(searchstr.toString(), start);\r\n    }\r\n\r\n    public int setString(long pos, String str) throws SQLException {\r\n        int bytePosition = UTF8position((int)pos-1);\r\n        super.setBytes(bytePosition+1, str.getBytes(Charset.forName(\"UTF-8\")));\r\n        return str.length();\r\n    }\r\n\r\n    public int setString(long pos, String str, int offset, int len) throws SQLException {\r\n        return setString(pos, str.substring(offset, offset+len));\r\n    }\r\n\r\n    public OutputStream setAsciiStream(long pos) throws SQLException {\r\n       return setBinaryStream(UTF8position((int)pos-1)+1);\r\n    }\r\n\r\n    public Writer setCharacterStream(long pos) throws SQLException {\r\n        int bytePosition  = UTF8position((int)pos-1);\r\n        OutputStream stream = setBinaryStream(bytePosition+1);\r\n        return new OutputStreamWriter(stream, Charset.forName(\"UTF-8\"));\r\n    }\r\n\r\n\r\n    public Reader getCharacterStream(long pos, long length) throws SQLException {\r\n       String sub = toString().substring((int)pos -1, (int)pos -1 + (int)length);\r\n       return new StringReader(sub);\r\n    }\r\n\r\n    @Override\r\n    /**\r\n     * return character length of the Clob. Assume UTF8 encoding.\r\n     */\r\n    public long length() {\r\n       long len = 0;\r\n       for(int i = 0; i < actualSize;)  {\r\n            int c = blobContent[i] & 0xff;\r\n            if(c < 0x80) {\r\n                i += 1;\r\n            }\r\n            else if((c & 0xC0) == 0xC0) {\r\n                i += 2;\r\n            }\r\n            else if ((c & 0xE0) == 0xE0) {\r\n                i += 3;\r\n            }\r\n            else if ((c & 0xF0) == 0xF0) {\r\n                i += 4;\r\n            }\r\n            else {\r\n                throw new AssertionError(\"invalid UTF8\");\r\n            }\r\n           len++;\r\n        }\r\n        return len;\r\n    }\r\n}\r\n", "erAlphaAnalyzer()\n    {\n        super(\"loweralpha\", MatchingType.ONE, \"^[\\\\p{Lower}]+$\");\n    }\n}\n", "til.Stack;\n\n/**\n * Created by Vaidehi on 11/13/16.\n */\npublic class TreeTraversals<T> {\n\n    public void inOrder(BTNode<T> rootNode){\n\n        if(rootNode == null){\n            return;\n        }\n        inOrder(rootNode.getLeftNode());\n        System.out.print(rootNode.getData() + \" \");\n        inOrder(rootNode.getRightNode());\n    }\n\n    public void preOrder(BTNode<T> rootNode){\n\n        if(rootNode == null){\n            return;\n        }\n\n        System.out.print(rootNode.getData() + \" \");\n        preOrder(rootNode.getLeftNode());\n        preOrder(rootNode.getRightNode());\n    }\n\n    public void postOrder(BTNode<T> rootNode){\n\n        if(rootNode == null){\n            return;\n        }\n\n        postOrder(rootNode.getLeftNode());\n        postOrder(rootNode.getRightNode());\n        System.out.print(rootNode.getData() + \" \");\n    }\n\n    public void levelOrderTraversal(BTNode<T> rootNode){\n        if(rootNode == null){\n            return;\n        }\n        Queue<BTNode<T>> queue = new LinkedList<BTNode<T>>();\n        queue.add(rootNode);\n        while(!queue.isEmpty()){\n            BTNode<T> currentNode = queue.poll();\n            System.out.print(currentNode.getData() + \" \");\n            BTNode<T> leftChild = currentNode.getLeftNode();\n            BTNode<T> rightChild = currentNode.getRightNode();\n            if(leftChild != null){\n                queue.add(leftChild);\n            }\n            if(rightChild != null){\n                queue.add(rightChild);\n            }\n        }\n\n    }\n\n    public void inOrderInterative(BTNode<T> rootNode){\n        if(rootNode == null){\n            return;\n        }\n        Stack<BTNode<T>> stack = new Stack<BTNode<T>>();\n        stack.add(rootNode);\n        BTNode<T> currentNode = rootNode.getLeftNode();\n        boolean terminate = Boolean.FALSE;\n        while(!terminate){\n            while(currentNode!=null){\n                stack.add(currentNode);\n                currentNode = currentNode.getLeftNode();\n            }\n            if(stack.isEmpty()){\n                terminate = Boolean.TRUE;\n            } else {\n                BTNode<T> poppedNode = stack.pop();\n                System.out.print(poppedNode.getData() + \" \");\n                currentNode = poppedNode.getRightNode();\n            }\n        }\n    }\n\n    public void preOrderIterative(BTNode<T> rootNode){\n        if(rootNode == null){\n            return;\n        }\n        Stack<BTNode<T>> stack = new Stack<BTNode<T>>();\n        BTNode<T> currentNode = rootNode;\n        boolean terminate = Boolean.FALSE;\n        while(!terminate){\n            while(currentNode!=null){\n                stack.add(currentNode);\n                System.out.print(currentNode.getData() + \" \");\n                currentNode = currentNode.getLeftNode();\n            }\n            if(stack.isEmpty()){\n                terminate = Boolean.TRUE;\n            } else {\n                BTNode<T> poppedNode = stack.pop();\n                currentNode = poppedNode.getRightNode();\n            }\n        }\n    }\n\n    public void postOrderIterative(BTNode<T> rootNode){\n\n    }\n\n    public static void main(String args[]){\n        BTNode<Integer> root = BinaryTreeUtils.getMockIntegerBinaryTree();\n        TreeTraversals<Integer> treeTraversals = new TreeTraversals<Integer>();\n        System.out.println(\"InOrder Traversal \");\n        treeTraversals.inOrder(root);\n        System.out.println(\"\\nPre Order Traversal \");\n        treeTraversals.preOrder(root);\n        System.out.println(\"\\nPost Order Traversal \");\n        treeTraversals.postOrder(root);\n        System.out.println(\"\\nLevel Order Traversal\");\n        treeTraversals.levelOrderTraversal(root);\n        System.out.println(\"\\nIn Order Traversal Iterative\");\n        treeTraversals.inOrderInterative(root);\n        System.out.println(\"\\nIn Pre Traversal Iterative\");\n        treeTraversals.preOrderIterative(root);\n    }\n}", ".stellar.base.xdr;\n\n\nimport java.io.IOException;\n\n// === xdr source ============================================================\n\n//  union Asset switch (AssetType type)\n//  {\n//  case ASSET_TYPE_NATIVE: // Not credit\n//      void;\n//  \n//  case ASSET_TYPE_CREDIT_ALPHANUM4:\n//      struct\n//      {\n//          opaque assetCode[4]; // 1 to 4 characters\n//          AccountID issuer;\n//      } alphaNum4;\n//  \n//  case ASSET_TYPE_CREDIT_ALPHANUM12:\n//      struct\n//      {\n//          opaque assetCode[12]; // 5 to 12 characters\n//          AccountID issuer;\n//      } alphaNum12;\n//  \n//      // add other asset types here in the future\n//  };\n\n//  ===========================================================================\npublic class Asset  {\n  public Asset () {}\n  AssetType type;\n  public AssetType getDiscriminant() {\n    return this.type;\n  }\n  public void setDiscriminant(AssetType value) {\n    this.type = value;\n  }\n  private AssetAlphaNum4 alphaNum4;\n  public AssetAlphaNum4 getAlphaNum4() {\n    return this.alphaNum4;\n  }\n  public void setAlphaNum4(AssetAlphaNum4 value) {\n    this.alphaNum4 = value;\n  }\n  private AssetAlphaNum12 alphaNum12;\n  public AssetAlphaNum12 getAlphaNum12() {\n    return this.alphaNum12;\n  }\n  public void setAlphaNum12(AssetAlphaNum12 value) {\n    this.alphaNum12 = value;\n  }\n  public static void encode(XdrDataOutputStream stream, Asset encodedAsset) throws IOException {\n  stream.writeInt(encodedAsset.getDiscriminant().getValue());\n  switch (encodedAsset.getDiscriminant()) {\n  case ASSET_TYPE_NATIVE:\n  break;\n  case ASSET_TYPE_CREDIT_ALPHANUM4:\n  AssetAlphaNum4.encode(stream, encodedAsset.alphaNum4);\n  break;\n  case ASSET_TYPE_CREDIT_ALPHANUM12:\n  AssetAlphaNum12.encode(stream, encodedAsset.alphaNum12);\n  break;\n  }\n  }\n  public static Asset decode(XdrDataInputStream stream) throws IOException {\n    Asset decodedAsset = new Asset();\n    switch (decodedAsset.getDiscriminant()) {\n  case ASSET_TYPE_NATIVE:\n  break;\n  case ASSET_TYPE_CREDIT_ALPHANUM4:\n  decodedAsset.alphaNum4 = AssetAlphaNum4.decode(stream);\n  break;\n  case ASSET_TYPE_CREDIT_ALPHANUM12:\n  decodedAsset.alphaNum12 = AssetAlphaNum12.decode(stream);\n  break;\n  }\n    return decodedAsset;\n  }\n\n  public static class AssetAlphaNum4 {\n    public AssetAlphaNum4 () {}\n    private byte[] assetCode;\n    public byte[] getAssetCode() {\n      return this.assetCode;\n    }\n    public void setAssetCode(byte[] value) {\n      this.assetCode = value;\n    }\n    private AccountID issuer;\n    public AccountID getIssuer() {\n      return this.issuer;\n    }\n    public void setIssuer(AccountID value) {\n      this.issuer = value;\n    }\n    public static void encode(XdrDataOutputStream stream, AssetAlphaNum4 encodedAssetAlphaNum4) throws IOException{\n      int assetCodesize = encodedAssetAlphaNum4.assetCode.length;\n      stream.write(encodedAssetAlphaNum4.getAssetCode(), 0, assetCodesize);\n      AccountID.encode(stream, encodedAssetAlphaNum4.issuer);\n    }\n    public static AssetAlphaNum4 decode(XdrDataInputStream stream) throws IOException {\n      AssetAlphaNum4 decodedAssetAlphaNum4 = new AssetAlphaNum4();\n      int assetCodesize = 4;\n      decodedAssetAlphaNum4.assetCode = new byte[assetCodesize];\n      stream.read(decodedAssetAlphaNum4.assetCode, 0, assetCodesize);\n      decodedAssetAlphaNum4.issuer = AccountID.decode(stream);\n      return decodedAssetAlphaNum4;\n    }\n\n  }\n  public static class AssetAlphaNum12 {\n    public AssetAlphaNum12 () {}\n    private byte[] assetCode;\n    public byte[] getAssetCode() {\n      return this.assetCode;\n    }\n    public void setAssetCode(byte[] value) {\n      this.assetCode = value;\n    }\n    private AccountID issuer;\n    public AccountID getIssuer() {\n      return this.issuer;\n    }\n    public void setIssuer(AccountID value) {\n      this.issuer = value;\n    }\n    public static void encode(XdrDataOutputStream stream, AssetAlphaNum12 encodedAssetAlphaNum12) throws IOException{\n      int assetCodesize = encodedAssetAlphaNum12.assetCode.length;\n      stream.write(encodedAssetAlphaNum12.getAssetCode(), 0, assetCodesize);\n      AccountID.encode(stream, encodedAssetAlphaNum12.issuer);\n    }\n    public static AssetAlphaNum12 decode(XdrDataInputStream stream) throws IOException {\n      AssetAlphaNum12 decodedAssetAlphaNum12 = new AssetAlphaNum12();\n      int assetCodesize = 12;\n      decodedAssetAlphaNum12.assetCode = new byte[assetCodesize];\n      stream.read(decodedAssetAlphaNum12.assetCode, 0, assetCodesize);\n      decodedAssetAlphaNum12.issuer = AccountID.decode(stream);\n      return decodedAssetAlphaNum12;\n    }\n\n  }\n}\n", "rt android.support.v7.app.AppCompatActivity;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.ImageView;\nimport android.widget.ProgressBar;\nimport android.widget.TextView;\n\nimport com.alucine.zinio.marvelpoc.helpers.DownloadComic;\nimport com.alucine.zinio.marvelpoc.object.CharacterInfo;\nimport com.karumi.marvelapiclient.model.CharacterResourceDto;\nimport com.karumi.marvelapiclient.model.ComicsDto;\nimport com.karumi.marvelapiclient.model.MarvelImage;\nimport com.karumi.marvelapiclient.model.MarvelResponse;\nimport com.nostra13.universalimageloader.core.DisplayImageOptions;\nimport com.nostra13.universalimageloader.core.ImageLoader;\nimport com.nostra13.universalimageloader.core.assist.FailReason;\nimport com.nostra13.universalimageloader.core.listener.ImageLoadingListener;\nimport com.nostra13.universalimageloader.core.listener.ImageLoadingProgressListener;\n\nimport java.util.List;\nimport java.util.Random;\n\npublic class DetailCharacter extends AppCompatActivity implements DownloadComic.DownloadComicssListener {\n    public final static String DATA = \"DATA\";\n    private MenuItem mProgressMenu;\n    private int comicID;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_detail_character);\n        setView();\n    }\n\n    private void setView() {\n        Bundle args = getIntent().getExtras();\n        CharacterInfo data = args.getParcelable(DATA);\n        getSupportActionBar().setTitle(data.title);\n        comicID = data.comicId;\n    }\n\n    @Override\n    public boolean onCreateOptionsMenu(Menu menu) {\n        // Inflate the menu; this adds items to the action bar if it is present.\n        getMenuInflater().inflate(R.menu.menu_main, menu);\n\n        mProgressMenu = menu.findItem(R.id.menu_progress);\n\n        requestComics();\n        return true;\n    }\n\n    private void requestComics() {\n        mProgressMenu.setVisible(true);\n        new DownloadComic(this,comicID).execute();\n    }\n\n    @Override\n    public void onDownloadComicsLoaded(MarvelResponse<ComicsDto> response) {\n        mProgressMenu.setVisible(false);\n\n        findViewById(R.id.loading).setVisibility(View.INVISIBLE);\n\n        TextView numberValue = (TextView) findViewById(R.id.numberValue);\n        TextView loading = (TextView) findViewById(R.id.loading);\n        TextView selectedValue = (TextView) findViewById(R.id.selectedValue);\n        TextView descriptionValue = (TextView) findViewById(R.id.descriptionValue);\n        TextView charactersValue = (TextView) findViewById(R.id.charactersValue);\n        ImageView image = (ImageView) findViewById(R.id.image);\n        final ProgressBar progressBar = (ProgressBar) findViewById(R.id.progressBar);\n\n        DisplayImageOptions options = new DisplayImageOptions.Builder()\n                .cacheInMemory(true)\n                .cacheOnDisk(true)\n                .showImageOnLoading(R.mipmap.ic_launcher)\n                .showImageForEmptyUri(R.mipmap.ic_launcher)\n                .showImageOnFail(R.mipmap.ic_launcher)\n                .considerExifParams(true)\n                .build();\n\n        if ( response != null ) {\n            if ( response.getCode() == 200 ) {\n                int count = response.getResponse().getCount();\n                numberValue.setText(\"\" + count);\n\n                if (count > 0) {\n                    Random rnd = new Random();\n                    int selected = rnd.nextInt(count);\n\n                    selectedValue.setText(\"\" + selected);\n                    descriptionValue.setText(response.getResponse().getComics().get(selected).getDescription());\n\n                    String characters = \"\";\n                    for (CharacterResourceDto characterResourceDto : response.getResponse().getComics().get(selected).getCharacters().getItems()) {\n                        characters = characters + characterResourceDto.getName() + \" , \";\n                    }\n                    charactersValue.setText(characters);\n\n                    List<MarvelImage> images = response.getResponse().getComics().get(0).getImages();\n\n                    if ( images.size() > 0 ){\n                        int imgSelected = rnd.nextInt(images.size());\n\n                        ImageLoader.getInstance().displayImage(images.get(imgSelected).getImageUrl(MarvelImage.Size.FULLSIZE), image,options, new ImageLoadingListener() {\n                            @Override\n                            public void onLoadingStarted(String imageUri, View view) {\n                                progressBar.setVisibility(View.VISIBLE);\n                            }\n                            @Override\n                            public void onLoadingFailed(String imageUri, View view, FailReason failReason) {\n                                progressBar.setVisibility(View.INVISIBLE);\n                            }\n                            @Override\n                            public void onLoadingComplete(String imageUri, View view, Bitmap loadedImage) {\n                                progressBar.setVisibility(View.INVISIBLE);\n                            }\n                            @Override\n                            public void onLoadingCancelled(String imageUri, View view) {\n                                progressBar.setVisibility(View.INVISIBLE);\n                            }\n                        }, new ImageLoadingProgressListener() {\n                            @Override\n                            public void onProgressUpdate(String imageUri, View view, int current, int total) {\n                            }\n                        });\n                    }\n\n                } else  {\n                    selectedValue.setText(\"-\");\n                    descriptionValue.setText(R.string.no_available);\n                    charactersValue.setText(R.string.no_available);\n                }\n            } else {\n                loading.setText(R.string.error_downloading_comics);\n            }\n        } else {\n            loading.setText(R.string.error_downloading_comics);\n        }\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n\npackage sun.io;\n\nimport sun.nio.cs.IBM857;\n\n/**\n * A table to convert to Cp857 to Unicode\n *\n * @author  ConverterGenerator tool\n */\n\npublic class ByteToCharCp857 extends ByteToCharSingleByte {\n\n    private final static IBM857 nioCoder = new IBM857();\n\n    public String getCharacterEncoding() {\n        return \"Cp857\";\n    }\n\n    public ByteToCharCp857() {\n        super.byteToCharTable = nioCoder.getDecoderSingleByteMappings();\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage java.lang;\n\nimport java.io.UnsupportedEncodingException;\nimport java.lang.ref.SoftReference;\nimport java.nio.ByteBuffer;\nimport java.nio.CharBuffer;\nimport java.nio.charset.Charset;\nimport java.nio.charset.CharsetDecoder;\nimport java.nio.charset.CharsetEncoder;\nimport java.nio.charset.CharacterCodingException;\nimport java.nio.charset.CoderResult;\nimport java.nio.charset.CodingErrorAction;\nimport java.nio.charset.IllegalCharsetNameException;\nimport java.nio.charset.UnsupportedCharsetException;\nimport java.util.Arrays;\nimport sun.misc.MessageUtils;\nimport sun.nio.cs.HistoricallyNamedCharset;\nimport sun.nio.cs.ArrayDecoder;\nimport sun.nio.cs.ArrayEncoder;\n\n/**\n * Utility class for string encoding and decoding.\n */\n\nclass StringCoding {\n\n    private StringCoding() { }\n\n    /** The cached coders for each thread */\n    private final static ThreadLocal<SoftReference<StringDecoder>> decoder =\n        new ThreadLocal<>();\n    private final static ThreadLocal<SoftReference<StringEncoder>> encoder =\n        new ThreadLocal<>();\n\n    private static boolean warnUnsupportedCharset = true;\n\n    private static <T> T deref(ThreadLocal<SoftReference<T>> tl) {\n        SoftReference<T> sr = tl.get();\n        if (sr == null)\n            return null;\n        return sr.get();\n    }\n\n    private static <T> void set(ThreadLocal<SoftReference<T>> tl, T ob) {\n        tl.set(new SoftReference<T>(ob));\n    }\n\n    // Trim the given byte array to the given length\n    //\n    private static byte[] safeTrim(byte[] ba, int len, Charset cs, boolean isTrusted) {\n        if (len == ba.length && (isTrusted || System.getSecurityManager() == null))\n            return ba;\n        else\n            return Arrays.copyOf(ba, len);\n    }\n\n    // Trim the given char array to the given length\n    //\n    private static char[] safeTrim(char[] ca, int len,\n                                   Charset cs, boolean isTrusted) {\n        if (len == ca.length && (isTrusted || System.getSecurityManager() == null))\n            return ca;\n        else\n            return Arrays.copyOf(ca, len);\n    }\n\n    private static int scale(int len, float expansionFactor) {\n        // We need to perform double, not float, arithmetic; otherwise\n        // we lose low order bits when len is larger than 2**24.\n        return (int)(len * (double)expansionFactor);\n    }\n\n    private static Charset lookupCharset(String csn) {\n        if (Charset.isSupported(csn)) {\n            try {\n                return Charset.forName(csn);\n            } catch (UnsupportedCharsetException x) {\n                throw new Error(x);\n            }\n        }\n        return null;\n    }\n\n    private static void warnUnsupportedCharset(String csn) {\n        if (warnUnsupportedCharset) {\n            // Use sun.misc.MessageUtils rather than the Logging API or\n            // System.err since this method may be called during VM\n            // initialization before either is available.\n            MessageUtils.err(\"WARNING: Default charset \" + csn +\n                             \" not supported, using ISO-8859-1 instead\");\n            warnUnsupportedCharset = false;\n        }\n    }\n\n\n    // -- Decoding --\n    private static class StringDecoder {\n        private final String requestedCharsetName;\n        private final Charset cs;\n        private final CharsetDecoder cd;\n        private final boolean isTrusted;\n\n        private StringDecoder(Charset cs, String rcn) {\n            this.requestedCharsetName = rcn;\n            this.cs = cs;\n            this.cd = cs.newDecoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            this.isTrusted = (cs.getClass().getClassLoader0() == null);\n        }\n\n        String charsetName() {\n            if (cs instanceof HistoricallyNamedCharset)\n                return ((HistoricallyNamedCharset)cs).historicalName();\n            return cs.name();\n        }\n\n        final String requestedCharsetName() {\n            return requestedCharsetName;\n        }\n\n        char[] decode(byte[] ba, int off, int len) {\n            int en = scale(len, cd.maxCharsPerByte());\n            char[] ca = new char[en];\n            if (len == 0)\n                return ca;\n            if (cd instanceof ArrayDecoder) {\n                int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);\n                return safeTrim(ca, clen, cs, isTrusted);\n            } else {\n                cd.reset();\n                ByteBuffer bb = ByteBuffer.wrap(ba, off, len);\n                CharBuffer cb = CharBuffer.wrap(ca);\n                try {\n                    CoderResult cr = cd.decode(bb, cb, true);\n                    if (!cr.isUnderflow())\n                        cr.throwException();\n                    cr = cd.flush(cb);\n                    if (!cr.isUnderflow())\n                        cr.throwException();\n                } catch (CharacterCodingException x) {\n                    // Substitution is always enabled,\n                    // so this shouldn't happen\n                    throw new Error(x);\n                }\n                return safeTrim(ca, cb.position(), cs, isTrusted);\n            }\n        }\n    }\n\n    static char[] decode(String charsetName, byte[] ba, int off, int len)\n        throws UnsupportedEncodingException\n    {\n        StringDecoder sd = deref(decoder);\n        String csn = (charsetName == null) ? \"ISO-8859-1\" : charsetName;\n        if ((sd == null) || !(csn.equals(sd.requestedCharsetName())\n                              || csn.equals(sd.charsetName()))) {\n            sd = null;\n            try {\n                Charset cs = lookupCharset(csn);\n                if (cs != null)\n                    sd = new StringDecoder(cs, csn);\n            } catch (IllegalCharsetNameException x) {}\n            if (sd == null)\n                throw new UnsupportedEncodingException(csn);\n            set(decoder, sd);\n        }\n        return sd.decode(ba, off, len);\n    }\n\n    static char[] decode(Charset cs, byte[] ba, int off, int len) {\n        // (1)We never cache the \"external\" cs, the only benefit of creating\n        // an additional StringDe/Encoder object to wrap it is to share the\n        // de/encode() method. These SD/E objects are short-lifed, the young-gen\n        // gc should be able to take care of them well. But the best approash\n        // is still not to generate them if not really necessary.\n        // (2)The defensive copy of the input byte/char[] has a big performance\n        // impact, as well as the outgoing result byte/char[]. Need to do the\n        // optimization check of (sm==null && classLoader0==null) for both.\n        // (3)getClass().getClassLoader0() is expensive\n        // (4)There might be a timing gap in isTrusted setting. getClassLoader0()\n        // is only chcked (and then isTrusted gets set) when (SM==null). It is\n        // possible that the SM==null for now but then SM is NOT null later\n        // when safeTrim() is invoked...the \"safe\" way to do is to redundant\n        // check (... && (isTrusted || SM == null || getClassLoader0())) in trim\n        // but it then can be argued that the SM is null when the opertaion\n        // is started...\n        CharsetDecoder cd = cs.newDecoder();\n        int en = scale(len, cd.maxCharsPerByte());\n        char[] ca = new char[en];\n        if (len == 0)\n            return ca;\n        boolean isTrusted = false;\n        if (System.getSecurityManager() != null) {\n            if (!(isTrusted = (cs.getClass().getClassLoader0() == null))) {\n                ba =  Arrays.copyOfRange(ba, off, off + len);\n                off = 0;\n            }\n        }\n        cd.onMalformedInput(CodingErrorAction.REPLACE)\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .reset();\n        if (cd instanceof ArrayDecoder) {\n            int clen = ((ArrayDecoder)cd).decode(ba, off, len, ca);\n            return safeTrim(ca, clen, cs, isTrusted);\n        } else {\n            ByteBuffer bb = ByteBuffer.wrap(ba, off, len);\n            CharBuffer cb = CharBuffer.wrap(ca);\n            try {\n                CoderResult cr = cd.decode(bb, cb, true);\n                if (!cr.isUnderflow())\n                    cr.throwException();\n                cr = cd.flush(cb);\n                if (!cr.isUnderflow())\n                    cr.throwException();\n            } catch (CharacterCodingException x) {\n                // Substitution is always enabled,\n                // so this shouldn't happen\n                throw new Error(x);\n            }\n            return safeTrim(ca, cb.position(), cs, isTrusted);\n        }\n    }\n\n    static char[] decode(byte[] ba, int off, int len) {\n        String csn = Charset.defaultCharset().name();\n        try {\n            // use charset name decode() variant which provides caching.\n            return decode(csn, ba, off, len);\n        } catch (UnsupportedEncodingException x) {\n            warnUnsupportedCharset(csn);\n        }\n        try {\n            return decode(\"ISO-8859-1\", ba, off, len);\n        } catch (UnsupportedEncodingException x) {\n            // If this code is hit during VM initialization, MessageUtils is\n            // the only way we will be able to get any kind of error message.\n            MessageUtils.err(\"ISO-8859-1 charset not available: \"\n                             + x.toString());\n            // If we can not find ISO-8859-1 (a required encoding) then things\n            // are seriously wrong with the installation.\n            System.exit(1);\n            return null;\n        }\n    }\n\n    // -- Encoding --\n    private static class StringEncoder {\n        private Charset cs;\n        private CharsetEncoder ce;\n        private final String requestedCharsetName;\n        private final boolean isTrusted;\n\n        private StringEncoder(Charset cs, String rcn) {\n            this.requestedCharsetName = rcn;\n            this.cs = cs;\n            this.ce = cs.newEncoder()\n                .onMalformedInput(CodingErrorAction.REPLACE)\n                .onUnmappableCharacter(CodingErrorAction.REPLACE);\n            this.isTrusted = (cs.getClass().getClassLoader0() == null);\n        }\n\n        String charsetName() {\n            if (cs instanceof HistoricallyNamedCharset)\n                return ((HistoricallyNamedCharset)cs).historicalName();\n            return cs.name();\n        }\n\n        final String requestedCharsetName() {\n            return requestedCharsetName;\n        }\n\n        byte[] encode(char[] ca, int off, int len) {\n            int en = scale(len, ce.maxBytesPerChar());\n            byte[] ba = new byte[en];\n            if (len == 0)\n                return ba;\n            if (ce instanceof ArrayEncoder) {\n                int blen = ((ArrayEncoder)ce).encode(ca, off, len, ba);\n                return safeTrim(ba, blen, cs, isTrusted);\n            } else {\n                ce.reset();\n                ByteBuffer bb = ByteBuffer.wrap(ba);\n                CharBuffer cb = CharBuffer.wrap(ca, off, len);\n                try {\n                    CoderResult cr = ce.encode(cb, bb, true);\n                    if (!cr.isUnderflow())\n                        cr.throwException();\n                    cr = ce.flush(bb);\n                    if (!cr.isUnderflow())\n                        cr.throwException();\n                } catch (CharacterCodingException x) {\n                    // Substitution is always enabled,\n                    // so this shouldn't happen\n                    throw new Error(x);\n                }\n                return safeTrim(ba, bb.position(), cs, isTrusted);\n            }\n        }\n    }\n\n    static byte[] encode(String charsetName, char[] ca, int off, int len)\n        throws UnsupportedEncodingException\n    {\n        StringEncoder se = deref(encoder);\n        String csn = (charsetName == null) ? \"ISO-8859-1\" : charsetName;\n        if ((se == null) || !(csn.equals(se.requestedCharsetName())\n                              || csn.equals(se.charsetName()))) {\n            se = null;\n            try {\n                Charset cs = lookupCharset(csn);\n                if (cs != null)\n                    se = new StringEncoder(cs, csn);\n            } catch (IllegalCharsetNameException x) {}\n            if (se == null)\n                throw new UnsupportedEncodingException (csn);\n            set(encoder, se);\n        }\n        return se.encode(ca, off, len);\n    }\n\n    static byte[] encode(Charset cs, char[] ca, int off, int len) {\n        CharsetEncoder ce = cs.newEncoder();\n        int en = scale(len, ce.maxBytesPerChar());\n        byte[] ba = new byte[en];\n        if (len == 0)\n            return ba;\n        boolean isTrusted = false;\n        if (System.getSecurityManager() != null) {\n            if (!(isTrusted = (cs.getClass().getClassLoader0() == null))) {\n                ca =  Arrays.copyOfRange(ca, off, off + len);\n                off = 0;\n            }\n        }\n        ce.onMalformedInput(CodingErrorAction.REPLACE)\n          .onUnmappableCharacter(CodingErrorAction.REPLACE)\n          .reset();\n        if (ce instanceof ArrayEncoder) {\n            int blen = ((ArrayEncoder)ce).encode(ca, off, len, ba);\n            return safeTrim(ba, blen, cs, isTrusted);\n        } else {\n            ByteBuffer bb = ByteBuffer.wrap(ba);\n            CharBuffer cb = CharBuffer.wrap(ca, off, len);\n            try {\n                CoderResult cr = ce.encode(cb, bb, true);\n                if (!cr.isUnderflow())\n                    cr.throwException();\n                cr = ce.flush(bb);\n                if (!cr.isUnderflow())\n                    cr.throwException();\n            } catch (CharacterCodingException x) {\n                throw new Error(x);\n            }\n            return safeTrim(ba, bb.position(), cs, isTrusted);\n        }\n    }\n\n    static byte[] encode(char[] ca, int off, int len) {\n        String csn = Charset.defaultCharset().name();\n        try {\n            // use charset name encode() variant which provides caching.\n            return encode(csn, ca, off, len);\n        } catch (UnsupportedEncodingException x) {\n            warnUnsupportedCharset(csn);\n        }\n        try {\n            return encode(\"ISO-8859-1\", ca, off, len);\n        } catch (UnsupportedEncodingException x) {\n            // If this code is hit during VM initialization, MessageUtils is\n            // the only way we will be able to get any kind of error message.\n            MessageUtils.err(\"ISO-8859-1 charset not available: \"\n                             + x.toString());\n            // If we can not find ISO-8859-1 (a required encoding) then things\n            // are seriously wrong with the installation.\n            System.exit(1);\n            return null;\n        }\n    }\n}\n", ".nwnx.nwnx2.jvm.NWLocation;\nimport org.nwnx.nwnx2.jvm.NWObject;\nimport org.nwnx.nwnx2.jvm.NWScript;\nimport org.nwnx.nwnx2.jvm.constants.Inventory;\n\nimport java.util.Date;\n\npublic class PlayerGO {\n    private NWObject _pc;\n\n    public PlayerGO(NWObject pc)\n    {\n        _pc = pc;\n    }\n\n    public String getUUID()\n    {\n        NWObject oDatabase = NWScript.getItemPossessedBy(_pc, Constants.PCDatabaseTag);\n        return NWScript.getLocalString(oDatabase, Constants.PCIDNumberVariable);\n    }\n\n    public PlayerEntity createEntity()\n    {\n        NWObject database = NWScript.getItemPossessedBy(_pc, Constants.PCDatabaseTag);\n        String uuid = NWScript.getLocalString(database, Constants.PCIDNumberVariable);\n        NWLocation location = NWScript.getLocation(_pc);\n\n        PlayerEntity entity = new PlayerEntity();\n        entity.setPCID(uuid);\n        entity.setCharacterName(NWScript.getName(_pc, false));\n        entity.setHitPoints(NWScript.getCurrentHitPoints(_pc));\n        entity.setLocationAreaTag(NWScript.getTag(NWScript.getArea(_pc)));\n        entity.setLocationOrientation(NWScript.getFacing(_pc));\n        entity.setLocationX(location.getX());\n        entity.setLocationY(location.getY());\n        entity.setLocationZ(location.getZ());\n        entity.setCreateTimestamp(new Date());\n\n        return entity;\n    }\n\n    public void destroyAllInventoryItems()\n    {\n        for(NWObject item : NWScript.getItemsInInventory(_pc))\n        {\n            NWScript.destroyObject(item, 0.0f);\n        }\n    }\n\n    public void destroyAllEquippedItems()\n    {\n        NWObject oInventory = NWScript.getItemInSlot(Inventory.SLOT_ARMS, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_ARROWS, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_BELT, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_BOLTS, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_BOOTS, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_BULLETS, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_CARMOUR, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_CHEST, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_CLOAK, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_CWEAPON_B, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_CWEAPON_L, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_CWEAPON_R, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_HEAD, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_LEFTHAND, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_LEFTRING, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_NECK, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_RIGHTHAND, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n        oInventory = NWScript.getItemInSlot(Inventory.SLOT_RIGHTRING, _pc);\n        NWScript.destroyObject(oInventory, 0.0f);\n    }\n\n\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.policyinsights.models;\n\nimport com.azure.core.annotation.Immutable;\nimport com.azure.core.util.logging.ClientLogger;\nimport com.azure.resourcemanager.policyinsights.fluent.models.AttestationInner;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport java.util.List;\n\n/** List of attestations. */\n@Immutable\npublic final class AttestationListResult {\n    @JsonIgnore private final ClientLogger logger = new ClientLogger(AttestationListResult.class);\n\n    /*\n     * Array of attestation definitions.\n     */\n    @JsonProperty(value = \"value\", access = JsonProperty.Access.WRITE_ONLY)\n    private List<AttestationInner> value;\n\n    /*\n     * The URL to get the next set of results.\n     */\n    @JsonProperty(value = \"nextLink\", access = JsonProperty.Access.WRITE_ONLY)\n    private String nextLink;\n\n    /**\n     * Get the value property: Array of attestation definitions.\n     *\n     * @return the value value.\n     */\n    public List<AttestationInner> value() {\n        return this.value;\n    }\n\n    /**\n     * Get the nextLink property: The URL to get the next set of results.\n     *\n     * @return the nextLink value.\n     */\n    public String nextLink() {\n        return this.nextLink;\n    }\n\n    /**\n     * Validates the instance.\n     *\n     * @throws IllegalArgumentException thrown if the instance is not valid.\n     */\n    public void validate() {\n        if (value() != null) {\n            value().forEach(e -> e.validate());\n        }\n    }\n}\n", "d, free of charge, to any person obtaining a copy\r\nof this software and associated documentation files (the \"Software\"), to deal\r\nin the Software without restriction, including without limitation the rights\r\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the Software is\r\nfurnished to do so, subject to the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be included in all\r\ncopies or substantial portions of the Software.\r\n\r\nThe Software shall be used for Good, not Evil.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\nSOFTWARE.\r\n*/\r\n\r\nimport java.util.Iterator;\r\n\r\n/**\r\n * Convert a web browser cookie list string to a JSONObject and back.\r\n * @author JSON.org\r\n * @version 2010-12-24\r\n */\r\npublic class CookieList {\r\n\r\n    /**\r\n     * Convert a cookie list into a JSONObject. A cookie list is a sequence\r\n     * of name/value pairs. The names are separated from the values by '='.\r\n     * The pairs are separated by ';'. The names and the values\r\n     * will be unescaped, possibly converting '+' and '%' sequences.\r\n     *\r\n     * To add a cookie to a cooklist,\r\n     * cookielistJSONObject.put(cookieJSONObject.getString(\"name\"),\r\n     *     cookieJSONObject.getString(\"value\"));\r\n     * @param string  A cookie list string\r\n     * @return A JSONObject\r\n     * @throws JSONException\r\n     */\r\n    public static JSONObject toJSONObject(String string) throws JSONException {\r\n        JSONObject jo = new JSONObject();\r\n        JSONTokener x = new JSONTokener(string);\r\n        while (x.more()) {\r\n            String name = Cookie.unescape(x.nextTo('='));\r\n            x.next('=');\r\n            jo.put(name, Cookie.unescape(x.nextTo(';')));\r\n            x.next();\r\n        }\r\n        return jo;\r\n    }\r\n\r\n\r\n    /**\r\n     * Convert a JSONObject into a cookie list. A cookie list is a sequence\r\n     * of name/value pairs. The names are separated from the values by '='.\r\n     * The pairs are separated by ';'. The characters '%', '+', '=', and ';'\r\n     * in the names and values are replaced by \"%hh\".\r\n     * @param jo A JSONObject\r\n     * @return A cookie list string\r\n     * @throws JSONException\r\n     */\r\n    public static String toString(JSONObject jo) throws JSONException {\r\n        boolean      b = false;\r\n        Iterator     keys = jo.keys();\r\n        String       string;\r\n        StringBuffer sb = new StringBuffer();\r\n        while (keys.hasNext()) {\r\n            string = keys.next().toString();\r\n            if (!jo.isNull(string)) {\r\n                if (b) {\r\n                    sb.append(';');\r\n                }\r\n                sb.append(Cookie.escape(string));\r\n                sb.append(\"=\");\r\n                sb.append(Cookie.escape(jo.getString(string)));\r\n                b = true;\r\n            }\r\n        }\r\n        return sb.toString();\r\n    }\r\n}\r\n", " InputHandler {\n    @Override\n    public boolean handle(String input, Display display) {\n        final String message = String.format(\"Did not understand input [%s]\", input);\n        display.show(message);\n\n        return true;\n    }\n}\n", "licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.react.views.imagehelper;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.concurrent.ThreadSafe;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport android.content.Context;\nimport android.graphics.drawable.Drawable;\nimport android.net.Uri;\n\n/**\n * Helper class for obtaining information about local images.\n */\n@ThreadSafe\npublic class ResourceDrawableIdHelper {\n\n  private Map<String, Integer> mResourceDrawableIdMap;\n\n  private static final String LOCAL_RESOURCE_SCHEME = \"res\";\n  private static volatile ResourceDrawableIdHelper sResourceDrawableIdHelper;\n\n  private ResourceDrawableIdHelper() {\n    mResourceDrawableIdMap = new HashMap<String, Integer>();\n  }\n\n  public static ResourceDrawableIdHelper getInstance() {\n    if (sResourceDrawableIdHelper == null) {\n      synchronized (ResourceDrawableIdHelper.class) {\n        if (sResourceDrawableIdHelper == null) {\n          sResourceDrawableIdHelper = new ResourceDrawableIdHelper();\n        }\n      }\n    }\n    return sResourceDrawableIdHelper;\n  }\n\n  public synchronized void clear() {\n    mResourceDrawableIdMap.clear();\n  }\n\n  public int getResourceDrawableId(Context context, @Nullable String name) {\n    if (name == null || name.isEmpty()) {\n      return 0;\n    }\n    name = name.toLowerCase().replace(\"-\", \"_\");\n\n    synchronized (this) {\n      if (mResourceDrawableIdMap.containsKey(name)) {\n        return mResourceDrawableIdMap.get(name);\n      }\n      int id = context.getResources().getIdentifier(\n        name,\n        \"drawable\",\n        context.getPackageName());\n      mResourceDrawableIdMap.put(name, id);\n      return id;\n    }\n  }\n\n  public @Nullable Drawable getResourceDrawable(Context context, @Nullable String name) {\n    int resId = getResourceDrawableId(context, name);\n    return resId > 0 ? context.getResources().getDrawable(resId) : null;\n  }\n\n  public Uri getResourceDrawableUri(Context context, @Nullable String name) {\n    int resId = getResourceDrawableId(context, name);\n    return resId > 0 ? new Uri.Builder()\n        .scheme(LOCAL_RESOURCE_SCHEME)\n        .path(String.valueOf(resId))\n        .build() : Uri.EMPTY;\n  }\n}\n", "package ethier.alex.world.core.processor;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n\n @author alex\n */\npublic class MetricManager {\n\n    List<Metric> metrics;\n\n    public MetricManager() {\n        metrics = new ArrayList<Metric>();\n    }\n\n    public void addRunData(long time,\n                           long usedMemory,\n                           long freeMemory,\n                           long numQueuedIncompletePartitions,\n                           long newCompletedPartitions,\n                           long newIncompletePartitions) {\n\n        Metric metric = new Metric(time,\n                                   usedMemory,\n                                   freeMemory,\n                                   numQueuedIncompletePartitions,\n                                   newCompletedPartitions,\n                                   newIncompletePartitions);\n\n        metrics.add(metric);\n    }\n\n    public String printMetrics() {\n        StringBuilder statisticsOutput = new StringBuilder();\n\n        for (int i = 0; i < metrics.size(); i++) {\n            Metric metric = metrics.get(i);\n\n            long maxMemory = Runtime.getRuntime().maxMemory();\n            double usedMemoryPercent = (1.0 * metric.usedMemory) / (1.0 * maxMemory);\n\n            statisticsOutput.append(\"\\n\");\n            statisticsOutput.append(\"Set Count: \\t\\t\\t\").append(i).append(\"\\n\");\n            statisticsOutput.append(\"Used Memory: \\t\\t\\t\").append(metric.usedMemory).append(\"\\n\");\n            statisticsOutput.append(\"Free Memory: \\t\\t\\t\").append(metric.freeMemory).append(\"\\n\");\n            statisticsOutput.append(\"Memory Usage Percent: \\t\\t\").append(usedMemoryPercent).append(\"\\n\");\n            statisticsOutput.append(\"Queued Incomplete Partitions: \\t\").append(metric.numQueuedIncompletePartitions).append(\"\\n\");\n            statisticsOutput.append(\"New Completed Partitions: \\t\").append(metric.newCompletedPartitions).append(\"\\n\");\n            statisticsOutput.append(\"New Incompleted Partitions: \\t\").append(metric.newIncompletePartitions).append(\"\\n\");\n            statisticsOutput.append(\"Set took: \\t\\t\\t\" + metric.time + \" milliseconds.\").append(\"\\n\");\n        }\n\n        return statisticsOutput.toString();\n    }\n\n    public String printAggregateMetrics() {\n        int numSets = metrics.size();\n        long maxMemory = Runtime.getRuntime().maxMemory();\n\n        double averageMemoryUsagePercent = 0L;\n        long averageQueuedPartitions = 0L;\n        long totalCompletedPartitions = 0L;\n        long averageIncompletedPartitions = 0L;\n        long totalTime = 0L;\n        double averageTime;\n        int processedPartitionsPerSecond;\n\n        for (Metric metric : metrics) {\n            averageMemoryUsagePercent += (1.0 * metric.usedMemory) / (1.0 * maxMemory);\n            averageQueuedPartitions += metric.numQueuedIncompletePartitions;\n            if (metric.newCompletedPartitions > totalCompletedPartitions) {\n                totalCompletedPartitions = metric.newCompletedPartitions;\n            }\n\n            averageIncompletedPartitions += metric.newIncompletePartitions;\n            totalTime += metric.time;\n        }\n\n        averageMemoryUsagePercent = (averageMemoryUsagePercent / (1.0 * numSets));\n        averageQueuedPartitions = (averageQueuedPartitions / numSets);\n        averageIncompletedPartitions = (averageIncompletedPartitions / numSets);\n        averageTime = (totalTime / numSets);\n        if(totalTime == 0) {\n            processedPartitionsPerSecond = Integer.MAX_VALUE;\n        } else {\n            // The assumption that all queued partitions are processed in a set leads to errors in Deep Processor.\n            processedPartitionsPerSecond = (int) (1000 * averageQueuedPartitions / totalTime);\n        }\n        \n\n        StringBuilder statisticsOutput = new StringBuilder();\n        statisticsOutput.append(\"\\n\");\n        statisticsOutput.append(\"Num Sets: \\t\\t\\t\\t\").append(numSets).append(\"\\n\");\n        statisticsOutput.append(\"Avg. Memory Usage Percent: \\t\\t\").append(averageMemoryUsagePercent).append(\"\\n\");\n        statisticsOutput.append(\"Avg. Queued Incomplete Partitions: \\t\").append(averageQueuedPartitions).append(\"\\n\");\n        statisticsOutput.append(\"Total Completed Partitions: \\t\\t\").append(totalCompletedPartitions).append(\"\\n\");\n        statisticsOutput.append(\"Avg. Incompleted Partitions: \\t\\t\").append(averageIncompletedPartitions).append(\"\\n\");\n        statisticsOutput.append(\"Total Time: \\t\\t\\t\\t\").append(totalTime).append(\" milliseconds.\").append(\"\\n\");\n        statisticsOutput.append(\"Avg. Time: \\t\\t\\t\\t\").append(averageTime).append(\" milliseconds.\").append(\"\\n\");\n        statisticsOutput.append(\"Avg. Partitions/sec: \\t\\t\\t\").append(processedPartitionsPerSecond).append(\"\\n\");\n        \n        return statisticsOutput.toString();\n    }\n}\n", "ve.commands.drive.MoveStraightPositionModeCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.drive.StopDriveTrainCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.drive.StrafeCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.drive.Turn90DegreesCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.drive.WaitCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.elevator.ElevatorIsAbovePositionNumberCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.elevator.ElevatorIsBelowPositionNumberCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.elevator.ElevatorJumpToPositionCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.elevator.ElevatorMoveToHeightCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.grabber.CloseGrabberCommand;\nimport org.usfirst.frc4915.MecanumDrive.commands.grabber.OpenGrabberCommand;\n\nimport edu.wpi.first.wpilibj.command.CommandGroup;\n\n/**\n *\n */\npublic class AutonomousCommandContainerAndReturn extends CommandGroup {\n    \n    public  AutonomousCommandContainerAndReturn() {\n        addParallel(new ElevatorMoveToHeightCommand());\n        addParallel(new StopDriveTrainCommand());\n\n        System.out.println(\"Moving Elevator (level 1.3)\");\n        addSequential(new ElevatorJumpToPositionCommand(1));\n        addSequential(new ElevatorIsAbovePositionNumberCommand(11), 1.2);\n        System.out.println(\"Closing Grabber\");\n        addSequential(new CloseGrabberCommand());\n        addSequential(new WaitCommand(.5));\n        System.out.println(\"Moving Elevator (level 2.5)\");\n        addSequential(new ElevatorJumpToPositionCommand(2.5), 0.7);\n        addSequential(new ElevatorIsAbovePositionNumberCommand(29), 1.2);\n        System.out.println(\"Driving back 8.5 ft\");\n        addSequential(new MoveStraightPositionModeCommand(-8.5, 1));\n\n        //Turn Left\n        addSequential(new Turn90DegreesCommand(true));\n        \n        System.out.println(\"Moving Elevator (level 1)\"); //puts down container\n        addSequential(new ElevatorJumpToPositionCommand(1));\n        //inches\n        addSequential(new ElevatorIsBelowPositionNumberCommand(13), 3);\n        addSequential(new OpenGrabberCommand());\n        addSequential(new WaitCommand(.5));\n        \n        // Raise the elevator to level 3 (above the container\n        addSequential(new ElevatorJumpToPositionCommand(3));\n        addSequential(new ElevatorIsAbovePositionNumberCommand(30), 3);\n        \n        // Should go right 10 feet - needs testing\n        addSequential(new StrafeCommand(10), 5);\n        addSequential(new ElevatorJumpToPositionCommand(0));\n        addSequential(new ElevatorIsBelowPositionNumberCommand(2), 1.2);\n        \n        addSequential(new WaitCommand(.5));\n        \n    }\n}\n", "-width histogram over a single integer-based field.\n */\npublic class IntHistogram {\n\tprivate final double[] buckets;\n\t// count of missing fields associated with tuples in a given bucket\n\tprivate final double[] missingFields;\n\t// count of tuples with any missing fields in a given bucket\n\tprivate final double[] missingTuples;\n\tprivate final int min, max;\n\tprivate final int valuesPerBucket;\n\tprivate int numValues;\n\t// count of missing values in this field\n\tprivate int ctMissing;\n\t\n    /**\n     * Create a new IntHistogram.\n     * \n     * This IntHistogram should maintain a histogram of integer values that it receives.\n     * It should split the histogram into \"buckets\" buckets.\n     * \n     * The values that are being histogrammed will be provided one-at-a-time through the \"addValue()\" function.\n     * \n     * Your implementation should use space and have execution time that are both\n     * constant with respect to the number of values being histogrammed.  For example, you shouldn't \n     * simply store every value that you see in a sorted list.\n     * \n     * @param buckets The number of buckets to split the input value into.\n     * @param min The minimum integer value that will ever be passed to this class for histogramming\n     * @param max The maximum integer value that will ever be passed to this class for histogramming\n     */\n    public IntHistogram(int buckets, int min, int max) { \n    \tif (min > max || buckets <= 0) {\n    \t\tthrow new IllegalArgumentException();\n    \t}\n    \tint numBuckets = Math.min(buckets, max - min + 1);\n    \tthis.buckets = new double[numBuckets];\n\t\tthis.missingFields = new double[numBuckets];\n\t\tthis.missingTuples = new double[numBuckets];\n    \tthis.min = min;\n    \tthis.max = max;\n    \tvaluesPerBucket = (int) Math.ceil((max - min + 1) / (double)this.buckets.length);\n    }\n\n\t/**\n\t * Constructor only meant to be used for copying a histogram. We have abandoned the missingFields/missingTuples\n\t * stats, so these are initialized to null (and never used)\n\t * @param buckets\n\t * @param min\n\t * @param max\n\t * @param valuesPerBucket\n\t */\n    private IntHistogram(double[] buckets, int min, int max, int valuesPerBucket) {\n\t\tthis.buckets = buckets;\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t\tthis.valuesPerBucket = valuesPerBucket;\n\t\tthis.numValues = (int) sum(buckets);\n\n\t\t// unused\n\t\tmissingFields = null;\n\t\t// count of tuples with any missing fields in a given bucket\n\t\tmissingTuples = null;\n\t}\n    \n    private int bucketOfValue(int v) {\n    \treturn (v - min) / valuesPerBucket;\n    }\n    \n    private int bucketMin(int v) {\n    \treturn (bucketOfValue(v) * valuesPerBucket) + min;\n    }\n    \n    private int bucketMax(int v) {\n    \treturn bucketMin(v) + valuesPerBucket - 1;\n    }\n    \n    private double bucketMean(int v){\n    \treturn (bucketMin(v) + bucketMax(v)) / 2.0;\n    }\n\n    /**\n     * Add a value to the set of values that you are keeping a histogram of.\n     * @param v Value to add to the histogram\n     */\n    public void addValue(int v) {\n    \tbuckets[bucketOfValue(v)]++;\n    \tnumValues++;\n    }\n\n    public void addValue(Tuple tup, int index) {\n\t\tField f = tup.getField(index);\n\t\tif (f.isMissing()) {\n\t\t\tincrCtMissing();\n\t\t} else {\n\t\t\tint vix = bucketOfValue(((IntField) f).getValue());\n\t\t\tbuckets[vix]++;\n\t\t\t// count of missing fields in this bucket\n\t\t\tList<Integer> missingIndices = tup.missingFieldsIndices();\n\t\t\tmissingFields[vix] += missingIndices.size();\n\t\t\tmissingTuples[vix] += (missingIndices.isEmpty()) ? 0 : 1;\n\t\t}\n\t\tnumValues++;\n\t}\n\n\tpublic void incrCtMissing() {\n\t\tctMissing++;\n\t}\n\n\tpublic int getCtMissing() {\n\t\treturn ctMissing;\n\t}\n\n    /**\n     * Estimate the selectivity of a particular predicate and operand on this table.\n     * \n     * For example, if \"op\" is \"GREATER_THAN\" and \"v\" is 5, \n     * return your estimate of the fraction of elements that are greater than 5.\n     * \n     * @param op Operator\n     * @param v Value\n     * @return Predicted selectivity of this particular operator and value\n     */\n    public double estimateSelectivity(Predicate.Op op, int v) {\n\t\tdouble selValues;\n\n\t\tif (v < min) {\n\t\t\tswitch(op) {\n\t\t\t\tcase EQUALS:\n\t\t\t\t\treturn 0.0;\n\t\t\t\tcase GREATER_THAN:\n\t\t\t\t\treturn 1.0;\n\t\t\t\tcase GREATER_THAN_OR_EQ:\n\t\t\t\t\treturn 1.0;\n\t\t\t\tcase LESS_THAN:\n\t\t\t\t\treturn 0.0;\n\t\t\t\tcase LESS_THAN_OR_EQ:\n\t\t\t\t\treturn 0.0;\n\t\t\t\tcase LIKE:\n\t\t\t\t\tthrow new RuntimeException(\"LIKE not valid for integer values.\");\n\t\t\t\tcase NOT_EQUALS:\n\t\t\t\t\treturn 1.0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Unexpected operator.\");\n\t\t\t}\n\t\t}\n\n\t\tif (v > max) {\n\t\t\tswitch(op) {\n\t\t\t\tcase EQUALS:\n\t\t\t\t\treturn 0.0;\n\t\t\t\tcase GREATER_THAN:\n\t\t\t\t\treturn 0.0;\n\t\t\t\tcase GREATER_THAN_OR_EQ:\n\t\t\t\t\treturn 0.0;\n\t\t\t\tcase LESS_THAN:\n\t\t\t\t\treturn 1.0;\n\t\t\t\tcase LESS_THAN_OR_EQ:\n\t\t\t\t\treturn 1.0;\n\t\t\t\tcase LIKE:\n\t\t\t\t\tthrow new RuntimeException(\"LIKE not valid for integer values.\");\n\t\t\t\tcase NOT_EQUALS:\n\t\t\t\t\treturn 1.0;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Unexpected operator.\");\n\t\t\t}\n\t\t}\n\n\t\tswitch(op) {\n\t\t\tcase EQUALS:\n\t\t\t\tselValues = buckets[bucketOfValue(v)] / valuesPerBucket;\n\t\t\t\tbreak;\n\t\t\tcase GREATER_THAN:\n\t\t\t\tselValues = (buckets[bucketOfValue(v)] / valuesPerBucket) * (bucketMax(v) - v);\n\t\t\t\tfor (int b = bucketOfValue(v) + 1; b < buckets.length; b++) {\n\t\t\t\t\tselValues += buckets[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GREATER_THAN_OR_EQ:\n\t\t\t\tselValues = (buckets[bucketOfValue(v)] / valuesPerBucket) * (bucketMax(v) - v + 1);\n\t\t\t\tfor (int b = bucketOfValue(v) + 1; b < buckets.length; b++) {\n\t\t\t\t\tselValues += buckets[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LESS_THAN:\n\t\t\t\tselValues = (buckets[bucketOfValue(v)] / valuesPerBucket) * (v - bucketMin(v));\n\t\t\t\tfor (int b = bucketOfValue(v) - 1; b >= 0; b--) {\n\t\t\t\t\tselValues += buckets[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LESS_THAN_OR_EQ:\n\t\t\t\tselValues = (buckets[bucketOfValue(v)] / valuesPerBucket) * (v - bucketMin(v) + 1);\n\t\t\t\tfor (int b = bucketOfValue(v) - 1; b >= 0; b--) {\n\t\t\t\t\tselValues += buckets[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LIKE:\n\t\t\t\tthrow new RuntimeException(\"LIKE not valid for integer values.\");\n\t\t\tcase NOT_EQUALS:\n\t\t\t\tselValues = numValues - (buckets[bucketOfValue(v)] / valuesPerBucket);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unexpected operator.\");\n\t\t}\n\n\t\treturn selValues / numValues;\n\t}\n\n\t/**\n\t * Estimating selectivity relative to null (i.e. missing). Only defined over equals and not-equals\n\t * This is a stand in for traditional SQL\n\t * SELECT * FROM t WHERE c1 IS [NOT] NULL\n\t * @param op\n\t * @return\n\t */\n\tpublic double estimateSelectivityNull(Predicate.Op op) {\n\t\tswitch(op) {\n\t\t\tcase EQUALS:\n\t\t\t\treturn ((double) getCtMissing()) / numValues;\n\t\t\tcase NOT_EQUALS:\n\t\t\t\treturn ((double) numValues - getCtMissing()) / numValues;\n\t\t\tdefault:\n\t\t\t\treturn 0.0;\n\t\t}\n\t}\n\n\tprivate double sum(double[] vs) {\n\t\tdouble res = 0;\n\t\tfor (double v : vs) res+= v;\n\t\treturn res;\n\t}\n\t\n\tpublic double mean() {\n\t\tdouble sum = 0.0;\n\t\tfor (int v=0; v<buckets.length; v++){\n\t\t\tsum += buckets[v] * bucketMean(v);\n\t\t}\n\t\treturn sum / this.numValues;\n\t}\n\t\n\tpublic double variance() {\n\t\tdouble mean = this.mean();\n\t\tdouble sum  = 0.0;\n\t\tfor (int v=0; v<buckets.length; v++){\n\t\t\tsum += buckets[v] * Math.pow(bucketMean(v) - mean, 2.0);\n\t\t}\n\t\treturn sum / this.numValues;\n\t}\n\n\t/**\n\t * Estimate number of empty fields, or tuples with at least one empty field, result from the given selection.\n\t * @param op\n\t * @param v\n\t * @param granular if true, returns number of fields, if false, returns number of tuples\n\t * @return\n\t */\n\tpublic double estimateMissing(Predicate.Op op, int v, boolean granular) {\n\t\tdouble[] missing;\n\n\t\tif (granular) {\n\t\t\tmissing = missingFields;\n\t\t} else {\n\t\t\tmissing = missingTuples;\n\t\t}\n\n\t\tdouble estimate = 0;\n\n\t\tif (v < min) {\n\t\t\tswitch(op) {\n\t\t\t\tcase EQUALS:\n\t\t\t\tcase LIKE:\n\t\t\t\t\treturn 0;\n\t\t\t\tcase GREATER_THAN:\n\t\t\t\tcase GREATER_THAN_OR_EQ:\n\t\t\t\t\treturn sum(missing);\n\t\t\t\tcase LESS_THAN:\n\t\t\t\tcase LESS_THAN_OR_EQ:\n\t\t\t\t\treturn 0;\n\t\t\t\tcase NOT_EQUALS:\n\t\t\t\t\treturn sum(missing);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Unexpected operator.\");\n\t\t\t}\n\t\t}\n\n\t\tif (v > max) {\n\t\t\tswitch(op) {\n\t\t\t\tcase EQUALS:\n\t\t\t\tcase LIKE:\n\t\t\t\tcase GREATER_THAN:\n\t\t\t\tcase GREATER_THAN_OR_EQ:\n\t\t\t\t\treturn 0;\n\t\t\t\tcase LESS_THAN:\n\t\t\t\tcase LESS_THAN_OR_EQ:\n\t\t\t\t\treturn sum(missing);\n\t\t\t\tcase NOT_EQUALS:\n\t\t\t\t\treturn sum(missing);\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new RuntimeException(\"Unexpected operator.\");\n\t\t\t}\n\t\t}\n\n\t\tswitch(op) {\n\t\t\tcase EQUALS:\n\t\t\t\testimate += missing[bucketOfValue(v)] / valuesPerBucket;\n\t\t\t\tbreak;\n\t\t\tcase GREATER_THAN:\n\t\t\t\testimate += (missing[bucketOfValue(v)] / valuesPerBucket) * (bucketMax(v) - v);\n\t\t\t\tfor (int b = bucketOfValue(v) + 1; b < missing.length; b++) {\n\t\t\t\t\testimate += missing[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase GREATER_THAN_OR_EQ:\n\t\t\t\testimate += (missing[bucketOfValue(v)] / valuesPerBucket) * (bucketMax(v) - v + 1);\n\t\t\t\tfor (int b = bucketOfValue(v) + 1; b < missing.length; b++) {\n\t\t\t\t\testimate += missing[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LESS_THAN:\n\t\t\t\testimate += (missing[bucketOfValue(v)] / valuesPerBucket) * (v - bucketMin(v));\n\t\t\t\tfor (int b = bucketOfValue(v) - 1; b >= 0; b--) {\n\t\t\t\t\testimate += missing[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LESS_THAN_OR_EQ:\n\t\t\t\testimate += (missing[bucketOfValue(v)] / valuesPerBucket) * (v - bucketMin(v) + 1);\n\t\t\t\tfor (int b = bucketOfValue(v) - 1; b >= 0; b--) {\n\t\t\t\t\testimate += missing[b];\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\tcase LIKE:\n\t\t\t\tthrow new RuntimeException(\"LIKE not valid for integer values.\");\n\t\t\tcase NOT_EQUALS:\n\t\t\t\testimate += sum(missing) - (missing[bucketOfValue(v)] / valuesPerBucket);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException(\"Unexpected operator.\");\n\t\t}\n\n\t\treturn estimate;\n\t}\n\n    /**\n     * @return\n     *     the average selectivity of this histogram.\n     *     \n     *     This is not an indispensable method to implement the basic\n     *     join optimization. It may be needed if you want to\n     *     implement a more efficient optimization\n     * */\n    public double avgSelectivity() {\n        // some code goes here\n        return 1.0;\n    }\n    \n    /**\n     * @return A string describing this histogram, for debugging purposes\n     */\n    public String toString() {\n        // some code goes here\n        return null;\n    }\n\n\t/**\n\t * Return a count of the (non-null) tuples by summing across buckets\n\t * @return\n\t */\n\tpublic double countTuples() {\n\t\treturn sum(buckets);\n\t}\n\n\t/**\n\t * Create a copy of the existing histogram\n\t * @return\n\t */\n\tpublic IntHistogram copyHistogram() {\n\t\tdouble[] copyBuckets = Arrays.copyOf(buckets, buckets.length);\n\t\treturn new IntHistogram(copyBuckets, min, max, valuesPerBucket);\n\t}\n\n\t/**\n\t * Adjust buckets\n\t * @param ct count to use for adjustment\n\t * @param denom denominator for adjustment\n\t * @param add if true, adds to existing value, otherwise overwrites existing value\n\t */\n\tprivate void adjustBuckets(double ct, double denom, boolean add) {\n\t\tfor(int i = 0; i < buckets.length; i++) {\n\t\t\tif (add) {\n\t\t\t\tbuckets[i] += (buckets[i] / denom) * ct;\n\t\t\t} else {\n\t\t\t\tbuckets[i] = (buckets[i] / denom) * ct;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Scale all buckets by a constant factor\n\t * @param factor\n\t */\n\tpublic void scaleBy(double factor) {\n\t\tadjustBuckets(factor, 1, false);\n\t\tnumValues = (int) countTuples();\n\t}\n\n\t/**\n\t * Add a number of new tuples to the existing distribution\n\t * @param newTuples\n\t */\n\tpublic void addToDistribution(double newTuples) {\n\t\tadjustBuckets(newTuples, countTuples(), true);\n\t\tnumValues += (int) newTuples;\n\t}\n\n\t/**\n\t * Set counts in each bucket according to existing distribution s.t. total number of couts\n\t * is equal to ctTuples\n\t * @param ctTuples\n\t */\n\tpublic void scaleTo(double ctTuples) {\n\t\tadjustBuckets(ctTuples, countTuples(), false);\n\t\tnumValues = (int) ctTuples;\n\t}\n\n\tpublic double[] getBuckets() {\n\t\treturn buckets;\n\t}\n\n\n}\n", "est.entities.PerformanceDataTestHelper;\nimport com.microsoft.bingads.v10.api.test.entities.QualityScoreDataTestHelper;\nimport com.microsoft.bingads.v10.bulk.entities.BulkKeyword;\nimport org.junit.Test;\n\npublic class BulkKeywordReadWriteTest {\n    \n    @Test\n    public void bulkKeyword_ReadPerfData_WriteToFile() {\n        PerformanceDataTestHelper.testPerformanceDataReadWrite(new BulkKeyword());       \n    }\n\n    @Test\n    public void bulkKeyword_ReadQSData_WriteToFile() {\n        QualityScoreDataTestHelper.testQualityScoreDataReadWrite(new BulkKeyword());\n    }\n}\n", " public static void main(String[] args) {\n      BST bst = new BST();\n      /*\n             50\n          25    75\n        15  30     85\n       */\n      bst.addNode(new BSTNode(50));\n      bst.addNode(new BSTNode(25));\n      bst.addNode(new BSTNode(75));\n      bst.addNode(new BSTNode(15));\n      bst.addNode(new BSTNode(30));\n      bst.addNode(new BSTNode(85));\n      \n      // In-order traversal.\n      System.out.println(\"In order left->root->right\");\n      bst.inOrderTraversal(bst.mRoot);\n\n      // Post-order traversal\n      System.out.println(\"\\nPost order left->right->root\");\n      bst.postOrderTraversal(bst.mRoot);\n\n      // Pore-order traversal\n      System.out.println(\"\\nPre order root->left->right\");\n      bst.preOrderTraversal(bst.mRoot);\n\n   }\n   \n   /**\n    * Add node to the tree.\n    * @param n Node to add.\n    */\n   public void addNode(BSTNode n) {\n      BSTNode tmp = mRoot;\n      \n      while(true) {\n         if(mRoot == null) {\n            mRoot = n;\n            return;\n         }\n         \n         if(n.value < tmp.value) {\n            if(tmp.leftNode != null) {\n               tmp = tmp.leftNode;\n            }\n            else {\n               tmp.leftNode = n;\n               return;\n            }\n         }\n         else {\n            if(tmp.rightNode != null) {\n               tmp = tmp.rightNode;\n            }\n            else {\n              tmp.rightNode = n;\n              return;\n            }\n         }\n      }\n   }\n   \n   /**\n    * Left->Root->Right\n    * @param root\n    */\n   public void inOrderTraversal(BSTNode node) {\n      if(node != null) {\n         inOrderTraversal(node.leftNode);\n         System.out.print(node.value + \" \");\n         inOrderTraversal(node.rightNode);\n      }\n   }\n   \n   /**\n    * Left->Right->Root\n    * @param root\n    */\n   public void postOrderTraversal(BSTNode node) {\n      if(node != null) {\n         postOrderTraversal(node.leftNode);\n         postOrderTraversal(node.rightNode);\n         System.out.print(node.value + \" \");\n      }\n   }   \n\n   /**\n    * Root->Left->Right\n    * @param root\n    */\n   public void preOrderTraversal(BSTNode node) {\n      if(node != null) {\n         System.out.print(node.value + \" \");\n         preOrderTraversal(node.leftNode);\n         preOrderTraversal(node.rightNode);\n      }\n   }   \n}\n\nclass BSTNode {\n   int value;\n   BSTNode leftNode;\n   BSTNode rightNode;\n   \n   public BSTNode(int v) {\n      value = v;\n   }\n}\n\n\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.jvmstat.perfdata.monitor.protocol.local;\n\nimport sun.jvmstat.monitor.*;\nimport sun.jvmstat.monitor.event.*;\nimport sun.jvmstat.perfdata.monitor.*;\nimport java.util.*;\nimport java.net.*;\n\n/**\n * Concrete implementation of the MonitoredHost interface for the\n * <em>local</em> protocol of the HotSpot PerfData monitoring implementation.\n *\n * @author Brian Doherty\n * @since 1.5\n */\npublic class MonitoredHostProvider extends MonitoredHost {\n    private static final int DEFAULT_POLLING_INTERVAL = 1000;\n\n    private ArrayList<HostListener> listeners;\n    private NotifierTask task;\n    private HashSet<Integer> activeVms;\n    private LocalVmManager vmManager;\n\n    /**\n     * Create a MonitoredHostProvider instance using the given HostIdentifier.\n     *\n     * @param hostId the host identifier for this MonitoredHost\n     */\n    public MonitoredHostProvider(HostIdentifier hostId) {\n        this.hostId = hostId;\n        this.listeners = new ArrayList<HostListener>();\n        this.interval = DEFAULT_POLLING_INTERVAL;\n        this.activeVms = new HashSet<Integer>();\n        this.vmManager = new LocalVmManager();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MonitoredVm getMonitoredVm(VmIdentifier vmid)\n                       throws MonitorException {\n        return getMonitoredVm(vmid, DEFAULT_POLLING_INTERVAL);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public MonitoredVm getMonitoredVm(VmIdentifier vmid, int interval)\n                       throws MonitorException {\n        try {\n            VmIdentifier nvmid = hostId.resolve(vmid);\n            return new LocalMonitoredVm(nvmid, interval);\n        } catch (URISyntaxException e) {\n            /*\n             * the VmIdentifier is expected to be a valid and it should\n             * resolve reasonably against the host identifier. A\n             * URISyntaxException here is most likely a programming error.\n             */\n            throw new IllegalArgumentException(\"Malformed URI: \"\n                                               + vmid.toString(), e);\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void detach(MonitoredVm vm) {\n        vm.detach();\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void addHostListener(HostListener listener) {\n        synchronized(listeners) {\n            listeners.add(listener);\n            if (task == null) {\n                task = new NotifierTask();\n                LocalEventTimer timer = LocalEventTimer.getInstance();\n                timer.schedule(task, interval, interval);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void removeHostListener(HostListener listener) {\n        synchronized(listeners) {\n            listeners.remove(listener);\n            if (listeners.isEmpty() && (task != null)) {\n                task.cancel();\n                task = null;\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public void setInterval(int newInterval) {\n        synchronized(listeners) {\n            if (newInterval == interval) {\n                return;\n            }\n\n            int oldInterval = interval;\n            super.setInterval(newInterval);\n\n            if (task != null) {\n                task.cancel();\n                NotifierTask oldTask = task;\n                task = new NotifierTask();\n                LocalEventTimer timer = LocalEventTimer.getInstance();\n                CountedTimerTaskUtils.reschedule(timer, oldTask, task,\n                                                 oldInterval, newInterval);\n            }\n        }\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    public Set<Integer> activeVms() {\n        return vmManager.activeVms();\n    }\n\n    /**\n     * Fire VmEvent events.\n     *\n     * @param active a set of Integer objects containing the vmid of\n     *               the active Vms\n     * @param started a set of Integer objects containing the vmid of\n     *                new Vms started since last interval.\n     * @param terminated a set of Integer objects containing the vmid of\n     *                   terminated Vms since last interval.\n     */\n    private void fireVmStatusChangedEvents(Set active, Set started,\n                                           Set terminated) {\n        ArrayList registered = null;\n        VmStatusChangeEvent ev = null;\n\n        synchronized(listeners) {\n            registered = (ArrayList)listeners.clone();\n        }\n\n        for (Iterator i = registered.iterator(); i.hasNext(); /* empty */) {\n            HostListener l = (HostListener)i.next();\n            if (ev == null) {\n                ev = new VmStatusChangeEvent(this, active, started, terminated);\n            }\n            l.vmStatusChanged(ev);\n        }\n    }\n\n    /**\n     * Class to poll the local system and generate event notifications.\n     */\n    private class NotifierTask extends CountedTimerTask {\n        public void run() {\n            super.run();\n\n            // save the last set of active JVMs\n            Set lastActiveVms = activeVms;\n\n            // get the current set of active JVMs\n            activeVms = (HashSet<Integer>)vmManager.activeVms();\n\n            if (activeVms.isEmpty()) {\n                return;\n            }\n            Set<Integer> startedVms = new HashSet<Integer>();\n            Set<Object> terminatedVms = new HashSet<Object>();\n\n            for (Iterator i = activeVms.iterator(); i.hasNext(); /* empty */) {\n                Integer vmid = (Integer)i.next();\n                if (!lastActiveVms.contains(vmid)) {\n                    // a new file has been detected, add to set\n                    startedVms.add(vmid);\n                }\n            }\n\n            for (Iterator i = lastActiveVms.iterator(); i.hasNext();\n                    /* empty */) {\n                Object o = i.next();\n                if (!activeVms.contains(o)) {\n                    // JVM has terminated, remove it from the active list\n                    terminatedVms.add(o);\n                }\n            }\n\n            if (!startedVms.isEmpty() || !terminatedVms.isEmpty()) {\n                fireVmStatusChangedEvents(activeVms, startedVms,\n                                          terminatedVms);\n            }\n        }\n    }\n}\n", ".google.gwt.resources.client.ImageResource;\n\npublic interface PieceImages extends ClientBundle {\n  @Source(\"images/pieces/1.png\")\n  ImageResource piece1();\n\n  @Source(\"images/pieces/2.png\")\n  ImageResource piece2();\n\n  @Source(\"images/pieces/3.png\")\n  ImageResource piece3();\n\n  @Source(\"images/pieces/4.png\")\n  ImageResource piece4();\n\n  @Source(\"images/pieces/5.png\")\n  ImageResource piece5();\n\n  @Source(\"images/pieces/6.png\")\n  ImageResource piece6();\n\n  @Source(\"images/pieces/7.png\")\n  ImageResource piece7();\n\n  @Source(\"images/pieces/8.png\")\n  ImageResource piece8();\n\n  @Source(\"images/pieces/9.png\")\n  ImageResource piece9();\n\n  @Source(\"images/pieces/10.png\")\n  ImageResource piece10();\n\n  @Source(\"images/pieces/11.png\")\n  ImageResource piece11();\n\n  @Source(\"images/pieces/12.png\")\n  ImageResource piece12();\n\n  @Source(\"images/pieces/13.png\")\n  ImageResource piece13();\n\n  @Source(\"images/pieces/14.png\")\n  ImageResource piece14();\n\n  @Source(\"images/pieces/15.png\")\n  ImageResource piece15();\n\n  @Source(\"images/pieces/16.png\")\n  ImageResource piece16();\n\n  @Source(\"images/pieces/17.png\")\n  ImageResource piece17();\n\n  @Source(\"images/pieces/18.png\")\n  ImageResource piece18();\n\n  @Source(\"images/pieces/19.png\")\n  ImageResource piece19();\n\n  @Source(\"images/pieces/20.png\")\n  ImageResource piece20();\n\n  @Source(\"images/pieces/21.png\")\n  ImageResource piece21();\n}\n", "ct;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.MediaType;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\nimport br.senai.sp.informatica.todolist.dao.ItemDAO;\nimport br.senai.sp.informatica.todolist.modelo.ItemLista;\n\n\n@RestController \npublic class ItemRestController {\n\n\t@Autowired\n\tprivate ItemDAO itemDao;\n\t\n\t@RequestMapping(value=\"/item/{id}\", method=RequestMethod.PUT, \n\t\t\tconsumes=MediaType.APPLICATION_JSON_UTF8_VALUE)\n\tpublic ResponseEntity<Void> marcarFeito(@PathVariable(\"id\") long idItem, @RequestBody String strFeito){\n\t\t \t\t\n\t\t\ttry {\n\t\t\t\tJSONObject job = new JSONObject(strFeito);\n\t\t\t\t itemDao.marcarFeito(idItem, job.getBoolean(\"feito\"));\n\t\t\t\t HttpHeaders responseHeaader = new HttpHeaders();\n\t\t\t\t URI location = new URI(\"/item/\" + idItem);\n\t\t\t\t responseHeaader.setLocation(location);\n\t\t\t\t \t\t\t\t \n\t\t\t\t return new  ResponseEntity<Void>(responseHeaader, HttpStatus.OK);\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn new  ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t\t}\n \t\n\t}\n\t\n\t@RequestMapping(value=\"/lista/{id}/item\", method=RequestMethod.POST, \n\t\t\tconsumes=MediaType.APPLICATION_JSON_UTF8_VALUE)\n\tpublic ResponseEntity<ItemLista> addItem(@PathVariable(\"id\") long idLista, @RequestBody ItemLista item){\n\t\titemDao.inserir(idLista, item);\n\t\n\t\ttry {\n\t\t\t \n\t\t\t URI location = new URI(\"/item/\" + item.getId());\n\t\t\t return    ResponseEntity.created(location).body(item);\n\t\t} catch (Exception e) {\n\t\t\treturn new  ResponseEntity<>(HttpStatus.INTERNAL_SERVER_ERROR);\n\t\t}\n\t\t\n\t\t\n\t}\n\t\n\t@RequestMapping(value=\"/item/{idItem}\", method=RequestMethod.GET, \n\t\t\tproduces=MediaType.APPLICATION_JSON_UTF8_VALUE)\n\tpublic ItemLista mostrarLista(@PathVariable(\"idItem\") Long idItem){\n\t\treturn itemDao.mostrarItem(idItem);\n\t}\n\t\n}\n", "\n    PlayerRevive,\n    PlayerDevive,\n    ModRevive,\n    DimensionRevive;\n\n    public LinkedList<Object> list;\n\n    public static void load()\n    {\n        for (ReviveChange change : values())\n            change.list = new LinkedList<Object>();\n    }\n}\n", ".graphics.VertexAttribute;\nimport com.badlogic.gdx.graphics.VertexAttributes;\nimport com.badlogic.gdx.utils.Disposable;\n\n/**\n * Created by macbury on 04.08.15.\n */\npublic class MeshFactory implements Disposable {\n  private VertexAttribute[] attributes;\n  public float verties[];\n  public short indices[];\n\n  public MeshFactory(float[] verties, short[] indices, VertexAttribute[] meshAttributtes) {\n    this.verties = verties;\n    this.indices = indices;\n    this.attributes = meshAttributtes;\n  }\n\n  public MeshFactory(float[] verties, short[] indices, MeshVertexInfo.AttributeType[] attributes) {\n    this.verties = verties;\n    this.indices = indices;\n\n    this.attributes = new VertexAttribute[attributes.length];\n    for (int i = 0; i < attributes.length; i++) {\n      this.attributes[i] = attributes[i].attribute();\n    }\n  }\n\n  public Mesh get() {\n    Mesh mesh = new Mesh(true, verties.length, indices.length, attributes);\n    mesh.setVertices(verties);\n    mesh.setIndices(indices);\n    mesh.setAutoBind(false);\n    return mesh;\n  }\n\n  @Override\n  public void dispose() {\n    verties    = null;\n    indices    = null;\n    attributes = null;\n  }\n}\n", "nted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.ochafik.util;\n\nimport java.util.Iterator;\n\npublic class IntVector implements IntArray {\n\tprivate int[] array;\n\tprivate int nextPosition;\n\t\n\tpublic IntVector() {\n\t\t// it would be silly to create a zero-sized array by default, wouldn't it ?\n\t\tthis(1);\n\t}\n\tpublic IntVector(int initialCapacity) {\n\t\tarray = new int[initialCapacity];\n\t}\n\t\n\tpublic void add(int v) {\n\t\tpushBack(v);\n\t}\n\t\n\tpublic int back() {\n\t\treturn array[nextPosition - 1];\n\t}\n\t\n\tpublic void ensureCapacity(int minCapacity) {\n\t\tif (array.length >= minCapacity) return;\n\t\t\n\t\t// Use same growth policy as C++ STL's default vector implementation\n\t\tsetArraySize(minCapacity < 7 ? minCapacity : (int)(minCapacity * 1.6));\n\t}\n\t\n\tprotected void setArraySize(int size) {\n\tif (array.length == size) return;\n\t\t\n\t\tint[] newArray = new int[size];\n\t\tSystem.arraycopy(array, 0, newArray, 0, Math.min(size, array.length));\n\t\tarray = newArray;\n\t}\n\n\tpublic void resize(int size) {\n\t\tsetArraySize(size);\n\t\tnextPosition = size;\n\t}\n\t\n\tpublic void pushBack(int v) {\n\t\tif (nextPosition >= array.length) {\n\t\t\tensureCapacity(array.length + 1);\n\t\t}\n\t\tarray[nextPosition++] = v;\n\t}\n\tpublic void insert(int offset, int value) {\n\t\tif (offset > nextPosition) {\n\t\t\t// case of offset < 0 tested below when accessing array[offset]\n            throw new ArrayIndexOutOfBoundsException(offset);\n        }\n\t\t\n\t\tif (offset == nextPosition) {\n            add(value);\n            return;\n        }\n        ensureCapacity(nextPosition + 1);\n        \n        System.arraycopy(array, offset, array, offset + 1, nextPosition - offset);\n        array[offset] = value;\n        nextPosition++;\n    }\n\tpublic void remove(int offset) {\n\t\tif (offset < 0 || offset >= nextPosition) {\n            throw new ArrayIndexOutOfBoundsException(offset);\n        }\n\t\t\n\t\tnextPosition--;\n\t\t\n        if (offset != nextPosition) {\n            System.arraycopy(array, offset + 1, array, offset, nextPosition - offset);\n        }\n        \n    }\n\t\n\tpublic int popBack() {\n\t\treturn array[--nextPosition];\n\t}\n\t\n\tpublic int size() {\n\t\treturn nextPosition;\n\t}\n\t\n\tpublic int get(int pos) {\n\t\tif (pos >= nextPosition) throw new ArrayIndexOutOfBoundsException(pos);\n\t\treturn array[pos];\n\t}\n\t\n\tpublic int[] getBackingArray() {\n\t\treturn array;\n\t}\n\t\n\tpublic void set(int pos, int value) {\n\t\tif (pos >= nextPosition) throw new ArrayIndexOutOfBoundsException(pos);\n\t\tarray[pos] = value;\n\t}\n\t@Override\n\tpublic String toString() {\n\t\treturn IntArrayUtils.toString(this);\n\t}\n\tpublic int[] toArray() {\n\t\tint len = size();\n\t\tint[] newArray = new int[len];\n\t\tSystem.arraycopy(array, 0, newArray, 0, len);\n\t\treturn newArray;\n\t}\n\tpublic boolean isEmpty() {\n\t\treturn nextPosition == 0;\n\t}\n\tpublic void clear() {\n\t\tnextPosition = 0;\n\t}\n\tpublic void fill(int v) {\n\t\tfor (int i = nextPosition; i-- != 0;) array[i] = v;\n\t}\n\tpublic void addAll(IntArray other) {\n\t\tint len = other.size();\n\t\tensureCapacity(size() + len);\n\t\tint[] a = other.getBackingArray();\n\t\tif (a != null) {\n\t\t\tSystem.arraycopy(a, 0, array, nextPosition, len);\n\t\t} else {\n\t\t\tint n = nextPosition;\n\t\t\tfor (int i = 0; i < len; i++) {\n\t\t\t\tarray[n + i] = other.get(i);\n\t\t\t}\n\t\t}\n\t\tnextPosition += len;\n\t}\n\tpublic Iterator<Integer> iterator() {\n\t\treturn IntArrayUtils.iterator(this);\n\t}\n}\n", "gePowered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.api.entity.living.monster;\n\nimport org.spongepowered.api.entity.living.Ranger;\n\n/**\n * Represents a Witch.\n */\npublic interface Witch extends Monster, Ranger {\n\n}\n", "; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * This file is available under and governed by the GNU General Public\n * License version 2 only, as published by the Free Software Foundation.\n * However, the following notice accompanied the original version of this\n * file:\n *\n * Written by Doug Lea with assistance from members of JCP JSR-166\n * Expert Group and released to the public domain, as explained at\n * http://creativecommons.org/publicdomain/zero/1.0/\n */\n\npackage java.util.concurrent.locks;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.concurrent.atomic.*;\n\n/**\n * A reentrant mutual exclusion {@link Lock} with the same basic\n * behavior and semantics as the implicit monitor lock accessed using\n * {@code synchronized} methods and statements, but with extended\n * capabilities.\n *\n * <p>A {@code ReentrantLock} is <em>owned</em> by the thread last\n * successfully locking, but not yet unlocking it. A thread invoking\n * {@code lock} will return, successfully acquiring the lock, when\n * the lock is not owned by another thread. The method will return\n * immediately if the current thread already owns the lock. This can\n * be checked using methods {@link #isHeldByCurrentThread}, and {@link\n * #getHoldCount}.\n *\n * <p>The constructor for this class accepts an optional\n * <em>fairness</em> parameter.  When set {@code true}, under\n * contention, locks favor granting access to the longest-waiting\n * thread.  Otherwise this lock does not guarantee any particular\n * access order.  Programs using fair locks accessed by many threads\n * may display lower overall throughput (i.e., are slower; often much\n * slower) than those using the default setting, but have smaller\n * variances in times to obtain locks and guarantee lack of\n * starvation. Note however, that fairness of locks does not guarantee\n * fairness of thread scheduling. Thus, one of many threads using a\n * fair lock may obtain it multiple times in succession while other\n * active threads are not progressing and not currently holding the\n * lock.\n * Also note that the untimed {@link #tryLock() tryLock} method does not\n * honor the fairness setting. It will succeed if the lock\n * is available even if other threads are waiting.\n *\n * <p>It is recommended practice to <em>always</em> immediately\n * follow a call to {@code lock} with a {@code try} block, most\n * typically in a before/after construction such as:\n *\n * <pre>\n * class X {\n *   private final ReentrantLock lock = new ReentrantLock();\n *   // ...\n *\n *   public void m() {\n *     lock.lock();  // block until condition holds\n *     try {\n *       // ... method body\n *     } finally {\n *       lock.unlock()\n *     }\n *   }\n * }\n * </pre>\n *\n * <p>In addition to implementing the {@link Lock} interface, this\n * class defines methods {@code isLocked} and\n * {@code getLockQueueLength}, as well as some associated\n * {@code protected} access methods that may be useful for\n * instrumentation and monitoring.\n *\n * <p>Serialization of this class behaves in the same way as built-in\n * locks: a deserialized lock is in the unlocked state, regardless of\n * its state when serialized.\n *\n * <p>This lock supports a maximum of 2147483647 recursive locks by\n * the same thread. Attempts to exceed this limit result in\n * {@link Error} throws from locking methods.\n *\n * @since 1.5\n * @author Doug Lea\n */\npublic class ReentrantLock implements Lock, java.io.Serializable {\n    private static final long serialVersionUID = 7373984872572414699L;\n    /** Synchronizer providing all implementation mechanics */\n    private final Sync sync;\n\n    /**\n     * Base of synchronization control for this lock. Subclassed\n     * into fair and nonfair versions below. Uses AQS state to\n     * represent the number of holds on the lock.\n     */\n    abstract static class Sync extends AbstractQueuedSynchronizer {\n        private static final long serialVersionUID = -5179523762034025860L;\n\n        /**\n         * Performs {@link Lock#lock}. The main reason for subclassing\n         * is to allow fast path for nonfair version.\n         */\n        abstract void lock();\n\n        /**\n         * Performs non-fair tryLock.  tryAcquire is\n         * implemented in subclasses, but both need nonfair\n         * try for trylock method.\n         */\n        final boolean nonfairTryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0) // overflow\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n\n        protected final boolean tryRelease(int releases) {\n            int c = getState() - releases;\n            if (Thread.currentThread() != getExclusiveOwnerThread())\n                throw new IllegalMonitorStateException();\n            boolean free = false;\n            if (c == 0) {\n                free = true;\n                setExclusiveOwnerThread(null);\n            }\n            setState(c);\n            return free;\n        }\n\n        protected final boolean isHeldExclusively() {\n            // While we must in general read state before owner,\n            // we don't need to do so to check if current thread is owner\n            return getExclusiveOwnerThread() == Thread.currentThread();\n        }\n\n        final ConditionObject newCondition() {\n            return new ConditionObject();\n        }\n\n        // Methods relayed from outer class\n\n        final Thread getOwner() {\n            return getState() == 0 ? null : getExclusiveOwnerThread();\n        }\n\n        final int getHoldCount() {\n            return isHeldExclusively() ? getState() : 0;\n        }\n\n        final boolean isLocked() {\n            return getState() != 0;\n        }\n\n        /**\n         * Reconstitutes this lock instance from a stream.\n         * @param s the stream\n         */\n        private void readObject(java.io.ObjectInputStream s)\n            throws java.io.IOException, ClassNotFoundException {\n            s.defaultReadObject();\n            setState(0); // reset to unlocked state\n        }\n    }\n\n    /**\n     * Sync object for non-fair locks\n     */\n    static final class NonfairSync extends Sync {\n        private static final long serialVersionUID = 7316153563782823691L;\n\n        /**\n         * Performs lock.  Try immediate barge, backing up to normal\n         * acquire on failure.\n         */\n        final void lock() {\n            if (compareAndSetState(0, 1))\n                setExclusiveOwnerThread(Thread.currentThread());\n            else\n                acquire(1);\n        }\n\n        protected final boolean tryAcquire(int acquires) {\n            return nonfairTryAcquire(acquires);\n        }\n    }\n\n    /**\n     * Sync object for fair locks\n     */\n    static final class FairSync extends Sync {\n        private static final long serialVersionUID = -3000897897090466540L;\n\n        final void lock() {\n            acquire(1);\n        }\n\n        /**\n         * Fair version of tryAcquire.  Don't grant access unless\n         * recursive call or no waiters or is first.\n         */\n        protected final boolean tryAcquire(int acquires) {\n            final Thread current = Thread.currentThread();\n            int c = getState();\n            if (c == 0) {\n                if (!hasQueuedPredecessors() &&\n                    compareAndSetState(0, acquires)) {\n                    setExclusiveOwnerThread(current);\n                    return true;\n                }\n            }\n            else if (current == getExclusiveOwnerThread()) {\n                int nextc = c + acquires;\n                if (nextc < 0)\n                    throw new Error(\"Maximum lock count exceeded\");\n                setState(nextc);\n                return true;\n            }\n            return false;\n        }\n    }\n\n    /**\n     * Creates an instance of {@code ReentrantLock}.\n     * This is equivalent to using {@code ReentrantLock(false)}.\n     */\n    public ReentrantLock() {\n        sync = new NonfairSync();\n    }\n\n    /**\n     * Creates an instance of {@code ReentrantLock} with the\n     * given fairness policy.\n     *\n     * @param fair {@code true} if this lock should use a fair ordering policy\n     */\n    public ReentrantLock(boolean fair) {\n        sync = fair ? new FairSync() : new NonfairSync();\n    }\n\n    /**\n     * Acquires the lock.\n     *\n     * <p>Acquires the lock if it is not held by another thread and returns\n     * immediately, setting the lock hold count to one.\n     *\n     * <p>If the current thread already holds the lock then the hold\n     * count is incremented by one and the method returns immediately.\n     *\n     * <p>If the lock is held by another thread then the\n     * current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until the lock has been acquired,\n     * at which time the lock hold count is set to one.\n     */\n    public void lock() {\n        sync.lock();\n    }\n\n    /**\n     * Acquires the lock unless the current thread is\n     * {@linkplain Thread#interrupt interrupted}.\n     *\n     * <p>Acquires the lock if it is not held by another thread and returns\n     * immediately, setting the lock hold count to one.\n     *\n     * <p>If the current thread already holds this lock then the hold count\n     * is incremented by one and the method returns immediately.\n     *\n     * <p>If the lock is held by another thread then the\n     * current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until one of two things happens:\n     *\n     * <ul>\n     *\n     * <li>The lock is acquired by the current thread; or\n     *\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts} the\n     * current thread.\n     *\n     * </ul>\n     *\n     * <p>If the lock is acquired by the current thread then the lock hold\n     * count is set to one.\n     *\n     * <p>If the current thread:\n     *\n     * <ul>\n     *\n     * <li>has its interrupted status set on entry to this method; or\n     *\n     * <li>is {@linkplain Thread#interrupt interrupted} while acquiring\n     * the lock,\n     *\n     * </ul>\n     *\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared.\n     *\n     * <p>In this implementation, as this method is an explicit\n     * interruption point, preference is given to responding to the\n     * interrupt over normal or reentrant acquisition of the lock.\n     *\n     * @throws InterruptedException if the current thread is interrupted\n     */\n    public void lockInterruptibly() throws InterruptedException {\n        sync.acquireInterruptibly(1);\n    }\n\n    /**\n     * Acquires the lock only if it is not held by another thread at the time\n     * of invocation.\n     *\n     * <p>Acquires the lock if it is not held by another thread and\n     * returns immediately with the value {@code true}, setting the\n     * lock hold count to one. Even when this lock has been set to use a\n     * fair ordering policy, a call to {@code tryLock()} <em>will</em>\n     * immediately acquire the lock if it is available, whether or not\n     * other threads are currently waiting for the lock.\n     * This &quot;barging&quot; behavior can be useful in certain\n     * circumstances, even though it breaks fairness. If you want to honor\n     * the fairness setting for this lock, then use\n     * {@link #tryLock(long, TimeUnit) tryLock(0, TimeUnit.SECONDS) }\n     * which is almost equivalent (it also detects interruption).\n     *\n     * <p> If the current thread already holds this lock then the hold\n     * count is incremented by one and the method returns {@code true}.\n     *\n     * <p>If the lock is held by another thread then this method will return\n     * immediately with the value {@code false}.\n     *\n     * @return {@code true} if the lock was free and was acquired by the\n     *         current thread, or the lock was already held by the current\n     *         thread; and {@code false} otherwise\n     */\n    public boolean tryLock() {\n        return sync.nonfairTryAcquire(1);\n    }\n\n    /**\n     * Acquires the lock if it is not held by another thread within the given\n     * waiting time and the current thread has not been\n     * {@linkplain Thread#interrupt interrupted}.\n     *\n     * <p>Acquires the lock if it is not held by another thread and returns\n     * immediately with the value {@code true}, setting the lock hold count\n     * to one. If this lock has been set to use a fair ordering policy then\n     * an available lock <em>will not</em> be acquired if any other threads\n     * are waiting for the lock. This is in contrast to the {@link #tryLock()}\n     * method. If you want a timed {@code tryLock} that does permit barging on\n     * a fair lock then combine the timed and un-timed forms together:\n     *\n     * <pre>if (lock.tryLock() || lock.tryLock(timeout, unit) ) { ... }\n     * </pre>\n     *\n     * <p>If the current thread\n     * already holds this lock then the hold count is incremented by one and\n     * the method returns {@code true}.\n     *\n     * <p>If the lock is held by another thread then the\n     * current thread becomes disabled for thread scheduling\n     * purposes and lies dormant until one of three things happens:\n     *\n     * <ul>\n     *\n     * <li>The lock is acquired by the current thread; or\n     *\n     * <li>Some other thread {@linkplain Thread#interrupt interrupts}\n     * the current thread; or\n     *\n     * <li>The specified waiting time elapses\n     *\n     * </ul>\n     *\n     * <p>If the lock is acquired then the value {@code true} is returned and\n     * the lock hold count is set to one.\n     *\n     * <p>If the current thread:\n     *\n     * <ul>\n     *\n     * <li>has its interrupted status set on entry to this method; or\n     *\n     * <li>is {@linkplain Thread#interrupt interrupted} while\n     * acquiring the lock,\n     *\n     * </ul>\n     * then {@link InterruptedException} is thrown and the current thread's\n     * interrupted status is cleared.\n     *\n     * <p>If the specified waiting time elapses then the value {@code false}\n     * is returned.  If the time is less than or equal to zero, the method\n     * will not wait at all.\n     *\n     * <p>In this implementation, as this method is an explicit\n     * interruption point, preference is given to responding to the\n     * interrupt over normal or reentrant acquisition of the lock, and\n     * over reporting the elapse of the waiting time.\n     *\n     * @param timeout the time to wait for the lock\n     * @param unit the time unit of the timeout argument\n     * @return {@code true} if the lock was free and was acquired by the\n     *         current thread, or the lock was already held by the current\n     *         thread; and {@code false} if the waiting time elapsed before\n     *         the lock could be acquired\n     * @throws InterruptedException if the current thread is interrupted\n     * @throws NullPointerException if the time unit is null\n     *\n     */\n    public boolean tryLock(long timeout, TimeUnit unit)\n            throws InterruptedException {\n        return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n    }\n\n    /**\n     * Attempts to release this lock.\n     *\n     * <p>If the current thread is the holder of this lock then the hold\n     * count is decremented.  If the hold count is now zero then the lock\n     * is released.  If the current thread is not the holder of this\n     * lock then {@link IllegalMonitorStateException} is thrown.\n     *\n     * @throws IllegalMonitorStateException if the current thread does not\n     *         hold this lock\n     */\n    public void unlock() {\n        sync.release(1);\n    }\n\n    /**\n     * Returns a {@link Condition} instance for use with this\n     * {@link Lock} instance.\n     *\n     * <p>The returned {@link Condition} instance supports the same\n     * usages as do the {@link Object} monitor methods ({@link\n     * Object#wait() wait}, {@link Object#notify notify}, and {@link\n     * Object#notifyAll notifyAll}) when used with the built-in\n     * monitor lock.\n     *\n     * <ul>\n     *\n     * <li>If this lock is not held when any of the {@link Condition}\n     * {@linkplain Condition#await() waiting} or {@linkplain\n     * Condition#signal signalling} methods are called, then an {@link\n     * IllegalMonitorStateException} is thrown.\n     *\n     * <li>When the condition {@linkplain Condition#await() waiting}\n     * methods are called the lock is released and, before they\n     * return, the lock is reacquired and the lock hold count restored\n     * to what it was when the method was called.\n     *\n     * <li>If a thread is {@linkplain Thread#interrupt interrupted}\n     * while waiting then the wait will terminate, an {@link\n     * InterruptedException} will be thrown, and the thread's\n     * interrupted status will be cleared.\n     *\n     * <li> Waiting threads are signalled in FIFO order.\n     *\n     * <li>The ordering of lock reacquisition for threads returning\n     * from waiting methods is the same as for threads initially\n     * acquiring the lock, which is in the default case not specified,\n     * but for <em>fair</em> locks favors those threads that have been\n     * waiting the longest.\n     *\n     * </ul>\n     *\n     * @return the Condition object\n     */\n    public Condition newCondition() {\n        return sync.newCondition();\n    }\n\n    /**\n     * Queries the number of holds on this lock by the current thread.\n     *\n     * <p>A thread has a hold on a lock for each lock action that is not\n     * matched by an unlock action.\n     *\n     * <p>The hold count information is typically only used for testing and\n     * debugging purposes. For example, if a certain section of code should\n     * not be entered with the lock already held then we can assert that\n     * fact:\n     *\n     * <pre>\n     * class X {\n     *   ReentrantLock lock = new ReentrantLock();\n     *   // ...\n     *   public void m() {\n     *     assert lock.getHoldCount() == 0;\n     *     lock.lock();\n     *     try {\n     *       // ... method body\n     *     } finally {\n     *       lock.unlock();\n     *     }\n     *   }\n     * }\n     * </pre>\n     *\n     * @return the number of holds on this lock by the current thread,\n     *         or zero if this lock is not held by the current thread\n     */\n    public int getHoldCount() {\n        return sync.getHoldCount();\n    }\n\n    /**\n     * Queries if this lock is held by the current thread.\n     *\n     * <p>Analogous to the {@link Thread#holdsLock} method for built-in\n     * monitor locks, this method is typically used for debugging and\n     * testing. For example, a method that should only be called while\n     * a lock is held can assert that this is the case:\n     *\n     * <pre>\n     * class X {\n     *   ReentrantLock lock = new ReentrantLock();\n     *   // ...\n     *\n     *   public void m() {\n     *       assert lock.isHeldByCurrentThread();\n     *       // ... method body\n     *   }\n     * }\n     * </pre>\n     *\n     * <p>It can also be used to ensure that a reentrant lock is used\n     * in a non-reentrant manner, for example:\n     *\n     * <pre>\n     * class X {\n     *   ReentrantLock lock = new ReentrantLock();\n     *   // ...\n     *\n     *   public void m() {\n     *       assert !lock.isHeldByCurrentThread();\n     *       lock.lock();\n     *       try {\n     *           // ... method body\n     *       } finally {\n     *           lock.unlock();\n     *       }\n     *   }\n     * }\n     * </pre>\n     *\n     * @return {@code true} if current thread holds this lock and\n     *         {@code false} otherwise\n     */\n    public boolean isHeldByCurrentThread() {\n        return sync.isHeldExclusively();\n    }\n\n    /**\n     * Queries if this lock is held by any thread. This method is\n     * designed for use in monitoring of the system state,\n     * not for synchronization control.\n     *\n     * @return {@code true} if any thread holds this lock and\n     *         {@code false} otherwise\n     */\n    public boolean isLocked() {\n        return sync.isLocked();\n    }\n\n    /**\n     * Returns {@code true} if this lock has fairness set true.\n     *\n     * @return {@code true} if this lock has fairness set true\n     */\n    public final boolean isFair() {\n        return sync instanceof FairSync;\n    }\n\n    /**\n     * Returns the thread that currently owns this lock, or\n     * {@code null} if not owned. When this method is called by a\n     * thread that is not the owner, the return value reflects a\n     * best-effort approximation of current lock status. For example,\n     * the owner may be momentarily {@code null} even if there are\n     * threads trying to acquire the lock but have not yet done so.\n     * This method is designed to facilitate construction of\n     * subclasses that provide more extensive lock monitoring\n     * facilities.\n     *\n     * @return the owner, or {@code null} if not owned\n     */\n    protected Thread getOwner() {\n        return sync.getOwner();\n    }\n\n    /**\n     * Queries whether any threads are waiting to acquire this lock. Note that\n     * because cancellations may occur at any time, a {@code true}\n     * return does not guarantee that any other thread will ever\n     * acquire this lock.  This method is designed primarily for use in\n     * monitoring of the system state.\n     *\n     * @return {@code true} if there may be other threads waiting to\n     *         acquire the lock\n     */\n    public final boolean hasQueuedThreads() {\n        return sync.hasQueuedThreads();\n    }\n\n\n    /**\n     * Queries whether the given thread is waiting to acquire this\n     * lock. Note that because cancellations may occur at any time, a\n     * {@code true} return does not guarantee that this thread\n     * will ever acquire this lock.  This method is designed primarily for use\n     * in monitoring of the system state.\n     *\n     * @param thread the thread\n     * @return {@code true} if the given thread is queued waiting for this lock\n     * @throws NullPointerException if the thread is null\n     */\n    public final boolean hasQueuedThread(Thread thread) {\n        return sync.isQueued(thread);\n    }\n\n\n    /**\n     * Returns an estimate of the number of threads waiting to\n     * acquire this lock.  The value is only an estimate because the number of\n     * threads may change dynamically while this method traverses\n     * internal data structures.  This method is designed for use in\n     * monitoring of the system state, not for synchronization\n     * control.\n     *\n     * @return the estimated number of threads waiting for this lock\n     */\n    public final int getQueueLength() {\n        return sync.getQueueLength();\n    }\n\n    /**\n     * Returns a collection containing threads that may be waiting to\n     * acquire this lock.  Because the actual set of threads may change\n     * dynamically while constructing this result, the returned\n     * collection is only a best-effort estimate.  The elements of the\n     * returned collection are in no particular order.  This method is\n     * designed to facilitate construction of subclasses that provide\n     * more extensive monitoring facilities.\n     *\n     * @return the collection of threads\n     */\n    protected Collection<Thread> getQueuedThreads() {\n        return sync.getQueuedThreads();\n    }\n\n    /**\n     * Queries whether any threads are waiting on the given condition\n     * associated with this lock. Note that because timeouts and\n     * interrupts may occur at any time, a {@code true} return does\n     * not guarantee that a future {@code signal} will awaken any\n     * threads.  This method is designed primarily for use in\n     * monitoring of the system state.\n     *\n     * @param condition the condition\n     * @return {@code true} if there are any waiting threads\n     * @throws IllegalMonitorStateException if this lock is not held\n     * @throws IllegalArgumentException if the given condition is\n     *         not associated with this lock\n     * @throws NullPointerException if the condition is null\n     */\n    public boolean hasWaiters(Condition condition) {\n        if (condition == null)\n            throw new NullPointerException();\n        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\n            throw new IllegalArgumentException(\"not owner\");\n        return sync.hasWaiters((AbstractQueuedSynchronizer.ConditionObject)condition);\n    }\n\n    /**\n     * Returns an estimate of the number of threads waiting on the\n     * given condition associated with this lock. Note that because\n     * timeouts and interrupts may occur at any time, the estimate\n     * serves only as an upper bound on the actual number of waiters.\n     * This method is designed for use in monitoring of the system\n     * state, not for synchronization control.\n     *\n     * @param condition the condition\n     * @return the estimated number of waiting threads\n     * @throws IllegalMonitorStateException if this lock is not held\n     * @throws IllegalArgumentException if the given condition is\n     *         not associated with this lock\n     * @throws NullPointerException if the condition is null\n     */\n    public int getWaitQueueLength(Condition condition) {\n        if (condition == null)\n            throw new NullPointerException();\n        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\n            throw new IllegalArgumentException(\"not owner\");\n        return sync.getWaitQueueLength((AbstractQueuedSynchronizer.ConditionObject)condition);\n    }\n\n    /**\n     * Returns a collection containing those threads that may be\n     * waiting on the given condition associated with this lock.\n     * Because the actual set of threads may change dynamically while\n     * constructing this result, the returned collection is only a\n     * best-effort estimate. The elements of the returned collection\n     * are in no particular order.  This method is designed to\n     * facilitate construction of subclasses that provide more\n     * extensive condition monitoring facilities.\n     *\n     * @param condition the condition\n     * @return the collection of threads\n     * @throws IllegalMonitorStateException if this lock is not held\n     * @throws IllegalArgumentException if the given condition is\n     *         not associated with this lock\n     * @throws NullPointerException if the condition is null\n     */\n    protected Collection<Thread> getWaitingThreads(Condition condition) {\n        if (condition == null)\n            throw new NullPointerException();\n        if (!(condition instanceof AbstractQueuedSynchronizer.ConditionObject))\n            throw new IllegalArgumentException(\"not owner\");\n        return sync.getWaitingThreads((AbstractQueuedSynchronizer.ConditionObject)condition);\n    }\n\n    /**\n     * Returns a string identifying this lock, as well as its lock state.\n     * The state, in brackets, includes either the String {@code \"Unlocked\"}\n     * or the String {@code \"Locked by\"} followed by the\n     * {@linkplain Thread#getName name} of the owning thread.\n     *\n     * @return a string identifying this lock, as well as its lock state\n     */\n    public String toString() {\n        Thread o = sync.getOwner();\n        return super.toString() + ((o == null) ?\n                                   \"[Unlocked]\" :\n                                   \"[Locked by thread \" + o.getName() + \"]\");\n    }\n}\n", "ession.automata.AbstractState;\nimport ua.com.fielden.platform.expression.automata.NoTransitionAvailable;\n\n/**\n * Handles white space after the word 'YEAR'.\n * \n * @author TG Team\n * \n */\npublic class State4 extends AbstractState {\n\n    public State4() {\n        super(\"S4\", false);\n    }\n\n    @Override\n    protected AbstractState transition(final char symbol) throws NoTransitionAvailable {\n        if (isWhiteSpace(symbol)) {\n            return this;\n        } else if (symbol == '(') {\n            return getAutomata().getState(\"S5\");\n        }\n        throw new NoTransitionAvailable(\"Invalid symbol '\" + symbol + \"'\", this, symbol);\n    }\n\n}\n", "port java.util.Date;\r\nimport java.util.Random;\r\n\r\n/**\r\n * \u041c\u0456\u0441\u0442\u0438\u0442\u044c \u043c\u0435\u0442\u043e\u0434\u0438 \u0441\u0442\u0432\u043e\u0440\u0435\u043d\u043d\u044f \u0442\u0430 \u0432\u0438\u0432\u0435\u0434\u0435\u043d\u043d\u044f \u043a\u043b\u0456\u0454\u043d\u0442\u0456\u0432.\r\n * \r\n * @author student Lytvyn I.I. KIT-26A\r\n */\r\npublic class ClientUtil {\r\n\r\n\t/**\r\n\t * \u0417\u0440\u0456\u0441\u0442 \u0437\u0430 \u0437\u0430\u043c\u043e\u0432\u0447\u0443\u0432\u0430\u043d\u043d\u044f\u043c\r\n\t */\r\n\tprivate final static int DEFAULT_HIGHT = 160;\r\n\r\n\t/**\r\n\t * \u0421\u0442\u0432\u043e\u0440\u044e\u0454 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u0456\u0454\u043d\u0442\u0430 \u0431\u044e\u0440\u043e \u0437\u043d\u0430\u0439\u043e\u043c\u0441\u0442\u0432.\r\n\t * \r\n\t * @return client\r\n\t */\r\n\tpublic static Client build() {\r\n\t\tfinal Client client = new Client();\r\n\r\n\t\tfinal Date today = new Date();\r\n\t\tfinal SimpleDateFormat ft = new SimpleDateFormat(\"dd.MM.yyyy\");\r\n\r\n\t\ttry {\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0441\u0442\u0430\u0442\u044c.\");\r\n\t\t\tfinal String gender = DialogHelper.getInput();\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0456\u043c'\u044f.\");\r\n\t\t\tfinal String name = DialogHelper.getInput();\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0437\u0440\u0456\u0441\u0442.\");\r\n\t\t\tfinal int height = Integer.parseInt(DialogHelper.getInput());\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u043a\u043e\u043b\u0456\u0440 \u043e\u0447\u0435\u0439.\");\r\n\t\t\tfinal String eyes = DialogHelper.getInput();\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0434\u0430\u0442\u0443 \u043d\u0430\u0440\u043e\u0434\u0436\u0435\u043d\u043d\u044f\"\r\n\t\t\t        + \" \u0443 \u0444\u043e\u0440\u043c\u0430\u0442\u0456 dd.MM.yyyy.\");\r\n\t\t\tfinal String birthday = DialogHelper.getInput();\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0445\u043e\u0431\u0456 \u0447\u0435\u0440\u0435\u0437 \\\";\\\".\");\r\n\t\t\tfinal String hobby = DialogHelper.getInput();\r\n\t\t\tSystem.out.format(\"\\n\u0412\u0432\u0435\u0434\u0456\u0442\u044c \u0432\u0438\u043c\u043e\u0433\u0438 \u0434\u043e \u043f\u0430\u0440\u0442\u043d\u0435\u0440\u0430 \u0447\u0435\u0440\u0435\u0437 \\\";\\\".\");\r\n\t\t\tfinal String reqs = DialogHelper.getInput();\r\n\r\n\t\t\tfinal String[] hobbies = hobby.split(\";\");\r\n\t\t\tfinal String[] requirements = reqs.split(\";\");\r\n\r\n\t\t\tclient.setName(name);\r\n\t\t\tclient.setBirthday(birthday);\r\n\t\t\tclient.setEyes(eyes);\r\n\t\t\tclient.setGender(gender);\r\n\t\t\tclient.setHeight(height);\r\n\t\t\tclient.setHobbies(hobbies);\r\n\t\t\tclient.setRegDate(ft.format(today));\r\n\t\t\tclient.setRequirements(requirements);\r\n\t\t} catch (final IOException e) {\r\n\t\t\tSystem.out.println(e.getMessage());\r\n\t\t}\r\n\r\n\t\treturn client;\r\n\t}\r\n\r\n\t/**\r\n\t * \u0413\u0435\u043d\u0435\u0440\u0443\u0454 \u043d\u043e\u0432\u0435 \u0431\u044e\u0440\u043e \u0437\u043d\u0430\u0439\u043e\u043c\u0441\u0442\u0432.\r\n\t * \r\n\t * @param size\r\n\t *            \u043a\u0456\u043b\u044c\u043a\u0456\u0441\u0442\u044c \u043a\u043b\u0456\u0454\u043d\u0442\u0456\u0432\r\n\t * @return bureau \u0431\u044e\u0440\u043e \u0437\u043d\u0430\u0439\u043e\u043c\u0441\u0442\u0432\r\n\t */\r\n\tpublic static LinkedList<Client> buildClients(int size) {\r\n\t\tfinal LinkedList<Client> clients = new LinkedList<>();\r\n\t\tfor (int i = 0; i < size; i++) {\r\n\t\t\tfinal Client temp = ClientUtil.buildTest();\r\n\t\t\ttemp.setRegNum(i);\r\n\t\t\tclients.addLast(temp);\r\n\t\t}\r\n\t\treturn clients;\r\n\t}\r\n\r\n\t/**\r\n\t * \u0413\u0435\u043d\u0435\u0440\u0443\u0454 \u043d\u043e\u0432\u043e\u0433\u043e \u043a\u043b\u0456\u0454\u043d\u0442\u0430 \u0431\u044e\u0440\u043e \u0437\u043d\u0430\u0439\u043e\u043c\u0441\u0442\u0432.\r\n\t * \r\n\t * @return client\r\n\t */\r\n\tpublic static Client buildTest() {\r\n\t\tfinal Client client = new Client();\r\n\r\n\t\tfinal Date today = new Date();\r\n\t\tfinal SimpleDateFormat ft = new SimpleDateFormat(\"dd.MM.yyyy\");\r\n\r\n\t\tclient.setName(\"Some_Name\");\r\n\t\tclient.setBirthday(ft.format(today));\r\n\t\tclient.setEyes(\"Some_Eyes\");\r\n\t\tclient.setGender(\"Some_Gender\");\r\n\t\tclient.setHeight(DEFAULT_HIGHT);\r\n\t\tfinal String hobbies = \"Some_Hobby;Some_Hobby;Some_Hobby\";\r\n\t\tfinal String[] hobby = hobbies.split(\";\");\r\n\t\tclient.setHobbies(hobby);\r\n\t\tclient.setRegDate(ft.format(today));\r\n\t\tfinal String reqs = \"Some_Requirement;Some_Requirement;\"\r\n\t\t        + \"Some_Requirement\";\r\n\t\tfinal String[] requirements = reqs.split(\";\");\r\n\t\tclient.setRequirements(requirements);\r\n\t\treturn client;\r\n\t}\r\n\r\n\t/**\r\n\t * \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0443\u0454 \u0434\u0430\u043d\u0456 \u043f\u0440\u043e \u043a\u043b\u0456\u0454\u043d\u0442\u0430 \u0443 \u0440\u044f\u0434\u043e\u043a \u0434\u043b\u044f \u043f\u043e\u0434\u0430\u043b\u044c\u0448\u043e\u0433\u043e \u0437\u0431\u0435\u0440\u0435\u0436\u0435\u043d\u043d\u044f\r\n\t * \r\n\t * @param client\r\n\t *            \u043a\u043b\u0456\u0454\u043d\u0442 \u0434\u043b\u044f \u043a\u043e\u043d\u0432\u0435\u0440\u0442\u0443\u0432\u0430\u043d\u043d\u044f\r\n\t * @return \u0434\u0430\u043d\u0456 \u043f\u0440\u043e \u043a\u043b\u0456\u0454\u043d\u0442\u0430\r\n\t */\r\n\tpublic static String clientToData(Client client) {\r\n\t\tString data = \"\";\r\n\t\tdata += client.getGender() + \"#\";\r\n\t\tdata += client.getRegNum() + \"#\";\r\n\t\tdata += client.getRegDate() + \"#\";\r\n\t\tdata += client.getName() + \"#\";\r\n\t\tdata += client.getHeight() + \"#\";\r\n\t\tdata += client.getEyes() + \"#\";\r\n\t\tdata += client.getBirthday() + \"#\";\r\n\r\n\t\tfinal int hobbCount = client.getHobbies().length;\r\n\t\tif (hobbCount > 1) {\r\n\t\t\tfor (int i = 0; i < hobbCount - 1; i++) {\r\n\t\t\t\tdata += client.getHobbies()[i] + \",\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tdata += client.getHobbies()[hobbCount - 1] + \"#\";\r\n\r\n\t\tfinal int reqsCount = client.getRequirements().length;\r\n\t\tif (reqsCount > 1) {\r\n\t\t\tfor (int i = 0; i < reqsCount - 1; i++) {\r\n\t\t\t\tdata += client.getRequirements()[i] + \",\";\r\n\t\t\t}\r\n\t\t}\r\n\t\tdata += client.getRequirements()[reqsCount - 1];\r\n\r\n\t\treturn data;\r\n\t}\r\n\r\n\t/**\r\n\t * \u0441\u0442\u0430\u0442\u044c; \u0440\u0435\u0454\u0441\u0442\u0440\u0430\u0446\u0456\u0439\u043d\u0438\u0439 \u043d\u043e\u043c\u0435\u0440; \u0434\u0430\u0442\u0430 \u0440\u0435\u0454\u0441\u0442\u0440\u0430\u0446\u0456\u0457; \u0432\u0456\u0434\u043e\u043c\u043e\u0441\u0442\u0456 \u043f\u0440\u043e \u0441\u0435\u0431\u0435\r\n\t * (\u0434\u043e\u0432\u0456\u043b\u044c\u043d\u0438\u0439 \u043d\u0430\u0431\u0456\u0440 \u0432\u043b\u0430\u0441\u0442\u0438\u0432\u043e\u0441\u0442\u0435\u0439: \u0456\u043c\u2019\u044f, \u0437\u0440\u0456\u0441\u0442, \u043a\u043e\u043b\u0456\u0440 \u043e\u0447\u0435\u0439, \u0434\u0430\u0442\u0430 \u043d\u0430\u0440\u043e\u0434\u0436\u0435\u043d\u043d\u044f,\r\n\t * \u0445\u043e\u0431\u0456 \u0442\u043e\u0449\u043e); \u0432\u0438\u043c\u043e\u0433\u0438 \u0434\u043e \u043f\u0430\u0440\u0442\u043d\u0435\u0440\u0430 (\u0434\u043e\u0432\u0456\u043b\u044c\u043d\u0438\u0439 \u043d\u0430\u0431\u0456\u0440 \u0432\u043b\u0430\u0441\u0442\u0438\u0432\u043e\u0441\u0442\u0435\u0439).\r\n\t * \r\n\t * @param client\r\n\t *            \u043a\u043b\u0456\u0454\u043d\u0442 \u0431\u044e\u0440\u043e \u0437\u043d\u0430\u0439\u043e\u043c\u0441\u0442\u0432\r\n\t * \r\n\t * @return info\r\n\t */\r\n\tpublic static String info(Client client) {\r\n\t\tString hobbies = \"\";\r\n\t\tfor (int i = 0; i < client.getHobbies().length; i++) {\r\n\t\t\thobbies += \"\" + (i + 1) + \". \" + client.getHobbies()[i] + \"\\n\";\r\n\t\t}\r\n\t\tString requirements = \"\";\r\n\t\tfor (int i = 0; i < client.getRequirements().length; i++) {\r\n\t\t\trequirements += \"\" + (i + 1) + \". \"\r\n\t\t\t        + client.getRequirements()[i] + \"\\n\";\r\n\t\t}\r\n\t\tfinal String info = \"-----------Client-----------\\n\" +\r\n\t\t        \"\u0421\u0442\u0430\u0442\u044c: \" + client.getGender() + \"\\n\" +\r\n\t\t        \"\u0420\u0435\u0454\u0441\u0442\u0440\u0430\u0446\u0456\u0439\u043d\u0438\u0439 \u043d\u043e\u043c\u0435\u0440: \" + client.getRegNum() + \"\\n\" +\r\n\t\t        \"\u0414\u0430\u0442\u0430 \u0440\u0435\u0454\u0441\u0442\u0440\u0430\u0446\u0456\u0457: \" + client.getRegDate() + \"\\n\" +\r\n\t\t        \"------------Info------------\\n\" +\r\n\t\t        \"\u0406\u043c\u2019\u044f: \" + client.getName() + \"\\n\" +\r\n\t\t        \"\u0417\u0440\u0456\u0441\u0442: \" + client.getHeight() + \"\\n\" +\r\n\t\t        \"\u041a\u043e\u043b\u0456\u0440 \u043e\u0447\u0435\u0439: \" + client.getEyes() + \"\\n\" +\r\n\t\t        \"\u0414\u0430\u0442\u0430 \u043d\u0430\u0440\u043e\u0434\u0436\u0435\u043d\u043d\u044f: \" + client.getBirthday() + \"\\n\" +\r\n\t\t        \"\u0425\u043e\u0431\u0456:\\n\" + hobbies +\r\n\t\t        \"-----------Partner-----------\\n\" +\r\n\t\t        \"\u0412\u0438\u043c\u043e\u0433\u0438 \u0434\u043e \u043f\u0430\u0440\u0442\u043d\u0435\u0440\u0430:\\n\" + requirements +\r\n\t\t        \"_____________________________\\n\";\r\n\t\treturn info;\r\n\t}\r\n\r\n\t/**\r\n\t * \u041a\u043e\u043d\u0432\u0435\u0440\u0442\u0443\u0454 \u0441\u043f\u0438\u0441\u043e\u043a \u0432 \u043c\u0430\u0441\u0438\u0432\r\n\t */\r\n\tpublic static Client[] listToArray(LinkedList<Client> list) {\r\n\t\tfinal Client[] array = new Client[list.size()];\r\n\t\tint i = 0;\r\n\t\tfor (final Client client : list) {\r\n\t\t\tarray[i++] = client;\r\n\t\t}\r\n\t\treturn array;\r\n\t}\r\n\r\n\t/**\r\n\t * \u0421\u0442\u0432\u043e\u0440\u044e\u0454 \u043a\u043b\u0456\u0454\u043d\u0442\u0430 \u0437 \u0440\u044f\u0434\u043a\u0430\r\n\t * \r\n\t * @param data\r\n\t *            \u0434\u0430\u043d\u0456\r\n\t * @return \u043a\u043b\u0456\u0454\u043d\u0442 \u0441\u0442\u0432\u043e\u0440\u0435\u043d\u0438\u0439 \u0437 \u0440\u044f\u0434\u043a\u0430\r\n\t */\r\n\tpublic static Client parse(String data) {\r\n\t\tfinal String[] temp = data.split(\"#\");\r\n\t\tfinal Client client = new Client();\r\n\t\tclient.setGender(temp[0]);\r\n\t\tclient.setRegNum(Integer.parseInt(temp[1]));\r\n\t\tclient.setRegDate(temp[2]);\r\n\t\tclient.setName(temp[3]);\r\n\t\tclient.setHeight(Integer.parseInt(temp[4]));\r\n\t\tclient.setEyes(temp[5]);\r\n\t\tclient.setBirthday(temp[6]);\r\n\t\tfinal String[] hobby = temp[7].split(\",\");\r\n\t\tclient.setHobbies(hobby);\r\n\t\tfinal String[] reqs = temp[8].split(\",\");\r\n\t\tclient.setRequirements(reqs);\r\n\r\n\t\treturn client;\r\n\t}\r\n\r\n\t/**\r\n\t * \u041f\u043e\u0432\u0435\u0440\u0442\u0430\u0454 \u043f\u0441\u0435\u0432\u0434\u043e-\u0440\u0430\u043d\u0434\u043e\u043c\u043d\u0435 \u0447\u0438\u0441\u043b\u043e.\r\n\t * \r\n\t * @param border\r\n\t *            \u0434\u043e\u043f\u0443\u0441\u0442\u0438\u043c\u0430 \u0433\u0440\u0430\u043d\u0438\u0446\u044f \u0447\u0438\u0441\u0435\u043b\r\n\t *\r\n\t * @return \u0447\u0438\u0441\u043b\u043e \u0442\u0438\u043f\u0443 Integer\r\n\t * @see java.util.Random#nextInt(int)\r\n\t */\r\n\tpublic static int randInt(int border) {\r\n\t\tif (border < 0) {\r\n\t\t\tthrow new IllegalArgumentException();\r\n\t\t}\r\n\t\tfinal Random rand = new Random();\r\n\t\tfinal int randomNum = rand.nextInt(border);\r\n\t\treturn randomNum;\r\n\t}\r\n\r\n\t/**\r\n\t * \u0421\u043e\u0440\u0442\u0443\u0432\u0430\u043d\u043d\u044f \u043a\u043e\u043d\u0442\u0435\u0439\u043d\u0435\u0440\u0443 \u0437\u0430 \u0434\u043e\u043f\u043e\u043c\u043e\u0433\u043e\u044e \u043a\u043e\u043c\u043f\u0430\u0440\u0430\u0442\u043e\u0440\u0430\r\n\t * \r\n\t * @param list\r\n\t * \r\n\t * @param clientComparator\r\n\t *            \u043a\u043e\u043c\u043f\u0430\u0440\u0430\u0442\u043e\u0440 \u0434\u043b\u044f \u0441\u043e\u0440\u0442\u0443\u0432\u0430\u043d\u043d\u044f\r\n\t */\r\n\tpublic static void sort(LinkedList<Client> list,\r\n\t        ClientComparator clientComparator) {\r\n\t\tfinal Client[] temp = listToArray(list);\r\n\t\tMergeSort.sort(temp, clientComparator);\r\n\t\tlist.clear();\r\n\t\tfor (int i = 0; i < temp.length; i++) {\r\n\t\t\tlist.addLast(temp[i]);\r\n\t\t}\r\n\t}\r\n}\r\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage com.sun.xml.internal.dtdparser;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.SAXException;\nimport org.xml.sax.SAXParseException;\n\nimport java.io.CharConversionException;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\nimport java.io.UnsupportedEncodingException;\nimport java.net.URL;\nimport java.util.Locale;\n\n/**\n * This is how the parser talks to its input entities, of all kinds.\n * The entities are in a stack.\n * <p/>\n * <P> For internal entities, the character arrays are referenced here,\n * and read from as needed (they're read-only).  External entities have\n * mutable buffers, that are read into as needed.\n * <p/>\n * <P> <em>Note:</em> This maps CRLF (and CR) to LF without regard for\n * whether it's in an external (parsed) entity or not.  The XML 1.0 spec\n * is inconsistent in explaining EOL handling; this is the sensible way.\n *\n * @author David Brownell\n * @author Janet Koenig\n * @version 1.4 00/08/05\n */\npublic class InputEntity {\n    private int start, finish;\n    private char buf [];\n    private int lineNumber = 1;\n    private boolean returnedFirstHalf = false;\n    private boolean maybeInCRLF = false;\n\n    // name of entity (never main document or unnamed DTD PE)\n    private String name;\n\n    private InputEntity next;\n\n    // for system and public IDs in diagnostics\n    private InputSource input;\n\n    // this is a buffer; some buffers can be replenished.\n    private Reader reader;\n    private boolean isClosed;\n\n    private DTDEventListener errHandler;\n    private Locale locale;\n\n    private StringBuffer rememberedText;\n    private int startRemember;\n\n    // record if this is a PE, so endParsedEntity won't be called\n    private boolean isPE;\n\n    // InputStreamReader throws an internal per-read exception, so\n    // we minimize reads.  We also add a byte to compensate for the\n    // \"ungetc\" byte we keep, so that our downstream reads are as\n    // nicely sized as we can make them.\n    final private static int BUFSIZ = 8 * 1024 + 1;\n\n    final private static char newline [] = {'\\n'};\n\n    public static InputEntity getInputEntity(DTDEventListener h, Locale l) {\n        InputEntity retval = new InputEntity();\n        retval.errHandler = h;\n        retval.locale = l;\n        return retval;\n    }\n\n    private InputEntity() {\n    }\n\n    //\n    // predicate:  return true iff this is an internal entity reader,\n    // and so may safely be \"popped\" as needed.  external entities have\n    // syntax to uphold; internal parameter entities have at most validity\n    // constraints to monitor.  also, only external entities get decent\n    // location diagnostics.\n    //\n    public boolean isInternal() {\n        return reader == null;\n    }\n\n    //\n    // predicate:  return true iff this is the toplevel document\n    //\n    public boolean isDocument() {\n        return next == null;\n    }\n\n    //\n    // predicate:  return true iff this is a PE expansion (so that\n    // LexicalEventListner.endParsedEntity won't be called)\n    //\n    public boolean isParameterEntity() {\n        return isPE;\n    }\n\n    //\n    // return name of current entity\n    //\n    public String getName() {\n        return name;\n    }\n\n    //\n    // use this for an external parsed entity\n    //\n    public void init(InputSource in, String name, InputEntity stack,\n                     boolean isPE)\n            throws IOException, SAXException {\n\n        input = in;\n        this.isPE = isPE;\n        reader = in.getCharacterStream();\n\n        if (reader == null) {\n            InputStream bytes = in.getByteStream();\n\n            if (bytes == null)\n                reader = XmlReader.createReader(new URL(in.getSystemId())\n                        .openStream());\n            else if (in.getEncoding() != null)\n                reader = XmlReader.createReader(in.getByteStream(),\n                        in.getEncoding());\n            else\n                reader = XmlReader.createReader(in.getByteStream());\n        }\n        next = stack;\n        buf = new char[BUFSIZ];\n        this.name = name;\n        checkRecursion(stack);\n    }\n\n    //\n    // use this for an internal parsed entity; buffer is readonly\n    //\n    public void init(char b [], String name, InputEntity stack, boolean isPE)\n            throws SAXException {\n\n        next = stack;\n        buf = b;\n        finish = b.length;\n        this.name = name;\n        this.isPE = isPE;\n        checkRecursion(stack);\n    }\n\n    private void checkRecursion(InputEntity stack)\n            throws SAXException {\n\n        if (stack == null)\n            return;\n        for (stack = stack.next; stack != null; stack = stack.next) {\n            if (stack.name != null && stack.name.equals(name))\n                fatal(\"P-069\", new Object[]{name});\n        }\n    }\n\n    public InputEntity pop() throws IOException {\n\n        // caller has ensured there's nothing left to read\n        close();\n        return next;\n    }\n\n    /**\n     * returns true iff there's no more data to consume ...\n     */\n    public boolean isEOF() throws IOException, SAXException {\n\n        // called to ensure WF-ness of included entities and to pop\n        // input entities appropriately ... EOF is not always legal.\n        if (start >= finish) {\n            fillbuf();\n            return start >= finish;\n        } else\n            return false;\n    }\n\n    /**\n     * Returns the name of the encoding in use, else null; the name\n     * returned is in as standard a form as we can get.\n     */\n    public String getEncoding() {\n\n        if (reader == null)\n            return null;\n        if (reader instanceof XmlReader)\n            return ((XmlReader) reader).getEncoding();\n\n        // XXX prefer a java2std() call to normalize names...\n\n        if (reader instanceof InputStreamReader)\n            return ((InputStreamReader) reader).getEncoding();\n        return null;\n    }\n\n\n    /**\n     * returns the next name char, or NUL ... faster than getc(),\n     * and the common \"name or nmtoken must be next\" case won't\n     * need ungetc().\n     */\n    public char getNameChar() throws IOException, SAXException {\n\n        if (finish <= start)\n            fillbuf();\n        if (finish > start) {\n            char c = buf[start++];\n            if (XmlChars.isNameChar(c))\n                return c;\n            start--;\n        }\n        return 0;\n    }\n\n    /**\n     * gets the next Java character -- might be part of an XML\n     * text character represented by a surrogate pair, or be\n     * the end of the entity.\n     */\n    public char getc() throws IOException, SAXException {\n\n        if (finish <= start)\n            fillbuf();\n        if (finish > start) {\n            char c = buf[start++];\n\n            // [2] Char ::= #x0009 | #x000A | #x000D\n            //            | [#x0020-#xD7FF]\n            //            | [#xE000-#xFFFD]\n            // plus surrogate _pairs_ representing [#x10000-#x10ffff]\n            if (returnedFirstHalf) {\n                if (c >= 0xdc00 && c <= 0xdfff) {\n                    returnedFirstHalf = false;\n                    return c;\n                } else\n                    fatal(\"P-070\", new Object[]{Integer.toHexString(c)});\n            }\n            if ((c >= 0x0020 && c <= 0xD7FF)\n                    || c == 0x0009\n                    // no surrogates!\n                    || (c >= 0xE000 && c <= 0xFFFD))\n                return c;\n\n            //\n            // CRLF and CR are both line ends; map both to LF, and\n            // keep line count correct.\n            //\n            else if (c == '\\r' && !isInternal()) {\n                maybeInCRLF = true;\n                c = getc();\n                if (c != '\\n')\n                    ungetc();\n                maybeInCRLF = false;\n\n                lineNumber++;\n                return '\\n';\n\n            } else if (c == '\\n' || c == '\\r') { // LF, or 2nd char in CRLF\n                if (!isInternal() && !maybeInCRLF)\n                    lineNumber++;\n                return c;\n            }\n\n            // surrogates...\n            if (c >= 0xd800 && c < 0xdc00) {\n                returnedFirstHalf = true;\n                return c;\n            }\n\n            fatal(\"P-071\", new Object[]{Integer.toHexString(c)});\n        }\n        throw new EndOfInputException();\n    }\n\n\n    /**\n     * lookahead one character\n     */\n    public boolean peekc(char c) throws IOException, SAXException {\n\n        if (finish <= start)\n            fillbuf();\n        if (finish > start) {\n            if (buf[start] == c) {\n                start++;\n                return true;\n            } else\n                return false;\n        }\n        return false;\n    }\n\n\n    /**\n     * two character pushback is guaranteed\n     */\n    public void ungetc() {\n\n        if (start == 0)\n            throw new InternalError(\"ungetc\");\n        start--;\n\n        if (buf[start] == '\\n' || buf[start] == '\\r') {\n            if (!isInternal())\n                lineNumber--;\n        } else if (returnedFirstHalf)\n            returnedFirstHalf = false;\n    }\n\n\n    /**\n     * optional grammatical whitespace (discarded)\n     */\n    public boolean maybeWhitespace()\n            throws IOException, SAXException {\n\n        char c;\n        boolean isSpace = false;\n        boolean sawCR = false;\n\n        // [3] S ::= #20 | #09 | #0D | #0A\n        for (; ;) {\n            if (finish <= start)\n                fillbuf();\n            if (finish <= start)\n                return isSpace;\n\n            c = buf[start++];\n            if (c == 0x20 || c == 0x09 || c == '\\n' || c == '\\r') {\n                isSpace = true;\n\n                //\n                // CR, LF are line endings ... CLRF is one, not two!\n                //\n                if ((c == '\\n' || c == '\\r') && !isInternal()) {\n                    if (!(c == '\\n' && sawCR)) {\n                        lineNumber++;\n                        sawCR = false;\n                    }\n                    if (c == '\\r')\n                        sawCR = true;\n                }\n            } else {\n                start--;\n                return isSpace;\n            }\n        }\n    }\n\n\n    /**\n     * normal content; whitespace in markup may be handled\n     * specially if the parser uses the content model.\n     * <p/>\n     * <P> content terminates with markup delimiter characters,\n     * namely ampersand (&amp;amp;) and left angle bracket (&amp;lt;).\n     * <p/>\n     * <P> the document handler's characters() method is called\n     * on all the content found\n     */\n    public boolean parsedContent(DTDEventListener docHandler\n                                 /*ElementValidator validator*/)\n            throws IOException, SAXException {\n\n        // [14] CharData ::= [^<&]* - ([^<&]* ']]>' [^<&]*)\n\n        int first;        // first char to return\n        int last;        // last char to return\n        boolean sawContent;    // sent any chars?\n        char c;\n\n        // deliver right out of the buffer, until delimiter, EOF,\n        // or error, refilling as we go\n        for (first = last = start, sawContent = false; ; last++) {\n\n            // buffer empty?\n            if (last >= finish) {\n                if (last > first) {\n//            validator.text ();\n                    docHandler.characters(buf, first, last - first);\n                    sawContent = true;\n                    start = last;\n                }\n                if (isEOF())    // calls fillbuf\n                    return sawContent;\n                first = start;\n                last = first - 1;    // incremented in loop\n                continue;\n            }\n\n            c = buf[last];\n\n            //\n            // pass most chars through ASAP; this inlines the code of\n            // [2] !XmlChars.isChar(c) leaving only characters needing\n            // special treatment ... line ends, surrogates, and:\n            //    0x0026 == '&'\n            //    0x003C == '<'\n            //    0x005D == ']'\n            // Comparisons ordered for speed on 'typical' text\n            //\n            if ((c > 0x005D && c <= 0xD7FF)    // a-z and more\n                    || (c < 0x0026 && c >= 0x0020)    // space & punct\n                    || (c > 0x003C && c < 0x005D)    // A-Z & punct\n                    || (c > 0x0026 && c < 0x003C)    // 0-9 & punct\n                    || c == 0x0009\n                    || (c >= 0xE000 && c <= 0xFFFD)\n            )\n                continue;\n\n            // terminate on markup delimiters\n            if (c == '<' || c == '&')\n                break;\n\n            // count lines\n            if (c == '\\n') {\n                if (!isInternal())\n                    lineNumber++;\n                continue;\n            }\n\n            // External entities get CR, CRLF --> LF mapping\n            // Internal ones got it already, and we can't repeat\n            // else we break char ref handling!!\n            if (c == '\\r') {\n                if (isInternal())\n                    continue;\n\n                docHandler.characters(buf, first, last - first);\n                docHandler.characters(newline, 0, 1);\n                sawContent = true;\n                lineNumber++;\n                if (finish > (last + 1)) {\n                    if (buf[last + 1] == '\\n')\n                        last++;\n                } else {    // CR at end of buffer\n// XXX case not yet handled:  CRLF here will look like two lines\n                }\n                first = start = last + 1;\n                continue;\n            }\n\n            // ']]>' is a WF error -- must fail if we see it\n            if (c == ']') {\n                switch (finish - last) {\n                // for suspicious end-of-buffer cases, get more data\n                // into the buffer to rule out this sequence.\n                case 2:\n                    if (buf[last + 1] != ']')\n                        continue;\n                    // FALLTHROUGH\n\n                case 1:\n                    if (reader == null || isClosed)\n                        continue;\n                    if (last == first)\n                        throw new InternalError(\"fillbuf\");\n                    last--;\n                    if (last > first) {\n//            validator.text ();\n                        docHandler.characters(buf, first, last - first);\n                        sawContent = true;\n                        start = last;\n                    }\n                    fillbuf();\n                    first = last = start;\n                    continue;\n\n                    // otherwise any \"]]>\" would be buffered, and we can\n                    // see right away if that's what we have\n                default:\n                    if (buf[last + 1] == ']' && buf[last + 2] == '>')\n                        fatal(\"P-072\", null);\n                    continue;\n                }\n            }\n\n            // correctly paired surrogates are OK\n            if (c >= 0xd800 && c <= 0xdfff) {\n                if ((last + 1) >= finish) {\n                    if (last > first) {\n//            validator.text ();\n                        docHandler.characters(buf, first, last - first);\n                        sawContent = true;\n                        start = last + 1;\n                    }\n                    if (isEOF()) {    // calls fillbuf\n                        fatal(\"P-081\",\n                                new Object[]{Integer.toHexString(c)});\n                    }\n                    first = start;\n                    last = first;\n                    continue;\n                }\n                if (checkSurrogatePair(last))\n                    last++;\n                else {\n                    last--;\n                    // also terminate on surrogate pair oddities\n                    break;\n                }\n                continue;\n            }\n\n            fatal(\"P-071\", new Object[]{Integer.toHexString(c)});\n        }\n        if (last == first)\n            return sawContent;\n//    validator.text ();\n        docHandler.characters(buf, first, last - first);\n        start = last;\n        return true;\n    }\n\n\n    /**\n     * CDATA -- character data, terminated by \"]]>\" and optionally\n     * including unescaped markup delimiters (ampersand and left angle\n     * bracket).  This should otherwise be exactly like character data,\n     * modulo differences in error report details.\n     * <p/>\n     * <P> The document handler's characters() or ignorableWhitespace()\n     * methods are invoked on all the character data found\n     *\n     * @param docHandler               gets callbacks for character data\n     * @param ignorableWhitespace      if true, whitespace characters will\n     *                                 be reported using docHandler.ignorableWhitespace(); implicitly,\n     *                                 non-whitespace characters will cause validation errors\n     * @param whitespaceInvalidMessage if true, ignorable whitespace\n     *                                 causes a validity error report as well as a callback\n     */\n    public boolean unparsedContent(DTDEventListener docHandler,\n                                   /*ElementValidator validator,*/\n                                   boolean ignorableWhitespace,\n                                   String whitespaceInvalidMessage)\n            throws IOException, SAXException {\n\n        // [18] CDSect ::= CDStart CData CDEnd\n        // [19] CDStart ::= '<![CDATA['\n        // [20] CData ::= (Char* - (Char* ']]>' Char*))\n        // [21] CDEnd ::= ']]>'\n\n        // caller peeked the leading '<' ...\n        if (!peek(\"![CDATA[\", null))\n            return false;\n        docHandler.startCDATA();\n\n        // only a literal ']]>' stops this ...\n        int last;\n\n        for (; ;) {        // until ']]>' seen\n            boolean done = false;\n            char c;\n\n            // don't report ignorable whitespace as \"text\" for\n            // validation purposes.\n            boolean white = ignorableWhitespace;\n\n            for (last = start; last < finish; last++) {\n                c = buf[last];\n\n                //\n                // Reject illegal characters.\n                //\n                if (!XmlChars.isChar(c)) {\n                    white = false;\n                    if (c >= 0xd800 && c <= 0xdfff) {\n                        if (checkSurrogatePair(last)) {\n                            last++;\n                            continue;\n                        } else {\n                            last--;\n                            break;\n                        }\n                    }\n                    fatal(\"P-071\", new Object[]\n                    {Integer.toHexString(buf[last])});\n                }\n                if (c == '\\n') {\n                    if (!isInternal())\n                        lineNumber++;\n                    continue;\n                }\n                if (c == '\\r') {\n                    // As above, we can't repeat CR/CRLF --> LF mapping\n                    if (isInternal())\n                        continue;\n\n                    if (white) {\n                        if (whitespaceInvalidMessage != null)\n                            errHandler.error(new SAXParseException(DTDParser.messages.getMessage(locale,\n                                    whitespaceInvalidMessage), null));\n                        docHandler.ignorableWhitespace(buf, start,\n                                last - start);\n                        docHandler.ignorableWhitespace(newline, 0, 1);\n                    } else {\n//            validator.text ();\n                        docHandler.characters(buf, start, last - start);\n                        docHandler.characters(newline, 0, 1);\n                    }\n                    lineNumber++;\n                    if (finish > (last + 1)) {\n                        if (buf[last + 1] == '\\n')\n                            last++;\n                    } else {    // CR at end of buffer\n// XXX case not yet handled ... as above\n                    }\n                    start = last + 1;\n                    continue;\n                }\n                if (c != ']') {\n                    if (c != ' ' && c != '\\t')\n                        white = false;\n                    continue;\n                }\n                if ((last + 2) < finish) {\n                    if (buf[last + 1] == ']' && buf[last + 2] == '>') {\n                        done = true;\n                        break;\n                    }\n                    white = false;\n                    continue;\n                } else {\n                    //last--;\n                    break;\n                }\n            }\n            if (white) {\n                if (whitespaceInvalidMessage != null)\n                    errHandler.error(new SAXParseException(DTDParser.messages.getMessage(locale,\n                            whitespaceInvalidMessage), null));\n                docHandler.ignorableWhitespace(buf, start, last - start);\n            } else {\n//        validator.text ();\n                docHandler.characters(buf, start, last - start);\n            }\n            if (done) {\n                start = last + 3;\n                break;\n            }\n            start = last;\n            if (isEOF())\n                fatal(\"P-073\", null);\n        }\n        docHandler.endCDATA();\n        return true;\n    }\n\n    // return false to backstep at end of buffer)\n    private boolean checkSurrogatePair(int offset)\n            throws SAXException {\n\n        if ((offset + 1) >= finish)\n            return false;\n\n        char c1 = buf[offset++];\n        char c2 = buf[offset];\n\n        if ((c1 >= 0xd800 && c1 < 0xdc00) && (c2 >= 0xdc00 && c2 <= 0xdfff))\n            return true;\n        fatal(\"P-074\", new Object[]{\n            Integer.toHexString(c1 & 0x0ffff),\n            Integer.toHexString(c2 & 0x0ffff)\n        });\n        return false;\n    }\n\n\n    /**\n     * whitespace in markup (flagged to app, discardable)\n     * <p/>\n     * <P> the document handler's ignorableWhitespace() method\n     * is called on all the whitespace found\n     */\n    public boolean ignorableWhitespace(DTDEventListener handler)\n            throws IOException, SAXException {\n\n        char c;\n        boolean isSpace = false;\n        int first;\n\n        // [3] S ::= #20 | #09 | #0D | #0A\n        for (first = start; ;) {\n            if (finish <= start) {\n                if (isSpace)\n                    handler.ignorableWhitespace(buf, first, start - first);\n                fillbuf();\n                first = start;\n            }\n            if (finish <= start)\n                return isSpace;\n\n            c = buf[start++];\n            switch (c) {\n            case '\\n':\n                if (!isInternal())\n                    lineNumber++;\n// XXX handles Macintosh line endings wrong\n                // fallthrough\n            case 0x09:\n            case 0x20:\n                isSpace = true;\n                continue;\n\n            case '\\r':\n                isSpace = true;\n                if (!isInternal())\n                    lineNumber++;\n                handler.ignorableWhitespace(buf, first,\n                        (start - 1) - first);\n                handler.ignorableWhitespace(newline, 0, 1);\n                if (start < finish && buf[start] == '\\n')\n                    ++start;\n                first = start;\n                continue;\n\n            default:\n                ungetc();\n                if (isSpace)\n                    handler.ignorableWhitespace(buf, first, start - first);\n                return isSpace;\n            }\n        }\n    }\n\n    /**\n     * returns false iff 'next' string isn't as provided,\n     * else skips that text and returns true.\n     * <p/>\n     * <P> NOTE:  two alternative string representations are\n     * both passed in, since one is faster.\n     */\n    public boolean peek(String next, char chars [])\n            throws IOException, SAXException {\n\n        int len;\n        int i;\n\n        if (chars != null)\n            len = chars.length;\n        else\n            len = next.length();\n\n        // buffer should hold the whole thing ... give it a\n        // chance for the end-of-buffer case and cope with EOF\n        // by letting fillbuf compact and fill\n        if (finish <= start || (finish - start) < len)\n            fillbuf();\n\n        // can't peek past EOF\n        if (finish <= start)\n            return false;\n\n        // compare the string; consume iff it matches\n        if (chars != null) {\n            for (i = 0; i < len && (start + i) < finish; i++) {\n                if (buf[start + i] != chars[i])\n                    return false;\n            }\n        } else {\n            for (i = 0; i < len && (start + i) < finish; i++) {\n                if (buf[start + i] != next.charAt(i))\n                    return false;\n            }\n        }\n\n        // if the first fillbuf didn't get enough data, give\n        // fillbuf another chance to read\n        if (i < len) {\n            if (reader == null || isClosed)\n                return false;\n\n            //\n            // This diagnostic \"knows\" that the only way big strings would\n            // fail to be peeked is where it's a symbol ... e.g. for an\n            // </EndTag> construct.  That knowledge could also be applied\n            // to get rid of the symbol length constraint, since having\n            // the wrong symbol is a fatal error anyway ...\n            //\n            if (len > buf.length)\n                fatal(\"P-077\", new Object[]{new Integer(buf.length)});\n\n            fillbuf();\n            return peek(next, chars);\n        }\n\n        start += len;\n        return true;\n    }\n\n\n    //\n    // Support for reporting the internal DTD subset, so <!DOCTYPE...>\n    // declarations can be recreated.  This is collected as a single\n    // string; such subsets are normally small, and many applications\n    // don't even care about this.\n    //\n    public void startRemembering() {\n\n        if (startRemember != 0)\n            throw new InternalError();\n        startRemember = start;\n    }\n\n    public String rememberText() {\n\n        String retval;\n\n        // If the internal subset crossed a buffer boundary, we\n        // created a temporary buffer.\n        if (rememberedText != null) {\n            rememberedText.append(buf, startRemember,\n                    start - startRemember);\n            retval = rememberedText.toString();\n        } else\n            retval = new String(buf, startRemember,\n                    start - startRemember);\n\n        startRemember = 0;\n        rememberedText = null;\n        return retval;\n    }\n\n    private InputEntity getTopEntity() {\n\n        InputEntity current = this;\n\n        // don't report locations within internal entities!\n\n        while (current != null && current.input == null)\n            current = current.next;\n        return current == null ? this : current;\n    }\n\n    /**\n     * Returns the public ID of this input source, if known\n     */\n    public String getPublicId() {\n\n        InputEntity where = getTopEntity();\n        if (where == this)\n            return input.getPublicId();\n        return where.getPublicId();\n    }\n\n    /**\n     * Returns the system ID of this input source, if known\n     */\n    public String getSystemId() {\n\n        InputEntity where = getTopEntity();\n        if (where == this)\n            return input.getSystemId();\n        return where.getSystemId();\n    }\n\n    /**\n     * Returns the current line number in this input source\n     */\n    public int getLineNumber() {\n\n        InputEntity where = getTopEntity();\n        if (where == this)\n            return lineNumber;\n        return where.getLineNumber();\n    }\n\n    /**\n     * returns -1; maintaining column numbers hurts performance\n     */\n    public int getColumnNumber() {\n\n        return -1;        // not maintained (speed)\n    }\n\n\n    //\n    // n.b. for non-EOF end-of-buffer cases, reader should return\n    // at least a handful of bytes so various lookaheads behave.\n    //\n    // two character pushback exists except at first; characters\n    // represented by surrogate pairs can't be pushed back (they'd\n    // only be in character data anyway).\n    //\n    // DTD exception thrown on char conversion problems; line number\n    // will be low, as a rule.\n    //\n    private void fillbuf() throws IOException, SAXException {\n\n        // don't touched fixed buffers, that'll usually\n        // change entity values (and isn't needed anyway)\n        // likewise, ignore closed streams\n        if (reader == null || isClosed)\n            return;\n\n        // if remembering DTD text, copy!\n        if (startRemember != 0) {\n            if (rememberedText == null)\n                rememberedText = new StringBuffer(buf.length);\n            rememberedText.append(buf, startRemember,\n                    start - startRemember);\n        }\n\n        boolean extra = (finish > 0) && (start > 0);\n        int len;\n\n        if (extra)        // extra pushback\n            start--;\n        len = finish - start;\n\n        System.arraycopy(buf, start, buf, 0, len);\n        start = 0;\n        finish = len;\n\n        try {\n            len = buf.length - len;\n            len = reader.read(buf, finish, len);\n        } catch (UnsupportedEncodingException e) {\n            fatal(\"P-075\", new Object[]{e.getMessage()});\n        } catch (CharConversionException e) {\n            fatal(\"P-076\", new Object[]{e.getMessage()});\n        }\n        if (len >= 0)\n            finish += len;\n        else\n            close();\n        if (extra)        // extra pushback\n            start++;\n\n        if (startRemember != 0)\n        // assert extra == true\n            startRemember = 1;\n    }\n\n    public void close() {\n\n        try {\n            if (reader != null && !isClosed)\n                reader.close();\n            isClosed = true;\n        } catch (IOException e) {\n            /* NOTHING */\n        }\n    }\n\n\n    private void fatal(String messageId, Object params [])\n            throws SAXException {\n\n        SAXParseException x = new SAXParseException(DTDParser.messages.getMessage(locale, messageId, params), null);\n\n        // not continuable ... e.g. WF errors\n        close();\n        errHandler.fatalError(x);\n        throw x;\n    }\n}\n", "m.android.ViewRenderer_2\n\timplements\n\t\tmono.android.IGCUserPeer,\n\t\tandroid.text.TextWatcher,\n\t\tandroid.text.NoCopySpan,\n\t\tandroid.view.View.OnFocusChangeListener\n{\n\tstatic final String __md_methods;\n\tstatic {\n\t\t__md_methods = \n\t\t\t\"n_afterTextChanged:(Landroid/text/Editable;)V:GetAfterTextChanged_Landroid_text_Editable_Handler:Android.Text.ITextWatcherInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\n\" +\n\t\t\t\"n_beforeTextChanged:(Ljava/lang/CharSequence;III)V:GetBeforeTextChanged_Ljava_lang_CharSequence_IIIHandler:Android.Text.ITextWatcherInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\n\" +\n\t\t\t\"n_onTextChanged:(Ljava/lang/CharSequence;III)V:GetOnTextChanged_Ljava_lang_CharSequence_IIIHandler:Android.Text.ITextWatcherInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\n\" +\n\t\t\t\"n_onFocusChange:(Landroid/view/View;Z)V:GetOnFocusChange_Landroid_view_View_ZHandler:Android.Views.View/IOnFocusChangeListenerInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\n\" +\n\t\t\t\"\";\n\t\tmono.android.Runtime.register (\"Xamarin.Forms.Platform.Android.EditorRenderer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", EditorRenderer.class, __md_methods);\n\t}\n\n\n\tpublic EditorRenderer (android.content.Context p0, android.util.AttributeSet p1) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1);\n\t\tif (getClass () == EditorRenderer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.EditorRenderer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0, p1 });\n\t}\n\n\n\tpublic EditorRenderer (android.content.Context p0) throws java.lang.Throwable\n\t{\n\t\tsuper (p0);\n\t\tif (getClass () == EditorRenderer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.EditorRenderer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0 });\n\t}\n\n\n\tpublic EditorRenderer (android.content.Context p0, android.util.AttributeSet p1, int p2) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1, p2);\n\t\tif (getClass () == EditorRenderer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.EditorRenderer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:System.Int32, mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\", this, new java.lang.Object[] { p0, p1, p2 });\n\t}\n\n\n\tpublic void afterTextChanged (android.text.Editable p0)\n\t{\n\t\tn_afterTextChanged (p0);\n\t}\n\n\tprivate native void n_afterTextChanged (android.text.Editable p0);\n\n\n\tpublic void beforeTextChanged (java.lang.CharSequence p0, int p1, int p2, int p3)\n\t{\n\t\tn_beforeTextChanged (p0, p1, p2, p3);\n\t}\n\n\tprivate native void n_beforeTextChanged (java.lang.CharSequence p0, int p1, int p2, int p3);\n\n\n\tpublic void onTextChanged (java.lang.CharSequence p0, int p1, int p2, int p3)\n\t{\n\t\tn_onTextChanged (p0, p1, p2, p3);\n\t}\n\n\tprivate native void n_onTextChanged (java.lang.CharSequence p0, int p1, int p2, int p3);\n\n\n\tpublic void onFocusChange (android.view.View p0, boolean p1)\n\t{\n\t\tn_onFocusChange (p0, p1);\n\t}\n\n\tprivate native void n_onFocusChange (android.view.View p0, boolean p1);\n\n\tjava.util.ArrayList refList;\n\tpublic void monodroidAddReference (java.lang.Object obj)\n\t{\n\t\tif (refList == null)\n\t\t\trefList = new java.util.ArrayList ();\n\t\trefList.add (obj);\n\t}\n\n\tpublic void monodroidClearReferences ()\n\t{\n\t\tif (refList != null)\n\t\t\trefList.clear ();\n\t}\n}\n", "ut;\r\nimport unluac.decompile.Walker;\r\nimport unluac.decompile.statement.Statement;\r\nimport unluac.parse.LFunction;\r\n\r\npublic class Break extends Block {\r\n\r\n  public final int target;\r\n  \r\n  public Break(LFunction function, int line, int target) {\r\n    super(function, line, line, 2);\r\n    this.target = target;\r\n  }\r\n\r\n  @Override\r\n  public void walk(Walker w) {\r\n    w.visitStatement(this);\r\n  }\r\n  \r\n  @Override\r\n  public void addStatement(Statement statement) {\r\n    throw new IllegalStateException();\r\n  }\r\n\r\n  @Override\r\n  public boolean isContainer() {\r\n    return false;\r\n  }\r\n  \r\n  @Override\r\n  public boolean isEmpty() {\r\n    return true;\r\n  }\r\n  \r\n  @Override\r\n  public boolean breakable() {\r\n    return false;\r\n  }\r\n  \r\n  @Override\r\n  public boolean isUnprotected() {\r\n    //Actually, it is unprotected, but not really a block\r\n    return false;\r\n  }\r\n\r\n  @Override\r\n  public int getLoopback() {\r\n    throw new IllegalStateException();\r\n  }\r\n\r\n  @Override\r\n  public void print(Decompiler d, Output out) {\r\n    out.print(\"do break end\");\r\n  }\r\n  \r\n  @Override\r\n  public void printTail(Decompiler d, Output out) {\r\n    out.print(\"break\");\r\n  }\r\n  \r\n}\r\n", ";\nimport javax.sql.DataSource;\n\nimport org.carbon.component.annotation.Assemble;\nimport org.carbon.component.annotation.Component;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/**\n * @author garden 2018/04/07.\n */\n@Component\npublic class DefaultTransactionalConnectionManager implements TransactionalConnectionManager {\n    private static final Logger logger = LoggerFactory.getLogger(DefaultTransactionalConnectionManager.class);\n    private static final ThreadLocal<DefaultTransactionalConnectionManager> threadBindContext =\n            ThreadLocal.withInitial(DefaultTransactionalConnectionManager::new);\n\n    @Assemble\n    private static DataSource dataSource;\n\n    private enum TransactionState {\n        NONE,\n        BEGAN,\n    }\n\n    private Connection transactionConnection;\n    private TransactionState transactionState;\n    private int transactionDepth;\n\n    public DefaultTransactionalConnectionManager() {\n        transactionDepth = 0;\n        transactionState = TransactionState.NONE;\n    }\n\n    private DefaultTransactionalConnectionManager currentContext() {\n        return threadBindContext.get();\n    }\n\n    private void removeContext() {\n        threadBindContext.remove();\n    }\n\n    @Override\n    public Connection allocateConnection() throws SQLException {\n        logDebugAction(\"allocate\");\n        DefaultTransactionalConnectionManager self = currentContext();\n\n        if (self.transactionState == TransactionState.NONE)\n            return dataSource.getConnection();\n\n        // if BEGIN\n        if (self.transactionConnection == null) {\n            self.transactionConnection = dataSource.getConnection();\n            self.transactionConnection.setAutoCommit(false);\n        }\n        return self.transactionConnection;\n    }\n\n    @Override\n    public void releaseConnection(Connection connection) throws SQLException {\n        logDebugAction(\"release\");\n        DefaultTransactionalConnectionManager self = currentContext();\n        if (self.transactionState == TransactionState.BEGAN) return;\n\n        try {\n            connection.close();\n        } finally {\n            removeContext();\n        }\n    }\n\n    @Override\n    public void begin() {\n        logDebugAction(\"begin\");\n        DefaultTransactionalConnectionManager self = currentContext();\n        self.transactionState = TransactionState.BEGAN;\n        self.transactionDepth++;\n    }\n\n    @Override\n    public void end() throws SQLException {\n        logDebugAction(\"end\");\n        DefaultTransactionalConnectionManager self = currentContext();\n        if (self.transactionConnection != null) {\n            self.transactionConnection.close();\n        }\n        removeContext();\n    }\n\n    @Override\n    public void commit() throws SQLException {\n        logDebugAction(\"commit\");\n        DefaultTransactionalConnectionManager self = currentContext();\n        self.transactionDepth--;\n        if (self.transactionDepth == 0) {\n            if (currentContext().transactionConnection == null) {\n                throw new IllegalStateException(\"transaction is began but connection is null\");\n            }\n            self.transactionConnection.commit();\n        }\n    }\n\n    @Override\n    public void rollback() throws SQLException {\n        logDebugAction(\"rollback\");\n        if (currentContext().transactionConnection != null) {\n            currentContext().transactionConnection.rollback();\n        }\n    }\n\n    private void logDebugAction(String action) {\n        DefaultTransactionalConnectionManager self = currentContext();\n        TransactionState state = self.transactionState;\n        int depth = self.transactionDepth;\n        logger.debug(\"[persistent{TRAN: {}, DEPTH: {}}] {}\", state, depth, action);\n    }\n}\n", "sourceforge.pmd.lang.plsql.dfa;\n\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport net.sourceforge.pmd.lang.DataFlowHandler;\nimport net.sourceforge.pmd.lang.ast.Node;\nimport net.sourceforge.pmd.lang.dfa.Linker;\nimport net.sourceforge.pmd.lang.dfa.LinkerException;\nimport net.sourceforge.pmd.lang.dfa.NodeType;\nimport net.sourceforge.pmd.lang.dfa.SequenceException;\nimport net.sourceforge.pmd.lang.dfa.Structure;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTCaseStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTCaseWhenClause;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTCloseStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTContinueStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTElseClause;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTElsifClause;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTEmbeddedSqlStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTExitStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTExpression;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTFetchStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTForStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTGotoStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTIfStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTLabelledStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTLoopStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTMethodDeclaration;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTOpenStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTPipelineStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTProgramUnit;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTRaiseStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTReturnStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTSqlStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTTriggerTimingPointSection;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTTriggerUnit;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTTypeMethod;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTUnlabelledStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTVariableOrConstantDeclarator;\nimport net.sourceforge.pmd.lang.plsql.ast.ASTWhileStatement;\nimport net.sourceforge.pmd.lang.plsql.ast.PLSQLNode;\nimport net.sourceforge.pmd.lang.plsql.ast.PLSQLParserVisitorAdapter;\n\n/**\n * @author raik\n *         <p/>\n *         Sublayer of DataFlowFacade. Finds all data flow nodes and stores the\n *         type information (@see StackObject). At last it uses this information to\n *         link the nodes.\n */\npublic class StatementAndBraceFinder extends PLSQLParserVisitorAdapter {\n    private final static Logger LOGGER = Logger.getLogger(StatementAndBraceFinder.class.getName()); \n\n    private final DataFlowHandler dataFlowHandler;\n    private Structure dataFlow;\n    \n    public StatementAndBraceFinder(DataFlowHandler dataFlowHandler) {\n\tthis.dataFlowHandler = dataFlowHandler;\n    }\n\n    public void buildDataFlowFor(PLSQLNode node) {\n        LOGGER.entering(this.getClass().getCanonicalName(),\"buildDataFlowFor\");\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"buildDataFlowFor: node class \" \n                      + node.getClass().getCanonicalName() + \" @ line \" \n                      + node.getBeginLine() \n                      +\", column \" + node.getBeginColumn()\n                      + \" --- \" + new Throwable().getStackTrace()\n                );\n        }\n        if (!(node instanceof ASTMethodDeclaration) \n             && !(node instanceof ASTProgramUnit) \n             && !(node instanceof ASTTypeMethod) \n             && !(node instanceof ASTTriggerUnit)\n             && !(node instanceof ASTTriggerTimingPointSection)\n            ) {\n            throw new RuntimeException(\"Can't build a data flow for anything other than a Method or a Trigger\");\n        }\n\n        this.dataFlow = new Structure(dataFlowHandler);\n        this.dataFlow.createStartNode(node.getBeginLine());\n        this.dataFlow.createNewNode(node);\n\n        node.jjtAccept(this, dataFlow);\n\n        this.dataFlow.createEndNode(node.getEndLine());\n\n        if (LOGGER.isLoggable(Level.FINE))\n        {\n          LOGGER.fine(\"DataFlow is \" + this.dataFlow.dump() ); \n        }\n        Linker linker = new Linker(dataFlowHandler, dataFlow.getBraceStack(), dataFlow.getContinueBreakReturnStack());\n        try {\n            linker.computePaths();\n        } catch (LinkerException e) {\n            LOGGER.severe(\"LinkerException\");\n            e.printStackTrace();\n        } catch (SequenceException e) {\n            LOGGER.severe(\"SequenceException\");\n            e.printStackTrace();\n        }\n        LOGGER.exiting(this.getClass().getCanonicalName(),\"buildDataFlowFor\");\n    }\n\n    \n     public Object visit(ASTSqlStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"immediate return ASTSqlStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTSqlStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n    \n     public Object visit(ASTEmbeddedSqlStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"immediate return ASTEmbeddedSqlStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTEmbeddedSqlStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n    \n     public Object visit(ASTCloseStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTCloseStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n    \n     public Object visit(ASTOpenStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTOpenStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n    \n     public Object visit(ASTFetchStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTFetchStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n    \n     public Object visit(ASTPipelineStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTPipelineStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n    \n    /* */\n\n    public Object visit(ASTVariableOrConstantDeclarator node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"createNewNode ASTVariableOrConstantDeclarator: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    }\n\n    public Object visit(ASTExpression node, Object data) {\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"Entry ASTExpression: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        if (!(data instanceof Structure)) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"immediate return ASTExpression: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n\n        //The equivalent of an ASTExpression is an Expression whose parent is an UnLabelledStatement\n        if (node.jjtGetParent() instanceof ASTUnlabelledStatement) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"createNewNode ASTSUnlabelledStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            dataFlow.createNewNode(node);\n        } else \n        // TODO what about throw stmts?\n        if (node.jjtGetParent() instanceof ASTIfStatement) {\n            dataFlow.createNewNode(node); // START IF\n            dataFlow.pushOnStack(NodeType.IF_EXPR, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack parent IF_EXPR: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } else if (node.jjtGetParent() instanceof ASTElsifClause) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"parent (Elsif) IF_EXPR at  \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            dataFlow.createNewNode(node); // START IF\n            dataFlow.pushOnStack(NodeType.IF_EXPR, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack parent (Elsif) IF_EXPR: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } else if (node.jjtGetParent() instanceof ASTWhileStatement) {\n            dataFlow.createNewNode(node); // START WHILE\n            dataFlow.pushOnStack(NodeType.WHILE_EXPR, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack parent WHILE_EXPR: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } else if (node.jjtGetParent() instanceof ASTCaseStatement) {\n            dataFlow.createNewNode(node); // START SWITCH\n            dataFlow.pushOnStack(NodeType.SWITCH_START, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack parent SWITCH_START: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } else if (node.jjtGetParent() instanceof ASTForStatement) {\n            /* A PL/SQL loop control:\n             *  [<REVERSE>] Expression()[\"..\"Expression()] \n             * \n             */\n            if (node.equals( node.jjtGetParent().getFirstChildOfType(ASTExpression.class) ) )\n            {\n              dataFlow.createNewNode(node); // FOR EXPR\n              dataFlow.pushOnStack(NodeType.FOR_EXPR, dataFlow.getLast());\n              if (LOGGER.isLoggable(Level.FINEST)) {\n              LOGGER.finest(\"pushOnStack parent FOR_EXPR: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n              }\n            }\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"parent (ASTForStatement): line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } else if (node.jjtGetParent() instanceof ASTLoopStatement) {\n            dataFlow.createNewNode(node); // DO EXPR\n            dataFlow.pushOnStack(NodeType.DO_EXPR, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack parent DO_EXPR: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        }\n\n        return super.visit(node, data);\n    }\n\n    public Object visit(ASTLabelledStatement node, Object data) {\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.LABEL_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack LABEL_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    } \n\n    /**\n     *  PL/SQL does not have a do/while statement or repeat/until statement: the equivalent is a LOOP statement.\n     *  A PL/SQL LOOP statement is exited using an explicit EXIT ( == break;) statement\n     * It does not have a test expression, so the Java control processing (on the expression) does not fire.\n     * The best way to cope it to push a DO_EXPR after the loop.\n     */\n    public Object visit(ASTLoopStatement node, Object data) {\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"entry ASTLoopStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        if (!(data instanceof Structure)) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"immediate return ASTLoopStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n\n        //process the contents on the LOOP statement \n        super.visit(node, data);\n\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.DO_EXPR, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack (ASTLoopStatement) DO_EXPR: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return data;\n    } \n\n    /**\n     * A PL/SQL WHILE statement includes the LOOP statement and all Expressions within it:  \n     * it does not have a single test expression, so the Java control processing (on the Expression) fires for each \n     * Expression in the LOOP.\n     * The best way to cope it to push a WHILE_LAST_STATEMENT after the WhileStatement has been processed.\n     */\n    public Object visit(ASTWhileStatement node, Object data) {\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"entry ASTWhileStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        if (!(data instanceof Structure)) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"immediate return ASTWhileStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            return data;\n        }\n\n        //process the contents on the WHILE statement \n        super.visit(node, data);\n\n        return data;\n    } \n\n\n// \t----------------------------------------------------------------------------\n//  BRANCH OUT\n\n    public Object visit(ASTStatement node, Object data) {\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"entry ASTStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn() + \" -> \" + node.getClass().getCanonicalName());\n        }\n        if (!(data instanceof Structure)) {\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"immediate return ASTStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n\n        if (node.jjtGetParent() instanceof ASTForStatement) {\n            ASTForStatement st = (ASTForStatement) node.jjtGetParent(); \n            if (node.equals(st.getFirstChildOfType(ASTStatement.class)))\n            {\n              this.addForExpressionNode(node, dataFlow);\n              dataFlow.pushOnStack(NodeType.FOR_BEFORE_FIRST_STATEMENT, dataFlow.getLast());\n              if (LOGGER.isLoggable(Level.FINEST)) {\n              LOGGER.finest(\"pushOnStack FOR_BEFORE_FIRST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n              }\n            }\n        } else if (node.jjtGetParent() instanceof ASTLoopStatement) {\n            ASTLoopStatement st = (ASTLoopStatement) node.jjtGetParent(); \n            if (node.equals(st.getFirstChildOfType(ASTStatement.class)))\n            {\n              dataFlow.pushOnStack(NodeType.DO_BEFORE_FIRST_STATEMENT, dataFlow.getLast());\n              dataFlow.createNewNode(node.jjtGetParent());\n              if (LOGGER.isLoggable(Level.FINEST)) {\n              LOGGER.finest(\"pushOnStack DO_BEFORE_FIRST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n              }\n            }\n        } \n\n\n        super.visit(node, data);\n\n        if (node.jjtGetParent() instanceof ASTElseClause) {\n            List<ASTStatement> allStatements = node.jjtGetParent().findChildrenOfType(ASTStatement.class) ;\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"ElseClause has \" + allStatements.size() + \" Statements \" );\n            }\n\n           /*\n           //Restrict to the last Statement of the Else Clause\n           if (node == allStatements.get(allStatements.size()-1) )\n           {\n            if (node.jjtGetParent().jjtGetParent() instanceof ASTCaseStatement) {\n                dataFlow.pushOnStack(NodeType.SWITCH_LAST_DEFAULT_STATEMENT, dataFlow.getLast());\n                LOGGER.finest(\"pushOnStack (Else-Below Case) SWITCH_LAST_DEFAULT_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            } /*SRT else // if (node == node.jjtGetParent() instanceof ASTElseClause) { \n            {\n              dataFlow.pushOnStack(NodeType.ELSE_LAST_STATEMENT, dataFlow.getLast());\n              LOGGER.finest(\"pushOnStack (Else-Below If) ELSE_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            } */\n           //}\n        } else if (node.jjtGetParent() instanceof ASTWhileStatement) {\n            ASTWhileStatement statement = (ASTWhileStatement) node.jjtGetParent();\n            List<ASTStatement> children = statement.findChildrenOfType(ASTStatement.class);\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"(LastChildren): size \" + children.size() );\n            }\n            ASTStatement lastChild = children.get(children.size()-1);\n\n            // Push on stack if this Node is the LAST Statement associated with the FOR Statment\n            if ( node.equals(lastChild) )\n            {\n              dataFlow.pushOnStack(NodeType.WHILE_LAST_STATEMENT, dataFlow.getLast());\n              if (LOGGER.isLoggable(Level.FINEST)) {\n              LOGGER.finest(\"pushOnStack WHILE_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n              }\n            }\n        }  else if (node.jjtGetParent() instanceof ASTForStatement ) {\n            ASTForStatement statement = (ASTForStatement) node.jjtGetParent();\n            List<ASTStatement> children = statement.findChildrenOfType(ASTStatement.class);\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"(LastChildren): size \" + children.size() );\n            }\n            ASTStatement lastChild = children.get(children.size()-1);\n\n            // Push on stack if this Node is the LAST Statement associated with the FOR Statment\n            if ( node.equals(lastChild) )\n            {\n            dataFlow.pushOnStack(NodeType.FOR_END, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n                LOGGER.finest(\"pushOnStack (LastChildStatemnt) FOR_END: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n            }\n        } else if (node.jjtGetParent() instanceof ASTLabelledStatement) {\n            dataFlow.pushOnStack(NodeType.LABEL_LAST_STATEMENT, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack LABEL_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } \n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"exit ASTStatement: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn() \n                       + \" -> \" + node.getClass().getCanonicalName() \n                       + \" ->-> \" + node.jjtGetParent().getClass().getCanonicalName() \n                );\n        }\n        return data;\n    }\n\n    public Object visit(ASTUnlabelledStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        super.visit(node, data);\n        if (node.jjtGetParent() instanceof ASTLabelledStatement) {\n            dataFlow.pushOnStack(NodeType.LABEL_LAST_STATEMENT, dataFlow.getLast());\n            if (LOGGER.isLoggable(Level.FINEST)) {\n            LOGGER.finest(\"pushOnStack (ASTUnlabelledStatement) LABEL_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n            }\n        } \n        return data;\n    }\n\n    public Object visit(ASTCaseStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n\n        /*\n         * A PL/SQL CASE statement may be either:- \n         * SIMPLE, e.g. CASE case_operand WHEN when_operand THEN statement ; ELSE statement ; END CASE\n         * SEARCHED, e.g. CASE WHEN boolean_expression THEN statement ; ELSE statement ; END CASE\n         * \n         * A SIMPLE CASE statement may be treated as a normal Java SWITCH statement ( see visit(ASTExpression)), \n         * but a SEARCHED CASE statement must have an atificial start node\n         */\n        if (null == node.getFirstChildOfType(ASTExpression.class) // CASE is \"searched case statement\"\n           )\n        {\n          dataFlow.createNewNode(node);\n          dataFlow.pushOnStack(NodeType.SWITCH_START, dataFlow.getLast());\n          if (LOGGER.isLoggable(Level.FINEST)) {\n          LOGGER.finest(\"pushOnStack SWITCH_START: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n          }\n        }\n\n        super.visit(node, data);\n\n        dataFlow.pushOnStack(NodeType.SWITCH_END, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack SWITCH_END: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return data;\n    }\n\n      public Object visit(ASTCaseWhenClause node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n\n\n         //Java ASTSwitchLabel \n        //SRT dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.CASE_LAST_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack CASE_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n\n        super.visit(node, data);\n\n        //dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.BREAK_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack (ASTCaseWhenClause) BREAK_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return data;\n    }\n     \n      public Object visit(ASTIfStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        LOGGER.finest(\"ElsifClause) super.visit line\" );\n        super.visit(node, data);\n\n\n        /*\n         * PLSQL AST now has explicit ELSIF and ELSE clauses\n         * All of the ELSE_END_STATEMENTS in an IF clause\n         * should point to the outer last clause because\n         * we have to convert a single PL/SQL IF/ELSIF/ELSE satement into the equivalent \n         * set of nested Java if/else {if/else {if/else}} statements \n         */\n          List<ASTElsifClause> elsifs = node.findChildrenOfType(ASTElsifClause.class);\n          ASTElseClause elseClause = node.getFirstChildOfType(ASTElseClause.class);\n          if (null == elseClause\n              && \n              elsifs.isEmpty()\n             ) // The IF statements has no ELSE or ELSIF statements and this is the last Statement \n          {\n              dataFlow.pushOnStack(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE, dataFlow.getLast());\n              if (LOGGER.isLoggable(Level.FINEST)) {\n              LOGGER.finest(\"pushOnStack (ASTIfClause - no ELSIFs) IF_LAST_STATEMENT_WITHOUT_ELSE: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n              }\n          } \n          else \n          {\n            if (!elsifs.isEmpty() )\n            {\n\n              ASTElsifClause lastElsifClause = elsifs.get(elsifs.size()-1);\n              for (ASTElsifClause elsifClause : elsifs )\n              {\n\n                /* If last ELSIF clause is not followed by a ELSE clause\n                 * then the last ELSIF is equivalent to an if statement without an else\n                 * Otherwise, it is equivalent to an if/else statement \n                 */\n                if (lastElsifClause.equals(elsifClause) && elseClause == null)\n                {\n                  dataFlow.pushOnStack(NodeType.IF_LAST_STATEMENT_WITHOUT_ELSE, dataFlow.getLast());\n                  if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.finest(\"pushOnStack (ASTIfClause - with ELSIFs) IF_LAST_STATEMENT_WITHOUT_ELSE: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n                  }\n                }\n                \n                {\n                  dataFlow.pushOnStack(NodeType.ELSE_LAST_STATEMENT, dataFlow.getLast());\n                  if (LOGGER.isLoggable(Level.FINEST)) {\n                  LOGGER.finest(\"pushOnStack (ASTIfClause - with ELSIFs) ELSE_LAST_STATEMENT : line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n                  }\n                }\n              }\n            }\n\n            if (null != elseClause)\n            {\n              //Output one terminating else\n              dataFlow.pushOnStack(NodeType.ELSE_LAST_STATEMENT, dataFlow.getLast());\n              if (LOGGER.isLoggable(Level.FINEST)) {\n              LOGGER.finest(\"pushOnStack (ASTIfClause - with ELSE) ELSE_LAST_STATEMENT : line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n              }\n            }\n        } \n        return data;\n    }\n\n      public Object visit(ASTElseClause node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n\n        if (node.jjtGetParent() instanceof ASTIfStatement) {\n          dataFlow.pushOnStack(NodeType.IF_LAST_STATEMENT, dataFlow.getLast());\n          if (LOGGER.isLoggable(Level.FINEST)) {\n          LOGGER.finest(\"pushOnStack (Visit ASTElseClause) IF_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n          LOGGER.finest(\"ElseClause) super.visit line\" );\n          }\n        }\n        else\n        {\n          //SRT dataFlow.createNewNode(node);\n          dataFlow.pushOnStack(NodeType.SWITCH_LAST_DEFAULT_STATEMENT, dataFlow.getLast());\n          if (LOGGER.isLoggable(Level.FINEST)) {\n          LOGGER.finest(\"pushOnStack SWITCH_LAST_DEFAULT_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n          }\n        }\n\n        super.visit(node, data);\n\n        return data;\n    }\n\n      public Object visit(ASTElsifClause node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.pushOnStack(NodeType.IF_LAST_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack (Visit ASTElsifClause) IF_LAST_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        LOGGER.finest(\"ElsifClause) super.visit line\" );\n        }\n        super.visit(node, data);\n\n        return data;\n    }\n\n    /**\n     * Treat a PLSQL CONTINUE like a Java \"continue\"\n     * \n     * @param node\n     * @param data\n     * @return \n     */\n    public Object visit(ASTContinueStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.CONTINUE_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack (ASTContinueStatement) CONTINUE_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    }\n\n    /**\n     * Treat a PLSQL EXIT like a Java \"break\"\n     * \n     * @param node\n     * @param data\n     * @return \n     */\n    public Object visit(ASTExitStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.BREAK_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack (ASTExitStatement) BREAK_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    }\n\t\n    /**\n     * Treat a PLSQL GOTO like a Java \"continue\"\n     * \n     * @param node\n     * @param data\n     * @return \n     */\n    public Object visit(ASTGotoStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.CONTINUE_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack (ASTGotoStatement) CONTINUE_STATEMENT (GOTO): line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    }\n\n    public Object visit(ASTReturnStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.RETURN_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack RETURN_STATEMENT: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    }\n\n    public Object visit(ASTRaiseStatement node, Object data) {\n        if (!(data instanceof Structure)) {\n            return data;\n        }\n        Structure dataFlow = (Structure) data;\n        dataFlow.createNewNode(node);\n        dataFlow.pushOnStack(NodeType.THROW_STATEMENT, dataFlow.getLast());\n        if (LOGGER.isLoggable(Level.FINEST)) {\n        LOGGER.finest(\"pushOnStack THROW: line \" + node.getBeginLine() +\", column \" + node.getBeginColumn());\n        }\n        return super.visit(node, data);\n    }\n\n    /*\n     * The method handles the special \"for\" loop. It creates always an\n     * expression node even if the loop looks like for(;;).\n     * */\n    private void addForExpressionNode(Node node, Structure dataFlow) {\n        ASTForStatement parent = (ASTForStatement) node.jjtGetParent();\n        boolean hasExpressionChild = false;\n\n        for (int i = 0; i < parent.jjtGetNumChildren(); i++) {\n            if (parent.jjtGetChild(i) instanceof ASTExpression) {\n                hasExpressionChild = true;\n            } \n             \n        }\n        if (!hasExpressionChild) {\n            if (node instanceof ASTStatement) {\n                /* if (!hasForInitNode && !hasForUpdateNode) {\n                    dataFlow.createNewNode(node);\n                    dataFlow.pushOnStack(NodeType.FOR_EXPR, dataFlow.getLast());\n                } */\n            }\n        }\n    }\n}\n", "th;\n\nimport com.marcinjasinski.sshpasswords.core.enums.GiodoOperationType;\n\nimport java.util.Date;\n\nimport javax.persistence.Entity;\nimport javax.persistence.EnumType;\nimport javax.persistence.Enumerated;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\nimport javax.validation.constraints.NotNull;\n\n/**\n * Class GiodoLog\n *\n * @author Marcin Jasinski {@literal <mkjasinski@gmail.com>}\n */\n@Entity\n@Table(name = \"giodolog\", schema = \"public\")\n@SuppressWarnings(\"PersistenceUnitPresent\")\npublic class GiodoLog extends BaseEntity {\n\n    @NotNull\n    private Date logTime;\n\n    @ManyToOne\n    private UserData user;\n\n    @Enumerated(EnumType.STRING)\n    private GiodoOperationType operation;\n\n    @Length(max = 512)\n    private String message;\n\n    public GiodoLog() {\n\n    }\n\n    public GiodoLog(Long id) {\n\n        super(id);\n    }\n\n    public GiodoLog(Date logTime, UserData user, GiodoOperationType operation, String message) {\n\n        this.logTime = logTime;\n        this.user = user;\n        this.operation = operation;\n        this.message = message;\n    }\n\n    public GiodoLog(Long id, Date logTime, UserData user, GiodoOperationType operation,\n                    String message) {\n\n        super(id);\n        this.logTime = logTime;\n        this.user = user;\n        this.operation = operation;\n        this.message = message;\n    }\n\n    public Date getLogTime() {\n\n        return logTime;\n    }\n\n    public void setLogTime(Date logTime) {\n\n        this.logTime = logTime;\n    }\n\n    public UserData getUser() {\n\n        return user;\n    }\n\n    public void setUser(UserData user) {\n\n        this.user = user;\n    }\n\n    public GiodoOperationType getOperation() {\n\n        return operation;\n    }\n\n    public void setOperation(GiodoOperationType operation) {\n\n        this.operation = operation;\n    }\n\n    public String getMessage() {\n\n        return message;\n    }\n\n    public void setMessage(String message) {\n\n        this.message = message;\n    }\n}\n", "ted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson;\n\nimport com.google.inject.AbstractModule;\nimport com.google.inject.ImplementedBy;\nimport hudson.model.PageDecorator;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport javax.inject.Inject;\nimport javax.inject.Qualifier;\nimport static org.hamcrest.Matchers.*;\nimport static org.junit.Assert.*;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.TestEnvironment;\nimport org.jvnet.hudson.test.TestExtension;\n\n/**\n * @author Kohsuke Kawaguchi\n */\npublic class ExtensionFinderTest {\n\n    @Rule\n    public JenkinsRule r = new JenkinsRule();\n\n    /**\n     * It's OK for some extensions to fail to load. The system needs to tolerate that.\n     */\n    @Test\n    public void failingInstance() {\n        FailingExtension i = PageDecorator.all().get(FailingExtension.class);\n        assertNull(\"Instantiation should have failed\",i);\n        assertTrue(\"Instantiation should have been attempted\", FailingExtension.error);\n    }\n\n    @TestExtension(\"failingInstance\")\n    public static class FailingExtension extends PageDecorator {\n        public FailingExtension() {\n            super(FailingExtension.class);\n            error = true;\n            throw new LinkageError();   // this component fails to load\n        }\n        public static boolean error;\n    }\n\n\n\n\n\n    /**\n     * Extensions are Guice components, so it should support injection.\n     */\n    @Test\n    public void injection() {\n        InjectingExtension i = PageDecorator.all().get(InjectingExtension.class);\n        assertNotNull(i.foo);\n        assertEquals(\"lion king\",i.value);\n    }\n\n    @TestExtension(\"injection\")\n    public static class InjectingExtension extends PageDecorator {\n        @Inject\n        Foo foo;\n\n        @Inject @LionKing\n        String value;\n\n\n        public InjectingExtension() {\n            super(InjectingExtension.class);\n        }\n        public static class Foo {}\n    }\n\n\n    @Retention(RetentionPolicy.RUNTIME) @Qualifier\n    public @interface LionKing {}\n\n    @Extension\n    public static class ModuleImpl extends AbstractModule {\n        protected void configure() {\n            TestEnvironment environment = TestEnvironment.get();\n            // JMH benchmarks do not initialize TestEnvironment, so check for null\n            if (environment != null && ExtensionFinderTest.class.getName().equals(environment.description().getClassName()) && \"injection\".equals(environment.description().getMethodName())) {\n                bind(String.class).annotatedWith(LionKing.class).toInstance(\"lion king\");\n            }\n        }\n    }\n\n\n    /**\n     * Tests the error recovery behaviour.\n     *\n     * One failure in binding definition shouldn't prevent Jenkins from booting.\n     */\n    @Test\n    public void errorRecovery() {\n        BrokenExtension i = PageDecorator.all().get(BrokenExtension.class);\n        assertNull(i);\n    }\n\n    @TestExtension(\"errorRecovery\")\n    public static class BrokenExtension extends PageDecorator {\n        public BrokenExtension() {\n            super(InjectingExtension.class);\n            \n            throw new Error();\n        }\n    }\n\n    @Test\n    public void injectMutualRecursion() {\n        A a = ExtensionList.lookupSingleton(A.class);\n        B b = ExtensionList.lookupSingleton(B.class);\n        assertEquals(b, a.b);\n        assertEquals(a, b.a);\n    }\n    @TestExtension(\"injectMutualRecursion\")\n    public static final class A {\n        @Inject B b;\n    }\n    @TestExtension(\"injectMutualRecursion\")\n    public static final class B {\n        @Inject A a;\n    }\n\n    @Issue(\"JENKINS-60816\")\n    @Test\n    public void injectInterface() {\n        assertThat(ExtensionList.lookupSingleton(X.class).xface, instanceOf(Impl.class));\n    }\n    @TestExtension(\"injectInterface\")\n    public static final class X {\n        @Inject\n        XFace xface;\n    }\n    @ImplementedBy(Impl.class)\n    public interface XFace {}\n    public static final class Impl implements XFace {}\n\n}\n", " * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport com.thoughtworks.xstream.converters.SingleValueConverter;\nimport com.thoughtworks.xstream.converters.basic.AbstractSingleValueConverter;\nimport hudson.cli.declarative.OptionHandlerExtension;\nimport hudson.util.EditDistance;\nimport org.apache.commons.beanutils.Converter;\nimport org.kohsuke.args4j.CmdLineException;\nimport org.kohsuke.args4j.CmdLineParser;\nimport org.kohsuke.args4j.OptionDef;\nimport org.kohsuke.args4j.spi.*;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.export.CustomExportedBean;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * The build outcome.\n *\n * @author Kohsuke Kawaguchi\n */\npublic final class Result implements Serializable, CustomExportedBean {\n    /**\n     * The build had no errors.\n     */\n    public static final Result SUCCESS = new Result(\"SUCCESS\",BallColor.BLUE,0);\n    /**\n     * The build had some errors but they were not fatal.\n     * For example, some tests failed.\n     */\n    public static final Result UNSTABLE = new Result(\"UNSTABLE\",BallColor.YELLOW,1);\n    /**\n     * The build had a fatal error.\n     */\n    public static final Result FAILURE = new Result(\"FAILURE\",BallColor.RED,2);\n    /**\n     * The module was not built.\n     * <p>\n     * This status code is used in a multi-stage build (like maven2)\n     * where a problem in earlier stage prevented later stages from building.\n     */\n    public static final Result NOT_BUILT = new Result(\"NOT_BUILT\",BallColor.NOTBUILT,3);\n    /**\n     * The build was manually aborted.\n     *\n     * If you are catching {@link InterruptedException} and interpreting it as {@link #ABORTED},\n     * you should check {@link Executor#abortResult()} instead (starting 1.417.)\n     */\n    public static final Result ABORTED = new Result(\"ABORTED\",BallColor.ABORTED,4);\n\n    private final String name;\n\n    /**\n     * Bigger numbers are worse.\n     */\n    public final int ordinal;\n\n    /**\n     * Default ball color for this status.\n     */\n    public final BallColor color;\n\n    private Result(String name, BallColor color, int ordinal) {\n        this.name = name;\n        this.color = color;\n        this.ordinal = ordinal;\n    }\n\n    /**\n     * Combines two {@link Result}s and returns the worse one.\n     */\n    public Result combine(Result that) {\n        if(this.ordinal < that.ordinal)\n            return that;\n        else\n            return this;\n    }\n\n    public boolean isWorseThan(Result that) {\n        return this.ordinal > that.ordinal;\n    }\n\n    public boolean isWorseOrEqualTo(Result that) {\n        return this.ordinal >= that.ordinal;\n    }\n\n    public boolean isBetterThan(Result that) {\n        return this.ordinal < that.ordinal;\n    }\n\n    public boolean isBetterOrEqualTo(Result that) {\n        return this.ordinal <= that.ordinal;\n    }\n\n\n    @Override\n    public String toString() {\n        return name;\n    }\n\n    public String toExportedObject() {\n        return name;\n    }\n    \n    public static Result fromString(String s) {\n        for (Result r : all)\n            if (s.equalsIgnoreCase(r.name))\n                return r;\n        return FAILURE;\n    }\n\n    private static List<String> getNames() {\n        List<String> l = new ArrayList<String>();\n        for (Result r : all)\n            l.add(r.name);\n        return l;\n    }\n\n    // Maintain each Result as a singleton deserialized (like build result from a slave node)\n    private Object readResolve() {\n        for (Result r : all)\n            if (ordinal==r.ordinal)\n                return r;\n        return FAILURE;\n    }\n\n    private static final long serialVersionUID = 1L;\n\n    private static final Result[] all = new Result[] {SUCCESS,UNSTABLE,FAILURE,NOT_BUILT,ABORTED};\n\n    public static final SingleValueConverter conv = new AbstractSingleValueConverter () {\n        public boolean canConvert(Class clazz) {\n            return clazz==Result.class;\n        }\n\n        public Object fromString(String s) {\n            return Result.fromString(s);\n        }\n    };\n\n    @OptionHandlerExtension\n    public static final class OptionHandlerImpl extends OptionHandler<Result> {\n        public OptionHandlerImpl(CmdLineParser parser, OptionDef option, Setter<? super Result> setter) {\n            super(parser, option, setter);\n        }\n\n        @Override\n        public int parseArguments(Parameters params) throws CmdLineException {\n            String param = params.getParameter(0);\n            Result v = fromString(param.replace('-', '_'));\n            if (v==null)\n                throw new CmdLineException(owner,\"No such status '\"+param+\"'. Did you mean \"+\n                        EditDistance.findNearest(param.replace('-', '_').toUpperCase(), getNames()));\n            setter.addValue(v);\n            return 1;\n        }\n\n        @Override\n        public String getDefaultMetaVariable() {\n            return \"STATUS\";\n        }\n    }\n\n    static {\n        Stapler.CONVERT_UTILS.register(new Converter() {\n            public Object convert(Class type, Object value) {\n                return Result.fromString(value.toString());\n            }\n        }, Result.class);\n    }\n}\n", "yParamTransactionId;\n\npublic class GDAXTradeHistoryParams implements TradeHistoryParamTransactionId {\n\n  String orderId = null;\n\n  public String getOrderId() {\n    return orderId;\n  }\n\n  public void setOrderId(String orderId) {\n    this.orderId = orderId;\n  }\n\n  @Override\n  public String getTransactionId() {\n    return orderId;\n  }\n\n  @Override\n  public void setTransactionId(String txId) {\n    orderId = txId;\n  }\n}\n", "y xavier on 1/28/14.\n */\npublic class TerminalStat extends Terminal {\n    private double in;\n    private double out;\n\n    public double getIn() {\n        return in;\n    }\n\n    public void setIn(double in) {\n        this.in = in;\n    }\n\n    public double getOut() {\n        return out;\n    }\n\n    public void setOut(double out) {\n        this.out = out;\n    }\n}\n", "import static data.Data.APPLES;\nimport static data.Data.MENU;\n\n/**\n */\npublic class FindingAndMatching_5_3 {\n\n    public static void main(String[] args) {\n        try {\n            anyMatch();\n            allMatch();\n\n            noneMatch();\n\n            findAny();\n\n            findFirstGreenApple();\n\n\n\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    private static void findFirstGreenApple() {\n        APPLES.stream()\n              .filter(apple -> apple.getColor().equals(\"green\"))\n              .findFirst()\n              .ifPresent(firstGreenApple -> System.out.println(\"firstGreenApple: \" + firstGreenApple));\n    }\n\n    private static void findAny() {\n        Optional<Apple> findAnyGreenApple = APPLES.stream()\n                                                  .filter(apple -> apple.getColor().equals(\"green\"))\n                                                  .findAny();\n        findAnyGreenApple.ifPresent(greenApple -> System.out.println(\"findAnyGreenApple: \" + findAnyGreenApple.get()));\n        System.out.println(\"findAnyGreenApple: \" + findAnyGreenApple.get());\n    }\n\n    private static void noneMatch() {\n        boolean noneIsAYellowApple = APPLES.stream()\n                               .noneMatch(apple -> apple.getColor().equals(\"yellow\"));\n        System.out.println(\"noneIsAYellowApple: \" + noneIsAYellowApple);\n    }\n\n    private static void allMatch() {\n        boolean everyAppleWeigthsAtLeast80 = APPLES.stream()\n                          .allMatch(apple -> apple.getWeight() >= 80);\n        System.out.println(\"everyAppleWeigthsAtLeast80: \" + everyAppleWeigthsAtLeast80);\n    }\n\n    private static void anyMatch() {\n        boolean atLeastOneVegDish = MENU.stream()\n                                        .anyMatch(d -> d.isVegetarian());\n        System.out.println(\"atLeastOneVegDish: \" + atLeastOneVegDish);\n    }\n\n\n}\n", "anted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage jp77.beta.utillib.pluginmanager.v1;\n\nimport jp77.beta.utillib.Listener;\nimport jp77.beta.utillib.classloader.v1.JarClassLoader;\nimport jp77.beta.utillib.classloader.ClassUtil;\n\nimport jp77.utillib.strings.MyStringBuffer;\n\nimport jp77.utillib.exceptions.InvalidFileTypeException;\n\nimport jp77.utillib.interfaces.IPluginListener;\nimport jp77.utillib.interfaces.IPluginListener.Event;\n\nimport jp77.utillib.pluginmanager.global.Parameter;\n\nimport jp77.utillib.arrays.ResizingArray;\n\nimport jp77.utillib.file.FileUtil;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Method;\n\nimport java.util.Enumeration;\nimport java.util.jar.JarEntry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\n/**\n * <pre>\n * <b>Current Version 1.0.2</b>\n * \n * September 24, 2009 (Version 1.0.0)\n *     -First Released\n * \n * March 12, 2009 (Version 1.0.1)\n *     -Updated\n *         -EveryThing\n * \n * May 5, 2010 (Version 1.0.2)\n *     -Added\n *         -In Use (Tells If The Plugin Is In Use)\n * \n * @author Justin Palinkas\n * \n * </pre>\n */\npublic class PluginManager {\n\tprivate static final Logger _LOG_ = Logger.getLogger(PluginManager.class.toString());\n\t\n\tpublic static final String _PLUGIN_DIRECTORY_ = \"plugins\";\n\n\tprivate final Class<?> _PLUGIN_INTERFACE;\n\n\tprivate final Listener<IPluginListener> _PLUGINLISTENERS = new Listener<IPluginListener>();\n\n\tprivate ResizingArray<PluginInfo> _PluginInfo = new ResizingArray<PluginInfo>(1, 2);\n\tprivate ResizingArray<String> _BlackList = new ResizingArray<String>(0, 3);\n\n\tprivate final boolean _CREATE_INSTANCE;\n\n\tpublic PluginManager(Class<?> plugininterface) {\n\t\tthis(plugininterface, true);\n\t}\n\n\tpublic PluginManager(Class<?> plugininterface, boolean createinstance) {\n\t\tif(plugininterface == null) {\n\t\t\tthrow new RuntimeException(\"Variable[plugininterface] - Is Null\");\n\t\t}\n\n\t\t_PLUGIN_INTERFACE = plugininterface;\n\t\t_CREATE_INSTANCE = createinstance;\n\t}\n\n\tpublic Listener<IPluginListener> getPluginListener() {\n\t\treturn _PLUGINLISTENERS;\n\t}\n\n\t/**\n\t * If You Are Done With Object Use Should checkOut The Object\n\t * \n\t * @param index\n\t * @return Plugin Instance\n\t */\n\tpublic Object getPlugin(int index) {\n\t\tfinal IPluginInfo P_INFO = getPluginInfoByIndex(index);\n\n\t\treturn (P_INFO == null ? null : P_INFO.getPlugin());\n\t}\n\n\t/**\n\t * If You Are Done With Object Use Should checkOut The Object\n\t * \n\t * @param pluginname\n\t * @return Plugin Instance\n\t */\n\tpublic Object getPlugin(String pluginname) {\n\t\tfinal IPluginInfo P_INFO = getPluginInfoByName(pluginname);\n\n\t\treturn (P_INFO == null ? null : P_INFO.getPlugin());\n\t}\n\n\t/**\n\t * If You Are Done With Object Use Should checkOut The Object\n\t * \n\t * @param index\n\t * @return\n\t */\n\tpublic IPluginInfo getPluginInfoAt(int index) {\n\t\treturn getPluginInfoByIndex(index);\n\t}\n\n\t/**\n\t * If You Are Done With Object Use Should checkOut The Object\n\t * \n\t * @param pluginname\n\t * @return\n\t */\n\tpublic IPluginInfo getPluginInfo(String pluginname) {\n\t\treturn getPluginInfoByName(pluginname);\n\t}\n\n\tpublic int getPluginInfoIndex(String pluginname) {\n\t\tfor(int X = 0; X < _PluginInfo.length(); X++) {\n\t\t\tfinal PluginInfo P_INFO = _PluginInfo.getAt(X);\n\n\t\t\tif(P_INFO._PluginName.equalsIgnoreCase(pluginname)) {\n\t\t\t\treturn X;\n\t\t\t}\n\t\t}\n\n\t\treturn -1;\n\t}\n\n\tpublic boolean isPluginDisabled(int index) {\n\t\treturn !isPluginEnabled(index);\n\t}\n\n\tpublic boolean isPluginDisabled(String pluginname) {\n\t\treturn !isPluginEnabled(pluginname);\n\t}\n\n\tpublic boolean isPluginEnabled(int index) {\n\t\tfinal IPluginInfo P_INFO = getPluginInfoAt(index);\n\n\t\treturn (P_INFO == null ? false : P_INFO.isEnabled());\n\t}\n\n\tpublic boolean isPluginEnabled(String pluginname) {\n\t\tfinal IPluginInfo P_INFO = getPluginInfo(pluginname);\n\n\t\treturn (P_INFO == null ? false : P_INFO.isEnabled());\n\t}\n\n\tpublic int pluginCount() {\n\t\treturn _PluginInfo.length();\n\t}\n\n\tpublic Class<?> getPluginInterface() {\n\t\treturn _PLUGIN_INTERFACE;\n\t}\n\n\t// Load Lib Directory\n\tpublic void loadDirectory() {\n\t\tloadDirectory(FileUtil.getAppPath(FileUtil._S_ + _PLUGIN_DIRECTORY_));\n\t}\n\n\t// Load Lib Directory\n\tpublic void loadDirectory(String directory) {\n\t\tloadDirectory(new File(directory));\n\t}\n\n\tpublic void loadDirectory(File directory) {\n\t\tif(directory == null) {\n\t\t\t_LOG_.log(Level.SEVERE, \"\", new RuntimeException(\"Variable[directory] - Is Null\"));\n\t\t} else if(!directory.exists()) {\n\t\t\t_LOG_.log(Level.SEVERE, \"\", new RuntimeException(\"Variable[directory] - \" + directory.getPath() + \" Does Not Exists\"));\n\t\t} else if(!directory.isDirectory()) {\n\t\t\t_LOG_.log(Level.SEVERE, \"\", new RuntimeException(\"Variable[directory] - Is Not A Directory\"));\n\t\t} else {\n\t\t\tfinal File[] FILES = directory.listFiles();\n\t\t\tfor(int X = 0; X < FILES.length; X++) {\n\t\t\t\tif(FILES[X].isFile()) {\n\t\t\t\t\tif(FileUtil.isFileType(FILES[X], JarClassLoader._JAR_MAGIC_NUMBER_)) {\n\t\t\t\t\t\tloadLibrary(FILES[X]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Loads Library\n\tpublic void loadLibrary(String file) {\n\t\tloadLibrary(new File(file));\n\t}\n\n\tpublic void loadLibrary(File file) {\n\t\tPluginClassLoader PLoader = null;\n\t\ttry {\n\t\t\tPLoader = new PluginClassLoader(file, _PLUGIN_INTERFACE);\n\n\t\t\t// Load Plugins\n\t\t\tfor(int X = 0; X < PLoader.pluginCount(); X++) {\n\t\t\t\tfinal String PLUGIN_CLASS;\n\t\t\t\ttry {\n\t\t\t\t\tPLUGIN_CLASS = PLoader.getPluginClassName(X);\n\n\t\t\t\t\t// Check to See if Plugin Is Allowed To Load\n\t\t\t\t\tif(isClassBlackListed(PLUGIN_CLASS)) {\n\t\t\t\t\t\t_LOG_.log(Level.INFO, \"Plugin[\" + PLUGIN_CLASS + \"] Is Blacklisted - Plugin Did Not Load\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfinal PluginInfo PINFO = new PluginInfo();\n\n\t\t\t\t\t\tPINFO._File = PLoader.getFile();\n\t\t\t\t\t\tPINFO._LibName = PLoader.getFile().getName();\n\t\t\t\t\t\tPINFO._ClassLoader = PLoader;\n\n\t\t\t\t\t\tPINFO._PluginClassName = PLUGIN_CLASS;\n\t\t\t\t\t\tPINFO._Plugin_Class = PLoader.loadPlugin(PINFO._PluginClassName);\n\n\t\t\t\t\t\tif(_CREATE_INSTANCE) {\n\t\t\t\t\t\t\tPINFO._Plugin_Instance = PINFO._Plugin_Class.newInstance();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tPINFO._Enabled = (PINFO._Plugin_Instance == null ? false : true);\n\n\t\t\t\t\t\tif(PINFO._Enabled && PINFO._Plugin_Instance != null) {\n\t\t\t\t\t\t\tfinal String PNAME = getPluginName(PINFO._Plugin_Instance);\n\n\t\t\t\t\t\t\tif(PNAME == null) {\n\t\t\t\t\t\t\t\tPINFO._PluginName = PINFO._PluginClassName;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tPINFO._PluginName = PNAME;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_PluginInfo.put(PINFO);\n\t\t\t\t\t\t\t// [Plugin Event] - Plugin Added\n\t\t\t\t\t\t\tsendEvent(Event.PLUGIN_ADDED, PINFO);\n\n\t\t\t\t\t\t\t_LOG_.log(Level.INFO, \"Plugin[\" + PINFO._PluginClassName + \"] - Plugin Loaded\");\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t} catch(InstantiationException e) {\n\t\t\t\t\t_LOG_.log(Level.SEVERE, \"Failed To Create Instance For Plugin: \" + file.getPath());\n\t\t\t\t} catch(IllegalAccessException e) {\n\t\t\t\t\t_LOG_.log(Level.SEVERE, \"Does Not Have A Public Constructor For Plugin: \" + file.getPath());\n\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t_LOG_.log(Level.SEVERE, \"While Loading Plugin: \" + file.getPath());\n\t\t\t\t\t_LOG_.log(Level.SEVERE, \"\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t} catch(FileNotFoundException e) {\n\t\t\t_LOG_.log(Level.SEVERE, \"Plugin: \" + file.getPath() + \" Not Found\");\n\t\t} catch(InvalidFileTypeException e) {\n\t\t\t_LOG_.log(Level.SEVERE, \"Plugin: \" + file.getPath() + \" Not A Jar/Zip File\");\n/*} catch(IOException e) {*/\n\t\t} catch(Exception e) {\n\t\t\t_LOG_.log(Level.SEVERE, \"While Loading Plugin: \" + file.getPath());\n\t\t\t_LOG_.log(Level.SEVERE, \"\", e);\n\t\t}\n\t}\n\n\tpublic void loadClass(Class<?> clazz, Parameter... parameters) {\n\t\tif(clazz == null) {\n\t\t\t_LOG_.log(Level.SEVERE, \"\", new RuntimeException(\"Variable[clazz] - Is Null\"));\n\t\t} else {\n\t\t\tif(!ClassUtil.implementsInterface(_PLUGIN_INTERFACE, clazz)) {\n\t\t\t\t_LOG_.log(Level.SEVERE, \"\", new RuntimeException(\"Variable[clazz] - \" + clazz.getName() + \" Does Not Implement Interface\"));\n\t\t\t} else {\n\t\t\t\t// Check to See if Plugin Is Allowed To Load\n\t\t\t\tif(isClassBlackListed(clazz.getName())) {\n\t\t\t\t\t_LOG_.log(Level.INFO, \"Plugin: \" + clazz.getName() + \" Is Blacklisted(Plugin Did Not Load)\");\n\t\t\t\t} else {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tfinal PluginInfo PINFO = new PluginInfo();\n\n\t\t\t\t\t\tPINFO._File = null;\n\t\t\t\t\t\tPINFO._LibName = null;\n\t\t\t\t\t\tPINFO._ClassLoader = clazz.getClassLoader();\n\t\t\t\t\t\tPINFO._Plugin_Class = clazz;\n\t\t\t\t\t\tPINFO._PluginClassName = clazz.getName();\n\n\t\t\t\t\t\tif(parameters.length > 0) {\n\t\t\t\t\t\t\tfinal Class<?>[] CLASSES = new Class[parameters.length];\n\t\t\t\t\t\t\tfinal Object[] ARGUMENTS = new Object[parameters.length];\n\n\t\t\t\t\t\t\tfor(int X = 0; X < parameters.length; X++) {\n\t\t\t\t\t\t\t\tCLASSES[X] = parameters[X].getType();\n\t\t\t\t\t\t\t\tARGUMENTS[X] = parameters[X].getArgument();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfinal Constructor<?> CONSTRUCTOR = clazz.getConstructor(CLASSES);\n\n\t\t\t\t\t\t\tif(CONSTRUCTOR == null) {\n\t\t\t\t\t\t\t\tPINFO._Enabled = false;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif(_CREATE_INSTANCE) {\n\t\t\t\t\t\t\t\t\tPINFO._Plugin_Instance = CONSTRUCTOR.newInstance(ARGUMENTS);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tPINFO._Enabled = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tif(_CREATE_INSTANCE) {\n\t\t\t\t\t\t\t\tPINFO._Plugin_Instance = clazz.newInstance();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tPINFO._Enabled = true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif(PINFO._Enabled && PINFO._Plugin_Instance != null) {\n\t\t\t\t\t\t\tfinal String PNAME = getPluginName(PINFO._Plugin_Instance);\n\n\t\t\t\t\t\t\tif(PNAME == null) {\n\t\t\t\t\t\t\t\tPINFO._PluginName = PINFO._PluginClassName;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tPINFO._PluginName = PNAME;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t_PluginInfo.put(PINFO);\n\t\t\t\t\t\t\t// [Plugin Event] - Plugin Added\n\t\t\t\t\t\t\tsendEvent(Event.PLUGIN_ADDED, PINFO);\n\n\t\t\t\t\t\t\t_LOG_.log(Level.INFO, \"Plugin[\" + PINFO._PluginClassName + \"] - Plugin Loaded\");\n\t\t\t\t\t\t}\n\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t_LOG_.log(Level.SEVERE, \"While Loading Plugin: \" + clazz.getName(), e);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void unloadLib(String libname) {// Jar/Zip File Name (ex.\n// Example.jar)\n\t\tfor(int X = 0; X < _PluginInfo.length(); X++) {\n\t\t\tPluginInfo TempInfo = _PluginInfo.getAt(X);\n\n\t\t\tif(TempInfo._LibName != null) {\n\t\t\t\tif(libname.equals(TempInfo._LibName)) {\n\t\t\t\t\tunloadPlugin(X);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// UnLoads Plugin\n\tpublic void unloadPlugin(String pluginname) {\n\t\tfinal int INDEX = getPluginInfoIndex(pluginname);\n\n\t\tif(INDEX != -1) {\n\t\t\tunloadPlugin(INDEX);\n\t\t}\n\t}\n\n\tpublic void unloadPlugin(int pluginindex) {\n\t\tif(_PluginInfo.validIndex(pluginindex)) {\n\t\t\tenablePlugin(pluginindex, false);\n\n\t\t\tfinal PluginInfo PINFO = _PluginInfo.getAt(pluginindex);\n\n\t\t\tPINFO._File = null;\n\t\t\tPINFO._LibName = null;\n\t\t\tPINFO._PluginName = null;\n\t\t\tPINFO._Plugin_Instance = null;\n\t\t\tPINFO._Plugin_Class = null;\n\t\t\tPINFO._ClassLoader = null;\n\t\t\tPINFO._PluginClassName = null;\n\n\t\t\t_PluginInfo.removeAt(pluginindex);\n\t\t\t// [Plugin Event] - Plugin Unload (Removed)\n\t\t\tsendEvent(Event.PLUGIN_REMOVED, PINFO);\n\t\t}\n\t}\n\n\tpublic void unloadAllPlugins() {\n\t\tfor(int X = (_PluginInfo.length() - 1); X > -1; X--) {\n\t\t\tunloadPlugin(X);\n\t\t}\n\t}\n\n\t// Enable Lib Plugin\n\tpublic void enablePlugin(int pluginindex, boolean enable) {\n\t\tif(_PluginInfo.validIndex(pluginindex)) {\n\t\t\tfinal PluginInfo PINFO = _PluginInfo.getAt(pluginindex);\n\n\t\t\tif(PINFO != null) {\n\t\t\t\tPINFO._Enabled = enable;\n\t\t\t\t// [Plugin Event] - Plugin Enabled (Enabled or Disabled)\n\t\t\t\tif(enable) {\n\t\t\t\t\tsendEvent(Event.PLUGIN_ENABLE, PINFO);// Plugin Enabled\n\t\t\t\t\t_LOG_.log(Level.INFO, \"Plugin\" + PINFO.getPluginName() + \" Is Enabled\");\n\t\t\t\t} else {\n\t\t\t\t\tsendEvent(Event.PLUGIN_DISABLED, PINFO);// Plugin Disabled\n\t\t\t\t\t_LOG_.log(Level.INFO, \"Plugin: \" + PINFO.getPluginName() + \" Is Disabled\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void enablePlugin(String pluginname, boolean enable) {\n\t\tfinal int INDEX = getPluginInfoIndex(pluginname);\n\n\t\tif(INDEX != -1) {\n\t\t\tenablePlugin(INDEX, enable);\n\t\t}\n\t}\n\n\t// Enable or Disables All Plugins\n\tpublic void enableAllPlugins(boolean enable) {\n\t\tfor(int X = 0; X < _PluginInfo.length(); X++) {\n\t\t\tenablePlugin(X, enable);\n\t\t}\n\t}\n\n\t/**\n\t * Ex. javax.swing.JButton\n\t * \n\t * @param classname\n\t */\n\tpublic void addBlackListClass(String classname) {\n\t\tif(classname != null && classname.length() > 0) {\n\t\t\tif(!isClassBlackListed(classname)) {\n\t\t\t\t_BlackList.put(classname);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ex. javax.swing.JButton\n\t * \n\t * @param classname\n\t */\n\tpublic void removeBlackListClass(String classname) {\n\t\tif(classname != null && classname.length() > 0) {\n\t\t\tfor(int X = 0; X < _BlackList.length();) {\n\t\t\t\tif(classname.equals(_BlackList.getAt(X))) {\n\t\t\t\t\t_BlackList.removeAt(X);\n\t\t\t\t} else {\n\t\t\t\t\tX++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Ex. javax.swing.JButton\n\t * \n\t * @param classname\n\t * @return\n\t */\n\tpublic boolean isClassBlackListed(String classname) {\n\t\tif(classname == null || classname.length() == 0) {\n\t\t\treturn false;\n\t\t} else {\n\t\t\tfor(int X = 0; X < _BlackList.length(); X++) {\n\t\t\t\tif(classname.equals(_BlackList.getAt(X))) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tprivate void sendEvent(Event event, IPluginInfo plugininfo) {\n\t\tfor(int X = 0; X < _PLUGINLISTENERS.listenerCount(); X++) {\n\t\t\tfinal IPluginListener LISTENER = _PLUGINLISTENERS.getListenerAt(X);\n\n\t\t\tif(LISTENER != null) {\n\t\t\t\tLISTENER.handleEvent(event, plugininfo);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate IPluginInfo getPluginInfoByIndex(int index) {\n\t\tif(_PluginInfo.validIndex(index)) {\n\t\t\treturn _PluginInfo.getAt(index);\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate IPluginInfo getPluginInfoByName(String pluginname) {\n\t\tfor(int X = 0; X < _PluginInfo.length(); X++) {\n\t\t\tfinal PluginInfo P_INFO = _PluginInfo.getAt(X);\n\n\t\t\tif(P_INFO._PluginName.equalsIgnoreCase(pluginname)) {\n\t\t\t\treturn P_INFO;\n\t\t\t}\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t// STATIC\n\tprivate static String getPluginName(Object instance) {\n\t\tMethod M = null;\n\t\ttry {\n\t\t\tM = instance.getClass().getMethod(\"getPluginName\");\n\n\t\t\tfinal Object OBJ = M.invoke(instance);\n\n\t\t\tif(OBJ instanceof String) {\n\t\t\t\treturn (String)OBJ;\n\t\t\t}\n\t\t} catch(Exception e) {}\n\n\t\treturn null;\n\t}\n\n\t// CLASSES\n\tprivate class PluginInfo implements IPluginInfo {\n\t\tprivate File _File = null;\n\t\tprivate String _LibName = null;\n\t\tprivate String _PluginName = null;\n\t\tprivate Object _Plugin_Instance = null;\n\t\tprivate Class<?> _Plugin_Class = null;\n\t\tprivate ClassLoader _ClassLoader = null;\n\t\tprivate String _PluginClassName = null;\n\t\tprivate boolean _Enabled = false;\n\n\t\t@Override\n\t\tpublic File getFile() {\n\t\t\treturn _File;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getJarFileName() {\n\t\t\treturn _LibName;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getPluginName() {\n\t\t\treturn _PluginName;\n\t\t}\n\n\t\t@Override\n\t\tpublic Object getPlugin() {\n\t\t\treturn _Plugin_Instance;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getPluginClass() {\n\t\t\treturn _Plugin_Class;\n\t\t}\n\n\t\t@Override\n\t\tpublic ClassLoader getClassLoader() {\n\t\t\treturn _ClassLoader;\n\t\t}\n\n\t\t@Override\n\t\tpublic String getPluginClassName() {\n\t\t\treturn _PluginClassName;\n\t\t}\n\n// public void enabled(boolean value) {\n// _Enabled = value;\n// }\n\n\t\t@Override\n\t\tpublic boolean isEnabled() {\n\t\t\treturn _Enabled;\n\t\t}\n\t}\n\n\tpublic class PluginClassLoader extends JarClassLoader {\n\t\tprivate ResizingArray<String> _PLUGIN_CLASSNAMES = new ResizingArray<String>();\n\n\t\tprivate final Class<?> _PLUGIN_INTERFACE;\n\n\t\tpublic PluginClassLoader(String path, Class<?> ainterface) throws IOException, FileNotFoundException, InvalidFileTypeException {\n\t\t\tthis(new File(path), ainterface);\n\t\t}\n\n\t\tpublic PluginClassLoader(File jarfile, Class<?> ainterface) throws IOException, FileNotFoundException, InvalidFileTypeException {\n\t\t\tsuper(jarfile);\n\n\t\t\tif(ainterface == null) {\n\t\t\t\tthrow new RuntimeException(\"Variable[ainterface] - Is Null\");\n\t\t\t}\n\n\t\t\t_PLUGIN_INTERFACE = ainterface;\n\n\t\t\tfinal MyStringBuffer FILENAME_BUFFER = new MyStringBuffer(32);\n\n\t\t\tfinal Enumeration<JarEntry> ENTRIES = super.getJarEntries();\n\t\t\twhile(ENTRIES.hasMoreElements()) {\n\t\t\t\tfinal JarEntry ENTRY = ENTRIES.nextElement();\n\n\t\t\t\tif(!ENTRY.isDirectory()) {\n\t\t\t\t\tFILENAME_BUFFER.append(ENTRY.getName());\n\n\t\t\t\t\tif(FILENAME_BUFFER.endsWith(\"Plugin.class\")) {\n\t\t\t\t\t\t// Removes File Extension(*.class)\n\t\t\t\t\t\tfinal int INDEX = FILENAME_BUFFER.lastIndexOf('.');\n\t\t\t\t\t\tif(INDEX != -1) {\n\t\t\t\t\t\t\tFILENAME_BUFFER.reset(INDEX);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Reformat String Ex. From [javax/swing/JButton] To\n\t\t\t\t\t\t// [javax.swing.JButton]\n\t\t\t\t\t\tFILENAME_BUFFER.replace('/', '.');\n\n\t\t\t\t\t\tif(!FILENAME_BUFFER.equals(ainterface.getCanonicalName())) {\n\t\t\t\t\t\t\t_PLUGIN_CLASSNAMES.put(FILENAME_BUFFER.toString());\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tFILENAME_BUFFER.reset();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Does Not Create New Instance Of Class\n\t\t * \n\t\t * @param index\n\t\t * @return\n\t\t */\n\t\tpublic Object loadPlugin(int index) {\n\t\t\tif(_PLUGIN_CLASSNAMES.validIndex(index)) {\n\t\t\t\treturn loadPluginClass(_PLUGIN_CLASSNAMES.getAt(index));\n\t\t\t} else {\n\t\t\t\treturn null;// Plugin Does Not Exists\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Does Not Create New Instance Of Class\n\t\t * \n\t\t * @param classname\n\t\t * @return\n\t\t */\n\t\tpublic Class<?> loadPlugin(String classname) {\n\t\t\tfinal int INDEX = findPluginClass(classname);\n\n\t\t\tif(INDEX == -1) {\n\t\t\t\treturn null;// Plugin Does Not Exists\n\t\t\t} else {\n\t\t\t\treturn loadPluginClass(classname);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @param index\n\t\t * @return Class Name At Index\n\t\t */\n\t\tpublic String getPluginClassName(int index) {\n\t\t\treturn _PLUGIN_CLASSNAMES.getAt(index);\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * @return The Number Of Available Plugin Class\n\t\t */\n\t\tpublic int pluginCount() {\n\t\t\treturn _PLUGIN_CLASSNAMES.length();\n\t\t}\n\n\t\tprivate int findPluginClass(String classname) {\n\t\t\tfor(int X = 0; X < _PLUGIN_CLASSNAMES.length(); X++) {\n\t\t\t\tif(classname.equals(_PLUGIN_CLASSNAMES.getAt(X))) {\n\t\t\t\t\treturn X;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn -1;\n\t\t}\n\n\t\t/**\n\t\t * \n\t\t * Does Not Create New Instance Of Class\n\t\t * \n\t\t * @param classname\n\t\t * @return\n\t\t */\n\t\tprivate Class<?> loadPluginClass(String classname) {// Ex javax.swing.JButton\n\t\t\tfinal Class<?> CLASS = super.loadClass(classname);\n\n\t\t\tif(CLASS != null) {\n\t\t\t\tif(!isPluginInterface(CLASS) && ClassUtil.implementsInterface(_PLUGIN_INTERFACE, CLASS)) {\n\t\t\t\t\tif(CLASS.isInterface()) {\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\treturn CLASS;\n\t\t\t\t\t\t} catch(Exception e) {\n\t\t\t\t\t\t\t_LOG_.log(Level.SEVERE, \"Plugin: \" + classname + \" Failed To Load\", e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\tprivate boolean isPluginInterface(Class<?> aclass) {\n\t\t\treturn (aclass == _PLUGIN_INTERFACE);\n\t\t}\n\t}\n}\n", "vax.faces.context.ExternalContext;\nimport javax.faces.context.FacesContext;\nimport javax.inject.Inject;\nimport javax.servlet.http.HttpServletResponse;\nimport javax.transaction.Transactional;\n\nimport br.com.casadocodigo.loja.daos.CheckoutDao;\nimport br.com.casadocodigo.loja.daos.SystemUserDao;\nimport br.com.casadocodigo.loja.models.Checkout;\nimport br.com.casadocodigo.loja.models.ShoppingCart;\nimport br.com.casadocodigo.loja.models.ShoppingItem;\nimport br.com.casadocodigo.loja.models.SystemUser;\n\n@Model\npublic class CheckoutBean {\n\n\tprivate SystemUser systemUser = new SystemUser();\n\t@Inject\n\tprivate SystemUserDao systemUserDao;\n\t@Inject\n\tprivate ShoppingCart shoppingCart;\n\t@Inject\n\tprivate CheckoutDao checkoutDao;\n\t@Inject\n\tprivate FacesContext facesContext;\n\t\n\tpublic SystemUser getSystemUser() {\n\t\treturn systemUser;\n\t}\n\t\n\tpublic void setSystemUser(SystemUser systemUser) {\n\t\tthis.systemUser = systemUser;\n\t}\n\t\n\t@Transactional\n\tpublic void checkout(){\n\t\tcheckUser();\n\t\t\n\t\tCheckout checkout = new Checkout(systemUser, shoppingCart);\n\t\tcheckoutDao.save(checkout);\n\t\tshoppingCart.clear();\n\t\t\n\t\tString contextName = facesContext.getExternalContext().getContextName();\n\t\tHttpServletResponse response = (HttpServletResponse) facesContext.getExternalContext().getResponse();\n\t\t\n\t\tresponse.setStatus(307);\n\t\tresponse.setHeader(\"Location\", \"/\"+ contextName +\"/services/payment?uuid=\"+ checkout.getUuid());\n\t}\n\n\tprivate void checkUser() {\n\t\tSystemUser userExist = systemUserDao.findByEmail(systemUser.getEmail());\n\t\tif(userExist == null){\n\t\t\tsystemUserDao.save(systemUser);\n\t\t}else{\n\t\t\tsystemUser = userExist;\n\t\t}\n\t}\n\t\n}\n", "e of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.iluwatar.eip.publish.subscribe;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Application test\n */\npublic class AppTest {\n\n  @Test\n  public void test() throws Exception {\n    App.main(new String[]{});\n  }\n}\n", "charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage com.epam.catgenome.controller.gene;\n\nimport com.epam.catgenome.controller.vo.TrackQuery;\nimport com.epam.catgenome.entity.track.Track;\nimport com.epam.catgenome.entity.vcf.Variation;\n\n/**\n * Class used in querying protein sequences with considering of gene variations.\n */\npublic class ProteinSequenceVariationQuery {\n\n    /**\n     * Track of variations, which should be taking into account during protein sequence reconstruction.\n     * This track of variations can be obtained through POST /vcf/variation/load service.\n     */\n    private Track<Variation> variations;\n\n    /**\n     * Track query of interested protein sequence reconstruction.\n     */\n    private TrackQuery trackQuery;\n\n    public ProteinSequenceVariationQuery() {\n        // no-op\n    }\n\n    /**\n     * Constructs a new ProteinSequenceVariationQuery instance\n     * @param variations Track of variations, which should be taking into account during protein sequence\n     *                   reconstruction. This track of variations can be obtained through\n     *                   POST /vcf/variation/load service.\n     * @param trackQuery Track query of interested protein sequence reconstruction.\n     */\n    public ProteinSequenceVariationQuery(final Track<Variation> variations, final TrackQuery trackQuery) {\n        this.variations = variations;\n        this.trackQuery = trackQuery;\n    }\n\n    public void setVariations(final Track<Variation> variations) {\n        this.variations = variations;\n    }\n\n    public void setTrackQuery(final TrackQuery trackQuery) {\n        this.trackQuery = trackQuery;\n    }\n\n    /**\n     * Track of variations, which should be taking into account during protein sequence reconstruction.\n     * This track of variations can be obtained through POST /vcf/variation/load service.\n     */\n    public Track<Variation> getVariations() {\n        return variations;\n    }\n\n    /**\n     * Track query of interested protein sequence reconstruction.\n     */\n    public TrackQuery getTrackQuery() {\n        return trackQuery;\n    }\n}\n", "equest;\nimport knorxx.framework.generator.web.client.RpcService;\nimport org.stjs.javascript.functions.Callback1;\n\n/**\n *\n * @author sj\n */\npublic class TestService implements RpcService {\n    \n    public static final String GET_BY_ID_METHOD_NAME = \"getById\";\n    public static final String GET_BY_ID_RESULT = \"haha\";\n    \n    public static final String THROW_EXCEPTION_METHOD_NAME = \"throwException\";\n    public static final String THROW_EXCEPTION_NAME = \"java.lang.IllegalStateException\";\n    \n    public String getById(HttpServletRequest request, long id, Callback1<String> callback, Object scope) {\n        return GET_BY_ID_RESULT;\n    }\n    \n    public String throwException(Callback1<String> callback, Object scope) {\n        throw new IllegalStateException();\n    }\n}\n", "a.util.List;\n\nimport javax.sql.DataSource;\n\nimport abd.pr1.mappers.PersonajeMapper;\nimport abd.pr1.observables.InfoPersonajeObserver;\nimport abd.pr1.observables.Observable;\nimport abd.pr1.tiposDeDatos.Personaje;\n\npublic class GestionPersonajes extends Observable<InfoPersonajeObserver>{\n\tprivate DataSource ds;\n\n\tpublic GestionPersonajes(DataSource ds) {\n\t\tthis.ds = ds;\n\t}\n\n\tpublic boolean nuevoPersonaje(String nombre, String descripcion) {\n\t\tList<Personaje> personajes = new ArrayList<>();\n\t    PersonajeMapper personajeMapper = new PersonajeMapper(ds);\n\t\tpersonajes = personajeMapper.buscarPersonajes(nombre);\n\t\tPersonaje tmpPersonaje = null;\n\t\tString error = \"\";\n\t\tIterator<Personaje> it = personajes.iterator();\n\t\twhile(it.hasNext() && error.isEmpty()) {\n\t\t\ttmpPersonaje = it.next();\n\t\t\tif(tmpPersonaje.getNombre().equalsIgnoreCase(nombre)) {\n\t\t\t\terror = \"Ya existe un Personaje con ese nombre.\";\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(error == null || error.isEmpty()){\n\t\t\tpersonajeMapper.insert(new Personaje( nombre, descripcion));\n\t\t\tavisarDatosPersonajes(nombre, descripcion);\n\t\t}\n\t\telse mostrarError(error);\n\n\t\treturn error.isEmpty();\n\t}\n\n\tprivate void mostrarError(String error) {\n\t\tIterator<InfoPersonajeObserver> it = super.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tit.next().errorProducido(error);\n\t\t}\t\n\t}\n\n\tpublic List<Personaje> buscarPersonaje(String nombrePersonaje) {\n\t\tPersonajeMapper personajeMapper = new PersonajeMapper(ds);\n\t\tList<Personaje> personajes = personajeMapper.buscarPersonajes(nombrePersonaje);\n\t\tmostrarCatalogoPersonajes(personajes);\n\t\t\n\t\treturn personajes;\t\n\t}\n\n\tprivate void mostrarCatalogoPersonajes(List<Personaje> personajes) {\n\t\tIterator<InfoPersonajeObserver> it = super.iterator();\n\t\twhile(it.hasNext())\n\t\t{\n\t\t\tit.next().mostrarTodosLosPersonajes(personajes);\n\t\t}\t\n\t}\n\t\n\tpublic void datosPersonajes(String nombrePersonaje) {\n\t\tPersonajeMapper personajeMapper = new PersonajeMapper(ds);\n\t\tPersonaje personaje = personajeMapper.buscarUnPersonaje(nombrePersonaje);\n\t\n\t\tString nombre = personaje.getNombre();\n\t\tString descripcion = personaje.getDescripcion();\n\t\t\n\t\tavisarDatosPersonajes(nombre, descripcion);\n\t}\n\n\tprivate void avisarDatosPersonajes(String nombre, String descripcion) {\n\t\tIterator<InfoPersonajeObserver> it = super.iterator();\n\t\twhile(it.hasNext()){\n\t\t\tit.next().datosPersonaje(nombre, descripcion);\n\t\t}\t\n\t}\n\t\n\tpublic void dameTodosLosPersonajes(String nombreEpisodio){\n\t\tPersonajeMapper personajeMapper = new PersonajeMapper(ds);\n\t\tList<Personaje> todosPersonajes = personajeMapper.buscarPersonajes(\"\");\n\t\t\n\t\t//Episodio episodio = new EpisodioMapper(ds).buscarEpisodio(nombreEpisodio);\n\t\t//Actuacion actua = new ActuacionMapper(ds).findById(episodio.getId());\n\t\t\n\t\t\n\t\t//List<Personaje> personajesLibres = new ArrayList<>();\t\t\n\t\t\n\t\t//Iterator<Personaje> it = todosPersonajes.iterator();\n\n\t\tmostrarCatalogoPersonajes(todosPersonajes);\n\t}\n}\n", "ee of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * \n */\npackage org.jmxtrans.embedded.output;\n\nimport org.jmxtrans.embedded.EmbeddedJmxTransException;\nimport org.jmxtrans.embedded.QueryResult;\nimport org.jmxtrans.embedded.util.io.IoUtils2;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStreamWriter;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.nio.charset.Charset;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * <a href=\"http://graphite.readthedocs.org/\">Graphite</a> implementation of the {@linkplain OutputWriter}.\n *\n * This implementation uses <a href=\"http://graphite.readthedocs.org/en/0.9.10/feeding-carbon.html#the-plaintext-protocol\">\n * Carbon Plan Text protocol</a> over HTTP.\n *\n * Read <a href=\"https://answers.launchpad.net/graphite/+question/213436\">this thread</a> in order to implement a HTTP\n * listener in front of Carbon backend.\n *\n * Settings:\n * <ul>\n * <li>\"url\": complete url of the Graphite proxy server. Mandatory</li>\n * <li>\"namePrefix\": prefix append to the metrics name.\n * Optional, default value: {@value #DEFAULT_NAME_PREFIX}.</li>\n * </ul>\n *\n * @author <a href=\"mailto:simon.mazas@gmail.com\">Simon Mazas</a>\n */\npublic class GraphiteHttpWriter extends AbstractOutputWriter implements OutputWriter {\n\n    public static final String DEFAULT_NAME_PREFIX = \"servers.#hostname#.\";\n\n    private final Logger logger = LoggerFactory.getLogger(getClass());\n\n    /**\n     * Metric path prefix. Ends with \".\" if not empty;\n     */\n    private String metricPathPrefix;\n\n    private URL graphiteHttpUrl;\n\n    @Override\n    public void start() {\n        String url = getStringSetting(SETTING_URL);\n\n        try {\n            graphiteHttpUrl = new URL(url);\n        } catch (MalformedURLException e) {\n            throw new EmbeddedJmxTransException(e);\n        }\n\n\t    logger.info(\"Start Graphite writer connected to '{}'...\", graphiteHttpUrl);\n\n        metricPathPrefix = getStringSetting(SETTING_NAME_PREFIX, DEFAULT_NAME_PREFIX);\n        metricPathPrefix = getStrategy().resolveExpression(metricPathPrefix);\n        if (!metricPathPrefix.isEmpty() && !metricPathPrefix.endsWith(\".\")) {\n            metricPathPrefix = metricPathPrefix + \".\";\n        }\n\n    }\n\n    /**\n     * Send given metrics to the Graphite server.\n     */\n    @Override\n    public void write(Iterable<QueryResult> results) {\n        logger.debug(\"Export to '{}' results {}\", graphiteHttpUrl, results);\n        HttpURLConnection urlConnection = null;\n        OutputStreamWriter urlWriter;\n        try {\n            StringBuilder sbUrlWriter = new StringBuilder(\"\");\n            for (QueryResult result : results) {\n                String msg = metricPathPrefix + result.getName() + \" \" + result.getValue() + \" \" + result.getEpoch(TimeUnit.SECONDS) + \"\\n\";\n                logger.debug(\"Export '{}'\", msg);\n                sbUrlWriter.append(msg);\n            }\n            if (sbUrlWriter.length() > 0) {\n                sbUrlWriter.insert(0, \"data=\");\n                urlConnection = (HttpURLConnection) graphiteHttpUrl.openConnection();\n                urlConnection.setRequestMethod(\"POST\");\n                urlConnection.setDoOutput(true);\n                urlWriter = new OutputStreamWriter(urlConnection.getOutputStream(), Charset.forName(\"UTF-8\"));\n                urlWriter.write(sbUrlWriter.toString());\n                urlWriter.flush();\n                IoUtils2.closeQuietly(urlWriter);\n                int responseCode = urlConnection.getResponseCode();\n                if (responseCode != 200) {\n                    logger.warn(\"Failure {}:'{}' to send result to Graphite HTTP proxy'{}' \", responseCode, urlConnection.getResponseMessage(), graphiteHttpUrl);\n                }\n                if (logger.isTraceEnabled()) {\n                    IoUtils2.copy(urlConnection.getInputStream(), System.out);\n                }\n            }\n        } catch (Exception e) {\n            logger.warn(\"Failure to send result to Graphite HTTP proxy '{}'\", graphiteHttpUrl, e);\n        } finally {\n            // Release the connection.\n            if (urlConnection != null) {\n                try {\n                    InputStream in = urlConnection.getInputStream();\n                    IoUtils2.copy(in, IoUtils2.nullOutputStream());\n                    IoUtils2.closeQuietly(in);\n                    InputStream err = urlConnection.getErrorStream();\n                    if (err != null) {\n                        IoUtils2.copy(err, IoUtils2.nullOutputStream());\n                        IoUtils2.closeQuietly(err);\n                    }\n                } catch (IOException e) {\n                    logger.warn(\"Exception flushing http connection\", e);\n                }\n            }\n        }\n    }\n\n}\n\n", " of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\npackage io.github.jonestimd.finance.dao;\n\nimport java.io.Serializable;\nimport java.util.List;\nimport java.util.stream.Stream;\n\npublic interface BaseDao<ENTITY, PK extends Serializable> {\n\n    List<ENTITY> getAll(String ... associations);\n\n    ENTITY get(PK id);\n\n    <T extends ENTITY> T save(T persistentEntity);\n\n    <T extends Iterable<? extends ENTITY>> T saveAll(T entities);\n\n    void saveAll(Stream<? extends ENTITY> entities);\n\n    <T extends ENTITY> T merge(T persistentEntity);\n\n    <T extends ENTITY> void delete(T persistentEntity);\n\n    void deleteAll(Iterable<? extends ENTITY> entities);\n\n    void deleteAll(Stream<? extends ENTITY> entities);\n}\n", "e, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\npackage io.inbot.xmltools;\r\n\r\nimport io.inbot.xmltools.exceptions.RethrownException;\r\nimport java.math.BigDecimal;\r\nimport java.math.BigInteger;\r\nimport java.text.DecimalFormat;\r\nimport java.text.NumberFormat;\r\nimport java.text.ParseException;\r\nimport java.text.ParsePosition;\r\nimport java.util.Iterator;\r\nimport java.util.Locale;\r\nimport java.util.Map;\r\nimport java.util.NoSuchElementException;\r\nimport java.util.Optional;\r\nimport java.util.TreeMap;\r\nimport java.util.stream.Stream;\r\nimport java.util.stream.StreamSupport;\r\nimport javax.xml.namespace.QName;\r\nimport javax.xml.xpath.XPathConstants;\r\nimport javax.xml.xpath.XPathExpressionException;\r\nimport org.apache.commons.lang3.StringUtils;\r\nimport org.w3c.dom.NamedNodeMap;\r\nimport org.w3c.dom.Node;\r\nimport org.w3c.dom.NodeList;\r\n\r\n/**\r\n * Simple browser abstraction over XML documents that allows you to browse the XML document using xpath expressions against a current node.\r\n *\r\n * It reuses xpath expressions using the {@link XPathExpressionCache}. This is a lot faster than recompiling the expressions every time.\r\n *\r\n * Note, you should use the XPathBrowserFactory for creating instances.\r\n *\r\n * Note, this class does not support namespaces currently. TODO: check here for potential solution\r\n * http://blog.davber.com/2006/09/17/xpath-with-namespaces-in-java/\r\n */\r\npublic class XPathBrowser {\r\n\r\n    private final Node rootNode;\r\n    private final XPathExpressionCache expressionCache;\r\n\r\n    XPathBrowser(XPathExpressionCache expressionCache, Node node) {\r\n        this.expressionCache = expressionCache;\r\n        this.rootNode=node;\r\n    }\r\n\r\n    /**\r\n     * Efficient xpath expression evaluator that uses the {@link XPathExpressionCache}.\r\n     * Use this if none of the other methods do what you need.\r\n     *\r\n     * @param expr expr\r\n     * @param node node\r\n     * @param resultType type\r\n     * @return DOM object of the specified type or null.\r\n     */\r\n    public Object eval(final String expr, final Node node, final QName resultType) {\r\n        try {\r\n            return expressionCache.getExpression(expr).evaluate(node, resultType);\r\n        } catch (XPathExpressionException e) {\r\n            throw RethrownException.rethrow(e);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Evaluate expression to a boolean value.\r\n     *\r\n     * @param n\r\n     *        node from which the (relative) expression is evaluated.\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression or false if the node was absent or empty.\r\n     */\r\n    public boolean getBoolean(final Node n, final String expr) {\r\n        return getString(n, expr).map(s->Boolean.valueOf(s)).orElse(false);\r\n    }\r\n\r\n    /**\r\n     * Evaluate expression to a boolean value.\r\n     *\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public boolean getBoolean(final String expr) {\r\n        return getBoolean(node(), expr);\r\n    }\r\n\r\n    /**\r\n     * @return current node as a boolean\r\n     */\r\n    public boolean getBoolean() {\r\n\t\treturn getBoolean(\".\");\r\n    }\r\n\r\n\r\n    /**\r\n     * Evaluate expression to a double value.\r\n     *\r\n     * @param n\r\n     *        node from which the (relative) expression is evaluated.\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<Double> getDouble(final Node n, final String expr) {\r\n        return getString(n, expr).map(s -> Double.valueOf(s));\r\n    }\r\n\r\n    /**\r\n     * Evaluate expression to a double value.\r\n     *\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<Double> getDouble(final String expr) {\r\n        return getDouble(node(), expr);\r\n    }\r\n\r\n    /**\r\n     * @return current node as a double.\r\n     */\r\n    public Optional<Double> getDouble() {\r\n\t\treturn getDouble(\".\");\r\n    }\r\n\r\n\r\n    /**\r\n     * Evaluate expression to a int value.\r\n     *\r\n     * @param n\r\n     *        node from which the (relative) expression is evaluated.\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<Integer> getInt(final Node n, final String expr) {\r\n        return getString(n, expr).map(s -> Integer.valueOf(s));\r\n    }\r\n\r\n    /**\r\n     * Evaluate expression to a int value.\r\n     *\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<Integer> getInt(final String expr) {\r\n        return getInt(node(), expr);\r\n    }\r\n\r\n    /**\r\n     * @return current node as an int\r\n     */\r\n    public Optional<Integer> getInt() {\r\n\t\treturn getInt(\".\");\r\n    }\r\n\r\n    public Optional<Number> getNumber(Locale locale, final String expr) {\r\n        return getNumber(locale,rootNode,expr);\r\n    }\r\n\r\n    public Optional<Number> getNumber(Locale locale, final Node n, final String expr) {\r\n        return getString(n, expr).map(s -> {\r\n            try {\r\n                return NumberFormat.getInstance(locale).parse(s);\r\n            } catch (ParseException e) {\r\n                throw RethrownException.rethrow(e);\r\n            }\r\n        });\r\n    }\r\n\r\n    public Optional<BigDecimal> getBigDecimal(Locale locale, final String expr) {\r\n        return getBigDecimal(locale,rootNode, expr);\r\n    }\r\n\r\n    public Optional<BigDecimal> getBigDecimal(Locale locale, final Node n, final String expr) {\r\n        return getString(n, expr).map(s -> {\r\n            DecimalFormat nf = (DecimalFormat)NumberFormat.getInstance(locale);\r\n            nf.setParseBigDecimal(true);\r\n            return (BigDecimal)nf.parse(s, new ParsePosition(0));\r\n        });\r\n    }\r\n\r\n    public Optional<BigInteger> getBigInteger(final String expr) {\r\n        return getBigInteger(rootNode, expr);\r\n    }\r\n\r\n    public Optional<BigInteger> getBigInteger(final Node n, final String expr) {\r\n        return getString(n, expr).map(s -> {\r\n            return new BigInteger(s);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Evaluate expression to a long value.\r\n     *\r\n     * @param n\r\n     *        node from which the (relative) expression is evaluated.\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<Long> getLong(final Node n, final String expr) {\r\n        return getString(n, expr).map(s -> Long.valueOf(s));\r\n    }\r\n\r\n    /**\r\n     * Evaluate expression to a long value.\r\n     *\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<Long> getLong(final String expr) {\r\n        return getLong(node(), expr);\r\n    }\r\n\r\n    /**\r\n     * @return current node as a long\r\n     */\r\n    public Optional<Long> getLong() {\r\n\t\treturn getLong(\".\");\r\n    }\r\n\r\n    /**\r\n     * Evaluate an expression that should result in a String (relative to the provided node).\r\n     *\r\n     * @param n\r\n     *        node from which the (relative) expression is evaluated.\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<String> getString(final Node n, final String expr) {\r\n        String result = ((String) eval(expr, n, XPathConstants.STRING)).trim();\r\n        if(StringUtils.isBlank(result)) {\r\n            return Optional.empty();\r\n        } else {\r\n            return Optional.of(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Evaluate an expression that should result in a String (relative to the root).\r\n     *\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return result of the expression.\r\n     */\r\n    public Optional<String> getString(final String expr) {\r\n        String s = ((String) eval(expr, node(), XPathConstants.STRING)).trim();\r\n        if(StringUtils.isBlank(s)) {\r\n            return Optional.empty();\r\n        } else {\r\n            return Optional.of(s);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return current node as a String\r\n     */\r\n    public Optional<String> getString() {\r\n\t\treturn getString(\".\");\r\n    }\r\n\r\n\r\n    /**\r\n\t * @param expr expression\r\n\t * @return the first node that matches the expression\r\n\t * @throws IllegalArgumentException if the node does not exist\r\n\t */\r\n\tpublic Optional<Node> getFirstNode(String expr) {\r\n\t\treturn getFirstNode(node(), expr);\r\n\t}\r\n\r\n\t/**\r\n\t * @param n node\r\n\t * @param expr expression\r\n\t * @return the first node that matches the expression\r\n\t * @throws IllegalArgumentException if the node does not exist\r\n\t */\r\n\tpublic Optional<Node> getFirstNode(Node n, String expr) {\r\n\t\tNodeList nodeList = getNodeList(n, expr);\r\n\t\tif(nodeList.getLength() == 0) {\r\n\t\t\treturn Optional.empty();\r\n\t\t} else {\r\n\t\t\treturn Optional.of(nodeList.item(0));\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Evaluate an expression that should result in a Node set (relative to the provided node).\r\n\t *\r\n\t * @param n\r\n\t *        node from which the (relative) expression is evaluated.\r\n\t * @param expr\r\n\t *        expr xpath expression.\r\n\t * @return a list of Nodes matching the expression.\r\n\t */\r\n\tpublic NodeList getNodeList(final Node n, final String expr) {\r\n\t    return (NodeList) eval(expr, n, XPathConstants.NODESET);\r\n\t}\r\n\r\n\t/**\r\n\t * Evaluate an expression that should result in a Node set (relative to the root).\r\n\t *\r\n\t * @param expr\r\n\t *        xpath expression.\r\n\t * @return a list of nodes matching the expression\r\n\t */\r\n\tpublic NodeList getNodeList(final String expr) {\r\n\t    return (NodeList) eval(expr, node(), XPathConstants.NODESET);\r\n\t}\r\n\r\n\t/**\r\n     * Get array of values that match specified expression.\r\n     *\r\n     * @param n\r\n     *        node from which the (relative) expression is evaluated.\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return array with matching values\r\n     */\r\n    public String[] getStringValues(final Node n, final String expr) {\r\n        final NodeList nodes = getNodeList(n, expr);\r\n        final String[] values = new String[nodes.getLength()];\r\n        for (int i = 0; i < nodes.getLength(); i++) {\r\n            values[i] = getString(nodes.item(i), \".\").orElse(\"\");\r\n        }\r\n        return values;\r\n\r\n    }\r\n\r\n    /**\r\n     * Get array of values that match specified expression.\r\n     *\r\n     * @param expr\r\n     *        xpath expression.\r\n     * @return array with matching values\r\n     */\r\n    public String[] getStringValues(final String expr) {\r\n        return getStringValues(node(), expr);\r\n    }\r\n\r\n    /**\r\n     * Get a named sub node from the parent.\r\n     *\r\n     * @param parent parent node\r\n     * @param name name\r\n     * @return a Node instance\r\n     */\r\n    public Node getSubNode(final Node parent, final String name) {\r\n        final Node node = (Node) eval(name, parent, XPathConstants.NODE);\r\n        return node;\r\n    }\r\n\r\n    /**\r\n     * @return the current node; expressions are evaluated relative to this node.\r\n     */\r\n    public Node node() {\r\n\t    return rootNode;\r\n\t}\r\n\r\n    public Optional<String> getNodeAttribute(String key) {\r\n        return getString(\"@\"+key);\r\n    }\r\n\r\n    public Map<String,String> nodeAttributes() {\r\n        NamedNodeMap attributes = rootNode.getAttributes();\r\n        TreeMap<String,String> map = new TreeMap<>();\r\n        if(attributes != null) {\r\n            attributes.getLength();\r\n            for(int i=0; i<attributes.getLength();i++) {\r\n                Node attributeNode = attributes.item(i);\r\n                map.put(attributeNode.getNodeName(), getString(attributeNode, \".\").get());\r\n            }\r\n        }\r\n        return map;\r\n    }\r\n\r\n    public XPathBrowser browse(final Node node) {\r\n        return new XPathBrowser(expressionCache, node);\r\n    }\r\n\r\n    public XPathBrowser browseFirst(String expression) {\r\n        return new XPathBrowser(expressionCache, getFirstNode(expression).orElseThrow(() -> new NoSuchElementException(\"node does not exist for \" + expression)));\r\n    }\r\n\r\n    public Stream<XPathBrowser> streamSubNodes() {\r\n        return StreamSupport.stream(browseSubNodes().spliterator(), false);\r\n    }\r\n\r\n    public Stream<XPathBrowser> streamMatching(String expr) {\r\n        return StreamSupport.stream(browseMatching(expr).spliterator(), false);\r\n    }\r\n\r\n    public Iterable<XPathBrowser> browseSubNodes() {\r\n    \treturn browseMatching(\"./*\");\r\n    }\r\n\r\n    public Iterable<XPathBrowser> browseMatching(final String expr) {\r\n    \tfinal NodeList nodeList = getNodeList(node(), expr);\r\n    \tfinal XPathBrowser parent = this;\r\n    \treturn new Iterable<XPathBrowser>() {\r\n\r\n\t\t\t@Override\r\n\t\t\tpublic Iterator<XPathBrowser> iterator() {\r\n\t\t\t\treturn new NodeIterator(nodeList, parent);\r\n\t\t\t}\r\n\t\t};\r\n    }\r\n\r\n    public Iterator<XPathBrowser> browseMatching(final Node n, final String expr) {\r\n    \tNodeList nodeList = getNodeList(n, expr);\r\n    \treturn new NodeIterator(nodeList, this);\r\n    }\r\n\r\n\tprivate final class NodeIterator implements Iterator<XPathBrowser> {\r\n\t\tprivate final NodeList nodeList;\r\n\t\tint i=0;\r\n\r\n\t\tprivate NodeIterator(NodeList nodeList, XPathBrowser browser) {\r\n\t\t\tthis.nodeList = nodeList;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic boolean hasNext() {\r\n\t\t\tboolean hasNext = i<nodeList.getLength();\r\n\r\n\t\t\treturn hasNext;\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic XPathBrowser next() {\r\n\t\t    return new XPathBrowser(expressionCache, nodeList.item(i++));\r\n\t\t}\r\n\r\n\t\t@Override\r\n\t\tpublic void remove() {\r\n\t\t\tthrow new UnsupportedOperationException(\"remove is not supported\");\r\n\t\t}\r\n\t}\r\n}\r\n", "ion, vhudson-jaxb-ri-2.1-2 \n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \n// Any modifications to this file will be lost upon recompilation of the source schema. \n// Generated on: 2014.01.30 at 01:53:29 PM CET \n//\n\n\npackage ExternalPackages.org.hupo.psi.ms.traml;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlType;\n\n\n/**\n * Intermediate product ion information of the transition when using MS3 or above\n * <p>\n * <p>Java class for IntermediateProductType complex type.\n * <p>\n * <p>The following schema fragment specifies the expected content contained within this class.\n * <p>\n * <pre>\n * &lt;complexType name=\"IntermediateProductType\">\n *   &lt;complexContent>\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\n *       &lt;sequence>\n *         &lt;element name=\"cvParam\" type=\"{http://psi.hupo.org/ms/traml}cvParamType\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n *         &lt;element name=\"userParam\" type=\"{http://psi.hupo.org/ms/traml}UserParamType\" maxOccurs=\"unbounded\" minOccurs=\"0\"/>\n *         &lt;element name=\"InterpretationList\" type=\"{http://psi.hupo.org/ms/traml}InterpretationListType\" minOccurs=\"0\"/>\n *         &lt;element name=\"ConfigurationList\" type=\"{http://psi.hupo.org/ms/traml}ConfigurationListType\" minOccurs=\"0\"/>\n *       &lt;/sequence>\n *     &lt;/restriction>\n *   &lt;/complexContent>\n * &lt;/complexType>\n * </pre>\n */\n@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"IntermediateProductType\", propOrder = {\n        \"cvParam\",\n        \"userParam\",\n        \"interpretationList\",\n        \"configurationList\"\n})\npublic class IntermediateProductType {\n\n    protected List<CvParamType> cvParam;\n    protected List<UserParamType> userParam;\n    @XmlElement(name = \"InterpretationList\")\n    protected InterpretationListType interpretationList;\n    @XmlElement(name = \"ConfigurationList\")\n    protected ConfigurationListType configurationList;\n\n    /**\n     * Gets the value of the cvParam property.\n     * <p>\n     * <p>\n     * This accessor method returns a reference to the live list,\n     * not a snapshot. Therefore any modification you make to the\n     * returned list will be present inside the JAXB object.\n     * This is why there is not a <CODE>set</CODE> method for the cvParam property.\n     * <p>\n     * <p>\n     * For example, to add a new item, do as follows:\n     * <pre>\n     *    getCvParam().add(newItem);\n     * </pre>\n     * <p>\n     * <p>\n     * <p>\n     * Objects of the following type(s) are allowed in the list\n     * {@link CvParamType }\n     */\n    public List<CvParamType> getCvParam() {\n        if (cvParam == null) {\n            cvParam = new ArrayList<CvParamType>();\n        }\n        return this.cvParam;\n    }\n\n    /**\n     * Gets the value of the userParam property.\n     * <p>\n     * <p>\n     * This accessor method returns a reference to the live list,\n     * not a snapshot. Therefore any modification you make to the\n     * returned list will be present inside the JAXB object.\n     * This is why there is not a <CODE>set</CODE> method for the userParam property.\n     * <p>\n     * <p>\n     * For example, to add a new item, do as follows:\n     * <pre>\n     *    getUserParam().add(newItem);\n     * </pre>\n     * <p>\n     * <p>\n     * <p>\n     * Objects of the following type(s) are allowed in the list\n     * {@link UserParamType }\n     */\n    public List<UserParamType> getUserParam() {\n        if (userParam == null) {\n            userParam = new ArrayList<UserParamType>();\n        }\n        return this.userParam;\n    }\n\n    /**\n     * Gets the value of the interpretationList property.\n     *\n     * @return possible object is\n     * {@link InterpretationListType }\n     */\n    public InterpretationListType getInterpretationList() {\n        return interpretationList;\n    }\n\n    /**\n     * Sets the value of the interpretationList property.\n     *\n     * @param value allowed object is\n     *              {@link InterpretationListType }\n     */\n    public void setInterpretationList(InterpretationListType value) {\n        this.interpretationList = value;\n    }\n\n    /**\n     * Gets the value of the configurationList property.\n     *\n     * @return possible object is\n     * {@link ConfigurationListType }\n     */\n    public ConfigurationListType getConfigurationList() {\n        return configurationList;\n    }\n\n    /**\n     * Sets the value of the configurationList property.\n     *\n     * @param value allowed object is\n     *              {@link ConfigurationListType }\n     */\n    public void setConfigurationList(ConfigurationListType value) {\n        this.configurationList = value;\n    }\n\n}\n", "undle;\n\npublic class BlankActivity extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_blank);\n    }\n}\n", "kage com.azure.security.keyvault.certificates;\n\nimport com.azure.core.util.polling.LongRunningOperationStatus;\nimport com.azure.core.util.polling.PollResponse;\nimport com.azure.core.util.polling.SyncPoller;\nimport com.azure.identity.DefaultAzureCredentialBuilder;\nimport com.azure.security.keyvault.certificates.models.CertificatePolicy;\nimport com.azure.security.keyvault.certificates.models.SubjectAlternativeNames;\nimport com.azure.security.keyvault.certificates.models.CertificateOperation;\nimport com.azure.security.keyvault.certificates.models.KeyVaultCertificate;\nimport com.azure.security.keyvault.certificates.models.KeyVaultCertificateWithPolicy;\nimport com.azure.security.keyvault.certificates.models.DeletedCertificate;\nimport com.azure.security.keyvault.certificates.models.CertificateKeyCurveName;\n\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Sample demonstrates how to list, recover and purge deleted certificates in a soft-delete enabled key vault.\n */\npublic class ManagingDeletedCertificates {\n    /**\n     * Authenticates with the key vault and shows how to list, recover and purge deleted certificates in a soft-delete enabled key vault.\n     *\n     * @param args Unused. Arguments to the program.\n     * @throws IllegalArgumentException when invalid key vault endpoint is passed.\n     * @throws InterruptedException when the thread is interrupted in sleep mode.\n     */\n    public static void main(String[] args) throws IllegalArgumentException, InterruptedException {\n\n        // NOTE: To manage deleted certificates, your key vault needs to have soft-delete enabled. Soft-delete allows deleted keys\n        // to be retained for a given retention period (90 days). During this period deleted keys can be recovered and if\n        // a key needs to be permanently deleted then it needs to be purged.\n\n        // Instantiate a certificate client that will be used to call the service. Notice that the client is using default Azure\n        // credentials. To make default credentials work, ensure that environment variables 'AZURE_CLIENT_ID',\n        // 'AZURE_CLIENT_KEY' and 'AZURE_TENANT_ID' are set with the service principal credentials.\n        CertificateClient certificateClient = new CertificateClientBuilder()\n            .vaultUrl(\"https://{YOUR_VAULT_NAME}.vault.azure.net\")\n            .credential(new DefaultAzureCredentialBuilder().build())\n            .buildClient();\n\n        // Let's create a self signed certificate valid for 1 year. if the certificate\n        //   already exists in the key vault, then a new version of the certificate is created.\n        CertificatePolicy policy = new CertificatePolicy(\"Self\", \"CN=SelfSignedJavaPkcs12\")\n            .setSubjectAlternativeNames(new SubjectAlternativeNames().setEmails(Arrays.asList(\"wow@gmail.com\")))\n            .setKeyReusable(true)\n            .setKeyCurveName(CertificateKeyCurveName.P_256);\n        Map<String, String> tags = new HashMap<>();\n        tags.put(\"foo\", \"bar\");\n\n        SyncPoller<CertificateOperation, KeyVaultCertificateWithPolicy> certificatePoller = certificateClient.beginCreateCertificate(\"certificateName\", policy, true,  tags);\n        certificatePoller.waitUntil(LongRunningOperationStatus.SUCCESSFULLY_COMPLETED);\n\n        KeyVaultCertificate cert = certificatePoller.getFinalResult();\n\n        // The certificate is no longer needed, need to delete it from the key vault.\n        SyncPoller<DeletedCertificate, Void> deletedCertificatePoller =\n            certificateClient.beginDeleteCertificate(\"certificateName\");\n        // Deleted Certificate is accessible as soon as polling beings.\n        PollResponse<DeletedCertificate> pollResponse = deletedCertificatePoller.poll();\n        System.out.printf(\"Deleted certitifcate with name %s and recovery id %s\", pollResponse.getValue().getName(),\n            pollResponse.getValue().getRecoveryId());\n        deletedCertificatePoller.waitForCompletion();\n        //To ensure certificate is deleted on server side.\n        Thread.sleep(30000);\n\n        // We accidentally deleted the certificate. Let's recover it.\n        // A deleted certificate can only be recovered if the key vault is soft-delete enabled.\n        SyncPoller<KeyVaultCertificateWithPolicy, Void> recoverCertPoller = certificateClient\n            .beginRecoverDeletedCertificate(\"certificateName\");\n        // Recovered certificate is accessible as soon as polling beings\n        PollResponse<KeyVaultCertificateWithPolicy> recoverPollResponse = recoverCertPoller.poll();\n        System.out.printf(\" Recovered Deleted certificate with name %s and id %s\", recoverPollResponse.getValue()\n            .getProperties().getName(), recoverPollResponse.getValue().getProperties().getId());\n        recoverCertPoller.waitForCompletion();\n\n        //To ensure certificate is recovered on server side.\n        Thread.sleep(30000);\n\n        // The certificates are no longer needed, need to delete them from the key vault.\n        deletedCertificatePoller = certificateClient.beginDeleteCertificate(\"certificateName\");\n        // Deleted Certificate is accessible as soon as polling beings.\n        PollResponse<DeletedCertificate> deletePollResponse = deletedCertificatePoller.poll();\n        System.out.printf(\"Deleted certificate with name %s and recovery id %s\", deletePollResponse.getValue().getName(),\n            deletePollResponse.getValue().getRecoveryId());\n        deletedCertificatePoller.waitForCompletion();\n        //To ensure certificate is deleted on server side.\n        Thread.sleep(30000);\n\n        // You can list all the deleted and non-purged certificates, assuming key vault is soft-delete enabled.\n        for (DeletedCertificate deletedCert : certificateClient.listDeletedCertificates()) {\n            System.out.printf(\"Deleted certificate's recovery Id %s\", deletedCert.getRecoveryId());\n        }\n\n        // If the key vault is soft-delete enabled, then for permanent deletion deleted certificate need to be purged.\n        certificateClient.purgeDeletedCertificate(\"certificateName\");\n\n        //To ensure certificate is purged on server side.\n        Thread.sleep(15000);\n    }\n}\n", "--------------------------------------------------------------\n *\n *The MIT License (MIT)\n *\n *Permission is hereby granted, free of charge, to any person obtaining a copy\n *of this software and associated documentation files (the \"Software\"), to deal\n *in the Software without restriction, including without limitation the rights\n *to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *copies of the Software, and to permit persons to whom the Software is\n *furnished to do so, subject to the following conditions:\n *\n *The above copyright notice and this permission notice shall be included in\n *all copies or substantial portions of the Software.\n *\n *THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *THE SOFTWARE.\n *\n */\n\npackage opencraft;\n\nimport java.io.File;\n\nimport org.apache.log4j.BasicConfigurator;\nimport org.apache.log4j.LogManager;\nimport org.apache.log4j.Logger;\n\nimport opencraft.lib.event.packet.Packet;\nimport opencraft.packet.PacketFileStart;\nimport opencraft.packet.c2s.PacketClientInfo;\nimport opencraft.packet.c2s.PacketKeyInput;\nimport opencraft.packet.c2s.PacketPartServer;\nimport opencraft.packet.c2s.PacketPlayerSight;\nimport opencraft.packet.c2s.PacketRequestMod;\nimport opencraft.packet.s2c.PacketBlockMap;\nimport opencraft.packet.s2c.PacketFullChunk;\nimport opencraft.packet.s2c.PacketKeyList;\nimport opencraft.packet.s2c.PacketSendModList;\nimport opencraft.packet.s2c.PacketUpdateBlock;\nimport opencraft.packet.s2c.PacketUpdateObject;\nimport opencraft.packet.s2c.PacketYouDied;\nimport opencraft.server.OpenCraftServer;\nimport opencraft.world.block.Block;\nimport opencraft.world.block.BlockAir;\n\npublic class OpenCraft {\n\t\n\tpublic static final File runDir = new File(\".\");\n\tpublic static final File modDir = new File(runDir, \"mods\");\n\tpublic static final File worldDir = new File(runDir, \"worlds\");\n\tpublic static final File playerDir = new File(worldDir, \"players\");\n\t\n\tpublic static Logger log = LogManager.getLogger(\"[OpenCraft]\");\n\t\n\tpublic static void main(String[] args) {\n\t\tBasicConfigurator.configure();\n\t\tcreateDir();\n\t\tregisterBlock();\n\t\tregisterPacket();\n\t\tOpenCraftServer.instance().start();\n\t}\n\t\n\tprivate static void registerBlock() {\n\t\tBlock.registry.registerBlock(new BlockAir());\n\t}\n\t\n\tprivate static void registerPacket() {\n\t\tPacket.registry.registerPacket(PacketFileStart.class);\n\t\tPacket.registry.registerPacket(PacketClientInfo.class);\n\t\tPacket.registry.registerPacket(PacketKeyInput.class);\n\t\tPacket.registry.registerPacket(PacketPartServer.class);\n\t\tPacket.registry.registerPacket(PacketPlayerSight.class);\n\t\tPacket.registry.registerPacket(PacketRequestMod.class);\n\t\tPacket.registry.registerPacket(PacketBlockMap.class);\n\t\tPacket.registry.registerPacket(PacketFullChunk.class);\n\t\tPacket.registry.registerPacket(PacketKeyList.class);\n\t\tPacket.registry.registerPacket(PacketSendModList.class);\n\t\tPacket.registry.registerPacket(PacketUpdateBlock.class);\n\t\tPacket.registry.registerPacket(PacketUpdateObject.class);\n\t\tPacket.registry.registerPacket(PacketYouDied.class);\n\t}\n\t\n\tprivate static void createDir() {\n\t\tmodDir.mkdirs();\n\t\tworldDir.mkdirs();\n\t\tplayerDir.mkdirs();\n\t}\n}\n", "\u00e1 mundo Java!\\nSegunda linha!\");\n  }\n}\n", "import io.pkts.packet.sip.SipPacket;\nimport io.pkts.protocol.Protocol;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.text.SimpleDateFormat;\n\n/**\n * Represents a captured packet.\n * \n * @author jonas@jonasborjesson.com\n */\npublic interface Packet extends Cloneable {\n\n    /**\n     * The arrival time of this packet in microseconds relative to epoch\n     * (midnight UTC of January 1, 1970).\n     * \n     * Note, since this returns with microseconds precision (which may or may\n     * not be relevant depending on the hardware on which the packet was\n     * captured on) and you wish to format this arrival time into a more human\n     * readable format you could use the {@link SimpleDateFormat} but it can\n     * only handle milliseconds precision (you will have to write your own date\n     * formatter if you want microseconds).\n     * \n     * Here is a snippet illustrating how to turn the arrival time of the packet\n     * into a human readable date\n     * \n     * <pre>\n     * Packet p = ...;\n     * SimpleDateFormat formatter = new SimpleDateFormat(\"yyyy.MM.dd HH:mm:ss.SSS\");\n     * Date date = new Date(p.getArrivalTime() / 1000);\n     * System.out.println(\"Arrival time: \" + formatter.format(date));\n     * </pre>\n     * \n     * Note how an integer devision is performed on the arrival time to\n     * \"cut off\" the microseconds from the time stamp\n     * \n     * @return the arrival time of the packet in microseconds since the start of\n     *         the epoch\n     */\n    long getArrivalTime();\n\n    /**\n     * Calling this method will force the packet to completely parse its data\n     * and check so that all the information conforms to whatever rules this\n     * packet needs to follow. E.g., if this happens to be a SIP packet, then it\n     * will check if it has the mandatory headers etc.\n     * \n     * Some simpler packets, such as the {@link IPPacket}, hardly does anything\n     * in this method but more complex protocols such as SIP (once again), HTTP\n     * etc can spend quite some time verifying everything, which is why you\n     * don't want to do it unless you really have to.\n     * \n     * In general, yajpcap has the philosophy of\n     * \"assume that everything is ok until things blow up and then deal with it\"\n     */\n    void verify();\n\n    /**\n     * Write this packet to the {@link OutputStream}. Typically, the\n     * {@link OutputStream} would be a {@link PcapOutputStream} so when writing\n     * packets to this stream they will still be a valid pcap.\n     * \n     * @param out\n     * @throws IOException\n     */\n    void write(OutputStream out) throws IOException;\n\n    /**\n     * Writes this packet to the {@link OutputStream} with the supplied payload.\n     * You can use this method to e.g. write a raw {@link UDPPacket} to the\n     * stream with this payload. Note, if the {@link UDPPacket} already had a\n     * payload it will be ignored so use this method with care.\n     * \n     * @param out\n     * @param payload\n     * @throws IOException\n     */\n    void write(OutputStream out, Buffer payload) throws IOException;\n\n    Packet clone();\n\n    /**\n     * Check whether this packet contains a particular protocol. This will cause\n     * the packet to examine all the containing packets to check whether they\n     * are indeed the protocol the user asked for.\n     * \n     * @param p\n     * @return\n     * @throws IOException\n     *             in case something goes wrong when framing the rest of the\n     *             protocol stack\n     */\n    boolean hasProtocol(Protocol p) throws IOException;\n\n    /**\n     * Get the protocol of this frame.\n     * \n     * @return\n     */\n    Protocol getProtocol();\n\n    /**\n     * Find the packet for protocol p.\n     * \n     * @param p\n     * @return the packets that encapsulates the protocol or null if this\n     *         protocol doesn't exist\n     * @throws IOException\n     *             in case something goes wrong when framing the rest of the\n     *             protocol stack\n     * @throws PacketParseException if the next packet can't be parsed by the\n     *                              framer\n     */\n    Packet getPacket(Protocol p) throws IOException, PacketParseException;\n\n    /**\n     * Get the name of the packet. Wireshark will give you a short description\n     * of all the known protocols within its \"super\" packet. E.g., if you\n     * \"click\" on the Pcap Frame it will have a field called\n     * \"protocols in frame\" and will display something like\n     * \"eth:ip:udp:sip:sdp\", this function will return a short name like that.\n     * \n     * @return\n     */\n    String getName();\n\n    /**\n     * Get the next frame, or null if there is none. Note, if there isn't\n     * another frame but there is still raw data within this frame, it only\n     * means that we didn't recognize the payload.\n     * \n     * @return\n     * @throws IOException\n     * @throws PacketParseException if the next packet can't be parsed by the\n     *                              framer\n     */\n    Packet getNextPacket() throws IOException, PacketParseException;\n\n    /**\n     * Almost all packets have a parent, which is the encapsulating protocol.\n     * E.g., the parent of a {@link SipPacket} is typically a\n     * {@link TransportPacket} such as {@link UDPPacket} or a {@link TCPPacket}.\n     * The parent of a {@link TransportPacket} is usually a {@link IPPacket} and\n     * so on.\n     * \n     * @return\n     */\n    Packet getParentPacket();\n\n    /**\n     * Get the payload of the frame. If null, then this frame doesn't have any\n     * payload\n     * \n     * @return\n     */\n    Buffer getPayload();\n\n}\n", "\n\t    private String password;\r\n\r\n\t    \r\n\t    private String token ;\r\n\r\n\r\n\r\n\t\tpublic String getUserName() {\r\n\t\t\treturn userName;\r\n\t\t}\r\n\r\n\r\n\r\n\t\tpublic void setUserName(String userName) {\r\n\t\t\tthis.userName = userName;\r\n\t\t}\r\n\r\n\r\n\r\n\t\tpublic String getPassword() {\r\n\t\t\treturn password;\r\n\t\t}\r\n\r\n\r\n\r\n\t\tpublic void setPassword(String password) {\r\n\t\t\tthis.password = password;\r\n\t\t}\r\n\r\n\r\n\r\n\t\tpublic String getToken() {\r\n\t\t\treturn token;\r\n\t\t}\r\n\r\n\r\n\r\n\t\tpublic void setToken(String token) {\r\n\t\t\tthis.token = token;\r\n\t\t}\r\n\t    \r\n\t    \r\n\t    \r\n\t    \r\n}\r\n", "nted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage org.ensor.robots.network.client;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.net.URI;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.TimeUnit;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport org.eclipse.jetty.websocket.WebSocket;\nimport org.eclipse.jetty.websocket.WebSocketClient;\nimport org.eclipse.jetty.websocket.WebSocketClientFactory;\nimport org.json.JSONObject;\n\n/**\n *\n * @author jona\n */\npublic class UpgradeClient implements WebSocket.OnBinaryMessage {\n    \n    private final String mHostname;\n    private final int mPort;\n    private final WebSocketClient mChannelManager;\n    private WebSocket.Connection mConnection;\n    \n    UpgradeClient(final String aHostname, final int aPort) throws Exception {\n        mHostname = aHostname;\n        mPort = aPort;\n        System.out.println(\"New factory\");\n        WebSocketClientFactory fact = new WebSocketClientFactory();\n        System.out.println(\"starting factory\");\n        fact.start();\n        System.out.println(\"New socket client\");\n        mChannelManager = fact.newWebSocketClient();\n    }\n    \n    public void connect() throws Exception {\n        System.out.println(\"open\");\n        Future<WebSocket.Connection> fc = mChannelManager.open(\n                new URI(\n                    \"ws://\" + mHostname + \":\" + mPort + \"/v1/upgrade/\"),\n                this);\n        mConnection = fc.get(10, TimeUnit.SECONDS);\n        System.out.println(\"open done\");\n    }\n\n    public boolean isConnected() {\n        return mConnection != null;\n    }\n    \n    public void uploadFile(File aFile) throws Exception {\n        \n        long fileLength = aFile.length();\n        long fileRead = 0;\n                \n        JSONObject header = new JSONObject();\n        header.put(\"length\", fileLength);\n        \n        FileInputStream fis = new FileInputStream(aFile);\n        \n        byte[] buffer = new byte[1024];\n        \n        while (fileRead < fileLength) {\n            int bytesRead = fis.read(buffer);\n            if (bytesRead > 0) {\n                mConnection.sendMessage(buffer, 0, bytesRead);\n                fileRead += bytesRead;\n            }\n            System.out.println(\"at \" + fileRead + \"/\" + fileLength);\n        }\n        System.out.println(\"done writing\");\n        \n    }\n    \n    public void onMessage(byte[] arg0, int arg1, int arg2) {\n    }\n\n    public void onOpen(Connection cnctn) {\n        try {\n            System.out.println(\"client.onOpen\");\n            mConnection = cnctn;\n        } catch (Exception ex) {\n            Logger.getLogger(UpgradeClient.class.getName()).log(Level.SEVERE, null, ex);\n        }\n    }\n\n    public void onClose(int i, String string) {\n    }\n    \n    public void disconnect() {\n        if (mConnection != null) {\n            mConnection.close();\n        }\n    }\n    \n    \n    public static void main(String [] args) {\n        try {\n            \n            if (args.length < 2) {\n                System.out.println(\"Usage: UpgradeClient hostname port\");\n                System.exit(1);\n            }\n\n            File fileToUpload = new File(\"target/snackbot-1.0-SNAPSHOT-bin.zip\");\n            \n            if (!fileToUpload.exists()) {\n                System.out.println(\"File \" + fileToUpload.getAbsolutePath() + \" does not exist\");\n                System.exit(1);\n            }\n            \n            String hostname = args[0];\n            short port = 8080;\n            if (args.length >= 2) {\n                port = Short.parseShort(args[1]);\n            }\n            System.out.println(\"Upgrading server at \" + hostname + \":\" + port);\n            UpgradeClient uc = new UpgradeClient(hostname, port);\n            uc.connect();\n            if (uc.isConnected()) {\n                uc.uploadFile(fileToUpload);\n            }\n            uc.disconnect();\n            System.exit(0);\n        } catch (Exception ex) {\n            Logger.getLogger(UpgradeClient.class.getName()).log(Level.SEVERE, null, ex);\n            System.exit(1);\n        }\n    }\n    \n}\n", "eclipse.core.resources.ICommand;\nimport org.eclipse.core.resources.IProject;\nimport org.eclipse.core.resources.IProjectDescription;\nimport org.eclipse.core.resources.IResource;\nimport org.eclipse.core.runtime.CoreException;\nimport org.eclipse.core.runtime.PlatformObject;\nimport org.eclipse.jface.action.IAction;\nimport org.eclipse.jface.viewers.ISelection;\nimport org.eclipse.jface.viewers.StructuredSelection;\nimport org.eclipse.swt.widgets.Event;\nimport org.eclipse.ui.IActionDelegate2;\nimport org.eclipse.ui.IObjectActionDelegate;\nimport org.eclipse.ui.IWorkbenchPart;\n\nabstract public class AbstractConvertProject implements IObjectActionDelegate, IActionDelegate2 {\n\tIProject selectedProject;\n\n\t@Override\n\tpublic void setActivePart(IAction action, IWorkbenchPart targetPart) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\tpublic static final String builderName=\"hu.rtemplate.Builder\";\n\tabstract void afterConvert() throws CoreException;\n\t@Override\n\tpublic void run(IAction action) {\n\t\ttry {\n\t\t\tIProjectDescription pd=selectedProject.getDescription();\n\t\t\tICommand[] newBuildSpec;\n\t\t\tICommand[] oldBuildSpec=pd.getBuildSpec();;\n\t\t\tif(toTemplate())\n\t\t\t{\n\t\t\t\tnewBuildSpec=new ICommand[oldBuildSpec.length+1];\n\t\t\t\tfor(int i=0;i<oldBuildSpec.length;++i)\n\t\t\t\t{\n\t\t\t\t\tnewBuildSpec[i+1]=oldBuildSpec[i];\n\t\t\t\t}\n\t\t\t\tICommand bc=pd.newCommand();\n\t\t\t\tbc.setBuilderName(builderName);\n\t\t\t\tnewBuildSpec[0]=bc;\n\t\t\t}else\n\t\t\t{\n\t\t\t\tList<ICommand> newList=new ArrayList<ICommand>();\n\t\t\t\tfor(int i=0;i<oldBuildSpec.length;++i)\n\t\t\t\t{\n\t\t\t\t\tICommand c=oldBuildSpec[i];\n\t\t\t\t\tif(!builderName.equals(c.getBuilderName()))\n\t\t\t\t\t{\n\t\t\t\t\t\tnewList.add(c);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tnewBuildSpec=newList.toArray(new ICommand[]{});\n\t\t\t}\n\t\t\tpd.setBuildSpec(newBuildSpec);\n\t\t\tselectedProject.setDescription(pd, IResource.FORCE, null);\n\t\t\tafterConvert();\n\t\t} catch (CoreException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\tabstract boolean toTemplate();\n\t@Override\n\tpublic void selectionChanged(IAction action, ISelection selection) {\n\t\tObject o = ((StructuredSelection) selection).getFirstElement();\n\t\tboolean enabled=false;\n\t\tif (o instanceof PlatformObject) {\n\t\t\tPlatformObject po = (PlatformObject) o;\n\t\t\tIProject project = (IProject) po.getAdapter(IProject.class);\n\t\t\tif (project != null) {\n\t\t\t\tthis.selectedProject=project;\n\t\t\t\tenabled=toTemplate();\n\t\t\t\ttry\n\t\t\t\t{\n\t\t\t\t\tfor(ICommand c:selectedProject.getDescription().getBuildSpec())\n\t\t\t\t\t{\n\t\t\t\t\t\tif(c.getBuilderName().equals(builderName))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tenabled=!toTemplate();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}catch(Exception e){}\n\t\t\t}\n\t\t}\n\t\taction.setEnabled(enabled);\n\t}\n\n\t@Override\n\tpublic void dispose() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic void init(IAction action) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n\t@Override\n\tpublic void runWithEvent(IAction action, Event event) {\n\t\trun(action);\n\t}\n\n}\n", "se;\nimport io.mewbase.server.Mewblet;\n\n/**\n * Created by tim on 16/12/16.\n */\npublic class ShoppingBasketMewblet implements Mewblet {\n\n    @Override\n    public void setup(Mewbase mewbase) throws Exception {\n\n        mewbase.createChannel(\"orders\").get();\n        mewbase.createBinder(\"baskets\").get();\n\n        mewbase.buildProjection(\"maintain_basket\")                                // projection name\n                .projecting(\"orders\")                                           // channel name\n                .filteredBy(ev -> ev.getString(\"eventType\").equals(\"add_item\")) // event filter\n                .onto(\"baskets\")                                                // binder name\n                .identifiedBy(ev -> ev.getString(\"basketID\"))                   // document id selector; how to obtain the doc id from the event bson\n                .as((basket, del) ->                                            // projection function\n                        BsonPath.add(basket, del.event().getInteger(\"quantity\"), \"products\", del.event().getString(\"productID\")))\n                .create();\n\n    }\n}\n", "ss Main {\r\n\tpublic static void main(String[] args) {\r\n\t\tScanner scan = new Scanner(System.in);\r\n\r\n\t\tSystem.out.println(\"Informe o nome do arquivo a ser acessado: \");\r\n\t\tFile arq = new File(scan.nextLine());\r\n\r\n\t\tif (arq.exists()) {\r\n\t\t\tint vogalA = 0, vogalE = 0, vogalI = 0, vogalO = 0, vogalU = 0;\r\n\t\t\ttry {\r\n\t\t\t\tScanner txt = new Scanner(arq);\r\n\r\n\t\t\t\twhile (txt.hasNextLine()) {\r\n\t\t\t\t\tString linha = txt.nextLine();\r\n\r\n\t\t\t\t\tvogalA += linha.length() - linha.toUpperCase().replace(\"A\", \"\").length();\r\n\t\t\t\t\tvogalE += linha.length() - linha.toUpperCase().replace(\"E\", \"\").length();\r\n\t\t\t\t\tvogalI += linha.length() - linha.toUpperCase().replace(\"I\", \"\").length();\r\n\t\t\t\t\tvogalO += linha.length() - linha.toUpperCase().replace(\"O\", \"\").length();\r\n\t\t\t\t\tvogalU += linha.length() - linha.toUpperCase().replace(\"U\", \"\").length();\r\n\t\t\t\t}\r\n\r\n\t\t\t\tSystem.out.println(\"Total de A: \" + vogalA);\r\n\t\t\t\tSystem.out.println(\"Total de E: \" + vogalE);\r\n\t\t\t\tSystem.out.println(\"Total de I: \" + vogalI);\r\n\t\t\t\tSystem.out.println(\"Total de O: \" + vogalO);\r\n\t\t\t\tSystem.out.println(\"Total de U: \" + vogalU);\r\n\t\t\t} catch (FileNotFoundException e) {\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tSystem.out.println(\"O arquivo informado n\u00e3o existe!\");\r\n\t\t}\r\n\t}\r\n}\r\n", "ort java.lang.reflect.Field;\nimport java.util.Date;\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * https://raw.githubusercontent.com/gunjanvishwakarma/c3p0-connection-leak-checker/dev/connection-leak-using-btrace/\n *\n * @author yuweijun 2016-09-29\n */\n@BTrace(unsafe = true)\npublic class C3P0ConnectionBtrace {\n\n    private Map<Integer, String> leakInfo = new HashMap<Integer, String>();\n\n    @OnMethod(clazz = \"com.mchange.v2.resourcepool.BasicResourcePool\", method = \"checkoutResource\")\n    @Sampled(kind = Sampled.Sampler.Const, mean = 100)\n    void func(@Self Object obj) {\n\n        @SuppressWarnings(\"unchecked\")\n        HashMap<Object, Object> managedMap = (HashMap<Object, Object>) BTraceUtils.get(BTraceUtils.field(\"com.mchange.v2.resourcepool.BasicResourcePool\", \"managed\"), obj);\n        for (Map.Entry<Object, Object> entry : managedMap.entrySet()) {\n            Object pc = entry.getValue();\n            String oldPc = leakInfo.get(pc.hashCode());\n            long last_checkin_time = (Long) BTraceUtils.get(BTraceUtils.field(\"com.mchange.v2.resourcepool.BasicResourcePool$PunchCard\", \"last_checkin_time\"), pc);\n            long checkout_time = (Long) BTraceUtils.get(BTraceUtils.field(\"com.mchange.v2.resourcepool.BasicResourcePool$PunchCard\", \"checkout_time\"), pc);\n            if (last_checkin_time <= checkout_time) {\n                Exception checkoutStackTraceException = (Exception) BTraceUtils.get(BTraceUtils.field(\"com.mchange.v2.resourcepool.BasicResourcePool$PunchCard\", \"checkoutStackTraceException\"), pc);\n                if (oldPc == null && checkoutStackTraceException != null) {\n                    leakInfo.put(\n                            pc.hashCode(),\n                            \"checkout_time==>  \" + new Date(checkout_time).toString() + \"  last_checkin_time==> \" + new Date(last_checkin_time).toString() + \" \" + checkoutStackTraceException);\n                }\n            } else {\n                if (oldPc != null) {\n                    leakInfo.remove(pc.hashCode());\n                }\n            }\n        }\n    }\n\n    @OnMethod(clazz = \"com.mchange.v2.resourcepool.BasicResourcePool\", method = \"checkoutResource\", location = @Location(value = Kind.RETURN, where = Where.BEFORE))\n    void func1(@Self Object basicResPool, @Return Object connection) throws IllegalArgumentException, IllegalAccessException, NoSuchFieldException, SecurityException, ClassNotFoundException {\n        @SuppressWarnings(\"unchecked\")\n        HashMap<Object, Object> managedMap = (HashMap<Object, Object>) BTraceUtils.get(BTraceUtils.field(\"com.mchange.v2.resourcepool.BasicResourcePool\", \"managed\"), basicResPool);\n        Object obj = managedMap.get(connection);\n        Object punchCard = Class.forName(\"com.mchange.v2.resourcepool.BasicResourcePool$PunchCard\").cast(obj);\n        Field field = punchCard.getClass().getDeclaredField(\"checkoutStackTraceException\");\n        field.set(punchCard, new Exception(\"c3p0 connection checkout stack trace\"));\n    }\n\n    @OnTimer(30000)\n    public void ontime() {\n        BTraceUtils.println(\"CHECKING LEAK\");\n        if (leakInfo.size() == 0) {\n            BTraceUtils.println(\"NO LEAK\");\n        } else {\n            BTraceUtils.println(\"LEAK IDENTIFIED\");\n            BTraceUtils.println(leakInfo);\n        }\n\n    }\n}\n", "ter;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.TextView;\nimport android.widget.Toast;\nimport java.util.regex.Pattern;\nimport java.util.regex.Matcher;\n\npublic class AndroidBluetooth extends Activity {\n\n    String selected_item_address;\n\n    private static final int REQUEST_ENABLE_BT = 1;\n    private static final int REQUEST_PAIRED_DEVICE = 2;\n\n    /** Called when the activity is first created. */\n    Button OnButton;\n    Button OffButton;\n    Button VisibleButton;\n    Button btnListPairedDevices;\n    TextView stateBluetooth;\n    BluetoothAdapter bluetoothAdapter;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.main);\n\n        OnButton = (Button)findViewById(R.id.bluetoothOnButton);\n        OnButton.setOnClickListener(btOnButtonOnClickListener);\n        OffButton = (Button)findViewById(R.id.bluetoothOffButton);\n        OffButton.setOnClickListener(btOffButtonOnClickListener);\n        VisibleButton = (Button)findViewById(R.id.bluetoothVisibleButton);\n        VisibleButton.setOnClickListener(btVisibleButtonOnClickListener);\n        btnListPairedDevices = (Button)findViewById(R.id.listpaireddevices);\n        btnListPairedDevices.setOnClickListener(btnListPairedDevicesOnClickListener);\n\n        stateBluetooth = (TextView)findViewById(R.id.bluetoothstate);\n        bluetoothAdapter = BluetoothAdapter.getDefaultAdapter();\n\n        CheckBlueToothState();\n    }\n\n    private void CheckBlueToothState(){\n        if (bluetoothAdapter == null){\n            stateBluetooth.setText(\"Bluetooth NOT support\");\n        }else{\n            if (bluetoothAdapter.isEnabled()){\n                if(bluetoothAdapter.isDiscovering()){\n                    stateBluetooth.setText(\"Bluetooth is currently in device discovery process.\");\n                }else{\n                    stateBluetooth.setText(\"Bluetooth is Enabled.\");\n                    btnListPairedDevices.setEnabled(true);\n                }\n            } else {\n                stateBluetooth.setText(\"Bluetooth is NOT Enabled!\");\n                Intent enableBtIntent = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\n                startActivityForResult(enableBtIntent, REQUEST_ENABLE_BT);\n            }\n        }\n    }\n\n\n    private Button.OnClickListener btnListPairedDevicesOnClickListener\n            = new Button.OnClickListener(){\n        @Override\n        public void onClick(View arg0) {\n            // TODO Auto-generated method stub\n            Intent intent = new Intent();\n            intent.setClass(AndroidBluetooth.this, ListPairedDevicesActivity.class);\n            Toast.makeText(getApplicationContext(),\"Select a Device for Details\\n\"+\n                    \"   or to test a connection.\",\n                    Toast.LENGTH_SHORT).show();\n            startActivityForResult(intent, REQUEST_PAIRED_DEVICE);\n        }\n    };\n\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent data) {\n        // TODO Auto-generated method stub\n        if(requestCode == REQUEST_ENABLE_BT){\n            CheckBlueToothState();\n        }if (requestCode == REQUEST_PAIRED_DEVICE){\n            if(resultCode == RESULT_OK){\n                if(!bluetoothAdapter.isEnabled()) {\n                    CheckBlueToothState();\n                }\n            }\n        }\n    }\n\n    private Button.OnClickListener btOnButtonOnClickListener = new Button.OnClickListener(){\n        @Override\n        public void onClick(View arg0) {\n            if (!bluetoothAdapter.isEnabled()) {\n                Intent turnOn = new Intent(BluetoothAdapter.ACTION_REQUEST_ENABLE);\n                startActivityForResult(turnOn, 0);\n                Toast.makeText(getApplicationContext(),\"Bluetooth Enabled\"\n                        ,Toast.LENGTH_SHORT).show();\n                CheckBlueToothState();\n            }\n            else{\n                Toast.makeText(getApplicationContext(),\"Bluetooth already Enabled\",\n                        Toast.LENGTH_SHORT).show();\n            }\n        }\n    };\n    private Button.OnClickListener btOffButtonOnClickListener = new Button.OnClickListener(){\n        @Override\n        public void onClick(View arg0) {\n            //turning bluetooth off this way requires BLUETOOTH_ADMIN permissions set in the AndroidManifest\n            bluetoothAdapter.disable();\n            Toast.makeText(getApplicationContext(),\"Bluetooth Disabled\" ,\n                    Toast.LENGTH_SHORT).show();\n            CheckBlueToothState();\n        }\n    };\n    private Button.OnClickListener btVisibleButtonOnClickListener = new Button.OnClickListener(){\n        @Override\n        public void onClick(View arg0) {\n            Intent getVisible = new Intent(BluetoothAdapter.ACTION_REQUEST_DISCOVERABLE);\n            startActivityForResult(getVisible, 0);\n        }\n    };\n}", "SecureRandom;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.ExecutionException;\n\nimport javax.annotation.Nullable;\n\nimport org.bitcoinj.core.Address;\nimport org.bitcoinj.core.Coin;\nimport org.bitcoinj.core.InsufficientMoneyException;\nimport org.bitcoinj.core.NetworkParameters;\nimport org.bitcoinj.core.Wallet;\nimport org.bitcoinj.crypto.DeterministicKey;\nimport org.bitcoinj.params.TestNet3Params;\nimport org.bitcoinj.signers.TransactionSigner;\nimport org.bitcoinj.wallet.DeterministicSeed;\nimport org.bitcoinj.wallet.DeterministicKeyChain;\nimport org.junit.After;\nimport org.junit.Test;\n\nimport tools.crypto.PluggableTransactionSigner;\n\npublic class HDWalletKit2Test {\n\tprivate HDWalletKit2 walletKit_1;\n\tprivate HDWalletKit2 walletKit_2;\n\tprivate String testDirectory = \"testFiles/tmp/\";\n\tprivate String filePrefix = \"speciebox-testnet-wallet_\";\n\t\n\t//These are wonderful tools provided by bitcoinj for this very purpose\n\tprivate NetworkParameters params = TestNet3Params.get();\n\n\t//@Test\n\tpublic void testSetupHDWalletandReload() throws Exception{\n\t\tString name = filePrefix+System.currentTimeMillis();\n\t\tFile dir = new File(testDirectory);\n\t\twalletKit_1 = new HDWalletKit2(params, dir, name, 1);\n\t\twalletKit_1.startAsync();\n\t\twalletKit_1.awaitRunning();\n\t\t\n        assertTrue(walletKit_1.getSigners().size() == 1);\n        \n        int tSigners = walletKit_1.getSigners().size();\n        DeterministicKey watch1 = walletKit_1.wallet().getWatchingKey();\n        \n\t\twalletKit_1.stopAsync();\n\t\twalletKit_1.awaitTerminated();\n        \n\t\tSystem.out.println(\"shutdown wallet 1 loading wallet 2\");\n\t\t\n\t\twalletKit_2 = new HDWalletKit2(params, dir, name, 1);\n\t\tassertTrue(walletKit_2.RELOAD);\n\t\t\n\t\twalletKit_2.startAsync();\n\t\twalletKit_2.awaitRunning();\n\t\t\n\t\tDeterministicKey watch2 = walletKit_2.wallet().getWatchingKey();\n\t\t\n\t\tassertEquals(tSigners, walletKit_2.getSigners().size());\n\t\tassertEquals(watch1, watch2);\n\t\twalletKit_2.stopAsync();\n\t\twalletKit_2.awaitTerminated();\n\t}\n\t\n\t@Test\n\tpublic void testSetupHDWalletAndAddWatchingKey() throws Exception{\n\t\twalletKit_1 = new HDWalletKit2(params, new File(testDirectory), filePrefix+System.currentTimeMillis(), 2);\n\t\twalletKit_1.startAsync();\n\t\twalletKit_1.awaitRunning();\n\t\t\n\t\tassertTrue(walletKit_1.getThreshold() == 2);\n        assertTrue(walletKit_1.getSigners().size() == 1);\n        \n\n        walletKit_2 = new HDWalletKit2(params, new File(testDirectory), filePrefix+System.currentTimeMillis(), 2);\n\t\twalletKit_2.startAsync();\n\t\twalletKit_2.awaitRunning();\n        \n        DeterministicKey wKey = DeterministicKey.deserializeB58(null, walletKit_2.wallet().getWatchingKey().serializePubB58());\n\t\twalletKit_1.addPairedWallet(\"description\", new PluggableTransactionSigner(wKey), true);\n        assertTrue(walletKit_1.getSigners().size() == 2);\n        Address a = walletKit_1.wallet().freshReceiveAddress();\n        System.out.println(\"freshReceiveAddress() : \" + a.hashCode());\n        assertTrue(a.isP2SHAddress());\n\t\twalletKit_1.stopAsync();\n\t\twalletKit_2.stopAsync();\n\t\twalletKit_1.awaitTerminated();\n\t\twalletKit_2.awaitTerminated();\n\t}\n\n\tpublic void simpleSend (Address toAddress, Coin value){\n\t\ttry {\n            Wallet.SendResult result = walletKit_2.wallet().sendCoins(walletKit_2.peerGroup(), toAddress, value);\n            result.broadcastComplete.get();\n            System.out.println(\"Coins sent. Transaction hash: \" + result.tx.getHashAsString());\n        } catch (InsufficientMoneyException e) {\n            System.out.println(\"Not enough coins in your wallet, \" + e.missing.getValue() + \" satoshis are missing (including fees)\");\n        } catch (InterruptedException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t} catch (ExecutionException e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\t@After\n\tpublic void cleanup(){\n\t\tFile dir = new File(testDirectory);\n\t    assertTrue(dir.isDirectory());\n\t    for (File file:dir.listFiles()) {\n\t        file.delete();\n\t    }\n\t}\n\n}\n\n", ".v7.app.AppCompatActivity;\nimport android.view.View;\nimport android.widget.ArrayAdapter;\nimport android.widget.Button;\nimport android.widget.Spinner;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.example.cardgame.cardgame.R;\nimport com.example.cardgame.cardgame.helper.Events;\nimport com.parse.ParseException;\nimport com.parse.ParseObject;\nimport com.parse.ParseRelation;\nimport com.parse.ParseUser;\nimport com.parse.SaveCallback;\nimport com.rengwuxian.materialedittext.MaterialEditText;\n\nimport de.greenrobot.event.EventBus;\n\npublic class createApptActivity extends AppCompatActivity {\n\n    //Creating a new appointment\n    private MaterialEditText title, detail, creator, location, capacity, phone, email;\n    private Spinner month, day, hour, minute;\n    private Button submit;\n\n    private Events.JoinedEvent joinedEvent = new Events.JoinedEvent();\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_create_appt);\n\n        setupUi();\n    }\n\n\n    private void setupUi() {\n        month = (Spinner) findViewById(R.id.month);\n        day = (Spinner) findViewById(R.id.day);\n        hour = (Spinner) findViewById(R.id.hour);\n        minute = (Spinner) findViewById(R.id.minute);\n\n        ArrayAdapter<CharSequence> adapter = ArrayAdapter.createFromResource(this,\n                R.array.months, android.R.layout.simple_spinner_item);\n        ArrayAdapter<CharSequence> adapter1 = ArrayAdapter.createFromResource(this,\n                R.array.days, android.R.layout.simple_spinner_item);\n        ArrayAdapter<CharSequence> adapter2 = ArrayAdapter.createFromResource(this,\n                R.array.hours, android.R.layout.simple_spinner_item);\n        ArrayAdapter<CharSequence> adapter3 = ArrayAdapter.createFromResource(this,\n                R.array.minutes, android.R.layout.simple_spinner_item);\n\n        adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        month.setAdapter(adapter);\n\n        adapter1.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        day.setAdapter(adapter1);\n\n        adapter2.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        hour.setAdapter(adapter2);\n\n        adapter3.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);\n        minute.setAdapter(adapter3);\n\n        title = (MaterialEditText) findViewById(R.id.title);\n        detail = (MaterialEditText) findViewById(R.id.detail);\n        creator = (MaterialEditText) findViewById(R.id.creator);\n        location = (MaterialEditText) findViewById(R.id.location);\n        capacity = (MaterialEditText) findViewById(R.id.capacity);\n        phone = (MaterialEditText) findViewById(R.id.phone);\n        email = (MaterialEditText) findViewById(R.id.email);\n\n        submit = (Button) findViewById(R.id.submit);\n        submit.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                if (!hasEmpty()) {\n                    submit.setEnabled(false);\n                    final ParseObject parseObject = new ParseObject(\"Appointment\");\n                    parseObject.put(\"title\", getString(title));\n                    parseObject.put(\"detail\", getString(detail));\n                    parseObject.put(\"creator\", getString(creator));\n                    parseObject.put(\"location\", getString(location));\n                    parseObject.put(\"capacity\", getString(capacity));\n                    parseObject.put(\"seats\", Integer.parseInt(getString(capacity)));\n                    parseObject.put(\"phone\", getString(phone));\n                    parseObject.put(\"email\", getString(email));\n                    parseObject.put(\"month\", month.getSelectedItem().toString());\n                    parseObject.put(\"day\", day.getSelectedItem().toString());\n                    parseObject.put(\"hour\", hour.getSelectedItem().toString());\n                    parseObject.put(\"minute\", minute.getSelectedItem().toString());\n                    parseObject.saveInBackground(new SaveCallback() {\n                        @Override\n                        public void done(ParseException e) {\n                            submit.setEnabled(true);\n                            if (e == null) {\n                                showToast(\"Created Successfully\");\n                                ParseUser user = ParseUser.getCurrentUser();\n                                ParseRelation<ParseObject> relation = user.getRelation(\"joined\");\n                                relation.add(parseObject);\n                                user.saveInBackground(new SaveCallback() {\n                                    @Override\n                                    public void done(ParseException e) {\n                                        if (e == null) {\n                                            parseObject.increment(\"seats\", -1); // decrease available seats\n                                            parseObject.saveInBackground(new SaveCallback() {\n                                                @Override\n                                                public void done(ParseException e) {\n                                                    if (e == null) {\n                                                        EventBus.getDefault().post(joinedEvent);\n                                                    }\n                                                }\n                                            });\n                                        } else {\n                                            showToast(\"error occurs, retry\");\n                                        }\n                                    }\n                                });\n                                finish();\n                            } else {\n                                showToast(\"Created fail\");\n                            }\n                        }\n                    });\n                }\n            }\n        });\n    }\n\n    private boolean hasEmpty() {\n        boolean empty = getString(title).isEmpty();\n        empty |= getString(detail).isEmpty();\n        empty |= getString(creator).isEmpty();\n        empty |= getString(location).isEmpty();\n        empty |= getString(capacity).isEmpty();\n        empty |= getString(phone).isEmpty();\n        empty |= getString(email).isEmpty();\n        return empty;\n    }\n\n    private String getString(MaterialEditText editText) {\n        return editText.getText().toString().trim();\n    }\n\n    private void showToast(String string) {\n        Toast.makeText(this, string, Toast.LENGTH_LONG).show();\n    }\n}\n", "nnection;\nimport com.rethinkdb.net.Cursor;\nimport gg.octave.bot.db.guilds.GuildData;\nimport gg.octave.bot.db.guilds.UserData;\nimport gg.octave.bot.db.premium.PremiumGuild;\nimport gg.octave.bot.db.premium.PremiumUser;\nimport org.redisson.Redisson;\nimport org.redisson.api.RedissonClient;\nimport org.redisson.config.Config;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport redis.clients.jedis.JedisPool;\n\nimport javax.annotation.Nullable;\nimport java.util.List;\n\nimport static com.rethinkdb.RethinkDB.r;\n\npublic class Database {\n    private static final Logger LOG = LoggerFactory.getLogger(\"Database\");\n    private final Connection conn;\n    private static JedisPool defaultJedisPool = new JedisPool(\"localhost\", 6379);\n    private Config config = new Config();\n    private RedissonClient redisson;\n\n    public Database(String name) {\n        config.useSingleServer().setAddress(\"redis://127.0.0.1:6379\");\n        redisson = Redisson.create(config);\n\n        Connection conn = null;\n        try {\n            Connection.Builder builder = r.connection().hostname(\"localhost\").port(28015);\n            // potential spot for authentication\n            conn = builder.connect();\n            if (r.dbList().<List<String>>run(conn).contains(name)) {\n                LOG.info(\"Connected to database.\");\n                conn.use(name);\n            } else {\n                LOG.info(\"Rethink Database `\" + name + \"` is not present. Closing connection.\");\n                close();\n                System.exit(0);\n            }\n        } catch (ReqlDriverError e) {\n            LOG.error(\"Rethink Database connection failed.\", e);\n            System.exit(0);\n        }\n        this.conn = conn;\n    }\n\n    public Connection getConn() {\n        return conn;\n    }\n\n    public boolean isOpen() {\n        return conn != null && conn.isOpen();\n    }\n\n    public void close() {\n        conn.close();\n    }\n\n    @Nullable\n    public GuildData getGuildData(String id) {\n        return get(\"guilds_v2\", id, GuildData.class);\n    }\n\n    @Nullable\n    public PremiumKey getPremiumKey(String id) {\n        return get(\"keys\", id, PremiumKey.class);\n    }\n\n    public UserData getUserData(String id) {\n        return get(\"users\", id, UserData.class);\n    }\n\n    @Nullable\n    public PatreonEntry getPatreonEntry(String id) {\n        return get(\"patreon\", id, PatreonEntry.class);\n    }\n\n    public boolean hasPremiumUser(String id) {\n        return isOpen() ? r.table(\"premiumusers\").get(id).coerceTo(\"bool\").run(conn) : false;\n    }\n\n    public PremiumUser getPremiumUser(String id) {\n        return !isOpen() ? null : r.table(\"premiumusers\")\n                .get(id)\n                .default_(r.hashMap(\"id\", id).with(\"pledgeAmount\", \"0.0\"))\n                .run(conn, PremiumUser.class);\n    }\n\n    public List<PremiumUser> getPremiumUsers() {\n        if (!isOpen()) {\n            return List.of();\n        }\n\n        Cursor<PremiumUser> cursor = r.table(\"premiumusers\").run(conn, PremiumUser.class);\n        return cursor.toList();\n    }\n\n    @Nullable\n    public PremiumGuild getPremiumGuild(String id) {\n        return get(\"premiumguilds\", id, PremiumGuild.class);\n    }\n\n    @Nullable\n    public Cursor<PremiumGuild> getPremiumGuilds(String id) {\n        return isOpen()\n                ? r.table(\"premiumguilds\").filter(guild -> guild.g(\"redeemer\").eq(id)).run(conn, PremiumGuild.class)\n                : null;\n    }\n\n    @Nullable\n    public <T> T get(String table, String id, Class<T> cls) {\n        return isOpen() ? r.table(table).get(id).run(conn, cls) : null;\n    }\n\n    public static JedisPool getDefaultJedisPool() {\n        return defaultJedisPool;\n    }\n\n    public RedissonClient getRedisson() {\n        return redisson;\n    }\n}\n", "er one or more contributor license agreements.  See the \n * NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The UCAID licenses this file to You under the Apache \n * License, Version 2.0 (the \"License\"); you may not use this file except in \n * compliance with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.opensaml.xml.security.credential;\n\n/**\n * Marker interface for implementations which hold information specific to a a particular context within \n * which a {@link CredentialResolver} resolves a {@link Credential}.\n */\npublic interface CredentialContext {\n\n}\n", " (C) 2015  Pcap4J.org\n  _##\n  _##########################################################################\n*/\n\npackage org.pcap4j.packet;\n\nimport static org.pcap4j.util.ByteArrays.*;\nimport java.nio.ByteOrder;\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.pcap4j.packet.factory.PacketFactories;\nimport org.pcap4j.packet.namednumber.ProtocolFamily;\nimport org.pcap4j.util.ByteArrays;\n\n/**\n *\n * @see <a href=\"http://www.tcpdump.org/linktypes.html\">Description of DLT_NULL in a Tcpdump document</a>\n * @author Kaito Yamada\n * @since pcap4j 1.5.0\n */\npublic final class BsdLoopbackPacket extends AbstractPacket {\n\n  /**\n   *\n   */\n  private static final long serialVersionUID = 5348192606048946251L;\n\n  private final BsdLoopbackHeader header;\n  private final Packet payload;\n\n  /**\n   * A static factory method.\n   * This method validates the arguments by {@link ByteArrays#validateBounds(byte[], int, int)},\n   * which may throw exceptions undocumented here.\n   *\n   * @param rawData rawData\n   * @param offset offset\n   * @param length length\n   * @return a new BsdLoopbackPacket object.\n   * @throws IllegalRawDataException if parsing the raw data fails.\n   */\n  public static BsdLoopbackPacket newPacket(\n    byte[] rawData, int offset, int length\n  ) throws IllegalRawDataException {\n    ByteArrays.validateBounds(rawData, offset, length);\n    return new BsdLoopbackPacket(rawData, offset, length);\n  }\n\n  private BsdLoopbackPacket(\n    byte[] rawData, int offset, int length\n  ) throws IllegalRawDataException {\n    this.header = new BsdLoopbackHeader(rawData, offset, length);\n\n    int payloadLength = length - header.length();\n    if (payloadLength > 0) {\n      this.payload\n        = PacketFactories.getFactory(Packet.class, ProtocolFamily.class)\n            .newInstance(rawData, offset + header.length(), payloadLength, header.getProtocolFamily());\n    }\n    else {\n      this.payload = null;\n    }\n  }\n\n  private BsdLoopbackPacket(Builder builder) {\n    if (\n         builder == null\n      || builder.protocolFamily == null\n    ) {\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"builder: \").append(builder)\n        .append(\" builder.packetType: \").append(builder.protocolFamily);\n      throw new NullPointerException(sb.toString());\n    }\n\n    this.payload = builder.payloadBuilder != null ? builder.payloadBuilder.build() : null;\n    this.header = new BsdLoopbackHeader(builder);\n  }\n\n  @Override\n  public BsdLoopbackHeader getHeader() {\n    return header;\n  }\n\n  @Override\n  public Packet getPayload() {\n    return payload;\n  }\n\n  @Override\n  public Builder getBuilder() {\n    return new Builder(this);\n  }\n\n  /**\n   * @author Kaito Yamada\n   * @since pcap4j 1.5.0\n   */\n  public static final class Builder extends AbstractBuilder {\n\n    private ProtocolFamily protocolFamily;\n    private Packet.Builder payloadBuilder;\n\n    /**\n     *\n     */\n    public Builder() {}\n\n    private Builder(BsdLoopbackPacket packet)  {\n      this.protocolFamily = packet.header.protocolFamily;\n      this.payloadBuilder = packet.payload != null ? packet.payload.getBuilder() : null;\n    }\n\n    /**\n     *\n     * @param protocolFamily protocolFamily\n     * @return this Builder object for method chaining.\n     */\n    public Builder protocolFamily(ProtocolFamily protocolFamily) {\n      this.protocolFamily = protocolFamily;\n      return this;\n    }\n\n    @Override\n    public Builder payloadBuilder(Packet.Builder payloadBuilder) {\n      this.payloadBuilder = payloadBuilder;\n      return this;\n    }\n\n    @Override\n    public Packet.Builder getPayloadBuilder() {\n      return payloadBuilder;\n    }\n\n    @Override\n    public BsdLoopbackPacket build() {\n      return new BsdLoopbackPacket(this);\n    }\n\n  }\n\n  /**\n   * @author Kaito Yamada\n   * @since pcap4j 1.5.0\n   */\n  public static final class BsdLoopbackHeader extends AbstractHeader {\n\n    /*\n     * BSD loopback encapsulation; the link layer header is a 4-byte field,\n     * in host byte order, containing a PF_ value from socket.h for the\n     * network-layer protocol of the packet.\n     * Note that ``host byte order'' is the byte order of the machine\n     * on which the packets are captured, and the PF_ values are for the\n     * OS of the machine on which the packets are captured; if a live capture\n     * is being done, ``host byte order'' is the byte order of the machine\n     * capturing the packets, and the PF_ values are those of the OS of the\n     * machine capturing the packets, but if a ``savefile'' is being read,\n     * the byte order and PF_ values are not necessarily those of the\n     * machine reading the capture file.\n     */\n\n    /**\n     *\n     */\n    private static final long serialVersionUID = -1053845855337317937L;\n\n    private static final int PROTOCOL_FAMILY_OFFSET\n      = 0;\n    private static final int PROTOCOL_FAMILY_SIZE\n      = INT_SIZE_IN_BYTES;\n    private static final int BSD_LOOPBACK_HEADER_SIZE\n      = PROTOCOL_FAMILY_OFFSET + PROTOCOL_FAMILY_SIZE;\n\n    private final ProtocolFamily protocolFamily;\n\n    private BsdLoopbackHeader(\n      byte[] rawData, int offset, int length\n    ) throws IllegalRawDataException {\n      if (length < BSD_LOOPBACK_HEADER_SIZE) {\n        StringBuilder sb = new StringBuilder(200);\n        sb.append(\"The data is too short to build a BSD loopback header(\")\n          .append(BSD_LOOPBACK_HEADER_SIZE)\n          .append(\" bytes). data: \")\n          .append(ByteArrays.toHexString(rawData, \" \"))\n          .append(\", offset: \")\n          .append(offset)\n          .append(\", length: \")\n          .append(length);\n        throw new IllegalRawDataException(sb.toString());\n      }\n\n      this.protocolFamily\n        = ProtocolFamily.getInstance(\n            ByteArrays.getInt(\n              rawData,\n              PROTOCOL_FAMILY_OFFSET + offset,\n              ByteOrder.nativeOrder()\n            )\n          );\n    }\n\n    private BsdLoopbackHeader(Builder builder) {\n      this.protocolFamily = builder.protocolFamily;\n    }\n\n    /**\n     * @return protocolFamily\n     */\n    public ProtocolFamily getProtocolFamily() {\n      return protocolFamily;\n    }\n\n    @Override\n    protected List<byte[]> getRawFields() {\n      List<byte[]> rawFields = new ArrayList<byte[]>();\n      rawFields.add(ByteArrays.toByteArray(protocolFamily.value(), ByteOrder.nativeOrder()));\n      return rawFields;\n    }\n\n    @Override\n    public int length() {\n      return BSD_LOOPBACK_HEADER_SIZE;\n    }\n\n    @Override\n    protected String buildString() {\n      StringBuilder sb = new StringBuilder();\n      String ls = System.getProperty(\"line.separator\");\n\n      sb.append(\"[BSD Loopback Header (\")\n        .append(length())\n        .append(\" bytes)]\")\n        .append(ls);\n      sb.append(\"  Protocol Family: \")\n        .append(protocolFamily)\n        .append(ls);\n\n      return sb.toString();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n      if (obj == this) { return true; }\n      if (!this.getClass().isInstance(obj)) { return false; }\n\n      BsdLoopbackHeader other = (BsdLoopbackHeader)obj;\n      return protocolFamily.equals(other.protocolFamily);\n    }\n\n    @Override\n    protected int calcHashCode() {\n      int result = 17;\n      result = 31 * result + protocolFamily.hashCode();\n      return result;\n    }\n\n  }\n\n}\n", "ng[] args) {\n\t\tSystem.out.println(reverseWords(\"Let's take LeetCode contest\"));\n\t}\n\n\tpublic static String reverseWords(String s) {\n\t\tStringBuilder sb = new StringBuilder();\n\t\tString[] sArray = s.split(\" \");\n\t\tfor (int i = 0; i < sArray.length; i++) {\n\t\t\tStringBuilder tempString = new StringBuilder(sArray[i]);\n\t\t\tsb = sb.append(tempString.reverse());\n\t\t\tif (i != sArray.length - 1)\n\t\t\t\tsb.append(\" \");\n\t\t}\n\t\treturn sb.toString();\n\t}\n}\n", "port org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;\nimport org.springframework.security.crypto.password.PasswordEncoder;\n\nimport ro.sci.gms.service.UserService;\n\n@Configuration\n@EnableWebSecurity\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n\t@Autowired\n\t@Qualifier(\"userService\")\n\tprivate UserService userService;\n\n\t@Override\n\tprotected void configure(HttpSecurity http) throws Exception {\n\t\thttp.csrf().disable();\n\t\thttp.authorizeRequests()\n\t\t\t\t.antMatchers(\"/\", \"/home\", \"/css/**\", \"/scss/**\", \"/images/**\", \"/js/**\", \"/webjars/**\", \"/fonts/**\", \"/register\", \"/rest/**\",\n\t\t\t\t\t\t\"/rest/register\", \"/send-mail\", \"/index.html\", \"/about-us.html\", \"/contact-us.html\", \"/services.html\", \"/blog.html\", \"/send-mail\", \"/register&login.html\", \"/register&login\").permitAll()\n\t\t\t\t.antMatchers(\"/doctor\").hasRole(\"DOCTOR\").anyRequest().authenticated()\n\t\t\t\t.and().formLogin().loginPage(\"/login\").permitAll().and().logout().permitAll()\n\t\t\t\t.and().formLogin().defaultSuccessUrl(\"/index.html\", true)\n\t\t\t\t.and().sessionManagement().maximumSessions(1);\n\t}\n\n\t@Autowired\n\tpublic void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {\n\t\tauth.userDetailsService((UserDetailsService) userService).passwordEncoder(passwordEncoder());\n\t}\n\t\n\t@Bean\n\tpublic PasswordEncoder passwordEncoder(){\n\t\tPasswordEncoder encoder = new BCryptPasswordEncoder();\n\t\treturn encoder;\n\t}\n}\n", "@author Emmanuel Bernard\n */\npublic class EmployeeId implements Serializable {\n\tString firstName;\n\tString lastName;\n}", "roups;\n\nimport com.google.gson.annotations.SerializedName;\nimport com.vk.api.sdk.queries.EnumParam;\n\npublic enum GroupMarketCurrency implements EnumParam {\n    @SerializedName(\"643\")\n    RUSSIAN_RUBLES(643),\n\n    @SerializedName(\"980\")\n    UKRAINIAN_HRYVNIA(980),\n\n    @SerializedName(\"398\")\n    KAZAKH_TENGE(398),\n\n    @SerializedName(\"978\")\n    EURO(978),\n\n    @SerializedName(\"840\")\n    US_DOLLARS(840);\n\n    private final Integer value;\n\n    GroupMarketCurrency(Integer value) {\n        this.value = value;\n    }\n\n    public String getValue() {\n        return value.toString();\n    }\n\n    @Override\n    public String toString() {\n        return value.toString().toLowerCase();\n    }\n}\n", " charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage com.googlecode.jmxtrans.classloader;\n\nimport com.googlecode.jmxtrans.test.IntegrationTest;\nimport org.junit.Ignore;\nimport org.junit.Test;\nimport org.junit.experimental.categories.Category;\n\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.net.MalformedURLException;\nimport java.net.URISyntaxException;\n\n@Category(IntegrationTest.class)\npublic class ClassLoadingTests {\n\n\t@Test(expected = ClassNotFoundException.class)\n\tpublic void classCannotBeAccessedIfJarIsNotLoaded() throws ClassNotFoundException {\n\t\tClass.forName(\"dummy.Dummy\");\n\t}\n\n\t/**\n\t * This test modify the class loader. This makes it hard to isolate, so let's just run it manually.\n\t */\n\t@Test\n\t@Ignore(\"Manual test\")\n\tpublic void loadedJarCanBeAccessed() throws ClassNotFoundException, MalformedURLException, FileNotFoundException, URISyntaxException {\n\t\tFile jarFile = new File(ClassLoadingTests.class.getResource(\"/dummy.jar\").toURI());\n\n\t\tnew ClassLoaderEnricher().add(jarFile);\n\t\tClass.forName(\"dummy.Dummy\");\n\t}\n\n\t@Test(expected = FileNotFoundException.class)\n\tpublic void loadingNonExistingFileThrowsException() throws MalformedURLException, FileNotFoundException {\n\t\tnew ClassLoaderEnricher().add(new File(\"/nonexising\"));\n\t}\n\n}\n", "teger> l, int k) {\n        ListNode<Integer> dummyHead = new ListNode(0, l);\n        ListNode<Integer> first = dummyHead.next;\n\n        while (k-- > 0) {\n            first = first.next;\n        }\n\n        ListNode<Integer> second = dummyHead;\n        while (first != null) {\n            first = first.next;\n            second = second.next;\n        }\n        second.next = second.next.next;\n        return dummyHead.next;\n    }\n\n    public static void main(String[] args) {\n        ListNode<Integer> L = new ListNode<>(1, new ListNode<>(2, new ListNode<>(3, null)));\n        L = removeLastKElement(L, 2);\n        assert (L.data == 1 && L.next.data == 3);\n        L = removeLastKElement(L, 2);\n        assert (L.data == 3 && L.next == null);\n        L = removeLastKElement(L, 1);\n        assert (L == null);\n    }\n}\n", "ort com.google.gwt.media.client.Audio;\n\nimport java.util.List;\n\nimport im.actor.core.Messenger;\nimport im.actor.core.NotificationProvider;\nimport im.actor.core.entity.Avatar;\nimport im.actor.core.entity.Notification;\nimport im.actor.core.entity.PeerType;\nimport im.actor.core.js.JsMessenger;\nimport im.actor.core.js.providers.electron.JsElectronApp;\nimport im.actor.core.js.providers.notification.JsManagedNotification;\nimport im.actor.core.js.providers.notification.JsNotification;\nimport im.actor.core.viewmodel.GroupVM;\nimport im.actor.core.viewmodel.UserVM;\n\npublic class JsNotificationsProvider implements NotificationProvider {\n\n    // private JsNotification currentNotification;\n\n    private Audio inappSound;\n\n    public JsNotificationsProvider() {\n        inappSound = Audio.createIfSupported();\n        if (inappSound != null) {\n            inappSound.setSrc(\"assets/sound/notification.mp3\");\n        }\n    }\n\n    @Override\n    public void onMessageArriveInApp(Messenger messenger) {\n        playSound();\n    }\n\n    @Override\n    public void onNotification(Messenger messenger, List<Notification> topNotifications, int messagesCount, int conversationsCount, boolean isInApp) {\n\n        String peerTitle;\n        String peerAvatarUrl = null;\n        String contentMessage = \"\";\n\n        Notification notification = topNotifications.get(0);\n\n        // Peer info\n        if (conversationsCount == 1) {\n            Avatar peerAvatar;\n            if (notification.getPeer().getPeerType() == PeerType.PRIVATE) {\n                UserVM userVM = messenger.getUser(notification.getPeer().getPeerId());\n                peerTitle = userVM.getName().get();\n                peerAvatar = userVM.getAvatar().get();\n            } else {\n                GroupVM groupVM = messenger.getGroup(notification.getPeer().getPeerId());\n                peerTitle = groupVM.getName().get();\n                peerAvatar = groupVM.getAvatar().get();\n            }\n            if (peerAvatar != null && peerAvatar.getSmallImage() != null) {\n                peerAvatarUrl = ((JsMessenger) messenger).getFileUrl(peerAvatar.getSmallImage().getFileReference());\n            }\n        } else {\n            peerTitle = \"New messages\";\n            peerAvatarUrl = \"assets/img/notification_icon_512.png\";\n        }\n\n        // Notification body\n\n        int nCount = Math.min(topNotifications.size(), 5);\n        boolean showCounters = false;\n        if (topNotifications.size() > 5) {\n            nCount--;\n            showCounters = true;\n        }\n\n        if (conversationsCount == 1) {\n            for (int i = 0; i < nCount; i++) {\n                Notification n = topNotifications.get(i);\n                if (contentMessage.length() > 0) {\n                    contentMessage += \"\\n\";\n                }\n                if (notification.getPeer().getPeerType() == PeerType.GROUP) {\n                    contentMessage += messenger.getUser(notification.getSender()).getName().get() + \": \";\n                }\n                contentMessage += messenger.getFormatter().formatContentText(n.getSender(),\n                        n.getContentDescription().getContentType(),\n                        n.getContentDescription().getText(),\n                        n.getContentDescription().getRelatedUser());\n            }\n\n            if (showCounters) {\n                contentMessage += \"\\n+\" + (messagesCount - 4) + \" new messages\";\n            }\n        } else {\n            for (int i = 0; i < nCount; i++) {\n                Notification n = topNotifications.get(i);\n                if (contentMessage.length() > 0) {\n                    contentMessage += \"\\n\";\n                }\n                String senderName = messenger.getUser(n.getSender()).getName().get();\n                if (n.getPeer().getPeerType() == PeerType.GROUP) {\n                    String groupName = messenger.getGroup(n.getPeer().getPeerId()).getName().get();\n                    contentMessage += \"[\" + groupName + \"] \" + senderName + \": \";\n                } else {\n                    contentMessage += senderName + \": \";\n                }\n                contentMessage += messenger.getFormatter().formatContentText(n.getSender(),\n                        n.getContentDescription().getContentType(),\n                        n.getContentDescription().getText(),\n                        n.getContentDescription().getRelatedUser());\n            }\n\n            if (showCounters) {\n                contentMessage += \"\\n+\" + (messagesCount - 4) + \" new messages in \" + conversationsCount + \" conversations\";\n            }\n        }\n\n        if (JsElectronApp.isSupported()) {\n            JsElectronApp.showNewMessages();\n        }\n\n        playSound();\n\n        if (!JsNotification.isSupported()) {\n            return;\n        }\n        if (!JsNotification.isGranted()) {\n            return;\n        }\n\n        JsManagedNotification.show(peerTitle, contentMessage, peerAvatarUrl);\n    }\n\n    @Override\n    public void onUpdateNotification(Messenger messenger, List<Notification> topNotifications, int messagesCount, int conversationsCount) {\n        // TODO: Implement\n    }\n\n    @Override\n    public void hideAllNotifications() {\n        if (JsElectronApp.isSupported()) {\n            JsElectronApp.hideNewMessages();\n        }\n    }\n\n    private void playSound() {\n        if (inappSound != null) {\n            inappSound.pause();\n            inappSound.setCurrentTime(0);\n            inappSound.play();\n        }\n    }\n}\n", "lombok.experimental.UtilityClass;\n\n@UtilityClass\npublic class Varargs {\n\n  @SuppressWarnings(\"unchecked\")\n  public static <T> T[] mergeToArray(final T first, final T... rest) {\n    final T[] array = (T[]) Array.newInstance(first.getClass(), 1 + rest.length);\n    array[0] = first;\n    if (rest.length != 0) {\n      System.arraycopy(rest, 0, array, 1, rest.length);\n    }\n    return array;\n  }\n\n  public static int[] mergeToArray(final int first, final int... rest) {\n    if (rest.length == 0) {\n      return new int[]{first};\n    } else {\n      final int[] array = new int[1 + rest.length];\n      array[0] = first;\n      System.arraycopy(rest, 0, array, 1, rest.length);\n      return array;\n    }\n  }\n\n  public static long[] mergeToArray(final long first, final long... rest) {\n    if (rest.length == 0) {\n      return new long[]{first};\n    } else {\n      final long[] array = new long[1 + rest.length];\n      array[0] = first;\n      System.arraycopy(rest, 0, array, 1, rest.length);\n      return array;\n    }\n  }\n\n  public static double[] mergeToArray(final double first, final double... rest) {\n    if (rest.length == 0) {\n      return new double[]{first};\n    } else {\n      final double[] array = new double[1 + rest.length];\n      array[0] = first;\n      System.arraycopy(rest, 0, array, 1, rest.length);\n      return array;\n    }\n  }\n}\n", "mport java.math.BigDecimal;\n\npublic class OkCoinFuturesTradeHistoryResult extends OkCoinErrorResult {\n\n  private final long tid;\n  private final long amount;\n  private final long timestamp;\n  private final TransactionType type;\n  /** USD amount, negative -> BID, positive -> ASK */\n  private final BigDecimal price;\n\n  /**\n   * Constructor\n   *\n   * @param amount\n   * @param price\n   * @param type\n   * @param tid\n   */\n  public OkCoinFuturesTradeHistoryResult(\n      @JsonProperty(\"error_code\") final int errorCode,\n      @JsonProperty(\"date\") long timestamp,\n      @JsonProperty(\"amount\") long amount,\n      @JsonProperty(\"tid\") long tid,\n      @JsonProperty(\"type\") TransactionType type,\n      @JsonProperty(\"price\") BigDecimal price) {\n\n    super(true, errorCode);\n    this.tid = tid;\n    this.amount = amount;\n    this.timestamp = timestamp;\n    this.type = type;\n    this.price = price;\n  }\n\n  public long getTimestamp() {\n\n    return timestamp;\n  }\n\n  public long getId() {\n\n    return tid;\n  }\n\n  public TransactionType getType() {\n\n    return type;\n  }\n\n  public BigDecimal getPrice() {\n    return price;\n  }\n\n  public long getAmount() {\n\n    return amount;\n  }\n\n  @Override\n  public String toString() {\n\n    return String.format(\n        \"UserTransaction{timestamp=%s, tid=%d, type=%s, price=%s, amount=%s}\",\n        timestamp, tid, type, price);\n  }\n\n  public enum TransactionType {\n    buy,\n    sell /*\n          * reseved so parsing won 't break in case Bitstamp adds new types\n          */\n  }\n}\n", "fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.google.common.base.Preconditions;\n\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic final class Score {\n    private final int upVotes;\n    private final int downVotes;\n\n    public Score(@JsonProperty(\"upVotes\") int upVotes, @JsonProperty(\"downVotes\") int downVotes) {\n        Preconditions.checkArgument(upVotes >= 0, \"upVotes == \" + upVotes);\n        Preconditions.checkArgument(downVotes >= 0, \"downVotes == \" + downVotes);\n        this.upVotes = upVotes;\n        this.downVotes = downVotes;\n    }\n\n    public int getUpVotes() {\n        return upVotes;\n    }\n\n    public int getDownVotes() {\n        return downVotes;\n    }\n\n    public int calculateScore() {\n        return upVotes - downVotes;\n    }\n\n    @JsonIgnore\n    public boolean isPositive() {\n        return calculateScore() > 0;\n    }\n\n    @JsonIgnore\n    public boolean isNegative() {\n        return calculateScore() < 0;\n    }\n\n    @JsonIgnore\n    public boolean isNeutral() {\n        return calculateScore() == 0;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Score)) return false;\n\n        Score score = (Score) o;\n\n        return upVotes == score.upVotes && downVotes == score.downVotes;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = upVotes;\n        result = 31 * result + downVotes;\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        return \"Score{\" +\n                \"upVotes=\" + upVotes +\n                \", downVotes=\" + downVotes +\n                '}';\n    }\n}\n", "are LLC or third-party contributors as\n * indicated by the @author tags or express copyright attribution\n * statements applied by the authors.  All third-party contributions are\n * distributed under license by Red Hat Middleware LLC.\n *\n * This copyrighted material is made available to anyone wishing to use, modify,\n * copy, or redistribute it subject to the terms and conditions of the GNU\n * Lesser General Public License, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this distribution; if not, write to:\n * Free Software Foundation, Inc.\n * 51 Franklin Street, Fifth Floor\n * Boston, MA  02110-1301  USA\n */\npackage org.hibernate.envers.query.criteria;\n\nimport org.hibernate.envers.configuration.AuditConfiguration;\nimport org.hibernate.envers.entities.RelationDescription;\nimport org.hibernate.envers.exception.AuditException;\nimport org.hibernate.envers.query.property.PropertyNameGetter;\nimport org.hibernate.envers.reader.AuditReaderImplementor;\nimport org.hibernate.envers.tools.query.Parameters;\nimport org.hibernate.envers.tools.query.QueryBuilder;\n\n/**\n * @author Adam Warski (adam at warski dot org)\n */\npublic class SimpleAuditExpression implements AuditCriterion {\n    private PropertyNameGetter propertyNameGetter;\n    private Object value;\n    private String op;\n\n    public SimpleAuditExpression(PropertyNameGetter propertyNameGetter, Object value, String op) {\n        this.propertyNameGetter = propertyNameGetter;\n        this.value = value;\n        this.op = op;\n    }\n\n    public void addToQuery(AuditConfiguration auditCfg, AuditReaderImplementor versionsReader, String entityName,\n\t\t\t\t\t\t   QueryBuilder qb, Parameters parameters) {\n\t\tString propertyName = CriteriaTools.determinePropertyName( auditCfg, versionsReader, entityName, propertyNameGetter );\n\n        RelationDescription relatedEntity = CriteriaTools.getRelatedEntity(auditCfg, entityName, propertyName);\n\n        if (relatedEntity == null) {\n            parameters.addWhereWithParam(propertyName, op, value);\n        } else {\n            if (!\"=\".equals(op) && !\"<>\".equals(op)) {\n                throw new AuditException(\"This type of operation: \" + op + \" (\" + entityName + \".\" + propertyName +\n                        \") isn't supported and can't be used in queries.\");\n            }\n\n            Object id = relatedEntity.getIdMapper().mapToIdFromEntity(value);\n\n            relatedEntity.getIdMapper().addIdEqualsToQuery(parameters, id, null, \"=\".equals(op));\n        }\n    }\n}\n", "equestBuilder;\nimport io.evanwong.oss.hipchat.v2.commons.RequestBuilder;\nimport org.apache.http.client.HttpClient;\n\nimport java.util.concurrent.ExecutorService;\n\npublic class GetAllEmoticonsRequestBuilder extends ExpandableRequestBuilder<GetAllEmoticonsRequestBuilder, GetAllEmoticonsRequest> {\n\n    private Integer startIndex;\n    private Integer maxResults;\n    private EmoticonType type;\n\n    public GetAllEmoticonsRequestBuilder(String accessToken, HttpClient httpClient, ExecutorService executorService) {\n        super(accessToken, httpClient, executorService);\n    }\n\n    public Integer getStartIndex() {\n        return startIndex;\n    }\n\n    public GetAllEmoticonsRequestBuilder setStartIndex(Integer startIndex) {\n        this.startIndex = startIndex;\n        return this;\n    }\n\n    public Integer getMaxResults() {\n        return maxResults;\n    }\n\n    public GetAllEmoticonsRequestBuilder setMaxResults(Integer maxResults) {\n        this.maxResults = maxResults;\n        return this;\n    }\n\n    public EmoticonType getType() {\n        return type;\n    }\n\n    public GetAllEmoticonsRequestBuilder setType(EmoticonType type) {\n        this.type = type;\n        return this;\n    }\n\n    @Override\n    public GetAllEmoticonsRequest build() {\n        return new GetAllEmoticonsRequest(startIndex, maxResults, type, accessToken, httpClient, executorService);\n    }\n}\n", ". See License.txt in the project root for\r\n * license information.\r\n *\r\n * Code generated by Microsoft (R) AutoRest Code Generator.\r\n * Changes may cause incorrect behavior and will be lost if the code is\r\n * regenerated.\r\n */\r\n\r\npackage fixtures.bodyarray;\r\n\r\nimport com.microsoft.rest.ServiceCall;\r\nimport com.microsoft.rest.ServiceCallback;\r\nimport com.microsoft.rest.ServiceResponse;\r\nimport fixtures.bodyarray.models.ErrorException;\r\nimport fixtures.bodyarray.models.Product;\r\nimport java.io.IOException;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.UUID;\r\nimport org.joda.time.DateTime;\r\nimport org.joda.time.LocalDate;\r\nimport org.joda.time.Period;\r\n\r\n/**\r\n * An instance of this class provides access to all the operations defined\r\n * in ArrayOperations.\r\n */\r\npublic interface ArrayOperations {\r\n    /**\r\n     * Get null array value.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Integer>> getNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get null array value.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getNullAsync(final ServiceCallback<List<Integer>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get invalid array [1, 2, 3.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Integer>> getInvalid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get invalid array [1, 2, 3.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getInvalidAsync(final ServiceCallback<List<Integer>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get empty array value [].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Integer>> getEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get empty array value [].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getEmptyAsync(final ServiceCallback<List<Integer>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [].\r\n     *\r\n     * @param arrayBody the List&lt;String&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putEmpty(List<String> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [].\r\n     *\r\n     * @param arrayBody the List&lt;String&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putEmptyAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get boolean array value [true, false, false, true].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Boolean&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Boolean>> getBooleanTfft() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get boolean array value [true, false, false, true].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getBooleanTfftAsync(final ServiceCallback<List<Boolean>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [true, false, false, true].\r\n     *\r\n     * @param arrayBody the List&lt;Boolean&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putBooleanTfft(List<Boolean> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [true, false, false, true].\r\n     *\r\n     * @param arrayBody the List&lt;Boolean&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putBooleanTfftAsync(List<Boolean> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get boolean array value [true, null, false].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Boolean&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Boolean>> getBooleanInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get boolean array value [true, null, false].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getBooleanInvalidNullAsync(final ServiceCallback<List<Boolean>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get boolean array value [true, 'boolean', false].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Boolean&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Boolean>> getBooleanInvalidString() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get boolean array value [true, 'boolean', false].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getBooleanInvalidStringAsync(final ServiceCallback<List<Boolean>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get integer array value [1, -1, 3, 300].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Integer>> getIntegerValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get integer array value [1, -1, 3, 300].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getIntegerValidAsync(final ServiceCallback<List<Integer>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [1, -1, 3, 300].\r\n     *\r\n     * @param arrayBody the List&lt;Integer&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putIntegerValid(List<Integer> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [1, -1, 3, 300].\r\n     *\r\n     * @param arrayBody the List&lt;Integer&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putIntegerValidAsync(List<Integer> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get integer array value [1, null, 0].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Integer>> getIntInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get integer array value [1, null, 0].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getIntInvalidNullAsync(final ServiceCallback<List<Integer>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get integer array value [1, 'integer', 0].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Integer&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Integer>> getIntInvalidString() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get integer array value [1, 'integer', 0].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getIntInvalidStringAsync(final ServiceCallback<List<Integer>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get integer array value [1, -1, 3, 300].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Long&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Long>> getLongValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get integer array value [1, -1, 3, 300].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getLongValidAsync(final ServiceCallback<List<Long>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [1, -1, 3, 300].\r\n     *\r\n     * @param arrayBody the List&lt;Long&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putLongValid(List<Long> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value empty [1, -1, 3, 300].\r\n     *\r\n     * @param arrayBody the List&lt;Long&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putLongValidAsync(List<Long> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get long array value [1, null, 0].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Long&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Long>> getLongInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get long array value [1, null, 0].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getLongInvalidNullAsync(final ServiceCallback<List<Long>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get long array value [1, 'integer', 0].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Long&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Long>> getLongInvalidString() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get long array value [1, 'integer', 0].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getLongInvalidStringAsync(final ServiceCallback<List<Long>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get float array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Double>> getFloatValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get float array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getFloatValidAsync(final ServiceCallback<List<Double>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @param arrayBody the List&lt;Double&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putFloatValid(List<Double> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @param arrayBody the List&lt;Double&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putFloatValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get float array value [0.0, null, -1.2e20].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Double>> getFloatInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get float array value [0.0, null, -1.2e20].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getFloatInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get boolean array value [1.0, 'number', 0.0].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Double>> getFloatInvalidString() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get boolean array value [1.0, 'number', 0.0].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getFloatInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get float array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Double>> getDoubleValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get float array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDoubleValidAsync(final ServiceCallback<List<Double>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @param arrayBody the List&lt;Double&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putDoubleValid(List<Double> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value [0, -0.01, 1.2e20].\r\n     *\r\n     * @param arrayBody the List&lt;Double&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putDoubleValidAsync(List<Double> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get float array value [0.0, null, -1.2e20].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Double>> getDoubleInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get float array value [0.0, null, -1.2e20].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDoubleInvalidNullAsync(final ServiceCallback<List<Double>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get boolean array value [1.0, 'number', 0.0].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Double&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Double>> getDoubleInvalidString() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get boolean array value [1.0, 'number', 0.0].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDoubleInvalidStringAsync(final ServiceCallback<List<Double>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get string array value ['foo1', 'foo2', 'foo3'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<String>> getStringValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get string array value ['foo1', 'foo2', 'foo3'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getStringValidAsync(final ServiceCallback<List<String>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value ['foo1', 'foo2', 'foo3'].\r\n     *\r\n     * @param arrayBody the List&lt;String&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putStringValid(List<String> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value ['foo1', 'foo2', 'foo3'].\r\n     *\r\n     * @param arrayBody the List&lt;String&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putStringValidAsync(List<String> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get string array value ['foo', null, 'foo2'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<String>> getStringWithNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get string array value ['foo', null, 'foo2'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getStringWithNullAsync(final ServiceCallback<List<String>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get string array value ['foo', 123, 'foo2'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<String>> getStringWithInvalid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get string array value ['foo', 123, 'foo2'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getStringWithInvalidAsync(final ServiceCallback<List<String>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;UUID&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<UUID>> getUuidValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getUuidValidAsync(final ServiceCallback<List<UUID>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].\r\n     *\r\n     * @param arrayBody the List&lt;UUID&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putUuidValid(List<UUID> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'd1399005-30f7-40d6-8da6-dd7c89ad34db', 'f42f6aa1-a5bc-4ddf-907e-5f915de43205'].\r\n     *\r\n     * @param arrayBody the List&lt;UUID&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putUuidValidAsync(List<UUID> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;UUID&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<UUID>> getUuidInvalidChars() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get uuid array value ['6dcc7237-45fe-45c4-8a6b-3a8a3f625652', 'foo'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getUuidInvalidCharsAsync(final ServiceCallback<List<UUID>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<LocalDate>> getDateValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get integer array value ['2000-12-01', '1980-01-02', '1492-10-12'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateValidAsync(final ServiceCallback<List<LocalDate>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].\r\n     *\r\n     * @param arrayBody the List&lt;LocalDate&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putDateValid(List<LocalDate> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['2000-12-01', '1980-01-02', '1492-10-12'].\r\n     *\r\n     * @param arrayBody the List&lt;LocalDate&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putDateValidAsync(List<LocalDate> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get date array value ['2012-01-01', null, '1776-07-04'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<LocalDate>> getDateInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get date array value ['2012-01-01', null, '1776-07-04'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateInvalidNullAsync(final ServiceCallback<List<LocalDate>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get date array value ['2011-03-22', 'date'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;LocalDate&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<LocalDate>> getDateInvalidChars() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get date array value ['2011-03-22', 'date'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateInvalidCharsAsync(final ServiceCallback<List<LocalDate>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<DateTime>> getDateTimeValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get date-time array value ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateTimeValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].\r\n     *\r\n     * @param arrayBody the List&lt;DateTime&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putDateTimeValid(List<DateTime> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['2000-12-01t00:00:01z', '1980-01-02T00:11:35+01:00', '1492-10-12T10:15:01-08:00'].\r\n     *\r\n     * @param arrayBody the List&lt;DateTime&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putDateTimeValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get date array value ['2000-12-01t00:00:01z', null].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<DateTime>> getDateTimeInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get date array value ['2000-12-01t00:00:01z', null].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateTimeInvalidNullAsync(final ServiceCallback<List<DateTime>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<DateTime>> getDateTimeInvalidChars() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get date array value ['2000-12-01t00:00:01z', 'date-time'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateTimeInvalidCharsAsync(final ServiceCallback<List<DateTime>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;DateTime&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<DateTime>> getDateTimeRfc1123Valid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get date-time array value ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDateTimeRfc1123ValidAsync(final ServiceCallback<List<DateTime>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].\r\n     *\r\n     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putDateTimeRfc1123Valid(List<DateTime> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['Fri, 01 Dec 2000 00:00:01 GMT', 'Wed, 02 Jan 1980 00:11:35 GMT', 'Wed, 12 Oct 1492 10:15:01 GMT'].\r\n     *\r\n     * @param arrayBody the List&lt;DateTimeRfc1123&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putDateTimeRfc1123ValidAsync(List<DateTime> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Period&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Period>> getDurationValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get duration array value ['P123DT22H14M12.011S', 'P5DT1H0M0S'].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDurationValidAsync(final ServiceCallback<List<Period>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].\r\n     *\r\n     * @param arrayBody the List&lt;Period&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putDurationValid(List<Period> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Set array value  ['P123DT22H14M12.011S', 'P5DT1H0M0S'].\r\n     *\r\n     * @param arrayBody the List&lt;Period&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putDurationValidAsync(List<Period> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;byte[]&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<byte[]>> getByteValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get byte array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each item encoded in base64.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getByteValidAsync(final ServiceCallback<List<byte[]>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.\r\n     *\r\n     * @param arrayBody the List&lt;byte[]&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putByteValid(List<byte[]> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Put the array value [hex(FF FF FF FA), hex(01 02 03), hex (25, 29, 43)] with each elementencoded in base 64.\r\n     *\r\n     * @param arrayBody the List&lt;byte[]&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putByteValidAsync(List<byte[]> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;byte[]&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<byte[]>> getByteInvalidNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get byte array value [hex(AB, AC, AD), null] with the first item base64 encoded.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getByteInvalidNullAsync(final ServiceCallback<List<byte[]>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;String&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<String>> getBase64Url() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get array value ['a string that gets encoded with base64url', 'test string' 'Lorem ipsum'] with the items base64url encoded.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getBase64UrlAsync(final ServiceCallback<List<String>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get array of complex type null value.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Product>> getComplexNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get array of complex type null value.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getComplexNullAsync(final ServiceCallback<List<Product>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get empty array of complex type [].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Product>> getComplexEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get empty array of complex type [].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getComplexEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Product>> getComplexItemNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get array of complex type with null item [{'integer': 1 'string': '2'}, null, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getComplexItemNullAsync(final ServiceCallback<List<Product>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Product>> getComplexItemEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get array of complex type with empty item [{'integer': 1 'string': '2'}, {}, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getComplexItemEmptyAsync(final ServiceCallback<List<Product>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Product&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Product>> getComplexValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get array of complex type with [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getComplexValidAsync(final ServiceCallback<List<Product>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @param arrayBody the List&lt;Product&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putComplexValid(List<Product> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Put an array of complex type with values [{'integer': 1 'string': '2'}, {'integer': 3, 'string': '4'}, {'integer': 5, 'string': '6'}].\r\n     *\r\n     * @param arrayBody the List&lt;Product&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putComplexValidAsync(List<Product> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get a null array.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<List<String>>> getArrayNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get a null array.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getArrayNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an empty array [].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<List<String>>> getArrayEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an empty array [].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getArrayEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<List<String>>> getArrayItemNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of array of strings [['1', '2', '3'], null, ['7', '8', '9']].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getArrayItemNullAsync(final ServiceCallback<List<List<String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<List<String>>> getArrayItemEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of array of strings [['1', '2', '3'], [], ['7', '8', '9']].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getArrayItemEmptyAsync(final ServiceCallback<List<List<String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;List&lt;String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<List<String>>> getArrayValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getArrayValidAsync(final ServiceCallback<List<List<String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].\r\n     *\r\n     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putArrayValid(List<List<String>> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Put An array of array of strings [['1', '2', '3'], ['4', '5', '6'], ['7', '8', '9']].\r\n     *\r\n     * @param arrayBody the List&lt;List&lt;String&gt;&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putArrayValidAsync(List<List<String>> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries with value null.\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Map<String, String>>> getDictionaryNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries with value null.\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDictionaryNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Map<String, String>>> getDictionaryEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDictionaryEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Map<String, String>>> getDictionaryItemNull() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, null, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDictionaryItemNullAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Map<String, String>>> getDictionaryItemEmpty() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {}, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDictionaryItemEmptyAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @return the List&lt;Map&lt;String, String&gt;&gt; object wrapped in {@link ServiceResponse} if successful.\r\n     */\r\n    ServiceResponse<List<Map<String, String>>> getDictionaryValid() throws ErrorException, IOException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall getDictionaryValidAsync(final ServiceCallback<List<Map<String, String>>> serviceCallback) throws IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value\r\n     * @throws ErrorException exception thrown from REST call\r\n     * @throws IOException exception thrown from serialization/deserialization\r\n     * @throws IllegalArgumentException exception thrown from invalid parameters\r\n     * @return the {@link ServiceResponse} object if successful.\r\n     */\r\n    ServiceResponse<Void> putDictionaryValid(List<Map<String, String>> arrayBody) throws ErrorException, IOException, IllegalArgumentException;\r\n\r\n    /**\r\n     * Get an array of Dictionaries of type &lt;string, string&gt; with value [{'1': 'one', '2': 'two', '3': 'three'}, {'4': 'four', '5': 'five', '6': 'six'}, {'7': 'seven', '8': 'eight', '9': 'nine'}].\r\n     *\r\n     * @param arrayBody the List&lt;Map&lt;String, String&gt;&gt; value\r\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\r\n     * @throws IllegalArgumentException thrown if callback is null\r\n     * @return the {@link ServiceCall} object\r\n     */\r\n    ServiceCall putDictionaryValidAsync(List<Map<String, String>> arrayBody, final ServiceCallback<Void> serviceCallback) throws IllegalArgumentException;\r\n\r\n}\r\n", "java.util.Objects;\nimport java.util.Scanner;\nimport java.util.Set;\n\npublic class Day1 {\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        List<Integer> seenNumbers = new ArrayList<>();\n        while (in.hasNextInt()) {\n            seenNumbers.add(in.nextInt());\n        }\n        Set<Pair> targets = new HashSet<>();\n        for (int i = 0; i < seenNumbers.size(); i++) {\n            for (int j = i + 1; j < seenNumbers.size(); j++) {\n                targets.add(new Pair(seenNumbers.get(i), seenNumbers.get(j)));\n            }\n        }\n        for (int val : seenNumbers) {\n            for (Pair p : targets) {\n                if (p.thirdMatches(val)) {\n                    System.out.println(p.result(val));\n                    return;\n                }\n            }\n\n        }\n\n    }\n}\n\nclass Pair {\n    int x;\n    int y;\n\n\n    public Pair(int x, int y) {\n        this.x = x;\n        this.y = y;\n    }\n\n    boolean thirdMatches(int z) {\n        return (2020 - x - y - z) == 0;\n    }\n\n    int result(int z) {\n       return x * y * z;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Pair pair = (Pair) o;\n        return x == pair.x &&\n                y == pair.y;\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(x, y);\n    }\n}", "x.modules.RepositoryHandler;\n\npublic class RepoHelper {\n\n\tpublic static Repository fromHandler(RepositoryHandler repo) {\n\t\treturn repo != null ? repo.getRepository() : null;\n\t}\n\n\tpublic static boolean equal(Repository a, Repository b) {\n\n\t\tif (a == b) {\n\t\t\treturn true;\n\t\t}\n\n\t\tif (a == null || b == null) {\n\t\t\treturn false;\n\t\t}\n\n\t\tString pathA = a.getDirectory().getAbsolutePath();\n\t\tString pathB = b.getDirectory().getAbsolutePath();\n\n\t\treturn pathA.equals(pathB);\n\t}\n}\n", "e MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage com.facebook.imagepipeline.cache;\n\nimport com.facebook.cache.common.CacheKey;\nimport com.facebook.common.internal.Supplier;\nimport com.facebook.common.memory.MemoryTrimmableRegistry;\nimport com.facebook.imagepipeline.image.CloseableImage;\nimport javax.annotation.Nullable;\n\npublic interface BitmapMemoryCacheFactory {\n\n  CountingMemoryCache<CacheKey, CloseableImage> create(\n      Supplier<MemoryCacheParams> bitmapMemoryCacheParamsSupplier,\n      MemoryTrimmableRegistry memoryTrimmableRegistry,\n      MemoryCache.CacheTrimStrategy trimStrategy,\n      boolean storeEntrySize,\n      boolean ignoreSizeMismatch,\n      @Nullable CountingMemoryCache.EntryStateObserver<CacheKey> observer);\n}\n", " java.applet.*;\n\npublic class Stoplicht extends Applet {\n\n    public void init() {\n    }\n\n    public void paint(Graphics g) {\n    setBackground(Color.white);\n        g.setColor(Color.gray);\n        g.fillRoundRect(45,25,110,260,20,20);\n        g.setColor(Color.black);\n        g.fillRoundRect(50,30,100,250,20,20);\n        g.setColor(Color.RED);\n        g.fillOval(75,60,50,50);\n        g.setColor(Color.yellow);\n        g.fillOval(75,130,50,50);\n        g.setColor(Color.green);\n        g.fillOval(75,200,50,50);\n\n\n    }\n}", "lBushwhackerRulesException extends RuntimeException {\n\n  public IllegalBushwhackerRulesException() {\n  }\n\n  public IllegalBushwhackerRulesException(String message) {\n    super(message);\n  }\n\n  public IllegalBushwhackerRulesException(String message, Throwable cause) {\n    super(message, cause);\n  }\n\n  public IllegalBushwhackerRulesException(Throwable cause) {\n    super(cause);\n  }\n}\n", "openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\n\npublic class HeaderPage extends AbstractPage {\n\n    public HeaderPage(WebDriver driver) {\n        super(driver);\n    }\n\n    @Override\n    public void waitForLoad() {\n        waitFor(\"#header-version\");\n    }\n\n    public boolean isLogged() {\n        return !isDefined(By.id(\"header-signin\"));\n    }\n\n    public void signOut() {\n        // Displays the user menu\n        displayUserMenu();\n        // Clicks on the signout\n        findBy(\"#header-signout\").click();\n    }\n\n    public void displayUserMenu() {\n        findBy(\"#header-user\").click();\n        waitFor(\"#header-signout\");\n    }\n\n    public LoginPage signIn() {\n        find(By.id(\"header-signin\")).click();\n        return switchAndLoad(LoginPage.class);\n    }\n\n    public String getSignedUserName() {\n        WebElement e = findOptional(By.id(\"header-user\"));\n        if (e != null) {\n            return e.getText();\n        } else {\n            return null;\n        }\n    }\n}\n", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.boot.logging.java;\n\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.util.Date;\nimport java.util.logging.Formatter;\nimport java.util.logging.LogRecord;\n\n/**\n * Simple 'Java Logging' {@link Formatter}.\n *\n * @author Phillip Webb\n */\npublic class SimpleFormatter extends Formatter {\n\n\tprivate static final String DEFAULT_FORMAT = \"[%1$tY-%1$tm-%1$td %1$tH:%1$tM:%1$tS.%1$tL] - %8$s %4$s [%7$s] --- %3$s: %5$s%6$s%n\";\n\n\tprivate final String format = getOrUseDefault(\"LOG_FORMAT\", DEFAULT_FORMAT);\n\n\tprivate final String pid = getOrUseDefault(\"PID\", \"????\");\n\n\tprivate final Date date = new Date();\n\n\t@Override\n\tpublic synchronized String format(LogRecord record) {\n\t\tthis.date.setTime(record.getMillis());\n\t\tString source = record.getLoggerName();\n\t\tString message = formatMessage(record);\n\t\tString throwable = getThrowable(record);\n\t\tString thread = getThreadName();\n\t\treturn String.format(this.format, this.date, source, record.getLoggerName(),\n\t\t\t\trecord.getLevel().getLocalizedName(), message, throwable, thread,\n\t\t\t\tthis.pid);\n\t}\n\n\tprivate String getThrowable(LogRecord record) {\n\t\tif (record.getThrown() == null) {\n\t\t\treturn \"\";\n\t\t}\n\t\tStringWriter stringWriter = new StringWriter();\n\t\tPrintWriter printWriter = new PrintWriter(stringWriter);\n\t\tprintWriter.println();\n\t\trecord.getThrown().printStackTrace(printWriter);\n\t\tprintWriter.close();\n\t\treturn stringWriter.toString();\n\t}\n\n\tprivate String getThreadName() {\n\t\tString name = Thread.currentThread().getName();\n\t\treturn (name == null ? \"\" : name);\n\t}\n\n\tprivate static String getOrUseDefault(String key, String defaultValue) {\n\t\tString value = null;\n\t\ttry {\n\t\t\tvalue = System.getenv(key);\n\t\t}\n\t\tcatch (Exception ex) {\n\t\t\t// ignore\n\t\t}\n\t\tif (value == null) {\n\t\t\tvalue = defaultValue;\n\t\t}\n\t\treturn System.getProperty(key, value);\n\t}\n\n}\n", "o () {\n\t\tsuper();\n\t}\n\n\tIOSCrypto (int cryptoAlgorithm) {\n\t\tsuper(cryptoAlgorithm);\n\t}\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n// key: compiler.err.type.found.req\n// key: compiler.misc.type.parameter\n// key: compiler.misc.type.req.class\n\nimport java.util.*;\n\nclass X<T> {\n    List<T<Integer>> list;\n}\n", "advance.geometry.ImmutablePoint;\r\nimport com.tagadvance.geometry.Point;\r\n\r\npublic class IntegerSudokuParser implements SudokuParser<Integer> {\r\n\r\n\t@Override\r\n\tpublic void populateSudokuFromString(Grid<Integer> grid, String puzzle) {\r\n\t\tImmutableDimension size = grid.getSize();\r\n\r\n\t\tint x = 0, y = 0;\r\n\t\tfor (int i = 0; i < puzzle.length(); i++) {\r\n\t\t\tImmutablePoint point = new Point(x, y);\r\n\t\t\tCell<Integer> cell = grid.getCellAt(point);\r\n\t\t\tString value = puzzle.substring(i, i + 1);\r\n\t\t\ttry {\r\n\t\t\t\tInteger integer = Integer.parseInt(value);\r\n\t\t\t\tcell.setValue(integer);\r\n\t\t\t} catch (NumberFormatException e) {\r\n\t\t\t\t// e.printStackTrace();\r\n\t\t\t}\r\n\t\t\tif (++x >= size.getWidth()) {\r\n\t\t\t\ty++;\r\n\t\t\t\tx = 0;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n}\r\n", "y granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage org.takes.rs;\n\nimport java.net.HttpURLConnection;\nimport lombok.EqualsAndHashCode;\nimport lombok.ToString;\n\n/**\n * Redirect.\n *\n * <p>The class is immutable and thread-safe.\n *\n * @author Yegor Bugayenko (yegor@teamed.io)\n * @version $Id$\n * @since 0.6\n */\n@ToString(callSuper = true)\n@EqualsAndHashCode(callSuper = true)\npublic final class RsRedirect extends RsWrap {\n\n    /**\n     * Ctor.\n     */\n    public RsRedirect() {\n        this(\"/\");\n    }\n\n    /**\n     * Ctor.\n     * @param location Where to redirect\n     */\n    public RsRedirect(final CharSequence location) {\n        this(location, HttpURLConnection.HTTP_SEE_OTHER);\n    }\n\n    /**\n     * Ctor.\n     * @param location Location\n     * @param code HTTP redirect status code\n     */\n    public RsRedirect(final CharSequence location, final int code) {\n        super(\n            new RsWithHeader(\n                new RsWithStatus(new RsEmpty(), code),\n                \"Location\", location\n        )\n        );\n    }\n\n}\n", "nProperty;\n\n/**\n * @author <a href=\"mailto:matthew.cachia@gmail.com\">Matthew Cachia</a>\n *\n */\npublic class SendMessage extends Event {\n\t\n\t/**\n\t * The user's account ID according to your systems. Use the same ID that you would use to look up users \n\t * on your website's databases. This field is required on all events performed by the user while logged in. \n\t * Users without an assigned {@link #userId} will not show up in the console. Note: User IDs are \n\t * <strong>case sensitive</strong>. You may need to normalize the capitalization of your user IDs.\n\t */\n\t@JsonProperty(\"$user_id\")\n\tprivate String userId;\n\t\n\t/**\n\t * The user's current session ID, used to tie a user's action before and after log in or account creation.\n\t */\n\t@JsonProperty(\"$session_id\")\n\tprivate String sessionId;\n\t\n\t/**\n\t * The ID of the user receiving the message. Required to compute network graphs. \n\t * \n\t * Note: User IDs are case sensitive. You may need to normalize the capitalization of your user IDs.\n\t */\n\t@JsonProperty(\"$recipient_user_id\")\n\tprivate String recipientUserId;\n\t\n\t/**\n\t * The subject of the message.\n\t */\n\t@JsonProperty(\"$subject\")\n\tprivate String subject;\n\t\n\t/**\n\t * The content of the message.\n\t */\n\t@JsonProperty(\"$content\")\n\tprivate String content;\n\t\n\tpublic SendMessage() {\n\t\tsuper(\"$send_message\");\n\t}\n\n\n\tpublic String getUserId() {\n\t\treturn userId;\n\t}\n\n\n\tpublic String getSessionId() {\n\t\treturn sessionId;\n\t}\n\n\n\tpublic String getRecipientUserId() {\n\t\treturn recipientUserId;\n\t}\n\n\n\tpublic String getSubject() {\n\t\treturn subject;\n\t}\n\n\n\tpublic String getContent() {\n\t\treturn content;\n\t}\n\n\n\tpublic SendMessage setUserId(String userId) {\n\t\tthis.userId = userId;\n\t\treturn this;\n\t}\n\n\n\tpublic SendMessage setSessionId(String sessionId) {\n\t\tthis.sessionId = sessionId;\n\t\treturn this;\n\t}\n\n\n\tpublic SendMessage setRecipientUserId(String recipientUserId) {\n\t\tthis.recipientUserId = recipientUserId;\n\t\treturn this;\n\t}\n\n\n\tpublic SendMessage setSubject(String subject) {\n\t\tthis.subject = subject;\n\t\treturn this;\n\t}\n\n\n\tpublic SendMessage setContent(String content) {\n\t\tthis.content = content;\n\t\treturn this;\n\t}\n\n    @Override\n    public int hashCode() {\n        final int prime = 31;\n        int result = super.hashCode();\n        result = prime * result + ((content == null) ? 0 : content.hashCode());\n        result = prime * result\n                + ((recipientUserId == null) ? 0 : recipientUserId.hashCode());\n        result = prime * result\n                + ((sessionId == null) ? 0 : sessionId.hashCode());\n        result = prime * result + ((subject == null) ? 0 : subject.hashCode());\n        result = prime * result + ((userId == null) ? 0 : userId.hashCode());\n        return result;\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        \n        if (!super.equals(obj)) {\n            return false;\n        }\n\n        if (obj == null || !(obj instanceof SendMessage)) {\n            return false;\n        }\n        \n        final SendMessage rm = (SendMessage)obj;\n        \n        if (this.sessionId == null) {\n            if (rm.getSessionId() != null) {\n                return false;\n            }\n        } else if (!this.sessionId.equals(rm.getSessionId())) {\n            return false;\n        }\n        \n        if (this.userId == null) {\n            if (rm.getUserId() != null) {\n                return false;\n            }\n        } else if (!this.userId.equals(rm.getUserId())) {\n            return false;\n        }\n        \n        if (this.content == null) {\n            if (rm.getContent() != null) {\n                return false;\n            }\n        } else if (!this.content.equals(rm.getContent())) {\n            return false;\n        }\n        \n        if (this.recipientUserId == null) {\n            if (rm.getRecipientUserId() != null) {\n                return false;\n            }\n        } else if (!this.recipientUserId.equals(rm.getRecipientUserId())) {\n            return false;\n        }\n        \n        if (this.subject == null) {\n            if (rm.getSubject() != null) {\n                return false;\n            }\n        } else if (!this.subject.equals(rm.getSubject())) {\n            return false;\n        }\n        \n        return true;\n    }\n\n}\n", ";\nimport android.app.Fragment;\nimport android.support.v4.app.ActionBarDrawerToggle;\nimport android.support.v4.view.GravityCompat;\nimport android.support.v4.widget.DrawerLayout;\nimport android.content.SharedPreferences;\nimport android.content.res.Configuration;\nimport android.os.Bundle;\nimport android.preference.PreferenceManager;\nimport android.view.LayoutInflater;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.ListView;\nimport android.widget.Toast;\n\n/**\n * Fragment used for managing interactions for and presentation of a navigation drawer.\n * See the <a href=\"https://developer.android.com/design/patterns/navigation-drawer.html#Interaction\">\n * design guidelines</a> for a complete explanation of the behaviors implemented here.\n */\npublic class NavigationDrawerFragment extends Fragment {\n\n    /**\n     * Remember the position of the selected item.\n     */\n    private static final String STATE_SELECTED_POSITION = \"selected_navigation_drawer_position\";\n\n    /**\n     * Per the design guidelines, you should show the drawer on launch until the user manually\n     * expands it. This shared preference tracks this.\n     */\n    private static final String PREF_USER_LEARNED_DRAWER = \"navigation_drawer_learned\";\n\n    /**\n     * A pointer to the current callbacks instance (the Activity).\n     */\n    private NavigationDrawerCallbacks mCallbacks;\n\n    /**\n     * Helper component that ties the action bar to the navigation drawer.\n     */\n    private ActionBarDrawerToggle mDrawerToggle;\n\n    private DrawerLayout mDrawerLayout;\n    private ListView mDrawerListView;\n    private View mFragmentContainerView;\n\n    private int mCurrentSelectedPosition = 0;\n    private boolean mFromSavedInstanceState;\n    private boolean mUserLearnedDrawer;\n\n    public NavigationDrawerFragment() {\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        // Read in the flag indicating whether or not the user has demonstrated awareness of the\n        // drawer. See PREF_USER_LEARNED_DRAWER for details.\n        SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(getActivity());\n        mUserLearnedDrawer = sp.getBoolean(PREF_USER_LEARNED_DRAWER, false);\n\n        if (savedInstanceState != null) {\n            mCurrentSelectedPosition = savedInstanceState.getInt(STATE_SELECTED_POSITION);\n            mFromSavedInstanceState = true;\n        }\n\n        // Select either the default item (0) or the last selected item.\n        selectItem(mCurrentSelectedPosition);\n    }\n\n    @Override\n    public void onActivityCreated (Bundle savedInstanceState) {\n        super.onActivityCreated(savedInstanceState);\n        // Indicate that this fragment would like to influence the set of actions in the action bar.\n        setHasOptionsMenu(true);\n    }\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n            Bundle savedInstanceState) {\n        mDrawerListView = (ListView) inflater.inflate(\n                R.layout.fragment_navigation_drawer, container, false);\n        mDrawerListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {\n            @Override\n            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {\n                selectItem(position);\n            }\n        });\n        mDrawerListView.setAdapter(new ArrayAdapter<String>(\n                getActionBar().getThemedContext(),\n                android.R.layout.simple_list_item_activated_1,\n                android.R.id.text1,\n                new String[]{\n                        getString(R.string.title_section1),\n                        getString(R.string.title_section2),\n                        getString(R.string.title_section3),\n                        getString(R.string.title_section4)\n                }));\n        mDrawerListView.setItemChecked(mCurrentSelectedPosition, true);\n        return mDrawerListView;\n    }\n\n    public boolean isDrawerOpen() {\n        return mDrawerLayout != null && mDrawerLayout.isDrawerOpen(mFragmentContainerView);\n    }\n\n    /**\n     * Users of this fragment must call this method to set up the navigation drawer interactions.\n     *\n     * @param fragmentId   The android:id of this fragment in its activity's layout.\n     * @param drawerLayout The DrawerLayout containing this fragment's UI.\n     */\n    public void setUp(int fragmentId, DrawerLayout drawerLayout) {\n        mFragmentContainerView = getActivity().findViewById(fragmentId);\n        mDrawerLayout = drawerLayout;\n\n        // set a custom shadow that overlays the main content when the drawer opens\n        mDrawerLayout.setDrawerShadow(R.drawable.drawer_shadow, GravityCompat.START);\n        // set up the drawer's list view with items and click listener\n\n        ActionBar actionBar = getActionBar();\n        actionBar.setDisplayHomeAsUpEnabled(true);\n        actionBar.setHomeButtonEnabled(true);\n\n        // ActionBarDrawerToggle ties together the the proper interactions\n        // between the navigation drawer and the action bar app icon.\n        mDrawerToggle = new ActionBarDrawerToggle(\n                getActivity(),                    /* host Activity */\n                mDrawerLayout,                    /* DrawerLayout object */\n                R.drawable.ic_drawer,             /* nav drawer image to replace 'Up' caret */\n                R.string.navigation_drawer_open,  /* \"open drawer\" description for accessibility */\n                R.string.navigation_drawer_close  /* \"close drawer\" description for accessibility */\n        ) {\n            @Override\n            public void onDrawerClosed(View drawerView) {\n                super.onDrawerClosed(drawerView);\n                if (!isAdded()) {\n                    return;\n                }\n\n                getActivity().invalidateOptionsMenu(); // calls onPrepareOptionsMenu()\n            }\n\n            @Override\n            public void onDrawerOpened(View drawerView) {\n                super.onDrawerOpened(drawerView);\n                if (!isAdded()) {\n                    return;\n                }\n\n                if (!mUserLearnedDrawer) {\n                    // The user manually opened the drawer; store this flag to prevent auto-showing\n                    // the navigation drawer automatically in the future.\n                    mUserLearnedDrawer = true;\n                    SharedPreferences sp = PreferenceManager\n                            .getDefaultSharedPreferences(getActivity());\n                    sp.edit().putBoolean(PREF_USER_LEARNED_DRAWER, true).apply();\n                }\n\n                getActivity().invalidateOptionsMenu(); // calls onPrepareOptionsMenu()\n            }\n        };\n\n        // If the user hasn't 'learned' about the drawer, open it to introduce them to the drawer,\n        // per the navigation drawer design guidelines.\n        if (!mUserLearnedDrawer && !mFromSavedInstanceState) {\n            mDrawerLayout.openDrawer(mFragmentContainerView);\n        }\n\n        // Defer code dependent on restoration of previous instance state.\n        mDrawerLayout.post(new Runnable() {\n            @Override\n            public void run() {\n                mDrawerToggle.syncState();\n            }\n        });\n\n        mDrawerLayout.setDrawerListener(mDrawerToggle);\n    }\n\n    private void selectItem(int position) {\n        mCurrentSelectedPosition = position;\n        if (mDrawerListView != null) {\n            mDrawerListView.setItemChecked(position, true);\n        }\n        if (mDrawerLayout != null) {\n            mDrawerLayout.closeDrawer(mFragmentContainerView);\n        }\n        if (mCallbacks != null) {\n            mCallbacks.onNavigationDrawerItemSelected(position);\n        }\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n        try {\n            mCallbacks = (NavigationDrawerCallbacks) activity;\n        } catch (ClassCastException e) {\n            throw new ClassCastException(\"Activity must implement NavigationDrawerCallbacks.\");\n        }\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n        mCallbacks = null;\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(STATE_SELECTED_POSITION, mCurrentSelectedPosition);\n    }\n\n    @Override\n    public void onConfigurationChanged(Configuration newConfig) {\n        super.onConfigurationChanged(newConfig);\n        // Forward the new configuration the drawer toggle component.\n        mDrawerToggle.onConfigurationChanged(newConfig);\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        if (mDrawerToggle.onOptionsItemSelected(item)) {\n            return true;\n        }\n        return super.onOptionsItemSelected(item);\n    }\n\n    /**\n     * Per the navigation drawer design guidelines, updates the action bar to show the global app\n     * 'context', rather than just what's in the current screen.\n     */\n    private void showGlobalContextActionBar() {\n        ActionBar actionBar = getActionBar();\n        actionBar.setDisplayShowTitleEnabled(true);\n        actionBar.setNavigationMode(ActionBar.NAVIGATION_MODE_STANDARD);\n        actionBar.setTitle(R.string.app_name);\n    }\n\n    private ActionBar getActionBar() {\n        return getActivity().getActionBar();\n    }\n\n    /**\n     * Callbacks interface that all activities using this fragment must implement.\n     */\n    public static interface NavigationDrawerCallbacks {\n        /**\n         * Called when an item in the navigation drawer is selected.\n         */\n        void onNavigationDrawerItemSelected(int position);\n    }\n}\n", "mport java.util.regex.Pattern;\n\n/**\n * @author Marco Behler <marco@marcobehler.com>\n */\n@Getter\npublic class TemplateContent {\n\n    private static final Pattern pattern = Pattern.compile(\"---(.*)---(.*)\", Pattern.DOTALL);\n\n    private final String text;\n\n    public TemplateContent(String text) {\n        this.text = text;\n    }\n\n\n    public static TemplateContent of(final String content) {\n        if (content == null) {\n            return new TemplateContent(\"\");\n        }\n\n        Matcher matcher = pattern.matcher(content);\n        if (!matcher.find()) {\n            return new TemplateContent(\"\");\n        }\n\n        String text = matcher.group(2).trim();\n        return new TemplateContent(text);\n    }\n}\n", "or;\nimport java.util.List;\nimport java.util.function.Function;\n\n/**\n * Comparator: Step by step code improvement in Java 8 way\n * \n * @author tirthalp\n *\n */\npublic class Ex02_Comparator {\t\n\t\n\tpublic static void main(String[] args) {\t\t\n\t\tbeforeJava8(Person.PERSONS_LIST);\t\t\n\t\tjava8way(Person.PERSONS_LIST);\n\t}\n\n\t// ---> STEP 1: Prior to Java 8 coding style\n\tprivate static void beforeJava8(List<Person> persons) {\n\t\t// Sort by age\t\t\n\t\tComparator<Person> cmpByAge = new Comparator<Person>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Person p1, Person p2) {\n\t\t\t\t\n\t\t\t\treturn Integer.compare(p1.getAge(), p2.getAge());\n\t\t\t}\n\t\t};\t\t\n\t\tCollections.sort(persons, cmpByAge);\t\t\n\t\tSystem.out.println(\"Before Java 8 - sort by age:\"+persons);\n\t\t\n\t\t// Sort by first name\n\t\tComparator<Person> cmpByFirstName = new Comparator<Person>() {\n\n\t\t\t@Override\n\t\t\tpublic int compare(Person p1, Person p2) {\n\t\t\t\t\n\t\t\t\treturn p1.getFirstName().compareTo(p2.getFirstName());\n\t\t\t}\n\t\t};\t\t\n\t\tCollections.sort(persons, cmpByFirstName);\t\t\n\t\tSystem.out.println(\"Before Java 8 - sort by first name:\"+persons);\n\t}\n\t\n\tprivate static void java8way(List<Person> persons) {\n\t\t\n\t\t// ---> STEP 2: Using Java 8 Lambda expression \n\t\t\n\t\t// Sort by age\t\n\t\tComparator<Person> cmpByAge = (p1, p2) -> { return p1.getAge() - p2.getAge(); };\n\t\tCollections.sort(persons, cmpByAge);\t\t\n\t\tSystem.out.println(\"Java 8 way - sort by age: \"+persons);\n\n\t\t// Sort by first name\n\t\tComparator<Person> cmpByFirstName = (p1, p2) -> { return p1.getFirstName().compareTo(p2.getFirstName()); };\n\t\tCollections.sort(persons, cmpByFirstName);\t\t\n\t\tSystem.out.println(\"Java 8 way - sort by first name: \"+persons);\n\t\t\n\t\t// ---> STEP 3: Further code improvement possible?\n\t\t\n\t\t// Yes, using Function \t\t\n\t\tFunction<Person, Integer> f = p -> p.getAge(); \n\t\tCollections.sort(persons, Comparator.comparing(f));\n\t\tSystem.out.println(\"Java 8 way of using function - sort by age: \"+persons);\n\t\t\n\t\t// Rather, static method reference syntax looks awesome\n\t\tCollections.sort(persons, Comparator.comparing(Person::getFirstName));\n\t\tSystem.out.println(\"Java 8 way of using static method reference - sort by first name: \"+persons);\n\t\t\n\t\t// --->  How to compare by age followed by first name followed by last name?\n\t\t\n\t\t// Well, usage of chaining pattern with Comparator.thenComparing \n\t\t\n\t\tCollections.sort(persons, Comparator.comparing(Person::getAge)\n\t\t\t\t\t\t\t\t\t\t\t.thenComparing(Person::getFirstName)\n\t\t\t\t\t\t\t\t\t\t\t.thenComparing(Person::getLastName)); // chaining pattern \n\t\tSystem.out.println(\"Java 8 way of using chaining pattern in Comparator - sort by age, first name and last name: \"+persons);\n\t}\t\t\n}\n", "ngframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.ResponseBody;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.List;\n\n@RestController\npublic class UploadController {\n\n    private UploadRepository repository;\n\n    @Autowired\n    public UploadController(UploadRepository repository) {\n        this.repository = repository;\n    }\n\n    @RequestMapping(value = \"/{id}\", method = RequestMethod.GET)\n    public ResponseEntity<UploadData> get(@PathVariable(\"id\") Long id) {\n        UploadData user = repository.findOne(id);\n        if (null == user) {\n            return new ResponseEntity<UploadData>(HttpStatus.NOT_FOUND);\n        }\n        return new ResponseEntity<UploadData>(user, HttpStatus.OK);\n    }\n\n    @RequestMapping(value = \"/add\", method = RequestMethod.POST)\n    public ResponseEntity<UploadData> update(@RequestBody UploadData user) {\n        repository.save(user);\n        return get(user.getId());\n    }\n\n    @RequestMapping(value = \"/result\", method = RequestMethod.GET)\n    public List<UploadData> all() {\n        return repository.findAll();\n    }\n\n    @RequestMapping(\"/datacheck\")\n    @ResponseBody\n    String data() {\n        return \"check data\";\n    }\n}", "mport android.util.FloatMath;\nimport android.view.ViewConfiguration;\nimport android.view.animation.AnimationUtils;\nimport android.view.animation.Interpolator;\n\n\n/**\n * This class encapsulates scrolling.  The duration of the scroll\n * can be passed in the constructor and specifies the maximum time that\n * the scrolling animation should take.  Past this time, the scrolling is \n * automatically moved to its final stage and computeScrollOffset()\n * will always return false to indicate that scrolling is over.\n */\npublic class Scroller  {\n    private int mMode;\n\n    private int mStartX;\n    private int mStartY;\n    private int mFinalX;\n    private int mFinalY;\n\n    private int mMinX;\n    private int mMaxX;\n    private int mMinY;\n    private int mMaxY;\n\n    private int mCurrX;\n    private int mCurrY;\n    private long mStartTime;\n    private int mDuration;\n    private float mDurationReciprocal;\n    private float mDeltaX;\n    private float mDeltaY;\n    private boolean mFinished;\n    private Interpolator mInterpolator;\n    private boolean mFlywheel;\n\n    private float mVelocity;\n\n    private static final int DEFAULT_DURATION = 250;\n    private static final int SCROLL_MODE = 0;\n    private static final int FLING_MODE = 1;\n\n    private static float DECELERATION_RATE = (float) (Math.log( 0.75 ) / Math.log( 0.9 ));\n    private static float ALPHA = 800; // pixels / seconds\n    private static float START_TENSION = 0.4f; // Tension at start: (0.4 * total T, 1.0 * Distance)\n    private static float END_TENSION = 1.0f - START_TENSION;\n    private static final int NB_SAMPLES = 100;\n    private static final float[] SPLINE = new float[NB_SAMPLES + 1];\n\n    private float mDeceleration;\n    private final float mPpi;\n\n    static {\n        float x_min = 0.0f;\n        for (int i = 0; i <= NB_SAMPLES; i++) {\n            final float t = (float) i / NB_SAMPLES;\n            float x_max = 1.0f;\n            float x, tx, coef;\n            while (true) {\n                x = x_min + (x_max - x_min) / 2.0f;\n                coef = 3.0f * x * (1.0f - x);\n                tx = coef * ((1.0f - x) * START_TENSION + x * END_TENSION) + x * x * x;\n                if (Math.abs( tx - t ) < 1E-5) break;\n                if (tx > t) x_max = x;\n                else x_min = x;\n            }\n            final float d = coef + x * x * x;\n            SPLINE[i] = d;\n        }\n        SPLINE[NB_SAMPLES] = 1.0f;\n\n        // This controls the viscous fluid effect (how much of it)\n        sViscousFluidScale = 8.0f;\n        // must be set to 1.0 (used in viscousFluid())\n        sViscousFluidNormalize = 1.0f;\n        sViscousFluidNormalize = 1.0f / viscousFluid(1.0f);\n    }\n\n    private static float sViscousFluidScale;\n    private static float sViscousFluidNormalize;\n\n    /**\n     * Create a Scroller with the default duration and interpolator.\n     */\n    public Scroller(Context context) {\n        this(context, null);\n    }\n\n    public Scroller(Context context, Interpolator interpolator) {\n        mFinished = true;\n        mInterpolator = interpolator;\n        mPpi = context.getResources().getDisplayMetrics().density * 160.0f;\n        mDeceleration = computeDeceleration( ViewConfiguration.getScrollFriction());\n    }\n\n    /**\n     * The amount of friction applied to flings. The default value\n     * is {@link ViewConfiguration#getScrollFriction}.\n     * \n     * @param friction A scalar dimension-less value representing the coefficient of\n     *         friction.\n     */\n    public final void setFriction(float friction) {\n        mDeceleration = computeDeceleration(friction);\n    }\n    \n    private float computeDeceleration(float friction) {\n        return SensorManager.GRAVITY_EARTH   // g (m/s^2)\n                      * 39.37f               // inch/meter\n                      * mPpi                 // pixels per inch\n                      * friction;\n    }\n\n    /**\n     * \n     * Returns whether the scroller has finished scrolling.\n     * \n     * @return True if the scroller has finished scrolling, false otherwise.\n     */\n    public final boolean isFinished() {\n        return mFinished;\n    }\n    \n    /**\n     * Force the finished field to a particular value.\n     *  \n     * @param finished The new finished value.\n     */\n    public final void forceFinished(boolean finished) {\n        mFinished = finished;\n    }\n    \n    /**\n     * Returns how long the scroll event will take, in milliseconds.\n     * \n     * @return The duration of the scroll in milliseconds.\n     */\n    public final int getDuration() {\n        return mDuration;\n    }\n    \n    /**\n     * Returns the current X offset in the scroll. \n     * \n     * @return The new X offset as an absolute distance from the origin.\n     */\n    public final int getCurrX() {\n        return mCurrX;\n    }\n    \n    /**\n     * Returns the current Y offset in the scroll. \n     * \n     * @return The new Y offset as an absolute distance from the origin.\n     */\n    public final int getCurrY() {\n        return mCurrY;\n    }\n    \n    /**\n     * Returns the current velocity.\n     *\n     * @return The original velocity less the deceleration. Result may be\n     * negative.\n     */\n    public float getCurrVelocity() {\n        return mVelocity - mDeceleration * timePassed() / 2000.0f;\n    }\n\n    /**\n     * Returns the start X offset in the scroll. \n     * \n     * @return The start X offset as an absolute distance from the origin.\n     */\n    public final int getStartX() {\n        return mStartX;\n    }\n    \n    /**\n     * Returns the start Y offset in the scroll. \n     * \n     * @return The start Y offset as an absolute distance from the origin.\n     */\n    public final int getStartY() {\n        return mStartY;\n    }\n    \n    /**\n     * Returns where the scroll will end. Valid only for \"fling\" scrolls.\n     * \n     * @return The final X offset as an absolute distance from the origin.\n     */\n    public final int getFinalX() {\n        return mFinalX;\n    }\n    \n    /**\n     * Returns where the scroll will end. Valid only for \"fling\" scrolls.\n     * \n     * @return The final Y offset as an absolute distance from the origin.\n     */\n    public final int getFinalY() {\n        return mFinalY;\n    }\n\n    /**\n     * Call this when you want to know the new location.  If it returns true,\n     * the animation is not yet finished.  loc will be altered to provide the\n     * new location.\n     */ \n    public boolean computeScrollOffset() {\n        if (mFinished) {\n            return false;\n        }\n\n        int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);\n    \n        if (timePassed < mDuration) {\n            switch (mMode) {\n            case SCROLL_MODE:\n                float x = timePassed * mDurationReciprocal;\n    \n                if (mInterpolator == null)\n                    x = viscousFluid(x); \n                else\n                    x = mInterpolator.getInterpolation(x);\n    \n                mCurrX = mStartX + Math.round( x * mDeltaX );\n                mCurrY = mStartY + Math.round( x * mDeltaY );\n                break;\n            case FLING_MODE:\n                final float t = (float) timePassed / mDuration;\n                final int index = (int) (NB_SAMPLES * t);\n                final float t_inf = (float) index / NB_SAMPLES;\n                final float t_sup = (float) (index + 1) / NB_SAMPLES;\n                final float d_inf = SPLINE[index];\n                final float d_sup = SPLINE[index + 1];\n                final float distanceCoef = d_inf + (t - t_inf) / (t_sup - t_inf) * (d_sup - d_inf);\n                \n                mCurrX = mStartX + Math.round( distanceCoef * (mFinalX - mStartX) );\n                // Pin to mMinX <= mCurrX <= mMaxX\n                mCurrX = Math.min( mCurrX, mMaxX );\n                mCurrX = Math.max( mCurrX, mMinX );\n                \n                mCurrY = mStartY + Math.round( distanceCoef * (mFinalY - mStartY) );\n                // Pin to mMinY <= mCurrY <= mMaxY\n                mCurrY = Math.min( mCurrY, mMaxY );\n                mCurrY = Math.max( mCurrY, mMinY );\n\n                if (mCurrX == mFinalX && mCurrY == mFinalY) {\n                    mFinished = true;\n                }\n\n                break;\n            }\n        }\n        else {\n            mCurrX = mFinalX;\n            mCurrY = mFinalY;\n            mFinished = true;\n        }\n        return true;\n    }\n    \n    /**\n     * Start scrolling by providing a starting point and the distance to travel.\n     * The scroll will use the default value of 250 milliseconds for the\n     * duration.\n     * \n     * @param startX Starting horizontal scroll offset in pixels. Positive\n     *        numbers will scroll the content to the left.\n     * @param startY Starting vertical scroll offset in pixels. Positive numbers\n     *        will scroll the content up.\n     * @param dx Horizontal distance to travel. Positive numbers will scroll the\n     *        content to the left.\n     * @param dy Vertical distance to travel. Positive numbers will scroll the\n     *        content up.\n     */\n    public void startScroll(int startX, int startY, int dx, int dy) {\n        startScroll(startX, startY, dx, dy, DEFAULT_DURATION);\n    }\n\n    /**\n     * Start scrolling by providing a starting point and the distance to travel.\n     * \n     * @param startX Starting horizontal scroll offset in pixels. Positive\n     *        numbers will scroll the content to the left.\n     * @param startY Starting vertical scroll offset in pixels. Positive numbers\n     *        will scroll the content up.\n     * @param dx Horizontal distance to travel. Positive numbers will scroll the\n     *        content to the left.\n     * @param dy Vertical distance to travel. Positive numbers will scroll the\n     *        content up.\n     * @param duration Duration of the scroll in milliseconds.\n     */\n    public void startScroll(int startX, int startY, int dx, int dy, int duration) {\n        mMode = SCROLL_MODE;\n        mFinished = false;\n        mDuration = duration;\n        mStartTime = AnimationUtils.currentAnimationTimeMillis();\n        mStartX = startX;\n        mStartY = startY;\n        mFinalX = startX + dx;\n        mFinalY = startY + dy;\n        mDeltaX = dx;\n        mDeltaY = dy;\n        mDurationReciprocal = 1.0f / (float) mDuration;\n    }\n\n    /**\n     * Start scrolling based on a fling gesture. The distance travelled will\n     * depend on the initial velocity of the fling.\n     * \n     * @param startX Starting point of the scroll (X)\n     * @param startY Starting point of the scroll (Y)\n     * @param velocityX Initial velocity of the fling (X) measured in pixels per\n     *        second.\n     * @param velocityY Initial velocity of the fling (Y) measured in pixels per\n     *        second\n     * @param minX Minimum X value. The scroller will not scroll past this\n     *        point.\n     * @param maxX Maximum X value. The scroller will not scroll past this\n     *        point.\n     * @param minY Minimum Y value. The scroller will not scroll past this\n     *        point.\n     * @param maxY Maximum Y value. The scroller will not scroll past this\n     *        point.\n     */\n    public void fling(int startX, int startY, int velocityX, int velocityY,\n            int minX, int maxX, int minY, int maxY) {\n        // Continue a scroll or fling in progress\n        if (mFlywheel && !mFinished) {\n            float oldVel = getCurrVelocity();\n\n            float dx = (float) (mFinalX - mStartX);\n            float dy = (float) (mFinalY - mStartY);\n            float hyp = FloatMath.sqrt( dx * dx + dy * dy );\n\n            float ndx = dx / hyp;\n            float ndy = dy / hyp;\n\n            float oldVelocityX = ndx * oldVel;\n            float oldVelocityY = ndy * oldVel;\n            if (Math.signum( velocityX ) == Math.signum( oldVelocityX ) &&\n                    Math.signum( velocityY ) == Math.signum( oldVelocityY )) {\n                velocityX += oldVelocityX;\n                velocityY += oldVelocityY;\n            }\n        }\n\n        mMode = FLING_MODE;\n        mFinished = false;\n\n        float velocity = FloatMath.sqrt( velocityX * velocityX + velocityY * velocityY );\n     \n        mVelocity = velocity;\n        final double l = Math.log( START_TENSION * velocity / ALPHA );\n        mDuration = (int) (1000.0 * Math.exp( l / (DECELERATION_RATE - 1.0) ));\n        mStartTime = AnimationUtils.currentAnimationTimeMillis();\n        mStartX = startX;\n        mStartY = startY;\n\n        float coeffX = velocity == 0 ? 1.0f : velocityX / velocity;\n        float coeffY = velocity == 0 ? 1.0f : velocityY / velocity;\n\n        int totalDistance =\n                (int) (ALPHA * Math.exp( DECELERATION_RATE / (DECELERATION_RATE - 1.0) * l ));\n        \n        mMinX = minX;\n        mMaxX = maxX;\n        mMinY = minY;\n        mMaxY = maxY;\n\n        mFinalX = startX + Math.round( totalDistance * coeffX );\n        // Pin to mMinX <= mFinalX <= mMaxX\n        mFinalX = Math.min( mFinalX, mMaxX );\n        mFinalX = Math.max( mFinalX, mMinX );\n        \n        mFinalY = startY + Math.round( totalDistance * coeffY );\n        // Pin to mMinY <= mFinalY <= mMaxY\n        mFinalY = Math.min( mFinalY, mMaxY );\n        mFinalY = Math.max( mFinalY, mMinY );\n    }\n    \n    static float viscousFluid(float x)\n    {\n        x *= sViscousFluidScale;\n        if (x < 1.0f) {\n            x -= (1.0f - (float) Math.exp( -x ));\n        } else {\n            float start = 0.36787944117f;   // 1/e == exp(-1)\n            x = 1.0f - (float) Math.exp( 1.0f - x );\n            x = start + x * (1.0f - start);\n        }\n        x *= sViscousFluidNormalize;\n        return x;\n    }\n    \n    /**\n     * Stops the animation. Contrary to {@link #forceFinished(boolean)},\n     * aborting the animating cause the scroller to move to the final x and y\n     * position\n     *\n     * @see #forceFinished(boolean)\n     */\n    public void abortAnimation() {\n        mCurrX = mFinalX;\n        mCurrY = mFinalY;\n        mFinished = true;\n    }\n    \n    /**\n     * Extend the scroll animation. This allows a running animation to scroll\n     * further and longer, when used with {@link #setFinalX(int)} or {@link #setFinalY(int)}.\n     *\n     * @param extend Additional time to scroll in milliseconds.\n     * @see #setFinalX(int)\n     * @see #setFinalY(int)\n     */\n    public void extendDuration(int extend) {\n        int passed = timePassed();\n        mDuration = passed + extend;\n        mDurationReciprocal = 1.0f / mDuration;\n        mFinished = false;\n    }\n\n    /**\n     * Returns the time elapsed since the beginning of the scrolling.\n     *\n     * @return The elapsed time in milliseconds.\n     */\n    public int timePassed() {\n        return (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);\n    }\n\n    /**\n     * Sets the final position (X) for this scroller.\n     *\n     * @param newX The new X offset as an absolute distance from the origin.\n     * @see #extendDuration(int)\n     * @see #setFinalY(int)\n     */\n    public void setFinalX(int newX) {\n        mFinalX = newX;\n        mDeltaX = mFinalX - mStartX;\n        mFinished = false;\n    }\n\n    /**\n     * Sets the final position (Y) for this scroller.\n     *\n     * @param newY The new Y offset as an absolute distance from the origin.\n     * @see #extendDuration(int)\n     * @see #setFinalX(int)\n     */\n    public void setFinalY(int newY) {\n        mFinalY = newY;\n        mDeltaY = mFinalY - mStartY;\n        mFinished = false;\n    }\n\n    /**\n     * @hide\n     */\n    public boolean isScrollingInDirection(float xvel, float yvel) {\n        return !mFinished && Math.signum( xvel ) == Math.signum( mFinalX - mStartX ) &&\n                Math.signum( yvel ) == Math.signum( mFinalY - mStartY );\n    }\n}\n", "lists.U32Vector;\n\n/**\n * The purpose of this class is to maintain an ordered set of line offsets for an\n * SwtCharBuffer. \n * <p>\n * With a LineOffsets instance it's possible to map from the number of a line to the text\n * position where it begins, and back, reasonably fast. \n * (O(1) for line number to line offset, O(log(#lines)) for line offset to line number)\n * <p>\n * LineOffsets extends U32Vector with a GapManager, allowing new line offsets\n * to be inserted quickly during normal text typing.\n * <p>\n * Instances of SwtCharBuffer should hold an instance LineOffsets class and notify it whenever the it's text changes.\n * The notification happens through the methods: \n * <p>\n * <ul>  \n *   <li>\n *     textRegionMoved, which should be called when the gap (of SwtCharBuffer) changes \n *     (position or size). \n *   </li>\n *   <li>\n *     textInserted.\n *   </li>\n *   <li>\n *     textDeleted. \n *   </li>\n * </ul> \n * <p>\n * <p>\n * \n * TODO: decouple this, using a more general event model..\n * \n * Assume that lineOffset is an instance of LineOffsets, held by swtCharBuffer an instance of \n * SwtCharBuffer. \n * <p>\n * Then a value of {@code o} at index {@code i} in lineOffsets.base\n * means that the line with line number\n * {@code n = (i < lOff.gapStart ? i : i + lOff.gapEnd - lOff.gapStart)}\n * <p>\n * starts at text position \n * {@code p = (o < swtCB.gapStart ? o : o + swtCB.gapEnd - swtCB.gapStart)}\n * <p>\n * @author Christian Surlykke\n *         12-07-2004\n */\npublic class LineOffsets extends U32Vector\n{\n  private static Pattern newLinePattern = Pattern.compile(\"\\n|\\r\\n|\\r\"); // We recognize all the usual forms of \n                                                                         // linedelimiters\n\n  public LineOffsets(int initialSize)\n  {\n    super(Math.max(101, initialSize));\n    insertLine(0, 0); // Line 0 allways starts at position 0 -\n                      // even if the text is just the empty string\n  }\n  \n  private void setOffset(int index, int Offset)\n  {\n    setIntAt(index, Offset);\n  }\n\n  private int getOffset(int index)\n  {\n    return getInt(index);\n  }\n\n  public void insertLine(int index, int offSet)\n  {\n    addSpace(index, 1);\n    setIntAt(index, offSet);\n  }\n\n  public int index2offset(int index) \n  {\n    return offsets.getInt(index); \n  }\n  \n  /**\n   * We seek the line containing a given text offset using a halfing of intervals algorithm. Therefore\n   * the method will use O(log(n)) time, n being the number of lines. \n   */\n  public int offset2index(int offset)\n  {\n    // Adhoc optimization: Very often this class will be asked for the line index belonging to the point\n    // where insertion happens, i.e. at the start of the gap. \n    // We try this before the full search so that we may return in O(1) time in this case.\n    int gapStart = getGapStart();\n    try \n    {\n      if (index2offset(gapStart - 1) <= offset && index2offset(gapStart) > offset)\n      {\n        return gapStart - 1;\n      }\n    }\n    catch (IndexOutOfBoundsException e)\n    { \n    }\n    \n    // The normal search\n    int intervalStart = 0;\n    int intervalEnd = size();\n  \n    // Invariant: offset(intervalStart) <= offset AND offset(intervalEnd) > offset\n    while (intervalEnd > intervalStart + 1) \n    {\n      int middle = (intervalStart + intervalEnd) / 2;\n      if (index2offset(middle) <= offset) \n      {\n        intervalStart = middle;\n      }\n      else \n      {\n        intervalEnd = middle;\n      }\n    }\n    \n    return intervalStart;\n  }\n\n  public void deleteLines(int firstLine, int numberOfLines)\n  {\n    if (numberOfLines > 0)\n    {\n      int pos = createPos(firstLine, false);\n      removePos(pos, numberOfLines);\n      releasePos(pos);\n    }\n  }\n\n  public void insertLines(int index, int[] offsets)\n  {\n    if (offsets != null && offsets.length > 0)\n    {\n      // The offsets should comply with:\n      // 0 <= offset[i] < offset[j] for 0 <= i < j\n      // \n      \n      // TOCONSIDER: \n      // Maybe we should define an exception of our own here?\n      \n      if (index2offset(index) > offsets[0])\n      {\n        throw new IllegalArgumentException();\n      }\n      \n      if (index < size() && offsets[offsets.length - 1] > index2offset(index + 1))\n      {\n        throw new IllegalArgumentException();\n      }\n      \n      for(int i = 0; i < offsets.length -1; i++)\n      {\n        if (offsets[i] > offsets[i + 1])\n        {\n          throw new IllegalArgumentException();\n        }\n      }\n      \n      gapReserve(index + 1, offsets.length);\n      System.arraycopy(offsets, 0, offsets, index + 1, offsets.length);\n    }\n  }\n  \n  public String toString()\n  {\n    StringBuffer sbuf = new StringBuffer();\n    int gapStart = getGapStart();\n    sbuf.append(\"Lines: {\" + size() + \", \" + gapStart);\n    sbuf.append(\" [\");\n    for (int i = 0; i < size(); i++) \n    { \n      if (i == gapStart)\n      {\n        sbuf.append(\"|\");\n      }\n      sbuf.append(offsets.getInt(i));\n      \n      if (i < size() - 1) \n      {\n        sbuf.append(\" \");\n      }\n    }\n    sbuf.append(\"]}\");\n    return sbuf.toString();\n    \n  }\n\n  public int countLines(String newText)\n  {\n    Matcher m = newLinePattern.matcher(newText);\n    int i = 0;\n    while (m.find())\n    {\n      i++;\n    }\n    return i;\n  }\n\n  public int linesInRange(int startOffset, int endOffset)\n  {\n    int indexOfStart = offset2index(startOffset);\n    int indexOfEnd = offset2index(endOffset);\n    return indexOfEnd - indexOfStart;\n  }\n\n  public void textRegionMoved(int regionStart, int regionEnd, int displacement)\n  {\n    int firstIndexToUpdate = offset2index(regionStart) + 1;\n    int lastIndexToUpdate = offset2index(regionEnd);\n    for (int index = firstIndexToUpdate; index <= lastIndexToUpdate; index++)\n    {\n      setOffset(index, getOffset(index) + displacement);\n    }\n  }\n\n  public void textInserted(int startOffset, CharSequence seq)\n  {\n    int index = offset2index(startOffset);\n    for (Matcher m = newLinePattern.matcher(seq); m.find(); )\n    {\n      insertLine(++index, startOffset + m.end());\n    }\n  }\n\n  public void textDeleted(int startOffset, int endOffset)\n  {\n    int index1 = offset2index(startOffset);\n    int index2 = index1;\n    int sz = size();\n    while (index2 < sz && getInt(index2) <= endOffset)\n        index2++;\n    delete(index1, index2);\n  }\n\n  public boolean isLineDelimiter(char c)\n  {\n    // TODO Auto-generated method stub\n    return c == '\\n' || c == '\\r';\n  }\n}\n", "WoVPreferences {\n    public static final String GCM_SENT_TOKEN_TO_SERVER = \"GCM_SENT_TOKEN_TO_SERVER\";\n    public static final String GCM_REGISTRATION_COMPLETE = \"GCM_REGISTRATION_COMPLETE\";\n    public static final String REPLAY_GAME_ID = \"replayGameId\";\n    public static final String REPLAY_GAME_TURN = \"replayGameTurn\";\n    public static final String TURN_BROADCAST = \"turnBroadcast\";\n    public static final String TURN_BUNDLE = \"turnBundle\";\n    public static final String GAME_LOADED_FROM_SERVER_BROADCAST = \"gameLoadedFromServerBroadcast\";\n    public static final String GAME_BUNDLE = \"gameBundle\";\n    public static final String GAME_JSON_DATA = \"gameJsonData\";\n\n    public static final int OPPONENT_BOT = 0;\n    public static final int OPPONENT_LOCAL_PLAYER = 1;\n    public static final int OPPONENT_NETWORK_PLAYER = 2;\n    public static final int OPPONENT_RESTORED_GAME = 3;\n\n    public static final String OPPONENT_TYPE = \"OPPONENT_TYPE\";\n    public static final String CURRENT_USER_ID = \"currentUserID\";\n    public static final String PREFERENCES = \"Preferences\";\n\n    public static final int DEFAULT_ZERO_COLOR = 210;\n    public static final int DEFAULT_CROSS_COLOR = 30;\n\n    public static final String AI_NICKNAME_STR = \"SkyNet\";\n    public static final int AI_NICKNAME_ID = 1;\n    public static final String AI_GOOGLE_TOKEN = \"uniqueGoogleTokenForAiPlayer\";\n\n    public static final String ANONYMOUS_GOOGLE_TOKEN = \"uniqueGoogleTokenForAnonymousPlayer\";\n    public static final String ANONYMOUS_NICKNAME_STR = \"Anonymous\";\n    public static final int ANONYMOUS_NICKNAME_ID = 1;\n}\n", "e;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class DefaultDataCollector implements CollectorInterface {\n\n    private ProfilerRequest profilerRequest;\n\n    @Nullable\n    public String getController() {\n        return this.getStringValue(this.profilerRequest.getContent(), \"_controller\\\";s:(\\\\d+):\");\n    }\n\n    @Nullable\n    public String getRoute() {\n        return this.getStringValue(this.profilerRequest.getContent(), \"_route\\\";s:(\\\\d+):\");\n    }\n\n    @Nullable\n    public String getStatusCode() {\n        return this.pregMatch(this.profilerRequest.getContent(), \"status_code\\\";i:(\\\\d+);\");\n    }\n\n    @Nullable\n    public String getTemplate() {\n        return this.pregMatch(this.profilerRequest.getContent(), \"\\\"template.twig \\\\(([^\\\"]*\\\\.html\\\\.\\\\w{2,4})\\\\)\\\"\");\n    }\n    @Nullable\n    protected String pregMatch(@Nullable String content, String regular) {\n        if(content == null) {\n            return null;\n        }\n\n        Matcher matcher = Pattern.compile(regular, Pattern.MULTILINE).matcher(content);\n        while(matcher.find()){\n            return matcher.group(1);\n        }\n\n        return null;\n\n    }\n\n    @Nullable\n    protected String getStringValue(@Nullable String content, String regular) {\n        if(content == null) {\n            return null;\n        }\n\n        Matcher matcher = Pattern.compile(regular, Pattern.MULTILINE).matcher(content);\n        while(matcher.find()){\n            String domain = matcher.group(1);\n            //String array_strings = matcher.group(2);\n\n            int start = matcher.end();\n            int end = start + Integer.parseInt(domain);\n\n            return content.substring(start + 1, end + 1);\n\n        }\n\n        return null;\n\n    }\n\n    @Override\n    public void setProfilerRequest(ProfilerRequest profilerRequest) {\n        this.profilerRequest = profilerRequest;\n    }\n}\n", "to-generated method stub\n\t\tScanner scn = new Scanner(System.in);\n\t\tSystem.out.print(\"\u00bd\u00d0\u00bf\u00e9\u00a4JA\u00ad\u00c8\");\n\t\tint a = scn.nextInt();\n\t\tSystem.out.print(\"\u00bd\u00d0\u00bf\u00e9\u00a4JB\u00ad\u00c8\");\n\t\tint b = scn.nextInt();\n\t\tif(a>b){\n\t\t\tSystem.out.print(a+\">\"+b);\n\t\t}else{\n\t\t\tif(a<b){\n\t\t\t\tSystem.out.print(a+\"<\"+b);\t\n\t\t\t}else{\n\t\t\t\tif(a==b){\n\t\t\t\t\tSystem.out.print(a+\"=\"+b);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n}\n\n", "nterface ILoadingFragment {\n    void show();\n\n    void hide();\n}\n", " free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage io.sponges.dubtrack4j.internal.request;\n\nimport io.sponges.dubtrack4j.internal.DubtrackAPIImpl;\nimport io.sponges.dubtrack4j.util.URL;\nimport okhttp3.Response;\nimport okhttp3.ResponseBody;\nimport org.json.JSONObject;\n\nimport java.io.IOException;\n\npublic class RemoveSongRequest implements DubRequest {\n\n    private final DubtrackAPIImpl dubtrack;\n    private final String room;\n    private final String user;\n\n    public RemoveSongRequest(DubtrackAPIImpl dubtrack, String room, String user) {\n        this.dubtrack = dubtrack;\n        this.room = room;\n        this.user = user;\n    }\n\n    @Override\n    public JSONObject request() throws IOException {\n        String url = String.format(URL.REMOVE_SONG.toString(), room, user);\n        Response response = dubtrack.getHttpRequester().delete(url);\n\n        ResponseBody body = response.body();\n        String result = body.string();\n        body.close();\n\n        return new JSONObject(result);\n    }\n\n}\n", "ension;\nimport net.nemerosa.ontrack.extension.support.AbstractExtension;\nimport net.nemerosa.ontrack.model.security.GlobalFunction;\nimport net.nemerosa.ontrack.model.security.GlobalSettings;\nimport net.nemerosa.ontrack.model.support.Action;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\n/**\n * Management of Stash configurations available in the user menu.\n */\n@Component\npublic class StashUserMenuExtension extends AbstractExtension implements UserMenuExtension {\n\n    @Autowired\n    public StashUserMenuExtension(StashExtensionFeature feature) {\n        super(feature);\n    }\n\n    @Override\n    public Class<? extends GlobalFunction> getGlobalFunction() {\n        return GlobalSettings.class;\n    }\n\n    @Override\n    public Action getAction() {\n        return Action.of(\"stash-configurations\", \"Bitbucket Server configurations\", \"configurations\");\n    }\n}\n", "ashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.eclipse.core.runtime.Assert;\nimport org.eclipse.core.runtime.AssertionFailedException;\n\nimport com.bkahlert.nebula.widgets.jointjs.JointJSCell;\nimport com.bkahlert.nebula.widgets.jointjs.JointJSElement;\nimport com.bkahlert.nebula.widgets.jointjs.JointJSLink;\nimport com.bkahlert.nebula.widgets.jointjs.JointJSLink.CoordinateEndpoint;\nimport com.bkahlert.nebula.widgets.jointjs.JointJSLink.IElementEndpoint;\nimport com.bkahlert.nebula.widgets.jointjs.JointJSLink.IEndpoint;\nimport com.bkahlert.nebula.widgets.jointjs.JointJSModel;\n\nimport de.fu_berlin.imp.apiua.core.model.URI;\n\npublic class JointJSAxialCodingModel implements IAxialCodingModel {\n\n\tpublic static interface IURIEndpoint extends IEndpoint {\n\t\tpublic URI getURI();\n\t}\n\n\tpublic static class URIEndpoint implements IURIEndpoint {\n\t\tprivate URI uri;\n\n\t\tpublic URIEndpoint(IElementEndpoint elementEndpoint) {\n\t\t\tthis.uri = new URI(elementEndpoint.getElement());\n\t\t}\n\n\t\t@Override\n\t\tpublic URI getURI() {\n\t\t\treturn this.uri;\n\t\t}\n\t}\n\n\tprivate static final long serialVersionUID = 1L;\n\tprivate final URI uri;\n\tprivate JointJSModel jointJsModel;\n\n\tprivate List<URI> codes;\n\tprivate final List<URI> codesNotInJson = new ArrayList<URI>();\n\tprivate List<URI> relations;\n\n\tpublic JointJSAxialCodingModel(URI uri, JointJSModel jointJsModel) {\n\t\ttry {\n\t\t\tAssert.isNotNull(uri);\n\t\t} catch (AssertionFailedException e) {\n\t\t\tthrow new IllegalArgumentException(e);\n\t\t}\n\t\tthis.uri = uri;\n\t\tthis.jointJsModel = jointJsModel;\n\t}\n\n\tpublic JointJSAxialCodingModel(URI uri, String json) {\n\t\tthis(uri, new JointJSModel(json));\n\t}\n\n\t@Override\n\tpublic URI getUri() {\n\t\treturn this.uri;\n\t}\n\n\t@Override\n\tpublic String getTitle() {\n\t\treturn this.jointJsModel.getTitle();\n\t}\n\n\tpublic void setTitle(String title) {\n\t\tthis.jointJsModel.setTitle(title);\n\t}\n\n\tpublic URI getOrigin() {\n\t\tString uri = this.jointJsModel.getData(\"origin\");\n\t\tif (uri != null) {\n\t\t\treturn new URI(uri);\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setOrigin(URI origin) {\n\t\tthis.jointJsModel.setData(\"origin\", origin != null ? origin.toString()\n\t\t\t\t: null);\n\t}\n\n\t@Override\n\tpublic String getTitle(URI uri) {\n\t\tString id = uri != null ? uri.toString() : null;\n\t\tJointJSCell cell = this.jointJsModel.getCell(id);\n\t\tif (cell instanceof JointJSElement) {\n\t\t\treturn ((JointJSElement) cell).getTitle();\n\t\t} else if (cell instanceof JointJSLink) {\n\t\t\treturn ((JointJSLink) cell).getTitle();\n\t\t}\n\t\treturn null;\n\t}\n\n\t@Override\n\tpublic Object getAttribute(URI uri, String key) {\n\t\tString id = uri != null ? uri.toString() : null;\n\t\tJointJSCell cell = this.jointJsModel.getCell(id);\n\t\treturn cell != null ? cell.getAttribute(key) : null;\n\t}\n\n\tpublic IEndpoint getEndpoint(URI uri, String endpointName) {\n\t\tObject endpointAttribute = this.getAttribute(uri, endpointName);\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tIEndpoint endpoint = JointJSLink\n\t\t\t\t.createEndpoint((HashMap<String, Object>) endpointAttribute);\n\t\treturn endpoint instanceof CoordinateEndpoint ? (CoordinateEndpoint) endpoint\n\t\t\t\t: new URIEndpoint((IElementEndpoint) endpoint);\n\t}\n\n\t@Override\n\tpublic IEndpoint getSource(URI uri) {\n\t\treturn this.getEndpoint(uri, \"source\");\n\t}\n\n\t@Override\n\tpublic IEndpoint getTarget(URI uri) {\n\t\treturn this.getEndpoint(uri, \"target\");\n\t}\n\n\t@Override\n\tpublic List<URI> getCodes() {\n\t\tif (this.codes == null) {\n\t\t\tthis.codes = new ArrayList<URI>();\n\t\t\tfor (JointJSElement element : this.jointJsModel.getElements()) {\n\t\t\t\tString id = element.getId();\n\t\t\t\tURI uri = id != null ? new URI(id) : null;\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tthis.codes.add(uri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tList<URI> codes = new ArrayList<URI>();\n\t\tcodes.addAll(this.codes);\n\t\tcodes.addAll(this.codesNotInJson);\n\t\treturn codes;\n\t}\n\n\t@Override\n\tpublic List<URI> getRelations() {\n\t\tif (this.relations == null) {\n\t\t\tthis.relations = new ArrayList<URI>();\n\t\t\tfor (JointJSLink link : this.jointJsModel.getLinks()) {\n\t\t\t\tString id = link.getId();\n\t\t\t\tURI uri = id != null ? new URI(id) : null;\n\t\t\t\tif (uri != null) {\n\t\t\t\t\tthis.relations.add(uri);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.relations;\n\t}\n\n\t@Override\n\tpublic IAxialCodingModel createCopy(Map<String, Object> customize) {\n\t\treturn new JointJSAxialCodingModel(this.uri,\n\t\t\t\tthis.jointJsModel.createCopy(customize));\n\t}\n\n\t@Override\n\tpublic String serialize() {\n\t\treturn this.jointJsModel.serialize();\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn JointJSAxialCodingModel.class.getSimpleName() + \" \\\"\"\n\t\t\t\t+ this.getTitle() + \"\\\": \" + this.codes.size() + \" codes, \"\n\t\t\t\t+ this.relations.size() + \" links\";\n\t}\n\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.network.v2020_03_01.implementation;\n\nimport java.util.List;\nimport com.microsoft.azure.management.network.v2020_03_01.VirtualWanSecurityProvider;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Collection of SecurityProviders.\n */\npublic class VirtualWanSecurityProvidersInner {\n    /**\n     * List of VirtualWAN security providers.\n     */\n    @JsonProperty(value = \"supportedProviders\")\n    private List<VirtualWanSecurityProvider> supportedProviders;\n\n    /**\n     * Get list of VirtualWAN security providers.\n     *\n     * @return the supportedProviders value\n     */\n    public List<VirtualWanSecurityProvider> supportedProviders() {\n        return this.supportedProviders;\n    }\n\n    /**\n     * Set list of VirtualWAN security providers.\n     *\n     * @param supportedProviders the supportedProviders value to set\n     * @return the VirtualWanSecurityProvidersInner object itself.\n     */\n    public VirtualWanSecurityProvidersInner withSupportedProviders(List<VirtualWanSecurityProvider> supportedProviders) {\n        this.supportedProviders = supportedProviders;\n        return this;\n    }\n\n}\n", "tion;\nimport java.io.Serializable;\nimport java.io.ObjectOutputStream;\nimport java.io.ByteArrayOutputStream;\n\npublic abstract class GameObject implements Serializable {\n\n\tprotected Image image;\n\tprotected double vX, vY;\n\tprotected double direction;\n\tprotected Location location;\n\tprotected DoodleJump doodleJump;\n\tprotected int height, width, health;\n\tprotected boolean hitPlatform, shouldFall, shouldRemove, canJump;\n\t\n\tpublic GameObject(Location location, Image image, DoodleJump doodleJump) {\n\t\tthis.location = location;\n\t\tthis.image = image;\n\t\tthis.doodleJump = doodleJump;\n\t\tthis.shouldFall = true;\n\t\tthis.health = 100;\n\t}\n\n\tpublic GameObject(Location location, int width, int height, DoodleJump doodleJump) {\n\t\tthis.location = location;\n\t\tthis.width = width;\n\t\tthis.height =  height;\n\t\tthis.doodleJump = doodleJump;\n\t\tthis.shouldFall = true;\n\t\tthis.health = 100;\n\t}\n\n\tpublic abstract void draw(Graphics2D g2);\n\n\tpublic abstract void checkCollision();\n\n\tpublic abstract void checkOffScreen();\n\n\tpublic abstract void move();\n\n\tpublic Rectangle boundingRect() {\n\t\treturn new Rectangle((int) (location.x()), (int) (location.y()), (int) width, (int) height);\n\t}\n\n\tprotected boolean willMoveOffscreen() {\n\t\tLocation loc = new Location(location);\n\t\tloc.addVector(Math.atan2(vY, vX), direction);\n\t\treturn !loc.inMap(new Rectangle(doodleJump.dimensions()));\n\t}\n\n\tpublic void markRemove() {\n\t\tthis.shouldRemove = true;\n\t}\n\n\tpublic boolean shouldRemove() {\n\t\treturn this.shouldRemove;\n\t}\n\n\tpublic byte[] serialize() {\n\t\ttry {\n\t\t\tByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream();\n\t\t\tObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream);\n\t\t\tobjectOutputStream.writeObject(this);\n\t\t\treturn byteArrayOutputStream.toByteArray();\n\t\t} catch (IOException e) {\n\t\t\tSystem.err.println(\"Could not serialize gameObject\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * @return the edge of the panel that the GameObject is on\n\t * 0 = left, 1 = top, 2 = right, 3 = bottom\n\t */\n\tprotected int getEdge() {\n\t\tif (location.y() <= height) {\n\t\t\treturn 1;\n\t\t} else if (location.y() >= doodleJump.height() - height) {\n\t\t\treturn 3;\n\t\t} else if (location.x() <= width) {\n\t\t\treturn 0;\n\t\t} else if (location.x() >= doodleJump.width() - width) {\n\t\t\treturn 2;\n\t\t}\n\t\treturn -1;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tif (this instanceof Player && ((Player)this).isOpponent()) {\n\t\t\tSystem.out.print(\"opponent \");\n\t\t}\n\t\treturn this.getClass().getSimpleName();\n\t}\n\t\n\tpublic int getHealth(){\n\t\treturn health;\n\t}\n}\n", "ort3Test {\n    @Test\n    public void test1() throws Exception {\n        System.setIn(new FileInputStream(\"src/test/resources/counting-sort3/test1.txt\"));\n        CountingSort3.main(new String[]{});\n    }\n}", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.drools.runtime.process;\n\nimport org.drools.definition.process.Node;\n\n/**\n * A node instance represents the execution of one specific node\n * in a process instance.  Whenever a node is reached during the\n * execution of a process instance, a node instance will be created.\n * A node instance contains all the runtime state related to the\n * execution of that node.\n * Multiple node instances for the same node can coexist in the same\n * process instance (if that node is to be executed multiple times\n * in that process instance).\n * \n * A node instance is uniquely identified (within its node instance\n * container!) by an id.\n * \n * Node instances can be nested, meaning that a node instance can\n * be created as part of another node instance.\n */\npublic interface NodeInstance {\n\n    /**\n     * The id of the node instance.  This is unique within the\n     * node instance container this node instance lives in.\n     *\n     * @return the id of the node instance\n     */\n    long getId();\n\n    /**\n     * The id of the node this node instance refers to.  The node\n     * represents the definition that this node instance was based\n     * on.\n     * \n     * @return the id of the node this node instance refers to\n     */\n    long getNodeId();\n    \n    /**\n     * Return the node this node instance refers to.  The node\n     * represents the definition that this node instance was based\n     * on.\n     * \n     * @return the node this node instance refers to\n     */\n    Node getNode();\n\n    /**\n     * The name of the node this node instance refers to.\n     * @return the name of the node this node instance refers to\n     */\n    String getNodeName();\n\n    /**\n     * The process instance that this node instance is executing in.\n     * @return the process instance that this node instance is executing in\n     */\n    WorkflowProcessInstance getProcessInstance();\n\n    /**\n     * The node instance container that this node instance is part of.\n     * If the node was defined in the top-level process scope, this is\n     * the same as the process instance.  If not, it is the node instance\n     * container this node instance is executing in. \n     * \n     * @return the process instance that this node instance is executing in\n     */\n    NodeInstanceContainer getNodeInstanceContainer();\n    \n    Object getVariable(String variableName);\n    \n    void setVariable(String variableName, Object value);\n\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/**\n * @bug 8015334\n * @summary Memory leak with kerning.\n */\n\nimport java.awt.EventQueue;\nimport java.awt.Font;\nimport java.awt.FontMetrics;\nimport java.awt.font.TextAttribute;\nimport java.util.HashMap;\nimport java.util.Map;\nimport javax.swing.JLabel;\nimport javax.swing.SwingUtilities;\n\npublic class KerningLeak {\n\n    public static void main(String[] args) {\n        EventQueue.invokeLater(new Runnable() {\n            @Override\n            public void run() {\n                leak();\n            }\n        });\n    }\n\n    private static void leak() {\n        Map<TextAttribute, Object> textAttributes = new HashMap<>();\n        textAttributes.put(TextAttribute.FAMILY, \"Sans Serif\");\n        textAttributes.put(TextAttribute.SIZE, 12);\n        textAttributes.put(TextAttribute.KERNING, TextAttribute.KERNING_ON);\n        Font font = Font.getFont(textAttributes);\n        JLabel label = new JLabel();\n        int dummy = 0;\n        for (int i = 0; i < 500; i++) {\n            if (i % 10 == 0) System.out.println(\"Starting iter \" + (i+1));\n            for (int j = 0; j <1000; j++) {\n                FontMetrics fm = label.getFontMetrics(font);\n                dummy += SwingUtilities.computeStringWidth(fm, Integer.toString(j));\n            }\n        }\n        System.out.println(\"done \" + dummy);\n    }\n}\n", ".GlStateManager;\nimport net.minecraft.client.resources.I18n;\n\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\n\nimport com.tom.api.gui.GuiTomsMod;\nimport com.tom.defense.ForceDeviceControlType;\nimport com.tom.lib.utils.RenderUtil;\n\nimport com.tom.core.tileentity.gui.GuiConfigurator.GuiButtonConfig;\n\n@SideOnly(Side.CLIENT)\npublic class GuiButtonRedstoneMode extends GuiButtonConfig {\n\tpublic ForceDeviceControlType controlType;\n\n\tpublic GuiButtonRedstoneMode(int buttonId, int x, int y, ForceDeviceControlType type) {\n\t\tsuper(buttonId, x, y, 20, 20, \"\");\n\t\tthis.controlType = type;\n\t}\n\n\t@Override\n\tpublic void drawButton(Minecraft mc, int mouseX, int mouseY, float partTicks) {\n\t\tif (this.visible) {\n\t\t\tmc.getTextureManager().bindTexture(BUTTON_TEXTURES);\n\t\t\tGlStateManager.color(1.0F, 1.0F, 1.0F, 1.0F);\n\t\t\tthis.hovered = mouseX >= this.x && mouseY >= this.y && mouseX < this.x + this.width && mouseY < this.y + this.height;\n\t\t\tint i = this.getHoverState(this.hovered);\n\t\t\tGlStateManager.enableBlend();\n\t\t\tGlStateManager.tryBlendFuncSeparate(770, 771, 1, 0);\n\t\t\tGlStateManager.blendFunc(770, 771);\n\t\t\tthis.drawTexturedModalRect(this.x, this.y, 0, 46 + i * 20, this.width / 2, this.height);\n\t\t\tthis.drawTexturedModalRect(this.x + this.width / 2, this.y, 200 - this.width / 2, 46 + i * 20, this.width / 2, this.height);\n\t\t\tthis.mouseDragged(mc, mouseX, mouseY);\n\t\t\tmc.getTextureManager().bindTexture(controlType.iconLocation);\n\t\t\tRenderUtil.drawTexturedRect(x + 2, y + 2, 16, 16);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void postDraw(Minecraft mc, int mouseX, int mouseY, GuiTomsMod gui) {\n\t\tif (this.visible) {\n\t\t\tif (hovered) {\n\t\t\t\tgui.drawHoveringTextI(I18n.format(controlType.name), mouseX, mouseY);\n\t\t\t}\n\t\t}\n\t}\n}", "mport javax.annotation.Generated;\n\nimport org.apache.commons.lang.builder.EqualsBuilder;\nimport org.apache.commons.lang.builder.HashCodeBuilder;\nimport org.apache.commons.lang.builder.ToStringBuilder;\n\nimport com.fasterxml.jackson.annotation.JsonAnyGetter;\nimport com.fasterxml.jackson.annotation.JsonAnySetter;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonPropertyOrder;\n\n@JsonInclude(JsonInclude.Include.NON_NULL)\n@Generated(\"com.googlecode.jsonschema2pojo\")\n@JsonPropertyOrder({ \"RowData\" })\npublic class ApiRow {\n\n\t@JsonProperty(\"RowData\")\n\tprivate ApiRowData rowData;\n\tprivate Map<String, Object> additionalProperties = new HashMap<String, Object>();\n\n\t@JsonProperty(\"RowData\")\n\tpublic ApiRowData getRowData() {\n\t\treturn this.rowData;\n\t}\n\n\t@JsonProperty(\"RowData\")\n\tpublic void setRowData(ApiRowData rowData) {\n\t\tthis.rowData = rowData;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn ToStringBuilder.reflectionToString(this);\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\treturn HashCodeBuilder.reflectionHashCode(this);\n\t}\n\n\t@Override\n\tpublic boolean equals(Object other) {\n\t\treturn EqualsBuilder.reflectionEquals(this, other);\n\t}\n\n\t@JsonAnyGetter\n\tpublic Map<String, Object> getAdditionalProperties() {\n\t\treturn this.additionalProperties;\n\t}\n\n\t@JsonAnySetter\n\tpublic void setAdditionalProperties(String name, Object value) {\n\t\tthis.additionalProperties.put(name, value);\n\t}\n\n}\n", ".util.Collections;\nimport java.util.List;\n\n/**\n * Created by Atlas on 10/1/2014.\n */\npublic class ReturnEmptyArraysOrCollectionsNotNulls {\n    private final List<String> data = new ArrayList<String>(Arrays.asList(new String[]{\"item1\", \"item2\"}));\n    private static final String[] EMPTY_DATA = new String[0];\n\n    public String[] getData() {\n        return data.toArray(EMPTY_DATA);\n    }\n\n    public List<String> getDataList(){\n        if(data.isEmpty()) {\n            return Collections.emptyList();\n        }\n        else {\n            return data;\n        }\n    }\n\n\n    //in short never return null for collections.\n\n}\n", "ontext;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.StaggeredGridLayoutManager;\nimport android.util.AttributeSet;\n\n/**\n * Created by Kosh on 17 May 2016, 10:02 PM\n */\npublic class StaggeredManager extends StaggeredGridLayoutManager {\n\n    public StaggeredManager(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {\n        super(context, attrs, defStyleAttr, defStyleRes);\n    }\n\n    public StaggeredManager(int spanCount, int orientation) {\n        super(spanCount, orientation);\n    }\n\n    @Override public void onLayoutChildren(RecyclerView.Recycler recycler, RecyclerView.State state) {\n        try {\n            super.onLayoutChildren(recycler, state);\n        } catch (IndexOutOfBoundsException ignored) {}\n    }\n}\n", "ellij.lang.injection.MultiHostInjector;\nimport com.intellij.lang.injection.MultiHostRegistrar;\nimport com.intellij.psi.PsiElement;\nimport com.intellij.psi.PsiLanguageInjectionHost;\nimport com.jetbrains.php.lang.psi.elements.*;\nimport com.jetbrains.php.lang.psi.elements.impl.StringLiteralExpressionImpl;\nimport fr.adrienbrault.idea.symfony2plugin.Symfony2ProjectComponent;\nimport fr.adrienbrault.idea.symfony2plugin.util.MethodMatcher;\nimport fr.adrienbrault.idea.symfony2plugin.util.PhpElementsUtil;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ParameterLanguageInjector implements MultiHostInjector {\n\n    private static final MethodMatcher.CallToSignature[] CSS_SELECTOR_SIGNATURES = {\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\DomCrawler\\\\Crawler\", \"filter\"),\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\DomCrawler\\\\Crawler\", \"children\"),\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\CssSelector\\\\CssSelectorConverter\", \"toXPath\"),\n    };\n\n    private static final MethodMatcher.CallToSignature[] XPATH_SIGNATURES = {\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\DomCrawler\\\\Crawler\", \"filterXPath\"),\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\DomCrawler\\\\Crawler\", \"evaluate\"),\n    };\n\n    private static final MethodMatcher.CallToSignature[] JSON_SIGNATURES = {\n            //new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\HttpFoundation\\\\JsonResponse\", \"__construct\"),\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\HttpFoundation\\\\JsonResponse\", \"fromJsonString\"),\n            new MethodMatcher.CallToSignature(\"\\\\Symfony\\\\Component\\\\HttpFoundation\\\\JsonResponse\", \"setJson\"),\n    };\n\n    private static final MethodMatcher.CallToSignature[] DQL_SIGNATURES = {\n            new MethodMatcher.CallToSignature(\"\\\\Doctrine\\\\ORM\\\\EntityManager\", \"createQuery\"),\n            new MethodMatcher.CallToSignature(\"\\\\Doctrine\\\\ORM\\\\Query\", \"setDQL\"),\n    };\n\n    private final MethodLanguageInjection[] LANGUAGE_INJECTIONS = {\n        new MethodLanguageInjection(LANGUAGE_ID_CSS, \"@media all { \", \" }\", CSS_SELECTOR_SIGNATURES),\n        new MethodLanguageInjection(LANGUAGE_ID_XPATH, null, null, XPATH_SIGNATURES),\n        new MethodLanguageInjection(LANGUAGE_ID_JSON, null, null, JSON_SIGNATURES),\n        new MethodLanguageInjection(LANGUAGE_ID_DQL, null, null, DQL_SIGNATURES),\n    };\n\n    public static final String LANGUAGE_ID_CSS = \"CSS\";\n    public static final String LANGUAGE_ID_XPATH = \"XPath\";\n    public static final String LANGUAGE_ID_JSON = \"JSON\";\n    public static final String LANGUAGE_ID_DQL = \"DQL\";\n\n    private static final String DQL_VARIABLE_NAME = \"dql\";\n\n    public ParameterLanguageInjector() {\n    }\n\n    @NotNull\n    @Override\n    public List<? extends Class<? extends PsiElement>> elementsToInjectIn() {\n        return Collections.singletonList(StringLiteralExpressionImpl.class);\n    }\n\n    @Override\n    public void getLanguagesToInject(@NotNull MultiHostRegistrar registrar, @NotNull PsiElement element) {\n        if (!(element instanceof StringLiteralExpression) || !((PsiLanguageInjectionHost) element).isValidHost()) {\n            return;\n        }\n        if (!Symfony2ProjectComponent.isEnabled(element.getProject())) {\n            return;\n        }\n\n        final StringLiteralExpressionImpl expr = (StringLiteralExpressionImpl) element;\n\n        PsiElement parent = expr.getParent();\n\n        final boolean isParameter = parent instanceof ParameterList && expr.getPrevPsiSibling() == null; // 1st parameter\n        final boolean isAssignment = parent instanceof AssignmentExpression;\n\n        if (!isParameter && !isAssignment) {\n            return;\n        }\n\n        if (isParameter)  {\n            parent = parent.getParent();\n        }\n\n        for (MethodLanguageInjection languageInjection : LANGUAGE_INJECTIONS) {\n            // $crawler->filter('...')\n            // $em->createQuery('...')\n            // JsonResponse::fromJsonString('...')\n            if (parent instanceof MethodReference) {\n                if (PhpElementsUtil.isMethodReferenceInstanceOf((MethodReference) parent, languageInjection.getSignatures())) {\n                    injectLanguage(registrar, expr, languageInjection);\n                    return;\n                }\n            }\n            // $dql = \"...\";\n            else if (parent instanceof AssignmentExpression) {\n                Language language = languageInjection.getLanguage();\n                if (language != null && LANGUAGE_ID_DQL.equals(language.getID())) {\n                    PhpPsiElement variable = ((AssignmentExpression) parent).getVariable();\n                    if (variable instanceof Variable) {\n                        if (DQL_VARIABLE_NAME.equals(variable.getName())) {\n                            injectLanguage(registrar, expr, languageInjection);\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n\n    }\n\n    private void injectLanguage(@NotNull MultiHostRegistrar registrar, @NotNull StringLiteralExpressionImpl element, MethodLanguageInjection languageInjection) {\n        Language language = languageInjection.getLanguage();\n        if (language == null) {\n            return;\n        }\n\n        registrar.startInjecting(language)\n            .addPlace(languageInjection.getPrefix(), languageInjection.getSuffix(), element, element.getValueRange())\n            .doneInjecting();\n    }\n\n    private static class MethodLanguageInjection {\n        private final String language;\n        private final String prefix;\n        private final String suffix;\n        private final MethodMatcher.CallToSignature[] signatures;\n\n        MethodLanguageInjection(String languageId, String prefix, String suffix, MethodMatcher.CallToSignature[] signatures) {\n            this.language = languageId;\n            this.prefix = prefix;\n            this.suffix = suffix;\n            this.signatures = signatures;\n        }\n\n        @Nullable\n        public Language getLanguage() {\n            return Language.findLanguageByID(this.language);\n        }\n\n        public String getPrefix() {\n            return prefix;\n        }\n\n        public String getSuffix() {\n            return suffix;\n        }\n\n        public MethodMatcher.CallToSignature[] getSignatures() {\n            return signatures;\n        }\n    }\n}\n", "nd.BeanDescription;\nimport com.fasterxml.jackson.databind.DeserializationConfig;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiator;\nimport com.fasterxml.jackson.databind.deser.ValueInstantiators;\nimport com.fasterxml.jackson.databind.deser.std.StdValueInstantiator;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedClass;\nimport com.fasterxml.jackson.databind.introspect.AnnotatedMethod;\nimport com.fasterxml.jackson.databind.module.SimpleModule;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.deser.LocalDateDeserializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.deser.LocalDateTimeDeserializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.deser.LocalTimeDeserializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.deser.key.LocalDateKeyDeserializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.deser.key.LocalDateTimeKeyDeserializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.deser.key.LocalTimeKeyDeserializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.ser.LocalDateSerializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.ser.LocalDateTimeSerializer;\nimport jp.pgw.develop.swallow.inu.jackson.datatype.threetenbp.ser.LocalTimeSerializer;\nimport org.threeten.bp.LocalDate;\nimport org.threeten.bp.LocalDateTime;\nimport org.threeten.bp.LocalTime;\nimport org.threeten.bp.ZoneId;\n\npublic final class ThreeTenModule extends SimpleModule {\n\n    private static final long serialVersionUID = 1L;\n\n    public ThreeTenModule() {\n        super(PackageVersion.VERSION);\n        addDeserializer(LocalDateTime.class, LocalDateTimeDeserializer.INSTANCE);\n        addDeserializer(LocalDate.class, LocalDateDeserializer.INSTANCE);\n        addDeserializer(LocalTime.class, LocalTimeDeserializer.INSTANCE);\n        addSerializer(LocalDateTime.class, LocalDateTimeSerializer.INSTANCE);\n        addSerializer(LocalDate.class, LocalDateSerializer.INSTANCE);\n        addSerializer(LocalTime.class, LocalTimeSerializer.INSTANCE);\n        addKeyDeserializer(LocalDateTime.class, LocalDateTimeKeyDeserializer.INSTANCE);\n        addKeyDeserializer(LocalDate.class, LocalDateKeyDeserializer.INSTANCE);\n        addKeyDeserializer(LocalTime.class, LocalTimeKeyDeserializer.INSTANCE);\n    }\n\n    @Override\n    public void setupModule(SetupContext context) {\n        super.setupModule(context);\n        context.addValueInstantiators(new ValueInstantiators.Base() {\n            @Override\n            public ValueInstantiator findValueInstantiator(DeserializationConfig config,\n                    BeanDescription beanDesc, ValueInstantiator defaultInstantiator)\n            {\n                Class<?> raw = beanDesc.getBeanClass();\n                // 15-May-2015, tatu: In theory not safe, but in practice we do need to do \"fuzzy\" matching\n                // because we will (for now) be getting a subtype, but in future may want to downgrade\n                // to the common base type. Even more, serializer may purposefully force use of base type.\n                // So... in practice it really should always work, in the end. :)\n                if (ZoneId.class.isAssignableFrom(raw)) {\n                    // let's assume we should be getting \"empty\" StdValueInstantiator here:\n                    if (defaultInstantiator instanceof StdValueInstantiator) {\n                        StdValueInstantiator inst = (StdValueInstantiator) defaultInstantiator;\n                        // one further complication: we need ZoneId info, not sub-class\n                        AnnotatedClass ac;\n                        if (raw == ZoneId.class) {\n                            ac = beanDesc.getClassInfo();\n                        } else {\n                            // we don't need Annotations, so constructing directly is fine here\n                            // even if it's not generally recommended\n                            ac = AnnotatedClass.construct(ZoneId.class, null, null);\n                        }\n                        if (!inst.canCreateFromString()) {\n                            AnnotatedMethod factory = _findFactory(ac, \"of\", String.class);\n                            if (factory != null) {\n                                inst.configureFromStringCreator(factory);\n                            }\n                            // otherwise... should we indicate an error?\n                        }\n                        // return ZoneIdInstantiator.construct(config, beanDesc, defaultInstantiator);\n                    }\n                }\n                return defaultInstantiator;\n            }\n        });\n    }\n\n    // For\n    protected AnnotatedMethod _findFactory(AnnotatedClass cls, String name, Class<?>... argTypes) {\n        final int argCount = argTypes.length;\n        for (AnnotatedMethod method : cls.getStaticMethods()) {\n            if (!name.equals(method.getName())\n                    || (method.getParameterCount() != argCount)) {\n                continue;\n            }\n            for (int i = 0; i < argCount; ++i) {\n                Class<?> argType = method.getParameter(i).getRawType();\n                if (!argType.isAssignableFrom(argTypes[i])) {\n                    continue;\n                }\n            }\n            return method;\n        }\n        return null;\n    }\n\n}\n", "15 Development Gateway, Inc and others.\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the MIT License (MIT)\n * which accompanies this distribution, and is available at\n * https://opensource.org/licenses/MIT\n *\n * Contributors:\n * Development Gateway - initial API and implementation\n *******************************************************************************/\npackage org.devgateway.ocds.web.spring;\n\nimport org.apache.commons.lang.BooleanUtils;\nimport org.devgateway.ocds.persistence.mongo.spring.ExcelImportService;\nimport org.devgateway.ocds.persistence.mongo.spring.ImportResult;\nimport org.devgateway.ocds.web.util.SettingsUtils;\nimport org.devgateway.toolkit.persistence.dao.AdminSettings;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\n\n//@Service\npublic class ScheduledExcelImportService {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(ScheduledExcelImportService.class);\n\n    @Autowired\n    private ExcelImportService excelImportService;\n\n    @Autowired\n    private SendEmailService sendEmailService;\n\n    @Autowired\n    private SettingsUtils settingsUtils;\n\n    //@Scheduled(cron = \"0 0 3 * * ?\")\n    public void excelImportService() {\n\n        AdminSettings settings = settingsUtils.getSettings();\n\n        if (BooleanUtils.isFalse(settings.getEnableDailyAutomatedImport())) {\n            return;\n        }\n\n        ImportResult result = null;\n        //result = excelImportService.importAllSheets();\n\n        if (!result.getSuccess()) {\n            sendEmailService.sendEmail(\"Excel import failed!\", result.getMsgBuffer().toString(),\n                    settings.getAdminEmail());\n        }\n    }\n}", "mport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\nimport org.seqcode.data.io.RegionFileUtilities;\nimport org.seqcode.data.motifdb.WeightMatrix;\nimport org.seqcode.genome.location.Region;\nimport org.seqcode.genome.sequence.SequenceUtils;\nimport org.seqcode.gseutils.Pair;\nimport org.seqcode.motifs.MemeER;\nimport org.seqcode.projects.sequnwinder.clusterkmerprofile.ClusterProfiles;\nimport org.seqcode.projects.sequnwinder.framework.SeqUnwinderConfig;\n\n\n\npublic class Discrim {\n\t\n\tprotected SeqUnwinderConfig seqConfig;\n\t/** List of all discriminative motifs for all the lables*/ \n\tprotected List<WeightMatrix> discrimMotifs = new ArrayList<WeightMatrix>();\n\t\n\t/** The ROC value of the identified motifs that indicates their significance */\n\tprotected HashMap<String, Double> discrimMotifsRocs = new HashMap<String,Double>();\n\tprotected String[] randomSequences = new String[MemeER.MOTIF_FINDING_NEGSEQ];\n\t\n\tpublic void setRandomRegs(){\n\t\t// Generate random sequences later need for meme analysis to assess motifs\n\t\t\n\t\tList<Region> randomRegions = MemeER.randomRegionPick(seqConfig.getGenome(), null, MemeER.MOTIF_FINDING_NEGSEQ,seqConfig.getWin());\n\t\tfor(int i=0; i<randomRegions.size(); i++){\n\t\t\trandomSequences[i] = seqConfig.getSeqGen().execute(randomRegions.get(i));\n\t\t}\n\t}\n\n\tpublic Discrim(SeqUnwinderConfig seqcon) {\n\t\tseqConfig = seqcon;\n\t}\n\t\n\tpublic void execute() throws IOException{\n\t\tsetRandomRegs();\n\t\tmakeMemeDirs();\n\t\tfor(String s : seqConfig.getKmerWeights().keySet()){\n\t\t\tif(!s.equals(\"Random\")){\n\t\t\t\tKmerModelScanner scanner = new KmerModelScanner(s);\n\t\t\t\tscanner.execute();\n\t\t\t}\n\t\t}\n\t\t// Update Config\n\t\tseqConfig.setDiscrimMotifs(discrimMotifs);\n\t\tseqConfig.setDiscrimMotifsRocs(discrimMotifsRocs);\n\t}\n\n\t\n\t//Make MEME output directories\n\tpublic void makeMemeDirs(){\n\t\tfor(String s : seqConfig.getMNames()){\n\t\t\tif(!s.equals(\"Random\")){\n\t\t\t\tFile memeDir = new File(seqConfig.getOutDir().getAbsoluteFile()+File.separator+s+File.separator+\"meme\");\n\t\t\t\tmemeDir.mkdirs();\n\t\t\t\tFile kmerProfDir = new File(seqConfig.getOutDir().getAbsoluteFile()+File.separator+s+File.separator+\"kmer_profiles\");\n\t\t\t\tkmerProfDir.mkdirs();\n\t\t\t}\n\t\t}\n\n\t}\n\n\t\n\tpublic class KmerModelScanner {\n\t\t//Model specific features\n\t\tprotected String kmerModelName;\n\t\tprotected List<Region> modelRegions = new ArrayList<Region>();\n\t\tprotected List<String> modelSeqs = new ArrayList<String>();\n\t\t\n\t\tprotected List<Region> posHills = new ArrayList<Region>();\n\t\tprotected List<String> posHillsSeqs = new ArrayList<String>();\n\t\t\n\t\tprotected ArrayList<int[]> profiles = new ArrayList<int[]>();\n\t\tprotected List<Integer> clusterAssignment = new ArrayList<Integer>();\n\t\tprotected int bestNumClusters = 2;\n\t\tprotected HashMap<Integer,String> posHillsToIndex =new HashMap<Integer,String>();\n\t\tprotected HashMap<Integer,Double> posHillScores =new HashMap<Integer,Double>();\n\t\tprotected File basedir_profiles;\n\t\tprotected File basedir_meme;\n\t\t\n\t\t/** \n\t\t * Constructor\n\t\t */\n\t\tpublic KmerModelScanner(String modName) {\n\t\t\tkmerModelName = modName;\n\t\t\tbasedir_profiles = new File(seqConfig.getOutDir().getAbsoluteFile()+File.separator+kmerModelName+File.separator+\"kmer_profiles\");\n\t\t\tbasedir_meme = new File(seqConfig.getOutDir().getAbsoluteFile()+File.separator+kmerModelName+File.separator+\"meme\");\n\t\t\t\n\t\t\t// Now add all the training examples that are linked to the current K-mer model\n\t\t\t// First; split to get subgroup names\n\t\t\tString[] subGsMod = kmerModelName.split(\"#\");\n\t\t\t\n\t\t\tfor(int p=0; p< seqConfig.getPeakAnnotations().size(); p++){\n\t\t\t\tString[] pieces = seqConfig.getPeakAnnotations().get(p).split(\";\");\n\t\t\t\tboolean addReg = true;\n\t\t\t\t\n\t\t\t\tfor(String subGsInMod : subGsMod){\n\t\t\t\t\tboolean SGinPeak = false;\n\t\t\t\t\tfor(String piece : pieces){\n\t\t\t\t\t\tif(subGsInMod.equals(piece)){\n\t\t\t\t\t\t\tSGinPeak = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif(!SGinPeak)\n\t\t\t\t\t\taddReg = false;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(addReg){\n\t\t\t\t\tif(seqConfig.getRegions().size() > 0){\n\t\t\t\t\t\tmodelRegions.add(seqConfig.getRegions().get(p));\n\t\t\t\t\t}else{\n\t\t\t\t\t\tmodelSeqs.add(seqConfig.getSeqs().get(p));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t\tpublic void execute() throws IOException{\n\t\t\t// First, find, cluster and print the hills\n\t\t\tclusterKmerProfilesAtMountains();\n\t\t\tif(posHills.size() > 100 || posHillsSeqs.size() >100){\n\t\t\t\tSystem.err.println(\"Finished clustering K-mer profiles for model: \"+kmerModelName);\n\n\t\t\t\t// Now do meme search on each clusters separately\n\t\t\t\tString memeargs = seqConfig.getMemeArgs();\n\t\t\t\tMemeER meme = new MemeER(seqConfig.getMemePath(), memeargs);\n\t\t\t\tmeme.setWorkingDir(seqConfig.getInterDir());\n\t\t\t\tmeme.setMotifMinROC(seqConfig.getMotifMinROC());\n\t\t\t\tfor(int c=0; c<bestNumClusters; c++){ // Over each cluster\n\t\t\t\t\tSystem.err.println(\"Loading sequences for meme analysis : \"+kmerModelName+ \"Cluster\"+c);\n\t\t\t\t\tint numHillsLoaded = 0;\n\t\t\t\t\tList<String> seqs = new ArrayList<String>();\n\t\t\t\t\tfor(int p=0; p<(seqConfig.getRegions().size() > 0? posHills.size(): posHillsSeqs.size()); p++){\n\t\t\t\t\t\tif(clusterAssignment.get(p) == c && numHillsLoaded < SeqUnwinderConfig.NUM_HILLS){\n\t\t\t\t\t\t\tnumHillsLoaded++;\n\t\t\t\t\t\t\tString s = seqConfig.getRegions().size() > 0 ? seqConfig.getSeqGen().execute(posHills.get(p).getMidpoint().expand(seqConfig.getMemeSearchWin()/2)) : posHillsSeqs.get(p);\n\t\t\t\t\t\t\tif(MemeER.lowercaseFraction(s)<= SeqUnwinderConfig.MOTIF_FINDING_ALLOWED_REPETITIVE){\n\t\t\t\t\t\t\t\tseqs.add(s);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(numHillsLoaded >= SeqUnwinderConfig.NUM_HILLS)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t//List<WeightMatrix> selectedMotifs = new ArrayList<WeightMatrix>();\n\t\t\t\t\tFile meme_outFile = new File(basedir_meme+File.separator+\"Cluster-\"+Integer.toString(c)+\"_meme\");\n\n\t\t\t\t\tSystem.err.println(\"Running meme now\");\n\t\t\t\t\tPair<List<WeightMatrix>,List<WeightMatrix>> matrices = meme.execute(seqs, meme_outFile, false);\n\t\t\t\t\tSystem.err.println(\"Finished running meme, Now evaluating motif significance\");\n\t\t\t\t\tList<WeightMatrix> wm = matrices.car();\n\t\t\t\t\tList<WeightMatrix> fm = matrices.cdr();\n\t\t\t\t\t// Index for all the selected motifs\n\t\t\t\t\tint motInd = 0;\n\t\t\t\t\t\n\t\t\t\t\tif(wm.size()>0){\n\t\t\t\t\t\t//Evaluate the significance of the discovered motifs\n\t\t\t\t\t\tdouble rocScores[] = meme.motifROCScores(wm,seqs,randomSequences);\n\t\t\t\t\t\tSystem.err.println(\"MEME results for:\" );\n\t\t\t\t\t\tfor(int w=0; w<fm.size(); w++){\n\t\t\t\t\t\t\tif(fm.get(w)!=null){\n\t\t\t\t\t\t\t\tSystem.err.println(\"\\t\"+fm.get(w).getName()+\"\\t\"+ WeightMatrix.getConsensus(fm.get(w))+\"\\tROC:\"+String.format(\"%.2f\",rocScores[w]));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(rocScores[w] > meme.getMotifMinROC()){\n\t\t\t\t\t\t\t\t//selectedMotifs.add(fm.get(w));\n\t\t\t\t\t\t\t\tfm.get(w).setName(kmerModelName+\"_c\"+Integer.toString(c)+\"_\"+Integer.toString(motInd));\n\t\t\t\t\t\t\t\tdiscrimMotifs.add(fm.get(w));\n\t\t\t\t\t\t\t\tdiscrimMotifsRocs.put(kmerModelName+\"_c\"+Integer.toString(c)+\"_\"+Integer.toString(motInd), rocScores[w]);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmotInd++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\n\t\t}\n\t\t\n\t\t\n\t\t//Settors\n\t\t\n\t\t\n\t\t//Fillers\n\t\tprivate void fillHills() throws IOException{\n\t\t\tList<Pair<Region,Double>> hills= new ArrayList<Pair<Region,Double>>();\n\t\t\tList<Pair<String,Double>> seqlets = new ArrayList<Pair<String,Double>>();\n\t\t\tif(seqConfig.getRegions().size() > 0){\n\t\t\t\thills= findHills();\n\t\t\t\tsorthills(hills);\n\t\t\t}else{\n\t\t\t\tseqlets = findSeqlets();\n\t\t\t\tsortseqlets(seqlets);\n\t\t\t}\n\t\t\t\n\t\t\t\n\t\t\tif(seqConfig.getRegions().size() > 0){\n\t\t\t\tint index=0;\n\t\t\t\tHashMap<String,Integer> addedHills = new HashMap<String,Integer>();\n\t\t\t\tfor(Pair<Region,Double> pr : hills){\n\t\t\t\t\tif(!addedHills.containsKey(pr.car().getLocationString())){\n\t\t\t\t\t\tposHills.add(pr.car());\n\t\t\t\t\t\tposHillsToIndex.put(index,pr.car().getLocationString() );\n\t\t\t\t\t\tposHillScores.put(index++, pr.cdr());\n\t\t\t\t\t\taddedHills.put(pr.car().getLocationString(), 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tprofiles = getProfilesAtHills(posHills);\n\t\t\t}else{\n\t\t\t\tint index=0;\n\t\t\t\t//HashMap<String,Integer> addedHills = new HashMap<String,Integer>();\n\t\t\t\tfor(Pair<String,Double> pr : seqlets){\n\t\t\t\t\tposHillsSeqs.add(pr.car());\n\t\t\t\t\tposHillsToIndex.put(index, \"chr:\"+index);\n\t\t\t\t\tposHillScores.put(index++, pr.cdr());\n\t\t\t\t}\n\t\t\t\tprofiles = getProfilesAtSeqlets(posHillsSeqs);\n\t\t\t}\n\t\t}\n\t\t\n\t\tprivate void sorthills(List<Pair<Region,Double>> hlls){\n\t\t\t\n\t\t\tCollections.sort(hlls,new Comparator<Pair<Region,Double>>(){\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Pair<Region, Double> o1, Pair<Region, Double> o2) {\n\t\t\t\t\treturn  -1*(o1.cdr().compareTo(o2.cdr()));\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t}\n\n\t\tprivate void sortseqlets(List<Pair<String,Double>> hlls){\n\t\t\tCollections.sort(hlls,new Comparator<Pair<String,Double>>(){\n\t\t\t\t@Override\n\t\t\t\tpublic int compare(Pair<String, Double> o1, Pair<String, Double> o2) {\n\t\t\t\t\treturn  -1*(o1.cdr().compareTo(o2.cdr()));\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Prints the mountain composition\n\t\t * @param useCache\n\t\t * @param genpath\n\t\t * @param oddsThresh\n\t\t */\n\t\tpublic void clusterKmerProfilesAtMountains() throws IOException{\n\t\t\tfillHills();\n\t\t\tSystem.err.println(\"No of regions for K-mer model \"+kmerModelName+\" : \"+(seqConfig.getRegions().size() > 0 ? modelRegions.size() : modelSeqs.size()));\n\t\t\tSystem.err.println(\"No of hills for K-mer model \"+kmerModelName+\" : \"+(seqConfig.getRegions().size() > 0 ? posHills.size() : posHillsSeqs.size()));\n\t\t\tif(posHills.size() > 100 || posHillsSeqs.size() > 100){\n\t\t\t\tClusterProfiles clusterManager = new ClusterProfiles(SeqUnwinderConfig.ITRS_CLUS,profiles,posHillsToIndex,seqConfig.getKmin(),seqConfig.getKmax(),posHillScores,basedir_profiles);\n\t\t\t\tclusterAssignment = clusterManager.execute();\n\t\t\t\tbestNumClusters = clusterManager.getNumClusters();\n\t\t\t}\n\t\t}\n\t\t\n\n\t\tprivate ArrayList<int[]> getProfilesAtSeqlets(List<String> rs){\n\t\t\tArrayList<int[]> ret = new ArrayList<int[]>();\n\n\t\t\tfor(String seq : rs){\n\t\t\t\tint numK = 0;\n\t\t\t\tfor(int k=seqConfig.getKmin(); k<=seqConfig.getKmax(); k++){\n\t\t\t\t\tnumK += (int)Math.pow(4, k);\n\t\t\t\t}\n\t\t\t\tint[] pfl = new int[numK];\n\t\t\t\tfor(int k=seqConfig.getKmin(); k<=seqConfig.getKmax(); k++){\n\t\t\t\t\tfor(int i=0; i<(seq.length()-k+1); i++){\n\t\t\t\t\t\tString currk = seq.substring(i, i+k);\n\t\t\t\t\t\tString revcurrk = SequenceUtils.reverseComplement(currk);\n\t\t\t\t\t\tint currKInt = RegionFileUtilities.seq2int(currk);\n\t\t\t\t\t\tint revcurrKInt = RegionFileUtilities.seq2int(revcurrk);\n\t\t\t\t\t\tint kmer = currKInt<revcurrKInt ? currKInt : revcurrKInt;\n\t\t\t\t\t\tint baseind = seqConfig.getKmerBaseInd(currk);\t\n\t\t\t\t\t\tpfl[baseind+kmer]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(pfl);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tprivate ArrayList<int[]> getProfilesAtHills(List<Region> rs){\n\t\t\tArrayList<int[]> ret = new ArrayList<int[]>();\n\n\t\t\tfor(Region r: rs){\n\t\t\t\tint[] pfl = new int[seqConfig.getNumK()];\n\t\t\t\tString seq = seqConfig.getSeqGen().execute(r).toUpperCase();\n\t\t\t\tfor(int k=seqConfig.getKmin(); k<=seqConfig.getKmax(); k++){\n\t\t\t\t\tfor(int i=0; i<(seq.length()-k+1); i++){\n\t\t\t\t\t\tString currk = seq.substring(i, i+k);\n\t\t\t\t\t\tString revcurrk = SequenceUtils.reverseComplement(currk);\n\t\t\t\t\t\tint currKInt = RegionFileUtilities.seq2int(currk);\n\t\t\t\t\t\tint revcurrKInt = RegionFileUtilities.seq2int(revcurrk);\n\t\t\t\t\t\tint kmer = currKInt<revcurrKInt ? currKInt : revcurrKInt;\n\t\t\t\t\t\tint baseind = seqConfig.getKmerBaseInd(currk);\t\n\t\t\t\t\t\tpfl[baseind+kmer]++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.add(pfl);\n\t\t\t}\n\t\t\t\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t/**\n\t\t * Finds mountains for a given list of regions and given scoring threshold\n\t\t * Odds threshold can be -ve when scanning the model at negPeaks. +ve when scanning the model at posPeaks\n\t\t * Also populates the \n\t\t * @param useCache\n\t\t * @param genpath\n\t\t * @param oddsThresh\n\t\t */\n\t\tprivate List<Pair<Region,Double>> findHills(){\n\t\t\t\n\t\t\t// Detects if scanning is done for the positive or neg set from the sign of oddsThresh\n\t\t\t//int classDetector = oddsThresh>0 ? 1:-1;\n\t\t\t\n\t\t\tList<Pair<Region,Double>> ret = new ArrayList<Pair<Region,Double>>();\n\t\t\t\n\t\t\tfor(Region r : modelRegions){\n\t\t\t\tString seq = seqConfig.getSeqGen().execute(r).toUpperCase();\n\t\t\t\tif(seq.contains(\"N\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tList<Pair<Region,Double>> mountains = new ArrayList<Pair<Region,Double>>();\n\t\t\t\tfor(int l=seqConfig.getMinM(); l<=seqConfig.getMaxM(); l++){\n\t\t\t\t\tfor(int i=0; i<(seq.length()-l+1); i++){\n\t\t\t\t\t\tString motif = seq.substring(i, i+l);\n\t\t\t\t\t\tdouble score=0.0;\n\t\t\t\t\t\tfor(int k=seqConfig.getKmin(); k<=seqConfig.getKmax(); k++){\n\t\t\t\t\t\t\tfor(int j=0; j<motif.length()-k+1; j++){\n\t\t\t\t\t\t\t\tString currk = motif.substring(j, j+k);\n\t\t\t\t\t\t\t\tString revcurrk = SequenceUtils.reverseComplement(currk);\n\t\t\t\t\t\t\t\tint  currKInt = RegionFileUtilities.seq2int(currk);\n\t\t\t\t\t\t\t\tint  revCurrKInt = RegionFileUtilities.seq2int(revcurrk);\n\t\t\t\t\t\t\t\tint kmer = currKInt<revCurrKInt ? currKInt : revCurrKInt;\n\t\t\t\t\t\t\t\tint baseInd = seqConfig.getKmerBaseInd(currk);\n\t\t\t\t\t\t\t\tscore = score+seqConfig.getKmerWeights().get(kmerModelName)[baseInd+kmer];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tRegion hill = new Region(seqConfig.getGenome(),r.getChrom(),r.getStart()+i,r.getStart()+i+l-1);\n\t\t\t\t\t\t\n\t\t\t\t\t\tIterator<Pair<Region,Double>> it = mountains.iterator();\n\t\t\t\t\t\tboolean add=true;\n\t\t\t\t\t\twhile(it.hasNext() && add){\n\t\t\t\t\t\t\tPair<Region,Double> pr = it.next();\n\t\t\t\t\t\t\tRegion currHill = pr.car();\n\t\t\t\t\t\t\tDouble currScore = pr.cdr();\n\t\t\t\t\t\t\tif(currHill.overlaps(hill) && currScore<=score){\n\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t\tadd=true;\n\t\t\t\t\t\t\t}else if(currHill.overlaps(hill) && currScore> score){\n\t\t\t\t\t\t\t\tadd=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(add && score > seqConfig.getHillsThresh()){\n\t\t\t\t\t\t\tmountains.add(new Pair<Region,Double>(hill,score));\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tret.addAll(mountains);\t\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tprivate List<Pair<String,Double>> findSeqlets(){\n\n\t\t\t// Detects if scanning is done for the positive or neg set from the sign of oddsThresh\n\t\t\t//int classDetector = oddsThresh>0 ? 1:-1;\n\n\t\t\tList<Pair<String,Double>> ret = new ArrayList<Pair<String,Double>>();\n\n\t\t\tfor(String seq : seqConfig.getSeqs()){\n\t\t\t\tif(seq.contains(\"N\"))\n\t\t\t\t\tcontinue;\n\t\t\t\tList<Pair<Region,Double>> mountains = new ArrayList<Pair<Region,Double>>();\n\t\t\t\tfor(int l=seqConfig.getMinM(); l<=seqConfig.getMaxM(); l++){\n\t\t\t\t\tfor(int i=0; i<(seq.length()-l+1); i++){\n\t\t\t\t\t\tString motif = seq.substring(i, i+l);\n\t\t\t\t\t\tdouble score=0.0;\n\t\t\t\t\t\tfor(int k=seqConfig.getKmin(); k<=seqConfig.getKmax(); k++){\n\t\t\t\t\t\t\tfor(int j=0; j<motif.length()-k+1; j++){\n\t\t\t\t\t\t\t\tString currk = motif.substring(j, j+k);\n\t\t\t\t\t\t\t\tString revcurrk = SequenceUtils.reverseComplement(currk);\n\t\t\t\t\t\t\t\tint  currKInt = RegionFileUtilities.seq2int(currk);\n\t\t\t\t\t\t\t\tint  revCurrKInt = RegionFileUtilities.seq2int(revcurrk);\n\t\t\t\t\t\t\t\tint kmer = currKInt<revCurrKInt ? currKInt : revCurrKInt;\n\t\t\t\t\t\t\t\tint baseInd = seqConfig.getKmerBaseInd(currk);\n\t\t\t\t\t\t\t\tscore = score+seqConfig.getKmerWeights().get(kmerModelName)[baseInd+kmer];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\t// Generating a dummy region; easy to overlap\n\t\t\t\t\t\tRegion hill = new Region(seqConfig.getGenome(),\"chr1\",i,i+l-1);\n\n\t\t\t\t\t\tIterator<Pair<Region,Double>> it = mountains.iterator();\n\t\t\t\t\t\tboolean add=true;\n\t\t\t\t\t\twhile(it.hasNext() && add){\n\t\t\t\t\t\t\tPair<Region,Double> pr = it.next();\n\t\t\t\t\t\t\tRegion currHill = pr.car();\n\t\t\t\t\t\t\tDouble currScore = pr.cdr();\n\t\t\t\t\t\t\tif(currHill.overlaps(hill) && currScore<score){\n\t\t\t\t\t\t\t\tit.remove();\n\t\t\t\t\t\t\t\tadd=true;\n\t\t\t\t\t\t\t}else if(currHill.overlaps(hill) && currScore> score){\n\t\t\t\t\t\t\t\tadd=false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(add && score > seqConfig.getHillsThresh()){\n\t\t\t\t\t\t\tmountains.add(new Pair<Region,Double>(hill,score));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// Now convert these dummy regions into seqs\n\t\t\t\tfor(Pair<Region,Double> pr : mountains){\n\t\t\t\t\tint subStrStart = pr.car().getStart();\n\t\t\t\t\tint subStrEnd = pr.car().getEnd()+1;\n\t\t\t\t\tString subStr = seq.substring(subStrStart, subStrEnd);\n\t\t\t\t\tPair<String,Double> seqPair = new Pair<String,Double>(subStr,pr.cdr());\n\t\t\t\t\tret.add(seqPair);\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\tpublic class HillsIndexComparator implements Comparator<Integer>{\n\t\t\t\n\t\t\tList<Pair<Region,Double>> hill;\n\t\t\t\n\t\t\tpublic HillsIndexComparator(List<Pair<Region,Double>> h) {\n\t\t\t\thill = h;\n\t\t\t}\n\t\t\t\n\t\t\tpublic Integer[] createIndexArray(){\n\t\t\t\tInteger[] indexes = new Integer[hill.size()];\n\t\t\t\tfor(int i=0; i<indexes.length; i++){\n\t\t\t\t\tindexes[i] = i;\n\t\t\t\t}\n\t\t\t\treturn indexes;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn -1*(hill.get(o1).cdr().compareTo(hill.get(o2).cdr()));\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\tpublic class SeqletsIndexComparator implements Comparator<Integer>{\n\n\t\t\tList<Pair<String,Double>> hill;\n\n\t\t\tpublic SeqletsIndexComparator(List<Pair<String,Double>> h) {\n\t\t\t\thill = h;\n\t\t\t}\n\n\t\t\tpublic Integer[] createIndexArray(){\n\t\t\t\tInteger[] indexes = new Integer[hill.size()];\n\t\t\t\tfor(int i=0; i<indexes.length; i++){\n\t\t\t\t\tindexes[i] = i;\n\t\t\t\t}\n\t\t\t\treturn indexes;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic int compare(Integer o1, Integer o2) {\n\t\t\t\treturn -1*(hill.get(o1).cdr().compareTo(hill.get(o2).cdr()));\n\t\t\t}\n\n\t\t}\n\t}\n\n}\n", "c TextParam(String snm, String sval) {\n\t\tname = snm;\n\t\tvalue = sval;\n\t}\n\n        @Override\n        public String toString() {\n            return value;\n        }\n\n\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\t\n\tpublic String getText() {\n\t\t return value;\n\t}\n\t\n\t\n}\n", "rivate static final long serialVersionUID = 1L;\n\t\n\tprivate Integer id;\n\tprivate String userName ;\n\tprivate String password;\n\tprivate Integer age;\n\tpublic Integer getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(Integer id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getUser_name() {\n\t\treturn userName;\n\t}\n\tpublic void setUser_name(String user_name) {\n\t\tthis.userName = user_name;\n\t}\n\tpublic String getPassword() {\n\t\treturn password;\n\t}\n\tpublic void setPassword(String password) {\n\t\tthis.password = password;\n\t}\n\tpublic Integer getAge() {\n\t\treturn age;\n\t}\n\tpublic void setAge(Integer age) {\n\t\tthis.age = age;\n\t}\n\n\tpublic String toString() {\n\t\treturn \"User [id=\" + id + \", user_name=\" + userName + \", password=\" + password + \", age=\" + age + \"]\";\n\t}\n\t\n}\n", ".v7.app.ActionBarActivity;\nimport android.os.Bundle;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.Toast;\n\n\npublic class MainActivity extends ActionBarActivity {\n\n    private Toast toast;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n    }\n\n    public void comingSoon(String message) {\n        if (toast != null)\n            toast.cancel();\n\n        toast = Toast.makeText(getApplicationContext(), message, Toast.LENGTH_LONG);\n        toast.show();\n    }\n\n    public void launchApp1(View view) {\n        comingSoon(getString(R.string.comingSoon) + getString(R.string.appName1));\n    }\n\n    public void launchApp2(View view) {\n        comingSoon(getString(R.string.comingSoon) + getString(R.string.appName2));\n    }\n\n    public void launchApp3(View view) {\n        comingSoon(getString(R.string.comingSoon) + getString(R.string.appName3));\n    }\n\n    public void launchApp4(View view) {\n        comingSoon(getString(R.string.comingSoon) + getString(R.string.appName4));\n    }\n\n    public void launchApp5(View view) {\n        comingSoon(getString(R.string.comingSoon) + getString(R.string.appName5));\n    }\n\n    public void launchApp6(View view) {\n        comingSoon(getString(R.string.comingSoon) + getString(R.string.appName6));\n    }\n}\n", "tool from the resource data it found.  It\n * should not be modified by hand.\n */\n\npackage com.example.cleverchat;\n\npublic final class R {\n    public static final class attr {\n    }\n    public static final class dimen {\n        /**  Default screen margins, per the Android Design guidelines. \n\n         Customize dimensions originally defined in res/values/dimens.xml (such as\n         screen margins) for sw720dp devices (e.g. 10\" tablets) in landscape here.\n    \n         */\n        public static final int activity_horizontal_margin=0x7f040000;\n        public static final int activity_vertical_margin=0x7f040001;\n        public static final int dimension1=0x7f040003;\n        public static final int my_dim=0x7f040002;\n    }\n    public static final class drawable {\n        public static final int ic_launcher=0x7f020000;\n        public static final int icon=0x7f020001;\n    }\n    public static final class id {\n        public static final int action_settings=0x7f080009;\n        public static final int chatMessage=0x7f080002;\n        public static final int hostIp=0x7f080005;\n        public static final int hostIpInput=0x7f080006;\n        public static final int quit=0x7f080004;\n        public static final int sendMessage=0x7f080003;\n        public static final int start_chat=0x7f080000;\n        public static final int textChat=0x7f080001;\n        public static final int userName=0x7f080007;\n        public static final int userNameInput=0x7f080008;\n    }\n    public static final class layout {\n        public static final int activity_main=0x7f030000;\n        public static final int connect_to_chat_layout=0x7f030001;\n    }\n    public static final class menu {\n        public static final int chat=0x7f070000;\n        public static final int main=0x7f070001;\n    }\n    public static final class string {\n        public static final int Start_Chat=0x7f050006;\n        public static final int action_settings=0x7f050001;\n        public static final int app_name=0x7f050000;\n        public static final int host_ip=0x7f050004;\n        public static final int name=0x7f050005;\n        public static final int quit=0x7f050007;\n        public static final int send=0x7f050003;\n        public static final int title_activity_chat=0x7f050002;\n    }\n    public static final class style {\n        /** \n        Base application theme, dependent on API level. This theme is replaced\n        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.\n    \n\n            Theme customizations available in newer API levels can go in\n            res/values-vXX/styles.xml, while customizations related to\n            backward-compatibility can go here.\n        \n\n        Base application theme for API 11+. This theme completely replaces\n        AppBaseTheme from res/values/styles.xml on API 11+ devices.\n    \n API 11 theme customizations can go here. \n\n        Base application theme for API 14+. This theme completely replaces\n        AppBaseTheme from BOTH res/values/styles.xml and\n        res/values-v11/styles.xml on API 14+ devices.\n    \n API 14 theme customizations can go here. \n         */\n        public static final int AppBaseTheme=0x7f060000;\n        /**  Application theme. \n All customizations that are NOT specific to a particular API-level can go here. \n         */\n        public static final int AppTheme=0x7f060001;\n    }\n}\n", "intDefinition;\nimport info.magnolia.rest.service.node.definition.NodeEndpointDefinition;\n\npublic class ConfiguredFirstServiceEndpointDefinition extends ConfiguredEndpointDefinition\n        implements NodeEndpointDefinition {\n\n    /**\n     * \n     */\n    private static final long serialVersionUID = 1L;\n\n}", "\n * Author: landerlyoung\n * Date:   2014-10-21\n * Time:   15:20\n * Life with passion. Code with creativity!\n */\npublic class DictDetail {\n    public String word;\n    public String usphontic;\n    public String usspeech;\n    public String ukphontic;\n    public String ukspeech;\n    public String pinyin;\n\n    public List<String> trs = new ArrayList<String>();\n    public List<WF> wfs = new ArrayList<WF>();\n\n    public static class WF {\n        public WF(String name, String value) {\n            this.name = name;\n            this.value = value;\n        }\n\n        public String name;\n        public String value;\n    }\n}\n", "hedules an arbitrary action in the future using {@link ScheduledAction}\n */\npublic final class Scheduler\n{\n\t/**\n\t * Adds a newKH action into the stack that will run at a set number of ticks in the future, defined by {@link ScheduledAction#getScheduledTime()}\n\t * @param action {@link ScheduledAction} to add to the queue\n\t */\n\tpublic void addAction(ScheduledAction action)\n\t{\n\t\tif(action.getSide() == Side.SERVER)\n\t\t{\n\t\t\tServerScheduler.addAction(action);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tClientScheduler.addAction(action);\n\t\t}\n\t}\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.network.v2019_11_01;\n\nimport com.microsoft.azure.arm.model.HasInner;\nimport com.microsoft.azure.arm.resources.models.HasManager;\nimport com.microsoft.azure.management.network.v2019_11_01.implementation.NetworkManager;\nimport com.microsoft.azure.management.network.v2019_11_01.implementation.ExpressRouteCircuitStatsInner;\n\n/**\n * Type representing ExpressRouteCircuitStats.\n */\npublic interface ExpressRouteCircuitStats extends HasInner<ExpressRouteCircuitStatsInner>, HasManager<NetworkManager> {\n    /**\n     * @return the primarybytesIn value.\n     */\n    Long primarybytesIn();\n\n    /**\n     * @return the primarybytesOut value.\n     */\n    Long primarybytesOut();\n\n    /**\n     * @return the secondarybytesIn value.\n     */\n    Long secondarybytesIn();\n\n    /**\n     * @return the secondarybytesOut value.\n     */\n    Long secondarybytesOut();\n\n}\n", "sponse;\nimport org.apache.http.NameValuePair;\nimport org.apache.http.client.*;\nimport org.apache.http.client.entity.UrlEncodedFormEntity;\nimport org.apache.http.client.methods.*;\nimport org.apache.http.impl.client.*;\nimport org.json.simple.parser.JSONParser;\nimport org.json.simple.parser.ParseException;\n\npublic class WebClient {\n\n\tprivate DefaultHttpClient httpClient;\n\n\tpublic WebClient()\n\t{\n\t\tthis.httpClient = new DefaultHttpClient();\n\t}\n\n\tpublic void dispose()\n\t{\n\t\tthis.httpClient.getConnectionManager().shutdown();\n\t}\n\n\tpublic String downloadString(String sUrl) throws ClientProtocolException,\n\t\t\tIOException {\n\n\t\t// put the URL in a HttpGet\n\t\tHttpGet getRequest = new HttpGet(sUrl);\n\n\t\t// Create a response handler that will create a String on our behalf\n\t\tResponseHandler<String> responseHandler = new BasicResponseHandler();\n\n\t\t// Execute the request with the responseHandler\n\t\treturn this.httpClient.execute(getRequest,\n\t\t\t\tresponseHandler);\n\t}\n\n\tprivate Object handleJsonResponse(HttpResponse response)  throws IOException, ParseException\n\t{\n\t\tBufferedReader br = new BufferedReader(\n\t\t\t\tnew InputStreamReader((response.getEntity().getContent())));\n\t\tif (response.getStatusLine().getStatusCode() != 200) {\n\t\t\tthrow new RuntimeException(\"Failed : HTTP error code : \"\n\t\t\t\t\t+ response.getStatusLine().getStatusCode() + \" Message : \" +\n\t\t\t\t\tresponse.getStatusLine().getReasonPhrase());\n\t\t}\n\t\treturn new JSONParser().parse(br);\n\n\t}\n\n\tpublic Object downloadJson(String sUrl, List<NameValuePair> nameValuePairs) throws IOException, ParseException\n\t{\n\t    HttpPost postRequest = new HttpPost(sUrl);\n\t\tpostRequest.addHeader(\"accept\", \"application/json\");\n\t\tpostRequest.addHeader(\"User-Agent\", \"JSONURLParser/1.0\");\n\t\tpostRequest.setEntity(new UrlEncodedFormEntity(nameValuePairs));\n\t\tHttpResponse response = this.httpClient.execute(postRequest);\n\t\treturn this.handleJsonResponse(response);\n\t}\n\n\tpublic Object downloadJson(String sUrl) throws IOException, ParseException\n\t{\n\t\tHttpGet getRequest = new HttpGet(\n\t\t\t\tsUrl);\n\t\tgetRequest.addHeader(\"accept\", \"application/json\");\n\t\tgetRequest.addHeader(\"User-Agent\", \"JSONURLParser/1.0\");\n\n\t\tHttpResponse response = this.httpClient.execute(getRequest);\n\t\treturn this.handleJsonResponse(response);\n\t}\n\n\n}\n", "18 Microsoft Research. All rights reserved.\n *\n * The MIT License (MIT)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN\n * AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * Contributors:\n *   Markus Alexander Kuppe - initial API and implementation\n ******************************************************************************/\npackage tlc2.tool.fp;\n\nimport java.io.IOException;\n\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.Setup;\nimport org.openjdk.jmh.annotations.State;\n\n@State(Scope.Benchmark)\npublic class LongArrayBenchmark {\n\tprivate LongArray array;\n\n    @Setup\n    public void up() throws IOException {\n        final long elements = 1L << 10;\n\t\tarray = new LongArray(elements);\n\t\tarray.zeroMemory(1);\n\t\tfor (long i = 0L; i < elements; i++) {\n\t\t\tarray.set(i, Long.MAX_VALUE - i);\n\t\t}\n    }\n    \n    @Benchmark\n    public void AswapWithCopy() {\n    \tarray.swapCopy(0, array.size() - 1);\n    }\n    \n\t@Benchmark\n\tpublic void BswapGetSet() {\n    \tarray.swap(0, array.size() - 1);\n    }\n}\n", "k.data.mongodb.repository.MongoRepository;\nimport org.springframework.data.rest.core.annotation.RepositoryRestResource;\n\nimport dead.of.night.studios.hostnow.model.Order;\n\n/**\n * \n * @author Nathanial W. Heard\n *\n * Interface used to auto setup database repository features \n * based on stubbed methods for order documents.\n *\n */\n\n@RepositoryRestResource(collectionResourceRel = \"orders\", path = \"orders\")\npublic interface IOrderRepository extends MongoRepository<Order, String> {\n\n\tpublic void delete(Order deleted);\n\t \n\tpublic List<Order> findAll();\n \n\tpublic Order findOne(String id);\n \n\tpublic Order save(Order saved);\n}\n", "\tif (b == 0) return a;\n\t\tint sum = a ^ b; // add without carrying\n\t\tint carry = (a & b) << 1; // carry, but don\ufffdt add\n\t\treturn add(sum, carry); // recurse\n\t}\n\t\n\tpublic static void main(String[] args) {\n\t\tint a = Integer.MAX_VALUE - 50;\n\t\tint b = 92;\n\t\tint sum = add(a, b);\n\t\tint intendedSum = a + b;\n\t\tif (sum != intendedSum) {\n\t\t\tSystem.out.println(\"ERROR\");\n\t\t} else {\n\t\t\tSystem.out.println(\"SUCCESS\");\n\t\t}\n\t\tSystem.out.println(a + \" + \" + b + \" = \" + sum + \" vs \" + intendedSum);\n\t}\n\n}\n", "t;\nimport javax.inject.Singleton;\n\n/**\n *\n */\n@Singleton\npublic class DALInitializer {\n    @Inject\n    DALInitializer(PersistService service) {\n        service.start();\n        // At this point JPA is started and ready.\n    }\n}\n", "ribute it and/or modify it under the terms of the\n * GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1\n * of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n * See the GNU Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License along with this library;\n * if not, see <https://www.gnu.org/licenses/>.\n */\n\npackage org.heigit.ors.api.requests.routing;\n\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonInclude;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\n\n@ApiModel(value = \"Round Trip Route Options\", parent = RouteRequestOptions.class, description = \"Specifies the parameters for generating round trip routes.\")\n@JsonInclude(JsonInclude.Include.NON_EMPTY)\npublic class RouteRequestRoundTripOptions {\n    public static final String PARAM_LENGTH = \"length\";\n    public static final String PARAM_POINTS = \"points\";\n    public static final String PARAM_SEED = \"seed\";\n\n    @ApiModelProperty(name = PARAM_LENGTH, value = \"The target length of the route in `m` (note that this is a preferred value, but results may be different).\",\n            example = \"10000\")\n    @JsonProperty(PARAM_LENGTH)\n    private Float length;\n    @JsonIgnore\n    private boolean hasLength = false;\n\n    @ApiModelProperty(name = PARAM_POINTS, value = \"The number of points to use on the route. Larger values create more circular routes.\",\n            example = \"5\")\n    @JsonProperty(PARAM_POINTS)\n    private Integer points;\n    @JsonIgnore\n    private boolean hasPoints = false;\n\n    @ApiModelProperty(name = PARAM_SEED, value = \"A seed to use for adding randomisation to the overall direction of the generated route\",\n            example = \"1\")\n    @JsonProperty(PARAM_SEED)\n    private Long seed;\n    @JsonIgnore\n    private boolean hasSeed = false;\n\n    public Float getLength() {\n        return length;\n    }\n\n    public void setLength(Float length) {\n        this.length = length;\n        hasLength = true;\n    }\n\n    public Integer getPoints() {\n        return this.points;\n    }\n\n    public void setPoints(Integer points) {\n        this.points = points;\n        hasPoints = true;\n    }\n\n    public Long getSeed() {\n        return seed;\n    }\n\n    public void setSeed(Long seed) {\n        this.seed = seed;\n        hasSeed = true;\n    }\n\n    public boolean hasLength() {\n        return hasLength;\n    }\n\n    public boolean hasPoints() {\n        return hasPoints;\n    }\n\n    public boolean hasSeed() {\n        return hasSeed;\n    }\n}\n", "f charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage com.mukunda.magicitems.commands;\n\nimport org.bukkit.ChatColor;\n\nimport com.mukunda.cmdhandler.CommandGroup;\nimport com.mukunda.cmdhandler.CommandHandler;\nimport com.mukunda.magicitems.MagicItems;\n\npublic class ReloadCommand extends CommandHandler {\n\n\tpublic ReloadCommand( CommandGroup parent ) {\n\t\tsuper( parent, \"reload\", 0, false );\n\t}\n\n\t@Override\n\tpublic void printSyntax() {\n\t\treply( \"/magicitems reload\" );\n\t}\n\n\t@Override\n\tpublic void printUsage() {\n\t\treply( \"Usage: /magicitems reload\" );\n\t\treply( \"Reloads item definitions.\" );\n\t\t\n\t}\n\n\t@Override\n\tpublic void run(String[] args) {\n\t\tMagicItems.getContext().reloadDefinitions();\n\t\treply( ChatColor.GREEN + \"Reload complete.\" );\n\t}\n\n}\n", "ttons.config.Constants;\nimport com.iorga.debattons.domain.User;\nimport com.iorga.debattons.repository.UserRepository;\nimport com.iorga.debattons.service.dto.UserDTO;\nimport com.iorga.debattons.service.util.RandomUtil;\n\nimport org.apache.commons.lang3.RandomStringUtils;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.mockito.Mock;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.auditing.AuditingHandler;\nimport org.springframework.data.auditing.DateTimeProvider;\nimport org.springframework.data.domain.Page;\nimport org.springframework.data.domain.PageRequest;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.time.LocalDateTime;\nimport java.util.Optional;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Mockito.when;\n\n/**\n * Integration tests for {@link UserService}.\n */\n@SpringBootTest(classes = DebattonsApp.class)\n@Transactional\npublic class UserServiceIT {\n\n    private static final String DEFAULT_LOGIN = \"johndoe\";\n\n    private static final String DEFAULT_EMAIL = \"johndoe@localhost\";\n\n    private static final String DEFAULT_FIRSTNAME = \"john\";\n\n    private static final String DEFAULT_LASTNAME = \"doe\";\n\n    private static final String DEFAULT_IMAGEURL = \"http://placehold.it/50x50\";\n\n    private static final String DEFAULT_LANGKEY = \"dummy\";\n\n    @Autowired\n    private UserRepository userRepository;\n\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private AuditingHandler auditingHandler;\n\n    @Mock\n    private DateTimeProvider dateTimeProvider;\n\n    private User user;\n\n    @BeforeEach\n    public void init() {\n        user = new User();\n        user.setLogin(DEFAULT_LOGIN);\n        user.setPassword(RandomStringUtils.random(60));\n        user.setActivated(true);\n        user.setEmail(DEFAULT_EMAIL);\n        user.setFirstName(DEFAULT_FIRSTNAME);\n        user.setLastName(DEFAULT_LASTNAME);\n        user.setImageUrl(DEFAULT_IMAGEURL);\n        user.setLangKey(DEFAULT_LANGKEY);\n\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(LocalDateTime.now()));\n        auditingHandler.setDateTimeProvider(dateTimeProvider);\n    }\n\n    @Test\n    @Transactional\n    public void assertThatUserMustExistToResetPassword() {\n        userRepository.saveAndFlush(user);\n        Optional<User> maybeUser = userService.requestPasswordReset(\"invalid.login@localhost\");\n        assertThat(maybeUser).isNotPresent();\n\n        maybeUser = userService.requestPasswordReset(user.getEmail());\n        assertThat(maybeUser).isPresent();\n        assertThat(maybeUser.orElse(null).getEmail()).isEqualTo(user.getEmail());\n        assertThat(maybeUser.orElse(null).getResetDate()).isNotNull();\n        assertThat(maybeUser.orElse(null).getResetKey()).isNotNull();\n    }\n\n    @Test\n    @Transactional\n    public void assertThatOnlyActivatedUserCanRequestPasswordReset() {\n        user.setActivated(false);\n        userRepository.saveAndFlush(user);\n\n        Optional<User> maybeUser = userService.requestPasswordReset(user.getLogin());\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user);\n    }\n\n    @Test\n    @Transactional\n    public void assertThatResetKeyMustNotBeOlderThan24Hours() {\n        Instant daysAgo = Instant.now().minus(25, ChronoUnit.HOURS);\n        String resetKey = RandomUtil.generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.saveAndFlush(user);\n\n        Optional<User> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey());\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user);\n    }\n\n    @Test\n    @Transactional\n    public void assertThatResetKeyMustBeValid() {\n        Instant daysAgo = Instant.now().minus(25, ChronoUnit.HOURS);\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(\"1234\");\n        userRepository.saveAndFlush(user);\n\n        Optional<User> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey());\n        assertThat(maybeUser).isNotPresent();\n        userRepository.delete(user);\n    }\n\n    @Test\n    @Transactional\n    public void assertThatUserCanResetPassword() {\n        String oldPassword = user.getPassword();\n        Instant daysAgo = Instant.now().minus(2, ChronoUnit.HOURS);\n        String resetKey = RandomUtil.generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.saveAndFlush(user);\n\n        Optional<User> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey());\n        assertThat(maybeUser).isPresent();\n        assertThat(maybeUser.orElse(null).getResetDate()).isNull();\n        assertThat(maybeUser.orElse(null).getResetKey()).isNull();\n        assertThat(maybeUser.orElse(null).getPassword()).isNotEqualTo(oldPassword);\n\n        userRepository.delete(user);\n    }\n\n    @Test\n    @Transactional\n    public void assertThatNotActivatedUsersWithNotNullActivationKeyCreatedBefore3DaysAreDeleted() {\n        Instant now = Instant.now();\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(now.minus(4, ChronoUnit.DAYS)));\n        user.setActivated(false);\n        user.setActivationKey(RandomStringUtils.random(20));\n        User dbUser = userRepository.saveAndFlush(user);\n        dbUser.setCreatedDate(now.minus(4, ChronoUnit.DAYS));\n        userRepository.saveAndFlush(user);\n        List<User> users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS));\n        assertThat(users).isNotEmpty();\n        userService.removeNotActivatedUsers();\n        users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS));\n        assertThat(users).isEmpty();\n    }\n\n    @Test\n    @Transactional\n    public void assertThatNotActivatedUsersWithNullActivationKeyCreatedBefore3DaysAreNotDeleted() {\n        Instant now = Instant.now();\n        when(dateTimeProvider.getNow()).thenReturn(Optional.of(now.minus(4, ChronoUnit.DAYS)));\n        user.setActivated(false);\n        User dbUser = userRepository.saveAndFlush(user);\n        dbUser.setCreatedDate(now.minus(4, ChronoUnit.DAYS));\n        userRepository.saveAndFlush(user);\n        List<User> users = userRepository.findAllByActivatedIsFalseAndActivationKeyIsNotNullAndCreatedDateBefore(now.minus(3, ChronoUnit.DAYS));\n        assertThat(users).isEmpty();\n        userService.removeNotActivatedUsers();\n        Optional<User> maybeDbUser = userRepository.findById(dbUser.getId());\n        assertThat(maybeDbUser).contains(dbUser);\n    }\n\n    @Test\n    @Transactional\n    public void assertThatAnonymousUserIsNotGet() {\n        user.setLogin(Constants.ANONYMOUS_USER);\n        if (!userRepository.findOneByLogin(Constants.ANONYMOUS_USER).isPresent()) {\n            userRepository.saveAndFlush(user);\n        }\n        final PageRequest pageable = PageRequest.of(0, (int) userRepository.count());\n        final Page<UserDTO> allManagedUsers = userService.getAllManagedUsers(pageable);\n        assertThat(allManagedUsers.getContent().stream()\n            .noneMatch(user -> Constants.ANONYMOUS_USER.equals(user.getLogin())))\n            .isTrue();\n    }\n\n}\n", "ic class KeyController {\n\tpublic Route listKeys;\n\tpublic Route retrieveKey;\n}\n", "java.util.*;\nimport java.util.logging.Logger;\n\n/**\n *\n * @author tduva\n */\npublic class SettingsManager {\n    \n    private static final Logger LOGGER = Logger.getLogger(SettingsManager.class.getName());\n    \n    private final Settings settings;\n    \n    private final String[] debugSettings = {\n        \"server\",\n        \"port\",\n        \"ontop\",\n        \"dontSaveSettings\",\n        \"usePassword\",\n        \"ignoreJoinsParts\",\n        \"debugLogIrc\",\n        \"showJoinsParts\",\n        \"showBanMessages\",\n        \"emoticonsEnabled\",\n        \"showBanMessages\",\n        \"saveChannelHistory\",\n        \"historyClear\",\n        \"autoScroll\",\n        \"bufferSize\"\n    };\n    \n    public SettingsManager(Settings settings) {\n        this.settings = settings;\n    }\n    \n    /**\n     * Defines what settings there are and their default values.\n     */\n    void defineSettings() {\n        \n        // Additional files (in addition to the default file)\n        String loginFile = Chatty.getUserDataDirectory()+\"login\";\n        String historyFile = Chatty.getUserDataDirectory()+\"favoritesAndHistory\";\n        String statusPresetsFile = Chatty.getUserDataDirectory()+\"statusPresets\";\n        \n        settings.addFile(loginFile);\n        settings.addFile(historyFile);\n        settings.addFile(statusPresetsFile);\n        \n        // Global\n        settings.addBoolean(\"ontop\", false);\n        settings.addBoolean(\"dontSaveSettings\",false);\n        settings.addString(\"timeoutButtons\",\"5,2m,10m,30m\");\n        \n        // Connecting/Login data\n        settings.addString(\"serverDefault\", \"irc.twitch.tv\");\n        settings.addString(\"portDefault\", \"6667,80\");\n        // Seperate settings for commandline/temp so others can be saved\n        settings.addString(\"server\", \"\", false);\n        settings.addString(\"port\", \"\", false);\n        \n        settings.addBoolean(\"tc3\", false);\n        \n        settings.addString(\"channel\", \"\");\n        settings.addString(\"username\", \"\");\n        settings.setFile(\"username\", loginFile);\n        settings.addString(\"password\", \"\", false);\n        settings.addBoolean(\"connectOnStartup\", false, false);\n        settings.addString(\"token\",\"\");\n        settings.setFile(\"token\", loginFile);\n        // Don't save setting, login with password isn't possible anymore\n        settings.addBoolean(\"usePassword\", false, false);\n        // Scopes\n        settings.addBoolean(\"token_editor\", false);\n        settings.setFile(\"token_editor\", loginFile);\n        settings.addBoolean(\"token_commercials\", false);\n        settings.setFile(\"token_commercials\", loginFile);\n        settings.addBoolean(\"token_user\", false);\n        settings.setFile(\"token_user\", loginFile);\n        \n        // Chat messages\n        settings.addBoolean(\"ignoreJoinsParts\",false);\n        settings.addBoolean(\"showJoinsParts\", false);\n        settings.addBoolean(\"showModMessages\", true);\n        settings.addBoolean(\"debugLogIrc\", false);\n        settings.addBoolean(\"showBanMessages\", false);\n        settings.addBoolean(\"deleteMessages\", false);\n        settings.addString(\"deletedMessagesMode\", \"keepShortened\");\n        settings.addLong(\"deletedMessagesMaxLength\", 50);\n        settings.addLong(\"bufferSize\", 250);\n        settings.addBoolean(\"twitchnotifyAsInfo\", true);\n        settings.addBoolean(\"printStreamStatus\", true);\n        \n        // Chat appearance\n        settings.addBoolean(\"emoticonsEnabled\",true);\n        settings.addBoolean(\"usericonsEnabled\",true);\n        settings.addString(\"font\",\"Consolas\");\n        settings.addLong(\"fontSize\",14);\n        settings.addLong(\"lineSpacing\", 3);\n        //settings.addBoolean(\"timestampEnabled\",true);\n        settings.addString(\"timestamp\",\"[HH:mm]\");\n        settings.addBoolean(\"capitalizedNames\", false);\n        settings.addBoolean(\"ffz\", true);\n        settings.addBoolean(\"ffzModIcon\", true);\n        settings.addString(\"tabOrder\", \"normal\");\n        \n        \n        // Colors\n        settings.addString(\"foregroundColor\",\"#111111\");\n        settings.addString(\"backgroundColor\",\"#FAFAFA\");\n        settings.addString(\"infoColor\",\"#001480\");\n        settings.addString(\"compactColor\",\"#A0A0A0\");\n        settings.addString(\"inputBackgroundColor\",\"#FFFFFF\");\n        settings.addString(\"inputForegroundColor\",\"#000000\");\n        settings.addString(\"highlightColor\",\"#FF0000\");\n        settings.addString(\"searchResultColor\", \"LightYellow\");\n        \n        \n        // History and Favorites\n        settings.addMap(\"channelHistory\",new TreeMap(), Setting.LONG);\n        settings.setFile(\"channelHistory\", historyFile);\n        settings.addList(\"channelFavorites\", new ArrayList(), Setting.STRING);\n        settings.setFile(\"channelFavorites\", historyFile);\n        settings.addList(\"gamesFavorites\",new ArrayList(), Setting.STRING);\n        settings.setFile(\"gamesFavorites\", historyFile);\n        settings.addLong(\"channelHistoryKeepDays\", 30);\n        settings.addBoolean(\"saveChannelHistory\", true);\n        settings.addBoolean(\"historyClear\", true);\n        \n        // Commercials\n        settings.addString(\"commercialHotkey\",\"\");\n        settings.addBoolean(\"adDelay\", false);\n        settings.addLong(\"adDelayLength\", 300);\n        \n        // Other\n        settings.addBoolean(\"channelsWarning\", true);\n        settings.addBoolean(\"autoScroll\", true);\n        settings.addLong(\"versionLastChecked\", 0);\n        settings.addBoolean(\"checkNewVersion\", true);\n        settings.addString(\"liveStreamsSorting\", \"recent\");\n        settings.addLong(\"historyRange\", 0);\n        settings.addString(\"spamProtection\", \"18/30\");\n        settings.addLong(\"userlistWidth\", 120);\n        \n        settings.addString(\"currentVersion\", \"\");\n        \n        settings.addBoolean(\"urlPrompt\", true);\n        \n        // Window\n        settings.addBoolean(\"maximized\", false);\n        settings.addBoolean(\"nod3d\", true);\n        settings.addBoolean(\"noddraw\", false);\n        \n        settings.addMap(\"windows\", new HashMap<>(), Setting.STRING);\n        settings.addLong(\"restoreMode\", 1);\n        \n        // Highlight\n        settings.addList(\"highlight\",new ArrayList(), Setting.STRING);\n        settings.addBoolean(\"highlightEnabled\", true);\n        settings.addBoolean(\"highlightUsername\", true);\n        settings.addBoolean(\"highlightOwnText\", false);\n        settings.addBoolean(\"highlightNextMessages\", false);\n        \n        // Sounds\n        settings.addBoolean(\"sounds\", false);\n        settings.addString(\"highlightSound\", \"off\");\n        settings.addString(\"highlightSoundFile\", \"ding.wav\");\n        settings.addLong(\"highlightSoundDelay\", 15);\n        settings.addLong(\"soundDelay\", 15);\n        settings.addLong(\"highlightSoundVolume\", 100);\n        settings.addString(\"statusSound\",\"off\");\n        settings.addString(\"statusSoundFile\",\"dingdong.wav\");\n        settings.addLong(\"statusSoundVolume\",100);\n        settings.addLong(\"statusSoundDelay\", 15);\n        settings.addString(\"messageSound\",\"off\");\n        settings.addString(\"messageSoundFile\",\"dingdong.wav\");\n        settings.addLong(\"messageSoundVolume\",100);\n        settings.addLong(\"messageSoundDelay\", 5);\n        settings.addString(\"joinPartSound\",\"off\");\n        settings.addString(\"joinPartSoundFile\",\"dingdong.wav\");\n        settings.addLong(\"joinPartSoundVolume\",100);\n        settings.addLong(\"joinPartSoundDelay\", 10);\n        \n        // Notifications\n        settings.addString(\"highlightNotification\", \"either\");\n        settings.addString(\"statusNotification\", \"either\");\n        settings.addBoolean(\"requestFollowedStreams\", true);\n        \n        settings.addBoolean(\"useCustomNotifications\", true);\n        \n        settings.addLong(\"nScreen\", -1);\n        settings.addLong(\"nPosition\", 3);\n        settings.addLong(\"nDisplayTime\", 10);\n        settings.addLong(\"nMaxDisplayTime\", 60*30);\n        settings.addLong(\"nMaxDisplayed\", 4);\n        settings.addLong(\"nMaxQueueSize\", 4);\n        settings.addBoolean(\"nActivity\", false);\n        settings.addLong(\"nActivityTime\", 10);\n        \n        settings.addLong(\"v0.5\", 0);\n        settings.addBoolean(\"tips\", true);\n        settings.addLong(\"lastTip\", 0);\n        \n        // Logging\n        settings.addString(\"logMode\", \"off\");\n        settings.addBoolean(\"logMod\", true);\n        settings.addBoolean(\"logJoinPart\", false);\n        settings.addBoolean(\"logBan\", true);\n        settings.addBoolean(\"logSystem\", false);\n        settings.addBoolean(\"logInfo\", true);\n        settings.addBoolean(\"logViewerstats\", true);\n        settings.addBoolean(\"logViewercount\", false);\n        settings.addList(\"logWhitelist\",new ArrayList(), Setting.STRING);\n        settings.addList(\"logBlacklist\",new ArrayList(), Setting.STRING);\n        \n        settings.addBoolean(\"debugCommands\", false, false);\n        \n        settings.addBoolean(\"customUsercolors\", false);\n        settings.addList(\"usercolors\", new LinkedList(), Setting.STRING);\n        \n        settings.addString(\"abCommandsChannel\", \"\");\n        settings.addString(\"abCommands\", \"add,set,remove\");\n        \n        settings.addList(\"statusPresets\", new ArrayList(), Setting.LIST);\n        settings.setFile(\"statusPresets\", statusPresetsFile);\n        \n        settings.addBoolean(\"saveStatusHistory\", true);\n        settings.addBoolean(\"statusHistoryClear\", true);\n        settings.addLong(\"statusHistoryKeepDays\", 30);\n        \n        //settings.getList2(\"highlight\").add(\".*abc.*\");\n        //settings.getMap2(\"channelHistory\").put(\"#joshimuz\",\"test\");\n    }\n    \n    /**\n     * Tries to load the settings from file.\n     */\n    void loadSettingsFromFile() {\n        settings.loadSettingsFromJson();\n    }\n    \n    /**\n     * Goes through the commandline options and sets the settings accordingly.\n     * \n     * Commandline options consist of key=value pairs, although empty values\n     * are possible.\n     * \n     * @param args Map with commandline settings, key=value pairs\n     */\n    void loadCommandLineSettings(HashMap<String, String> args) {\n        for (String key : args.keySet()) {\n            // Go through all commandline options\n            String value = args.get(key);\n            if (key == null) {\n                continue;\n            }\n            switch (key) {\n                case \"user\":\n                    settings.setString(\"username\", value);\n                    break;\n                case \"channel\":\n                    settings.setString(\"channel\", value);\n                    break;\n                case \"connect\":\n                    settings.setBoolean(\"connectOnStartup\", true);\n                    break;\n                case \"token\":\n                    if (!value.isEmpty()) {\n                        settings.setString(\"token\", value);\n                    }\n                    settings.setBoolean(\"usePassword\", false);\n                    break;\n                case \"password\":\n                    settings.setString(\"password\", value);\n                    settings.setBoolean(\"usePassword\", true);\n                    break;\n                case \"ds\":\n                    settings.setBoolean(\"dontSaveSettings\", true);\n                    break;\n                case \"server\":\n                    settings.setString(\"server\", value);\n                    break;\n                case \"port\":\n                    settings.setString(\"port\", value);\n                    break;\n            }\n        }\n    }\n    \n    public void debugSettings() {\n        StringBuilder result = new StringBuilder(\"Settings: \");\n        boolean first = true;\n        for (String setting : debugSettings) {\n            if (!first) {\n                result.append(\", \");\n            } else {\n                first = false;\n            }\n            result.append(setting);\n            result.append(\":\");\n            result.append(settings.settingValueToString(setting));\n        }\n        LOGGER.info(result.toString());\n    }\n    \n}\n", "craft.entity.player.EntityPlayer;\nimport net.minecraft.entity.player.InventoryPlayer;\nimport net.minecraft.inventory.Container;\nimport net.minecraft.inventory.Slot;\nimport net.minecraft.item.ItemStack;\n\npublic class BarrierContainer extends Container {\n    public HxCTile hxCTile;\n    public BarrierContainer(EntityPlayer player, HxCTile te){\n        hxCTile = te;\n        addSlotToContainer(new Slot(hxCTile, 0, 80, 35));\n        bindPlayerInventory(player.inventory);\n    }\n\n    @Override\n    public boolean canInteractWith(EntityPlayer player) {\n        return true;\n    }\n\n    private void bindPlayerInventory(InventoryPlayer inventoryPlayer) {\n        for (int i = 0; i < 3; i++)\n            for (int j = 0; j < 9; j++)\n                addSlotToContainer(new Slot(inventoryPlayer, j + i * 9 + 9, 8 + j * 18, 84 + i * 18));\n\n        for (int i = 0; i < 9; i++)\n            addSlotToContainer(new Slot(inventoryPlayer, i, 8 + i * 18, 142));\n    }\n\n    @Override\n    public ItemStack transferStackInSlot(EntityPlayer player, int slot) {\n        ItemStack stack = null;\n        Slot slotObject = (Slot) inventorySlots.get(slot);\n        if (slotObject != null && slotObject.getHasStack()) {\n            ItemStack stackInSlot = slotObject.getStack();\n            stack = stackInSlot.copy();\n            if (slot == 0)\n                if (!this.mergeItemStack(stackInSlot, 1, 35, true))\n                    return null;\n\n                else if (!this.mergeItemStack(stackInSlot, 0, 0, false))\n                    return null;\n\n            if (stackInSlot.stackSize == 0)\n                slotObject.putStack(null);\n            else slotObject.onSlotChanged();\n\n            if (stackInSlot.stackSize == stack.stackSize)\n                return null;\n\n            slotObject.onPickupFromSlot(player, stackInSlot);\n        }\n        return stack;\n    }\n}", "S: The stunning micro-library that helps you to develop easily \n *             AJAX web applications by using Java and jQuery\n * openAUSIAS is distributed under the MIT License (MIT)\n * Sources at https://github.com/rafaelaznar/openAUSIAS\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage net.daw.service.implementation;\n\nimport com.google.gson.Gson;\nimport java.sql.Connection;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport javax.servlet.http.HttpServletRequest;\nimport net.daw.bean.implementation.PerfilBean;\nimport net.daw.bean.implementation.UsuarioBean;\nimport net.daw.connection.publicinterface.ConnectionInterface;\nimport net.daw.dao.implementation.PerfilDao;\nimport net.daw.dao.implementation.UsuarioDao;\n\nimport net.daw.helper.statics.AppConfigurationHelper;\nimport static net.daw.helper.statics.AppConfigurationHelper.getSourceConnection;\nimport net.daw.helper.statics.ExceptionBooster;\nimport net.daw.helper.statics.FilterBeanHelper;\nimport net.daw.helper.statics.JsonMessage;\nimport net.daw.helper.statics.ParameterCook;\n\nimport net.daw.service.publicinterface.TableServiceInterface;\nimport net.daw.service.publicinterface.ViewServiceInterface;\n\npublic class UsuarioService implements TableServiceInterface, ViewServiceInterface {\n\n    protected HttpServletRequest oRequest = null;\n\n    public UsuarioService(HttpServletRequest request) {\n        oRequest = request;\n    }\n\n    private Boolean checkpermission(String strMethodName) throws Exception {\n        UsuarioBean oUserBean = (UsuarioBean) oRequest.getSession().getAttribute(\"userBean\");\n        if (oUserBean != null) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    @Override\n    public String getcount() throws Exception {\n        if (this.checkpermission(\"getcount\")) {\n            String data = null;\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                data = JsonMessage.getJson(\"200\", Integer.toString(oUsuarioDao.getCount(alFilter)));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getCount ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n      public String getcountusuarionoduplicado() throws Exception {\n        if (this.checkpermission(\"getcount\")) {\n            String data = null;\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            int id_usuario = ParameterCook.prepareInt(\"id_usuario\",oRequest);\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                data = JsonMessage.getJson(\"200\", Integer.toString(oUsuarioDao.getCountusuarionoduplicado(id_usuario,alFilter)));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getCount ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n    @Override\n    public String get() throws Exception {\n        if (this.checkpermission(\"get\")) {\n            int id = ParameterCook.prepareId(oRequest);\n            String data = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                UsuarioBean oUsuarioBean = new UsuarioBean(id);\n                oUsuarioBean = oUsuarioDao.get(oUsuarioBean, AppConfigurationHelper.getJsonDepth());\n                Gson gson = AppConfigurationHelper.getGson();\n                data = JsonMessage.getJson(\"200\", AppConfigurationHelper.getGson().toJson(oUsuarioBean));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":get ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n\n    @Override\n    public String getall() throws Exception {\n        if (this.checkpermission(\"getall\")) {\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            HashMap<String, String> hmOrder = ParameterCook.prepareOrder(oRequest);\n            String data = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                ArrayList<UsuarioBean> arrBeans = oUsuarioDao.getAll(alFilter, hmOrder, 1);\n                data = JsonMessage.getJson(\"200\", AppConfigurationHelper.getGson().toJson(arrBeans));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getAll ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n\n    @Override\n    @SuppressWarnings(\"empty-statement\")\n    public String getpage() throws Exception {\n        if (this.checkpermission(\"getpage\")) {\n            int intRegsPerPag = ParameterCook.prepareRpp(oRequest);;\n            int intPage = ParameterCook.preparePage(oRequest);\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            HashMap<String, String> hmOrder = ParameterCook.prepareOrder(oRequest);\n            String data = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                List<UsuarioBean> arrBeans = oUsuarioDao.getPage(intRegsPerPag, intPage, alFilter, hmOrder, AppConfigurationHelper.getJsonDepth());\n                data = JsonMessage.getJson(\"200\", AppConfigurationHelper.getGson().toJson(arrBeans));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getPage ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n       @SuppressWarnings(\"empty-statement\")\n    public String getpageusuarionoduplicado() throws Exception {\n        if (this.checkpermission(\"getpage\")) {\n            int intRegsPerPag = ParameterCook.prepareRpp(oRequest);;\n            int intPage = ParameterCook.preparePage(oRequest);\n            int id_usuario = ParameterCook.prepareInt(\"id_usuario\",oRequest);\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            HashMap<String, String> hmOrder = ParameterCook.prepareOrder(oRequest);\n            String data = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                List<UsuarioBean> arrBeans = oUsuarioDao.getPageusuarionoduplicado(id_usuario,intRegsPerPag, intPage, alFilter, hmOrder, AppConfigurationHelper.getJsonDepth());\n                data = JsonMessage.getJson(\"200\", AppConfigurationHelper.getGson().toJson(arrBeans));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getPage ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n    @Override\n    public String getpages() throws Exception {\n        if (this.checkpermission(\"getpages\")) {\n            int intRegsPerPag = ParameterCook.prepareRpp(oRequest);\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            String data = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                data = JsonMessage.getJson(\"200\", Integer.toString(oUsuarioDao.getPages(intRegsPerPag, alFilter)));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getPages ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n        public String getpagesusuarionoduplicado() throws Exception {\n        if (this.checkpermission(\"getpages\")) {\n            int intRegsPerPag = ParameterCook.prepareRpp(oRequest);\n            int id_usuario = ParameterCook.prepareInt(\"id_usuario\",oRequest);\n            ArrayList<FilterBeanHelper> alFilter = ParameterCook.prepareFilter(oRequest);\n            String data = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                data = JsonMessage.getJson(\"200\", Integer.toString(oUsuarioDao.getPagesusuarionoduplicado(id_usuario,intRegsPerPag, alFilter)));\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getPages ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n    @Override\n    public String getaggregateviewsome() throws Exception {\n        if (this.checkpermission(\"getaggregateviewsome\")) {\n            String data = null;\n            try {\n                String page = this.getpage();\n                String pages = this.getpages();\n                String registers = this.getcount();\n                data = \"{\"\n                        + \"\\\"page\\\":\" + page\n                        + \",\\\"pages\\\":\" + pages\n                        + \",\\\"registers\\\":\" + registers\n                        + \"}\";\n                data = JsonMessage.getJson(\"200\", data);\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getAggregateViewSome ERROR: \" + ex.getMessage()));\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n      public String getaggregateviewsomeusuarionoduplicado() throws Exception {\n        if (this.checkpermission(\"getaggregateviewsomeusuarionoduplicado\")) {\n            String data = null;\n            try {\n                String page = this.getpageusuarionoduplicado();\n                String pages = this.getpagesusuarionoduplicado();\n                String registers = this.getcountusuarionoduplicado();\n                data = \"{\"\n                        + \"\\\"page\\\":\" + page\n                        + \",\\\"pages\\\":\" + pages\n                        + \",\\\"registers\\\":\" + registers\n                        + \"}\";\n                data = JsonMessage.getJson(\"200\", data);\n            } catch (Exception ex) {\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":getAggregateViewSome ERROR: \" + ex.getMessage()));\n            }\n            return data;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n    \n    @Override\n    public String remove() throws Exception {\n        if (this.checkpermission(\"remove\")) {\n            Integer id = ParameterCook.prepareId(oRequest);\n            String resultado = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                oConnection.setAutoCommit(false);\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                resultado = JsonMessage.getJson(\"200\", (String) oUsuarioDao.remove(id).toString());\n                oConnection.commit();\n            } catch (Exception ex) {\n                oConnection.rollback();\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":remove ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return resultado;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n\n    @Override\n    public String set() throws Exception {\n        if (this.checkpermission(\"set\")) {\n            String jason = ParameterCook.prepareJson(oRequest);\n            String resultado = null;\n            Connection oConnection = null;\n            ConnectionInterface oDataConnectionSource = null;\n            try {\n                oDataConnectionSource = getSourceConnection();\n                oConnection = oDataConnectionSource.newConnection();\n                oConnection.setAutoCommit(false);\n                UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                UsuarioBean oUsuarioBean = new UsuarioBean();\n               // PerfilBean oPerfilBean = new PerfilBean();                \n                oUsuarioBean = AppConfigurationHelper.getGson().fromJson(jason, oUsuarioBean.getClass());\n                if (oUsuarioBean != null) {\n                    Integer iResult = oUsuarioDao.set(oUsuarioBean);\n                    \n                    if (iResult >= 1) {\n                        \n                        resultado = JsonMessage.getJson(\"200\", iResult.toString());\n                    } else {\n                        resultado = JsonMessage.getJson(\"500\", \"Error during registry set\");\n                    }\n                } else {\n                    resultado = JsonMessage.getJson(\"500\", \"Error during registry set\");\n                }\n                oConnection.commit();\n            } catch (Exception ex) {\n                oConnection.rollback();\n                ExceptionBooster.boost(new Exception(this.getClass().getName() + \":set ERROR: \" + ex.getMessage()));\n            } finally {\n                if (oConnection != null) {\n                    oConnection.close();\n                }\n                if (oDataConnectionSource != null) {\n                    oDataConnectionSource.disposeConnection();\n                }\n            }\n            return resultado;\n        } else {\n            return JsonMessage.getJsonMsg(\"401\", \"Unauthorized\");\n        }\n    }\n\n    public String login() throws SQLException, Exception {\n        UsuarioBean oUserBean = (UsuarioBean) oRequest.getSession().getAttribute(\"userBean\");\n        String strAnswer = null;\n        String strCode = \"200\";\n        if (oUserBean == null) {\n            String login = oRequest.getParameter(\"login\");\n            String pass = oRequest.getParameter(\"password\");\n            if (!login.equals(\"\") && !pass.equals(\"\")) {\n                ConnectionInterface oDataConnectionSource = null;\n                Connection oConnection = null;\n                try {\n                    oDataConnectionSource = getSourceConnection();\n                    oConnection = oDataConnectionSource.newConnection();\n                    UsuarioBean oUsuario = new UsuarioBean();\n                    oUsuario.setEmail(login);\n                    oUsuario.setPassword(pass);\n                    UsuarioDao oUsuarioDao = new UsuarioDao(oConnection);\n                    oUsuario = oUsuarioDao.getFromLogin(oUsuario);\n                    if (oUsuario.getId() != 0) {\n                        oRequest.getSession().setAttribute(\"userBean\", oUsuario);\n                        strAnswer = oUsuario.getNombre();\n                    } else {\n                        strCode = \"403\";\n                        strAnswer = \"User or password incorrect\";\n                    }\n                } catch (Exception ex) {\n                    ExceptionBooster.boost(new Exception(this.getClass().getName() + \":login ERROR \" + ex.toString()));\n                } finally {\n                    if (oConnection != null) {\n                        oConnection.close();\n                    }\n                    if (oDataConnectionSource != null) {\n                        oDataConnectionSource.disposeConnection();\n                    }\n                }\n            }\n        } else {\n            strAnswer = \"Already logged in\";\n        }\n        return JsonMessage.getJsonMsg(strCode, strAnswer);\n    }\n\n    public String logout() {\n        oRequest.getSession().invalidate();\n        return JsonMessage.getJsonMsg(\"200\", \"Bye\");\n    }\n\n    public String getsessionstatus() {\n        String strAnswer = null;\n        UsuarioBean oUserBean = (UsuarioBean) oRequest.getSession().getAttribute(\"userBean\");\n        if (oUserBean == null) {\n            return JsonMessage.getJsonMsg(\"403\", \"ERROR: You don't have permission to perform this operation\");\n        } else {\n            return JsonMessage.getJsonMsg(\"200\", oUserBean.getNombre());\n        }\n    }\n\n    public int sessionuserlevel() {\n        String strAnswer = null;\n        UsuarioBean oUserBean = (UsuarioBean) oRequest.getSession().getAttribute(\"userBean\");\n        if (oUserBean == null) {\n            return 0;\n        } else {\n            return oUserBean.getId_perfil();\n        }\n    }\n\n}\n", "ssListener} is a class that needs to react to events\n * concerning the memory of the machine.\n *\n * @author Martin L&uuml;ck\n */\npublic interface MemoryAccessListener {\n\n    /**\n     * Called if there was a read access to the memory.\n     *\n     * @param address\n     *          the address that was read from\n     * @param value\n     *          the read value of the memory address\n     */\n    void memoryReadAccess(int address, int value);\n\n    /**\n     * Called if there was a write access to the memory.\n     *\n     * @param address\n     *          the address that was written to\n     * @param value\n     *          the value that was written to the address\n     */\n    void memoryWriteAccess(int address, int value);\n\n    /**\n     * Called if the memory was reset. Not to be mistaken with the zeroing of the memory.\n     */\n    void memoryReset();\n\n    /**\n     * Called if the memory was changed for a different reason, e.g. zeroing.\n     */\n    void memoryChanged();\n}", "Executable;\nimport _04BarracksWarsCommandsStrikeBack.contracts.Interpreter;\nimport _04BarracksWarsCommandsStrikeBack.contracts.Repository;\nimport _04BarracksWarsCommandsStrikeBack.contracts.UnitFactory;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\npublic class CommandInterpreter implements Interpreter {\n\n    private static final String PACKAGE_PATH_COMMAND = \"_04BarracksWarsCommandsStrikeBack.core.commands.\";\n    private static final String COMMAND_SUFFIX = \"Command\";\n\n    private Repository repository;\n    private UnitFactory unitFactory;\n\n    public CommandInterpreter(Repository repository, UnitFactory unitFactory) {\n        this.repository = repository;\n        this.unitFactory = unitFactory;\n    }\n\n    @Override\n    public String interpretCommand(String[] data) {\n\n        Executable command = parseCommand(data);\n        return command.execute();\n    }\n\n    private Executable parseCommand(String[] data) {\n        String commandName = Character.toUpperCase(data[0].charAt(0)) + data[0].substring(1);\n        try {\n            Constructor constructor = Class.forName(PACKAGE_PATH_COMMAND + commandName + COMMAND_SUFFIX)\n                    .getDeclaredConstructor(Repository.class, UnitFactory.class, String[].class);\n            return (Executable) constructor.newInstance(this.repository, this.unitFactory, data);\n        } catch (ClassNotFoundException | NoSuchMethodException | IllegalAccessException | InstantiationException | InvocationTargetException e) {\n            throw new RuntimeException(\"Invalid command!\");\n        }\n    }\n}\n", "bra, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\npackage com.zimbra.soap.admin.type;\n\nimport com.google.common.collect.Iterables;\nimport com.google.common.collect.Lists;\n\nimport java.util.Collections;\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlAttribute;\nimport javax.xml.bind.annotation.XmlElement;\n\nimport com.zimbra.common.soap.AdminConstants;\nimport com.zimbra.soap.type.Id;\n\n@XmlAccessorType(XmlAccessType.NONE)\npublic class FreeBusyQueueProvider {\n\n    /**\n     * @zm-api-field-tag provider-name\n     * @zm-api-field-description Provider name\n     */\n    @XmlAttribute(name=AdminConstants.A_NAME, required=true)\n    private final String name;\n\n    /**\n     * @zm-api-field-description Information on accounts\n     */\n    @XmlElement(name=AdminConstants.E_ACCOUNT, required=false)\n    private List<Id> accounts = Lists.newArrayList();\n\n    /**\n     * no-argument constructor wanted by JAXB\n     */\n    @SuppressWarnings(\"unused\")\n    private FreeBusyQueueProvider() {\n        this((String) null);\n    }\n\n    public FreeBusyQueueProvider(String name) {\n        this.name = name;\n    }\n\n    public void setAccounts(Iterable <Id> accounts) {\n        this.accounts.clear();\n        if (accounts != null) {\n            Iterables.addAll(this.accounts,accounts);\n        }\n    }\n\n    public FreeBusyQueueProvider addAccount(Id account) {\n        this.accounts.add(account);\n        return this;\n    }\n\n    public String getName() { return name; }\n    public List<Id> getAccounts() {\n        return Collections.unmodifiableList(accounts);\n    }\n}\n", "two-element inner tree node.\r\n */\r\npublic final class Node2<V, A> extends Node<V, A> {\r\n  private final V2<A> as;\r\n\r\n  Node2(final Measured<V, A> m, final V2<A> as) {\r\n    super(m, m.sum(m.measure(as._1()), m.measure(as._2())));\r\n    this.as = as;\r\n  }\r\n\r\n  @Override public <B> B foldRight(final F<A, F<B, B>> aff, final B z) {\r\n    return aff.f(as._1()).f(aff.f(as._2()).f(z));\r\n  }\r\n\r\n  @Override public <B> B foldLeft(final F<B, F<A, B>> bff, final B z) {\r\n    return bff.f(bff.f(z).f(as._1())).f(as._2());\r\n  }\r\n\r\n  public Digit<V, A> toDigit() {\r\n    return new Two<V, A>(measured(), as);\r\n  }\r\n\r\n  @SuppressWarnings({\"ReturnOfNull\"})\r\n  @Override public P2<Integer, A> lookup(final F<V, Integer> o, final int i) {\r\n    return null; // TODO\r\n  }\r\n\r\n  public <B> B match(final F<Node2<V, A>, B> n2, final F<Node3<V, A>, B> n3) {\r\n    return n2.f(this);\r\n  }\r\n\r\n  public V2<A> toVector() {\r\n    return as;\r\n  }\r\n}\r\n", "ents.  See the NOTICE file distributed with\n* this work for additional information regarding copyright ownership.\n* The ASF licenses this file to You under the Apache License, Version 2.0\n* (the \"License\"); you may not use this file except in compliance with\n* the License.  You may obtain a copy of the License at\n*\n*     http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing, software\n* distributed under the License is distributed on an \"AS IS\" BASIS,\n* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n* See the License for the specific language governing permissions and\n* limitations under the License.\n*/ \npackage javax.servlet.jsp;\n\nimport java.util.Enumeration;\n\nimport javax.el.ELContext;\nimport javax.servlet.jsp.el.ExpressionEvaluator;\nimport javax.servlet.jsp.el.VariableResolver;\n\n/**\n * <p>\n * <code>JspContext</code> serves as the base class for the \n * PageContext class and abstracts all information that is not specific\n * to servlets.  This allows for Simple Tag Extensions to be used\n * outside of the context of a request/response Servlet.\n * <p>\n * The JspContext provides a number of facilities to the \n * page/component author and page implementor, including:\n * <ul>\n * <li>a single API to manage the various scoped namespaces\n * <li>a mechanism to obtain the JspWriter for output\n * <li>a mechanism to expose page directive attributes to the \n *     scripting environment\n * </ul>\n *\n * <p><B>Methods Intended for Container Generated Code</B>\n * <p>\n * The following methods enable the <B>management of nested</B> JspWriter \n * streams to implement Tag Extensions: <code>pushBody()</code> and\n * <code>popBody()</code>\n *\n * <p><B>Methods Intended for JSP authors</B>\n * <p>\n * Some methods provide <B>uniform access</B> to the diverse objects\n * representing scopes.\n * The implementation must use the underlying machinery\n * corresponding to that scope, so information can be passed back and\n * forth between the underlying environment (e.g. Servlets) and JSP pages.\n * The methods are:\n * <code>setAttribute()</code>,  <code>getAttribute()</code>,\n * <code>findAttribute()</code>,  <code>removeAttribute()</code>,\n * <code>getAttributesScope()</code> and \n * <code>getAttributeNamesInScope()</code>.\n * \n * <p>\n * The following methods provide <B>convenient access</B> to implicit objects:\n * <code>getOut()</code>\n *\n * <p>\n * The following methods provide <B>programmatic access</b> to the \n * Expression Language evaluator:\n * <code>getExpressionEvaluator()</code>, <code>getVariableResolver()</code>\n *\n * @since 2.0\n */\n\npublic abstract class JspContext {\n\n    /**\n     * Sole constructor. (For invocation by subclass constructors, \n     * typically implicit.)\n     */\n    public JspContext() {\n        // NOOP by default\n    }\n    \n    /** \n     * Register the name and value specified with page scope semantics.\n     * If the value passed in is <code>null</code>, this has the same \n     * effect as calling \n     * <code>removeAttribute( name, PageContext.PAGE_SCOPE )</code>.\n     *\n     * @param name the name of the attribute to set\n     * @param value the value to associate with the name, or null if the\n     *     attribute is to be removed from the page scope.\n     * @throws NullPointerException if the name is null\n     */\n\n    abstract public void setAttribute(String name, Object value);\n\n    /**\n     * Register the name and value specified with appropriate \n     * scope semantics.  If the value passed in is <code>null</code>, \n     * this has the same effect as calling\n     * <code>removeAttribute( name, scope )</code>.\n     * \n     * @param name the name of the attribute to set\n     * @param value the object to associate with the name, or null if\n     *     the attribute is to be removed from the specified scope.\n     * @param scope the scope with which to associate the name/object\n     * \n     * @throws NullPointerException if the name is null\n     * @throws IllegalArgumentException if the scope is invalid\n     * @throws IllegalStateException if the scope is \n     *     PageContext.SESSION_SCOPE but the page that was requested\n     *     does not participate in a session or the session has been\n     *     invalidated.\n     */\n\n    abstract public void setAttribute(String name, Object value, int scope);\n\n    /**\n     * Returns the object associated with the name in the page scope or null\n     * if not found.\n     *\n     * @param name the name of the attribute to get\n     * @return the object associated with the name in the page scope \n     *     or null if not found.\n     * \n     * @throws NullPointerException if the name is null\n     */\n\n    abstract public Object getAttribute(String name);\n\n    /**\n     * Return the object associated with the name in the specified\n     * scope or null if not found.\n     *\n     * @param name the name of the attribute to set\n     * @param scope the scope with which to associate the name/object\n     * @return the object associated with the name in the specified\n     *     scope or null if not found.\n     * \n     * @throws NullPointerException if the name is null\n     * @throws IllegalArgumentException if the scope is invalid \n     * @throws IllegalStateException if the scope is \n     *     PageContext.SESSION_SCOPE but the page that was requested\n     *     does not participate in a session or the session has been\n     *     invalidated.\n     */\n\n    abstract public Object getAttribute(String name, int scope);\n\n    /**\n     * Searches for the named attribute in page, request, session (if valid),\n     * and application scope(s) in order and returns the value associated or\n     * null.\n     *\n     * @param name the name of the attribute to search for\n     * @return the value associated or null\n     * @throws NullPointerException if the name is null\n     */\n\n    abstract public Object findAttribute(String name);\n\n    /**\n     * Remove the object reference associated with the given name\n     * from all scopes.  Does nothing if there is no such object.\n     *\n     * @param name The name of the object to remove.\n     * @throws NullPointerException if the name is null\n     */\n\n    abstract public void removeAttribute(String name);\n\n    /**\n     * Remove the object reference associated with the specified name\n     * in the given scope.  Does nothing if there is no such object.\n     *\n     * @param name The name of the object to remove.\n     * @param scope The scope where to look.\n     * @throws IllegalArgumentException if the scope is invalid\n     * @throws IllegalStateException if the scope is \n     *     PageContext.SESSION_SCOPE but the page that was requested\n     *     does not participate in a session or the session has been\n     *     invalidated.\n     * @throws NullPointerException if the name is null\n     */\n\n    abstract public void removeAttribute(String name, int scope);\n\n    /**\n     * Get the scope where a given attribute is defined.\n     *\n     * @param name the name of the attribute to return the scope for\n     * @return the scope of the object associated with the name specified or 0\n     * @throws NullPointerException if the name is null\n     */\n\n    abstract public int getAttributesScope(String name);\n\n    /**\n     * Enumerate all the attributes in a given scope.\n     *\n     * @param scope the scope to enumerate all the attributes for\n     * @return an enumeration of names (java.lang.String) of all the \n     *     attributes the specified scope\n     * @throws IllegalArgumentException if the scope is invalid\n     * @throws IllegalStateException if the scope is \n     *     PageContext.SESSION_SCOPE but the page that was requested\n     *     does not participate in a session or the session has been\n     *     invalidated.\n     */\n\n    abstract public Enumeration<String> getAttributeNamesInScope(int scope);\n\n    /**\n     * The current value of the out object (a JspWriter).\n     *\n     * @return the current JspWriter stream being used for client response\n     */\n    abstract public JspWriter getOut();\n    \n    /**\n     * Provides programmatic access to the ExpressionEvaluator.\n     * The JSP Container must return a valid instance of an \n     * ExpressionEvaluator that can parse EL expressions.\n     *\n     * @return A valid instance of an ExpressionEvaluator.\n     * @since 2.0\n     * @deprecated As of JSP 2.1, replaced by\n     *             JspApplicationContext.getExpressionFactory()\n     */\n    @SuppressWarnings(\"dep-ann\") // TCK signature test fails with annotation\n    public abstract ExpressionEvaluator getExpressionEvaluator();\n    \n    \n    public abstract ELContext getELContext();\n    \n    /**\n     * Returns an instance of a VariableResolver that provides access to the\n     * implicit objects specified in the JSP specification using this JspContext\n     * as the context object.\n     *\n     * @return A valid instance of a VariableResolver.\n     * @since 2.0\n     * @deprecated As of JSP 2.1,\n     *             replaced by javax.el.ELContext.getELResolver()\n     *             which can be obtained by\n     *             jspContext.getELContext().getELResolver()\n     */\n    @SuppressWarnings(\"dep-ann\") // TCK signature test fails with annotation\n    public abstract VariableResolver getVariableResolver();\n    \n    /**\n     * Return a new JspWriter object that sends output to the\n     * provided Writer.  Saves the current \"out\" JspWriter,\n     * and updates the value of the \"out\" attribute in the\n     * page scope attribute namespace of the JspContext.\n     * <p>The returned JspWriter must implement all methods and\n     * behave as though it were unbuffered.  More specifically:\n     * <ul>\n     *   <li>clear() must throw an IOException</li>\n     *   <li>clearBuffer() does nothing</li>\n     *   <li>getBufferSize() always returns 0</li>\n     *   <li>getRemaining() always returns 0</li>\n     * </ul>\n     * </p>\n     *\n     * @param writer The Writer for the returned JspWriter to send\n     *     output to.\n     * @return a new JspWriter that writes to the given Writer.\n     * @since 2.0\n     */\n    public JspWriter pushBody( java.io.Writer writer ) {\n        return null; // XXX to implement\n    }\n    \n    /**\n     * Return the previous JspWriter \"out\" saved by the matching\n     * pushBody(), and update the value of the \"out\" attribute in\n     * the page scope attribute namespace of the JspContext.\n     *\n     * @return the saved JspWriter.\n     */\n    public JspWriter popBody() {\n        return null; // XXX to implement\n    }\n}\n", "e of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.iluwatar.prototype;\n\nimport org.junit.jupiter.api.Test;\n\n/**\n * Application test\n */\npublic class AppTest {\n\n  @Test\n  public void test() {\n    App.main(new String[]{});\n  }\n}\n", "scraft.ViesCraft;\nimport com.viesis.viescraft.common.items.ItemHelper;\n\nimport net.minecraft.util.text.translation.I18n;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.item.EnumRarity;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.util.text.TextFormatting;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\n\npublic class ItemBalloon extends Item {\n\t\n\tpublic ItemBalloon() \n\t{\n\t\tItemHelper.setItemName(this, \"airship_balloon\");\n\t\tthis.setMaxStackSize(64);\n\t\tthis.setCreativeTab(ViesCraft.tabViesCraftItems);\n\t}\n\t\n\t@SideOnly(Side.CLIENT)\n    public void addInformation(ItemStack stack, EntityPlayer playerIn, List toolTip, boolean advanced) \n\t{\n\t\ttoolTip.add(TextFormatting.DARK_GREEN + \"================================\");\n\t\ttoolTip.add(TextFormatting.GRAY + I18n.translateToLocal(\"vc.item.tt.balloon.1\"));\n\t\ttoolTip.add(TextFormatting.GRAY + I18n.translateToLocal(\"vc.item.tt.balloon.2\"));\n\t\ttoolTip.add(TextFormatting.DARK_GREEN + \"================================\");\n\t}\n\t\n\tpublic EnumRarity getRarity(ItemStack stack)\n    {\n        return EnumRarity.COMMON;\n    }\n}\n", ".regex.Pattern;\n\npublic abstract class TerminalCommand {\n\t\n\tprivate static final String CMD_CONNECT = \"^connect (?<address>((\\\\d){1,3}\\\\.){3}(\\\\d){1,3})\\\\:(?<port>\\\\d{2,5})$\";\n\tprivate static final String CMD_EXIT \t\t= \"^exit|close|quit$\";\n\tprivate static final String CMD_HELP \t\t= \"^help$\";\n\tprivate static final String CMD_SEND \t\t= \"^send (?<msg>[\\\\w\\\\d\\\\s\\\\.\\\\-\\\\_\\\\/\\\\\\\\]+)$\";\n\n\tprivate static final int ALIAS_CONNECT \t= 0;\n\tprivate static final int ALIAS_EXIT \t\t= 1;\n\tprivate static final int ALIAS_HELP \t\t= 2;\n\tprivate static final int ALIAS_SEND \t\t= 3;\n\n\tpublic void start(){\n\t\tSystem.out.println(\"\\ntype help for help:\\n\");\n\t\tScanner teclado = new Scanner(System.in);\n\t\tString msg;\n\n\t\twhile(true){\n\t\t\tSystem.out.print(\"$ \");\n\t\t\tmsg = teclado.nextLine();\n\t\t\t// REFATORAR: Pensar numa forma de reusar os comandos quando apertas as setas\n\t\t\tif(!run(msg)){\n\t\t\t\tSystem.out.println(\"ERRO: Comando inexistente.\");\n\t\t\t\tSystem.out.println(\" Digite \\'help\\'\");\n\t\t\t\tSystem.out.println(\"\");\n\t\t\t}\n\n\t\t\tif(msg.matches(CMD_EXIT)){\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic boolean run(String cmd){\n\t\treturn interprete(cmd);\n\t}\n\n\tprivate boolean interprete(String cmd){\n\t\t// execute regex\n\t\tboolean result = true;\n\t\t// Create a Pattern object\n    Pattern r;\n    // Now create matcher object.\n    Matcher m;\n\n\t\tif(cmd.matches(CMD_CONNECT)){\n      r = Pattern.compile(CMD_CONNECT);\n    \tm = r.matcher(cmd);\n\n    \tif(m.find()){\n\t\t\t\tString address = m.group(\"address\");\n\t\t\t\tint port = Integer.parseInt(m.group(\"port\"));\n\t\t\t\tconnect(address, port);\n\t\t\t}else{\n\t\t\t\tresult = false;\n\t\t\t}\n\n\n\t\t}else if(cmd.matches(CMD_EXIT)){\n\t\t\texit();\n\n\t\t}else if(cmd.matches(CMD_HELP)){\n\t\t\tSystem.out.println(msgHelp());\n\n\t\t}else if(cmd.matches(CMD_SEND)){\n\t\t\tr = Pattern.compile(CMD_SEND);\n    \tm = r.matcher(cmd);\n\n    \tif(m.find()){\n\t\t\t\tString msg = m.group(\"msg\");\n\t\t\t\tsend(msg);\n\t\t\t}else{\n\t\t\t\tresult = false;\n\t\t\t}\n\n\t\t}else{\n\n\t\t\tresult = false;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprotected abstract void connect(String address, int port);\n\tprotected abstract void exit();\n\tprotected abstract void send(String msg);\n\n\tprivate String msgHelp(){\n\t\tString\tresult;\n\n\t\tresult = (\n\t\t\t\"\\n\"+\n\t\t\t\"connect <ip>:<port>  Use para conectar-se ao host <ip>\\n\"+\n\t\t\t\"                      na porta <port>.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"exit                 Use para desconectar ou desligar\\n\" +\n\t\t\t\"                      o seu host.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"help                 Use para ver essa mensagem.\\n\" +\n\t\t\t\"\\n\" +\n\t\t\t\"send <file>          Use para enviar o arquivo <file> \\n\" +\n\t\t\t\"                      para o servidor.\\n\"+\n\t\t\t\"\\n\"\n\t\t);\n\n\t\treturn result;\n\t}\n}", "FrameInstance;\nimport com.oracle.truffle.api.nodes.Node;\nimport com.oracle.truffle.api.source.SourceSection;\n\nimport som.interpreter.nodes.MessageSendNode.GenericMessageSendNode;\n\n\npublic class PrimitiveCallOrigin {\n  public static Node getCallerNode() {\n    int[] level = new int[1];\n\n    FrameInstance f = Truffle.getRuntime().iterateFrames(fi -> {\n      if (level[0] == 2) {\n        return fi;\n      }\n      level[0]++;\n      return null;\n    });\n    return f.getCallNode();\n  }\n\n  public static SourceSection getCaller() {\n    Node directCallNode = getCallerNode();\n    Node current = directCallNode;\n\n    while (!(current instanceof GenericMessageSendNode)) {\n      current = current.getParent();\n    }\n    return current.getSourceSection();\n  }\n}\n", "craft.entity.player.PlayerEntity;\nimport net.minecraft.entity.player.PlayerInventory;\nimport net.minecraft.inventory.InventoryHelper;\nimport net.minecraft.inventory.ItemStackHelper;\nimport net.minecraft.inventory.container.Container;\nimport net.minecraft.inventory.container.INamedContainerProvider;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.item.crafting.FurnaceRecipe;\nimport net.minecraft.nbt.CompoundNBT;\nimport net.minecraft.network.NetworkManager;\nimport net.minecraft.network.play.server.SUpdateTileEntityPacket;\nimport net.minecraft.tileentity.ITickableTileEntity;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.tileentity.TileEntityType;\nimport net.minecraft.util.Direction;\nimport net.minecraft.util.NonNullList;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.util.text.ITextComponent;\nimport net.minecraft.util.text.StringTextComponent;\nimport net.minecraft.world.World;\nimport net.minecraftforge.common.capabilities.Capability;\nimport net.minecraftforge.common.util.INBTSerializable;\nimport net.minecraftforge.common.util.LazyOptional;\nimport net.minecraftforge.items.CapabilityItemHandler;\nimport net.minecraftforge.items.IItemHandler;\nimport org.apache.logging.log4j.LogManager;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\nimport javax.annotation.ParametersAreNonnullByDefault;\nimport java.util.Objects;\nimport java.util.Optional;\n\n/**\n * Subclass to create a specific TileEntity type for a {@link MachineBlock}, {@code XXTile}.<br>\n * A supplier of this {@code XXTile} must be passed as argument to construct a {@link MachineBlock}.<br>\n * Register with {@code .simpleTileEntity()} on the block registration chain:<br>\n * <pre>\n * MY_MACHINE = REGISTRATE.object(\"my_machine\").block(Material.IRON, p -> new MachineBlock(p, () -> new XXTile(MY_MACHINE.getSibling(ForgeRegistries.TILE_ENTITIES).get())))\n *         .simpleTileEntity(XXTile::new)\n *         .simpleItem().register();\n * </pre>\n * Also, because of how Registrate's registration chains work, {@code XXTile}'s constructor needs to eat a it's own TileEntityType.<br>\n * You can get that with {@code GRINDER.getSibling(ForgeRegistries.TILE_ENTITIES).get()}<br>\n * More details on the constructor javadoc: {@link AbstractMachineTile#AbstractMachineTile}.\n */\npublic abstract class AbstractMachineTile extends TileEntity implements ITickableTileEntity, INamedContainerProvider {\n\n    // todo: trying to implement machine functionality, reference code:\n    // https://github.com/TheGreyGhost/MinecraftByExample/blob/master/src/main/java/minecraftbyexample/mbe31_inventory_furnace/TileEntityFurnace.java\n    private final LazyOptional<IItemHandler> handler = LazyOptional.of(this::createHandler);\n    private final IMachineContainerFactory containerFactory;\n\n    public static int OUTPUT_SLOTS_COUNT;\n    public static int INPUT_SLOTS_COUNT;\n    public static int TOTAL_SLOTS_COUNT;\n\n    private final String INPUT_SLOTS_NBT = \"inputSlots\";\n    private final String OUTPUT_SLOTS_NBT = \"outputSlots\";\n\n    // stores input\n    protected MachineContents inputContents;\n    // stores output\n    protected MachineContents outputContents;\n    // stores state data\n    protected final MachineStateData machineStateData = new MachineStateData();\n\n    protected NonNullList<ItemStack> items;\n\n    /**\n     * Check class javadoc: {@link AbstractMachineTile}.\n     * @param tileEntityTypeIn Subclass constructor param, pass through\n     * @param containerFactory A factory of {@code XXTile}'s respective {@code XXContainer} -> {@code XXContainer::new} should suffice.\n     */\n    public AbstractMachineTile(TileEntityType<?> tileEntityTypeIn, IMachineContainerFactory containerFactory) {\n        super(tileEntityTypeIn);\n        this.containerFactory = containerFactory;\n        inputContents = MachineContents.createForTileEntity(INPUT_SLOTS_COUNT, this::canPlayerAccessInventory, this::markDirty);\n        outputContents = MachineContents.createForTileEntity(OUTPUT_SLOTS_COUNT, this::canPlayerAccessInventory, this::markDirty);\n    }\n\n    /**\n     * Implementation example:\n     * <pre>{@code return new ItemStackHandler(1) {\n     *     @Override\n     *     public boolean isItemValid(int slot, ItemStack stack) {\n     *         return stack.getItem() == RegistrateHandler.SOME_ITEM.get().asItem();\n     *     }\n     *     @Override\n     *     public ItemStack insertItem(int slot, ItemStack stack, boolean simulate) {\n     *         if (stack.getItem() != RegistrateHandler.SOME_ITEM.get().asItem()) {\n     *             return stack;\n     *         }\n     *         return super.insertItem(slot, stack, simulate);\n     *     }\n     * };}</pre>\n     * @return An ItemHandler with your machine's specific functionality.\n     */\n    @Nonnull\n    protected abstract IItemHandler createHandler();\n\n    public abstract boolean canPlayerAccessInventory(PlayerEntity player);\n\n    @Nonnull\n    @Override\n    public ITextComponent getDisplayName() {\n        return new StringTextComponent(Objects.requireNonNull(getType().getRegistryName()).getPath());\n    }\n\n    /**\n     * The name is misleading; createMenu has nothing to do with creating a Screen, it is used to create the Container on the server only\n     * @param windowID\n     * @param inv\n     * @param player\n     * @return\n     */\n    @Override\n    @ParametersAreNonnullByDefault\n    public Container createMenu(int windowID, PlayerInventory inv, PlayerEntity player) {\n        // return containerFactory.create(windowID, inv, pos);\n        return containerFactory.create(windowID, inv, pos);\n    }\n\n    // This is where you load the data that you saved in writeToNBT\n    @Override\n    @ParametersAreNonnullByDefault\n    public void read(BlockState state, CompoundNBT tag) {\n        super.read(state, tag);\n        machineStateData.readFromNBT(tag);\n        CompoundNBT inventoryNBT = tag.getCompound(INPUT_SLOTS_NBT);\n        inputContents.deserializeNBT(inventoryNBT);\n        inventoryNBT = tag.getCompound(OUTPUT_SLOTS_NBT);\n        outputContents.deserializeNBT(inventoryNBT);\n\n        if (inputContents.getSizeInventory() != INPUT_SLOTS_COUNT || outputContents.getSizeInventory() != OUTPUT_SLOTS_COUNT)\n            throw new IllegalArgumentException(\"Corrupted NBT: Number of inventory slots did not match expected\");\n    }\n\n\n    // This is where you save any data that you don't want to lose when the tile entity unloads\n    // In this case, it saves the state of the machine (burn time etc) and the ItemStacks stored in the input, and output slots\n    @Nonnull\n    @Override\n    @ParametersAreNonnullByDefault\n    public CompoundNBT write(CompoundNBT tag) {\n\n        machineStateData.putIntoNBT(tag);\n        tag.put(INPUT_SLOTS_NBT, inputContents.serializeNBT());\n        tag.put(OUTPUT_SLOTS_NBT, outputContents.serializeNBT());\n\n        return super.write(tag);\n    }\n\n    @Nonnull\n    @Override\n    public <T> LazyOptional<T> getCapability(@Nonnull Capability<T> cap, @Nullable Direction side) {\n        if (cap == CapabilityItemHandler.ITEM_HANDLER_CAPABILITY) {\n            return handler.cast();\n        }\n        return super.getCapability(cap, side);\n    }\n\n    /*\n    * Notes on TileEntity and why all the following networking is required:\n    * Client and Server refer to the logical client (render, guis, etc) and logical server (game logic) that run for every minecraft world\n    *\n    * There is no connection between the Client TE and the Client Container\n    * The client TE syncs with the Server TE via these networking methods\n    * The Server TE talks to the Server Container\n    * The Server Container syncs with the Client Container, which talks with the Screen, both existing only when the client opens the GUI (created and destroyed)\n    * */\n\n    // When the world loads from disk, the server needs to send the TE info to the client\n    // This happens with getUpdatePacket(), getUpdateTag(), onDataPacket() and handleUpdateTag()\n    @Nullable\n    @Override\n    public SUpdateTileEntityPacket getUpdatePacket() {\n        CompoundNBT updateTag = getUpdateTag();\n        final int METADATA = 42; // arbitrary --> so why dafuk??? https://github.com/TheGreyGhost/MinecraftByExample/blob/b8d7d5f304314b3065f5d149ab15f50485c1e1d8/src/main/java/minecraftbyexample/mbe31_inventory_furnace/TileEntityFurnace.java#L376\n        return new SUpdateTileEntityPacket(this.pos, METADATA, updateTag);\n    }\n\n    @Override\n    public void onDataPacket(NetworkManager net, SUpdateTileEntityPacket pkt) {\n        CompoundNBT updateTag = pkt.getNbtCompound();\n        BlockState blockState = world.getBlockState(pos);\n        handleUpdateTag(blockState, updateTag);\n    }\n\n    // Creates a tag containing the TE info, used by vanilla to transmit from server to client\n    // Warning - although out getUpdatePacket() uses this, vanilla also calls it directly so don't remove it!\n    @Override\n    public CompoundNBT getUpdateTag() {\n        CompoundNBT tag = new CompoundNBT();\n        write(tag);\n        return tag;\n    }\n\n    // Populates this TE with info from the tag, used by vanilla to transmit from server to client\n    // This is exactly equal to the method it overrides (vanilla default). Here for clarity\n    @Override\n    public void handleUpdateTag(BlockState state, CompoundNBT tag) {\n        read(state, tag);\n    }\n\n    /**\n     * Drop all TE contents when destroyed\n     * @param world\n     * @param pos\n     */\n    public void dropAllContents(World world, BlockPos pos) {\n        InventoryHelper.dropInventoryItems(world, pos, inputContents);\n        InventoryHelper.dropInventoryItems(world, pos, outputContents);\n    }\n\n    public boolean isBurning() {\n        return machineStateData.cookTimeElapsed < machineStateData.cookTimeForCompletion;\n    }\n\n    /**\n     *\n     * @param world\n     * @param itemStack\n     * @return result of smelt for itemStack or ItemStack.EMPTY if can't be smelted\n     */\n    public ItemStack getSmeltingResultForItem(World world, ItemStack itemStack) {\n        Optional<FurnaceRecipe> matchingRecipe = getMatchingRecipeForInput(world, itemStack);\n        return matchingRecipe.map(furnaceRecipe -> furnaceRecipe.getRecipeOutput().copy()).orElse(ItemStack.EMPTY);\n    }\n\n    // todo: making this not static to allow overrides started a chain of making methods not static that should be thought over\n    protected abstract Optional<FurnaceRecipe> getMatchingRecipeForInput(World world, ItemStack itemStack);\n}\n", "ItemStack;\nimport net.minecraft.nbt.NBTTagCompound;\nimport net.minecraft.nbt.NBTTagList;\nimport net.minecraft.network.PacketBuffer;\nimport net.minecraft.util.NonNullList;\n\npublic abstract class PacketNBT extends PenguinPacket {\n    public NBTTagCompound nbt;\n\n    public PacketNBT() {\n    }\n\n    public PacketNBT(NonNullList<ItemStack> inventory) {\n        nbt = new NBTTagCompound();\n        nbt.setInteger(\"length\", inventory.size());\n        NBTTagList itemList = new NBTTagList();\n        for (int i = 0; i < inventory.size(); i++) {\n            ItemStack stack = inventory.get(i);\n            if (!stack.isEmpty()) {\n                NBTTagCompound tag = new NBTTagCompound();\n                tag.setByte(\"Slot\", (byte) i);\n                tag.setBoolean(\"NULLItemStack\", false);\n                stack.writeToNBT(tag);\n                itemList.appendTag(tag);\n            } else {\n                NBTTagCompound tag = new NBTTagCompound();\n                tag.setByte(\"Slot\", (byte) i);\n                tag.setBoolean(\"NULLItemStack\", true);\n                itemList.appendTag(tag);\n            }\n        }\n        nbt.setTag(\"Inventory\", itemList);\n    }\n\n    @Override\n    public void toBytes(ByteBuf buffer) {\n        try {\n            new PacketBuffer(buffer).writeCompoundTag(nbt);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    public void fromBytes(ByteBuf buffer) {\n        try {\n            nbt = new PacketBuffer(buffer).readCompoundTag();\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n}", "th.service.SecurityService;\nimport com.hellokoding.auth.service.UserService;\nimport com.hellokoding.auth.validator.UserValidator;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\n@Controller\npublic class UserController {\n    @Autowired\n    private UserService userService;\n\n    @Autowired\n    private SecurityService securityService;\n\n    @Autowired\n    private UserValidator userValidator;\n\n    @RequestMapping(value = \"/registration\", method = RequestMethod.GET)\n    public String registration(Model model) {\n        model.addAttribute(\"userForm\", new User());\n\n        return \"registration\";\n    }\n\n    @RequestMapping(value = \"/registration\", method = RequestMethod.POST)\n    public String registration(@ModelAttribute(\"userForm\") User userForm, BindingResult bindingResult, Model model) {\n        userValidator.validate(userForm, bindingResult);\n\n        if (bindingResult.hasErrors()) {\n            return \"registration\";\n        }\n\n//        userService.save(userForm);\n\n        securityService.autologin(userForm.getUsername(), userForm.getPasswordConfirm());\n\n        return \"redirect:/welcome\";\n    }\n\n    @RequestMapping(value = \"/login\", method = RequestMethod.GET)\n    public String login(Model model, String error, String logout) {\n        if (error != null)\n            model.addAttribute(\"error\", \"Your username and password is invalid.\");\n\n        if (logout != null)\n            model.addAttribute(\"message\", \"You have been logged out successfully.\");\n\n        return \"login\";\n    }\n\n    @RequestMapping(value = {\"/\", \"/welcome\"}, method = RequestMethod.GET)\n    public String welcome(Model model) {\n        return \"welcome\";\n    }\n}\n", "free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage org.jdbdt;\n\nimport static org.junit.Assert.*;\nimport static org.jdbdt.JDBDT.*;\nimport static org.jdbdt.TestUtil.*;\n\nimport org.junit.Before;\nimport org.junit.FixMethodOrder;\nimport org.junit.Test;\nimport org.junit.runners.MethodSorters;\n\n@SuppressWarnings(\"javadoc\")\n@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic class TableTest extends DBTestCase {  \n  private Table theSUT;\n  \n  @Before\n  public void createTable() {\n    theSUT = table(UserDAO.TABLE_NAME).columns(UserDAO.COLUMNS).build(getDB());\n  }\n  \n  @Test\n  public void testInit() {\n    assertEquals(UserDAO.TABLE_NAME, theSUT.getName());\n  }\n  \n  @Test\n  public void testQueryExecution() {\n    DataSet actual = executeQuery(theSUT);\n    DataSet expected = \n      data(theSUT, getConversion())\n        .rows(INITIAL_DATA);\n    assertDataSet(expected, actual);\n  }\n  \n  \n}\n", ".xgen4j.test.info_generation.regularTest.ea1.ea2.EA2Error;\n\nimport java.lang.String;\nimport java.lang.Integer;\nimport com.rodrigodev.xgen4j.test.common.doubles.error.message.TestObject;\n\nimport com.rodrigodev.xgen4j.test.info_generation.regularTest.ErrorCode;\n\n/**\n * Autogenerated by XGen4J on January 1, 0001.\n */\npublic abstract class EA3_2Error extends EA2Error {\n\n    public static final ErrorCode CODE = new ErrorCode(\"e-a-3-2\", 2345, EA2Error.CODE);\n\n    private static String MESSAGE_FORMAT = \"EA3_2: {param1: '%s', param2: %d, param3: '%s'}\";\n\n    private static String createMessage(String param1, Integer param2, TestObject param3) {\n        if(param1 == null) throw new NullPointerException(\"param1\");\n        if(param2 == null) throw new NullPointerException(\"param2\");\n        if(param3 == null) throw new NullPointerException(\"param3\");\n\n        return String.format(MESSAGE_FORMAT, param1, param2, param3);\n    }\n\n    public static void throwException(String param1, Integer param2, TestObject param3) {\n        throw new EA3_2Exception(CODE, createMessage(param1, param2, param3));\n    }\n\n    public static void throwException(String param1, Integer param2, TestObject param3, Throwable cause) {\n        throw new EA3_2Exception(CODE, createMessage(param1, param2, param3), cause);\n    }\n\n\n}\n", "swing.JApplet;\r\nimport javax.swing.SwingUtilities;\r\n\r\nimport com.doremitutor.support.Utilities;\r\n\r\npublic class SinWaveDemoApplet extends JApplet{\r\n\tpublic void init() {\r\n\t\tfinal JApplet applet=this;\r\n\t\ttry {\r\n\t\t\tSwingUtilities.invokeAndWait(new Runnable() {\r\n\t\t\t\tpublic void run() {\r\n\t\t\t\t\tUtilities.setUpApp(applet, null, SinWaveDemoPanel.getInstance(false));\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t} catch (InvocationTargetException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t} catch (InterruptedException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\tpublic void destroy(){\r\n\t\tSystem.exit(0);\r\n\t}\r\n}", ";\nimport io.feellix.restvideodemo.file.DevNullFileStorageRepository;\nimport org.apache.tika.Tika;\nimport org.dozer.DozerBeanMapper;\nimport org.dozer.Mapper;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class VideoDemoConfig {\n\n    @Bean\n    public Mapper mapper() {\n        return new DozerBeanMapper();\n    }\n\n    @Bean\n    public FileStorageRepository storageRepository() {\n        return new DevNullFileStorageRepository();\n    }\n\n    @Bean\n    public Tika defaultDetector() {\n        return new Tika();\n    }\n}\n", "WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n * NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\n\npackage com.stakhouski.anton.stealandrun;\n\nimport android.content.Context;\nimport android.opengl.GLSurfaceView;\n\n/**\n * Created by archer on 15.10.16.\n */\n\npublic class MyGLSurfaceView extends GLSurfaceView {\n\n    public MyGLSurfaceView(Context context) {\n        super(context);\n\n        // Create an OpenGL ES 3.0 context\n        setEGLContextClientVersion(3);\n\n        // Render the view only when there is a change in the drawing data\n        //setRenderMode(GLSurfaceView.RENDERMODE_WHEN_DIRTY);\n    }\n\n}\n", "olarbirds.gifcreator.javafx.JavaFxController;\nimport javafx.collections.ObservableList;\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.Parent;\nimport javafx.scene.Scene;\nimport javafx.stage.Stage;\n\nimport java.io.IOException;\nimport java.net.URL;\nimport java.util.Locale;\nimport java.util.PropertyResourceBundle;\n\npublic final class ApplicationWindow {\n\n    /**\n     * Shows a fresh instance of a page.\n     * @param page which page to show.\n     */\n    public static void showPage(final ApplicationPage page) {\n        FXMLLoader loader = new FXMLLoader();\n\n        loader.setLocation(jarResource(page.fxmlPath));\n        loader.setResources(PropertyResourceBundle.getBundle(page.resourcesBundlePath, Locale.getDefault()));\n\n        Parent root = null;\n        try {\n            root = loader.load();\n        } catch (IOException e) {\n            System.err.println(\"Failed to change page to \" + page.name());\n            e.printStackTrace();\n            return;\n        }\n\n        Scene scene = new Scene(root);\n        ObservableList<String> stylesheets = scene.getStylesheets();\n        for (final String stylesheetPath : page.stylesheetPaths) {\n            stylesheets.add(jarResource(stylesheetPath).toExternalForm());\n        }\n\n        final SharedState state = SharedState.getInstance();\n        Object controller = loader.getController();\n        Stage primaryStage = state.getPrimaryStage();\n        if (controller instanceof JavaFxController) {\n            ((JavaFxController) controller).setStage(primaryStage);\n        }\n\n        primaryStage.setScene(scene);\n        disposeController(state.currentJavafxController);\n        state.currentJavafxController = controller;\n\n    }\n\n    protected static void disposeController(Object controller) {\n        if (controller instanceof Disposable) {\n            ((Disposable) controller).dispose();\n        }\n    }\n\n    protected static URL jarResource(String jarPath) {\n        return ApplicationWindow.class.getResource(jarPath);\n    }\n\n}\n", "and binary forms, with or without modification, are permitted\n * provided that the following conditions are met:\n *\n * * Redistributions of source code must retain the above copyright notice, this list of conditions\n * and the following disclaimer.\n *\n * * Redistributions in binary form must reproduce the above copyright notice, this list of\n * conditions and the following disclaimer in the documentation and/or other materials provided with\n * the distribution.\n *\n * * Neither the name of [project] nor the names of its contributors may be used to endorse or\n * promote products derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\n * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY\n * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage com.systematic.trading.strategy.operator;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\n\nimport java.time.LocalDate;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport com.systematic.trading.model.signal.SignalType;\nimport com.systematic.trading.signal.model.DatedSignal;\n\n/**\n * Verifies the trading strategy AND operator performs as a logical AND.\n * \n * @author CJ Hare\n */\npublic class TradingStrategyAndOperatorTest {\n\n\t/** OR instance being tested. */\n\tprivate TradingStrategyAndOperator operator;\n\n\t@Before\n\tpublic void setUp() {\n\n\t\toperator = new TradingStrategyAndOperator();\n\t}\n\n\t@Test\n\tpublic void conjoin() {\n\n\t\tfinal List<DatedSignal> left = signals(signal(LocalDate.of(2011, 4, 18)), signal(LocalDate.of(2011, 6, 26)));\n\t\tfinal List<DatedSignal> right = signals(\n\t\t        signal(LocalDate.of(2011, 4, 18)),\n\t\t        signal(LocalDate.of(2011, 5, 21)),\n\t\t        signal(LocalDate.of(2011, 6, 26), SignalType.BEARISH));\n\n\t\tfinal List<DatedSignal> signals = conjoin(left, right);\n\n\t\tverifySignals(signals(signal(LocalDate.of(2011, 4, 18))), signals);\n\t}\n\n\t@Test\n\tpublic void conjoinLeftOnly() {\n\n\t\tfinal List<DatedSignal> left = signals(signal(LocalDate.of(2011, 5, 21)));\n\t\tfinal List<DatedSignal> right = signals();\n\n\t\tfinal List<DatedSignal> signals = conjoin(left, right);\n\n\t\tverifySignals(signals(), signals);\n\t}\n\n\t@Test\n\tpublic void conjoinRightOnly() {\n\n\t\tfinal List<DatedSignal> left = signals();\n\t\tfinal List<DatedSignal> right = signals(signal(LocalDate.of(2011, 5, 21)));\n\n\t\tfinal List<DatedSignal> signals = conjoin(left, right);\n\n\t\tverifySignals(signals(), signals);\n\t}\n\n\t@Test\n\tpublic void conjoinBoth() {\n\n\t\tfinal List<DatedSignal> left = signals(signal(LocalDate.of(2011, 5, 21)));\n\t\tfinal List<DatedSignal> right = signals(signal(LocalDate.of(2011, 5, 21)));\n\n\t\tfinal List<DatedSignal> signals = conjoin(left, right);\n\n\t\tverifySignals(signals(signal(LocalDate.of(2011, 5, 21))), signals);\n\t}\n\n\tprivate List<DatedSignal> conjoin( final List<DatedSignal> left, final List<DatedSignal> right ) {\n\n\t\treturn operator.conjoin(left, right);\n\t}\n\n\tprivate List<DatedSignal> signals( final DatedSignal... dates ) {\n\n\t\tfinal List<DatedSignal> signals = new ArrayList<>(dates.length);\n\n\t\tfor (final DatedSignal date : dates) {\n\t\t\tsignals.add(date);\n\t\t}\n\n\t\treturn signals;\n\t}\n\n\tprivate DatedSignal signal( final LocalDate date ) {\n\n\t\treturn new DatedSignal(date, SignalType.BULLISH);\n\t}\n\n\tprivate DatedSignal signal( final LocalDate date, final SignalType type ) {\n\n\t\treturn new DatedSignal(date, type);\n\t}\n\n\tprivate void verifySignals( final List<DatedSignal> expected, final List<DatedSignal> actual ) {\n\n\t\tassertNotNull(actual);\n\t\tassertEquals(expected.size(), actual.size());\n\n\t\tfor (int i = 0; i < expected.size(); i++) {\n\t\t\tassertEquals(expected.get(i).date(), actual.get(i).date());\n\t\t\tassertEquals(expected.get(i).type(), actual.get(i).type());\n\t\t}\n\t}\n}\n", "port java.util.TreeMap;\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Arrays;\nimport java.util.Iterator;\n\n\npublic class DiceRoll {\n\n\tpublic static void main(String args[]) throws IOException\n\t{\n\t\tScanner kb = new Scanner(new File(\"diceroll.dat\"));\n\t\t\n\t\tint times = 0; \n\t\tint count = Integer.parseInt(kb.nextLine().trim());\n\t\twhile(times < count) {\n\t\t\ttimes++;\n\t\t\tString t = kb.nextLine().trim();\n\t\t\t\t\t\n\t\t\tRandom rand = new Random(Long.parseLong(t));\t\n \t\t\tString top = \"WHITE\";\n\n\t\t\tint dir = rand.nextInt(4) + 1;\t\t\t// direction of roll\n\t\t\tint numTimes = rand.nextInt(25) + 1;\t\t\t// number of times it rolls\n\t\t\t\n\t\t\t//numTimes is even, color stay the same\n\t\t\t//numTimes is odd, color changes\n\t\t\t//dir=1 or dir=2 ==> roll forward or backward\n\t\t\t//dir=3 or dir=4 ==> roll left or right\n\n\t\t\tif(numTimes % 2 == 1)\n\t\t\t\tif(dir==1 || dir==2)\n\t\t\t\t\ttop = \"RED\";\n\t\t\t\telse\n\t\t\t\t\ttop = \"BLUE\";\t\t\n\t\t\tout.println(top);\n\t\t\t\n//\t\t\tprint random numbers generated\n//\t\t\tout.print(dir + \" \" + numTimes + \" \");\t\t\n\t\t}\n\t}\t\n}\n", "hts reserved.\n */\npackage com.iwc.shop.modules.test.service;\n\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport com.iwc.shop.common.service.CrudService;\nimport com.iwc.shop.modules.test.entity.Test;\nimport com.iwc.shop.modules.test.dao.TestDao;\n\n/**\n * \u6d4b\u8bd5Service\n * @author Tony Wong\n * @version 2013-10-17\n */\n@Service\n@Transactional(readOnly = true)\npublic class TestService extends CrudService<TestDao, Test> {\n\n}\n", " third-party contributors as\n * indicated by the @author tags or express copyright attribution\n * statements applied by the authors.  All third-party contributions are\n * distributed under license by Red Hat Inc.\n *\n * This copyrighted material is made available to anyone wishing to use, modify,\n * copy, or redistribute it subject to the terms and conditions of the GNU\n * Lesser General Public License, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this distribution; if not, write to:\n * Free Software Foundation, Inc.\n * 51 Franklin Street, Fifth Floor\n * Boston, MA  02110-1301  USA\n */\npackage org.hibernate.type;\n\nimport java.io.Serializable;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.util.Map;\n\nimport org.dom4j.Element;\nimport org.dom4j.Node;\nimport org.hibernate.AssertionFailure;\nimport org.hibernate.EntityMode;\nimport org.hibernate.HibernateException;\nimport org.hibernate.MappingException;\nimport org.hibernate.engine.internal.ForeignKeys;\nimport org.hibernate.engine.spi.EntityUniqueKey;\nimport org.hibernate.engine.spi.Mapping;\nimport org.hibernate.engine.spi.PersistenceContext;\nimport org.hibernate.engine.spi.SessionFactoryImplementor;\nimport org.hibernate.engine.spi.SessionImplementor;\nimport org.hibernate.internal.util.ReflectHelper;\nimport org.hibernate.persister.entity.EntityPersister;\nimport org.hibernate.persister.entity.Joinable;\nimport org.hibernate.persister.entity.UniqueKeyLoadable;\nimport org.hibernate.proxy.HibernateProxy;\nimport org.hibernate.tuple.ElementWrapper;\n\n/**\n * Base for types which map associations to persistent entities.\n *\n * @author Gavin King\n */\npublic abstract class EntityType extends AbstractType implements AssociationType {\n\n\tprivate final TypeFactory.TypeScope scope;\n\tprivate final String associatedEntityName;\n\tprotected final String uniqueKeyPropertyName;\n\tprotected final boolean isEmbeddedInXML;\n\tprivate final boolean eager;\n\tprivate final boolean unwrapProxy;\n\tprivate final boolean referenceToPrimaryKey;\n\n\tprivate transient Class returnedClass;\n\n\t/**\n\t * Constructs the requested entity type mapping.\n\t *\n\t * @param scope The type scope\n\t * @param entityName The name of the associated entity.\n\t * @param uniqueKeyPropertyName The property-ref name, or null if we\n\t * reference the PK of the associated entity.\n\t * @param eager Is eager fetching enabled.\n\t * @param isEmbeddedInXML Should values of this mapping be embedded in XML modes?\n\t * @param unwrapProxy Is unwrapping of proxies allowed for this association; unwrapping\n\t * says to return the \"implementation target\" of lazy prooxies; typically only possible\n\t * with lazy=\"no-proxy\".\n\t *\n\t * @deprecated Use {@link #EntityType(org.hibernate.type.TypeFactory.TypeScope, String, boolean, String, boolean, boolean)} instead.\n\t * See Jira issue: <a href=\"https://hibernate.onjira.com/browse/HHH-7771\">HHH-7771</a>\n\t */\n\t@Deprecated\n\tprotected EntityType(\n\t\t\tTypeFactory.TypeScope scope,\n\t\t\tString entityName,\n\t\t\tString uniqueKeyPropertyName,\n\t\t\tboolean eager,\n\t\t\tboolean isEmbeddedInXML,\n\t\t\tboolean unwrapProxy) {\n\t\tthis( scope, entityName, uniqueKeyPropertyName == null, uniqueKeyPropertyName, eager, unwrapProxy );\n\t}\n\n\t/**\n\t * Constructs the requested entity type mapping.\n\t *\n\t * @param scope The type scope\n\t * @param entityName The name of the associated entity.\n\t * @param uniqueKeyPropertyName The property-ref name, or null if we\n\t * reference the PK of the associated entity.\n\t * @param eager Is eager fetching enabled.\n\t * @param unwrapProxy Is unwrapping of proxies allowed for this association; unwrapping\n\t * says to return the \"implementation target\" of lazy prooxies; typically only possible\n\t * with lazy=\"no-proxy\".\n\t * \n\t * @deprecated Use {@link #EntityType(org.hibernate.type.TypeFactory.TypeScope, String, boolean, String, boolean, boolean)} instead.\n\t */\n\t@Deprecated\n\tprotected EntityType(\n\t\t\tTypeFactory.TypeScope scope,\n\t\t\tString entityName,\n\t\t\tString uniqueKeyPropertyName,\n\t\t\tboolean eager,\n\t\t\tboolean unwrapProxy) {\n\t\tthis( scope, entityName, uniqueKeyPropertyName == null, uniqueKeyPropertyName, eager, unwrapProxy );\n\t}\n\n\t/**\n\t * Constructs the requested entity type mapping.\n\t *\n\t * @param scope The type scope\n\t * @param entityName The name of the associated entity.\n\t * @param referenceToPrimaryKey True if association references a primary key.\n\t * @param uniqueKeyPropertyName The property-ref name, or null if we\n\t * reference the PK of the associated entity.\n\t * @param eager Is eager fetching enabled.\n\t * @param unwrapProxy Is unwrapping of proxies allowed for this association; unwrapping\n\t * says to return the \"implementation target\" of lazy prooxies; typically only possible\n\t * with lazy=\"no-proxy\".\n\t */\n\tprotected EntityType(\n\t\t\tTypeFactory.TypeScope scope,\n\t\t\tString entityName,\n\t\t\tboolean referenceToPrimaryKey,\n\t\t\tString uniqueKeyPropertyName,\n\t\t\tboolean eager,\n\t\t\tboolean unwrapProxy) {\n\t\tthis.scope = scope;\n\t\tthis.associatedEntityName = entityName;\n\t\tthis.uniqueKeyPropertyName = uniqueKeyPropertyName;\n\t\tthis.isEmbeddedInXML = true;\n\t\tthis.eager = eager;\n\t\tthis.unwrapProxy = unwrapProxy;\n\t\tthis.referenceToPrimaryKey = referenceToPrimaryKey;\n\t}\n\n\tprotected TypeFactory.TypeScope scope() {\n\t\treturn scope;\n\t}\n\n\t/**\n\t * An entity type is a type of association type\n\t *\n\t * @return True.\n\t */\n\tpublic boolean isAssociationType() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * Explicitly, an entity type is an entity type ;)\n\t *\n\t * @return True.\n\t */\n\tpublic final boolean isEntityType() {\n\t\treturn true;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic boolean isMutable() {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generates a string representation of this type.\n\t *\n\t * @return string rep\n\t */\n\tpublic String toString() {\n\t\treturn getClass().getName() + '(' + getAssociatedEntityName() + ')';\n\t}\n\n\t/**\n\t * For entity types, the name correlates to the associated entity name.\n\t */\n\tpublic String getName() {\n\t\treturn associatedEntityName;\n\t}\n\n\t/**\n\t * Does this association foreign key reference the primary key of the other table?\n\t * Otherwise, it references a property-ref.\n\t *\n\t * @return True if this association reference the PK of the associated entity.\n\t */\n\tpublic boolean isReferenceToPrimaryKey() {\n\t\treturn referenceToPrimaryKey;\n\t}\n\n\tpublic String getRHSUniqueKeyPropertyName() {\n\t\t// Return null if this type references a PK.  This is important for\n\t\t// associations' use of mappedBy referring to a derived ID.\n\t\treturn referenceToPrimaryKey ? null : uniqueKeyPropertyName;\n\t}\n\n\tpublic String getLHSPropertyName() {\n\t\treturn null;\n\t}\n\n\tpublic String getPropertyName() {\n\t\treturn null;\n\t}\n\n\t/**\n\t * The name of the associated entity.\n\t *\n\t * @return The associated entity name.\n\t */\n\tpublic final String getAssociatedEntityName() {\n\t\treturn associatedEntityName;\n\t}\n\n\t/**\n\t * The name of the associated entity.\n\t *\n\t * @param factory The session factory, for resolution.\n\t * @return The associated entity name.\n\t */\n\tpublic String getAssociatedEntityName(SessionFactoryImplementor factory) {\n\t\treturn getAssociatedEntityName();\n\t}\n\n\t/**\n\t * Retrieves the {@link Joinable} defining the associated entity.\n\t *\n\t * @param factory The session factory.\n\t * @return The associated joinable\n\t * @throws MappingException Generally indicates an invalid entity name.\n\t */\n\tpublic Joinable getAssociatedJoinable(SessionFactoryImplementor factory) throws MappingException {\n\t\treturn ( Joinable ) factory.getEntityPersister( associatedEntityName );\n\t}\n\n\t/**\n\t * This returns the wrong class for an entity with a proxy, or for a named\n\t * entity.  Theoretically it should return the proxy class, but it doesn't.\n\t * <p/>\n\t * The problem here is that we do not necessarily have a ref to the associated\n\t * entity persister (nor to the session factory, to look it up) which is really\n\t * needed to \"do the right thing\" here...\n\t *\n\t * @return The entiyt class.\n\t */\n\tpublic final Class getReturnedClass() {\n\t\tif ( returnedClass == null ) {\n\t\t\treturnedClass = determineAssociatedEntityClass();\n\t\t}\n\t\treturn returnedClass;\n\t}\n\n    private Class determineAssociatedEntityClass() {\n        final String entityName = getAssociatedEntityName();\n        try {\n            return ReflectHelper.classForName(entityName);\n        }\n        catch ( ClassNotFoundException cnfe ) {\n            return this.scope.resolveFactory().getEntityPersister(entityName).\n                getEntityTuplizer().getMappedClass();\n        }\n    }\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic Object nullSafeGet(ResultSet rs, String name, SessionImplementor session, Object owner)\n\tthrows HibernateException, SQLException {\n\t\treturn nullSafeGet( rs, new String[] {name}, session, owner );\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic final Object nullSafeGet(\n\t\t\tResultSet rs,\n\t\t\tString[] names,\n\t\t\tSessionImplementor session,\n\t\t\tObject owner) throws HibernateException, SQLException {\n\t\treturn resolve( hydrate(rs, names, session, owner), session, owner );\n\t}\n\n\t/**\n\t * Two entities are considered the same when their instances are the same.\n\t *\n\t *\n\t * @param x One entity instance\n\t * @param y Another entity instance\n\t * @return True if x == y; false otherwise.\n\t */\n\tpublic final boolean isSame(Object x, Object y) {\n\t\treturn x == y;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic int compare(Object x, Object y) {\n\t\treturn 0; //TODO: entities CAN be compared, by PK, fix this! -> only if/when we can extract the id values....\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic Object deepCopy(Object value, SessionFactoryImplementor factory) {\n\t\treturn value; //special case ... this is the leaf of the containment graph, even though not immutable\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic Object replace(\n\t\t\tObject original,\n\t\t\tObject target,\n\t\t\tSessionImplementor session,\n\t\t\tObject owner,\n\t\t\tMap copyCache) throws HibernateException {\n\t\tif ( original == null ) {\n\t\t\treturn null;\n\t\t}\n\t\tObject cached = copyCache.get(original);\n\t\tif ( cached != null ) {\n\t\t\treturn cached;\n\t\t}\n\t\telse {\n\t\t\tif ( original == target ) {\n\t\t\t\treturn target;\n\t\t\t}\n\t\t\tif ( session.getContextEntityIdentifier( original ) == null  &&\n\t\t\t\t\tForeignKeys.isTransient( associatedEntityName, original, Boolean.FALSE, session ) ) {\n\t\t\t\tfinal Object copy = session.getEntityPersister( associatedEntityName, original )\n\t\t\t\t\t\t.instantiate( null, session );\n\t\t\t\tcopyCache.put( original, copy );\n\t\t\t\treturn copy;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tObject id = getIdentifier( original, session );\n\t\t\t\tif ( id == null ) {\n\t\t\t\t\tthrow new AssertionFailure(\"non-transient entity has a null id\");\n\t\t\t\t}\n\t\t\t\tid = getIdentifierOrUniqueKeyType( session.getFactory() )\n\t\t\t\t\t\t.replace(id, null, session, owner, copyCache);\n\t\t\t\treturn resolve( id, session, owner );\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic int getHashCode(Object x, SessionFactoryImplementor factory) {\n\t\tEntityPersister persister = factory.getEntityPersister(associatedEntityName);\n\t\tif ( !persister.canExtractIdOutOfEntity() ) {\n\t\t\treturn super.getHashCode( x );\n\t\t}\n\n\t\tfinal Serializable id;\n\t\tif (x instanceof HibernateProxy) {\n\t\t\tid = ( (HibernateProxy) x ).getHibernateLazyInitializer().getIdentifier();\n\t\t}\n\t\telse {\n\t\t\tfinal Class mappedClass = persister.getMappedClass();\n\t\t\tif ( mappedClass.isAssignableFrom( x.getClass() ) ) {\n\t\t\t\tid = persister.getIdentifier( x );\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = (Serializable) x;\n\t\t\t}\n\t\t}\n\t\treturn persister.getIdentifierType().getHashCode( id, factory );\n\t}\n\n\t@Override\n\tpublic boolean isEqual(Object x, Object y, SessionFactoryImplementor factory) {\n\t\t// associations (many-to-one and one-to-one) can be null...\n\t\tif ( x == null || y == null ) {\n\t\t\treturn x == y;\n\t\t}\n\n\t\tEntityPersister persister = factory.getEntityPersister(associatedEntityName);\n\t\tif ( !persister.canExtractIdOutOfEntity() ) {\n\t\t\treturn super.isEqual(x, y );\n\t\t}\n\n\t\tfinal Class mappedClass = persister.getMappedClass();\n\t\tSerializable xid;\n\t\tif (x instanceof HibernateProxy) {\n\t\t\txid = ( (HibernateProxy) x ).getHibernateLazyInitializer()\n\t\t\t\t\t.getIdentifier();\n\t\t}\n\t\telse {\n\t\t\tif ( mappedClass.isAssignableFrom( x.getClass() ) ) {\n\t\t\t\txid = persister.getIdentifier( x );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//JPA 2 case where @IdClass contains the id and not the associated entity\n\t\t\t\txid = (Serializable) x;\n\t\t\t}\n\t\t}\n\n\t\tSerializable yid;\n\t\tif (y instanceof HibernateProxy) {\n\t\t\tyid = ( (HibernateProxy) y ).getHibernateLazyInitializer()\n\t\t\t\t\t.getIdentifier();\n\t\t}\n\t\telse {\n\t\t\tif ( mappedClass.isAssignableFrom( y.getClass() ) ) {\n\t\t\t\tyid = persister.getIdentifier( y );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t//JPA 2 case where @IdClass contains the id and not the associated entity\n\t\t\t\tyid = (Serializable) y;\n\t\t\t}\n\t\t}\n\n\t\treturn persister.getIdentifierType()\n\t\t\t\t.isEqual(xid, yid, factory);\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic boolean isEmbeddedInXML() {\n\t\treturn isEmbeddedInXML;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic boolean isXMLElement() {\n\t\treturn isEmbeddedInXML;\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic Object fromXMLNode(Node xml, Mapping factory) throws HibernateException {\n\t\tif ( !isEmbeddedInXML ) {\n\t\t\treturn getIdentifierType(factory).fromXMLNode(xml, factory);\n\t\t}\n\t\telse {\n\t\t\treturn xml;\n\t\t}\n\t}\n\n\t/**\n\t * {@inheritDoc}\n\t */\n\tpublic void setToXMLNode(Node node, Object value, SessionFactoryImplementor factory) throws HibernateException {\n\t\tif ( !isEmbeddedInXML ) {\n\t\t\tgetIdentifierType(factory).setToXMLNode(node, value, factory);\n\t\t}\n\t\telse {\n\t\t\tElement elt = (Element) value;\n\t\t\treplaceNode( node, new ElementWrapper(elt) );\n\t\t}\n\t}\n\n\tpublic String getOnCondition(String alias, SessionFactoryImplementor factory, Map enabledFilters)\n\tthrows MappingException {\n\t\tif ( isReferenceToPrimaryKey() ) { //TODO: this is a bit arbitrary, expose a switch to the user?\n\t\t\treturn \"\";\n\t\t}\n\t\telse {\n\t\t\treturn getAssociatedJoinable( factory ).filterFragment( alias, enabledFilters );\n\t\t}\n\t}\n\n\t/**\n\t * Resolve an identifier or unique key value\n\t */\n\tpublic Object resolve(Object value, SessionImplementor session, Object owner) throws HibernateException {\n\t\tif ( isNotEmbedded( session ) ) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( value != null && !isNull( owner, session ) ) {\n\t\t\tif ( isReferenceToPrimaryKey() ) {\n\t\t\t\treturn resolveIdentifier( (Serializable) value, session );\n\t\t\t}\n\t\t\telse if ( uniqueKeyPropertyName != null ) {\n\t\t\t\treturn loadByUniqueKey( getAssociatedEntityName(), uniqueKeyPropertyName, value, session );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\n\tpublic Type getSemiResolvedType(SessionFactoryImplementor factory) {\n\t\treturn factory.getEntityPersister( associatedEntityName ).getIdentifierType();\n\t}\n\n\tprotected final Object getIdentifier(Object value, SessionImplementor session) throws HibernateException {\n\t\tif ( isNotEmbedded(session) ) {\n\t\t\treturn value;\n\t\t}\n\n\t\tif ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {\n\t\t\treturn ForeignKeys.getEntityIdentifierIfNotUnsaved( getAssociatedEntityName(), value, session ); //tolerates nulls\n\t\t}\n\t\telse if ( value == null ) {\n\t\t\treturn null;\n\t\t}\n\t\telse {\n\t\t\tEntityPersister entityPersister = session.getFactory().getEntityPersister( getAssociatedEntityName() );\n\t\t\tObject propertyValue = entityPersister.getPropertyValue( value, uniqueKeyPropertyName );\n\t\t\t// We now have the value of the property-ref we reference.  However,\n\t\t\t// we need to dig a little deeper, as that property might also be\n\t\t\t// an entity type, in which case we need to resolve its identitifier\n\t\t\tType type = entityPersister.getPropertyType( uniqueKeyPropertyName );\n\t\t\tif ( type.isEntityType() ) {\n\t\t\t\tpropertyValue = ( ( EntityType ) type ).getIdentifier( propertyValue, session );\n\t\t\t}\n\n\t\t\treturn propertyValue;\n\t\t}\n\t}\n\n\t/**\n\t * @deprecated To be removed in 5.  Removed as part of removing the notion of DOM entity-mode.\n\t * See Jira issue: <a href=\"https://hibernate.onjira.com/browse/HHH-7771\">HHH-7771</a>\n\t */\n\t@Deprecated\n\tprotected boolean isNotEmbedded(SessionImplementor session) {\n//\t\treturn !isEmbeddedInXML;\n\t\treturn false;\n\t}\n\n\t/**\n\t * Generate a loggable representation of an instance of the value mapped by this type.\n\t *\n\t * @param value The instance to be logged.\n\t * @param factory The session factory.\n\t * @return The loggable string.\n\t * @throws HibernateException Generally some form of resolution problem.\n\t */\n\tpublic String toLoggableString(Object value, SessionFactoryImplementor factory) {\n\t\tif ( value == null ) {\n\t\t\treturn \"null\";\n\t\t}\n\t\t\n\t\tEntityPersister persister = factory.getEntityPersister( associatedEntityName );\n\t\tStringBuilder result = new StringBuilder().append( associatedEntityName );\n\n\t\tif ( persister.hasIdentifierProperty() ) {\n\t\t\tfinal EntityMode entityMode = persister.getEntityMode();\n\t\t\tfinal Serializable id;\n\t\t\tif ( entityMode == null ) {\n\t\t\t\tif ( isEmbeddedInXML ) {\n\t\t\t\t\tthrow new ClassCastException( value.getClass().getName() );\n\t\t\t\t}\n\t\t\t\tid = ( Serializable ) value;\n\t\t\t} else if ( value instanceof HibernateProxy ) {\n\t\t\t\tHibernateProxy proxy = ( HibernateProxy ) value;\n\t\t\t\tid = proxy.getHibernateLazyInitializer().getIdentifier();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tid = persister.getIdentifier( value );\n\t\t\t}\n\t\t\t\n\t\t\tresult.append( '#' )\n\t\t\t\t.append( persister.getIdentifierType().toLoggableString( id, factory ) );\n\t\t}\n\t\t\n\t\treturn result.toString();\n\t}\n\n\t/**\n\t * Is the association modeled here defined as a 1-1 in the database (physical model)?\n\t *\n\t * @return True if a 1-1 in the database; false otherwise.\n\t */\n\tpublic abstract boolean isOneToOne();\n\n\t/**\n\t * Is the association modeled here a 1-1 according to the logical moidel?\n\t *\n\t * @return True if a 1-1 in the logical model; false otherwise.\n\t */\n\tpublic boolean isLogicalOneToOne() {\n\t\treturn isOneToOne();\n\t}\n\n\t/**\n\t * Convenience method to locate the identifier type of the associated entity.\n\t *\n\t * @param factory The mappings...\n\t * @return The identifier type\n\t */\n\tType getIdentifierType(Mapping factory) {\n\t\treturn factory.getIdentifierType( getAssociatedEntityName() );\n\t}\n\n\t/**\n\t * Convenience method to locate the identifier type of the associated entity.\n\t *\n\t * @param session The originating session\n\t * @return The identifier type\n\t */\n\tType getIdentifierType(SessionImplementor session) {\n\t\treturn getIdentifierType( session.getFactory() );\n\t}\n\n\t/**\n\t * Determine the type of either (1) the identifier if we reference the\n\t * associated entity's PK or (2) the unique key to which we refer (i.e.\n\t * the property-ref).\n\t *\n\t * @param factory The mappings...\n\t * @return The appropriate type.\n\t * @throws MappingException Generally, if unable to resolve the associated entity name\n\t * or unique key property name.\n\t */\n\tpublic final Type getIdentifierOrUniqueKeyType(Mapping factory) throws MappingException {\n\t\tif ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {\n\t\t\treturn getIdentifierType(factory);\n\t\t}\n\t\telse {\n\t\t\tType type = factory.getReferencedPropertyType( getAssociatedEntityName(), uniqueKeyPropertyName );\n\t\t\tif ( type.isEntityType() ) {\n\t\t\t\ttype = ( ( EntityType ) type).getIdentifierOrUniqueKeyType( factory );\n\t\t\t}\n\t\t\treturn type;\n\t\t}\n\t}\n\n\t/**\n\t * The name of the property on the associated entity to which our FK\n\t * refers\n\t *\n\t * @param factory The mappings...\n\t * @return The appropriate property name.\n\t * @throws MappingException Generally, if unable to resolve the associated entity name\n\t */\n\tpublic final String getIdentifierOrUniqueKeyPropertyName(Mapping factory)\n\tthrows MappingException {\n\t\tif ( isReferenceToPrimaryKey() || uniqueKeyPropertyName == null ) {\n\t\t\treturn factory.getIdentifierPropertyName( getAssociatedEntityName() );\n\t\t}\n\t\telse {\n\t\t\treturn uniqueKeyPropertyName;\n\t\t}\n\t}\n\t\n\tprotected abstract boolean isNullable();\n\n\t/**\n\t * Resolve an identifier via a load.\n\t *\n\t * @param id The entity id to resolve\n\t * @param session The orginating session.\n\t * @return The resolved identifier (i.e., loaded entity).\n\t * @throws org.hibernate.HibernateException Indicates problems performing the load.\n\t */\n\tprotected final Object resolveIdentifier(Serializable id, SessionImplementor session) throws HibernateException {\n\t\tboolean isProxyUnwrapEnabled = unwrapProxy &&\n\t\t\t\tsession.getFactory()\n\t\t\t\t\t\t.getEntityPersister( getAssociatedEntityName() )\n\t\t\t\t\t\t.isInstrumented();\n\n\t\tObject proxyOrEntity = session.internalLoad(\n\t\t\t\tgetAssociatedEntityName(),\n\t\t\t\tid,\n\t\t\t\teager,\n\t\t\t\tisNullable() && !isProxyUnwrapEnabled\n\t\t);\n\n\t\tif ( proxyOrEntity instanceof HibernateProxy ) {\n\t\t\t( ( HibernateProxy ) proxyOrEntity ).getHibernateLazyInitializer()\n\t\t\t\t\t.setUnwrap( isProxyUnwrapEnabled );\n\t\t}\n\n\t\treturn proxyOrEntity;\n\t}\n\n\tprotected boolean isNull(Object owner, SessionImplementor session) {\n\t\treturn false;\n\t}\n\n\t/**\n\t * Load an instance by a unique key that is not the primary key.\n\t *\n\t * @param entityName The name of the entity to load\n\t * @param uniqueKeyPropertyName The name of the property defining the uniqie key.\n\t * @param key The unique key property value.\n\t * @param session The originating session.\n\t * @return The loaded entity\n\t * @throws HibernateException generally indicates problems performing the load.\n\t */\n\tpublic Object loadByUniqueKey(\n\t\t\tString entityName, \n\t\t\tString uniqueKeyPropertyName, \n\t\t\tObject key, \n\t\t\tSessionImplementor session) throws HibernateException {\n\t\tfinal SessionFactoryImplementor factory = session.getFactory();\n\t\tUniqueKeyLoadable persister = ( UniqueKeyLoadable ) factory.getEntityPersister( entityName );\n\n\t\t//TODO: implement caching?! proxies?!\n\n\t\tEntityUniqueKey euk = new EntityUniqueKey(\n\t\t\t\tentityName, \n\t\t\t\tuniqueKeyPropertyName, \n\t\t\t\tkey, \n\t\t\t\tgetIdentifierOrUniqueKeyType( factory ),\n\t\t\t\tpersister.getEntityMode(),\n\t\t\t\tsession.getFactory()\n\t\t);\n\n\t\tfinal PersistenceContext persistenceContext = session.getPersistenceContext();\n\t\tObject result = persistenceContext.getEntity( euk );\n\t\tif ( result == null ) {\n\t\t\tresult = persister.loadByUniqueKey( uniqueKeyPropertyName, key, session );\n\t\t}\n\t\treturn result == null ? null : persistenceContext.proxyFor( result );\n\t}\n\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n *\n */\n\npackage sun.jvm.hotspot;\n\nimport java.rmi.RemoteException;\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\nimport sun.jvm.hotspot.debugger.Debugger;\nimport sun.jvm.hotspot.debugger.DebuggerException;\nimport sun.jvm.hotspot.debugger.JVMDebugger;\nimport sun.jvm.hotspot.debugger.MachineDescription;\nimport sun.jvm.hotspot.debugger.MachineDescriptionAMD64;\nimport sun.jvm.hotspot.debugger.MachineDescriptionIA64;\nimport sun.jvm.hotspot.debugger.MachineDescriptionIntelX86;\nimport sun.jvm.hotspot.debugger.MachineDescriptionSPARC32Bit;\nimport sun.jvm.hotspot.debugger.MachineDescriptionSPARC64Bit;\nimport sun.jvm.hotspot.debugger.NoSuchSymbolException;\nimport sun.jvm.hotspot.debugger.bsd.BsdDebuggerLocal;\nimport sun.jvm.hotspot.debugger.linux.LinuxDebuggerLocal;\nimport sun.jvm.hotspot.debugger.proc.ProcDebuggerLocal;\nimport sun.jvm.hotspot.debugger.remote.RemoteDebugger;\nimport sun.jvm.hotspot.debugger.remote.RemoteDebuggerClient;\nimport sun.jvm.hotspot.debugger.remote.RemoteDebuggerServer;\nimport sun.jvm.hotspot.debugger.windbg.WindbgDebuggerLocal;\nimport sun.jvm.hotspot.runtime.VM;\nimport sun.jvm.hotspot.types.TypeDataBase;\nimport sun.jvm.hotspot.utilities.PlatformInfo;\nimport sun.jvm.hotspot.utilities.UnsupportedPlatformException;\n\n/** <P> This class wraps much of the basic functionality and is the\n * highest-level factory for VM data structures. It makes it simple\n * to start up the debugging system. </P>\n *\n * <P> FIXME: especially with the addition of remote debugging, this\n * has turned into a mess; needs rethinking. </P>\n */\n\npublic class HotSpotAgent {\n    private JVMDebugger debugger;\n    private MachineDescription machDesc;\n    private TypeDataBase db;\n\n    private String os;\n    private String cpu;\n\n    // The system can work in several ways:\n    //  - Attaching to local process\n    //  - Attaching to local core file\n    //  - Connecting to remote debug server\n    //  - Starting debug server for process\n    //  - Starting debug server for core file\n\n    // These are options for the \"client\" side of things\n    private static final int PROCESS_MODE   = 0;\n    private static final int CORE_FILE_MODE = 1;\n    private static final int REMOTE_MODE    = 2;\n    private int startupMode;\n\n    // This indicates whether we are really starting a server or not\n    private boolean isServer;\n\n    // All possible required information for connecting\n    private int pid;\n    private String javaExecutableName;\n    private String coreFileName;\n    private String debugServerID;\n\n    // All needed information for server side\n    private String serverID;\n\n    private String[] jvmLibNames;\n\n    static void showUsage() {\n    }\n\n    public HotSpotAgent() {\n        // for non-server add shutdown hook to clean-up debugger in case\n        // of forced exit. For remote server, shutdown hook is added by\n        // DebugServer.\n        Runtime.getRuntime().addShutdownHook(new java.lang.Thread(\n        new Runnable() {\n            public void run() {\n                synchronized (HotSpotAgent.this) {\n                    if (!isServer) {\n                        detach();\n                    }\n                }\n            }\n        }));\n    }\n\n    //--------------------------------------------------------------------------------\n    // Accessors (once the system is set up)\n    //\n\n    public synchronized Debugger getDebugger() {\n        return debugger;\n    }\n\n    public synchronized TypeDataBase getTypeDataBase() {\n        return db;\n    }\n\n    //--------------------------------------------------------------------------------\n    // Client-side operations\n    //\n\n    /** This attaches to a process running on the local machine. */\n    public synchronized void attach(int processID)\n    throws DebuggerException {\n        if (debugger != null) {\n            throw new DebuggerException(\"Already attached\");\n        }\n        pid = processID;\n        startupMode = PROCESS_MODE;\n        isServer = false;\n        go();\n    }\n\n    /** This opens a core file on the local machine */\n    public synchronized void attach(String javaExecutableName, String coreFileName)\n    throws DebuggerException {\n        if (debugger != null) {\n            throw new DebuggerException(\"Already attached\");\n        }\n        if ((javaExecutableName == null) || (coreFileName == null)) {\n            throw new DebuggerException(\"Both the core file name and Java executable name must be specified\");\n        }\n        this.javaExecutableName = javaExecutableName;\n        this.coreFileName = coreFileName;\n        startupMode = CORE_FILE_MODE;\n        isServer = false;\n        go();\n    }\n\n    /** This uses a JVMDebugger that is already attached to the core or process */\n    public synchronized void attach(JVMDebugger d)\n    throws DebuggerException {\n        debugger = d;\n        isServer = false;\n        go();\n    }\n\n    /** This attaches to a \"debug server\" on a remote machine; this\n      remote server has already attached to a process or opened a\n      core file and is waiting for RMI calls on the Debugger object to\n      come in. */\n    public synchronized void attach(String remoteServerID)\n    throws DebuggerException {\n        if (debugger != null) {\n            throw new DebuggerException(\"Already attached to a process\");\n        }\n        if (remoteServerID == null) {\n            throw new DebuggerException(\"Debug server id must be specified\");\n        }\n\n        debugServerID = remoteServerID;\n        startupMode = REMOTE_MODE;\n        isServer = false;\n        go();\n    }\n\n    /** This should only be called by the user on the client machine,\n      not the server machine */\n    public synchronized boolean detach() throws DebuggerException {\n        if (isServer) {\n            throw new DebuggerException(\"Should not call detach() for server configuration\");\n        }\n        return detachInternal();\n    }\n\n    //--------------------------------------------------------------------------------\n    // Server-side operations\n    //\n\n    /** This attaches to a process running on the local machine and\n      starts a debug server, allowing remote machines to connect and\n      examine this process. Uses specified name to uniquely identify a\n      specific debuggee on the server */\n    public synchronized void startServer(int processID, String uniqueID) {\n        if (debugger != null) {\n            throw new DebuggerException(\"Already attached\");\n        }\n        pid = processID;\n        startupMode = PROCESS_MODE;\n        isServer = true;\n        serverID = uniqueID;\n        go();\n    }\n\n    /** This attaches to a process running on the local machine and\n      starts a debug server, allowing remote machines to connect and\n      examine this process. */\n    public synchronized void startServer(int processID)\n    throws DebuggerException {\n        startServer(processID, null);\n    }\n\n    /** This opens a core file on the local machine and starts a debug\n      server, allowing remote machines to connect and examine this\n      core file. Uses supplied uniqueID to uniquely identify a specific\n      debugee */\n    public synchronized void startServer(String javaExecutableName,\n    String coreFileName,\n    String uniqueID) {\n        if (debugger != null) {\n            throw new DebuggerException(\"Already attached\");\n        }\n        if ((javaExecutableName == null) || (coreFileName == null)) {\n            throw new DebuggerException(\"Both the core file name and Java executable name must be specified\");\n        }\n        this.javaExecutableName = javaExecutableName;\n        this.coreFileName = coreFileName;\n        startupMode = CORE_FILE_MODE;\n        isServer = true;\n        serverID = uniqueID;\n        go();\n    }\n\n    /** This opens a core file on the local machine and starts a debug\n      server, allowing remote machines to connect and examine this\n      core file. */\n    public synchronized void startServer(String javaExecutableName, String coreFileName)\n    throws DebuggerException {\n        startServer(javaExecutableName, coreFileName, null);\n    }\n\n    /** This may only be called on the server side after startServer()\n      has been called */\n    public synchronized boolean shutdownServer() throws DebuggerException {\n        if (!isServer) {\n            throw new DebuggerException(\"Should not call shutdownServer() for client configuration\");\n        }\n        return detachInternal();\n    }\n\n\n    //--------------------------------------------------------------------------------\n    // Internals only below this point\n    //\n\n    private boolean detachInternal() {\n        if (debugger == null) {\n            return false;\n        }\n        boolean retval = true;\n        if (!isServer) {\n            VM.shutdown();\n        }\n        // We must not call detach() if we are a client and are connected\n        // to a remote debugger\n        Debugger dbg = null;\n        DebuggerException ex = null;\n        if (isServer) {\n            try {\n                RMIHelper.unbind(serverID);\n            }\n            catch (DebuggerException de) {\n                ex = de;\n            }\n            dbg = debugger;\n        } else {\n            if (startupMode != REMOTE_MODE) {\n                dbg = debugger;\n            }\n        }\n        if (dbg != null) {\n            retval = dbg.detach();\n        }\n\n        debugger = null;\n        machDesc = null;\n        db = null;\n        if (ex != null) {\n            throw(ex);\n        }\n        return retval;\n    }\n\n    private void go() {\n        setupDebugger();\n        setupVM();\n    }\n\n    private void setupDebugger() {\n        if (startupMode != REMOTE_MODE) {\n            //\n            // Local mode (client attaching to local process or setting up\n            // server, but not client attaching to server)\n            //\n\n            // Handle existing or alternate JVMDebugger:\n            // these will set os, cpu independently of our PlatformInfo implementation.\n            String alternateDebugger = System.getProperty(\"sa.altDebugger\");\n            if (debugger != null) {\n                setupDebuggerExisting();\n\n            } else if (alternateDebugger != null) {\n                setupDebuggerAlternate(alternateDebugger);\n\n            } else {\n                // Otherwise, os, cpu are those of our current platform:\n                try {\n                    os  = PlatformInfo.getOS();\n                    cpu = PlatformInfo.getCPU();\n                } catch (UnsupportedPlatformException e) {\n                   throw new DebuggerException(e);\n                }\n                if (os.equals(\"solaris\")) {\n                    setupDebuggerSolaris();\n                } else if (os.equals(\"win32\")) {\n                    setupDebuggerWin32();\n                } else if (os.equals(\"linux\")) {\n                    setupDebuggerLinux();\n                } else if (os.equals(\"bsd\")) {\n                    setupDebuggerBsd();\n                } else if (os.equals(\"darwin\")) {\n                    setupDebuggerDarwin();\n                } else {\n                    // Add support for more operating systems here\n                    throw new DebuggerException(\"Operating system \" + os + \" not yet supported\");\n                }\n            }\n\n            if (isServer) {\n                RemoteDebuggerServer remote = null;\n                try {\n                    remote = new RemoteDebuggerServer(debugger);\n                }\n                catch (RemoteException rem) {\n                    throw new DebuggerException(rem);\n                }\n                RMIHelper.rebind(serverID, remote);\n            }\n        } else {\n            //\n            // Remote mode (client attaching to server)\n            //\n\n            // Create and install a security manager\n\n            // FIXME: currently commented out because we were having\n            // security problems since we're \"in the sun.* hierarchy\" here.\n            // Perhaps a permissive policy file would work around this. In\n            // the long run, will probably have to move into com.sun.*.\n\n            //    if (System.getSecurityManager() == null) {\n            //      System.setSecurityManager(new RMISecurityManager());\n            //    }\n\n            connectRemoteDebugger();\n        }\n    }\n\n    private void setupVM() {\n        // We need to instantiate a HotSpotTypeDataBase on both the client\n        // and server machine. On the server it is only currently used to\n        // configure the Java primitive type sizes (which we should\n        // consider making constant). On the client it is used to\n        // configure the VM.\n\n        try {\n            if (os.equals(\"solaris\")) {\n                db = new HotSpotTypeDataBase(machDesc,\n                new HotSpotSolarisVtblAccess(debugger, jvmLibNames),\n                debugger, jvmLibNames);\n            } else if (os.equals(\"win32\")) {\n                db = new HotSpotTypeDataBase(machDesc,\n                new Win32VtblAccess(debugger, jvmLibNames),\n                debugger, jvmLibNames);\n            } else if (os.equals(\"linux\")) {\n                db = new HotSpotTypeDataBase(machDesc,\n                new LinuxVtblAccess(debugger, jvmLibNames),\n                debugger, jvmLibNames);\n            } else if (os.equals(\"bsd\")) {\n                db = new HotSpotTypeDataBase(machDesc,\n                new BsdVtblAccess(debugger, jvmLibNames),\n                debugger, jvmLibNames);\n            } else if (os.equals(\"darwin\")) {\n                db = new HotSpotTypeDataBase(machDesc,\n                new BsdVtblAccess(debugger, jvmLibNames),\n                debugger, jvmLibNames);\n            } else {\n                throw new DebuggerException(\"OS \\\"\" + os + \"\\\" not yet supported (no VtblAccess yet)\");\n            }\n        }\n        catch (NoSuchSymbolException e) {\n            throw new DebuggerException(\"Doesn't appear to be a HotSpot VM (could not find symbol \\\"\" +\n            e.getSymbol() + \"\\\" in remote process)\");\n        }\n\n        if (startupMode != REMOTE_MODE) {\n            // Configure the debugger with the primitive type sizes just obtained from the VM\n            debugger.configureJavaPrimitiveTypeSizes(db.getJBooleanType().getSize(),\n            db.getJByteType().getSize(),\n            db.getJCharType().getSize(),\n            db.getJDoubleType().getSize(),\n            db.getJFloatType().getSize(),\n            db.getJIntType().getSize(),\n            db.getJLongType().getSize(),\n            db.getJShortType().getSize());\n        }\n\n        if (!isServer) {\n            // Do not initialize the VM on the server (unnecessary, since it's\n            // instantiated on the client)\n            try {\n                VM.initialize(db, debugger);\n            } catch (DebuggerException e) {\n                throw (e);\n            } catch (Exception e) {\n                throw new DebuggerException(e);\n            }\n        }\n    }\n\n    //--------------------------------------------------------------------------------\n    // OS-specific debugger setup/connect routines\n    //\n\n    // Use the existing JVMDebugger, as passed to our constructor.\n    // Retrieve os and cpu from that debugger, not the current platform.\n    private void setupDebuggerExisting() {\n\n        os = debugger.getOS();\n        cpu = debugger.getCPU();\n        setupJVMLibNames(os);\n        machDesc = debugger.getMachineDescription();\n    }\n\n    // Given a classname, load an alternate implementation of JVMDebugger.\n    private void setupDebuggerAlternate(String alternateName) {\n\n        try {\n            Class c = Class.forName(alternateName);\n            Constructor cons = c.getConstructor();\n            debugger = (JVMDebugger) cons.newInstance();\n            attachDebugger();\n            setupDebuggerExisting();\n\n        } catch (ClassNotFoundException cnfe) {\n            throw new DebuggerException(\"Cannot find alternate SA Debugger: '\" + alternateName + \"'\");\n        } catch (NoSuchMethodException nsme) {\n            throw new DebuggerException(\"Alternate SA Debugger: '\" + alternateName + \"' has missing constructor.\");\n        } catch (InstantiationException ie) {\n            throw new DebuggerException(\"Alternate SA Debugger: '\" + alternateName + \"' fails to initialise: \", ie);\n        } catch (IllegalAccessException iae) {\n            throw new DebuggerException(\"Alternate SA Debugger: '\" + alternateName + \"' fails to initialise: \", iae);\n        } catch (InvocationTargetException iae) {\n            throw new DebuggerException(\"Alternate SA Debugger: '\" + alternateName + \"' fails to initialise: \", iae);\n        }\n\n        System.err.println(\"Loaded alternate HotSpot SA Debugger: \" + alternateName);\n    }\n\n    //\n    // Solaris\n    //\n\n    private void setupDebuggerSolaris() {\n        setupJVMLibNamesSolaris();\n        ProcDebuggerLocal dbg = new ProcDebuggerLocal(null, true);\n        debugger = dbg;\n        attachDebugger();\n\n        // Set up CPU-dependent stuff\n        if (cpu.equals(\"x86\")) {\n            machDesc = new MachineDescriptionIntelX86();\n        } else if (cpu.equals(\"sparc\")) {\n            int addressSize = dbg.getRemoteProcessAddressSize();\n            if (addressSize == -1) {\n                throw new DebuggerException(\"Error occurred while trying to determine the remote process's \" +\n                                            \"address size\");\n            }\n\n            if (addressSize == 32) {\n                machDesc = new MachineDescriptionSPARC32Bit();\n            } else if (addressSize == 64) {\n                machDesc = new MachineDescriptionSPARC64Bit();\n            } else {\n                throw new DebuggerException(\"Address size \" + addressSize + \" is not supported on SPARC\");\n            }\n        } else if (cpu.equals(\"amd64\")) {\n            machDesc = new MachineDescriptionAMD64();\n        } else {\n            throw new DebuggerException(\"Solaris only supported on sparc/sparcv9/x86/amd64\");\n        }\n\n        dbg.setMachineDescription(machDesc);\n        return;\n    }\n\n    private void connectRemoteDebugger() throws DebuggerException {\n        RemoteDebugger remote =\n        (RemoteDebugger) RMIHelper.lookup(debugServerID);\n        debugger = new RemoteDebuggerClient(remote);\n        machDesc = ((RemoteDebuggerClient) debugger).getMachineDescription();\n        os = debugger.getOS();\n        setupJVMLibNames(os);\n        cpu = debugger.getCPU();\n    }\n\n    private void setupJVMLibNames(String os) {\n        if (os.equals(\"solaris\")) {\n            setupJVMLibNamesSolaris();\n        } else if (os.equals(\"win32\")) {\n            setupJVMLibNamesWin32();\n        } else if (os.equals(\"linux\")) {\n            setupJVMLibNamesLinux();\n        } else if (os.equals(\"bsd\")) {\n            setupJVMLibNamesBsd();\n        } else if (os.equals(\"darwin\")) {\n            setupJVMLibNamesDarwin();\n        } else {\n            throw new RuntimeException(\"Unknown OS type\");\n        }\n    }\n\n    private void setupJVMLibNamesSolaris() {\n        jvmLibNames = new String[] { \"libjvm.so\" };\n    }\n\n    //\n    // Win32\n    //\n\n    private void setupDebuggerWin32() {\n        setupJVMLibNamesWin32();\n\n        if (cpu.equals(\"x86\")) {\n            machDesc = new MachineDescriptionIntelX86();\n        } else if (cpu.equals(\"amd64\")) {\n            machDesc = new MachineDescriptionAMD64();\n        } else if (cpu.equals(\"ia64\")) {\n            machDesc = new MachineDescriptionIA64();\n        } else {\n            throw new DebuggerException(\"Win32 supported under x86, amd64 and ia64 only\");\n        }\n\n        // Note we do not use a cache for the local debugger in server\n        // mode; it will be taken care of on the client side (once remote\n        // debugging is implemented).\n\n        debugger = new WindbgDebuggerLocal(machDesc, !isServer);\n\n        attachDebugger();\n\n        // FIXME: add support for server mode\n    }\n\n    private void setupJVMLibNamesWin32() {\n        jvmLibNames = new String[] { \"jvm.dll\" };\n    }\n\n    //\n    // Linux\n    //\n\n    private void setupDebuggerLinux() {\n        setupJVMLibNamesLinux();\n\n        if (cpu.equals(\"x86\")) {\n            machDesc = new MachineDescriptionIntelX86();\n        } else if (cpu.equals(\"ia64\")) {\n            machDesc = new MachineDescriptionIA64();\n        } else if (cpu.equals(\"amd64\")) {\n            machDesc = new MachineDescriptionAMD64();\n        } else if (cpu.equals(\"sparc\")) {\n            if (LinuxDebuggerLocal.getAddressSize()==8) {\n                    machDesc = new MachineDescriptionSPARC64Bit();\n            } else {\n                    machDesc = new MachineDescriptionSPARC32Bit();\n            }\n        } else {\n          try {\n            machDesc = (MachineDescription)\n              Class.forName(\"sun.jvm.hotspot.debugger.MachineDescription\" +\n                            cpu.toUpperCase()).newInstance();\n          } catch (Exception e) {\n            throw new DebuggerException(\"Linux not supported on machine type \" + cpu);\n          }\n        }\n\n        LinuxDebuggerLocal dbg =\n        new LinuxDebuggerLocal(machDesc, !isServer);\n        debugger = dbg;\n\n        attachDebugger();\n    }\n\n    private void setupJVMLibNamesLinux() {\n        jvmLibNames = new String[] { \"libjvm.so\" };\n    }\n\n    //\n    // BSD\n    //\n\n    private void setupDebuggerBsd() {\n        setupJVMLibNamesBsd();\n\n        if (cpu.equals(\"x86\")) {\n            machDesc = new MachineDescriptionIntelX86();\n        } else if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n            machDesc = new MachineDescriptionAMD64();\n        } else {\n            throw new DebuggerException(\"BSD only supported on x86/x86_64. Current arch: \" + cpu);\n        }\n\n        BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);\n        debugger = dbg;\n\n        attachDebugger();\n    }\n\n    private void setupJVMLibNamesBsd() {\n        jvmLibNames = new String[] { \"libjvm.so\" };\n    }\n\n    //\n    // Darwin\n    //\n\n    private void setupDebuggerDarwin() {\n        setupJVMLibNamesDarwin();\n\n        if (cpu.equals(\"amd64\") || cpu.equals(\"x86_64\")) {\n            machDesc = new MachineDescriptionAMD64();\n        } else {\n            throw new DebuggerException(\"Darwin only supported on x86_64. Current arch: \" + cpu);\n        }\n\n        BsdDebuggerLocal dbg = new BsdDebuggerLocal(machDesc, !isServer);\n        debugger = dbg;\n\n        attachDebugger();\n    }\n\n    private void setupJVMLibNamesDarwin() {\n        jvmLibNames = new String[] { \"libjvm.dylib\" };\n    }\n\n    /** Convenience routine which should be called by per-platform\n      debugger setup. Should not be called when startupMode is\n      REMOTE_MODE. */\n    private void attachDebugger() {\n        if (startupMode == PROCESS_MODE) {\n            debugger.attach(pid);\n        } else if (startupMode == CORE_FILE_MODE) {\n            debugger.attach(javaExecutableName, coreFileName);\n        } else {\n            throw new DebuggerException(\"Should not call attach() for startupMode == \" + startupMode);\n        }\n    }\n}\n", ";\nimport info.bitrich.xchangestream.core.StreamingExchangeFactory;\nimport io.reactivex.disposables.Disposable;\nimport org.knowm.xchange.currency.CurrencyPair;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n/** Created by Pavel Chertalev on 15.03.2018. */\npublic class HitbtcManualExample {\n  private static final Logger LOG = LoggerFactory.getLogger(HitbtcManualExample.class);\n\n  public static void main(String[] args) {\n    StreamingExchange exchange =\n        StreamingExchangeFactory.INSTANCE.createExchange(HitbtcStreamingExchange.class);\n\n    exchange.connect().blockingAwait();\n    Disposable orderBookObserver =\n        exchange\n            .getStreamingMarketDataService()\n            .getOrderBook(CurrencyPair.BTC_USD)\n            .subscribe(\n                orderBook -> {\n                  LOG.info(\"First ask: {}\", orderBook.getAsks().get(0));\n                  LOG.info(\"First bid: {}\", orderBook.getBids().get(0));\n                },\n                throwable -> LOG.error(\"ERROR in getting order book: \", throwable));\n\n    Disposable tradesObserver =\n        exchange\n            .getStreamingMarketDataService()\n            .getTrades(CurrencyPair.BTC_USD)\n            .subscribe(\n                trade -> {\n                  LOG.info(\"TRADE: {}\", trade);\n                },\n                throwable -> LOG.error(\"ERROR in getting trade: \", throwable));\n\n    Disposable tickerObserver =\n        exchange\n            .getStreamingMarketDataService()\n            .getTicker(CurrencyPair.ETH_BTC)\n            .subscribe(\n                ticker -> {\n                  LOG.info(\"TICKER: {}\", ticker);\n                },\n                throwable -> LOG.error(\"ERROR in getting ticker: \", throwable));\n\n    try {\n      Thread.sleep(10000);\n    } catch (InterruptedException e) {\n      e.printStackTrace();\n    }\n\n    orderBookObserver.dispose();\n    tradesObserver.dispose();\n    tickerObserver.dispose();\n    exchange.disconnect().subscribe(() -> LOG.info(\"Disconnected\"));\n  }\n}\n", "r;\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\n\npublic class AlertDialog extends JDialog {\n\tprivate static final Dimension SIZE = new Dimension(150, 80);\n\tprivate static final int MARGIN = 10;\n\tprivate static final Border MARGIN_BORDER = BorderFactory.createEmptyBorder(MARGIN, MARGIN, MARGIN, MARGIN);\n\tprivate static final String ALERT_LABEL_FORMAT_STRING =\n\t\t\t\"<html>\" +\n\t\t\t\t\t\"<body WIDTH=%d style='text-align:center'>\" +\n\t\t\t\t\t\t\t\"%s\" +\n\t\t\t\t\t\"<body>\" +\n\t\t\t\"</html>\";\n\n\tpublic AlertDialog(Frame owner, String title, String description) {\n\t\tsuper(owner, title, true);\n\t\tthis.setDefaultCloseOperation(DISPOSE_ON_CLOSE);\n\t\tthis.setLocationRelativeTo(null);\n\t\tthis.setMinimumSize(SIZE);\n\t\tthis.setResizable(false);\n\n\t\tJPanel contentPanel = new JPanel(new BorderLayout());\n\t\tcontentPanel.setLayout(new BoxLayout(contentPanel, BoxLayout.Y_AXIS));\n\t\tcontentPanel.setBorder(MARGIN_BORDER);\n\n\t\tJLabel alertLabel = new JLabel(String.format(ALERT_LABEL_FORMAT_STRING, SIZE.width-MARGIN*2, description));\n\t\talertLabel.setAlignmentX(Component.CENTER_ALIGNMENT);\n\t\tcontentPanel.add(alertLabel, BorderLayout.CENTER);\n\n\t\tJButton alertButton = new JButton(new AbstractAction() {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\t\tdispose();\n\t\t\t}\n\t\t});\n\t\talertButton.setText(\"Ok\");\n\t\talertButton.setAlignmentX(Component.CENTER_ALIGNMENT);\n\t\tcontentPanel.add(alertButton, BorderLayout.SOUTH);\n\n\t\tthis.setContentPane(contentPanel);\n\t\tthis.pack();\n\t\tthis.setVisible(true);\n\t}\n}\n", "ht (c) 2002-2016 by bentodev.org\n *\n * Use of this code in source or compiled form is subject to the\n * Bento Poetic License at http://www.bentodev.org/poetic-license.html\n */\n\npackage bento.lang;\n\nimport bento.runtime.Context;\n\nimport java.util.*;\n\n/**\n * A ConditionalStatement is an <code>if</code> or <code>with</code> statement,\n * optionally with an <code>else</code> clause.\n *\n * @author Michael St. Hippolyte\n * @version $Revision: 1.15 $\n */\npublic class ConditionalStatement extends AbstractConstruction implements ConstructionContainer, ConstructionGenerator {\n\n    private ValueSource condition;\n    private Block body;\n    private Block elseBody;\n    private ConditionalStatement elseIf;\n\n    public ConditionalStatement() {\n        super();\n    }\n\n    public ConditionalStatement(ValueSource condition, Block body, Block elseBody) {\n        super();\n        setIfElse(condition, body, elseBody);\n    }\n\n    public ConditionalStatement(ValueSource condition, Block body, ConditionalStatement elseIf) {\n        super();\n        setIfElseIf(condition, body, elseIf);\n    }\n\n    public boolean isPrimitive() {\n        return false;\n    }\n\n    public boolean isDynamic() {\n        return true;\n    }\n\n    public boolean isStatic() {\n        return false;\n    }\n\n    /** if **/\n    protected void setIf(ValueSource condition, Block body) {\n        this.condition = condition;\n        if (body != null && (body.getNumChildren() > 0 || body.isDynamic())) {\n            this.body = body;\n        } else {\n            this.body = null;\n        }\n        elseBody = null;\n        elseIf = null;\n    }\n\n    /** if - else **/\n    protected void setIfElse(ValueSource condition, Block body, Block elseBody) {\n        this.condition = condition;\n        if (body != null && (body.getNumChildren() > 0 || body.isDynamic())) {\n            this.body = body;\n        } else {\n            this.body = null;\n        }\n        if (elseBody != null && (elseBody.getNumChildren() > 0 || elseBody.isDynamic())) {\n            this.elseBody = elseBody;\n        } else {\n            this.elseBody = null;\n        }\n        elseIf = null;\n    }\n\n    /** if - else if **/\n    protected void setIfElseIf(ValueSource condition, Block body, ConditionalStatement elseIf) {\n        this.condition = condition;\n        if (body != null && (body.getNumChildren() > 0 || body.isDynamic())) {\n            this.body = body;\n        } else {\n            this.body = null;\n        }\n        elseBody = null;\n        this.elseIf = elseIf;\n    }\n\n    public Block getBody() {\n        return body;\n    }\n\n    public BentoNode getElse() {\n        if (elseIf == null) {\n            return elseBody;\n        } else {\n            return elseIf;\n        }\n    }\n\n    public List<Construction> getConstructions(Context context) {\n        List<Construction> constructions = Context.newArrayList(2 * TYPICAL_LIST_SIZE, Construction.class);\n        if (condition instanceof ConstructionContainer) {\n            List<Construction> conditionConstructions = ((ConstructionContainer) condition).getConstructions(context);\n            if (conditionConstructions != null) {\n                constructions.addAll(conditionConstructions);\n            }\n        } else if (condition instanceof Construction) {\n            constructions.add((Construction) condition);\n        }\n        if (body != null) {\n            List<Construction> bodyConstructions = body.getConstructions(context);\n            if (bodyConstructions != null) {\n                constructions.addAll(bodyConstructions);\n            }\n        }\n        if (elseBody != null) {\n            List<Construction> elseConstructions = elseBody.getConstructions(context);\n            if (elseConstructions != null) {\n                constructions.addAll(elseConstructions);\n            }\n        } else if (elseIf != null) {\n            List<Construction> elseIfConstructions = elseIf.getConstructions(context);\n            if (elseIfConstructions != null) {\n                constructions.addAll(elseIfConstructions);\n            }\n        }\n        return constructions;\n    }\n\n    public List<Construction> generateConstructions(Context context) throws Redirection {\n        List<Construction> constructions = Context.newArrayList(TYPICAL_LIST_SIZE, Construction.class);\n        if (booleanValueOf(condition, context)) {\n            if (body != null) {\n                if (body instanceof ConstructionGenerator) {\n                    constructions.addAll(((ConstructionGenerator) body).generateConstructions(context));\n                } else {\n                    constructions.addAll(body.getConstructions(context));\n                }\n            }\n        } else {\n            if (elseBody != null) {\n                if (elseBody instanceof ConstructionGenerator) {\n                    constructions.addAll(((ConstructionGenerator) elseBody).generateConstructions(context));\n                } else {\n                    constructions.addAll(elseBody.getConstructions(context));\n                }\n            } else if (elseIf != null) {\n                constructions.addAll(elseIf.generateConstructions(context));\n            }\n        }\n        ((ArrayList<Construction>) constructions).trimToSize();\n        return constructions;\n    }\n\n    public Object generateData(Context context, Definition def) throws Redirection {\n        Object data = null;\n        if (valueOf(condition, context).getBoolean()) {\n            if (body != null) {\n                data = body.getData(context);\n            }\n        } else {\n            if (elseBody != null) {\n                data = elseBody.getData(context);\n            } else if (elseIf != null) {\n                data = elseIf.generateData(context, def);\n            }\n        }\n        return data;\n    }\n\n    public Type getType(Context context, boolean generate) {\n        if (generate) {\n            try {\n                if (valueOf(condition, context).getBoolean()) {\n                    if (body != null && body.getNumChildren() > 0) {\n                        return body.getType(context, generate);\n                    } else {\n                        return DefaultType.TYPE;                    }\n                } else {\n                    if (elseBody != null && elseBody.getNumChildren() > 0) {\n                        return elseBody.getType(context, generate);\n                    } else if (elseIf != null) {\n                        return elseIf.getType(context, generate);\n                    } else {\n                        return DefaultType.TYPE;                    }\n                }\n            } catch (Redirection r) {\n                return DefaultType.TYPE;\n            }\n        } else {\n            if (body == null || body.getNumChildren() == 0 || ((elseBody == null || elseBody.getNumChildren() == 0) && elseIf == null)) {\n                return DefaultType.TYPE;\n            }\n            Type bodyType = body.getType(context, generate);\n            Type elseType;\n            if (elseBody != null && elseBody.getNumChildren() > 0) {\n                elseType = elseBody.getType(context, generate);\n            } else if (elseIf != null) {\n                elseType = elseIf.getType(context, generate);\n            } else {\n                return DefaultType.TYPE;\n            }\n            return findCommonType(context, bodyType, elseType);\n        }\n    }\n    \n    private Type findCommonType(Context context, Type type1, Type type2) {\n        if (type1 == null || type2 == null) {\n            return DefaultType.TYPE;\n        } else if (type1.equals(PrimitiveType.VOID) || type2.equals(PrimitiveType.VOID)) {\n            return PrimitiveType.VOID;\n        } else if (type1.equals(DefaultType.TYPE) || type2.equals(DefaultType.TYPE)) {\n            return DefaultType.TYPE;\n        } else if (type2.isTypeOf(type1, context)) {\n            return type1;\n        } else if (type1.isTypeOf(type2, context)) {\n            return type2;\n        } else {\n            return findCommonType(context, type1.getSuper(), type2.getSuper());\n        }\n    }\n\n    public String toString(String prefix) {\n        StringBuffer sb = new StringBuffer(prefix);\n        if (condition instanceof WithPredicate) {\n            sb.append(\"with \");\n        } else {\n            sb.append(\"if \");\n        }\n        sb.append(condition.toString());\n        sb.append(' ');\n        sb.append(body.toString(prefix));\n        if (elseBody != null) {\n            sb.append(prefix);\n            sb.append(\"else \");\n            sb.append(elseBody.toString(prefix));\n        } else if (elseIf != null) {\n            sb.append(prefix);\n            sb.append(\"else \");\n            sb.append(elseIf.toString(prefix));\n        }\n        return sb.toString();\n    }\n}", "t.Keys;\nimport com.badlogic.gdx.InputAdapter;\nimport com.badlogic.gdx.graphics.Color;\nimport com.badlogic.gdx.graphics.glutils.ShapeRenderer;\nimport com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;\nimport com.badlogic.gdx.math.MathUtils;\nimport com.badlogic.gdx.math.Vector2;\nimport com.badlogic.gdx.utils.viewport.Viewport;\n\nimport java.util.Random;\n\n\npublic class BouncingBall extends InputAdapter {\n\n    private static final Color COLOR = Color.RED;\n    private static final float DRAG = 1.0f;\n    private static final float RADIUS_FACTOR = 1.0f / 20;\n    private static final float RADIUS_GROWTH_RATE = 1.5f;\n    private static final float MIN_RADIUS_MULTIPLIER = 0.1f;\n    private static final float ACCELERATION = 500.0f;\n    private static final float MAX_SPEED = 400.0f;\n\n    private static final float KICK_VELOCITY = 500.0f;\n\n    float baseRadius;\n    float radiusMultiplier;\n\n    Vector2 position;\n    Vector2 velocity;\n\n    Viewport viewport;\n\n    public BouncingBall(Viewport viewport) {\n        this.viewport = viewport;\n        init();\n    }\n\n    public void init() {\n        position = new Vector2(viewport.getWorldWidth() / 2, viewport.getWorldHeight() / 2);\n        velocity = new Vector2();\n        baseRadius = RADIUS_FACTOR * Math.min(viewport.getWorldWidth(), viewport.getWorldHeight());\n        radiusMultiplier = 1;\n    }\n\n    private void randomKick() {\n        Random random = new Random();\n        float angle = MathUtils.PI2 * random.nextFloat();\n        velocity.x += KICK_VELOCITY * MathUtils.cos(angle);\n        velocity.y += KICK_VELOCITY * MathUtils.sin(angle);\n    }\n\n    public void update(float delta) {\n\n        // Growing and shrinking\n        if (Gdx.input.isKeyPressed(Keys.Z)){\n            radiusMultiplier += delta * RADIUS_GROWTH_RATE;\n        }\n        if (Gdx.input.isKeyPressed(Keys.X)){\n            radiusMultiplier -= delta * RADIUS_GROWTH_RATE;\n            radiusMultiplier = Math.max(radiusMultiplier, MIN_RADIUS_MULTIPLIER);\n        }\n\n        // Movement\n        if (Gdx.input.isKeyPressed(Keys.LEFT)){\n            velocity.x -= delta * ACCELERATION;\n\n        }\n        if (Gdx.input.isKeyPressed(Keys.RIGHT)){\n            velocity.x += delta * ACCELERATION;\n\n        }\n        if (Gdx.input.isKeyPressed(Keys.UP)){\n            velocity.y += delta * ACCELERATION;\n\n        }\n        if (Gdx.input.isKeyPressed(Keys.DOWN)){\n            velocity.y -= delta * ACCELERATION;\n\n        }\n\n        velocity.clamp(0, MAX_SPEED);\n\n        velocity.x -= delta * DRAG * velocity.x;\n        velocity.y -= delta * DRAG * velocity.y;\n\n        position.x += delta * velocity.x;\n        position.y += delta * velocity.y;\n\n\n        collideWithWalls(baseRadius * radiusMultiplier, viewport.getWorldWidth(), viewport.getWorldHeight());\n    }\n\n    private void collideWithWalls(float radius, float viewportWidth, float viewportHeight) {\n        if (position.x - radius < 0) {\n            position.x = radius;\n            velocity.x = -velocity.x;\n        }\n        if (position.x + radius > viewportWidth) {\n            position.x = viewportWidth - radius;\n            velocity.x = -velocity.x;\n        }\n        if (position.y - radius < 0) {\n            position.y = radius;\n            velocity.y = -velocity.y;\n        }\n        if (position.y + radius > viewportHeight) {\n            position.y = viewportHeight - radius;\n            velocity.y = -velocity.y;\n        }\n    }\n\n    public void render(ShapeRenderer renderer) {\n        renderer.set(ShapeType.Filled);\n        renderer.setColor(COLOR);\n        renderer.circle(position.x, position.y, baseRadius * radiusMultiplier);\n    }\n\n\n    @Override\n    public boolean keyDown(int keycode) {\n\n        if (keycode == Keys.SPACE){\n            randomKick();\n        }\n\n        // TODO: If Keys.R was pressed, call init() to reset the ball\n        if (keycode == Keys.R){\n            init();\n        }\n\n        return true;\n    }\n}\n", "port com.swandiggy.poe4j.data.annotations.Order;\nimport com.swandiggy.poe4j.data.rows.BaseRow;\nimport lombok.Data;\nimport lombok.EqualsAndHashCode;\n\n@Data\n@EqualsAndHashCode(callSuper = true)\n@DatFile(\"StrMissionMapModNumbers\")\npublic class StrMissionMapModNumber\n    extends BaseRow\n{\n\n    @Order(0)\n    private String id;\n    @Order(1)\n    private Integer spawnWeight;\n    @Order(2)\n    private Integer minLevel;\n    @Order(3)\n    private Integer maxLevel;\n    @Order(4)\n    private Integer unknown0;\n    @Order(5)\n    private Integer unknown1;\n\n}\n", "cense found in the\n * LICENSE file in the root directory of this source tree.\n */\n\npackage com.facebook.drawee.drawable;\n\nimport static org.mockito.Mockito.*;\n\nimport android.graphics.Canvas;\nimport android.graphics.ColorFilter;\nimport android.graphics.Rect;\nimport android.graphics.drawable.Drawable;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.robolectric.RobolectricTestRunner;\n\n/**\n * Tests for {@link ForwardingDrawable}\n */\n@RunWith(RobolectricTestRunner.class)\npublic class ForwardingDrawableTest {\n  private Drawable mInnerDrawable;\n  private ForwardingDrawable mDrawable;\n\n  @Before\n  public void setup() {\n    mInnerDrawable = mock(Drawable.class);\n    mDrawable = new ForwardingDrawable(mInnerDrawable);\n    // ForwardingDrawable will call mInnerDrawable.setCallback\n    reset(mInnerDrawable);\n  }\n\n  @Test\n  public void testIntrinsicDimensions() {\n    when(mInnerDrawable.getIntrinsicWidth()).thenReturn(100);\n    when(mInnerDrawable.getIntrinsicHeight()).thenReturn(200);\n    Drawable drawable1 = new ForwardingDrawable(mInnerDrawable);\n    Assert.assertEquals(100, drawable1.getIntrinsicWidth());\n    Assert.assertEquals(200, drawable1.getIntrinsicHeight());\n  }\n\n  @Test\n  public void testGetCurrent() {\n    Assert.assertEquals(mInnerDrawable, mDrawable.getCurrent());\n  }\n\n  @Test\n  public void testSettersAndGetters() {\n    ColorFilter colorFilterMock = mock(ColorFilter.class);\n    Rect rectMock = mock(Rect.class);\n    int alpha = 77;\n    boolean dither = true;\n    boolean filterBitmap = false;\n    boolean visible = false;\n    boolean restart = false;\n\n    //when(mInnerDrawable.setVisible(visible, restart)).thenReturn(true);\n    when(mInnerDrawable.getOpacity()).thenReturn(11);\n    Assert.assertEquals(11, mDrawable.getOpacity());\n\n    mDrawable.getPadding(rectMock);\n    mDrawable.setAlpha(alpha);\n    mDrawable.setDither(dither);\n    mDrawable.setFilterBitmap(filterBitmap);\n    mDrawable.setColorFilter(colorFilterMock);\n    mDrawable.onBoundsChange(rectMock);\n    mDrawable.setVisible(visible, restart);\n\n    verify(mInnerDrawable).getPadding(rectMock);\n    verify(mInnerDrawable).setAlpha(alpha);\n    verify(mInnerDrawable).setDither(dither);\n    verify(mInnerDrawable).setFilterBitmap(filterBitmap);\n    verify(mInnerDrawable).setColorFilter(colorFilterMock);\n    verify(mInnerDrawable).setBounds(rectMock);\n    verify(mInnerDrawable).setVisible(visible, restart);\n  }\n\n  @Test\n  public void testDraw() {\n    Canvas mockCanvas = mock(Canvas.class);\n    mDrawable.draw(mockCanvas);\n    verify(mInnerDrawable).draw(mockCanvas);\n  }\n\n  @Test\n  public void testCopyProperties() {\n    Rect rect = new Rect(10, 20, 30, 40);\n    int config = 11;\n    int level = 100;\n    boolean visible = true;\n    int[] stateSet = new int[]{1, 2};\n\n    mDrawable.setBounds(rect);\n    mDrawable.setChangingConfigurations(config);\n    mDrawable.setLevel(level);\n    mDrawable.setVisible(visible, false);\n    mDrawable.setState(stateSet);\n\n    Drawable newDrawable = mock(Drawable.class);\n    mDrawable.setCurrent(newDrawable);\n\n    verify(newDrawable).setBounds(rect);\n    verify(newDrawable).setChangingConfigurations(config);\n    verify(newDrawable).setLevel(level);\n    verify(newDrawable).setVisible(visible, false);\n    verify(newDrawable).setState(stateSet);\n  }\n}\n", "InternalRequiredPort {\n\n    public SelfPort() {\n        super(\"self\");\n    }\n}\n", "cciGames.gameEngine.PlayerMapObjectInterface;\nimport voogasalad_GucciGames.gameplayer.windows.mainwindow.map.MapInterface;\nimport voogasalad_GucciGames.gameplayer.windows.mainwindow.map.cell.MapCellInterface;\n\npublic class CellUnit {\n\n\tprivate String myImage;\n\tprivate MapInterface myMap;\n\tprivate MapCellInterface myCell;\n\n\tprivate PlayerMapObjectInterface myUnit;\n\n\tpublic CellUnit(MapInterface map, MapCellInterface cell, PlayerMapObjectInterface unit) {\n\t\tmyMap = map;\n\t\tmyCell = cell;\n\t\tmyUnit = unit;\n\t}\n\n\tpublic void updateImage(String image) {\n\t\tmyImage = image;\n\t}\n\n\tpublic String getImage() {\n\t\treturn myImage;\n\t}\n\n}\n", ".eclipse.jdt.annotation.Nullable;\r\n\r\nimport lombok.EqualsAndHashCode;\r\nimport lombok.ToString;\r\n\r\n@ToString\r\n@EqualsAndHashCode\r\npublic class MatchingResult {\r\n\r\n\tprivate final Map<Person, Group> map = new HashMap<>();\r\n\r\n\tpublic @Nullable Group getGroup(Person person) {\r\n\t\treturn map.get(person);\r\n\t}\r\n\r\n\tpublic void add(Person person, @Nullable Group group) {\r\n\t\tif (group != null) {\r\n\t\t\tmap.put(person, group);\r\n\t\t}\r\n\t}\r\n}\r\n", "le.com/p/encog-java/\n \n * Copyright 2008-2012 Heaton Research, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *   \n * For more information on Heaton Research copyrights, licenses \n * and trademarks visit:\n * http://www.heatonresearch.com/copyright\n */\npackage org.encog.app.analyst.csv.normalize;\n\n", "bstraction.MCDynmapAPI;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapAreaMarker;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapCircleMarker;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapIcon;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapIconMarker;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapMarker;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapMarkerAPI;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapMarkerSet;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapPlayerSet;\r\nimport com.hekta.chdynmap.abstraction.MCDynmapPolyLineMarker;\r\nimport com.laytonsmith.core.constructs.Target;\r\nimport com.laytonsmith.core.exceptions.ConfigRuntimeException;\r\nimport com.laytonsmith.core.functions.Exceptions.ExceptionType;\r\nimport java.util.regex.Pattern;\r\n\r\n/**\r\n *\r\n * @author Hekta\r\n */\r\npublic final class CHDynmapStatic {\r\n\r\n\tpublic static MCDynmapAPI getDynmapAPI(Target t) {\r\n\t\tMCDynmapAPI api = CHDynmap.getDynmapAPI();\r\n\t\tif (api != null) {\r\n\t\t\treturn api;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"Needed plugin Dynmap not found.\", ExceptionType.InvalidPluginException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapMarkerAPI getMarkerAPI(Target t) {\r\n\t\ttry {\r\n\t\t\treturn getDynmapAPI(t).getMarkerAPI();\r\n\t\t} catch (NullPointerException exception) {\r\n\t\t\tthrow new ConfigRuntimeException(\"The marker API of Dynmap plugin is not loaded.\", ExceptionType.PluginInternalException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapMarkerSet getMarkerSet(String setID, Target t) {\r\n\t\tMCDynmapMarkerSet set = getMarkerAPI(t).getMarkerSet(setID);\r\n\t\tif (set != null) {\r\n\t\t\treturn set;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + setID + \"\\\" is not an existing markerset.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapMarker getMarker(String setID, String markerID, Target t) {\r\n\t\tMCDynmapMarker marker = getMarkerSet(setID, t).getMarker(markerID);\r\n\t\tif (marker != null) {\r\n\t\t\treturn marker;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + markerID + \"\\\" is not an existing marker.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapAreaMarker getAreaMarker(String setID, String markerID, Target t) {\r\n\t\tMCDynmapAreaMarker marker = getMarkerSet(setID, t).getAreaMarker(markerID);\r\n\t\tif (marker != null) {\r\n\t\t\treturn marker;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + markerID + \"\\\" is not an existing area marker.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapCircleMarker getCircleMarker(String setID, String markerID, Target t) {\r\n\t\tMCDynmapCircleMarker marker = getMarkerSet(setID, t).getCircleMarker(markerID);\r\n\t\tif (marker != null) {\r\n\t\t\treturn marker;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + markerID + \"\\\" is not an existing circle marker.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapIconMarker getIconMarker(String setID, String markerID, Target t) {\r\n\t\tMCDynmapIconMarker marker = getMarkerSet(setID, t).getIconMarker(markerID);\r\n\t\tif (marker != null) {\r\n\t\t\treturn marker;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + markerID + \"\\\" is not an existing icon marker.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapPolyLineMarker getPolyLineMarker(String setID, String markerID, Target t) {\r\n\t\tMCDynmapPolyLineMarker marker = getMarkerSet(setID, t).getPolyLineMarker(markerID);\r\n\t\tif (marker != null) {\r\n\t\t\treturn marker;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + markerID + \"\\\" is not an existing polyline marker.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapIcon getIcon(String iconID, Target t) {\r\n\t\tMCDynmapIcon icon = getMarkerAPI(t).getIcon(iconID);\r\n\t\tif (icon != null) {\r\n\t\t\treturn icon;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + iconID + \"\\\" is not an existing icon.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static MCDynmapPlayerSet getPlayerSet(String setID, Target t) {\r\n\t\tMCDynmapPlayerSet set = getMarkerAPI(t).getPlayerSet(setID);\r\n\t\tif (set != null) {\r\n\t\t\treturn set;\r\n\t\t} else {\r\n\t\t\tthrow new ConfigRuntimeException(\"\\\"\" + setID + \"\\\" is not an existing playerset.\", ExceptionType.NotFoundException, t);\r\n\t\t}\r\n\t}\r\n\r\n\tpublic static void testDynmapIDValidity(String ID, Target t) {\r\n\t\tif (Pattern.matches(\"[^\\\\w\\\\.]\", ID)) {\r\n\t\t\tthrow new ConfigRuntimeException(\"A setID must only contain numbers, letters, periods (.) and underscores (_).\", ExceptionType.FormatException, t);\r\n\t\t}\r\n\t}\r\n}", "* @author Edmond Weiss\n * @since 2017-01-12\n */\npackage chapter3;\n\npublic class GamePickACard3_24 {\n  public static void main(String[] args) {\n    // Generate random rank and suit\n    int cardRank = (int)(Math.random() * 13 + 1); // Range 1 <= x <= 13\n    int suit = (int)(Math.random() * 4); // Range 0 <= x < 4\n    \n    // Display result\n    System.out.print(\"The card you picked is \");\n    // Display rank\n    switch (cardRank) {\n      case 1: System.out.print(\"Ace\"); break;\n      case 2: System.out.print(\"2\"); break;\n      case 3: System.out.print(\"3\"); break;\n      case 4: System.out.print(\"4\"); break;\n      case 5: System.out.print(\"5\"); break;\n      case 6: System.out.print(\"6\"); break;\n      case 7: System.out.print(\"7\"); break;\n      case 8: System.out.print(\"8\"); break;\n      case 9: System.out.print(\"9\"); break;\n      case 10: System.out.print(\"10\"); break;\n      case 11: System.out.print(\"Jack\"); break;\n      case 12: System.out.print(\"Queen\"); break;\n      case 13: System.out.print(\"King\"); break;\n    }\n    System.out.print(\" of \");\n    // Display suit\n    switch (suit) {\n      case 0: System.out.println(\"Clubs\"); break;\n      case 1: System.out.println(\"Diamonds\"); break;\n      case 2: System.out.println(\"Hearts\"); break;\n      case 3: System.out.println(\"Spades\"); break;\n    }\n  }\n}", "wt.Graphics;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.MouseListener;\nimport java.awt.event.MouseMotionListener;\n\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\n\nimport Game.GamePanel;\nimport Main.Frame;\nimport Main.ShowFPS;\n\n//Probably shouldn't implement Runnable atm, unless want to add custom extra things in the future\npublic class MenuPanel extends JPanel implements Runnable{\n\tThread thread = new Thread(this);\n\tprivate boolean first = true;\n\tpublic int myWidth, myHeight;\n\t\n\t\n\tpublic MenuPanel(){\n\t\t//Add a mouse Listener to the JPanel\n\t\tthis.addMouseListener(new MouseListener(){\n\t\t\t@Override\n\t\t\tpublic void mouseClicked(MouseEvent arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseEntered(MouseEvent arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseExited(MouseEvent arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mousePressed(MouseEvent arg0) {\n\t\t\t\tString levelname = JOptionPane.showInputDialog(\"Enter level name (try 'stresstest', 'test', 'test1')\");\n\t\t\t\tFrame.setComponent(new GamePanel(levelname));\n\t\t\t\tFrame.frame.setTitle(\"SideScroller Game - \" + levelname);\n\t\t\t\tSystem.out.println(\"Hiu\");\n\t\t\t\t\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseReleased(MouseEvent arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t\t\n\t\t//Add a mouseMotionListner to the JPanel\n\t\tthis.addMouseMotionListener(new MouseMotionListener(){\n\n\t\t\t@Override\n\t\t\tpublic void mouseDragged(MouseEvent e) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void mouseMoved(MouseEvent e) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\t\n\t\t\t}\n\t\t});\n\t\t\n\t\t//Set focusable to mouseMotionListener can detect and focus on panel\n\t\tthis.setFocusable(true);\n\t\tthis.requestFocusInWindow();\n\t\t\n\t\t//Debug\n\t\tthis.setName(\"MenuPanel\");\n\t\t\n\t\t//Start the runnable thread\n\t\tthread.start();\n\t}\n\t\n\t//PaintComponent for the MenuPanel\n\t@Override\n\tpublic void paintComponent(Graphics g){\n\t\tif(first){\n\t\t\tdefine();\n\t\t\tfirst = false;\n\t\t}\n\t\t\n\t\tg.setColor(new Color(100,0,255));\n\t\tg.fillRect(0, 0, myWidth, myHeight);\n\t\t\n\t\tg.setColor(Color.white);\n\t\tg.setFont(new Font(\"Arial\", Font.ITALIC, 40));\n\t\tg.drawString(\"Click anywhere to start\", 40, 60);\n\t\t\n\t\tShowFPS.drawFPS(g);\n\t}\n\t\n\t//Sets local variables on instance creation\n\tpublic void define(){\n\t\tmyWidth = getWidth();\n\t\tmyHeight = getHeight();\n\t}\n\t\n\t//New Thread method\n\tpublic void run(){\n\t\t\n\t}\n}\n", "charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage io.webfolder.cdp.command;\n\nimport io.webfolder.cdp.annotation.Domain;\nimport io.webfolder.cdp.annotation.Experimental;\nimport io.webfolder.cdp.annotation.Optional;\nimport io.webfolder.cdp.annotation.Returns;\nimport io.webfolder.cdp.type.indexeddb.DatabaseWithObjectStores;\nimport io.webfolder.cdp.type.indexeddb.KeyRange;\nimport io.webfolder.cdp.type.indexeddb.RequestDataResult;\nimport java.util.List;\n\n@Experimental\n@Domain(\"IndexedDB\")\npublic interface IndexedDB {\n    /**\n     * Enables events from backend.\n     */\n    void enable();\n\n    /**\n     * Disables events from backend.\n     */\n    void disable();\n\n    /**\n     * Requests database names for given security origin.\n     * \n     * @param securityOrigin Security origin.\n     * \n     * @return Database names for origin.\n     */\n    @Returns(\"databaseNames\")\n    List<String> requestDatabaseNames(String securityOrigin);\n\n    /**\n     * Requests database with given name in given frame.\n     * \n     * @param securityOrigin Security origin.\n     * @param databaseName Database name.\n     * \n     * @return Database with an array of object stores.\n     */\n    @Returns(\"databaseWithObjectStores\")\n    DatabaseWithObjectStores requestDatabase(String securityOrigin, String databaseName);\n\n    /**\n     * Requests data from object store or index.\n     * \n     * @param securityOrigin Security origin.\n     * @param databaseName Database name.\n     * @param objectStoreName Object store name.\n     * @param indexName Index name, empty string for object store data requests.\n     * @param skipCount Number of records to skip.\n     * @param pageSize Number of records to fetch.\n     * @param keyRange Key range.\n     * \n     * @return RequestDataResult\n     */\n    RequestDataResult requestData(String securityOrigin, String databaseName,\n            String objectStoreName, String indexName, Integer skipCount, Integer pageSize,\n            @Optional KeyRange keyRange);\n\n    /**\n     * Clears all entries from an object store.\n     * \n     * @param securityOrigin Security origin.\n     * @param databaseName Database name.\n     * @param objectStoreName Object store name.\n     */\n    void clearObjectStore(String securityOrigin, String databaseName, String objectStoreName);\n\n    /**\n     * Deletes a database.\n     * \n     * @param securityOrigin Security origin.\n     * @param databaseName Database name.\n     */\n    void deleteDatabase(String securityOrigin, String databaseName);\n\n    /**\n     * Requests data from object store or index.\n     * \n     * @param securityOrigin Security origin.\n     * @param databaseName Database name.\n     * @param objectStoreName Object store name.\n     * @param indexName Index name, empty string for object store data requests.\n     * @param skipCount Number of records to skip.\n     * @param pageSize Number of records to fetch.\n     * \n     * @return RequestDataResult\n     */\n    RequestDataResult requestData(String securityOrigin, String databaseName,\n            String objectStoreName, String indexName, Integer skipCount, Integer pageSize);\n}\n", "y granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.yandex.money.api.methods;\n\nimport com.yandex.money.api.model.Error;\nimport com.yandex.money.api.net.MethodResponse;\n\nimport java.util.Collections;\nimport java.util.Map;\n\n/**\n * Base class for all process payment operations.\n *\n * @author Slava Yasevich (vyasevich@yamoney.ru)\n */\npublic abstract class BaseProcessPayment implements MethodResponse {\n\n    protected static final String MEMBER_STATUS = \"status\";\n    protected static final String MEMBER_ERROR = \"error\";\n    protected static final String MEMBER_ACS_URI = \"acs_uri\";\n    protected static final String MEMBER_ACS_PARAMS = \"acs_params\";\n    protected static final String MEMBER_NEXT_RETRY = \"next_retry\";\n\n    public final Status status;\n    public final Error error;\n    public final String invoiceId;\n    public final String acsUri;\n    public final Map<String, String> acsParams;\n    public final Long nextRetry; // TODO make it long\n\n    /**\n     * Constructor.\n     *\n     * @param status status of the operation\n     * @param error error code\n     * @param acsUri address for 3D Secure authorization\n     * @param acsParams POST parameters for 3D Secure authorization (key-value pairs)\n     * @param nextRetry recommended time interval between process payment requests\n     */\n    public BaseProcessPayment(Status status, Error error, String invoiceId, String acsUri,\n                              Map<String, String> acsParams, Long nextRetry) {\n\n        if (status == Status.EXT_AUTH_REQUIRED && acsUri == null) {\n            throw new NullPointerException(\"acsUri is null when status is ext_auth_required\");\n        }\n        if (acsParams == null) {\n            throw new NullPointerException(\"acsParams is null\");\n        }\n        this.status = status;\n        this.error = error;\n        this.invoiceId = invoiceId;\n        this.acsUri = acsUri;\n        this.acsParams = Collections.unmodifiableMap(acsParams);\n        this.nextRetry = nextRetry;\n    }\n\n    @Override\n    public String toString() {\n        return \"BaseProcessPayment{\" +\n                \"status=\" + status +\n                \", error=\" + error +\n                \", invoiceId='\" + invoiceId + '\\'' +\n                \", acsUri='\" + acsUri + '\\'' +\n                \", acsParams=\" + acsParams +\n                \", nextRetry=\" + nextRetry +\n                '}';\n    }\n\n    public enum Status {\n        SUCCESS(CODE_SUCCESS),\n        REFUSED(CODE_REFUSED),\n        IN_PROGRESS(CODE_IN_PROGRESS),\n        EXT_AUTH_REQUIRED(CODE_EXT_AUTH_REQUIRED),\n        UNKNOWN(CODE_UNKNOWN);\n\n        public final String code;\n\n        Status(String code) {\n            this.code = code;\n        }\n\n        public static Status parse(String status) {\n            for (Status value : values()) {\n                if (value.code.equals(status)) {\n                    return value;\n                }\n            }\n            return UNKNOWN;\n        }\n    }\n}\n", "ivityManager;\nimport android.content.Intent;\nimport android.graphics.Color;\nimport android.os.Bundle;\nimport android.support.v7.app.ActionBarActivity;\nimport android.util.Log;\nimport android.view.KeyEvent;\nimport android.view.Menu;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.view.inputmethod.EditorInfo;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\n\nimport domains.Message;\nimport handlers.OrtcHandler;\nimport interfaces.InterfaceRefresher;\nimport preferences.PreferencesManager;\nimport rtmchat.realtime.co.rtmchat.R;\nimport services.MyService;\n\n\npublic class MainActivity extends ActionBarActivity implements InterfaceRefresher {\n\n    @Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.activity_main);\n\n\t\tOrtcHandler.prepareClient(getApplicationContext(),this);\n\n        if(!isMyServiceRunning(MyService.class)) {\n            startService(new Intent(this, MyService.class));\n        }\n\n        EditText inputUser = (EditText) this.findViewById(R.id.nickNameInput);\n\t\t\n\t\tfinal Button bt = (Button) findViewById(R.id.chatRooms);\n\t\tbt.setEnabled(false);\n\t\tbt.setOnClickListener(new View.OnClickListener() {\n\t\t\t@Override\n\t\t\tpublic void onClick(View v) {\n\t\t\t\tIntent myIntent = new Intent(MainActivity.this, ChatRoomActivity.class);\n\t\t\t\tMainActivity.this.startActivity(myIntent);\t\t\t\t\n\t\t\t}\n\t\t});\n\n\t\tString user = PreferencesManager.getInstance(this).loadUser();\n\n\t\tif(user != null){\n            String welcomeLabel = String.format(getString(R.string.welcomeLabel), user);\n\t\t\tinputUser.setText(welcomeLabel);\n\t\t\tinputUser.setEnabled(false);\n\t\t}else{\n\t\t\tinputUser.setOnEditorActionListener(new TextView.OnEditorActionListener() {\n\t\t        @Override\n\t\t        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {\n\t\t            if (actionId == EditorInfo.IME_ACTION_DONE) {\n\t\t            \tPreferencesManager.getInstance(MainActivity.this).saveUser(v.getText().toString());\n\t\t            \tv.setEnabled(false);\n\t\t            \t\n\t\t            \tif(OrtcHandler.selfHandler.isConnected){\n\t\t            \t\tbt.setEnabled(true);\n\t\t            \t\tbt.setBackgroundColor(Color.WHITE);\n\t\t            \t\treturn true;\n\t\t            \t}\n\t\t            }\n\t\t            return false;\n\t\t        }\n\n\t\t    });\n\t\t}\n\t}\n\n    @Override\n\tpublic boolean onCreateOptionsMenu(Menu menu) {\n\t\tgetMenuInflater().inflate(R.menu.menu_main, menu);\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic boolean onOptionsItemSelected(MenuItem item) {\n\t\tint id = item.getItemId();\n\t\tif (id == R.id.action_settings) {\n\t\t\treturn true;\n\t\t}\n\t\treturn super.onOptionsItemSelected(item);\n\t}\n\n\t@Override\n\tpublic void refreshData(Message msg) {\n\t\trunOnUiThread(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tTextView connectionLabel = (TextView)findViewById(R.id.connectionLabel);\n\t\t\t\tconnectionLabel.setText(getString(R.string.ortcConnected));\n\t\t\t\tButton chatRooms = (Button)findViewById(R.id.chatRooms);\n\t\t\t\tif(PreferencesManager.getInstance(MainActivity.this).loadUser() != null){\n\t\t\t\t\tchatRooms.setEnabled(true);\n\t\t\t\t\tchatRooms.setBackgroundColor(Color.WHITE);\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\t\t});\n\t\t\n\t}\n\n    private boolean isMyServiceRunning(Class<?> serviceClass) {\n        ActivityManager manager = (ActivityManager) getSystemService(ACTIVITY_SERVICE);\n        for (ActivityManager.RunningServiceInfo service : manager.getRunningServices(Integer.MAX_VALUE)) {\n            if (serviceClass.getName().equals(service.service.getClassName())) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n", "on,\n    draft,\n    addFriend;\n}\n", "app.Dialog;\nimport android.content.DialogInterface.OnClickListener;\nimport android.os.Bundle;\nimport android.support.v4.app.DialogFragment;\n\n/**\n * Create dialog for media picker module. Should only use in this module.\n */\npublic class MediaPickerErrorDialog extends DialogFragment {\n\tprivate String mMessage;\n\tprivate OnClickListener mOnPositionClickListener;\n\n\tpublic static MediaPickerErrorDialog newInstance(String msg) {\n\t\tMediaPickerErrorDialog dialog = new MediaPickerErrorDialog();\n\t\tBundle bundle = new Bundle();\n\t\tbundle.putString(\"msg\", msg);\n\t\tdialog.setArguments(bundle);\n\t\treturn dialog;\n\t}\n\n\t@Override\n\tpublic void onCreate(Bundle savedInstanceState) {\n\t\tsuper.onCreate(savedInstanceState);\n\t\tmMessage = getArguments().getString(\"msg\");\n\t}\n\n\t@Override\n\tpublic Dialog onCreateDialog(Bundle savedInstanceState) {\n\t\treturn new AlertDialog.Builder(getActivity()).setMessage(mMessage).setPositiveButton(android.R.string.ok, mOnPositionClickListener).create();\n\t}\n\n\tpublic void setOnOKClickListener(OnClickListener mOnClickListener) {\n\t\tthis.mOnPositionClickListener = mOnClickListener;\n\t}\n}\n", "e;\nimport com.facebook.react.bridge.JavaScriptModule;\nimport com.facebook.react.bridge.NativeModule;\nimport com.facebook.react.bridge.ReactApplicationContext;\nimport com.facebook.react.uimanager.ViewManager;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class RNAssetResizeToBase64Package implements ReactPackage\n{\n\tIntent mIntent;\n\n\t@Override\n\tpublic List<NativeModule> createNativeModules(ReactApplicationContext reactContext)\n\t{\n\t\tList<NativeModule> modules = new ArrayList<>();\n\t\tmodules.add(new RNAssetResizeToBase64Module(reactContext));\n\t\treturn modules;\n\t}\n\n\t@Override\n\tpublic List<Class<? extends JavaScriptModule>> createJSModules()\n\t{\n\t\treturn Collections.emptyList();\n\t}\n\n\t@Override\n\tpublic List<ViewManager> createViewManagers(ReactApplicationContext reactContext)\n\t{\n\t\treturn Arrays.<ViewManager>asList();\n\t}\n}\n", "h;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.wickedsource.coderadar.core.rest.validation.ResourceNotFoundException;\nimport org.wickedsource.coderadar.user.domain.User;\nimport org.wickedsource.coderadar.user.domain.UserRegistrationDataResource;\nimport org.wickedsource.coderadar.user.domain.UserRepository;\n\nimport static org.assertj.core.api.Assertions.assertThat;\nimport static org.mockito.Matchers.anyLong;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Mockito.when;\n\n@RunWith(SpringJUnit4ClassRunner.class)\npublic class RegistrationServiceTest {\n\n    @InjectMocks\n    private RegistrationService registrationService;\n\n    @Mock\n    private UserRepository userRepository;\n\n    @Test\n    public void existsUser() throws Exception {\n        when(userRepository.findByUsername(anyString())).thenReturn(new User());\n        boolean existsUser = registrationService.userExists(new UserRegistrationDataResource(\"username\", \"password\"));\n        assertThat(existsUser).isTrue();\n    }\n\n    @Test\n    public void notExistUser() throws Exception {\n        when(userRepository.findByUsername(anyString())).thenReturn(null);\n        boolean existsUser = registrationService.userExists(new UserRegistrationDataResource(\"username\", \"password\"));\n        assertThat(existsUser).isFalse();\n    }\n\n    @Test\n    public void getUser() throws Exception {\n        User user = new User();\n        user.setUsername(\"user\");\n        when(userRepository.findOne(anyLong())).thenReturn(user);\n        User foundUser = registrationService.getUser(1L);\n        assertThat(foundUser).isSameAs(user);\n    }\n\n    @Test(expected = ResourceNotFoundException.class)\n    public void getUserNotFound() throws Exception {\n        when(userRepository.findOne(anyLong())).thenReturn(null);\n        registrationService.getUser(1L);\n    }\n}\n", "age com.azure.storage.blob.specialized;\n\nimport com.azure.core.util.Context;\nimport com.azure.core.util.FluxUtil;\nimport com.azure.core.util.logging.ClientLogger;\nimport com.azure.storage.blob.BlobAsyncClient;\nimport com.azure.storage.blob.implementation.util.StorageBlockingSink;\nimport com.azure.storage.blob.models.AccessTier;\nimport com.azure.storage.blob.models.AppendBlobRequestConditions;\nimport com.azure.storage.blob.models.BlobHttpHeaders;\nimport com.azure.storage.blob.models.BlobRequestConditions;\nimport com.azure.storage.blob.models.BlobStorageException;\nimport com.azure.storage.blob.models.PageBlobRequestConditions;\nimport com.azure.storage.blob.models.PageRange;\nimport com.azure.storage.blob.models.ParallelTransferOptions;\nimport com.azure.storage.blob.options.BlobParallelUploadOptions;\nimport com.azure.storage.blob.options.BlockBlobOutputStreamOptions;\nimport com.azure.storage.common.StorageOutputStream;\nimport com.azure.storage.common.implementation.Constants;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\nimport reactor.core.scheduler.Schedulers;\n\nimport java.io.IOException;\nimport java.nio.ByteBuffer;\nimport java.util.Map;\nimport java.util.concurrent.locks.Condition;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\n/**\n * BlobOutputStream allows for the uploading of data to a blob using a stream-like approach.\n */\npublic abstract class BlobOutputStream extends StorageOutputStream {\n\n    BlobOutputStream(final int writeThreshold) {\n        super(writeThreshold);\n    }\n\n    static BlobOutputStream appendBlobOutputStream(final AppendBlobAsyncClient client,\n        final AppendBlobRequestConditions appendBlobRequestConditions) {\n        return new AppendBlobOutputStream(client, appendBlobRequestConditions);\n    }\n\n    /**\n     * Creates a block blob output stream from a BlobAsyncClient\n     * @param client {@link BlobAsyncClient} The blob client.\n     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n     * @param headers {@link BlobHttpHeaders}\n     * @param metadata Metadata to associate with the blob. If there is leading or trailing whitespace in any\n     * metadata key or value, it must be removed or encoded.\n     * @param tier {@link AccessTier} for the destination blob.\n     * @param requestConditions {@link BlobRequestConditions}\n     * @return {@link BlobOutputStream} associated with the blob.\n     */\n    public static BlobOutputStream blockBlobOutputStream(final BlobAsyncClient client,\n        final ParallelTransferOptions parallelTransferOptions, final BlobHttpHeaders headers,\n        final Map<String, String> metadata, final AccessTier tier, final BlobRequestConditions requestConditions) {\n        return blockBlobOutputStream(client, parallelTransferOptions, headers, metadata, tier, requestConditions,\n            Context.NONE);\n    }\n\n    /**\n     * Creates a block blob output stream from a BlobAsyncClient\n     * @param client {@link BlobAsyncClient} The blob client.\n     * @param parallelTransferOptions {@link ParallelTransferOptions} used to configure buffered uploading.\n     * @param headers {@link BlobHttpHeaders}\n     * @param metadata Metadata to associate with the blob. If there is leading or trailing whitespace in any\n     * metadata key or value, it must be removed or encoded.\n     * @param tier {@link AccessTier} for the destination blob.\n     * @param requestConditions {@link BlobRequestConditions}\n     * @param context Additional context that is passed through the Http pipeline during the service call.\n     * @return {@link BlobOutputStream} associated with the blob.\n     */\n    public static BlobOutputStream blockBlobOutputStream(final BlobAsyncClient client,\n        final ParallelTransferOptions parallelTransferOptions, final BlobHttpHeaders headers,\n        final Map<String, String> metadata, final AccessTier tier,\n        final BlobRequestConditions requestConditions, Context context) {\n        return blockBlobOutputStream(client, new BlockBlobOutputStreamOptions()\n                .setParallelTransferOptions(parallelTransferOptions).setHeaders(headers).setMetadata(metadata)\n                .setTier(tier).setRequestConditions(requestConditions),\n            context);\n    }\n\n    /**\n     * Creates a block blob output stream from a BlobAsyncClient\n     * @param client {@link BlobAsyncClient} The blob client.\n     * @param options {@link BlockBlobOutputStreamOptions}\n     * @param context Additional context that is passed through the Http pipeline during the service call.\n     * @return {@link BlobOutputStream} associated with the blob.\n     */\n    public static BlobOutputStream blockBlobOutputStream(final BlobAsyncClient client,\n        BlockBlobOutputStreamOptions options, Context context) {\n        options = options == null ? new BlockBlobOutputStreamOptions() : options;\n        return new BlockBlobOutputStream(client, options.getParallelTransferOptions(), options.getHeaders(),\n            options.getMetadata(), options.getTags(), options.getTier(), options.getRequestConditions(), context);\n    }\n\n    static BlobOutputStream pageBlobOutputStream(final PageBlobAsyncClient client, final PageRange pageRange,\n        final BlobRequestConditions requestConditions) {\n        return new PageBlobOutputStream(client, pageRange, requestConditions);\n    }\n\n    abstract void commit();\n\n    /**\n     * Closes this output stream and releases any system resources associated with this stream. If any data remains in\n     * the buffer it is committed to the service.\n     *\n     * @throws IOException If an I/O error occurs.\n     */\n    @Override\n    public synchronized void close() throws IOException {\n        try {\n            // if the user has already closed the stream, this will throw a STREAM_CLOSED exception\n            // if an exception was thrown by any thread in the threadExecutor, realize it now\n            this.checkStreamState();\n\n            // flush any remaining data\n            this.flush();\n\n            // try to commit the blob\n            try {\n                this.commit();\n            } catch (final BlobStorageException e) {\n                throw new IOException(e);\n            }\n            /* Need this check because for block blob the buffered upload error only manifests itself after commit is\n               called */\n            if (this.lastError != null) {\n                throw lastError;\n            }\n        } finally {\n            // if close() is called again, an exception will be thrown\n            this.lastError = new IOException(Constants.STREAM_CLOSED);\n        }\n    }\n\n    private static final class AppendBlobOutputStream extends BlobOutputStream {\n        private static final String INVALID_BLOCK_SIZE =\n            \"Block data should not exceed BlockBlobURL.MAX_STAGE_BLOCK_BYTES\";\n\n        private final AppendBlobRequestConditions appendBlobRequestConditions;\n        private final AppendBlobAsyncClient client;\n\n        private AppendBlobOutputStream(final AppendBlobAsyncClient client,\n            final AppendBlobRequestConditions appendBlobRequestConditions) {\n            super(AppendBlobClient.MAX_APPEND_BLOCK_BYTES);\n            this.client = client;\n            this.appendBlobRequestConditions = (appendBlobRequestConditions == null)\n                ? new AppendBlobRequestConditions() : appendBlobRequestConditions;\n\n            if (this.appendBlobRequestConditions.getAppendPosition() == null) {\n                this.appendBlobRequestConditions.setAppendPosition(client.getProperties().block().getBlobSize());\n            }\n        }\n\n        private Mono<Void> appendBlock(Flux<ByteBuffer> blockData, long writeLength) {\n            long newAppendOffset = appendBlobRequestConditions.getAppendPosition() + writeLength;\n            return client.appendBlockWithResponse(blockData, writeLength, null, appendBlobRequestConditions)\n                .doOnNext(ignored -> appendBlobRequestConditions.setAppendPosition(newAppendOffset))\n                .then()\n                .onErrorResume(t -> t instanceof IOException || t instanceof BlobStorageException, e -> {\n                    this.lastError = new IOException(e);\n                    return Mono.empty();\n                });\n        }\n\n        @Override\n        protected Mono<Void> dispatchWrite(byte[] data, int writeLength, long offset) {\n            if (writeLength == 0) {\n                return Mono.empty();\n            }\n\n            // We cannot differentiate between max size condition failing only in the retry versus failing in the\n            // first attempt and retry even for a single writer scenario. So we will eliminate the latter and handle\n            // the former in the append block method.\n            if (appendBlobRequestConditions.getMaxSize() != null\n                && appendBlobRequestConditions.getAppendPosition() > appendBlobRequestConditions.getMaxSize()) {\n                this.lastError = new IOException(INVALID_BLOCK_SIZE);\n                return Mono.error(this.lastError);\n            }\n\n            Flux<ByteBuffer> fbb = Flux.range(0, 1).concatMap(pos -> Mono.fromCallable(() ->\n                ByteBuffer.wrap(data, (int) offset, writeLength)));\n\n            return this.appendBlock(fbb.subscribeOn(Schedulers.elastic()), writeLength);\n        }\n\n        @Override\n        void commit() {\n            // AppendBlob doesn't need to commit anything.\n        }\n    }\n\n    private static final class BlockBlobOutputStream extends BlobOutputStream {\n\n        private final Lock lock;\n        private final Condition transferComplete;\n        private final StorageBlockingSink sink;\n\n        boolean complete;\n\n        private BlockBlobOutputStream(final BlobAsyncClient client,\n            final ParallelTransferOptions parallelTransferOptions, final BlobHttpHeaders headers,\n            final Map<String, String> metadata, Map<String, String> tags, final AccessTier tier,\n            final BlobRequestConditions requestConditions, Context context) {\n            super(Integer.MAX_VALUE); // writeThreshold is effectively not used by BlockBlobOutputStream.\n            // There is a bug in reactor core that does not handle converting Context.NONE to a reactor context.\n            context = context == null || context.equals(Context.NONE) ? null : context;\n\n            this.lock = new ReentrantLock();\n            this.transferComplete = lock.newCondition();\n            this.sink = new StorageBlockingSink();\n\n            Flux<ByteBuffer> body = this.sink.asFlux();\n\n            client.uploadWithResponse(new BlobParallelUploadOptions(body)\n                .setParallelTransferOptions(parallelTransferOptions).setHeaders(headers).setMetadata(metadata)\n                .setTags(tags).setTier(tier).setRequestConditions(requestConditions))\n                // This allows the operation to continue while maintaining the error that occurred.\n                .onErrorResume(e -> {\n                    if (e instanceof IOException) {\n                        this.lastError = (IOException) e;\n                    } else {\n                        this.lastError = new IOException(e);\n                    }\n                    return Mono.empty();\n                })\n                // Use doFinally to cover all termination scenarios of the Flux.\n                .doFinally(signalType -> {\n                    lock.lock();\n                    try {\n                        complete = true;\n                        transferComplete.signal();\n                    } finally {\n                        lock.unlock();\n                    }\n                })\n                .contextWrite(FluxUtil.toReactorContext(context))\n                .subscribe();\n        }\n\n        @Override\n        void commit() {\n\n            // Need to wait until the uploadTask completes\n            lock.lock();\n            try {\n                sink.emitCompleteOrThrow(); /* Allow upload task to try to complete. */\n\n                while (!complete) {\n                    transferComplete.await();\n                }\n            } catch (InterruptedException e) {\n                this.lastError = new IOException(e.getMessage()); // Should we just throw and not populate this since its recoverable?\n            } catch (Exception e) { // Catch any exceptions by the sink.\n                this.lastError = new IOException(e);\n            } finally {\n                lock.unlock();\n            }\n\n        }\n\n        @Override\n        protected void writeInternal(final byte[] data, int offset, int length) {\n            this.checkStreamState();\n            /*\n            We need to do a deep copy here because the writing is async in this case. It is a common pattern for\n            customers writing to an output stream to perform the writes in a tight loop with a reused buffer. This\n            coupled with async network behavior can result in the data being overwritten as the buffer is reused.\n             */\n            byte[] buffer = new byte[length];\n            System.arraycopy(data, offset, buffer, 0, length);\n\n            try {\n                this.sink.emitNext(ByteBuffer.wrap(buffer));\n            } catch (Exception e) {\n                this.lastError = new IOException(e);\n            }\n        }\n\n        // Never called\n        @Override\n        protected Mono<Void> dispatchWrite(byte[] data, int writeLength, long offset) {\n            return Mono.empty();\n        }\n    }\n\n    private static final class PageBlobOutputStream extends BlobOutputStream {\n        private static final String INVALID_NUMBER_OF_BYTES_IN_THE_BUFFER =\n            \"Page data must be a multiple of 512 bytes. Buffer currently contains %d bytes.\";\n\n        private final ClientLogger logger = new ClientLogger(PageBlobOutputStream.class);\n        private final PageBlobAsyncClient client;\n        private final PageBlobRequestConditions pageBlobRequestConditions;\n        private final PageRange pageRange;\n\n        private PageBlobOutputStream(final PageBlobAsyncClient client, final PageRange pageRange,\n            final BlobRequestConditions blobRequestConditions) {\n            super(PageBlobClient.MAX_PUT_PAGES_BYTES);\n            this.client = client;\n            this.pageRange = pageRange;\n\n            if (blobRequestConditions != null) {\n                this.pageBlobRequestConditions = new PageBlobRequestConditions()\n                    .setLeaseId(blobRequestConditions.getLeaseId())\n                    .setIfMatch(blobRequestConditions.getIfMatch())\n                    .setIfNoneMatch(blobRequestConditions.getIfNoneMatch())\n                    .setIfModifiedSince(blobRequestConditions.getIfModifiedSince())\n                    .setIfUnmodifiedSince(blobRequestConditions.getIfUnmodifiedSince());\n            } else {\n                this.pageBlobRequestConditions = null;\n            }\n        }\n\n        private Mono<Void> writePages(Flux<ByteBuffer> pageData, int length, long offset) {\n            return client.uploadPagesWithResponse(new PageRange().setStart(offset).setEnd(offset + length - 1),\n                pageData, null, pageBlobRequestConditions)\n                .then()\n                .onErrorResume(BlobStorageException.class, e -> {\n                    this.lastError = new IOException(e);\n                    return Mono.empty();\n                });\n        }\n\n        @Override\n        protected Mono<Void> dispatchWrite(byte[] data, int writeLength, long offset) {\n            if (writeLength == 0) {\n                return Mono.empty();\n            }\n\n            if (writeLength % PageBlobAsyncClient.PAGE_BYTES != 0) {\n                return Mono.error(new IOException(String.format(INVALID_NUMBER_OF_BYTES_IN_THE_BUFFER,\n                    writeLength)));\n            }\n\n            Flux<ByteBuffer> fbb = Flux.range(0, 1)\n                .concatMap(pos -> Mono.fromCallable(() -> ByteBuffer.wrap(data, (int) offset, writeLength)));\n\n            long pageOffset = pageRange.getStart();\n            if (pageOffset + writeLength - 1 > pageRange.getEnd()) {\n                throw logger.logExceptionAsError(\n                    new RuntimeException(\"The input data length is larger than the page range.\"));\n            }\n            pageRange.setStart(pageRange.getStart() + writeLength);\n            return this.writePages(fbb.subscribeOn(Schedulers.elastic()), writeLength, pageOffset);\n        }\n\n        @Override\n        void commit() {\n            // PageBlob doesn't need to commit anything.\n        }\n    }\n}\n", "ce.EntityManager;\nimport javax.persistence.PersistenceContext;\n\npublic class DatabaseProducer {\n\n  @Produces\n  @PersistenceContext(unitName = \"vbookPersistenceUnit\")\n  private EntityManager entityManager;\n}\n", "public interface IMediator {\n    String Method_Name = \"handleNotification\";\n\n    void onRegister();\n    void onRemove();\n\n    void setViewComponent(Object viewComponent);\n    Object getViewComponent();\n\n    void setMediatorName(String name);\n    String getMediatorName();\n\n    void initializeMediator();\n    void handleNotification(INotification notification);\n    String[] listNotificationInterests();\n}\n", "MIT License (MIT)\n// \n// Copyright (c) 2014-2015 Keld Oelykke\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\npackage starkcoder.failfast.unit.objects.shorts;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNull;\nimport static org.junit.Assert.assertTrue;\n\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.rules.TestWatcher;\nimport org.junit.runner.Description;\n\nimport starkcoder.failfast.FailFast;\nimport starkcoder.failfast.IFailFast;\nimport starkcoder.failfast.SFailFast;\nimport starkcoder.failfast.checks.Checker;\nimport starkcoder.failfast.checks.IChecker;\nimport starkcoder.failfast.contractors.CallContractor;\nimport starkcoder.failfast.contractors.ICallContractor;\nimport starkcoder.failfast.fails.FailFastException;\nimport starkcoder.failfast.fails.Failer;\nimport starkcoder.failfast.fails.IFailer;\nimport starkcoder.failfast.templates.objects.IObjectNullTest;\n\n/**\n * Fail-fast unit test of {link:IObjectShortNullCheck} and {link:IObjectShortNullFail}.\n * \n * @author Keld Oelykke\n */\npublic class ShortNullTest implements IObjectNullTest<Short>\n{\n\n  private IChecker checker;\n  private IFailer failer;\n  private String toString = null;\n\n  @Override\n  public String toString()\n  {\n    return this.toString;\n  }\n\n  @Rule\n  public TestWatcher watcher = new TestWatcher()\n  {\n    protected void starting(Description description)\n    {\n      toString = description.getTestClass().getSimpleName() + \".\" + description.getMethodName();\n    }\n  };\n\n  /**\n   * Setup FailFast instances.\n   */\n  @Before\n  public void setUp()\n  {\n    // this would be in you application startup section\n    ICallContractor callContractor = new CallContractor();\n    IFailFast failFastOrNull = new FailFast(new Checker(callContractor),\n        new Failer(callContractor), callContractor);\n    SFailFast.setFailFastOrNull(failFastOrNull);\n    this.checker = SFailFast.getChecker();\n    this.failer = SFailFast.getFailer();\n  }\n\n  /**\n   * Clear FailFast instances.\n   */\n  @After\n  public void tearDown()\n  {\n    // this would be in you application shutdown section\n    SFailFast.setFailFastOrNull(null);\n    this.checker = null;\n    this.failer = null;\n  }\n\n  // 1st - caller checks\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testObjectNullCheckerCallerIsNull()\n  {\n    Short referenceNull = null;\n    if (checker.isShortNull(null, referenceNull))\n    {\n      failer.failShortNull(this, \"referenceNull\");\n    }\n  }\n\n  @Test(expected = IllegalArgumentException.class)\n  public void testObjectNullFailerCallerIsNull()\n  {\n    Short referenceNull = null;\n    if (checker.isShortNull(this, referenceNull))\n    {\n      failer.failShortNull(null, \"referenceNull\");\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testObjectNullFailerCallerIsWrong()\n  {\n    Short referenceNull = null;\n    if (checker.isShortNull(new String(\"Foo\"), referenceNull))\n    {\n      failer.failShortNull(new String(\"Bar\"), \"referenceNull\");\n    }\n  }\n\n  // 2nd - mismatch calls\n\n  @Test(expected = IllegalStateException.class)\n  public void testObjectNullMismatchCheckCheck()\n  {\n    Short referenceNull = null;\n    if (checker.isShortNull(this, referenceNull))\n    {\n      checker.isShortNull(this, referenceNull);\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testObjectNullMismatchFail()\n  {\n    failer.failShortNull(this, \"referenceNull\");\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testObjectNullMismatchWrongCheck()\n  {\n    Short referenceNull = new Short((short) 0);\n    if (checker.isShortNotNull(this, referenceNull)) // wrong call\n    {\n      failer.failShortNull(this, \"referenceNull\");\n    }\n  }\n\n  @Test(expected = IllegalStateException.class)\n  public void testObjectNullMismatchWrongFail()\n  {\n    Short referenceNull = null;\n    if (checker.isShortNull(this, referenceNull))\n    {\n      failer.failShortNotNull(this, \"referenceNull\"); // wrong call\n    }\n  }\n\n  // 3rd - normal cases\n\n  @Test(expected = FailFastException.class)\n  public void testObjectNullFailNoMessage()\n  {\n    Short referenceNull = null;\n    try\n    {\n      if (checker.isShortNull(this, referenceNull))\n      {\n        failer.failShortNull(this, \"referenceNull\");\n      }\n    }\n    catch (FailFastException failFastException)\n    {\n      assertEquals(\"Expected registered exception in failer\", failFastException,\n          failer.getFailFastExceptionOrNull());\n      System.out.println(failFastException.getMessage());\n      throw failFastException;\n\n    }\n  }\n\n  @Test(expected = FailFastException.class)\n  public void testObjectNullFailMessage()\n  {\n    Short referenceNull = null;\n    try\n    {\n      if (checker.isShortNull(this, referenceNull))\n      {\n        failer.failShortNull(this, \"referenceNull\", \"Extra info goes here\");\n      }\n    }\n    catch (FailFastException failFastException)\n    {\n      assertEquals(\"Expected registered exception in failer\", failFastException,\n          failer.getFailFastExceptionOrNull());\n      System.out.println(failFastException.getMessage());\n      throw failFastException;\n\n    }\n  }\n\n  @Test\n  public void testObjectNullNoFail()\n  {\n    Short referenceNotNull = new Short((short) 0);\n    if (checker.isShortNull(this, referenceNotNull))\n    {\n      failer.failShortNull(this, \"referenceNotNull\");\n    }\n    assertTrue(\"Expected referenceNotNull to pass the null check\", true);\n    assertNull(\"Expected no registered exception in failer\", failer.getFailFastExceptionOrNull());\n  }\n\n}\n", "let.MIDlet;\n\nimport br.unicamp.ic.sed.mobilemedia.copyphoto.spec.req.IMobileResources;\n\npublic class AdapterResourcesCopyPhoto implements IMobileResources {\n\n\tprivate IManager manager = ComponentFactory.createInstance();\n\t\n\tpublic MIDlet getMainMIDlet() {\n\t\t\n\t\tbr.unicamp.ic.sed.mobilemedia.main.IMobileResources mobileResources = (br.unicamp.ic.sed.mobilemedia.main.IMobileResources) manager.getRequiredInterface(\"IMobileResources\");\n\t\treturn mobileResources.getMainMIDlet();\n\t\t\n\t}\n\n\t\n\t\n}\n", "ss JSONChat {\n\n    private String id;\n    private String user;\n    private String message;\n    private LinkedList<String> messages = new LinkedList<String>();\n\n\n    public JSONChat() {\n    }\n\n    public JSONChat(String asd) {\n        this.id = asd;\n    }\n\n    public JSONChat(MyChat myChat) {\n        this.id = myChat.id;\n        this.user = myChat.user;\n        this.message = myChat.message;\n        this.messages = myChat.messages;\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    public void setId(String id) {\n        this.id = id;\n    }\n\n    public LinkedList<String> getMessages() {\n        return messages;\n    }\n\n    public void setMessages(LinkedList<String> messages) {\n        this.messages = messages;\n    }\n\n    public String getUser() {\n        return user;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n}\n", "a.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * Author: andrewgrosner\n * Description: Will generate a $Container class definition for the Model class. It is required when using\n * ModelContainers, that we mark every contained class with this annotation so we can handle them properly.\n */\n@Retention(RetentionPolicy.SOURCE)\n@Target(ElementType.TYPE)\npublic @interface ContainerAdapter {\n}\n", ".common.FMLLog;\nimport cpw.mods.fml.common.event.FMLInitializationEvent;\nimport cpw.mods.fml.common.event.FMLPostInitializationEvent;\nimport cpw.mods.fml.common.event.FMLPreInitializationEvent;\nimport cpw.mods.fml.common.network.NetworkRegistry;\nimport mcjty.deepresonance.DeepResonance;\nimport mcjty.deepresonance.blocks.ModBlocks;\nimport mcjty.deepresonance.blocks.crystals.ResonatingCrystalConfiguration;\nimport mcjty.deepresonance.blocks.generator.GeneratorConfiguration;\nimport mcjty.deepresonance.crafting.ModCrafting;\nimport mcjty.deepresonance.fluid.DRFluidRegistry;\nimport mcjty.deepresonance.gui.GuiProxy;\nimport mcjty.deepresonance.items.ModItems;\nimport mcjty.deepresonance.network.DRMessages;\nimport mcjty.deepresonance.radiation.RadiationTickEvent;\nimport mcjty.deepresonance.worldgen.WorldGen;\nimport mcjty.deepresonance.worldgen.WorldGenConfiguration;\nimport mcjty.deepresonance.worldgen.WorldTickHandler;\nimport mcjty.varia.WrenchChecker;\nimport net.minecraftforge.common.config.Configuration;\nimport org.apache.logging.log4j.Level;\n\npublic abstract class CommonProxy {\n\n    private Configuration mainConfig;\n\n    public void preInit(FMLPreInitializationEvent e) {\n        mainConfig = DeepResonance.config;\n        readMainConfig();\n        DRMessages.registerNetworkMessages();\n        DRFluidRegistry.preInitFluids();\n        ModItems.init();\n        ModBlocks.init();\n        ModCrafting.init();\n        WorldGen.init();\n    }\n\n    private void readMainConfig() {\n        Configuration cfg = mainConfig;\n        try {\n            cfg.load();\n            cfg.addCustomCategoryComment(WorldGenConfiguration.CATEGORY_WORLDGEN, \"Configuration for wodlgen\");\n            cfg.addCustomCategoryComment(GeneratorConfiguration.CATEGORY_GENERATOR, \"Configuration for the generator multiblock\");\n            cfg.addCustomCategoryComment(ResonatingCrystalConfiguration.CATEGORY_CRYSTALS, \"Configuration for the crystals\");\n            WorldGenConfiguration.init(cfg);\n            GeneratorConfiguration.init(cfg);\n            ResonatingCrystalConfiguration.init(cfg);\n        } catch (Exception e1) {\n            FMLLog.log(Level.ERROR, e1, \"Problem loading config file!\");\n        } finally {\n            if (mainConfig.hasChanged()) {\n                mainConfig.save();\n            }\n        }\n    }\n\n    public void init(FMLInitializationEvent e) {\n        NetworkRegistry.INSTANCE.registerGuiHandler(DeepResonance.instance, new GuiProxy());\n        FMLCommonHandler.instance().bus().register(WorldTickHandler.instance);\n        FMLCommonHandler.instance().bus().register(new RadiationTickEvent());\n    }\n\n    public void postInit(FMLPostInitializationEvent e) {\n        mainConfig.load();\n        mainConfig.save();\n        mainConfig = null;\n        WrenchChecker.init();\n    }\n\n}\n", "--------------\n// Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.  See License in the project root for license information.\n// ------------------------------------------------------------------------------\n\npackage com.microsoft.graph.models;\n\n\n/**\n * The Enum Meeting Chat Mode.\n*/\npublic enum MeetingChatMode\n{\n    /**\n    * enabled\n    */\n    ENABLED,\n    /**\n    * disabled\n    */\n    DISABLED,\n    /**\n    * limited\n    */\n    LIMITED,\n    /**\n    * unknown Future Value\n    */\n    UNKNOWN_FUTURE_VALUE,\n    /**\n    * For MeetingChatMode values that were not expected from the service\n    */\n    UNEXPECTED_VALUE\n}\n", "(http://boofcv.org).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage boofcv.alg.tracker.tld;\n\nimport boofcv.struct.ImageRectangle;\nimport boofcv.struct.image.ImageGray;\nimport georegression.struct.shapes.Rectangle2D_F64;\nimport org.ddogleg.struct.FastQueue;\nimport org.ddogleg.struct.GrowQueue_F64;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Random;\n\n/**\n * Uses information from the user and from the tracker to update the positive and negative target model for both\n * ferns and templates.\n *\n * @author Peter Abeles\n */\npublic class TldLearning<T extends ImageGray> {\n\n\t// Random number generator\n\tprivate Random rand;\n\n\t// Detects rectangles: Removes candidates don't match the fern descriptors\n\tprivate TldFernClassifier<T> fern;\n\t// Detects rectangles: Removes candidates don't match NCC descriptors\n\tprivate TldTemplateMatching<T> template;\n\t// Detects rectangles: Removes candidates which lack texture\n\tprivate TldVarianceFilter<T> variance;\n\n\tprivate TldDetection<T> detection;\n\n\t// Storage for sorting of results\n\tprivate GrowQueue_F64 storageMetric = new GrowQueue_F64();\n\n\t// regions which need to have their ferns updated\n\tprivate List<ImageRectangle> fernNegative = new ArrayList<>();\n\n\tprivate ImageRectangle targetRegion_I32 = new ImageRectangle();\n\n\tprivate TldHelperFunctions helper = new TldHelperFunctions();\n\tprivate TldParameters config;\n\n\t/**\n\t * Creates and configures learning\n\t */\n\tpublic TldLearning(Random rand, TldParameters config,\n\t\t\t\t\t   TldTemplateMatching<T> template, TldVarianceFilter<T> variance, TldFernClassifier<T> fern,\n\t\t\t\t\t   TldDetection<T> detection ) {\n\t\tthis.rand = rand;\n\t\tthis.config = config;\n\t\tthis.template = template;\n\t\tthis.variance = variance;\n\t\tthis.fern = fern;\n\t\tthis.detection = detection;\n\t}\n\n\t/**\n\t * Select positive and negative examples based on the region the user's initially selected region.  The selected\n\t * region is used as a positive example while all the other regions far away are used as negative examples.\n\t *\n\t * @param targetRegion user selected region\n\t * @param cascadeRegions Set of regions used by the cascade detector\n\t */\n\tpublic void initialLearning( Rectangle2D_F64 targetRegion ,\n\t\t\t\t\t\t\t\t FastQueue<ImageRectangle> cascadeRegions ) {\n\t\tstorageMetric.reset();\n\t\tfernNegative.clear();\n\n\n\t\t// learn the initial descriptor\n\t\tTldHelperFunctions.convertRegion(targetRegion, targetRegion_I32);\n\n\t\t// select the variance the first time using user selected region\n\t\tvariance.selectThreshold(targetRegion_I32);\n\t\t// add positive examples\n\t\ttemplate.addDescriptor(true, targetRegion_I32);\n\t\tfern.learnFernNoise(true, targetRegion_I32);\n\n\t\t// Find all the regions which can be used to learn a negative descriptor\n\t\tfor( int i = 0; i < cascadeRegions.size; i++ ) {\n\t\t\tImageRectangle r = cascadeRegions.get(i);\n\n\t\t\t// see if it passes the variance test\n\t\t\tif( !variance.checkVariance(r) )\n\t\t\t\tcontinue;\n\n\t\t\t// learn features far away from the target region\n\t\t\tdouble overlap = helper.computeOverlap(targetRegion_I32, r);\n\t\t\tif( overlap > config.overlapLower )\n\t\t\t\tcontinue;\n\n\t\t\tfernNegative.add(r);\n\t\t}\n\n\t\t// randomize which regions are used\n//\t\tCollections.shuffle(fernNegative,rand);\n\t\tint N = fernNegative.size();//Math.min(config.numNegativeFerns,fernNegative.size());\n\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\tfern.learnFern(false, fernNegative.get(i) );\n\t\t}\n\n\t\t// run detection algorithm and if there is an ambiguous solution mark it as not target\n\t\tdetection.detectionCascade(cascadeRegions);\n\n\t\tlearnAmbiguousNegative(targetRegion);\n\t}\n\n\n\t/**\n\t * Updates learning using the latest tracking results.\n\t * @param targetRegion Region selected by the fused tracking\n\t */\n\tpublic void updateLearning( Rectangle2D_F64 targetRegion ) {\n\n\t\tstorageMetric.reset();\n\n\t\t// learn the initial descriptor\n\t\tTldHelperFunctions.convertRegion(targetRegion, targetRegion_I32);\n\n\t\ttemplate.addDescriptor(true, targetRegion_I32);\n\t\tfern.learnFernNoise(true, targetRegion_I32);\n\n\t\t// mark only a few of the far away regions as negative.  Marking all of them as negative is\n\t\t// computationally expensive\n\t\tFastQueue<TldRegionFernInfo> ferns = detection.getFernInfo();\n\t\tint N = Math.min(config.numNegativeFerns,ferns.size);\n\t\tfor( int i = 0; i < N; i++ ) {\n\t\t\tint index = rand.nextInt(ferns.size);\n\t\t\tTldRegionFernInfo f = ferns.get(index);\n\n\t\t\t// no need to check variance here since the detector already did it\n\n\t\t\t// learn features far away from the target region\n\t\t\tdouble overlap = helper.computeOverlap(targetRegion_I32, f.r);\n\t\t\tif( overlap > config.overlapLower )\n\t\t\t\tcontinue;\n\n\t\t\tfern.learnFern(false, f.r );\n\t\t}\n\n\t\tlearnAmbiguousNegative(targetRegion);\n\t}\n\n\t/**\n\t * Mark regions which were local maximums and had high confidence as negative.  These regions were\n\t * candidates for the tracker but were not selected\n\t */\n\tprotected void learnAmbiguousNegative(Rectangle2D_F64 targetRegion) {\n\n\t\tTldHelperFunctions.convertRegion(targetRegion, targetRegion_I32);\n\n\t\tif( detection.isSuccess() ) {\n\t\t\tTldRegion best = detection.getBest();\n\n\t\t\t// see if it found the correct solution\n\t\t\tdouble overlap = helper.computeOverlap(best.rect,targetRegion_I32);\n\t\t\tif( overlap <= config.overlapLower ) {\n\t\t\t\ttemplate.addDescriptor(false,best.rect);\n//\t\t\t\tfern.learnFernNoise(false, best.rect );\n\t\t\t}\n\n\t\t\t// mark all ambiguous regions as bad\n\t\t\tList<ImageRectangle> ambiguous = detection.getAmbiguousRegions();\n\t\t\tfor( ImageRectangle r : ambiguous ) {\n\t\t\t\toverlap = helper.computeOverlap(r,targetRegion_I32);\n\t\t\t\tif( overlap <= config.overlapLower ) {\n\t\t\t\t\tfern.learnFernNoise(false, r );\n\t\t\t\t\ttemplate.addDescriptor(false,r);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/**\n * @test\n * @bug 4856966\n * @summary\n * @author Andreas Sterbenz\n * @library ..\n */\n\nimport java.util.*;\n\nimport java.security.*;\n\nimport javax.crypto.*;\nimport javax.crypto.spec.*;\n\npublic class ReinitCipher extends PKCS11Test {\n\n    public static void main(String[] args) throws Exception {\n        main(new ReinitCipher());\n    }\n\n    public void main(Provider p) throws Exception {\n        if (p.getService(\"Cipher\", \"ARCFOUR\") == null) {\n            System.out.println(\"Not supported by provider, skipping\");\n            return;\n        }\n        Random random = new Random();\n        byte[] data1 = new byte[10 * 1024];\n        random.nextBytes(data1);\n        byte[] keyData = new byte[16];\n        random.nextBytes(keyData);\n        SecretKeySpec key = new SecretKeySpec(keyData, \"ARCFOUR\");\n\n        Cipher cipher = Cipher.getInstance(\"ARCFOUR\", p);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipher.update(data1);\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipher.update(data1);\n        cipher.doFinal();\n        cipher.doFinal();\n        cipher.update(data1);\n        cipher.doFinal();\n        cipher.init(Cipher.ENCRYPT_MODE, key);\n        cipher.doFinal();\n\n        System.out.println(\"All tests passed\");\n    }\n}\n", "openapi.actionSystem.AnActionEvent;\nimport com.intellij.openapi.actionSystem.CommonDataKeys;\nimport com.intellij.openapi.actionSystem.DataConstants;\nimport com.intellij.openapi.fileEditor.FileEditorManager;\nimport com.intellij.openapi.project.Project;\nimport com.intellij.openapi.vfs.VirtualFile;\nimport com.wix.rt.build.RTFileUtil;\nimport com.wix.rtk.projectView.RTFile;\nimport com.wix.rt.projectView.RTMergerTreeStructureProvider;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * build react templates action\n * Created by idok on 11/17/14.\n */\npublic class SwitchViewAction extends AnAction {\n\n    @Override\n    public void update(@NotNull AnActionEvent e) {\n        boolean enabled = false;\n        Project project = CommonDataKeys.PROJECT.getData(e.getDataContext());\n        boolean rtEnabled = RTActionUtil.isRTEnabled(project);\n        if (project != null) {\n            final VirtualFile file = (VirtualFile) e.getDataContext().getData(DataConstants.VIRTUAL_FILE);\n            enabled = rtEnabled && (RTFileUtil.isRTFile(file) || BuildTemplateAction.isRtFileContext(e.getDataContext()));\n//            if (file != null) {\n//                e.getPresentation().setText(\"Switch to Code Behind file '\" + file.getName() + '\\'');\n//            }\n        }\n        e.getPresentation().setVisible(enabled);\n    }\n\n    @Override\n    public void actionPerformed(@NotNull final AnActionEvent e) {\n        final Project project = e.getProject();\n        if (project == null) return;\n        final VirtualFile file = (VirtualFile) e.getDataContext().getData(DataConstants.VIRTUAL_FILE);\n\n        if (file == null) {\n            RTFile[] rtFiles = RTFile.DATA_KEY.getData(e.getDataContext());\n            if (rtFiles == null || rtFiles.length == 0) {\n                System.out.println(\"No file for rt compile\");\n                return;\n            }\n            // handle all files\n            for (RTFile rtFile : rtFiles) {\n                FileEditorManager.getInstance(project).openFile(rtFile.getController().getVirtualFile(), true, true);\n            }\n        } else {\n            VirtualFile vfs = file.getParent().findChild(RTMergerTreeStructureProvider.getJSControllerName(file));\n            if (vfs != null) {\n                FileEditorManager.getInstance(project).openFile(vfs, true, true);\n            }\n        }\n    }\n}\n", "mport java.util.Collection;\nimport java.util.List;\n\nimport javax.rmi.PortableRemoteObject;\n\nimport dmytro.kuzenko.core.DatabaseHandler;\nimport dmytro.kuzenko.core.types.Row;\nimport dmytro.kuzenko.core.types.Table;\n\npublic class RemoteDatabaseHandlerImpl extends PortableRemoteObject implements DatabaseHandler {\n    \n    private DatabaseHandler delegate;\n\n    protected RemoteDatabaseHandlerImpl() throws RemoteException {\n        super();\n    }\n\n    @Override\n    public void forDatabaseFolder(String databaseFolder) throws RemoteException {\n        delegate.forDatabaseFolder(databaseFolder);\n    }\n\n    @Override\n    public Table loadTable(String tableName) throws IOException {\n        return delegate.loadTable(tableName);\n    }\n\n    @Override\n    public Collection<Table> listTables() throws IOException {\n        return delegate.listTables();\n    }\n\n    @Override\n    public Table createTable(String tableName, List<String> columnTypes) throws IOException {\n        return delegate.createTable(tableName, columnTypes);\n    }\n\n    @Override\n    public void removeTable(String tableName) throws IOException {\n        delegate.removeTable(tableName);\n    }\n\n    @Override\n    public Row addRow(String tableName, List<String> columnData) throws Exception {\n        return delegate.addRow(tableName, columnData);\n    }\n\n    @Override\n    public List<Row> removeRow(String tableName, List<String> columnData) throws Exception {\n        return delegate.removeRow(tableName, columnData);\n    }\n\n    @Override\n    public void dropDatabase() throws IOException {\n        delegate.dropDatabase();\n    }\n\n    @Override\n    public String getDatabaseName() throws RemoteException {\n        return delegate.getDatabaseName();\n    }\n\n    @Override\n    public List<Row> loadTableData(String tableName) throws IOException {\n        return delegate.loadTableData(tableName);\n    }\n\n    public void setDelegate(DatabaseHandler delegate) {\n        this.delegate = delegate;\n    }\n\n\t@Override\n\tpublic Table descartTable(String tableName1, String tableName2) throws Exception {\n\t\treturn delegate.descartTable(tableName1, tableName2);\n\t}\n}\n", "java.sql.ResultSet;\r\nimport java.sql.SQLException;\r\nimport java.sql.Statement;\r\n\r\n\r\nimport io.avengers.domain.Hero;\r\nimport io.avengers.domain.Sex;\r\n\r\npublic class HeroDataDao extends MarvelDao{\r\n\r\n\tpublic Hero findHeroData(String term) throws SQLException {\r\n\r\n\t\tString query = \"SELECT h.id, h.name, h.sex, h.likes, h.dislikes, h.picture, h.abilities, h.history, irl.name as irl, t.name as team FROM heroes h INNER JOIN irl ON h.id=irl.hero_id LEFT JOIN team_hero th ON h.id=th.hero_id  LEFT JOIN team t ON t.id=th.team_id WHERE h.name LIKE ?\";\r\n\r\n\t\t// port 3306, no password\r\n\t\tConnection connect = connectToMySql();\r\n\r\n\t\tPreparedStatement statement = connect.prepareStatement(query);\r\n\t\tstatement.setString(1,'%'+term+'%');\r\n\t\r\n\t\tResultSet resultSet = statement.executeQuery();\r\n\r\n\t\tHero h = new Hero();\r\n\t\twhile (resultSet.next()) {\r\n\r\n\t\t\ttry {\r\n\t\t\t\tint id = resultSet.getInt(\"id\");\r\n\t\t\t\tString name = resultSet.getString(\"name\");\r\n\t\t\t\r\n\t\t\t\tString sSex = resultSet.getString(\"sex\");\r\n\t\t\t\tLong likes = resultSet.getLong(\"likes\");\r\n\t\t\t\tLong dislikes = resultSet.getLong(\"dislikes\");\r\n\t\t\t\tbyte[] picture = resultSet.getBytes(\"picture\");\r\n\t\t\t\tString abilities = resultSet.getString(\"abilities\");\r\n\t\t\t\tString history = resultSet.getString(\"history\");\r\n\t\t\t\tString team = resultSet.getString(\"team\");\r\n\t\t\t\tString irl = resultSet.getString(\"irl\");\r\n\t\t\t\t\r\n\r\n\t\t\t\tHero h1 = new Hero(id, name, Sex.O, likes, dislikes, picture, abilities, history);\r\n\t\t\t\th1.setIrl(irl);\r\n\t\t\t\th1.setTeam(team);\r\n\t\t\t\th = h1;\r\n\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tthrow new IllegalStateException(\"Database has been compromised: \" + e.getMessage());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t\tconnect.close();\r\n\t\treturn h;\r\n\r\n\t}\r\n\r\n}\r\n", "ationLogger;\nimport io.github.behoston.meloooncensor.config.Configuration;\nimport org.bukkit.ChatColor;\nimport org.bukkit.entity.Player;\nimport org.bukkit.event.EventHandler;\nimport org.bukkit.event.Listener;\nimport org.bukkit.event.player.AsyncPlayerChatEvent;\n\nimport java.util.HashMap;\n\npublic class ChatEventListener implements Listener {\n\n    Configuration config;\n    ViolationLogger logger;\n\n    public ChatEventListener (Configuration config, ViolationLogger logger) {\n        this.config = config;\n        this.logger = logger;\n    }\n\n    @EventHandler\n    public void onPlayerChat (AsyncPlayerChatEvent event) {\n        if (config.isEnabled()) {\n            Player player = event.getPlayer();\n            String message = event.getMessage();\n\n            if ( ! config.allowBypass(player)) {\n                if (config.getFilter().violatesPolicy(message)) {\n                    String censoredMessage = config.getFilter().censorMessage(message);\n\n                    if (censoredMessage == null) {\n                        event.setCancelled(true);\n                    } else {\n                        event.setMessage(censoredMessage);\n                    }\n\n                    HashMap<String, String> values = new HashMap<>();\n                    values.put(\"player\", player.getName());\n\n                    player.sendMessage(ChatColor.GRAY + config.getFormattedMessage(values));\n\n                    if (logger != null) {\n                        // The check above is in case the log file failed to create\n                        logger.log(player, message);\n                    }\n                }\n            }\n        }\n    }\n\n}\n", "is template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage com.ikeengine.test;\r\n\r\nimport com.ikeengine.component.TestComponent;\r\nimport com.ikeengine.core.AbstractGame;\r\nimport com.ikeengine.debug.MessageActivator;\r\nimport com.ikeengine.debug.MessageBus;\r\nimport com.ikeengine.input.Key;\r\nimport com.ikeengine.scene.Scene;\r\nimport com.ikeengine.scene.SceneManager;\r\nimport com.ikeengine.util.Loader;\r\n\r\n/**\r\n *\r\n * @author Jonathan Elue\r\n */\r\npublic class Game extends AbstractGame {\r\n\r\n    /**\r\n     * @param args the command line arguments\r\n     */\r\n    public static void main(String[] args) {\r\n        Game g = new Game(\"IkeEngine Test\", 640, 480, 2, true);\r\n        g.start();\r\n    }\r\n\r\n    public Game(String title, int width, int height, int threadCount, boolean debug) {\r\n        super(title, width, height, threadCount, debug);\r\n    }\r\n\r\n    @Override\r\n    public void init(Loader loader, SceneManager s, MessageBus bus) {\r\n        Scene scene = new Scene(bus);\r\n\r\n        int test = scene.generateGameObject();\r\n        scene.addComponent(new TestComponent(test,\r\n                new MessageActivator(new String[]{\"KEY_INPUT\", \"REPEAT\"}, new Object[] {Key.GLFW_SPACE, null}, new int[][]{{TestComponent.ACTION}, {TestComponent.REPEAT}})));\r\n\r\n        s.addScene(\"Test Scene\", scene);\r\n    }\r\n\r\n}\r\n", " free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n *  The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n\n * Except as contained in this notice, the name of OVH and or its trademarks\n * (and among others RunAbove) shall not be used in advertising or otherwise to\n * promote the sale, use or other dealings in this Software without prior\n * written authorization from OVH.\n * Unit test for run above api\n * \n *\n * storage container object\n *\n */\n/**\n * The Class StorageContainerObject.\n */\npublic class StorageContainerObject {\n\n\t/** File content type. */\n\tprivate String contentType;\n\n\t/** Last modification date. */\n\tprivate String lastModified;\n\n\t/** File name. */\n\tprivate String name;\n\n\t/**   File size in bytes. */\n\tprivate long size;\n\n\t/**\n\t * File content type.\n\t *\n\t * @return the content type\n\t */\n\tpublic String getContentType() {\n\t\treturn contentType;\n\t}\n\n\t/**\n\t * File content type.\n\t *\n\t * @param contentType the new content type\n\t */\n\tpublic void setContentType(String contentType) {\n\t\tthis.contentType = contentType;\n\t}\n\n\t/**\n\t * Last modification date.\n\t *\n\t * @return the last modified\n\t */\n\tpublic String getLastModified() {\n\t\treturn lastModified;\n\t}\n\n\t/**\n\t * Last modification date.\n\t *\n\t * @param lastModified the new last modified\n\t */\n\tpublic void setLastModified(String lastModified) {\n\t\tthis.lastModified = lastModified;\n\t}\n\n\t/**\n\t * File name.\n\t *\n\t * @return the name\n\t */\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t/**\n\t * File name.\n\t *\n\t * @param name the new name\n\t */\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * File size in bytes.\n\t *\n\t * @return the size\n\t */\n\tpublic long getSize() {\n\t\treturn size;\n\t}\n\n\t/**\n\t * File size in bytes.\n\t *\n\t * @param size the new size\n\t */\n\tpublic void setSize(long size) {\n\t\tthis.size = size;\n\t}\n\n}", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.data.processor.data.entity;\n\nimport com.google.common.collect.ImmutableMap;\nimport org.spongepowered.api.data.DataContainer;\nimport org.spongepowered.api.data.DataHolder;\nimport org.spongepowered.api.data.DataTransactionResult;\nimport org.spongepowered.api.data.key.Key;\nimport org.spongepowered.api.data.key.Keys;\nimport org.spongepowered.api.data.manipulator.immutable.entity.ImmutableVehicleData;\nimport org.spongepowered.api.data.manipulator.mutable.entity.VehicleData;\nimport org.spongepowered.api.entity.Entity;\nimport org.spongepowered.api.entity.EntitySnapshot;\nimport org.spongepowered.api.world.World;\nimport org.spongepowered.common.SpongeImpl;\nimport org.spongepowered.common.data.manipulator.mutable.entity.SpongeVehicleData;\nimport org.spongepowered.common.data.processor.common.AbstractEntityDataProcessor;\nimport org.spongepowered.common.data.util.EntityUtil;\nimport org.spongepowered.common.data.value.immutable.ImmutableSpongeValue;\nimport org.spongepowered.common.data.value.immutable.common.ImmutableSpongeEntityValue;\n\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.UUID;\n\nimport javax.annotation.Nullable;\n\npublic class VehicleDataProcessor extends AbstractEntityDataProcessor<net.minecraft.entity.Entity, VehicleData, ImmutableVehicleData> {\n\n    public VehicleDataProcessor() {\n        super(net.minecraft.entity.Entity.class);\n    }\n\n    @Override\n    protected boolean doesDataExist(net.minecraft.entity.Entity entity) {\n        return entity.isRiding();\n    }\n\n    @Override\n    protected boolean set(net.minecraft.entity.Entity entity, Map<Key<?>, Object> keyValues) {\n        final EntitySnapshot vehicle = (EntitySnapshot) keyValues.get(Keys.VEHICLE);\n        Optional<Entity> entity1 = vehicle.restore();\n        return EntityUtil.setVehicle(entity, (net.minecraft.entity.Entity) entity1.orElse(null));\n    }\n\n    @Override\n    protected Map<Key<?>, ?> getValues(net.minecraft.entity.Entity entity) {\n        return ImmutableMap.of(Keys.VEHICLE, ((Entity) entity.ridingEntity).createSnapshot(), Keys.BASE_VEHICLE, EntityUtil.getBaseVehicle(entity));\n    }\n\n    @Override\n    public Optional<VehicleData> fill(DataContainer container, final VehicleData vehicleData) {\n        if (!container.contains(Keys.VEHICLE.getQuery(), Keys.BASE_VEHICLE.getQuery())) {\n            return Optional.empty();\n        } else {\n            EntitySnapshot vehicle = container.getSerializable(Keys.VEHICLE.getQuery(), EntitySnapshot.class).get();\n            EntitySnapshot baseVehicle = container.getSerializable(Keys.BASE_VEHICLE.getQuery(), EntitySnapshot.class).get();\n            return Optional.of(vehicleData.set(Keys.VEHICLE, vehicle).set(Keys.BASE_VEHICLE, baseVehicle));\n        }\n    }\n\n    @Override\n    public DataTransactionResult remove(DataHolder dataHolder) {\n        if (supports(dataHolder)) {\n            net.minecraft.entity.Entity entity = ((net.minecraft.entity.Entity) dataHolder);\n            if (entity.isRiding()) {\n                Entity ridingEntity = (Entity) entity.ridingEntity;\n                entity.mountEntity(null);\n                return DataTransactionResult.successResult(new ImmutableSpongeValue<>(Keys.VEHICLE, ridingEntity.createSnapshot()));\n            }\n            return DataTransactionResult.builder().result(DataTransactionResult.Type.SUCCESS).build();\n        } else {\n            return DataTransactionResult.failNoData();\n        }\n    }\n\n    @Override\n    protected VehicleData createManipulator() {\n        return new SpongeVehicleData();\n    }\n}\n", "e Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.jk.util.validation.builtin;\n\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport com.jk.util.validation.Problems;\nimport com.jk.util.validation.Validator;\n\n// TODO: Auto-generated Javadoc\n/**\n * The Class UrlValidator.\n *\n * @author Tim Boudreau\n */\nclass UrlValidator implements Validator<String> {\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * com.fs.commons.desktop.validation.Validator#validate(com.fs.commons.desktop.\n\t * validation.Problems, java.lang.String, java.lang.Object)\n\t */\n\t@Override\n\tpublic boolean validate(final Problems problems, final String compName, final String model) {\n\t\ttry {\n\t\t\tfinal URL url = new URL(model);\n\t\t\t// java.net.url does not require US-ASCII host names,\n\t\t\t// but the spec does\n\t\t\tfinal String host = url.getHost();\n\t\t\tif (!\"\".equals(host)) { // NOI18N\n\t\t\t\treturn new ValidHostNameOrIPValidator(true).validate(problems, compName, host);\n\t\t\t}\n\t\t\tfinal String protocol = url.getProtocol();\n\t\t\tif (\"mailto\".equals(protocol)) { // NOI18N\n\t\t\t\tString emailAddress = url.toString().substring(\"mailto:\".length()); // NOI18N\n\t\t\t\temailAddress = emailAddress == null ? \"\" : emailAddress;\n\t\t\t\treturn new EmailAddressValidator().validate(problems, compName, emailAddress);\n\t\t\t}\n\t\t\treturn true;\n\t\t} catch (final MalformedURLException e) {\n\t\t\tfinal String problem = ValidationBundle.getMessage(UrlValidator.class, \"URL_NOT_VALID\", model); // NOI18N\n\t\t\tproblems.add(problem);\n\t\t\treturn false;\n\t\t}\n\t}\n\n}\n", "ftware Foundation (ASF) under one or more\n   contributor license agreements.  See the NOTICE file distributed with\n   this work for additional information regarding copyright ownership.\n   The ASF licenses this file to You under the Apache License, Version 2.0\n   (the \"License\"); you may not use this file except in compliance with\n   the License.  You may obtain a copy of the License at\n\n       http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n==================================================================== */\n\npackage org.apache.poi.hslf.record;\n\nimport org.apache.poi.hslf.record.SlideAtom.*;\n\nimport junit.framework.TestCase;\nimport java.io.ByteArrayOutputStream;\n\n/**\n * Tests that SlideAtom works properly\n *\n * @author Nick Burch (nick at torchbox dot com)\n */\npublic final class TestSlideAtom extends TestCase {\n\t// From a real file\n\tprivate byte[] data_a = new byte[] { 1, 0, 0xEF-256, 3, 0x18, 0, 0, 0,\n\t\t0, 0, 0, 0, 0x0F, 0x10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x80-256,\n\t\t0, 1, 0, 0, 7, 0, 0x0C, 0x30 };\n\n    public void testRecordType() {\n\t\tSlideAtom sa = new SlideAtom(data_a, 0, data_a.length);\n\t\tassertEquals(1007l, sa.getRecordType());\n\t}\n\tpublic void testFlags() {\n\t\tSlideAtom sa = new SlideAtom(data_a, 0, data_a.length);\n\n\t\t// First 12 bytes are a SSlideLayoutAtom, checked elsewhere\n\n\t\t// Check the IDs\n\t\tassertEquals(0x80000000, sa.getMasterID());\n\t\tassertEquals(256, sa.getNotesID());\n\n\t\t// Check the flags\n\t\tassertEquals(true, sa.getFollowMasterObjects());\n\t\tassertEquals(true, sa.getFollowMasterScheme());\n\t\tassertEquals(true, sa.getFollowMasterBackground());\n\t}\n\tpublic void testSSlideLayoutAtom() {\n\t\tSlideAtom sa = new SlideAtom(data_a, 0, data_a.length);\n\t\tSSlideLayoutAtom ssla = sa.getSSlideLayoutAtom();\n\n\t\tassertEquals(0, ssla.getGeometryType());\n\n\t\t// Should also check the placehold IDs at some point\n\t}\n\n\tpublic void testWrite() throws Exception {\n\t\tSlideAtom sa = new SlideAtom(data_a, 0, data_a.length);\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\tsa.writeOut(baos);\n\t\tbyte[] b = baos.toByteArray();\n\n\t\tassertEquals(data_a.length, b.length);\n\t\tfor(int i=0; i<data_a.length; i++) {\n\t\t\tassertEquals(data_a[i],b[i]);\n\t\t}\n\t}\n}\n", "ository;\nimport org.springframework.stereotype.Repository;\n\n@Repository\npublic interface SchoolClassRepository extends JpaRepository<SchoolClass, Long>{\n\n}\n", ".JSONObject;\nimport org.parceler.Parcel;\n\n/**\n * Created by acamara on 6/26/17.\n */\n\n@Parcel\npublic class User {\n    // list attributes\n    public String name;\n    public long uid;\n    public String screenName;\n    public String profileImageUrl;\n\n    public User(){\n\n    }\n\n    //deserialize the JSON\n    public static User fromJSON(JSONObject json) throws JSONException{\n        User user = new User();\n\n        // extract and fill values\n        user.name = json.getString(\"name\");\n        user.uid = json.getLong(\"id\");\n        user.screenName = \"@\" + json.getString(\"screen_name\");\n        user.profileImageUrl = json.getString(\"profile_image_url\");\n\n        return user;\n    }\n}\n", "ationHelper.defaultIgniteCfg;\nimport static java.util.stream.Collectors.toList;\n\nimport java.util.Collection;\nimport java.util.stream.IntStream;\n\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.Ignition;\nimport org.apache.ignite.lang.IgniteCallable;\n\n/**\n * \n * @author Gaurav Rai Mazra {@link https://lineofcode.in}\n *\n */\npublic class IgniteComputeExample {\n\tstatic class NumberMultiplier implements IgniteCallable<Integer> {\n\t\tprivate static final long serialVersionUID = 7645655734200971503L;\n\t\tprivate Integer number;\n\n\t\tpublic NumberMultiplier(Integer number) {\n\t\t\tthis.number = number;\n\t\t}\n\t\t\n\t\t@Override\n\t\tpublic Integer call() throws Exception {\n\t\t\treturn number * number;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tCollection<IgniteCallable<Integer>> jobs = IntStream.range(1, 11)\n\t\t\t\t.mapToObj(NumberMultiplier::new).collect(toList());\n\n\t\ttry (Ignite ignite = Ignition.start(defaultIgniteCfg(\"compute-grid\"))) {\n\t\t\tignite.compute().call(jobs).forEach(System.out::println);\n\t\t}\n\t}\n}\n", "rvlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.apache.commons.lang3.StringUtils;\nimport org.apache.log4j.Logger;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.ModelMap;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport twitter4j.Twitter;\nimport twitter4j.TwitterException;\nimport twitter4j.TwitterFactory;\nimport twitter4j.User;\nimport twitter4j.auth.AccessToken;\nimport twitter4j.auth.RequestToken;\n\n\n@Controller\n@RequestMapping(\"/twitterConnect\")\npublic class twitterConnectController {\n\t\n\tprivate static final Logger logger = Logger.getLogger(v4RegisterWithTwitterConnectController.class);\n\t\n\t@RequestMapping(method = RequestMethod.GET,params=\"start\")\n\tpublic void twconn(HttpServletRequest servletRequest, HttpServletResponse servletResponse) {\n\t\t\n\t\tString rurl = servletRequest.getParameter(\"rurl\");\n\t\t\n\t\tString callbackURL = \"/twitterConnect.htm\";\n\t\t\t\t\n\t\tTwitter twitter = new TwitterFactory().getInstance();\n\t\t\n\t\ttry {\n\t\t\t\n\t    \t\tRequestToken requestToken = twitter.getOAuthRequestToken(callbackURL.toString());\n\t\n\t    \t\tCommonCookie.add(servletResponse, \"twitter4j\", requestToken.getToken()+\":\"+requestToken.getTokenSecret(), \"domain.com\", \"/\", -1);            \n\t    \t\tCommonCookie.add(servletResponse, \"newregrurl\", rurl,\"domain.com\", \"/\", -1);\n\t    \n\t\t\tservletResponse.sendRedirect(requestToken.getAuthenticationURL());\n\t\t\t\n\t\t}catch (IOException e) {\n\t\t\tlogger.error(\"IOException.\", e);\t\n\t        } catch (TwitterException e) {\n\t        \tlogger.error(\"TwitterException.\", e);\n\t        }\n\t\t\n\t}\n\t\n\t@RequestMapping(method = RequestMethod.GET)\n\tpublic String get(HttpServletRequest servletRequest, HttpServletResponse servletResponse, ModelMap model) {\n\t\t\n\t\t// twitter4j\n\t\tString twitter4jtoken=\"\";\n\t\tString twitter4jtokenSecret=\"\";\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tCookie cookie = CommonCookie.get(servletRequest, \"twitter4j\");\n\t\t\tString twitter4jRequestToken = cookie.getValue();\n\t\t\t\n\t\t\tif( !twitter4jRequestToken.equals(\"\") ){\n\t\t\t\tString[] cc= twitter4jRequestToken.split(\":\");\n\t\t\t\ttwitter4jtoken =cc[0];\n\t\t\t\ttwitter4jtokenSecret = cc[1];\n\t\t\t}\n\t\t\tCommonCookie.add(servletResponse, \"twitter4j\", \"0\" , \"domain.com\", \"/\", -1);\n\t\t} catch (Exception ex) {}\n\n\t\t\n\t\tString verifier = servletRequest.getParameter(\"oauth_verifier\");\n\t\tString oauth_token = servletRequest.getParameter(\"oauth_token\");\n\t\t\n\t\tTwitter twitter = new TwitterFactory().getInstance();\n\t\t\n\t\ttry {\n\t\t\t\n\t\t\tAccessToken accessToken = new AccessToken(twitter4jtoken, twitter4jtokenSecret);\n\t\t\ttwitter.setOAuthAccessToken(accessToken);            \n\t\t\ttwitter.getOAuthAccessToken(verifier);\n            \n        \t} catch (TwitterException e) {\n        \t\tlogger.error(\"TwitterException\", e);\n        \t}\n\t\t\t\t\n\t\tUser user = null;\n\t\ttry {\n\t\t\tuser = twitter.verifyCredentials();\n\t\t} catch (TwitterException e1) {\n\t\t\tlogger.error(\"TwitterException user info\", e1);\n\t\t}\n\t\t\t\t\t\t\t\n\t\treturn \"html\";\n\t\t\n\t}\t\n\t\n\t\n\t\n}\n", "on.model.Person;\nimport cz.cvut.kbss.jopa.model.EntityManager;\nimport cz.cvut.kbss.jopa.model.EntityManagerFactory;\nimport cz.cvut.kbss.jopa.model.metamodel.Metamodel;\nimport org.junit.jupiter.api.Test;\n\nimport java.net.URI;\nimport java.util.concurrent.CountDownLatch;\n\nimport static org.junit.jupiter.api.Assertions.assertSame;\nimport static org.mockito.ArgumentMatchers.any;\nimport static org.mockito.Mockito.*;\n\nclass DelegatingEntityManagerTest {\n\n    private final DelegatingEntityManager sut = new DelegatingEntityManager();\n\n    @Test\n    void delegatesCallsToCurrentEntityManager() {\n        final EntityManager em = mock(EntityManager.class);\n        sut.setLocalTransaction(new JopaTransactionDefinition(em));\n\n        final Person instance = new Person();\n        sut.persist(instance);\n        verify(em).persist(instance);\n    }\n\n    @Test\n    void findOpensNonTransactionalManagerToPerformOperation() {\n        final EntityManager em = mock(EntityManager.class);\n        final EntityManagerFactory emfMock = mock(EntityManagerFactory.class);\n        when(emfMock.createEntityManager()).thenReturn(em);\n        final URI uri = URI.create(\"http://www.example.org/PersonOne\");\n        final Person instance = new Person();\n        when(em.find(Person.class, uri)).thenReturn(instance);\n        sut.setEntityManagerProvider(new SinglePUEntityManagerProvider(emfMock));\n\n        final Person p = sut.find(Person.class, uri);\n        assertSame(instance, p);\n        verify(em).close();\n    }\n\n    @Test\n    void getEntityManagerFactoryDoesNotRequireTransactionalEntityManager() {\n        final EntityManagerProvider provider = mock(EntityManagerProvider.class);\n        sut.setEntityManagerProvider(provider);\n        sut.getEntityManagerFactory();\n        verify(provider).getEntityManagerFactory();\n        verify(provider, never()).createEntityManager();\n    }\n\n    @Test\n    void getMetamodelDoesNotRequireTransactionalEntityManager() {\n        final Metamodel metamodelMock = mock(Metamodel.class);\n        final EntityManagerFactory emfMock = mock(EntityManagerFactory.class);\n        when(emfMock.getMetamodel()).thenReturn(metamodelMock);\n        final EntityManagerProvider provider = mock(EntityManagerProvider.class);\n        when(provider.getEntityManagerFactory()).thenReturn(emfMock);\n        sut.setEntityManagerProvider(provider);\n        final Metamodel result = sut.getMetamodel();\n        assertSame(metamodelMock, result);\n        verify(provider).getEntityManagerFactory();\n        verify(provider, never()).createEntityManager();\n    }\n\n    @Test\n    void twoThreadsWorkWithDifferentTransactionManagers() throws Exception {\n        final EntityManager emOne = mock(EntityManager.class);\n        final EntityManager emTwo = mock(EntityManager.class);\n        final CountDownLatch latch = new CountDownLatch(2);\n        final Thread tOne = new Thread(new TestTransaction(emOne, latch));\n        final Thread tTwo = new Thread(new TestTransaction(emTwo, latch));\n        tOne.start();\n        tTwo.start();\n        latch.await();\n\n        verify(emOne).persist(any());\n        verify(emOne).contains(any());\n        verify(emTwo).persist(any());\n        verify(emTwo).contains(any());\n    }\n\n    @Test\n    void getReferenceDelegatesCallToNonTransactionalEntityManager() {\n        final EntityManager em = mock(EntityManager.class);\n        final EntityManagerFactory emfMock = mock(EntityManagerFactory.class);\n        when(emfMock.createEntityManager()).thenReturn(em);\n        final URI uri = URI.create(\"http://www.example.org/PersonOne\");\n        final Person instance = new Person();\n        when(em.getReference(Person.class, uri)).thenReturn(instance);\n        sut.setEntityManagerProvider(new SinglePUEntityManagerProvider(emfMock));\n        sut.setLocalTransaction(new JopaTransactionDefinition(em));\n\n        final Person p = sut.getReference(Person.class, uri);\n        assertSame(instance, p);\n    }\n\n    private class TestTransaction implements Runnable {\n\n        private EntityManager em;\n        private CountDownLatch countDown;\n\n        TestTransaction(EntityManager em, CountDownLatch countDown) {\n            this.em = em;\n            this.countDown = countDown;\n        }\n\n        @Override\n        public void run() {\n            DelegatingEntityManagerTest.this.sut.setLocalTransaction(new JopaTransactionDefinition(em));\n            DelegatingEntityManagerTest.this.sut.persist(new Person());\n            DelegatingEntityManagerTest.this.sut.contains(\"Test\");\n            countDown.countDown();\n        }\n    }\n}\n", "t.exceptions.NBTException;\nimport com.hackhalo2.libhack.nbt.stream.NBTInputStream;\nimport com.hackhalo2.libhack.nbt.stream.NBTOutputStream;\nimport com.hackhalo2.libhack.util.IOHandler;\n\npublic final class TagString extends AbstractTag {\n\t\n\tprivate String value;\n\n\tpublic TagString(String name, String value) {\n\t\tsuper(name, TagType.STRING.getID());\n\t\tthis.value = value;\n\t}\n\n\tpublic TagString(NBTInputStream in, boolean anonymous)\n\t\t\tthrows NBTException, IOException {\n\t\tsuper(in, anonymous, TagType.STRING.getID());\n\t\t\n\t\tint size = in.readShort();\n\t\t\n\t\tbyte[] data = new byte[size];\n\t\tin.readFully(data);\n\t\t\n\t\tthis.value = new String(data, IOHandler.UTF8);\n\t}\n\t\n\tpublic String getValue() {\n\t\treturn this.value;\n\t}\n\t\n\tpublic void setValue(String value) {\n\t\tthis.value = value;\n\t}\n\t\n\t@Override\n\tpublic void writeNBT(NBTOutputStream out, boolean anonymous)\n\t\t\tthrows NBTException, IOException {\n\t\tsuper.writeNBT(out, anonymous);\n\t\t\n\t\tbyte[] outputBytes = this.value.getBytes(IOHandler.UTF8);\n\t\tout.writeShort(outputBytes.length);\n\t\t\n\t\tout.write(outputBytes);\n\t}\n\n}\n", "jmlab.twitter.util.QueryHelper;\r\nimport org.nkjmlab.twitter.util.TwitterFactory;\r\nimport org.nkjmlab.util.io.FileUtils;\r\n\r\nimport twitter4j.Query;\r\nimport twitter4j.Twitter;\r\n\r\npublic class TweetsRecorder {\r\n\r\n\tprotected static org.apache.logging.log4j.Logger log = org.apache.logging.log4j.LogManager\r\n\t\t\t.getLogger();\r\n\r\n\tpublic static void main(String[] args) {\r\n\r\n\t\tTwitter twitter = TwitterFactory.getSingleton();\r\n\t\tQuery query = QueryHelper.create(\"\u4eba\u8eab\u4e8b\u6545\");\r\n\r\n\t\tTweetsDatabase tweetsDatabase = new TweetsDatabase(\r\n\t\t\t\tFileUtils.getFileInUserDirectory(\"h2-db/tweets\"));\r\n\r\n\t\tString tableName = \"TWEETS\";\r\n\r\n\t\ttweetsDatabase.crawl(tableName, query, twitter);\r\n\r\n\t}\r\n\r\n}\r\n", "itySystem;\nimport com.oneponygames.frozen.base.eventsystem.events.GameEvent;\n\n/**\n * Created by Icewind on 23.01.2017.\n */\npublic abstract class EntitySystemEvent implements GameEvent {\n\n    private final EntitySystem system;\n\n    public EntitySystemEvent(EntitySystem system) {\n        this.system = system;\n    }\n\n    public EntitySystem getSystem() {\n        return system;\n    }\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * @test\n * @bug 6327342\n * @summary Try to poll a DelayQueue with only unexpired elements\n * @author Martin Buchholz\n */\n\nimport java.util.concurrent.*;\n\npublic class PollUnexpired {\n    private static class Godot implements Delayed {\n        public long getDelay(TimeUnit unit) {return Long.MAX_VALUE;}\n        public int compareTo(Delayed other) {return 0;}\n    }\n\n    private static void realMain(String[] args) throws Throwable {\n        DelayQueue<Godot> q = new DelayQueue<Godot>();\n        for (int i = 0; i < 3; i++) {\n            equal(q.size(), i);\n            equal(q.poll(), null);\n            equal(q.size(), i);\n            equal(q.poll(100, TimeUnit.MILLISECONDS), null);\n            equal(q.size(), i);\n            q.add(new Godot());\n        }\n    }\n\n    //--------------------- Infrastructure ---------------------------\n    static volatile int passed = 0, failed = 0;\n    static void pass() {passed++;}\n    static void fail() {failed++; Thread.dumpStack();}\n    static void fail(String msg) {System.out.println(msg); fail();}\n    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n    static void check(boolean cond) {if (cond) pass(); else fail();}\n    static void equal(Object x, Object y) {\n        if (x == null ? y == null : x.equals(y)) pass();\n        else fail(x + \" not equal to \" + y);}\n    public static void main(String[] args) throws Throwable {\n        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n}\n", "tion, v2.2.4 \r\n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \r\n// Any modifications to this file will be lost upon recompilation of the source schema. \r\n// Generated on: 2013.03.26 at 05:36:33 PM IST \r\n//\r\n\r\n\r\npackage com.emc.cto.ridagent.rid.jaxb;\r\n\r\nimport javax.xml.bind.annotation.XmlAccessType;\r\nimport javax.xml.bind.annotation.XmlAccessorType;\r\nimport javax.xml.bind.annotation.XmlAttribute;\r\nimport javax.xml.bind.annotation.XmlRootElement;\r\nimport javax.xml.bind.annotation.XmlType;\r\nimport javax.xml.bind.annotation.adapters.CollapsedStringAdapter;\r\nimport javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\r\n\r\n\r\n/**\r\n * <p>Java class for anonymous complex type.\r\n * \r\n * <p>The following schema fragment specifies the expected content contained within this class.\r\n * \r\n * <pre>\r\n * &lt;complexType>\r\n *   &lt;complexContent>\r\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\r\n *       &lt;attribute name=\"type\" use=\"required\">\r\n *         &lt;simpleType>\r\n *           &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}NMTOKEN\">\r\n *             &lt;whiteSpace value=\"collapse\"/>\r\n *             &lt;enumeration value=\"Attack\"/>\r\n *             &lt;enumeration value=\"Network\"/>\r\n *             &lt;enumeration value=\"Content\"/>\r\n *             &lt;enumeration value=\"DataWithHandlingRequirements\"/>\r\n *             &lt;enumeration value=\"AudienceRestriction\"/>\r\n *             &lt;enumeration value=\"Other\"/>\r\n *             &lt;enumeration value=\"ext-value\"/>\r\n *           &lt;/restriction>\r\n *         &lt;/simpleType>\r\n *       &lt;/attribute>\r\n *       &lt;attribute name=\"ext-type\" type=\"{http://www.w3.org/2001/XMLSchema}string\" />\r\n *     &lt;/restriction>\r\n *   &lt;/complexContent>\r\n * &lt;/complexType>\r\n * </pre>\r\n * \r\n * \r\n */\r\n@XmlAccessorType(XmlAccessType.FIELD)\r\n@XmlType(name = \"\")\r\n@XmlRootElement(name = \"TrafficType\", namespace = \"urn:ietf:params:xml:ns:iodef-rid-2.0\")\r\npublic class TrafficType {\r\n\r\n    @XmlAttribute(name = \"type\", required = true)\r\n    @XmlJavaTypeAdapter(CollapsedStringAdapter.class)\r\n    protected String type;\r\n    @XmlAttribute(name = \"ext-type\")\r\n    protected String extType;\r\n\r\n    /**\r\n     * Gets the value of the type property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getType() {\r\n        return type;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the type property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setType(String value) {\r\n        this.type = value;\r\n    }\r\n\r\n    /**\r\n     * Gets the value of the extType property.\r\n     * \r\n     * @return\r\n     *     possible object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public String getExtType() {\r\n        return extType;\r\n    }\r\n\r\n    /**\r\n     * Sets the value of the extType property.\r\n     * \r\n     * @param value\r\n     *     allowed object is\r\n     *     {@link String }\r\n     *     \r\n     */\r\n    public void setExtType(String value) {\r\n        this.extType = value;\r\n    }\r\n\r\n}\r\n", "ic class DriveCommand extends MMCommand {\n\tprivate final boolean autopilot;\n\tprivate double left;\n\tprivate double right;\n\tprivate double speed;\n\tprivate final double time;\n\n\t/**\n\t * Drives the robot straight, using the autopilot gyro stabilization.\n\t * @param speed desired speed\n\t * @param time  timeout, in seconds\n\t */\n\tpublic DriveCommand(double speed, double time) {\n\t\tautopilot = true;\n\t\tthis.speed = speed;\n\t\tthis.time = time;\n\t\trequires(Robot.driveTrain);\n\t}\n\n\t/**\n\t * Drives the robot, running the left and right motors independently. Gyro stabilization and acceleration curve\n\t * aren't utilized.\n\t * @param left  left motor speed\n\t * @param right right motor speed\n\t * @param time  timeout, in seconds\n\t */\n\tpublic DriveCommand(double left, double right, double time) {\n\t\tautopilot = false;\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.time = time;\n\t}\n\n\t// Called just before this Command runs the first time\n\tprotected void initialize() {\n\t\t/*if (gear) {\n\t\t\tsetTimeout(0.25);\n\t\t\tRobot.driveTrain.setAutopilot(0.4);\n\t\t} else {\n\t\t\tsetTimeout(2);\n\t\t\tRobot.driveTrain.setAutopilot(-0.6);\n\t\t}*/\n\t\ttimeout(time);\n\t\tif (autopilot) {\n\t\t\t//Robot.driveTrain.setAutopilot(speed);\n\t\t\tRobot.driveTrain.takeControl(this);\n\t\t\tRobot.driveTrain.drive(speed); // TODO: change to go back to using autopilot\n\t\t} else {\n\t\t\tRobot.driveTrain.takeControl(this);\n\t\t\tRobot.driveTrain.drive(left, right);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resume() {\n\t\tSystem.out.println(\"Resuming: \" + this);\n\t\tif (autopilot) {\n\t\t\tRobot.driveTrain.drive(speed); // TODO: remove\n\t\t} else {\n\t\t\tRobot.driveTrain.drive(left, right);\n\t\t}\n\t}\n\n\tprotected boolean isFinished() {\n\t\treturn super.isFinished() || !Robot.driveTrain.controlledBy(this);\n\t}\n}\n", "btaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\npackage org.capcaval.c3.sample.tutorial02.hellomachine;\r\n\r\nimport org.capcaval.c3.component.ComponentService;\n\r\n\r\npublic interface HelloMachineServices extends ComponentService{\r\n\t\r\n\tpublic void salute(final String name);\r\n\r\n}\r\n", "iewGroup\n\timplements\n\t\tmono.android.IGCUserPeer\n{\n\tstatic final String __md_methods;\n\tstatic {\n\t\t__md_methods = \n\t\t\t\"n_onLayout:(ZIIII)V:GetOnLayout_ZIIIIHandler\\n\" +\n\t\t\t\"\";\n\t\tmono.android.Runtime.register (\"Xamarin.Forms.Platform.Android.MasterDetailContainer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", MasterDetailContainer.class, __md_methods);\n\t}\n\n\n\tpublic MasterDetailContainer (android.content.Context p0) throws java.lang.Throwable\n\t{\n\t\tsuper (p0);\n\t\tif (getClass () == MasterDetailContainer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.MasterDetailContainer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0 });\n\t}\n\n\n\tpublic MasterDetailContainer (android.content.Context p0, android.util.AttributeSet p1) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1);\n\t\tif (getClass () == MasterDetailContainer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.MasterDetailContainer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0, p1 });\n\t}\n\n\n\tpublic MasterDetailContainer (android.content.Context p0, android.util.AttributeSet p1, int p2) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1, p2);\n\t\tif (getClass () == MasterDetailContainer.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.MasterDetailContainer, Xamarin.Forms.Platform.Android, Version=1.3.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:System.Int32, mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\", this, new java.lang.Object[] { p0, p1, p2 });\n\t}\n\n\n\tpublic void onLayout (boolean p0, int p1, int p2, int p3, int p4)\n\t{\n\t\tn_onLayout (p0, p1, p2, p3, p4);\n\t}\n\n\tprivate native void n_onLayout (boolean p0, int p1, int p2, int p3, int p4);\n\n\tjava.util.ArrayList refList;\n\tpublic void monodroidAddReference (java.lang.Object obj)\n\t{\n\t\tif (refList == null)\n\t\t\trefList = new java.util.ArrayList ();\n\t\trefList.add (obj);\n\t}\n\n\tpublic void monodroidClearReferences ()\n\t{\n\t\tif (refList != null)\n\t\t\trefList.clear ();\n\t}\n}\n", "ava.awt.Dimension;\nimport java.awt.FlowLayout;\nimport java.awt.Insets;\nimport javax.swing.JScrollPane;\nimport javax.swing.SwingUtilities;\n\n/** FlowLayout subclass that fully supports wrapping of components. */\n@SuppressWarnings(\"serial\")\npublic class WrapLayout extends FlowLayout {\n  /**\n   * Constructs a new {@code WrapLayout} with a left alignment and a default 5-unit horizontal and vertical gap.\n   */\n  public WrapLayout() {\n    super();\n  }\n\n  /**\n   * Constructs a new {@code FlowLayout} with the specified alignment and a default 5-unit horizontal and vertical gap.\n   * The value of the alignment argument must be one of {@code\n   * WrapLayout}, {@code WrapLayout}, or {@code WrapLayout}.\n   *\n   * @param align\n   *          the alignment value\n   */\n  public WrapLayout(int align) {\n    super(align);\n  }\n\n  /**\n   * Creates a new flow layout manager with the indicated alignment and the indicated horizontal and vertical gaps.\n   *\n   * <p>\n   * The value of the alignment argument must be one of {@code WrapLayout}, {@code WrapLayout}, or {@code WrapLayout}.\n   *\n   * @param align\n   *          the alignment value\n   * @param hgap\n   *          the horizontal gap between components\n   * @param vgap\n   *          the vertical gap between components\n   */\n  public WrapLayout(int align, int hgap, int vgap) {\n    super(align, hgap, vgap);\n  }\n\n  /**\n   * Returns the preferred dimensions for this layout given the <i>visible</i> components in the specified target\n   * container.\n   *\n   * @param target\n   *          the component which needs to be laid out\n   * @return the preferred dimensions to lay out the subcomponents of the specified container\n   */\n  @Override\n  public Dimension preferredLayoutSize(Container target) {\n    return layoutSize(target, true);\n  }\n\n  /**\n   * Returns the minimum dimensions needed to layout the <i>visible</i> components contained in the specified target\n   * container.\n   *\n   * @param target\n   *          the component which needs to be laid out\n   * @return the minimum dimensions to lay out the subcomponents of the specified container\n   */\n  @Override\n  public Dimension minimumLayoutSize(Container target) {\n    Dimension minimum = layoutSize(target, false);\n    minimum.width -= (getHgap() + 1);\n    return minimum;\n  }\n\n  /**\n   * Returns the minimum or preferred dimension needed to layout the target container.\n   *\n   * @param target\n   *          target to get layout size for\n   * @param preferred\n   *          should preferred size be calculated\n   * @return the dimension to layout the target container\n   */\n  private Dimension layoutSize(Container target, boolean preferred) {\n    synchronized (target.getTreeLock()) {\n      // Each row must fit with the width allocated to the containter.\n      // When the container width = 0, the preferred width of the container\n      // has not yet been calculated so lets ask for the maximum.\n\n      Container container = target;\n\n      while (container.getSize().width == 0 && container.getParent() != null) {\n        container = container.getParent();\n      }\n\n      int targetWidth = container.getSize().width;\n      if (targetWidth == 0) {\n        targetWidth = Integer.MAX_VALUE;\n      }\n      int hgap = getHgap();\n      int vgap = getVgap();\n      Insets insets = target.getInsets();\n      int horizontalInsetsAndGap = insets.left + insets.right + (hgap * 2);\n      int maxWidth = targetWidth - horizontalInsetsAndGap;\n\n      // Fit components into the allowed width\n\n      Dimension dim = new Dimension(0, 0);\n      int rowWidth = 0;\n      int rowHeight = 0;\n\n      int nmembers = target.getComponentCount();\n\n      for (int i = 0; i < nmembers; i++) {\n        Component m = target.getComponent(i);\n\n        if (m.isVisible()) {\n          Dimension d = preferred ? m.getPreferredSize() : m.getMinimumSize();\n\n          // Can't add the component to current row. Start a new row.\n\n          if (rowWidth + d.width > maxWidth) {\n            addRow(dim, rowWidth, rowHeight);\n            rowWidth = 0;\n            rowHeight = 0;\n          }\n\n          // Add a horizontal gap for all components after the first\n\n          if (rowWidth != 0) {\n            rowWidth += hgap;\n          }\n\n          rowWidth += d.width;\n          rowHeight = Math.max(rowHeight, d.height);\n        }\n      }\n\n      addRow(dim, rowWidth, rowHeight);\n\n      dim.width += horizontalInsetsAndGap;\n      dim.height += insets.top + insets.bottom + vgap * 2;\n\n      // When using a scroll pane or the DecoratedLookAndFeel we need to\n      // make sure the preferred size is less than the size of the\n      // target containter so shrinking the container size works\n      // correctly. Removing the horizontal gap is an easy way to do this.\n\n      Container scrollPane = SwingUtilities.getAncestorOfClass(JScrollPane.class, target);\n\n      if (scrollPane != null && target.isValid()) {\n        dim.width -= (hgap + 1);\n      }\n\n      return dim;\n    }\n  }\n\n  /*\n   * A new row has been completed. Use the dimensions of this row to update the\n   * preferred size for the container.\n   *\n   * @param dim update the width and height when appropriate\n   *\n   * @param rowWidth the width of the row to add\n   *\n   * @param rowHeight the height of the row to add\n   */\n  private void addRow(Dimension dim, int rowWidth, int rowHeight) {\n    dim.width = Math.max(dim.width, rowWidth);\n\n    if (dim.height > 0) {\n      dim.height += getVgap();\n    }\n\n    dim.height += rowHeight;\n  }\n}\n", "pringframework.messaging.simp.config.MessageBrokerRegistry;\nimport org.springframework.web.socket.config.annotation.AbstractWebSocketMessageBrokerConfigurer;\nimport org.springframework.web.socket.config.annotation.EnableWebSocketMessageBroker;\nimport org.springframework.web.socket.config.annotation.StompEndpointRegistry;\n\n/**\n * Created by zengjie on 5/30/16.\n */\n@Configuration\n@EnableWebSocketMessageBroker\npublic class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer {\n\n    @Override\n    public void registerStompEndpoints(StompEndpointRegistry registry) {\n        // the endpoint for websocket connections\n        registry.addEndpoint(\"/stomp\").withSockJS();\n    }\n\n    @Override\n    public void configureMessageBroker(MessageBrokerRegistry config) {\n        // use the /topic prefix for outgoing WebSocket communication\n        config.enableSimpleBroker(\"/topic\");\n\n        // use the /app prefix for others\n        config.setApplicationDestinationPrefixes(\"/app\");\n    }\n}\n", " of this file are licensed under the MIT License (http://www.opensource.org/licenses/mit-license.php)\n */\npackage hudson.security.csrf;\n\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport hudson.Extension;\nimport hudson.model.PersistentDescriptor;\nimport jenkins.util.SystemProperties;\nimport hudson.Util;\nimport jenkins.model.Jenkins;\nimport hudson.model.ModelObject;\n\nimport javax.servlet.ServletRequest;\nimport javax.servlet.http.HttpServletRequest;\n\nimport jenkins.security.HexStringConfidentialKey;\n\nimport net.sf.json.JSONObject;\n\nimport org.acegisecurity.Authentication;\nimport org.jenkinsci.Symbol;\nimport org.kohsuke.accmod.Restricted;\nimport org.kohsuke.accmod.restrictions.NoExternalUse;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.StaplerRequest;\n\n/**\n * A crumb issuing algorithm based on the request principal and the remote address.\n * \n * @author dty\n */\npublic class DefaultCrumbIssuer extends CrumbIssuer {\n    \n    private transient MessageDigest md;\n    private boolean excludeClientIPFromCrumb;\n\n    @Restricted(NoExternalUse.class)\n    public static /* non-final: Groovy Console */ boolean EXCLUDE_SESSION_ID = SystemProperties.getBoolean(DefaultCrumbIssuer.class.getName() + \".EXCLUDE_SESSION_ID\");\n\n    @DataBoundConstructor\n    public DefaultCrumbIssuer(boolean excludeClientIPFromCrumb) {\n        this.excludeClientIPFromCrumb = excludeClientIPFromCrumb;\n        initializeMessageDigest();\n    }\n\n    public boolean isExcludeClientIPFromCrumb() {\n        return this.excludeClientIPFromCrumb;\n    }\n    \n    private Object readResolve() {\n        initializeMessageDigest();\n        return this;\n    }\n\n    private void initializeMessageDigest() {\n        try {\n            md = MessageDigest.getInstance(\"SHA-256\");\n        } catch (NoSuchAlgorithmException e) {\n            md = null;\n            LOGGER.log(Level.SEVERE, e, () -> \"Cannot find SHA-256 MessageDigest implementation.\");\n        }\n    }\n    \n    @Override\n    protected synchronized String issueCrumb(ServletRequest request, String salt) {\n        if (request instanceof HttpServletRequest) {\n            if (md != null) {\n                HttpServletRequest req = (HttpServletRequest) request;\n                StringBuilder buffer = new StringBuilder();\n                Authentication a = Jenkins.getAuthentication();\n                buffer.append(a.getName());\n                buffer.append(';');\n                if (!isExcludeClientIPFromCrumb()) {\n                    buffer.append(getClientIP(req));\n                }\n                if (!EXCLUDE_SESSION_ID) {\n                    buffer.append(';');\n                    buffer.append(req.getSession().getId());\n                }\n\n                md.update(buffer.toString().getBytes());\n                return Util.toHexString(md.digest(salt.getBytes()));\n            }\n        }\n        return null;\n    }\n\n    @Override\n    public boolean validateCrumb(ServletRequest request, String salt, String crumb) {\n        if (request instanceof HttpServletRequest) {\n            String newCrumb = issueCrumb(request, salt);\n            if ((newCrumb != null) && (crumb != null)) {\n                // String.equals() is not constant-time, but this is\n                return MessageDigest.isEqual(newCrumb.getBytes(StandardCharsets.US_ASCII),\n                        crumb.getBytes(StandardCharsets.US_ASCII));\n            }\n        }\n        return false;\n    }\n\n    private static final String X_FORWARDED_FOR = \"X-Forwarded-For\";\n\n    private String getClientIP(HttpServletRequest req) {\n        String defaultAddress = req.getRemoteAddr();\n        String forwarded = req.getHeader(X_FORWARDED_FOR);\n        if (forwarded != null) {\n\t        String[] hopList = forwarded.split(\",\");\n            if (hopList.length >= 1) {\n                return hopList[0];\n            }\n        }\n        return defaultAddress;\n    }\n    \n    @Extension @Symbol(\"standard\")\n    public static final class DescriptorImpl extends CrumbIssuerDescriptor<DefaultCrumbIssuer> implements ModelObject, PersistentDescriptor {\n\n        private final static HexStringConfidentialKey CRUMB_SALT = new HexStringConfidentialKey(Jenkins.class,\"crumbSalt\",16);\n        \n        public DescriptorImpl() {\n            super(CRUMB_SALT.get(), SystemProperties.getString(\"hudson.security.csrf.requestfield\", CrumbIssuer.DEFAULT_CRUMB_NAME));\n        }\n\n        @Override\n        public String getDisplayName() {\n            return Messages.DefaultCrumbIssuer_DisplayName();\n        }\n\n        @Override\n        public DefaultCrumbIssuer newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            if (req == null) {\n                // This state is prohibited according to the Javadoc of the super method.\n                throw new FormException(\"DefaultCrumbIssuer new instance method is called for null Stapler request. \"\n                        + \"Such call is prohibited.\", \"req\");\n            }\n            return req.bindJSON(DefaultCrumbIssuer.class, formData);\n        }\n    }\n    \n    private static final Logger LOGGER = Logger.getLogger(DefaultCrumbIssuer.class.getName());\n}\n", "TimerTickTask extends TimerTask {\n\n\tprivate TickDynamicMod mod;\n\t\n\tpublic TimerTickTask(TickDynamicMod mod) {\n\t\tthis.mod = mod;\n\t}\n\t\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tmod.tpsMutex.acquire();\n\t\t\t\n\t\t\tif(mod.tpsList.size() >= mod.tpsAverageSeconds)\n\t\t\t\tmod.tpsList.removeFirst();\n\t\t\tmod.tpsList.add(mod.tickCounter);\n\t\t\tmod.tickCounter = 0;\n\t\t\t\n\t\t} catch (InterruptedException e) {\n\t\t\tSystem.err.println(\"Exception during TPS Calculation:\");\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif(mod != null && mod.tpsMutex != null)\n\t\t\t\tmod.tpsMutex.release();\n\t\t}\n\t\t\n\n\t}\n\n}\n", "ort net.minecraft.item.Items;\nimport net.minecraft.util.registry.Bootstrap;\nimport net.minecraftforge.items.IItemHandler;\nimport net.minecraftforge.items.ItemStackHandler;\nimport org.cyclops.commoncapabilities.IngredientComponents;\nimport org.cyclops.commoncapabilities.api.capability.itemhandler.DefaultSlotlessItemHandlerWrapper;\nimport org.cyclops.commoncapabilities.api.capability.itemhandler.ItemMatch;\nimport org.cyclops.cyclopscore.ingredient.collection.IngredientArrayList;\nimport org.junit.Before;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.junit.Assert.assertThat;\n\npublic class TestItemStackSlotlessItemStorageWrapper {\n\n    private static ItemStack APPLE_1;\n    private static ItemStack APPLE_10;\n\n    private static ItemStack APPLE_64;\n    private static ItemStack APPLE_8;\n    private static ItemStack APPLE_9;\n    private static ItemStack APPLE_11;\n\n    private IItemHandler innerStorage;\n    private IngredientComponentStorageWrapperHandlerItemStackSlotless.ComponentStorageWrapper storage;\n    private IngredientComponentStorageWrapperHandlerItemStackSlotless.ItemStorageWrapper wrapper;\n\n    @BeforeClass\n    public static void init() {\n        // We need the Minecraft registries to be filled\n        Bootstrap.register();\n    }\n\n    public static boolean eq(ItemStack a, ItemStack b) {\n        return IngredientComponents.ITEMSTACK.getMatcher().matchesExactly(a, b);\n    }\n\n    @Before\n    public void beforeEach() {\n        APPLE_1 = new ItemStack(Items.APPLE, 1);\n        APPLE_10 = new ItemStack(Items.APPLE, 10);\n\n        APPLE_64 = new ItemStack(Items.APPLE, 64);\n        APPLE_8 = new ItemStack(Items.APPLE, 8);\n        APPLE_9 = new ItemStack(Items.APPLE, 9);\n        APPLE_11 = new ItemStack(Items.APPLE, 11);\n\n        innerStorage = new ItemStackHandler(10);\n        ((ItemStackHandler) innerStorage).setStackInSlot(2, APPLE_1.copy());\n        ((ItemStackHandler) innerStorage).setStackInSlot(6, APPLE_10.copy());\n        storage = new IngredientComponentStorageWrapperHandlerItemStackSlotless.ComponentStorageWrapper(IngredientComponents.ITEMSTACK, new DefaultSlotlessItemHandlerWrapper(innerStorage));\n        wrapper = new IngredientComponentStorageWrapperHandlerItemStackSlotless.ItemStorageWrapper(IngredientComponents.ITEMSTACK, storage);\n    }\n\n    @Test\n    public void testGetItems() {\n        assertThat(new IngredientArrayList<>(IngredientComponents.ITEMSTACK, wrapper.getItems()),\n                is(new IngredientArrayList<>(IngredientComponents.ITEMSTACK, ItemStack.EMPTY, ItemStack.EMPTY, APPLE_1, ItemStack.EMPTY, ItemStack.EMPTY,\n                        ItemStack.EMPTY, APPLE_10, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY)));\n    }\n\n    @Test\n    public void testFindItems() {\n        assertThat(new IngredientArrayList<>(IngredientComponents.ITEMSTACK, wrapper.findItems(ItemStack.EMPTY, ItemMatch.ANY)),\n                is(new IngredientArrayList<>(IngredientComponents.ITEMSTACK, ItemStack.EMPTY, ItemStack.EMPTY, APPLE_1, ItemStack.EMPTY, ItemStack.EMPTY,\n                        ItemStack.EMPTY, APPLE_10, ItemStack.EMPTY, ItemStack.EMPTY, ItemStack.EMPTY)));\n    }\n\n    @Test\n    public void testInsertItem() {\n        assertThat(eq(wrapper.insertItem(APPLE_1, true), ItemStack.EMPTY), is(true));\n        assertThat(eq(wrapper.insertItem(APPLE_1, false), ItemStack.EMPTY), is(true));\n    }\n\n    @Test\n    public void testExtractItem() {\n        assertThat(eq(wrapper.extractItem(10, true), APPLE_1), is(true));\n        assertThat(eq(wrapper.extractItem(10, true), APPLE_1), is(true));\n        assertThat(eq(wrapper.extractItem(0, true), ItemStack.EMPTY), is(true));\n\n        assertThat(eq(wrapper.extractItem(10, false), APPLE_1), is(true));\n        assertThat(eq(wrapper.extractItem(0, false), ItemStack.EMPTY), is(true));\n        assertThat(eq(wrapper.extractItem(10, false), APPLE_10), is(true));\n        assertThat(eq(wrapper.extractItem(10, false), ItemStack.EMPTY), is(true));\n    }\n\n    @Test\n    public void testExtractItemMatch() {\n        assertThat(eq(wrapper.extractItem(APPLE_10, ItemMatch.EXACT, true), APPLE_10), is(true));\n        assertThat(eq(wrapper.extractItem(APPLE_10, ItemMatch.EXACT, true), APPLE_10), is(true));\n        assertThat(eq(wrapper.extractItem(APPLE_10, ItemMatch.EXACT, true), APPLE_10), is(true));\n\n        assertThat(eq(wrapper.extractItem(APPLE_10, ItemMatch.EXACT, false), APPLE_10), is(true));\n        assertThat(eq(wrapper.extractItem(APPLE_10, ItemMatch.EXACT, false), APPLE_10), is(false));\n        assertThat(eq(wrapper.extractItem(APPLE_1, ItemMatch.EXACT, false), APPLE_1), is(true));\n        assertThat(eq(wrapper.extractItem(APPLE_1, ItemMatch.EXACT, false), APPLE_1), is(false));\n    }\n\n    @Test\n    public void testGetLimit() {\n        assertThat(wrapper.getLimit(), is(640));\n    }\n\n}\n", " TreeNode {\n\t\tint val;\n\t\tTreeNode left;\n\t\tTreeNode right;\n\n\t\tTreeNode() {\n\t\t}\n\n\t\tTreeNode(int val) {\n\t\t\tthis.val = val;\n\t\t}\n\n\t\tTreeNode(int val, TreeNode left, TreeNode right) {\n\t\t\tthis.val = val;\n\t\t\tthis.left = left;\n\t\t\tthis.right = right;\n\t\t}\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tTreeNode tn = new TreeNode(1);\n\t\ttn.left = new TreeNode(2);\n\t\ttn.right = new TreeNode(5);\n\t\ttn.left.left = new TreeNode(3);\n\t\ttn.left.right = new TreeNode(4);\n\t\ttn.right.right = new TreeNode(6);\n\t\tflatten(tn);\n\t\tprintNodes(tn);\n\t\tSystem.out.println();\n\t\ttn = new TreeNode(1);\n\t\ttn.right = new TreeNode(2);\n\t\ttn.right.left = new TreeNode(3);\n\t\tflatten(tn);\n\t\tprintNodes(tn);\n\t}\n\n\tpublic static void flatten(TreeNode root) {\n\t\tif (root == null)\n\t\t\treturn;\n\t\tflatten(root.left);\n\t\tflatten(root.right);\n\n\t\tTreeNode left = root.left;\n\t\tif (left != null) {\n\t\t\tTreeNode leftPtr = left;\n\t\t\twhile (left != null && left.right != null) {\n\t\t\t\tleft = left.right;\n\t\t\t}\n\n\t\t\tleft.right = root.right;\n\n\t\t\troot.left = null;\n\t\t\troot.right = leftPtr;\n\t\t}\n\t}\n\n\tpublic static void printNodes(TreeNode root) {\n\t\twhile (root != null) {\n\t\t\tSystem.out.print(root.val + \"->\");\n\t\t\troot = root.right;\n\t\t}\n\t}\n\n}\n", "til.List;\nimport java.util.Map;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\nimport org.displaytag.tags.TableTagParameters;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.ExtendedModelMap;\nimport org.springframework.ui.Model;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.servlet.ModelAndView;\n\nimport ca.gc.agr.mbb.hostpathogen.web.Constants;\nimport ca.gc.agr.mbb.hostpathogen.web.dao.SearchException;\nimport ca.gc.agr.mbb.hostpathogen.web.model.Host;\nimport ca.gc.agr.mbb.hostpathogen.web.service.HostManager;\n\n\n/**\n * Simple class to retrieve a list of hosts from the database.\n * <p>\n * <a href=\"HostController.java.html\"><i>View Source</i></a>\n * </p>\n *\n * @author bilkhus\n */\n@Controller\n@RequestMapping(\"/hosts*\")\npublic class HostController extends GenericController {\n    private HostManager hostManager = null;\n\n    @Autowired\n    public void setHostManager(HostManager hostManager) {\n        this.hostManager = hostManager;\n    }\n    \n\t/** The table id hosts list. */\n\tprivate String tableIdHostList = \"hostList\";\n\t\n\t/** The list columns hosts. */\n\tString[] listColumnsHosts = {\n\t\t\t\t\t\t\t\t//\"id\", \n\t\t\t\t\t\t\t     \"genus\", \n\t\t\t\t\t\t\t     \"species\",\n\t\t\t\t\t\t\t     \"subSpecificTaxa\",\n\t\t\t\t\t\t\t     \"cultivar\", \n\t\t\t\t\t\t\t     \"enName\",\n\t\t\t\t\t\t\t     \"frName\"\n\t\t\t\t\t\t\t     };\n\n    @RequestMapping(method = RequestMethod.GET)\n    public ModelAndView handleRequest(@RequestParam(required = false, value = \"genus\") String genus,\n\t\t\t  \t\t\t\t\t\t  @RequestParam(required = false, value = \"species\") String species,    \t\t\n\t\t\t  \t\t\t\t\t\t  @RequestParam(required = false, value = \"subSpecificTaxa\") String subSpecificTaxa,\n\t\t\t  \t\t\t\t\t\t  @RequestParam(required = false, value = \"pageSize\") Integer pageSizeParam,\n    \t\t\t\t\t\t\t\t  HttpServletRequest request,\n    \t\t\t\t\t\t\t\t  HttpServletResponse response\n    \t\t\t\t\t\t\t\t  ) throws Exception {\n        Model model = new ExtendedModelMap();\n        \n        Map<String, String> filters = createFilters(); \n        \n        filters.put(\"genus\", genus);\n        filters.put(\"species\", species);\n        filters.put(\"subSpecificTaxa\", subSpecificTaxa);\n        \n        pageSizeParam = (pageSizeParam!=null && pageSizeParam!=0) ? pageSizeParam : pageSize;\n        \n        int startingRecord = getStartingRecord(request, pageSizeParam, tableIdHostList);\n        String sortColumn = getSortColumn(request, tableIdHostList, listColumnsHosts, 0);\n        boolean sortOrder = getSortOrder(request, tableIdHostList);\n        boolean export = request.getParameter(TableTagParameters.PARAMETER_EXPORTING) != null;\n        if(export){\n        \tpartialListValue = false;\n        \trequest.setAttribute(\"partialListValue\", false);\n        } else {\n        \tpartialListValue = true;\n        \trequest.setAttribute(\"partialListValue\", true);\n        }\n        \n       \tList<Host> list = new ArrayList<Host>();\n        \n        try {\n    \t\trequest.setAttribute(\"resultSize\", hostManager.getDataCount(filters));\n    \t\tlist = hostManager.getFilteredPagedData(startingRecord, pageSizeParam, sortColumn, sortOrder, filters, export);\n    \t\tmodel.addAttribute(Constants.HOST_LIST, list);\n            \n        } catch (SearchException se) {\n            model.addAttribute(\"searchError\", se.getMessage());\n            model.addAttribute(hostManager.getHosts());\n        }\n        return new ModelAndView(\"hostList\", model.asMap());\n    }\n    \n}", "public static void main(String[] args) throws Throwable {\n        HproseHttpClient client = new HproseHttpClient();\n        client.useService(\"http://localhost:8084/examserver/Methods\");\n        System.out.println(client.invoke(\"ex1_getId\"));\n        System.out.println(client.invoke(\"ex2_getId\"));\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage com.sun.tools.internal.xjc;\n\nimport java.text.MessageFormat;\nimport java.util.ResourceBundle;\n\n/**\n * Formats error messages.\n */\npublic class Messages\n{\n    /** Loads a string resource and formats it with specified arguments. */\n    public static String format( String property, Object... args ) {\n        String text = ResourceBundle.getBundle(Messages.class.getPackage().getName() +\".MessageBundle\").getString(property);\n        return MessageFormat.format(text,args);\n    }\n\n//\n//\n// Message resources\n//\n//\n    static final String UNKNOWN_LOCATION = // 0 args\n        \"ConsoleErrorReporter.UnknownLocation\";\n\n    static final String LINE_X_OF_Y = // 2 args\n        \"ConsoleErrorReporter.LineXOfY\";\n\n    static final String UNKNOWN_FILE = // 0 args\n        \"ConsoleErrorReporter.UnknownFile\";\n\n    static final String DRIVER_PUBLIC_USAGE = // 0 args\n        \"Driver.Public.Usage\";\n\n    static final String DRIVER_PRIVATE_USAGE = // 0 args\n        \"Driver.Private.Usage\";\n\n    static final String ADDON_USAGE = // 0 args\n        \"Driver.AddonUsage\";\n\n    static final String EXPERIMENTAL_LANGUAGE_WARNING = // 2 arg\n        \"Driver.ExperimentalLanguageWarning\";\n\n    static final String NON_EXISTENT_DIR = // 1 arg\n        \"Driver.NonExistentDir\";\n\n    // Usage not found. TODO Remove\n    // static final String MISSING_RUNTIME_PACKAGENAME = // 0 args\n    //     \"Driver.MissingRuntimePackageName\";\n\n    static final String MISSING_MODE_OPERAND = // 0 args\n            \"Driver.MissingModeOperand\";\n\n    // Usage not found. TODO Remove\n    // static final String MISSING_COMPATIBILITY_OPERAND = // 0 args\n    //     \"Driver.MissingCompatibilityOperand\";\n\n    static final String MISSING_PROXY = // 0 args\n        \"Driver.MISSING_PROXY\";\n\n    static final String MISSING_PROXYFILE = // 0 args\n        \"Driver.MISSING_PROXYFILE\";\n\n    static final String NO_SUCH_FILE = // 1 arg\n        \"Driver.NO_SUCH_FILE\";\n\n    static final String ILLEGAL_PROXY = // 1 arg\n        \"Driver.ILLEGAL_PROXY\";\n\n    static final String ILLEGAL_TARGET_VERSION = // 1 arg\n        \"Driver.ILLEGAL_TARGET_VERSION\";\n\n    static final String MISSING_OPERAND = // 1 arg\n        \"Driver.MissingOperand\";\n\n    static final String MISSING_PROXYHOST = // 0 args\n        \"Driver.MissingProxyHost\";\n\n    static final String MISSING_PROXYPORT = // 0 args\n        \"Driver.MissingProxyPort\";\n\n    static final String STACK_OVERFLOW = // 0 arg\n        \"Driver.StackOverflow\";\n\n    static final String UNRECOGNIZED_MODE = // 1 arg\n        \"Driver.UnrecognizedMode\";\n\n    static final String UNRECOGNIZED_PARAMETER = // 1 arg\n        \"Driver.UnrecognizedParameter\";\n\n    static final String UNSUPPORTED_ENCODING = // 1 arg\n            \"Driver.UnsupportedEncoding\";\n\n    static final String MISSING_GRAMMAR = // 0 args\n        \"Driver.MissingGrammar\";\n\n    static final String PARSING_SCHEMA = // 0 args\n        \"Driver.ParsingSchema\";\n\n    static final String PARSE_FAILED = // 0 args\n        \"Driver.ParseFailed\";\n\n    static final String COMPILING_SCHEMA = // 0 args\n        \"Driver.CompilingSchema\";\n\n    static final String FAILED_TO_GENERATE_CODE = // 0 args\n        \"Driver.FailedToGenerateCode\";\n\n    static final String FILE_PROLOG_COMMENT = // 1 arg\n        \"Driver.FilePrologComment\";\n\n    static final String DATE_FORMAT = // 0 args\n        \"Driver.DateFormat\";\n\n    static final String TIME_FORMAT = // 0 args\n        \"Driver.TimeFormat\";\n\n    static final String AT = // 0 args\n        \"Driver.At\";\n\n    static final String VERSION = // 0 args\n        \"Driver.Version\";\n\n    static final String FULLVERSION = // 0 args\n        \"Driver.FullVersion\";\n\n    static final String BUILD_ID = // 0 args\n        \"Driver.BuildID\";\n\n    static final String ERROR_MSG = // 1:arg\n        \"Driver.ErrorMessage\";\n\n    static final String WARNING_MSG = // 1:arg\n        \"Driver.WarningMessage\";\n\n    static final String INFO_MSG = // 1:arg\n        \"Driver.InfoMessage\";\n\n    static final String ERR_NOT_A_BINDING_FILE = // 2 arg\n        \"Driver.NotABindingFile\";\n\n    static final String ERR_TOO_MANY_SCHEMA = // 0 args\n        \"ModelLoader.TooManySchema\";\n\n    static final String ERR_BINDING_FILE_NOT_SUPPORTED_FOR_RNC = // 0 args\n        \"ModelLoader.BindingFileNotSupportedForRNC\";\n\n    static final String DEFAULT_VERSION = // 0 args\n        \"Driver.DefaultVersion\";\n\n    static final String DEFAULT_PACKAGE_WARNING = // 0 args\n        \"Driver.DefaultPackageWarning\";\n\n    static final String NOT_A_VALID_FILENAME = // 2 args\n        \"Driver.NotAValidFileName\";\n    static final String FAILED_TO_PARSE = // 2 args\n        \"Driver.FailedToParse\";\n    static final String NOT_A_FILE_NOR_URL = // 1 arg\n        \"Driver.NotAFileNorURL\";\n\n    static final String FIELD_RENDERER_CONFLICT = // 2 args\n        \"FIELD_RENDERER_CONFLICT\";\n\n    static final String NAME_CONVERTER_CONFLICT = // 2 args\n        \"NAME_CONVERTER_CONFLICT\";\n    static final String FAILED_TO_LOAD = // 2 args\n        \"FAILED_TO_LOAD\";\n\n    static final String PLUGIN_LOAD_FAILURE = // 1 arg\n        \"PLUGIN_LOAD_FAILURE\";\n}\n", "", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.eventgrid.v2020_01_01_preview.implementation;\n\nimport com.microsoft.azure.AzureEnvironment;\nimport com.microsoft.azure.AzureResponseBuilder;\nimport com.microsoft.azure.credentials.AzureTokenCredentials;\nimport com.microsoft.azure.management.apigeneration.Beta;\nimport com.microsoft.azure.management.apigeneration.Beta.SinceVersion;\nimport com.microsoft.azure.arm.resources.AzureConfigurable;\nimport com.microsoft.azure.serializer.AzureJacksonAdapter;\nimport com.microsoft.rest.RestClient;\nimport com.microsoft.azure.management.eventgrid.v2020_01_01_preview.Domains;\nimport com.microsoft.azure.management.eventgrid.v2020_01_01_preview.DomainTopics;\nimport com.microsoft.azure.management.eventgrid.v2020_01_01_preview.EventSubscriptions;\nimport com.microsoft.azure.management.eventgrid.v2020_01_01_preview.Operations;\nimport com.microsoft.azure.management.eventgrid.v2020_01_01_preview.Topics;\nimport com.microsoft.azure.management.eventgrid.v2020_01_01_preview.TopicTypes;\nimport com.microsoft.azure.arm.resources.implementation.AzureConfigurableCoreImpl;\nimport com.microsoft.azure.arm.resources.implementation.ManagerCore;\n\n/**\n * Entry point to Azure EventGrid resource management.\n */\npublic final class EventGridManager extends ManagerCore<EventGridManager, EventGridManagementClientImpl> {\n    private Domains domains;\n    private DomainTopics domainTopics;\n    private EventSubscriptions eventSubscriptions;\n    private Operations operations;\n    private Topics topics;\n    private TopicTypes topicTypes;\n    /**\n    * Get a Configurable instance that can be used to create EventGridManager with optional configuration.\n    *\n    * @return the instance allowing configurations\n    */\n    public static Configurable configure() {\n        return new EventGridManager.ConfigurableImpl();\n    }\n    /**\n    * Creates an instance of EventGridManager that exposes EventGrid resource management API entry points.\n    *\n    * @param credentials the credentials to use\n    * @param subscriptionId the subscription UUID\n    * @return the EventGridManager\n    */\n    public static EventGridManager authenticate(AzureTokenCredentials credentials, String subscriptionId) {\n        return new EventGridManager(new RestClient.Builder()\n            .withBaseUrl(credentials.environment(), AzureEnvironment.Endpoint.RESOURCE_MANAGER)\n            .withCredentials(credentials)\n            .withSerializerAdapter(new AzureJacksonAdapter())\n            .withResponseBuilderFactory(new AzureResponseBuilder.Factory())\n            .build(), subscriptionId);\n    }\n    /**\n    * Creates an instance of EventGridManager that exposes EventGrid resource management API entry points.\n    *\n    * @param restClient the RestClient to be used for API calls.\n    * @param subscriptionId the subscription UUID\n    * @return the EventGridManager\n    */\n    public static EventGridManager authenticate(RestClient restClient, String subscriptionId) {\n        return new EventGridManager(restClient, subscriptionId);\n    }\n    /**\n    * The interface allowing configurations to be set.\n    */\n    public interface Configurable extends AzureConfigurable<Configurable> {\n        /**\n        * Creates an instance of EventGridManager that exposes EventGrid management API entry points.\n        *\n        * @param credentials the credentials to use\n        * @param subscriptionId the subscription UUID\n        * @return the interface exposing EventGrid management API entry points that work across subscriptions\n        */\n        EventGridManager authenticate(AzureTokenCredentials credentials, String subscriptionId);\n    }\n\n    /**\n     * @return Entry point to manage Domains.\n     */\n    public Domains domains() {\n        if (this.domains == null) {\n            this.domains = new DomainsImpl(this);\n        }\n        return this.domains;\n    }\n\n    /**\n     * @return Entry point to manage DomainTopics.\n     */\n    public DomainTopics domainTopics() {\n        if (this.domainTopics == null) {\n            this.domainTopics = new DomainTopicsImpl(this);\n        }\n        return this.domainTopics;\n    }\n\n    /**\n     * @return Entry point to manage EventSubscriptions.\n     */\n    public EventSubscriptions eventSubscriptions() {\n        if (this.eventSubscriptions == null) {\n            this.eventSubscriptions = new EventSubscriptionsImpl(this);\n        }\n        return this.eventSubscriptions;\n    }\n\n    /**\n     * @return Entry point to manage Operations.\n     */\n    public Operations operations() {\n        if (this.operations == null) {\n            this.operations = new OperationsImpl(this);\n        }\n        return this.operations;\n    }\n\n    /**\n     * @return Entry point to manage Topics.\n     */\n    public Topics topics() {\n        if (this.topics == null) {\n            this.topics = new TopicsImpl(this);\n        }\n        return this.topics;\n    }\n\n    /**\n     * @return Entry point to manage TopicTypes.\n     */\n    public TopicTypes topicTypes() {\n        if (this.topicTypes == null) {\n            this.topicTypes = new TopicTypesImpl(this);\n        }\n        return this.topicTypes;\n    }\n\n    /**\n    * The implementation for Configurable interface.\n    */\n    private static final class ConfigurableImpl extends AzureConfigurableCoreImpl<Configurable> implements Configurable {\n        public EventGridManager authenticate(AzureTokenCredentials credentials, String subscriptionId) {\n           return EventGridManager.authenticate(buildRestClient(credentials), subscriptionId);\n        }\n     }\n    private EventGridManager(RestClient restClient, String subscriptionId) {\n        super(\n            restClient,\n            subscriptionId,\n            new EventGridManagementClientImpl(restClient).withSubscriptionId(subscriptionId));\n    }\n}\n", "equestContext;\nimport javax.ws.rs.container.ContainerResponseContext;\nimport javax.ws.rs.container.ContainerResponseFilter;\nimport javax.ws.rs.ext.Provider;\n\n@Provider\npublic class CorsFilter implements ContainerResponseFilter {\n\n\tprivate final String HEADERS = \"Origin, Content-Type, Accept\";\n\n\t@Override\n\tpublic void filter(ContainerRequestContext request, ContainerResponseContext response) throws IOException {\n\n\t\tresponse.getHeaders().add(\"Access-Control-Allow-Origin\", \"*\");\n\t\tresponse.getHeaders().add(\"Access-Control-Allow-Headers\", HEADERS);\n\t\tresponse.getHeaders().add(\"Access-Control-Allow-Methods\", \"GET, POST, PUT, DELETE, OPTIONS, HEAD\");\n\n\t}\n}\n", "mport java.net.UnknownHostException;\r\nimport java.text.DecimalFormat;\r\nimport java.util.ArrayList;\r\nimport java.util.Calendar;\r\nimport java.util.HashMap;\r\nimport java.util.HashSet;\r\nimport java.util.List;\r\nimport java.util.Map;\r\nimport java.util.Set;\r\nimport java.util.TreeMap;\r\nimport java.util.TreeSet;\r\nimport java.util.Map.Entry;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.TimeUnit;\r\nimport java.util.concurrent.atomic.AtomicReference;\r\nimport java.util.regex.Pattern;\r\n\r\n\r\nimport com.billybyte.commoncollections.Tuple;\r\nimport com.billybyte.commoninterfaces.QueryInterface;\r\nimport com.billybyte.commonstaticmethods.Dates;\r\nimport com.billybyte.commonstaticmethods.RegexMethods;\r\nimport com.billybyte.commonstaticmethods.Rounding;\r\nimport com.billybyte.commonstaticmethods.Utils;\r\nimport com.billybyte.dse.DerivativeSetEngine;\r\nimport com.billybyte.dse.inputs.QueryManager;\r\n\r\nimport com.billybyte.marketdata.SecDef;\r\nimport com.billybyte.marketdata.SecDefSimple;\r\nimport com.billybyte.marketdata.ShortNameInfo;\r\nimport com.billybyte.marketdata.SecEnums.SecCurrency;\r\nimport com.billybyte.marketdata.SecEnums.SecExchange;\r\nimport com.billybyte.marketdata.SecEnums.SecSymbolType;\r\nimport com.billybyte.marketdata.futures.FuturesCodes;\r\nimport com.billybyte.marketdata.futures.FuturesProduct;\r\nimport com.billybyte.marketdata.futures.FuturesProductQuery;\r\nimport com.billybyte.marketdata.futures.MonthYear;\r\nimport com.billybyte.mongo.MongoCollectionWrapper;\r\nimport com.billybyte.mongo.MongoDatabaseNames;\r\nimport com.billybyte.mongo.MongoWrapper;\r\n\r\nimport com.billybyte.queries.ComplexQueryResult;\r\nimport com.mongodb.BasicDBObject;\r\nimport com.mongodb.DB;\r\nimport com.mongodb.DBCollection;\r\nimport com.mongodb.DBObject;\r\n\r\npublic class MarketDataComLib {\r\n\tpublic static final String[] MONTH_CODES_REGULAR = {\"F\",\"G\",\"H\",\"J\",\"K\",\"M\",\"N\",\"Q\",\"U\",\"V\",\"X\",\"Z\"};\r\n\tpublic static final Pattern MONTHYEAR_REGEX_PATTERN = Pattern.compile(\"((F|G|H|J|K|M|N|Q|U|V|X|Z)([0-9]{2,2}))\");\r\n\tpublic static final Pattern CME_SHORTNAME_REGEX_PATTERN = Pattern.compile(\"([A-Z0-9]{1,})(F|G|H|J|K|M|N|Q|U|V|X|Z)([0-9]{2,2})\");\r\n\tpublic static final Pattern CME_SHORTNAME_REGEX_PATTERN_1DIGIT_YEAR = Pattern.compile(\"([A-Z0-9]{1,})(F|G|H|J|K|M|N|Q|U|V|X|Z)([0-9]{1,1})\");\r\n\tpublic static final DecimalFormat MONTH_FORMAT = new DecimalFormat(\"00\");\r\n\tpublic static final DecimalFormat YEAR_FORMAT = new DecimalFormat(\"0000\");\r\n\tpublic static final DecimalFormat YEAR_2DIGIT_FORMAT = new DecimalFormat(\"00\");\r\n\tpublic static final String DEFAULT_SHORTNAME_SEPARATOR=\".\";\r\n\tpublic static final String DEFAULT_CORRELATION_PAIR_SEPARATOR=\"__\";\r\n\tpublic static final String DEFAULT_EXCH_IN_SHORTNAME_SEPARATOR=\"_\";\r\n\t\r\n\r\n\t\r\n\tprivate static final MarketDataComLib instanceForExceptions = new MarketDataComLib();\r\n\tprivate static final int DEFAULT_TIMEOUT_VALUE=1000;\r\n\tprivate static final TimeUnit DEFAULT_TIMEUNIT = TimeUnit.MILLISECONDS;\r\n\r\n\tprivate static final AtomicReference<Map<String, String>> atomicUnderlyingCache = \r\n\t\t\tnew AtomicReference<Map<String,String>>(new HashMap<String,String>());\r\n\r\n\tpublic static String getUnderlyingShortNameFromSpan(String key){\r\n\t\tint cacheSize = atomicUnderlyingCache.get().size();\r\n\t\t// get everything if nothing in cache\r\n\t\tif(cacheSize==0){\r\n\t\t\tMongoCollectionWrapper mwc = null;\r\n\t\t\ttry {\r\n\t\t\t\tmwc =\r\n\t\t\t\t\t\tnew MongoCollectionWrapper(\r\n\t\t\t\t\t\t\t\t\"127.0.0.1\",27022, \r\n\t\t\t\t\t\t\t\tUnderlyingInfo.getDbName(UnderlyingInfo.class), \r\n\t\t\t\t\t\t\t\tUnderlyingInfo.getCollectionName(UnderlyingInfo.class));\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\tUtils.prtObMess(MarketDataComLib.class, \"NON-FATAL: Span Mongo Server not running\");\r\n\t\t\t\te.printStackTrace();\r\n\t\t\t\tUtils.prtObMess(MarketDataComLib.class, \"END NON-FATAL: Span Mongo Server not running\");\r\n\t\t\t\t// put one dummy item in cache to stop looping thru this code\r\n\t\t\t\tatomicUnderlyingCache.get().put(\"dummyBcNoSpanRunning\", \"dummyBcNoSpanRunning\");\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\r\n\t\t\t// get everything the first time through\r\n\t\t\tDBObject search = new BasicDBObject();\r\n\t\t\tList<UnderlyingInfo> uiList = mwc.getList(UnderlyingInfo.class, search);\r\n\t\t\tif(uiList.size()<1)return null;\r\n\t\t\tfor(UnderlyingInfo ui : uiList){\r\n\t\t\t\tatomicUnderlyingCache.get().put(ui.get_id(), ui.getUnderlyingShorName());\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\t\r\n\t\treturn atomicUnderlyingCache.get().get(key);\r\n\t}\r\n\t\r\n\r\n\t/**\r\n\t * get month number (1 - 12) for a month code like F or G or Z\r\n\t */\r\n\tpublic static int getMonthNumFromMonthCode(String monthCode){\r\n\t\tfor(int i = 0;i<MONTH_CODES_REGULAR.length;i++){\r\n\t\t\tif(MONTH_CODES_REGULAR[i].compareTo(monthCode)==0){\r\n\t\t\t\treturn i+1;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn -1;\r\n\t}\r\n\t\r\n\tpublic static String getYyyyMmFromYearAndMonth(int year,int month){\r\n\t\tDecimalFormat dcfYear = new DecimalFormat(\"0000\");\t\t\r\n\t\tDecimalFormat dcfMonth = new DecimalFormat(\"00\");\r\n\t\treturn dcfYear.format(year)+dcfMonth.format(month);\r\n\t}\r\n\t\r\n\r\n\tpublic static String getFuturesShortNameFromCmeFormat(\r\n\t\t\tString cmeShortName,\r\n\t\t\tFuturesProductQuery fpq){\r\n\t\tList<String> futuresPartList = RegexMethods.getRegexMatches(CME_SHORTNAME_REGEX_PATTERN, cmeShortName);\r\n\t\tif(futuresPartList==null || futuresPartList.size()<1){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tString futuresPart = futuresPartList.get(0);\r\n\t\tString symbol = futuresPart.substring(0,futuresPart.length()-3);\r\n\t\tFuturesProduct fp = fpq.get(symbol, 1, TimeUnit.SECONDS);\r\n\t\tif(fp==null)return null;\r\n\t\tSecExchange exchange = fp.getExchange();\r\n\t\tSecCurrency currency = fp.getCurrency();\r\n\t\tString monthCode = futuresPart.substring(futuresPart.length()-3, futuresPart.length()-2);\r\n\t\tint year = 2000 + new Integer(futuresPart.substring(futuresPart.length()-2, futuresPart.length()));\r\n\t\tint month=getMonthNumFromMonthCode(monthCode);\r\n\t\t// create shortName for futures or options\r\n\t\tShortNameInfo sni = new ShortNameInfo(symbol,\r\n\t\t\t\tSecSymbolType.FUT ,exchange,currency,year,month,null,\t\r\n\t\t\t\tnull,null);\r\n\t\treturn sni.getShortName();\t\t\t\t\t\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param cmeShortName - like NGH12\r\n\t * @param exchange - like SecExchange.NYMEX\r\n\t * @param currency - like SecCurrency.USD\r\n\t * @param putCall - either P or C\r\n\t * @param strike - BigDecimal number representing strike\r\n\t * @return - return a valid shortName like NG.FUT.NYMEX.USD.201112, or NG.FOP.NYMEX.USD.201112.C.4.300\r\n\t */\r\n\tpublic static ShortNameInfo getShortNameFromCmeFormat(\r\n\t\t\tString cmeShortName,\r\n\t\t\tSecExchange exchange,\r\n\t\t\tSecCurrency currency,\r\n\t\t\tString putCall,\r\n\t\t\tBigDecimal strike){\r\n\t\tList<String> futuresPartList = RegexMethods.getRegexMatches(CME_SHORTNAME_REGEX_PATTERN, cmeShortName);\r\n\t\tif(futuresPartList==null || futuresPartList.size()<1){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tString futuresPart = futuresPartList.get(0);\r\n\t\tString monthCode = futuresPart.substring(futuresPart.length()-3, futuresPart.length()-2);\r\n\t\tint year = 2000 + new Integer(futuresPart.substring(futuresPart.length()-2, futuresPart.length()));\r\n\t\tint month=getMonthNumFromMonthCode(monthCode);\r\n\t\tString symbol = futuresPart.substring(0,futuresPart.length()-3);\r\n\t\t// create shortName for futures or options\r\n\t\tShortNameInfo sni = new ShortNameInfo(\r\n\t\t\t\tsymbol,putCall==null ? SecSymbolType.FUT : SecSymbolType.FOP,exchange,currency,\tyear,month,\t\r\n\t\t\t\tnull,putCall,strike);\r\n\t\treturn sni;\t\t\t\t\t\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\t\r\n\tpublic static String getCmeShortName2DigitYearFromSecDef(SecDef sd){\r\n\t\tif(sd.getSymbolType().compareTo(SecSymbolType.FUT)==0 ||\r\n\t\t\t\tsd.getSymbolType().compareTo(SecSymbolType.FOP)==0){\r\n\t\t\treturn sd.getSymbol()+FuturesCodes.monthCodes[sd.getContractMonth()-1]+\r\n\t\t\t\t\tYEAR_2DIGIT_FORMAT.format(sd.getContractYear()-2000);\r\n\t\t}else{\r\n\t\t\treturn null;\r\n\t\t}\r\n\t}\r\n\r\n\t\t\r\n\t/**\r\n\t * \r\n\t * @param cmeShortName - like NGH2\r\n\t * @param exchange - like SecExchange.NYMEX\r\n\t * @param currency - like SecCurrency.USD\r\n\t * @param putCall - either P or C\r\n\t * @param strike - BigDecimal number representing strike\r\n\t * @return - return a valid shortName like NG.FUT.NYMEX.USD.201112, or NG.FOP.NYMEX.USD.201112.C.4.300\r\n\t */\r\n\tpublic static ShortNameInfo getShortNameFromCmeFormat1DigitYear(\r\n\t\t\tString cmeShortName,\r\n\t\t\tSecExchange exchange,\r\n\t\t\tSecCurrency currency,\r\n\t\t\tString putCall,\r\n\t\t\tBigDecimal strike,\r\n\t\t\tint thisYear){\r\n\t\t// insert decade into cmeShortName, and call getShortNameFromCmeFormat\r\n\t\tint year =   new Integer(cmeShortName.substring(cmeShortName.length()-1, cmeShortName.length()));\r\n\t\t// what decade is it?\r\n\t\tint yearOfDecade = thisYear % ((thisYear/10)*10);\r\n\t\t//=(INT(E14/10)*10 - INT(E14/100)*100)/10\r\n\t\tint decade = ((thisYear/10)*10 - (thisYear/100)*100)/10;\r\n\t\tif(yearOfDecade>year){\r\n\t\t\tdecade = decade+1;\r\n\t\t}\r\n\t\tString shortName2charYear = cmeShortName.substring(0,cmeShortName.length()-1)+(decade % 10)+year;\r\n\t\treturn getShortNameFromCmeFormat(shortName2charYear,exchange,currency,putCall,strike);\r\n\t}\r\n\t\r\n\t\r\n\tpublic static ShortNameInfo getShortNameFromMmmYyFormat(\r\n\t\t\tString symbol,\r\n\t\t\tString MmmYyFormat,\r\n\t\t\tSecExchange exchange,\r\n\t\t\tSecCurrency currency,\r\n\t\t\tString putCall,\r\n\t\t\tBigDecimal strike){\r\n\t\t\r\n\t\t// first get MonthYear\r\n\t\tif(MmmYyFormat==null)return null;\r\n\t\tMonthYear my=null;\r\n\t\ttry {\r\n\t\t\tmy = new MonthYear(MmmYyFormat);\r\n\t\t} catch (Exception e) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tint month = my.getMonth().getIndex();\r\n\t\tint year = new Integer(my.getYear());\r\n\t\tShortNameInfo sni = new ShortNameInfo(\r\n\t\t\t\tsymbol,putCall==null ? SecSymbolType.FUT : SecSymbolType.FOP,exchange,currency,\tyear,month,\t\r\n\t\t\t\tnull,putCall,strike);\r\n\t\treturn sni;\t\t\t\t\t\t\t\r\n\t\t\r\n\t\t\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static final Tuple<String[],ShortNameInfo> getShortNameInfoFromCmeSymbol(String exchSym,FuturesProductQuery fpq,\r\n\t\t\tQueryInterface<String, SecDef>sdQuery){\r\n\t\tString[] reasons=null;\r\n\t\tShortNameInfo sni=null;\r\n\t\tString[] symParts = exchSym.split(\" \");\r\n\t\t\r\n\t\tString symbol = symParts[0].substring(0,symParts[0].length()-(3));\r\n\t\tFuturesProduct fp = fpq.get(symbol, 1, TimeUnit.SECONDS);\r\n\t\tif(fp==null){\r\n\t\t\treasons = new String[]{ \"Can't find FuturesProduct for \"+exchSym};\r\n\t\t\tTuple<String[],ShortNameInfo> ret = new  Tuple<String[], ShortNameInfo>(reasons, sni);\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\tSecExchange exchange = fp.getExchange();\r\n\t\tSecCurrency currency = fp.getCurrency();\r\n\t\t\r\n\t\t// get month year\r\n\t\tString myString = symParts[0].substring(symParts[0].length()-(3),symParts[0].length());\r\n\t\tString monthString = myString.substring(0,1);\r\n\t\tint contractMonth = getMonthNumFromMonthCode(monthString);\r\n\t\tint contractYear = new Integer(myString.substring(1,3))+2000;\r\n\t\tSecSymbolType symbolType = null;\r\n\t\t// see if it's a valud options symbol\r\n\t\tif(fp.getValidTypes().contains(SecSymbolType.FOP) && symParts.length==2){\r\n\t\t\tsymbolType = SecSymbolType.FOP;\r\n\t\t}else if(fp.getValidTypes().contains(SecSymbolType.FUT) && symParts.length==1){\r\n\t\t\tsymbolType = SecSymbolType.FUT;\r\n\t\t}\r\n\t\tif(symbolType==null){\r\n\t\t\treasons = new String[]{\"Can get symbolType for \"+exchSym};\r\n\t\t\tTuple<String[],ShortNameInfo> ret = new  Tuple<String[], ShortNameInfo>(reasons, sni);\r\n\t\t\treturn ret;\r\n\t\t}\r\n\t\tString right = null;\r\n\t\tBigDecimal strike = null;\r\n\t\tif(symbolType==SecSymbolType.FOP){\r\n\t\t\tString futSym = fp.getUnderlyingSymbol();\r\n\t\t\tif(futSym==null){\r\n\t\t\t\treasons = new String[]{\"Can get futures Symbol in FuturesProduct for \"+exchSym};\r\n\t\t\t\tTuple<String[],ShortNameInfo> ret = new  Tuple<String[], ShortNameInfo>(reasons, sni);\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tShortNameInfo futSni = \r\n\t\t\t\t\t\tnew ShortNameInfo(futSym, SecSymbolType.FUT, exchange, \r\n\t\t\t\t\t\t\t\tcurrency, contractYear, contractMonth ,null, null, null);\r\n\t\t\t\tSecDef futSd = sdQuery.get(futSni.getShortName(),10,TimeUnit.SECONDS);\r\n\t\t\t\tif(futSd ==null){\r\n\t\t\t\t\treasons = new String[]{\"Can get futures SecDef for \"+exchSym};\r\n\t\t\t\t\tTuple<String[],ShortNameInfo> ret = new  Tuple<String[], ShortNameInfo>(reasons, sni);\r\n\t\t\t\t\treturn ret;\r\n\t\t\t\t}\r\n\t\t\t\tint futPrec = futSd.getExchangePrecision();\r\n\t\t\t\tstrike = new BigDecimal(symParts[1].substring(0,symParts[1].length()-1));\r\n\t\t\t\tstrike = strike.divide(BigDecimal.TEN.pow(futPrec)).setScale(futPrec,RoundingMode.HALF_EVEN);\r\n\t\t\t} catch (Exception e) {\r\n\t\t\t\treasons = new String[]{\"Can get futures shortName for \"+exchSym+\" exception Cause = \"+e.getCause().getMessage()};\r\n\t\t\t\tTuple<String[],ShortNameInfo> ret = new  Tuple<String[], ShortNameInfo>(reasons, sni);\r\n\t\t\t\treturn ret;\r\n\t\t\t}\r\n\t\t\t// parse out right and symbol\r\n\t\t\tright = symParts[1].substring(symParts[1].length()-1,symParts[1].length());\r\n\t\t\t//TODO !!!!!!!!!!!DEBUG!!!!!!!! 2012 06 23\r\n\t\t}\r\n\t\tsni = new ShortNameInfo(symbol, symbolType, exchange, currency, contractYear, contractMonth, \r\n\t\t\t\tnull,right, strike);\r\n\t\treasons = new String[]{};\r\n\t\tTuple<String[],ShortNameInfo> ret = new  Tuple<String[], ShortNameInfo>(reasons, sni);\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic static String getSymTypeExch(SecDef sd){\r\n\t\treturn sd.getSymbol()+DEFAULT_SHORTNAME_SEPARATOR+\r\n\t\t\t\tsd.getSymbolType().toString()+DEFAULT_SHORTNAME_SEPARATOR+\r\n\t\t\t\tsd.getExchange().toString();\r\n\t}\r\n\t\r\n\tpublic static List<SecDef> getAllOutRightShortNamesInclusive(QueryInterface<String, SecDef> outRightQuery,\r\n\t\t\tSecDef begContract, SecDef endContract, int timeoutValue, TimeUnit timeUnitType) {\r\n\t\tSecDef sdCurrent = begContract;\r\n\t\tSecDef sdLast = endContract;\r\n\t\t// get all legs in between by incrementing the contract month of each leg\r\n\t\tint lastMonthYear = sdLast.getContractYear() * 100\r\n\t\t\t\t+ sdLast.getContractMonth();\r\n\t\tint currMonthYear;\r\n\t\tint nextYear;\r\n\t\tint nextMonth;\r\n\t\t\r\n\t\tnextYear = sdCurrent.getContractYear();\r\n\t\tnextMonth = sdCurrent.getContractMonth() ;\r\n\t\tString symbol = sdCurrent.getSymbol();\r\n\t\tSecSymbolType type = sdCurrent.getSymbolType();\r\n\t\tSecExchange exch = sdCurrent.getExchange();\r\n\t\tSecCurrency currency = sdCurrent.getCurrency();\r\n\t\tString right = sdCurrent.getRight();\r\n\t\tBigDecimal strike = sdCurrent.getStrike();\r\n\t\t\r\n\t\t\r\n\t\tArrayList<SecDef> secDefList = new ArrayList<SecDef>();\r\n\t\tdo {\r\n\t\t\tif(sdCurrent!=null){\r\n\t\t\t\tsecDefList.add(sdCurrent);\r\n\t\t\t}\r\n\t\t\tnextMonth = nextMonth + 1;\r\n\t\t\tif (nextMonth > 12) {\r\n\t\t\t\tnextMonth = 1;\r\n\t\t\t\tnextYear += 1;\r\n\t\t\t}\r\n\t\t\tcurrMonthYear = nextYear*100+nextMonth;\r\n\t\t\tShortNameInfo sni = new ShortNameInfo(symbol,type,exch,currency,nextYear,nextMonth,\r\n\t\t\t\t\tnull,right,strike);\r\n\t\t\t\t\t\r\n\t\t\tsdCurrent=outRightQuery.get(sni.getShortName(), timeoutValue, timeUnitType);\r\n\t\t\t\r\n\t\t} while (currMonthYear <= lastMonthYear);\r\n\t\treturn secDefList;\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * return the underlying secdef  If necessary use the FuturesOptionsSymbolPairQuery\r\n\t *   to get the symbol that corresponds to the option symbol\r\n\t * @param optionSd - option SecDef (currently supports SecSymbolType.OPT and FOP\r\n\t * @param timeoutValue\r\n\t * @param timeUnitType\r\n\t * @return for OPT - return the STK SecDef with same symbol.  \r\n\t * \t\t\tFor FOP return the FUT SecDef with same symbol and contractMonth and Year\r\n\t */\r\n\tpublic static SecDef getUnderylingSecDefFromOptionSecDef(\r\n\t\t\tSecDef optionSd,\r\n\t\t\tQueryInterface<String, SecDef> secDefQuery,\r\n\t\t\tFuturesProductQuery fpq, Calendar evalDate,\r\n\t\t\tint timeoutValue, TimeUnit  timeUnitType){\r\n\t\tString underFromSpan = \r\n\t\t\t\tgetUnderlyingShortNameFromSpan(optionSd.getShortName());\r\n\t\tif(underFromSpan!=null){\r\n\t\t\treturn secDefQuery.get(underFromSpan, timeoutValue, timeUnitType);\r\n\t\t}\r\n\t\tSecSymbolType retType =null;\r\n\t\t//TODO - THIS IS A HACK\r\n\t\tif(optionSd.getSymbolType()==SecSymbolType.OPT){\r\n\t\t\tretType = SecSymbolType.STK;\r\n\t\t}else if(optionSd.getSymbolType()==SecSymbolType.FOP){\r\n\t\t\tretType = SecSymbolType.FUT;\r\n\t\t}else if(optionSd.getSymbolType()==SecSymbolType.FUT || \r\n\t\t\t\toptionSd.getSymbolType()==SecSymbolType.STK){\r\n\t\t\treturn optionSd;\r\n\t\t}\r\n\t\tString sym=null;\r\n\t\tsym = optionSd.getSymbol();\r\n\t\tif(optionSd.getSymbolType()==SecSymbolType.FOP){\r\n\t\t\tFuturesProduct fp = fpq.get(optionSd.getSymbol(), timeoutValue, timeUnitType);\r\n\t\t\tsym = fp.getUnderlyingSymbol();\r\n\t\t}\r\n\t\tSecExchange exc = optionSd.getExchange();\r\n\t\tSecCurrency curr = optionSd.getCurrency();\r\n\t\tint contractYear = optionSd.getContractYear();\r\n\t\tint contractMonth = optionSd.getContractMonth();\r\n\t\t// assemble a shortName, and get it's SecDef from the GlobalQuery\r\n\t\tif(contractYear>0){\r\n\t\t\tif(contractMonth<=0){\r\n\t\t\t\treturn null;\r\n\t\t\t}\r\n\t\t}\r\n\t\tShortNameInfo sni = \r\n\t\t\tnew ShortNameInfo(sym,retType,exc,curr,contractYear,contractMonth,null,null,null);\r\n\t\tString shortNameUnderlying = sni.getShortName();\r\n\t\t// try to get sec def\r\n\t\tSecDef ret = secDefQuery.get(shortNameUnderlying, timeoutValue, timeUnitType);\r\n\t\t// now see if the symbol is a special case of some sort\r\n\t\t// TODO - this is a hack!!!!!\r\n\t\tif(optionSd.getSymbol().compareTo(\"KD\")==0){\r\n\t\t\t// replace the monthyear\r\n\t\t\tString symbol  = ret.getSymbol();\r\n\t\t\tSecSymbolType type = ret.getSymbolType();\r\n\t\t\tSecExchange exchange = ret.getExchange();\r\n\t\t\tSecCurrency currency = ret.getCurrency();\r\n\t\t\tString right = ret.getRight();\r\n\t\t\tBigDecimal strike = ret.getStrike();\r\n\t\t\t\r\n\t\t\tSecDef spotSd = getSpotContractPerBusinessDay(secDefQuery, symbol, type, exchange, currency, right, strike, evalDate);\r\n\t\t\treturn spotSd;\r\n\t\t}else{\r\n\t\t\treturn ret;\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t\r\n\tpublic static List<SecDef> getAllOutRightShortNamesInclusive(QueryInterface<String, SecDef> outRightQuery,\r\n\t\t\tString shortNameOfWideSpread, int timeoutValue, TimeUnit timeUnitType) {\r\n\t\tString[] legs = shortNameOfWideSpread.split(\"[-:]\");\r\n\t\tif (legs.length < 2) {\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tSecDef sdFirst = outRightQuery.get(legs[0], timeoutValue,\r\n\t\t\t\ttimeUnitType);\r\n\t\tSecDef sdLast = outRightQuery.get(legs[1], timeoutValue,\r\n\t\t\t\ttimeUnitType);\r\n\t\treturn getAllOutRightShortNamesInclusive(outRightQuery,sdFirst,sdLast,timeoutValue,timeUnitType);\r\n\t}\r\n\r\n\tpublic static List<SecDef> getAllOutRightShortNamesInclusive(\r\n\t\t\tQueryInterface<String,SecDef> outrightSecDefQueryEngine,\r\n\t\t\tString shortNameOfWideSpread){\r\n\t\t// \r\n\t\treturn getAllOutRightShortNamesInclusive(outrightSecDefQueryEngine,shortNameOfWideSpread,100,TimeUnit.MILLISECONDS);\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param productName\r\n\t * @param businessDay\r\n\t * @return SecurityDefinition\r\n\t\t// get the year and month of the businessDate to create a MonthYear object for\r\n\t\t//  the MonthYear that immediately proceeds the month of this businessDate.  The spot commodity contract for\r\n\t\t//   any commodity always has a month year that is the same as or greater than the month and year of the business date.\r\n\t\t//  So, if the business date is 12/15/2009, then the spot contract for any commodity is not going to be X9.  It will\r\n\t\t * be Z9 or greater. \r\n\t\t * We will start searching at the current monthyear. \r\n\t * \r\n\t */\r\n\t@Deprecated\r\n\tpublic static SecDef getSpotContractPerBusinessDay_old(QueryInterface<String,SecDef> secDefQueryEngine,\r\n\t\t\tString symbol,SecSymbolType type,SecExchange exchange,SecCurrency currency,\r\n\t\t\tString right,BigDecimal strike, Calendar businessDay){\r\n\t\tint year = businessDay.get(Calendar.YEAR);\r\n\t\tint firstSearhContractYear = year;\r\n\t\tint lastSearhContractYear = year+1;\r\n\t\tint month = businessDay.get(Calendar.MONTH)+1;\r\n\t\t\r\n\t\tShortNameInfo sniFirst = new ShortNameInfo(symbol,type,exchange,currency,firstSearhContractYear,month,\r\n\t\t\t\tnull,right,strike);\r\n\t\tSecDef sdFirst = \r\n\t\t\tsecDefQueryEngine.get(sniFirst.getShortName(),DEFAULT_TIMEOUT_VALUE,DEFAULT_TIMEUNIT);\r\n\t\tShortNameInfo sniLast = new ShortNameInfo(symbol,type,exchange,currency,lastSearhContractYear,month,\r\n\t\t\t\tnull,right,strike);\r\n\t\tSecDef sdLast = \r\n\t\t\tsecDefQueryEngine.get(sniLast.getShortName(),DEFAULT_TIMEOUT_VALUE,DEFAULT_TIMEUNIT);\r\n\r\n\t\t\r\n\t\tList<SecDef> sds =null;\r\n\t\ttry {\r\n\t\t\tsds = getAllOutRightShortNamesInclusive(secDefQueryEngine,sdFirst,sdLast,DEFAULT_TIMEOUT_VALUE,DEFAULT_TIMEUNIT);\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow Utils.IllState(instanceForExceptions, e.getMessage());\r\n\t\t}\r\n\t\tif(sds==null){\r\n\t\t\tthrow Utils.IllState(instanceForExceptions, \" getSpotContractPerBusinessDay error on symbol:\"+symbol+\" exchange: \"+exchange+\" businessDay: \"+businessDay.getTime().toString());\r\n\t\t}\r\n\t\tSecDef current = null;\r\n\t\tfor(SecDef sd : sds){\r\n\t\t\tCalendar c = Calendar.getInstance();\r\n\t\t\tc.set(sd.getExpiryYear(),sd.getExpiryMonth()-1,sd.getExpiryDay());\r\n\t\t\tif(c.compareTo(businessDay)>=0){\r\n\t\t\t\tcurrent = sd;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn current;\r\n\t\t\r\n\t}\r\n\t\r\n    \r\n    \r\n    \r\n\t/**\r\n\t* \r\n\t* @param productName\r\n\t* @param businessDay\r\n\t* @return SecurityDefinition\r\n\t// get the year and month of the businessDate to create a MonthYear object for\r\n\t//  the MonthYear that immediately proceeds the month of this businessDate.  The spot commodity contract for\r\n\t//   any commodity always has a month year that is the same as or greater than the month and year of the business date.\r\n\t//  So, if the business date is 12/15/2009, then the spot contract for any commodity is not going to be X9.  It will\r\n\t* be Z9 or greater. \r\n\t* We will start searching at the current monthyear. \r\n\t* \r\n\t*/\r\n\tpublic static SecDef getSpotContractPerBusinessDay(QueryInterface<String,SecDef> secDefQueryEngine,\r\n\tString symbol,SecSymbolType type,SecExchange exchange,SecCurrency currency,\r\n\tString right,BigDecimal strike, Calendar businessDay){\r\n\t\tint year = businessDay.get(Calendar.YEAR);\r\n\t\tint firstSearhContractYear = year;\r\n\t\tint month = businessDay.get(Calendar.MONTH)+1;\r\n\t\tCalendar lastCalendar = Dates.addBusinessDays(\"US\", businessDay, 100);\r\n\t\tint lastSearchContractYear = lastCalendar.get(Calendar.YEAR);\r\n\t\tint lastMonth = lastCalendar.get(Calendar.MONTH)+1;\r\n\t\t\r\n\t\tShortNameInfo sniFirst = new ShortNameInfo(symbol,type,exchange,currency,firstSearhContractYear,month,\r\n\t\t\t\tnull,right,strike);\r\n\t\tSecDef sdFirst = \r\n\t\tsecDefQueryEngine.get(sniFirst.getShortName(),DEFAULT_TIMEOUT_VALUE,DEFAULT_TIMEUNIT);\r\n\t\tShortNameInfo sniLast = new ShortNameInfo(symbol,type,exchange,currency,lastSearchContractYear,lastMonth,\r\n\t\t\t\tnull,right,strike);\r\n\t\tSecDef sdLast = \r\n\t\tsecDefQueryEngine.get(sniLast.getShortName(),DEFAULT_TIMEOUT_VALUE,DEFAULT_TIMEUNIT);\r\n\t\t\r\n\t\t\r\n\t\tList<SecDef> sds =null;\r\n\t\ttry {\r\n\t\t\tsds = getAllOutRightShortNamesInclusive(secDefQueryEngine,sdFirst,sdLast,DEFAULT_TIMEOUT_VALUE,DEFAULT_TIMEUNIT);\r\n\t\t} catch (Exception e) {\r\n\t\t\tthrow Utils.IllState(instanceForExceptions, e.getMessage());\r\n\t\t}\r\n\t\tif(sds==null){\r\n\t\t\tthrow Utils.IllState(instanceForExceptions, \" getSpotContractPerBusinessDay error on symbol:\"+symbol+\" exchange: \"+exchange+\" businessDay: \"+businessDay.getTime().toString());\r\n\t\t}\r\n\t\tSecDef current = null;\r\n\t\tfor(SecDef sd : sds){\r\n\t\t\tCalendar c = Calendar.getInstance();\r\n\t\t\tc.set(sd.getExpiryYear(),sd.getExpiryMonth()-1,sd.getExpiryDay());\r\n\t\t\tif(c.compareTo(businessDay)>=0){\r\n\t\t\t\tcurrent = sd;\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn current;\r\n\t\r\n\t}\t\r\n\t\t\r\n\tpublic static List<SecDef> getFuturesListFromDateAndSymbol(QueryInterface<String,SecDef> secDefQueryEngine,\r\n\t\t\tString symbol, Calendar firstBusinessDay,Calendar lastBusinessDay){\r\n\t\tFuturesProductQuery fpq = new FuturesProductQuery();\r\n\t\tFuturesProduct fp = fpq.get(symbol, 1, TimeUnit.SECONDS);\r\n\t\treturn getFuturesListFromDate(secDefQueryEngine,symbol,fp.getExchange(),\r\n\t\t\t\tfp.getCurrency(),firstBusinessDay,lastBusinessDay);\r\n\t}\r\n\t\r\n\tpublic static List<SecDef> getFuturesListFromDate(QueryInterface<String,SecDef> secDefQueryEngine,\r\n\t\t\tString symbol,SecExchange exchange,SecCurrency currency, Calendar firstBusinessDay,Calendar lastBusinessDay){\r\n\t\tif(lastBusinessDay.compareTo(firstBusinessDay)<0){\r\n\t\t\tthrow Utils.IllArg(instanceForExceptions, \"firstBusinessDay: \"+firstBusinessDay.getTime().toString()+\" is greater than lastBusinessDay: \"+lastBusinessDay.getTime().toString());\r\n\t\t}\r\n\t\t\r\n\t\tCalendar currentCal = (Calendar)firstBusinessDay.clone();\r\n\t\tList<SecDef> ret = new ArrayList<SecDef>();\r\n\t\tdo{\r\n\t\t\tSecDef currSd = getSpotContractPerBusinessDay(secDefQueryEngine,\r\n\t\t\t\t\tsymbol,SecSymbolType.FUT,exchange,currency,null,null,currentCal);\r\n\t\t\tif(currSd==null){\r\n\t\t\t\tthrow Utils.IllState(instanceForExceptions, \"no spot futures contract for Calendar: \"+currentCal.getTime().toString());\r\n\t\t\t}\r\n\t\t\tret.add(currSd);\r\n\t\t\tcurrentCal.add(Calendar.MONTH, 1);\r\n\t\t}while(currentCal.compareTo(lastBusinessDay)<=0);\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic static List<String[]> getAmexNames(){\r\n\t\tString csvFileName = Utils.createPackagePath(\"../CommonLibraries/src/\", MarketDataComLib.class)+\"AmexSymbols.csv\";\r\n\t\treturn Utils.getCSVData(csvFileName);\r\n\t}\r\n\r\n\tpublic static List<String[]> getNasdaqNames(){\r\n\t\tString csvFileName = Utils.createPackagePath(\"../CommonLibraries/src/\", MarketDataComLib.class)+\"NasdaqSymbols.csv\";\r\n\t\treturn Utils.getCSVData(csvFileName);\r\n\t}\r\n\r\n\tpublic static List<String[]> getOtcbbNames(){\r\n\t\tString csvFileName = Utils.createPackagePath(\"../CommonLibraries/src/\", MarketDataComLib.class)+\"OtcbbSymbols.csv\";\r\n\t\treturn Utils.getCSVData(csvFileName);\r\n\t}\r\n\t\r\n\tpublic static List<String[]> getAllEquityNames(){\r\n\t\tList<String[]> ret = getAmexNames();\r\n\t\tret.addAll(getNasdaqNames());\r\n\t\tret.addAll(getOtcbbNames());\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\r\n\tpublic static Boolean isCall(SecDef optionSecDef){\r\n\t\tif(optionSecDef==null)return null;\r\n\t\tString right = optionSecDef.getRight();\r\n\t\tif(right==null){\r\n\t\t\treturn null;\r\n\t\t}\r\n\t\tif(right.trim().compareTo(\" \")<=0)return null;\r\n\t\tright = right.toUpperCase().substring(0);\r\n\t\tif(right.compareTo(\"C\")==0){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\treturn false;\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static Boolean isCall(String shortName) {\r\n\t\tString callString = DEFAULT_SHORTNAME_SEPARATOR+\"C\"+DEFAULT_SHORTNAME_SEPARATOR;\r\n\t\tif(shortName.contains(callString)) {\r\n\t\t\treturn true;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\t\r\n\tpublic static Boolean isOutOfMoney(SecDef optionSecDef,BigDecimal atm){\r\n\t\tBoolean iscall = isCall(optionSecDef);\r\n\t\tif(iscall==null)return null;\r\n\t\tBigDecimal strike = optionSecDef.getStrike();\r\n\t\tif(iscall){\r\n\t\t\tif(strike.compareTo(atm)>=0){\r\n\t\t\t\treturn true;\r\n\t\t\t}else{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\tif(strike.compareTo(atm)<=0){\r\n\t\t\t\treturn true;\r\n\t\t\t}else{\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t\r\n\tpublic static SecDef swapOptionRight(SecDef optionSecDef){\r\n\t\tBoolean iscall = isCall(optionSecDef);\r\n\t\tif(iscall==null)return null;\r\n\t\tSecDef ret;\r\n\t\tif(iscall){\r\n\t\t\t// make a put\r\n\t\t\tShortNameInfo sni = new ShortNameInfo(optionSecDef.getSymbol(),\r\n\t\t\t\t\toptionSecDef.getSymbolType(),optionSecDef.getExchange(),\r\n\t\t\t\t\toptionSecDef.getCurrency(),\r\n\t\t\t\t\toptionSecDef.getContractYear(),optionSecDef.getContractMonth(),\r\n\t\t\t\t\toptionSecDef.getContractDay(),\"P\",\r\n\t\t\t\t\toptionSecDef.getStrike());\r\n\t\t\t\r\n\t\t\tret = new SecDefSimple(\r\n\t\t\t\t\t\t\tsni.getShortName(),\r\n\t\t\t\t\t\t\tsni,optionSecDef.getExchangeSymbol(),optionSecDef.getExchangePrecision(),\r\n\t\t\t\t\t\t\toptionSecDef.getMinTick(),optionSecDef.getExpiryYear(),optionSecDef.getExpiryMonth(),\r\n\t\t\t\t\t\t\toptionSecDef.getExpiryDay(),optionSecDef.getMultiplier(),optionSecDef.getPrimaryExch()\r\n\t\t\t\t\t\t);\r\n\t\t}else{\r\n\t\t\t// make a call\r\n\t\t\tShortNameInfo sni = new ShortNameInfo(optionSecDef.getSymbol(),\r\n\t\t\t\t\toptionSecDef.getSymbolType(),optionSecDef.getExchange(),\r\n\t\t\t\t\toptionSecDef.getCurrency(),\r\n\t\t\t\t\toptionSecDef.getContractYear(),optionSecDef.getContractMonth(),\r\n\t\t\t\t\toptionSecDef.getExpiryDay(),\"C\",\r\n\t\t\t\t\toptionSecDef.getStrike());\r\n\t\t\t\r\n\t\t\tret = new SecDefSimple(\r\n\t\t\t\t\t\t\tsni.getShortName(),\r\n\t\t\t\t\t\t\tsni,optionSecDef.getExchangeSymbol(),optionSecDef.getExchangePrecision(),\r\n\t\t\t\t\t\t\toptionSecDef.getMinTick(),optionSecDef.getExpiryYear(),optionSecDef.getExpiryMonth(),\r\n\t\t\t\t\t\t\toptionSecDef.getExpiryDay(),optionSecDef.getMultiplier(),optionSecDef.getPrimaryExch()\r\n\t\t\t\t\t\t);\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t/**\r\n\t * Create a map of futures products from the csv file with those products\r\n\t * The key is the symbol.\r\n\t */\r\n\tpublic static Map<String,FuturesProduct> getFuturesProductMapFromCsvFile(){\r\n\t\tMap<String, FuturesProduct> ret = new ConcurrentHashMap<String, FuturesProduct>();\r\n\t\tList<FuturesProduct> list = getFuturesProductListFromCsvFile();\r\n\t\t\tfor(FuturesProduct prod:list){\r\n\t\t\t\tfor(String symbol:prod.getSymbols()){\r\n\t\t\t\t\tret.put(symbol,prod);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\r\n\r\n\tprivate static final String EXCHANGE_PRODUCT_LIST_PATH = \"ExchangeProductList.csv\";\r\n\tpublic static List<FuturesProduct> getFuturesProductListFromCsvFile(){\r\n\t\tList<FuturesProduct> ret = new ArrayList<FuturesProduct>();\r\n\t\tList<String[]> csvData = Utils.getCSVData(FuturesProduct.class, EXCHANGE_PRODUCT_LIST_PATH);\r\n\t\tString[] csvHeader = csvData.get(0);\r\n\r\n \t\tint symbol_col = Utils.getCsvColumnIndex(\"symbol\", csvHeader);\r\n \t\tint contractDescription_col = Utils.getCsvColumnIndex(\"contractDescription\", csvHeader);\r\n \t\tint exchange_col = Utils.getCsvColumnIndex(\"exchange\", csvHeader);\r\n \t\tint monthsAllowed_col = Utils.getCsvColumnIndex(\"monthsAllowed\", csvHeader);\r\n \t\tint ticValue_col = Utils.getCsvColumnIndex(\"ticValue\", csvHeader);\r\n \t\tint pointValue_col = Utils.getCsvColumnIndex(\"pointValue\", csvHeader);\r\n \t\tint notionalContractSize_col = Utils.getCsvColumnIndex(\"notionalContractSize\", csvHeader);\r\n \t\tint minOrderTick_col = Utils.getCsvColumnIndex(\"minOrderTick\", csvHeader);\r\n \t\tint notionalTickSize_col = Utils.getCsvColumnIndex(\"notionalTickSize\", csvHeader);\r\n \t\tint validTypes_col = Utils.getCsvColumnIndex(\"validTypes\", csvHeader);\r\n \t\tint underlyingSymbol_col = Utils.getCsvColumnIndex(\"underlyingSymbol\", csvHeader);\r\n\t\tint spanSymbol_col  = Utils.getCsvColumnIndex(\"spanSymbol\", csvHeader);\r\n \t\t\r\n\t\tfor(int i=1;i<csvData.size();i++){\r\n\t\t\tString[] line = csvData.get(i);\r\n\t\t\t  Set<String> symbols\t;\r\n\t\t\t  String contractDescription;\r\n\t\t\t  SecExchange exchange\t;\r\n\t\t\t  long startTimeInMills=0;\r\n\t\t\t  long endTimeInMills=0;\r\n\t\t\t  String sizeDescription = null\t;\r\n\t\t\t  Set<Integer> monthsAllowed\t;\r\n\t\t\t  BigDecimal ticValue\t;\r\n\t\t\t  BigDecimal pointValue\t;\r\n\t\t\t  BigDecimal notionalContractSize\t;\r\n\t\t\t  BigDecimal minOrderTick\t;\r\n\t\t\t  BigDecimal notionalTickSize;\t\r\n\t\t\t  Set<SecSymbolType> validTypes;\r\n\t\t\t  String underlyingSymbol;\r\n\t\t\t  \r\n\t\t\tString[] validSymbolStrings = line[symbol_col].split(\";\");\r\n\t\t\tsymbols = new HashSet<String>();\r\n\t\t\tfor(String validSymbolString:validSymbolStrings){\r\n\t\t\t\tsymbols.add(validSymbolString);\r\n\t\t\t}\r\n\r\n\t\t\texchange = SecExchange.fromString(line[exchange_col]);\r\n\t\t\tvalidTypes = new HashSet<SecSymbolType>();\r\n\t\t\tcontractDescription = line[contractDescription_col];\r\n\t\t\tfor(String validType:line[validTypes_col].split(\";\")){\r\n\t\t\t\tvalidTypes.add(SecSymbolType.fromString(validType));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tString monthsAllowedString = line[monthsAllowed_col];\r\n\t\t\tmonthsAllowed = new  TreeSet<Integer>();\r\n\t\t\tfor(int j = 0;j<monthsAllowedString.length();j++){\r\n\t\t\t\tString s = monthsAllowedString.substring(j,j+1);\r\n\t\t\t\tmonthsAllowed.add(getMonthNumFromMonthCode(s));\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tnotionalContractSize = new BigDecimal(line[notionalContractSize_col]);\r\n\t\t\tnotionalTickSize = new BigDecimal(line[notionalTickSize_col]);\r\n\t\t\tpointValue = new BigDecimal(line[pointValue_col]);\r\n\t\t\tticValue = notionalTickSize;\r\n\t\t\tminOrderTick = new BigDecimal(line[minOrderTick_col]);\r\n\t\t\tunderlyingSymbol =  line[underlyingSymbol_col];\r\n\t\t\t\r\n\t\t\tString spanSymbol = FuturesProduct.NO_SPAN_SYMBOL;\r\n\t\t\tif(line.length>spanSymbol_col){\r\n\t\t\t\tspanSymbol = line[spanSymbol_col];\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\tFuturesProduct prod = new FuturesProduct(\r\n\t\t\t\t\tsymbols,exchange,validTypes,monthsAllowed,\r\n\t\t\t\t\tcontractDescription,notionalContractSize,notionalTickSize,\r\n\t\t\t\t\tpointValue,ticValue,startTimeInMills,endTimeInMills,minOrderTick,\r\n\t\t\t\t\tsizeDescription,underlyingSymbol,SecCurrency.USD,spanSymbol);\r\n\t\t\tret.add(prod);\r\n\t\t\t\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t\r\n\t\r\n\tpublic static BigDecimal getAtmStrike(SecDef secDef,BigDecimal price, double strikeValToRoundto){\r\n\t\tint prec = secDef.getExchangePrecision();\r\n\t\tBigDecimal strike = Rounding.round_by_xs_decimal(price.doubleValue(), strikeValToRoundto, prec);\r\n\t\treturn strike;\r\n\t}\r\n\t\r\n\r\n\r\n\t\r\n\t\r\n\tpublic static String getOptionsShortnameWoStrikeRight(SecDef optionSd){\r\n\t\tString sep = DEFAULT_SHORTNAME_SEPARATOR;\r\n\t\treturn optionSd.getSymbol()+sep+optionSd.getSymbolType()+sep+optionSd.getExchange().toString()+sep+optionSd.getCurrency().toString()+sep+\r\n\t\t\tYEAR_FORMAT.format(optionSd.getContractYear())+MONTH_FORMAT.format(optionSd.getContractMonth());\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param right - \"C\" or \"P\", depending if you want calls or puts\r\n\t * @param sdList - list of options SecDefs for a particular underlying\r\n\t * @return }@code TreeMap<Long, TreeMap<BigDecimal, SecDef>>} which represents all of the SecDefs for these options\r\n\t * \t\t\tsorted by expiry, and then strike \r\n\t */\r\n\tpublic static TreeMap<Long, TreeMap<BigDecimal, SecDef>> sortSecDefsByExpiryStrike(String right,List<SecDef> sdList){\r\n\t\tTreeMap<Long, TreeMap<BigDecimal, SecDef>> ret = new TreeMap<Long, TreeMap<BigDecimal,SecDef>>();\r\n\t\tfor(int i = 0;i<sdList.size();i++){\r\n\t\t\tSecDef sd = sdList.get(i);\r\n\t\t\tif(sd.getRight().compareTo(right)==0){\r\n\t\t\t\tupdateStrikeSdTreeMap(sd,ret);\r\n\t\t\t}else{\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param sd : SecDef to add\r\n\t * @param rightMap - a TreeMap<Long, TreeMap<BigDecimal, SecDef>> of\r\n\t * \t\t\toptions that have the same right (C or P)\r\n\t */\r\n\tprivate static void updateStrikeSdTreeMap(SecDef sd,\r\n\t\t\tTreeMap<Long, TreeMap<BigDecimal, SecDef>> rightMap){\r\n\t\tlong yyyyMmDd = sd.getExpiryYear()*10000+sd.getExpiryMonth()*100+sd.getExpiryDay();\r\n\t\tif(!rightMap.containsKey(yyyyMmDd)){\r\n\t\t\tTreeMap<BigDecimal, SecDef> newMap = new TreeMap<BigDecimal, SecDef>();\r\n\t\t\trightMap.put(yyyyMmDd, newMap);\r\n\t\t}\r\n\t\tTreeMap<BigDecimal, SecDef> innerMap = rightMap.get(yyyyMmDd);\r\n\t\tinnerMap.put(sd.getStrike(), sd);\r\n\t}\r\n\r\n\t/**\r\n\t * Returns a ComplexQueryResult consisting of the supplied exception and a null result\r\n\t * @param e\r\n\t * @return\r\n\t */\r\n\tpublic static <K> ComplexQueryResult<K> errorRet(Exception e){\r\n\t\treturn new ComplexQueryResult<K>(e, null);\r\n\t}\r\n\t\r\n\t/**\r\n\t * Returns a ComplexQueryResult consisting of the supplied exception and a null result\r\n\t * @param e\r\n\t * @return\r\n\t */\r\n\tpublic static <K> ComplexQueryResult<K> errorRet(Exception e, K dummy){\r\n\t\treturn new ComplexQueryResult<K>(e, null);\r\n\t}\r\n\r\n\t\r\n\t/**\r\n\t * Returns a ComplexQueryResult consisting of the supplied String to be used as an exception message and a null result\r\n\t * @param e\r\n\t * @return\r\n\t */\r\n\tpublic static <K> ComplexQueryResult<K> errorRet(String exceptionMessage){\r\n\t\tException e = Utils.IllState(ComplexQueryResult.class, exceptionMessage);\r\n\t\treturn new ComplexQueryResult<K>(e, null);\r\n\t}\r\n\t\r\n\tpublic static BigDecimal getCallPutFromSecDef(SecDef sd){\r\n\t\tBigDecimal ret = BigDecimal.ZERO;\r\n\t\tif(sd.getRight()!=null&&sd.getRight().compareTo(\"P\")==0){\r\n\t\t\tret = BigDecimal.ONE;\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\r\n\t\r\n\t\r\n\tpublic static Calendar getCalendarOfExpiryFromSecDef(SecDef sd){\r\n\t\tint day = sd.getExpiryDay();\r\n\t\tint month = sd.getExpiryMonth();\r\n\t\tint year = sd.getExpiryYear();\r\n\t\tCalendar ret = Calendar.getInstance();\r\n\t\tret.set(year, month-1,day);\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\t\r\n\tpublic static int getBusinessDaysFromFirstToExpiry(SecDef sd){\r\n\t\tCalendar actualExpiry = getCalendarOfExpiryFromSecDef(sd);\r\n\t\tCalendar firstOfMonthActual = Calendar.getInstance();\r\n\t\tfirstOfMonthActual.set(sd.getContractYear(), sd.getContractMonth()-1,1);\r\n\t\tint totalBusinessDaysInMonthTillExpiry = Dates.getAllBusinessDays(firstOfMonthActual, actualExpiry).size();\r\n\t\treturn totalBusinessDaysInMonthTillExpiry;\r\n\t}\r\n\r\n\t/**\r\n\t * Get a new SecDef at the provided strike based on the supplied base SecDef\r\n\t * @param baseSd\r\n\t * @param strike\r\n\t * @param sdQuery\r\n\t * @return\r\n\t */\r\n\tpublic static SecDef getSecDefAtNewStrike(SecDef baseSd, BigDecimal strike, QueryInterface<String,SecDef> sdQuery){\r\n\t\tint prec = baseSd.getExchangePrecision();\r\n\t\tstrike.setScale(prec, RoundingMode.HALF_EVEN);\r\n\t\tString newShort = baseSd.getExchangeSymbol()+\".\"+baseSd.getSymbolType()+\".\"+baseSd.getExchange()+\".\"+\r\n\t\tbaseSd.getCurrency()+\".\"+(baseSd.getContractYear()*100+baseSd.getContractMonth())+\".\"+baseSd.getRight()+\".\"+strike;\r\n\t\treturn sdQuery.get(newShort, 1, TimeUnit.SECONDS);\r\n\t}\r\n\r\n\tpublic static Double getDte(Calendar today, Calendar expiry){\r\n\t\tlong days = Dates.getDifference(today, expiry, TimeUnit.DAYS)+1l;\r\n\t\treturn new Double(days/365.0);\r\n\t}\r\n\r\n\tpublic static Double getDteFromSd(Calendar today, SecDef sd){\r\n\t\tif(sd == null)return null;\r\n\t\tCalendar c = getCalendarOfExpiryFromSecDef(sd);\r\n\t\t\r\n\t\tlong days = Dates.getDifference(today, c, TimeUnit.DAYS)+1l;\r\n\t\treturn new Double(days/365.0);\r\n\t}\r\n\t\r\n\tpublic static Long getDaysToExpirationFromSd(Calendar today, SecDef sd){\r\n\t\tif(sd == null)return null;\r\n\t\tCalendar c = getCalendarOfExpiryFromSecDef(sd);\r\n\t\t\r\n\t\tlong days = Dates.getDifference(today, c, TimeUnit.DAYS)+1l;\r\n\t\treturn days;\r\n\t}\r\n\r\n\tpublic static double[][] getCorrMatrixFromCqrMap(SecDef[] sds,\r\n\t\t\tMap<String, ComplexQueryResult<BigDecimal>> in) {\r\n\t\tTreeSet<String> ts = new TreeSet<String>();\r\n\t\tTreeSet<String> pairs = new TreeSet<String>();\r\n\t\tList<String> shortList = new ArrayList<String>();\r\n\t\tdouble[][] ret = new double[sds.length][sds.length];\t\t\r\n\t\tfor(int i = 0;i<sds.length;i++){\r\n\t\t\tts.add(sds[i].getShortName());\r\n\t\t\t// fill diagonals\r\n\t\t\tret[i][i] = 1.0;\r\n\t\t\tshortList.add(sds[i].getShortName());\r\n\t\t}\r\n\t\tfor(Entry<String, ComplexQueryResult<BigDecimal>> entry: in.entrySet()){\r\n\t\t\tComplexQueryResult<BigDecimal> cqr = entry.getValue();\r\n\t\t\tif(!cqr.isValidResult())return null;\r\n\t\t\tString[] parts = entry.getKey().split(\"__\");\r\n\t\t\tif(parts.length!=2)return null;\r\n\t\t\tif(shortList.contains(parts[0])&&shortList.contains(parts[1])){\r\n\t\t\t\t\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic TreeSet<String> getUnderlyingShortNamesFromCqrCorrMap(\r\n\t\t\tMap<String, ComplexQueryResult<BigDecimal>>cqrMap){\r\n\t\tTreeSet<String> ret = new TreeSet<String>();\r\n\t\tfor(Entry<String, ComplexQueryResult<BigDecimal>> entry:cqrMap.entrySet()){\r\n\t\t\tString[] split = entry.getKey().split(DEFAULT_CORRELATION_PAIR_SEPARATOR);\r\n\t\t\tret.add(split[0]);\r\n\t\t\tret.add(split[1]);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic static double[][] getCorrMatrixFromBigDecMap(SecDef[] sds,\r\n\t\t\tMap<String, BigDecimal> in) {\r\n\t\tTreeSet<String> ts = new TreeSet<String>();\r\n\t\t\r\n\t\tfor(int i = 0;i<sds.length;i++){\r\n\t\t\tts.add(sds[i].getShortName());\r\n\t\t}\r\n\t\tdouble[][] ret = new double[sds.length][sds.length];\r\n\t\tfor(Entry<String, BigDecimal> entry: in.entrySet()){\r\n\t\t\tBigDecimal value = entry.getValue();\r\n\t\t\tString[] parts = entry.getKey().split(\"__\");\r\n\t\t\tif(parts.length!=2)return null;\r\n\t\t\tint index0 = ts.headSet(parts[0]).size();\r\n\t\t\tint index1 = ts.headSet(parts[1]).size();\r\n\t\t\tret[index0][index1] = value.doubleValue();\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t\r\n\tpublic static boolean isValidComplexQueryResultMap(Map<String, ComplexQueryResult<?>> results,Set<String> snSet){\r\n\t\tboolean allGood = true;\r\n\t\tfor(String sn:snSet){\r\n\t\t\tif(!results.containsKey(sn)){\r\n\t\t\t\tallGood=false;\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif(!results.get(sn).isValidResult()){\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\t\r\n\t\treturn allGood;\r\n\t}\r\n\t\r\n\tpublic static List<String> ComplexQueryResultMapInvalidResults(Map<String, ComplexQueryResult<?>> results){\r\n\t\tList<String> errors = new ArrayList<String>();\r\n\t\tfor(Entry<String, ComplexQueryResult<?>> result:results.entrySet()){\r\n\t\t\tComplexQueryResult<?> cqr = result.getValue();\r\n\t\t\tif(!cqr.isValidResult()){\r\n\t\t\t\terrors.add(cqr.getException().getMessage());\r\n\t\t\t}\r\n\t\t}\r\n\t\tif(errors.size()<1)return null;\r\n\t\treturn errors;\r\n\t}\r\n\r\n\t@SuppressWarnings(\"rawtypes\")\r\n\tpublic static String CqrInvalidResultListString(Map<String,ComplexQueryResult<BigDecimal>> cqrMap){\r\n\t\tList<String> errors = new ArrayList<String>();\r\n\t\tfor(Entry<String, ComplexQueryResult<BigDecimal>> result:cqrMap.entrySet()){\r\n\t\t\tComplexQueryResult<?> cqr = result.getValue();\r\n\t\t\tif(!cqr.isValidResult()){\r\n\t\t\t\terrors.add(cqr.getException().getMessage());\r\n\t\t\t}\r\n\t\t}\r\n\t\tString mess = null;\r\n\t\t\r\n\t\tif(errors.size()>0){\r\n\t\t\tmess = \"\";\r\n\t\t\tfor(String err:errors){\r\n\t\t\t\tmess += err+\";\";\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn mess;\r\n\t}\r\n\t\r\n\tpublic static List<SecDef> getOptionSecDefs(\r\n\t\t\tQueryInterface<String, SecDef> sdQuery,\r\n\t\t\tint timeoutValue, TimeUnit timeUnitType,\r\n\t\t\tString symbol,SecSymbolType symbolType,\r\n\t\t\tSecExchange exchange,SecCurrency currency,\r\n\t\t\tint contractYear,int contractMonth, Integer contractDay,\r\n\t\t\tBigDecimal midPointStrike, BigDecimal strikeDistance, \r\n\t\t\tint numCalls,int numPuts){\r\n\t\r\n\t\tList<SecDef> ret = new ArrayList<SecDef>();\r\n\t\tString right = \"P\";\r\n\t\tfor(int i = numPuts-1;i>=0;i--){\r\n\t\t\tBigDecimal strike = \r\n\t\t\t\t\tmidPointStrike.multiply(strikeDistance).multiply(new BigDecimal(i));\r\n\t\t\tShortNameInfo sni = \r\n\t\t\t\t\tnew ShortNameInfo(\r\n\t\t\t\t\t\t\tsymbol, symbolType, exchange, \r\n\t\t\t\t\t\t\tcurrency, contractYear, contractMonth, \r\n\t\t\t\t\t\t\tnull,right, strike);\r\n\t\t\tString sn = sni.getShortName();\r\n\t\t\tif(sn==null){\r\n\t\t\t\tret.add(null);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tSecDef sd = sdQuery.get(sn, timeoutValue, timeUnitType);\r\n\t\t\tif(sd==null){\r\n\t\t\t\tret.add(null);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tret.add(sd);\r\n\t\t}\r\n\t\t\r\n\t\tright = \"C\";\r\n\t\tfor(int i = 1;i<numCalls;i++){\r\n\t\t\tBigDecimal strike = \r\n\t\t\t\t\tmidPointStrike.multiply(strikeDistance).multiply(new BigDecimal(i));\r\n\t\t\tShortNameInfo sni = \r\n\t\t\t\t\tnew ShortNameInfo(\r\n\t\t\t\t\t\t\tsymbol, symbolType, exchange, \r\n\t\t\t\t\t\t\tcurrency, contractYear, contractMonth, contractDay,\r\n\t\t\t\t\t\t\tright, strike);\r\n\t\t\tString sn = sni.getShortName();\r\n\t\t\tif(sn==null){\r\n\t\t\t\tret.add(null);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tSecDef sd = sdQuery.get(sn, timeoutValue, timeUnitType);\r\n\t\t\tif(sd==null){\r\n\t\t\t\tret.add(null);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tret.add(sd);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic static <I,O> Map<String, ComplexQueryResult<O>> processCqrResult(\r\n\t\t\tSet<String> keySet,\r\n\t\t\tMap<String,ComplexQueryResult<I>> map,\r\n\t\t\tTransformCqrQuery<I,O> transformQuery,\r\n\t\t\tint timeoutValue, TimeUnit timeUnitType){\r\n\t\t\r\n\t\tMap<String, ComplexQueryResult<O>> ret = new HashMap<String, ComplexQueryResult<O>>();\r\n\t\t\r\n\t\tfor(String key:keySet){\r\n\t\t\tif(!map.containsKey(key)){\r\n\t\t\t\tComplexQueryResult<O> cqrErr = \r\n\t\t\t\t\t\terrorRet(key+\" No Input Cqr Found\");\r\n\t\t\t\tret.put(key,cqrErr);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tComplexQueryResult<I> cqrIn = map.get(key);\r\n\t\t\tif(!cqrIn.isValidResult()){\r\n\t\t\t\tComplexQueryResult<O> cqrErr = \r\n\t\t\t\t\t\terrorRet(key+\" \"+cqrIn.getException().getMessage());\r\n\t\t\t\tret.put(key,cqrErr);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tI in = cqrIn.getResult();\r\n\t\t\tTuple<String, I> inTuple = new  Tuple<String, I>(key, in);\r\n\t\t\tComplexQueryResult<O> cqrOut = transformQuery.get(inTuple, timeoutValue, timeUnitType);\r\n\t\t\tif(cqrOut==null){\r\n\t\t\t\tComplexQueryResult<O> cqrErr = \r\n\t\t\t\t\t\terrorRet(key+\" Transform Failed\");\r\n\t\t\t\tret.put(key,cqrErr);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tret.put(key, cqrOut);\r\n\t\t}\r\n\t\treturn ret;\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic abstract static class TransformCqrQuery<I,O> implements \r\n\t\tQueryInterface<Tuple<String, I>, ComplexQueryResult<O>>{\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic static <K,V> Tuple<Boolean,ComplexQueryResult<V>> checkCqr(K key,\r\n\t\t\tMap<K,ComplexQueryResult<V>> cqrMap){\r\n\t\tif(!cqrMap.containsKey(key)){\r\n\t\t\tComplexQueryResult<V> cqr = errorRet(key+\" No value returned from Query\");\r\n\t\t\tTuple<Boolean,ComplexQueryResult<V>> ret = \r\n\t\t\t\t\tnew Tuple<Boolean, ComplexQueryResult<V>>(false, \r\n\t\t\t\t\t\t\tcqr);\r\n\t\t\treturn  ret;\r\n\t\t}\r\n\t\tComplexQueryResult<V> cqrInMap = cqrMap.get(key);\r\n\t\tboolean goodOrBad = true;\r\n\t\tif(!cqrInMap.isValidResult()){\r\n\t\t\tgoodOrBad=false;\r\n\t\t}\r\n\t\tTuple<Boolean,ComplexQueryResult<V>> ret = \r\n\t\t\t\tnew Tuple<Boolean, ComplexQueryResult<V>>(goodOrBad, \r\n\t\t\t\t\t\tcqrInMap);\r\n\t\treturn  ret;\r\n\t}\r\n\t\r\n\tpublic static Long getYYYYMMFromContract(String MYY){\r\n\t\tString contract = MYY.substring(MYY.length()-3,MYY.length());\r\n\t\tInteger month = getMonthNumFromMonthCode(contract.substring(0,1));\r\n\t\tInteger year = Integer.parseInt(contract.substring(1, 3));\r\n\t\treturn Long.parseLong((((year+2000)*100)+month)+\"\");\r\n\t}\r\n\r\n\tpublic static Set<String> getPairNameSet(\r\n\t\t\tSet<String> snSet,\r\n\t\t\tString pairSeparator){\r\n\t\tString ps = pairSeparator;\r\n\t\tif(ps==null){\r\n\t\t\tps = DEFAULT_CORRELATION_PAIR_SEPARATOR;\r\n\t\t}\r\n\t\tSet<String> ret = new TreeSet<String>();\r\n\t\tList<String> orderedList = new ArrayList<String>(new TreeSet<String>(snSet));\r\n\t\tfor(int i = 0;i<snSet.size();i++){\r\n\t\t\tfor(int j = i;j<snSet.size();j++){\r\n\t\t\t\tString pair = orderedList.get(i)+ps+orderedList.get(j);\r\n\t\t\t\tret.add(pair);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\t\r\n\tpublic static <V> Map<String, V> getSubPairMapFromStringSet(\r\n\t\tSet<String> snSet,\r\n\t\tMap<String,V> map,\r\n\t\tString pairSeparator){\r\n\t\tString ps = pairSeparator;\r\n\t\tif(ps==null){\r\n\t\t\tps = DEFAULT_CORRELATION_PAIR_SEPARATOR;\r\n\t\t}\r\n\t\tTreeMap<String, V> ret = new TreeMap<String, V>();\r\n\t\tList<String> orderedList = new ArrayList<String>(new TreeSet<String>(snSet));\r\n\t\tfor(int i = 0;i<orderedList.size();i++ ){\r\n\t\t\tfor(int j = 0;j<orderedList.size();j++){\r\n\t\t\t\tString pair = orderedList.get(i)+ps+orderedList.get(j);\r\n\t\t\t\tif(!map.containsKey(pair))continue;\r\n\t\t\t\tret.put(pair, map.get(pair));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn ret;\r\n\t}\r\n\r\n\t\r\n\tpublic static Map<String,List<String>> getUnderlyingsPerDerivName(\r\n\t\t\tSet<String> derivNames,\r\n\t\t\tDerivativeSetEngine dse,\r\n\t\t\tint timeunitValue,\r\n\t\t\tTimeUnit timeUnit){\r\n\t\tMap<String,List<String>> ret = \r\n\t\t\t\tnew HashMap<String, List<String>>();\r\n\t\t\r\n\t\tQueryManager qm = dse.getQueryManager();\r\n\t\tList<String> orderedDerivNames = new ArrayList<String>(new TreeSet<String>(derivNames));\r\n\t\tSet<String> underDiotNames = new HashSet<String>();\r\n\t\tfor(int i = 0;i<orderedDerivNames.size();i++){\r\n\t\t\tString derivName = orderedDerivNames.get(i);\r\n\t\t\tList<String> underList = new ArrayList<String>();\r\n\t\t\tfor(SecDef sd:qm.getUnderlyingSecDefs(derivName, timeunitValue, timeUnit)){\r\n\t\t\t\tString underName = sd.getShortName();\r\n\t\t\t\tunderList.add(underName);\r\n\t\t\t\tunderDiotNames.add(sd.getShortName());\r\n\t\t\t}\r\n\t\t\tret.put(derivName,underList);\r\n\t\t}\r\n\t\treturn ret;\r\n\t}\r\n\r\n\tpublic static Set<String> getUnderlyingNamesSet(\r\n\t\t\tSet<String> derivNames,\r\n\t\t\tDerivativeSetEngine dse,\r\n\t\t\tint timeunitValue,\r\n\t\t\tTimeUnit timeUnit){\r\n\t\tMap<String, List<String>> underlyingNamesMap = \r\n\t\t\t\tgetUnderlyingsPerDerivName(derivNames, dse, timeunitValue, timeUnit);\r\n\t\tSet<String> underlyingNames = new HashSet<String>();\r\n\t\tfor(Entry<String, List<String>> entry:underlyingNamesMap.entrySet()){\r\n\t\t\tunderlyingNames.addAll(entry.getValue());\r\n\t\t}\r\n\t\treturn underlyingNames;\r\n\t}\r\n}\r\n", "ncorrect behavior and will be lost if\n *     the code is regenerated.\n */\npackage com.mozu.api.contracts.commerceruntime.orders;\n\nimport java.util.List;\nimport java.util.HashMap;\nimport java.io.Serializable;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport org.joda.time.DateTime;\nimport java.io.IOException;\nimport java.lang.ClassNotFoundException;\nimport com.mozu.api.contracts.commerceruntime.orders.OrderValidationMessage;\n\n/**\n *\tProperties of the resulting order validation performed by an order validation capability.\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class OrderValidationResult implements Serializable\n{\n\t// Default Serial Version UID\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * Date and time when the entity was created, represented in UTC Date/Time.\n\t */\n\tprotected  DateTime createdDate;\n\n\tpublic DateTime getCreatedDate() {\n\t\treturn this.createdDate;\n\t}\n\n\tpublic void setCreatedDate(DateTime createdDate) {\n\t\tthis.createdDate = createdDate;\n\t}\n\n\t/**\n\t * The current status of an object. This status is specific to the object including payment (New, Authorized, Captured, Declined, Failed, Voided, Credited, CheckRequested, or RolledBack), discount (Active, Scheduled, or Expired), returns (ReturnAuthorized), tenant, package (Fulfilled or NotFulfilled), application, master and product catalogs, orders (Pending, Submitted, Processing, Pending Review, Closed, or Canceled), and order validation results (Pass, Fail, Error, or Review).\n\t */\n\tprotected  String status;\n\n\tpublic String getStatus() {\n\t\treturn this.status;\n\t}\n\n\tpublic void setStatus(String status) {\n\t\tthis.status = status;\n\t}\n\n\t/**\n\t * Read-only identifier defined by the order validation capability that uniquely identifies this validation operation.\n\t */\n\tprotected  String validationId;\n\n\tpublic String getValidationId() {\n\t\treturn this.validationId;\n\t}\n\n\tpublic void setValidationId(String validationId) {\n\t\tthis.validationId = validationId;\n\t}\n\n\t/**\n\t * Read-only name of this order validator supplied by the capability.\n\t */\n\tprotected  String validatorName;\n\n\tpublic String getValidatorName() {\n\t\treturn this.validatorName;\n\t}\n\n\tpublic void setValidatorName(String validatorName) {\n\t\tthis.validatorName = validatorName;\n\t}\n\n\t/**\n\t * The type of order validator supplied by the capability. At this time, the only supported validator type is Fraud.\n\t */\n\tprotected  String validatorType;\n\n\tpublic String getValidatorType() {\n\t\treturn this.validatorType;\n\t}\n\n\tpublic void setValidatorType(String validatorType) {\n\t\tthis.validatorType = validatorType;\n\t}\n\n\t/**\n\t * Array list of validation and status messages associated with shipping rates, orders, and product purchasable state.\n\t */\n\tprotected List<OrderValidationMessage> messages;\n\tpublic List<OrderValidationMessage> getMessages() {\n\t\treturn this.messages;\n\t}\n\tpublic void setMessages(List<OrderValidationMessage> messages) {\n\t\tthis.messages = messages;\n\t}\n\n\n}\n", ".Presenter.LoginPresenter;\n\nimport javax.inject.Singleton;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n@Module\npublic class PresenterModule {\n\n    @Provides\n    @Singleton\n    LoginPresenter provideLoginPresenter(Context context) {\n        return new LoginPresenter(context);\n    }\n\n}\n\n", "ple class used to introduce abstract classes in the beginners Java course.\n * \n * <p>\n * https://jcoder.io/content/course/java/beginners/ch05/abstract\n * </p>\n * \n * @author Camilo Gonzalez\n */\npublic abstract class NumeralSystem {\n\n    public abstract String convert(int number);\n\n    public void print(int number) {\n        String convertedNumber = convert(number);\n        System.out.println(convertedNumber);\n    }\n\n}\n", "der = new Downloader();\n        downloader.download();\n    }\n\n    public void parse() {\n        Parser parser = new JSONParser();\n        parser.parse();\n    }\n\n}\n", "Scanner(System.in);\n           int n=sc.nextInt();\n           String ans=\"\";\n           if(n%2==1){\n             ans = \"Weird\";\n           }\n           else{\n\n              //Complete the code\n\n           }\n           System.out.println(ans);\n\n       }\n   }\n", "FoundException;\n\n/**\n * This file parser can be used to read from the device's local filesystem\n * Created by Nick on 5/1/2016.\n */\npublic class LocalFileParser extends AbstractFileParser {\n    /**\n     * @param fileUri The URI of the local file\n     * @param fileLoader Callback which runs when the InputStream is gotten\n     * @throws FileNotFoundException\n     */\n    public LocalFileParser(String fileUri, FileLoader fileLoader) throws FileNotFoundException {\n        FileInputStream f = new FileInputStream(fileUri);\n        fileLoader.onFileLoaded(f);\n    }\n}\n", "a.math.MathContext;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\n\n// VM/interpreter for running non standard dc code. Only made to work with code generated by this compiler\npublic class dcVM {\n    private static String prog = \"5\\nsa\\n0 k\\nla\\n5 k\\n3.2\\n+\\nsb\\n0 k\\nlb\\np\\nsi\";\n    //private static String prog = \"5 2.9 + p\";\n    private static Deque<BigDecimal> stack = new ArrayDeque<BigDecimal>();\n    private static List<BigDecimal> registers = new ArrayList<BigDecimal>(26);\n    private static MathContext mc = new MathContext(1);\n\n    public static void main(String[] args) throws Exception {\n        for (int i = 0; i < 26; i++) {\n            registers.add(null);\n        }\n        StreamTokenizer tokenizer = new StreamTokenizer(new StringReader(prog));\n\n        while (tokenizer.nextToken() != StreamTokenizer.TT_EOF) {\n            switch (tokenizer.ttype) {\n                case StreamTokenizer.TT_WORD:\n                    String word = tokenizer.sval;\n                    char opcode = word.charAt(0);\n                    int reg;\n                    switch (opcode) {\n                        case 's':\n                            reg = word.charAt(1) - 'a';\n                            registers.set(reg, stack.pop());\n                            break;\n                        case 'l':\n                            reg = word.charAt(1) - 'a';\n                            stack.push(registers.get(reg));\n                            break;\n                        case 'p':\n                            System.out.print(stack.peek());\n                            break;\n                        case 'k':\n                            mc = new MathContext(stack.pop().intValue() + 1);\n                            break;\n                        default:\n                            System.err.println(\"Unknown opcode: \" + tokenizer);\n                    }\n                    break;\n                case StreamTokenizer.TT_NUMBER:\n                    stack.push(new BigDecimal(tokenizer.nval));\n                    break;\n                case '+':\n                    stack.push(stack.pop().add(stack.pop(), mc));\n                    break;\n                case '-':\n                    stack.push(stack.pop().subtract(stack.pop(), mc));\n                    break;\n                default:\n                    System.err.println(\"Unknown token: \" + tokenizer);\n            }\n        }\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/**\n * @test\n * @bug 7130335 7130335\n * @summary Make sure that round-trip conversion (format/parse) works\n *          with old timestamps in Europe/Moscow and with multiple time zone letters.\n */\nimport java.text.*;\nimport java.util.*;\nimport static java.util.GregorianCalendar.*;\n\npublic class Bug7130335 {\n    private static final TimeZone MOSCOW = TimeZone.getTimeZone(\"Europe/Moscow\");\n    private static final TimeZone LONDON = TimeZone.getTimeZone(\"Europe/London\");\n    private static final TimeZone LA = TimeZone.getTimeZone(\"America/Los_Angeles\");\n    private static final TimeZone[] ZONES = {\n        MOSCOW, LONDON, LA\n    };\n\n    public static void main(String[] args) throws Exception {\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS z\", Locale.US);\n        sdf.setTimeZone(MOSCOW);\n        Calendar cal = new GregorianCalendar(MOSCOW, Locale.US);\n        cal.clear();\n        // Try both +03:00 and +02:00\n        cal.set(1922, SEPTEMBER, 30);\n        test(sdf, cal);\n        cal.add(DAY_OF_YEAR, 1);\n        test(sdf, cal);\n        cal.set(1991, MARCH, 31);\n        // in daylight saving time\n        test(sdf, cal);\n        cal.add(DAY_OF_YEAR, 1);\n        test(sdf, cal);\n        // Try the current timestamp\n        cal.setTimeInMillis(System.currentTimeMillis());\n        test(sdf, cal);\n\n        // tests for multiple time zone letters (8000529)\n        test8000529(\"yyyy-MM-dd HH:mm:ss.SSS Z (z)\");\n        test8000529(\"yyyy-MM-dd HH:mm:ss.SSS Z (zzzz)\");\n        test8000529(\"yyyy-MM-dd HH:mm:ss.SSS z (Z)\");\n        test8000529(\"yyyy-MM-dd HH:mm:ss.SSS zzzz (Z)\");\n\n    }\n\n    private static void test(SimpleDateFormat sdf, Calendar cal) throws Exception {\n        Date d = cal.getTime();\n        String f = sdf.format(d);\n        System.out.println(f);\n        Date pd = sdf.parse(f);\n        String p = sdf.format(pd);\n        if (!d.equals(pd) || !f.equals(p)) {\n            throw new RuntimeException(\"format: \" + f + \", parse: \" + p);\n        }\n    }\n\n    private static void test8000529(String fmt) throws Exception {\n        for (TimeZone tz : ZONES) {\n            SimpleDateFormat sdf = new SimpleDateFormat(fmt, Locale.US);\n            sdf.setTimeZone(tz);\n            Calendar cal = new GregorianCalendar(tz, Locale.US);\n            cal.clear();\n            cal.set(2012, JUNE, 22);\n            test(sdf, cal);\n            cal.set(2012, DECEMBER, 22);\n            test(sdf, cal);\n            cal.setTimeInMillis(System.currentTimeMillis());\n            test(sdf, cal);\n        }\n    }\n}\n", "ort java.util.concurrent.TimeUnit;\n\nimport static org.junit.Assert.*;\n\nimport org.apache.log4j.BasicConfigurator;\nimport org.apache.log4j.Level;\nimport org.apache.log4j.Logger;\nimport org.junit.BeforeClass;\nimport org.junit.Test;\n\nimport com.google.common.collect.Sets;\nimport com.mikehelmick.proc.Message.MessageBuilder;\n\npublic class ProcessManagerTest {\n  private static Logger logger = Logger.getLogger(ProcessManagerTest.class);\n  \n  @BeforeClass\n  public static void setupLogging() {\n    BasicConfigurator.configure();\n    Logger.getRootLogger().setLevel(Level.DEBUG);\n  }\n  \n  @Test\n  public void testHeartbeat() {\n    final CountDownLatch cdl = new CountDownLatch(2);\n    \n    Heartbeat hb = new Heartbeat(cdl);\n    ProcessManager.getInstance().start();\n    \n    while (true) {\n      try {\n        if (cdl.await(10, TimeUnit.SECONDS)) {\n          break;\n        } \n      } catch (InterruptedException iex) {\n        Thread.interrupted();\n      }\n    }\n    \n    ProcessManager.getInstance().shutdown();\n    ProcessManager.reset();\n  }\n\n  private static class Heartbeat extends Proc {\n    final CountDownLatch latch;\n\n    Heartbeat(CountDownLatch latch) {\n      this.latch = latch;\n    }\n    \n    @Override\n    public void tick() {\n      latch.countDown();\n    }\n\n    @Override\n    public void receiveMessage(Message message) {\n      \n    }\n  }\n  \n  @Test\n  public void testPingPong() throws InterruptedException {\n    PingPong p1 = new PingPong(3);\n    PingPong p2 = new PingPong(3);\n    PingPong p3 = new PingPong(3);\n    \n    ProcessManager.getInstance().start();\n    \n    assertTrue(p1.await());\n    assertTrue(p2.await());\n    assertTrue(p3.await());\n    \n    ProcessManager.getInstance().shutdown();\n    ProcessManager.reset();\n  }\n\n  private static class PingPong extends Proc {\n    \n    private final long totalProcs;\n\n    private Set<Long> pongReceived = Sets.newConcurrentHashSet();\n    private final CountDownLatch cdl;\n    \n    private boolean sentPings = false;\n    \n    PingPong(int totalProcs) {\n      this.totalProcs = totalProcs;\n      cdl = new CountDownLatch(totalProcs - 1);\n    }\n    \n    boolean await() throws InterruptedException {\n      cdl.await();// 120, TimeUnit.SECONDS);\n      return true;\n    }\n\n    @Override\n    public void tick() {\n      if (!sentPings) {\n        logger.info(\"Tick, sending pings\");\n        sendAll(MessageBuilder.create().setMessage(\"ping\"));\n        sentPings = true;\n      }\n      logger.info(\"tick, latch: \" + cdl.getCount());\n    }\n\n    @Override\n    public void receiveMessage(Message message) {\n      if (message.getMessage().equals(\"pong\")) {\n        logger.info(getProcessId() + \" received pong from \" + message.getSender());\n        if (pongReceived.add(message.getSender())) {\n          cdl.countDown();\n        }\n      } else if (message.getMessage().equals(\"ping\")) {\n        sendOne(MessageBuilder.create().setMessage(\"pong\"), message.getSender());\n      }\n    }\n    \n  }\n  \n}\n", "r;\nimport java.sql.Date;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.List;\nimport java.util.TimeZone;\n\nimport javax.swing.AbstractAction;\nimport javax.swing.Action;\nimport javax.swing.DefaultComboBoxModel;\nimport javax.swing.JButton;\nimport javax.swing.JCheckBox;\nimport javax.swing.JDialog;\nimport javax.swing.JFileChooser;\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JTextField;\nimport javax.swing.filechooser.FileNameExtensionFilter;\n\nimport SQLExplorer.db.Query;\nimport SQLExplorer.db.tool.Restore;\nimport SQLExplorer.ui.ErrorException;\nimport SQLExplorer.ui.UI;\nimport SQLExplorer.ui.components.FrameFooter;\n\npublic class Import implements ActionListener {\n\n\tpublic UI ui;\n\tprivate JDialog d;\n\tpublic JTextField path, file;\n\tpublic JCheckBox force;\n\n\tpublic Import(UI ui) {\n\t\tthis.ui = ui;\n\t}\n\n\tprivate void renderDialog() {\n\t\td = new JDialog(ui, \"Import Options\", true);\n\t\td.setLayout(null);\n\n\t\tfinal JLabel lforce = new JLabel(\"Skip Errors\");\n\t\tlforce.setBounds(10, 10, 120, 25);\n\t\td.add(lforce);\n\n\t\tforce = new JCheckBox();\n\t\tforce.setBounds(95, 12, 20, 20);\n\t\tforce.setSelected(true);\n\t\td.add(force);\n\n\t\tfinal JLabel lfile = new JLabel(\"File to Import\");\n\t\tlfile.setBounds(10, 40, 120, 25);\n\t\td.add(lfile);\n\n\t\tpath = new JTextField(System.getProperty(\"user.home\"));\n\t\tpath.setBounds(95, 40, 215, 25);\n\t\td.add(path);\n\n\t\tfinal JButton choose = new JButton(\"Choose\");\n\t\tchoose.setBounds(310, 40, 80, 25);\n\t\td.add(choose);\n\n\t\tchoose.addActionListener(new ActionListener() {\n\t\t\t@Override\n\t\t\tpublic void actionPerformed(ActionEvent event) {\t\t\t\t\n\t\t\t\tJFileChooser chooser = TFile.dialog(false);\n\t\t\t\tFileNameExtensionFilter filter = new FileNameExtensionFilter(\n\t\t\t\t        \"SQL\", \"sql\");\n\t\t\t\t    chooser.setFileFilter(filter);\n\t\t\t\tfinal int fch = chooser.showOpenDialog(ui);\n\t\t\t\tif (fch == JFileChooser.APPROVE_OPTION) {\n\t\t\t\t\tpath.setText(chooser.getSelectedFile().toString());\n\t\t\t\t} else if (fch == JFileChooser.CANCEL_OPTION) {\n\t\t\t\t\tchooser.setVisible(false);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tfinal JButton create = new JButton(\"Import\");\n\t\tcreate.setBounds(120, 75, 90, 25);\n\t\td.add(create);\n\t\tcreate.addActionListener(run);\n\n\t\tfinal JButton cancel = new JButton(\"Cancel\");\n\t\tcancel.setBounds(210, 75, 90, 25);\n\t\td.add(cancel);\n\t\tcancel.addActionListener(close);\n\n\t\td.setDefaultCloseOperation(JDialog.DISPOSE_ON_CLOSE);\n\t\td.setResizable(false);\n\t\td.setSize(400, 145);\n\t\td.setLocationRelativeTo(null);\n\t\td.setVisible(true);\n\t}\n\t\n\tprivate void close() {\n\t\td.getContentPane().removeAll();\n\t\td.dispose();\n\t\td = null;\n\t}\n\n\tprivate Action close = new AbstractAction() {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t@Override\n\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\tclose();\n\t\t}\n\t};\n\n\tprivate Action run = new AbstractAction() {\n\n\t\tprivate static final long serialVersionUID = 1L;\n\n\t\t@Override\n\t\tpublic void actionPerformed(ActionEvent e) {\n\t\t\tclose();\n\t\t\tFrameFooter.progress.setVisible(true);\n\t\t\tRestore runner = new Restore(Import.this,\n\t\t\t\t\tSystem.currentTimeMillis());\n\t\t\tnew Thread(runner).start();\n\t\t}\n\t};\n\n\t@Override\n\tpublic void actionPerformed(ActionEvent event) {\n\t\trenderDialog();\n\t}\n\t\n\tpublic void finished(long elapsed) {\n\t\ttry {\n\t\t\t// Rendering new a list of databases\n\t\t\tList<Object> dbs = new Query(ui).listDatabases();\n\t\t\tDefaultComboBoxModel<Object> model = new DefaultComboBoxModel<Object>(\n\t\t\t\t\tdbs.toArray());\n\t\t\tui.database.setModel(model);\n\t\t\tui.database.setSelectedIndex(0);\n\t\t} catch (ErrorException ex) {\n\t\t\tJOptionPane.showMessageDialog(ui, ex.getMessage().toString(),\n\t\t\t\t\t\"Error\", JOptionPane.ERROR_MESSAGE);\n\t\t}\n\t\tDate date = new Date(elapsed);\n\t\tDateFormat formatter = new SimpleDateFormat(\"HH:mm:ss:SSS\");\n\t\tformatter.setTimeZone(TimeZone.getTimeZone(\"UTC\"));\t\t\n\t\tJOptionPane.showMessageDialog(ui,\n\t\t\t\t\"Database restore has been completed successfully.\\nSpent time: \"\n\t\t\t\t\t\t+ formatter.format(date), \"Import Completed\",\n\t\t\t\tJOptionPane.INFORMATION_MESSAGE);\n\t\tFrameFooter.progress.setVisible(false);\t\t\n\t}\n}\n", "\n\n    public double a;\n    public double b;\n\n    public Rectangle(double a, double b){\n        this.a = a;\n        this.b = b;\n    }\n\n    public double area(){\n        return this.a * this.b;\n    }\n}\n", " = true;\n        \n        for (long i = 2; i <= number / i; i++)\n        {\n            if (number % i == 0)\n            {\n                prime = false;\n                break;\n            }\n        }\n        \n        return prime;\n    }\n    \n    public static void main(String[] args)\n    {\n        \n        // Draw a spiral on the screen\n        final int SCALE = 400; // default: 200\n        final double PEN = 0.002; // default: 0.005\n        \n        StdDraw.setXscale(0, SCALE);\n        StdDraw.setYscale(0, SCALE);\n        StdDraw.setPenRadius(PEN);\n        \n        int x = 0, y = 0;\n        \n        int step = 1;\n        int dirX = 1, dirY = 1;\n        \n        // StdDraw.clear();\n        \n        long count = 1;\n        int loops = 0;\n        \n        while (count <= SCALE * SCALE)\n        {            \n            if (loops % 2 == 0)\n            {\n                for (int j = 0; j < step; j++)\n                {\n                    if (isPrime(count))\n                        StdDraw.setPenColor(StdDraw.BLACK);\n                    else\n                        StdDraw.setPenColor(StdDraw.WHITE);\n\n                    StdDraw.point(x + SCALE / 2, y + SCALE / 2);\n                    // StdDraw.show(5);\n                    x += dirX;\n                    count++;\n                }\n                \n                dirX *= -1;\n            }\n            else\n            {\n                for (int j = 0; j < step; j++)\n                {\n                    if (isPrime(count))\n                        StdDraw.setPenColor(StdDraw.BLACK);\n                    else\n                        StdDraw.setPenColor(StdDraw.WHITE);\n\n                    StdDraw.point(x + SCALE / 2, y + SCALE / 2);\n                    //StdDraw.show(5);\n                    y += dirY;\n                    count++;\n                }\n                \n                dirY *= -1;\n                step++;\n            }\n            \n            loops++;\n        }        \n    }\n}", "\nimport com.laytonsmith.abstraction.MCLocation;\nimport com.laytonsmith.core.ObjectGenerator;\nimport com.laytonsmith.core.Static;\nimport com.laytonsmith.core.constructs.CBoolean;\nimport com.laytonsmith.core.constructs.CDouble;\nimport com.laytonsmith.core.constructs.CInt;\nimport com.laytonsmith.core.constructs.CString;\nimport com.laytonsmith.core.constructs.Construct;\nimport com.laytonsmith.core.constructs.Target;\nimport com.laytonsmith.core.exceptions.ConfigRuntimeException;\nimport com.laytonsmith.core.exceptions.PrefilterNonMatchException;\nimport com.laytonsmith.core.functions.Exceptions.ExceptionType;\n\nimport java.util.Map;\n\n/**\n *\n * \n */\npublic final class Prefilters {\n\n    private Prefilters(){}\n\n    public enum PrefilterType{\n        /**\n         * Item matches are fuzzy matches for item notation. Red wool and black wool\n         * will match. Essentially, this match ignores the item's data value when\n         * comparing.\n         */\n\t\tITEM_MATCH,\n\t\t/**\n\t\t * Checks if indexes 'x', 'y', 'z' and 'world' (or 0, 1, 2, 3) of a location array match.\n\t\t * The location is matched via block matching, for instance if the array's x parameter is 1, 1.3 will match.\n\t\t */\n\t\tLOCATION_MATCH,\n\t\t/**\n\t\t * Simple boolean match.\n\t\t */\n\t\tBOOLEAN_MATCH,\n        /**\n         * String matches are just exact string matches.\n         */\n        STRING_MATCH,\n        /**\n         * Math match parses numbers out and checks to see if the numbers\n         * are equivalent. i.e. 1.0 does equal 1.\n         */\n        MATH_MATCH,\n        /**\n         * Regexes allow for more complex matching. A full blown regular expression\n         * is accepted as the argument.\n         */\n        REGEX,\n        /**\n         * An expression allows for more complex numerical matching. Similar to a regex,\n         * but designed for numerical values. This requires WorldEdit in plugins, lib,\n\t\t * or in the server root to function.\n         */\n        EXPRESSION,\n        /**\n         * A macro expression allows for either an exact string match, or a regular expression,\n         * or an expression. It is parsed according to the format of the prefilter. In\n         * general, this should be used most often for things that are not definitively\n         * another type, so as to give scripts more flexibility.\n         */\n        MACRO\n    }\n    \n    public static void match(Map<String, Construct> map, String key,\n            String actualValue, PrefilterType type) throws PrefilterNonMatchException{\n        match(map, key, new CString(actualValue, Target.UNKNOWN), type);\n    }\n    \n    public static void match(Map<String, Construct> map, String key,\n            int actualValue, PrefilterType type) throws PrefilterNonMatchException{\n        match(map, key, new CInt(actualValue, Target.UNKNOWN), type);\n    }\n    \n    public static void match(Map<String, Construct> map, String key,\n            double actualValue, PrefilterType type) throws PrefilterNonMatchException{\n        match(map, key, new CDouble(actualValue, Target.UNKNOWN), type);\n    }\n    \n\tpublic static void match(Map<String, Construct> map, String key,\n\t\t\tboolean actualValue, PrefilterType type) throws PrefilterNonMatchException {\n\t\tmatch(map, key, CBoolean.get(actualValue), type);\n\t}\n    \n\tpublic static void match(Map<String, Construct> map, String key,\n\t\t\tMCLocation actualValue, PrefilterType type) throws PrefilterNonMatchException {\n\t\tmatch(map, key, ObjectGenerator.GetGenerator().location(actualValue, false), type);\n\t}\n    \n    /**\n     * Given a prototype and the actual user provided value, determines if it matches.\n     * If it doesn't, it throws an exception. If the value is not provided, or it does\n     * match, it returns void, which means that the test passed, and the event matches.\n     */\n\tpublic static void match(Map<String, Construct> map, String key,\n\t\t\tConstruct actualValue, PrefilterType type) throws PrefilterNonMatchException{\n\t\tif(map.containsKey(key)){\n\t\t\tswitch(type){\n\t\t\t\tcase ITEM_MATCH:\n\t\t\t\t\tItemMatch(map.get(key), actualValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STRING_MATCH:\n\t\t\t\t\tStringMatch(map.get(key).val(), actualValue.val());\n\t\t\t\t\tbreak;\n\t\t\t\tcase MATH_MATCH:\n\t\t\t\t\tMathMatch(map.get(key), actualValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase EXPRESSION:\n\t\t\t\t\tConstruct exp = map.get(key);\n\t\t\t\t\tif(!exp.val().isEmpty()\n\t\t\t\t\t\t\t&& exp.val().charAt(0) == '(' && exp.val().charAt(exp.val().length() - 1) == ')'){\n\t\t\t\t\t\tExpressionMatch(exp, key, actualValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow ConfigRuntimeException.BuildException(\"Prefilter expecting expression type, and \\\"\"\n\t\t\t\t\t\t\t\t+ exp.val() + \"\\\" does not follow expression format. \"\n\t\t\t\t\t\t\t\t+ \"(Did you surround it in parenthesis?)\",\n\t\t\t\t\t\t\t\tExceptionType.FormatException, exp.getTarget());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase REGEX:\n\t\t\t\t\tString regex = map.get(key).val();\n\t\t\t\t\tif(!regex.isEmpty()\n\t\t\t\t\t\t\t&& regex.charAt(0) == '/' && regex.charAt(regex.length() - 1) == '/'){\n\t\t\t\t\t\tRegexMatch(regex, actualValue);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow ConfigRuntimeException.BuildException(\"Prefilter expecting regex type, and \\\"\"\n\t\t\t\t\t\t\t\t+ regex + \"\\\" does not follow regex format\",\n\t\t\t\t\t\t\t\tExceptionType.FormatException, map.get(key).getTarget());\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase MACRO:\n\t\t\t\t\tMacroMatch(key, map.get(key), actualValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase BOOLEAN_MATCH:\n\t\t\t\t\tBooleanMatch(map.get(key), actualValue);\n\t\t\t\t\tbreak;\n\t\t\t\tcase LOCATION_MATCH:\n\t\t\t\t\tLocationMatch(map.get(key), actualValue);\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n    \n\tprivate static void ItemMatch(Construct item1, Construct item2) throws PrefilterNonMatchException{\n\t\tString i1 = item1.val().split(\":\")[0];\n\t\tString i2 = item2.val().split(\":\")[0];\n\t\tif (!i1.trim().equals(i2)) {\n\t\t\tthrow new PrefilterNonMatchException();\n\t\t}\n\t}\n\n\tprivate static void BooleanMatch(Construct bool1, Construct bool2) throws PrefilterNonMatchException {\n\t\tif (Static.getBoolean(bool1) != Static.getBoolean(bool2)) {\n\t\t\tthrow new PrefilterNonMatchException();\n\t\t}\n\t}\n\n\tprivate static void LocationMatch(Construct location1, Construct location2) throws PrefilterNonMatchException {\n\t\tMCLocation l1 = ObjectGenerator.GetGenerator().location(location1, null, location1.getTarget());\n\t\tMCLocation l2 = ObjectGenerator.GetGenerator().location(location2, null, Target.UNKNOWN);\n\t\tif ((!l1.getWorld().equals(l2.getWorld())) || (l1.getBlockX() != l2.getBlockX()) || (l1.getBlockY() != l2.getBlockY()) || (l1.getBlockZ() != l2.getBlockZ())) {\n\t\t\tthrow new PrefilterNonMatchException();\n\t\t}\n\t}\n\n    private static void StringMatch(String string1, String string2) throws PrefilterNonMatchException{\n        if(!string1.equals(string2)){\n            throw new PrefilterNonMatchException();\n        }\n    }\n    \n    private static void MathMatch(Construct one, Construct two) throws PrefilterNonMatchException{\n        try{\n            double dOne = Static.getNumber(one, Target.UNKNOWN);\n            double dTwo = Static.getNumber(two, Target.UNKNOWN);\n            if(dOne != dTwo){\n                throw new PrefilterNonMatchException();\n            }\n        } catch(ConfigRuntimeException e){\n            throw new PrefilterNonMatchException();\n        }\n    }\n    \n\tprivate static void ExpressionMatch(Construct expression, String key, Construct dvalue) throws PrefilterNonMatchException{\n\t\tString exp = expression.val().substring(1, expression.val().length() - 1);\n\t\tboolean inequalityMode = false;\n\t\tif(exp.contains(\"<\") || exp.contains(\">\") || exp.contains(\"==\")){\n\t\t\tinequalityMode = true;\n\t\t}\n\t\tString eClass = \"com.sk89q.worldedit.internal.expression.Expression\";\n\t\tString errClass = \"com.sk89q.worldedit.internal.expression.ExpressionException\";\n\t\tClass eClazz, errClazz;\n\t\ttry {\n\t\t\teClazz = Class.forName(eClass);\n\t\t\terrClazz = Class.forName(errClass);\n\t\t} catch (ClassNotFoundException cnf) {\n\t\t\tthrow ConfigRuntimeException.BuildException(\"You are missing a required dependency: \" + eClass,\n\t\t\t\t\tExceptionType.PluginInternalException, expression.getTarget(), cnf);\n\t\t}\n\t\ttry {\n\t\t\tObject e = ReflectionUtils.invokeMethod(eClazz, null, \"compile\",\n\t\t\t\t\tnew Class[]{String.class, String[].class}, new Object[]{exp, new String[]{key}});\n\t\t\tdouble val = (double) ReflectionUtils.invokeMethod(eClazz, e, \"evaluate\",\n\t\t\t\t\tnew Class[]{double[].class},\n\t\t\t\t\tnew Object[]{new double[]{Static.getDouble(dvalue, Target.UNKNOWN)}});\n\t\t\tif (inequalityMode) {\n\t\t\t\tif (val == 0) {\n\t\t\t\t\tthrow new PrefilterNonMatchException();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (val != Static.getDouble(dvalue, Target.UNKNOWN)) {\n\t\t\t\t\tthrow new PrefilterNonMatchException();\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (ReflectionUtils.ReflectionException rex) {\n\t\t\tif (rex.getCause().getClass().isAssignableFrom(errClazz)) {\n\t\t\t\tthrow ConfigRuntimeException.BuildException(\"Your expression was invalidly formatted\",\n\t\t\t\t\t\tExceptionType.PluginInternalException, expression.getTarget(), rex.getCause());\n\t\t\t} else {\n\t\t\t\tthrow ConfigRuntimeException.BuildException(rex.getMessage(), ExceptionType.PluginInternalException,\n\t\t\t\t\t\texpression.getTarget(), rex.getCause());\n\t\t\t}\n\t\t}\n\t}\n    \n\tprivate static void RegexMatch(String regex, Construct value) throws PrefilterNonMatchException{\n\t\tregex = regex.substring(1, regex.length() - 1);\n\t\tif(!value.val().matches(regex)){\n\t\t\tthrow new PrefilterNonMatchException();\n\t\t}\n\t}\n    \n\tprivate static void MacroMatch(String key, Construct expression, Construct value) throws PrefilterNonMatchException{\n\t\tif(expression.val().isEmpty()) {\n\t\t\tthrow new PrefilterNonMatchException();\n\t\t} else if (expression.val().charAt(0) == '(' && expression.val().charAt(expression.val().length() - 1) == ')') {\n\t\t\tExpressionMatch(expression, key, value);\n\t\t} else if (expression.val().charAt(0) == '/' && expression.val().charAt(expression.val().length() - 1) == '/') {\n\t\t\tRegexMatch(expression.val(), value);\n\t\t} else {\n\t\t\tStringMatch(expression.val(), value.val());\n\t\t}\n\t}\n}\n", " objects\r\n * \r\n * @author Serjoscha Bassauer\r\n */\r\npackage de.bwv_aachen.dijkstra.controller;\r\n\r\nimport java.io.File;\r\nimport java.io.FileNotFoundException;\r\nimport java.io.FileWriter;\r\nimport java.io.IOException;\r\nimport java.util.HashMap;\r\nimport java.util.Map;\r\n\r\nimport org.json.simple.parser.ParseException;\r\n\r\nimport de.bwv_aachen.dijkstra.gui.ConnectionVisualization;\r\nimport de.bwv_aachen.dijkstra.gui.Mainwindow;\r\nimport de.bwv_aachen.dijkstra.gui.View;\r\nimport de.bwv_aachen.dijkstra.model.BadFileFormatException;\r\nimport de.bwv_aachen.dijkstra.model.ImplListDataModelFactory;\r\nimport de.bwv_aachen.dijkstra.model.ListDataModel;\r\n\r\npublic class Controller {\r\n\r\n    private ListDataModel          model;\r\n    private HashMap<String, View>  views;\r\n\r\n    public final static Controller INSTANCE = new Controller();\r\n\r\n    /**\r\n     * Controller\r\n     * <p>\r\n     * Simple constructor which sets the standard view. The view can be\r\n     * exchanged later.\r\n     */\r\n    private Controller() {\r\n        views = new HashMap<String, View>();\r\n        \r\n        new ConnectionVisualization(this);\r\n        new Mainwindow(this);\r\n    }\r\n    \r\n    public void register(String name, View view) {\r\n        views.put(name, view);\r\n    }\r\n\r\n    /**\r\n     * readFile\r\n     * \r\n     * @param f\r\n     *            The file to read\r\n     *            <p>\r\n     *            Reads a file for the data model factory\r\n     */\r\n    public void readFile(File f) throws FileNotFoundException, IOException,\r\n            ParseException, BadFileFormatException {\r\n        model = ImplListDataModelFactory.INSTANCE.factory(f);\r\n    }\r\n\r\n    /**\r\n     * writeFile\r\n     * \r\n     * @param f\r\n     *            The file to read\r\n     *            <p>\r\n     *            Writes a file from the data model factory\r\n     */\r\n    public void writeFile(File f) throws FileNotFoundException, IOException,\r\n            BadFileFormatException {\r\n        FileWriter writer;\r\n\r\n        if (!f.exists()) {\r\n            f.createNewFile();\r\n        }\r\n\r\n        writer = new FileWriter(f);\r\n\r\n        // f.setWritable(true);\r\n\r\n        model.writeJSONString(writer);\r\n\r\n        writer.close();\r\n    }\r\n\r\n    public ListDataModel getModel() {\r\n        return model;\r\n    }\r\n    \r\n    public View getView(String name) {\r\n        return views.get(name);\r\n    }\r\n    \r\n    public void drawView(String name) {\r\n        getView(name).draw();\r\n    }\r\n\r\n\r\n    /**\r\n     * main\r\n     * <p>\r\n     * The main method, starts the program\r\n     */\r\n    public static void main(String[] args) {\r\n        INSTANCE.drawView(\"MainWindow\");\r\n    }\r\n\r\n    public File getDefaultConnectionFile() {\r\n        return new File(\"test/testconnection.json\");\r\n    }\r\n\r\n    public void command(String command) {\r\n        switch(command) {\r\n        case \"AirportListChanged\" : {\r\n            for(Map.Entry<String, View> view : views.entrySet()) {\r\n                switch(view.getKey()) {\r\n                    case(\"MainWindow\") :\r\n                    case(\"EditorWindow\") :\r\n                    {\r\n                        //View neu zeichnen\r\n                        view.getValue().draw();\r\n                    }\r\n                }\r\n            }\r\n            break;\r\n        }\r\n    }\r\n        \r\n    }\r\n\r\n}\r\n", "tion and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * \r\n * 3. Products derived from the software may not be called \"Alice\",\r\n *    nor may \"Alice\" appear in their name, without prior written\r\n *    permission of Carnegie Mellon University.\r\n * \r\n * 4. All advertising materials mentioning features or use of this software\r\n *    must display the following acknowledgement:\r\n *    \"This product includes software developed by Carnegie Mellon University\"\r\n */\r\n\r\npackage edu.cmu.cs.stage3.util.criterion;\r\n\r\npublic class MatchesAnyCriterion implements edu.cmu.cs.stage3.util.Criterion {\r\n\tprotected edu.cmu.cs.stage3.util.Criterion[] m_criteria;\r\n\r\n\tpublic MatchesAnyCriterion( edu.cmu.cs.stage3.util.Criterion[] criteria ) {\r\n\t\tm_criteria = criteria;\r\n\t}\r\n\r\n\tpublic boolean accept( Object o ) {\r\n\t\tif( m_criteria != null ) {\r\n\t\t\tfor( int i = 0; i < m_criteria.length; i++ ) {\r\n\t\t\t\tif( m_criteria[i].accept( o ) ) {\r\n\t\t\t\t\treturn true;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n", "ang. The Four Group.\n */\n\npackage org.sogyf.example.model;\n\n/**\n * <p>\n * .\n * </p>\n *\n * @author sagyf yang\n * @version 1.0 2014-02-08 20:45\n * @since JDK 1.6\n */\npublic class Saying {\n\n    private final long id;\n\n    private final String content;\n\n\n    public Saying(long id, String content) {\n        this.id = id;\n        this.content = content;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public String getContent() {\n        return content;\n    }\n}\n", "classification.ClassificationLabelGeneratorManagerService;\r\nimport hu.bme.aait.hermes.dialog.web.dto.message.ServerClassificationMessage;\r\n\r\nimport org.apache.log4j.Logger;\r\nimport org.springframework.beans.factory.annotation.Autowired;\r\nimport org.springframework.stereotype.Service;\r\nimport org.springframework.web.socket.WebSocketSession;\r\n\r\nimport com.google.gson.Gson;\r\nimport com.google.gson.GsonBuilder;\r\n\r\n@Service\r\npublic class ClassificationLabelProviderService extends BaseProviderService{\r\n\tfinal static Logger LOG = Logger.getLogger(ClassificationLabelProviderService.class);\r\n\r\n\t@Autowired\r\n\tprivate ClassificationLabelGeneratorManagerService classificationLabelGeneratorManagerService;\r\n\r\n\tpublic void sendLabels(WebSocketSession session, Long projectId, Long ownerId) {\r\n\t\tServerClassificationMessage serverClassificationMessage = new ServerClassificationMessage();\r\n\r\n\t\ttry {\r\n\t\t\tserverClassificationMessage.setProjectClassifications(classificationLabelGeneratorManagerService.getClassifiactionLabelsForProject(projectId, ownerId));\r\n\t\t\tserverClassificationMessage.setProjectId(projectId);\r\n\t\t} catch (Exception e) {\r\n\t\t\tLOG.error(\"Error during project classification\", e);\r\n\t\t}\r\n\r\n\t\tGson gson = new GsonBuilder().create();\r\n\t\tsendTextMessage(session, gson.toJson(serverClassificationMessage));\r\n\t}\r\n}\r\n", "rowable {\n}\n", "= y;\n\n//https://pt.stackoverflow.com/q/110798/101\n", "\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n\t@Test\n\tpublic void addition_isCorrect() throws Exception {\n\t\tassertEquals(4, 2 + 2);\n\t}\n}", "s.MultiThreaded;\nimport forklift.decorators.OnMessage;\nimport forklift.decorators.Producer;\nimport forklift.integration.server.TestServiceManager;\nimport forklift.producers.ForkliftProducerI;\nimport forklift.schemas.AvroMessage;\nimport forklift.source.decorators.Queue;\n\nimport org.junit.jupiter.api.AfterAll;\nimport org.junit.jupiter.api.BeforeAll;\nimport org.junit.jupiter.api.BeforeEach;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport static org.junit.jupiter.api.Assertions.assertTrue;\n\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\n\n/**\n * Abstract class which provides support for some common integration testing scenarios.\n * <pre>\n *     1.  Starts up and exposes a TestService Manager at the start of every test.\n *         The testServiceManager starts up embedded Zookeeper, Kafka, and Schema-Registry servers\n *     2.  Various Consumer classes\n *     3.  sentMessageIds and consumedMessageIds.  Implementing classes should ensure that they\n *         populate the sentMessageIds set.\n *     4.  The messageAsserts function which provides some useful output and asserts that the sentMessageIds set\n *         and consumedMessageIds set are equal.\n * </pre>\n *\n */\npublic abstract class BaseIntegrationTest {\n    protected static final Logger log = LoggerFactory.getLogger(BaseIntegrationTest.class);\n    protected static Set<String> sentMessageIds = ConcurrentHashMap.newKeySet();\n    protected static Set<String> consumedMessageIds = ConcurrentHashMap.newKeySet();\n    protected static TestServiceManager serviceManager;\n    protected final int maxTimeouts = 5;\n    protected int timeouts = 0;\n\n    @AfterAll\n    public static void after() {\n        serviceManager.stop();\n    }\n\n    @BeforeEach\n    public void setupMaps() {\n        sentMessageIds = ConcurrentHashMap.newKeySet();\n        consumedMessageIds = ConcurrentHashMap.newKeySet();\n    }\n\n    @BeforeAll\n    public static void setup() {\n        serviceManager = new TestServiceManager();\n        serviceManager.start();\n    }\n\n    protected void messageAsserts(){\n        log.info(\"SentIds: \" + sentMessageIds.size() + \" consumedIds: \" + consumedMessageIds.size());\n        assertTrue(sentMessageIds.equals(consumedMessageIds));\n        assertTrue(sentMessageIds.size() > 0);\n    }\n\n\n    @Queue(\"forklift-string-topic\")\n    public static class StringConsumer {\n\n        @forklift.decorators.Message\n        private ForkliftMessage forkliftMessage;\n\n        @forklift.decorators.Message\n        private String value;\n\n        @Producer(queue = \"forklift-string-topic\")\n        private ForkliftProducerI injectedProducer;\n\n        @OnMessage\n        public void onMessage() {\n            if (value == null) {\n                return;\n            }\n            consumedMessageIds.add(forkliftMessage.getId());\n        }\n    }\n\n    @MultiThreaded(10)\n    @Queue(\"forklift-string-topic\")\n    public static class MultiThreadedStringConsumer {\n\n        @forklift.decorators.Message\n        private ForkliftMessage forkliftMessage;\n\n        @forklift.decorators.Message\n        private String value;\n\n        @Producer(queue = \"forklift-string-topic\")\n        private ForkliftProducerI injectedProducer;\n\n        @OnMessage\n        public void onMessage() {\n            if (value == null) {\n                return;\n            }\n            consumedMessageIds.add(forkliftMessage.getId());\n        }\n    }\n\n    @Queue(\"forklift-object-topic\")\n    public static class ForkliftObjectConsumer {\n\n        @forklift.decorators.Message\n        private ForkliftMessage forkliftMessage;\n\n        @forklift.decorators.Message\n        private TestMessage testMessage;\n\n        @Producer(queue = \"forklift-string-topic\")\n        private ForkliftProducerI injectedProducer;\n\n        @OnMessage\n        public void onMessage() {\n            if (testMessage == null || testMessage.getText() == null) {\n                return;\n            }\n            consumedMessageIds.add(forkliftMessage.getId());\n        }\n    }\n\n    @Queue(\"forklift-map-topic\")\n    public static class ForkliftMapConsumer {\n\n        @forklift.decorators.Message\n        private ForkliftMessage forkliftMessage;\n\n        @forklift.decorators.Message\n        private Map<String, String> mapMessage;\n\n        @Producer(queue = \"forklift-string-topic\")\n        private ForkliftProducerI injectedProducer;\n\n        @OnMessage\n        public void onMessage() {\n            if (mapMessage == null || mapMessage.size() == 0) {\n                return;\n            }\n            consumedMessageIds.add(forkliftMessage.getId());\n        }\n    }\n\n    @Queue(\"forklift-avro-topic\")\n    public static class ForkliftAvroConsumer {\n\n        @forklift.decorators.Message\n        private ForkliftMessage forkliftMessage;\n\n        @forklift.decorators.Message\n        private AvroMessage value;\n\n        @Producer(queue = \"forklift-avro-topic\")\n        private ForkliftProducerI injectedProducer;\n\n        @OnMessage\n        public void onMessage() {\n            if (value == null) {\n                return;\n            }\n            consumedMessageIds.add(forkliftMessage.getId());\n        }\n    }\n}\n", "ase;\n\n/**\n * <a href=\"http://d.android.com/tools/testing/testing_android.html\">Testing Fundamentals</a>\n */\npublic class ApplicationTest extends ApplicationTestCase<Application> {\n    public ApplicationTest() {\n        super(Application.class);\n    }\n}", "tool from the resource data it found.  It\n * should not be modified by hand.\n */\n\npackage course.labs.locationlab;\n\npublic final class R {\n    public static final class attr {\n    }\n    public static final class drawable {\n        public static final int ic_launcher=0x7f020000;\n        public static final int stub=0x7f020001;\n    }\n    public static final class id {\n        public static final int country_name=0x7f070004;\n        public static final int delete_badges=0x7f070005;\n        public static final int flag=0x7f070001;\n        public static final int footer=0x7f070000;\n        public static final int place_name=0x7f070003;\n        public static final int place_no_country=0x7f070007;\n        public static final int place_one=0x7f070006;\n        public static final int place_two=0x7f070008;\n        public static final int text_desc=0x7f070002;\n    }\n    public static final class layout {\n        public static final int footer_view=0x7f030000;\n        public static final int place_badge_view=0x7f030001;\n    }\n    public static final class menu {\n        public static final int main=0x7f060000;\n    }\n    public static final class string {\n        public static final int app_name=0x7f040000;\n        public static final int berwyn_string=0x7f040009;\n        public static final int delete=0x7f040002;\n        public static final int duplicate_location_string=0x7f04000a;\n        public static final int flag_image_desc_string=0x7f04000b;\n        public static final int footer_text=0x7f040001;\n        public static final int mock_name_united_states_string=0x7f040007;\n        public static final int no_country_string=0x7f040006;\n        public static final int place_no_country=0x7f040004;\n        public static final int place_one=0x7f040003;\n        public static final int place_two=0x7f040005;\n        public static final int the_greenhouse_string=0x7f040008;\n    }\n    public static final class style {\n        /**\n        Base application theme, dependent on API level. This theme is replaced\n        by AppBaseTheme from res/values-vXX/styles.xml on newer devices.\n\n\n            Theme customizations available in newer API levels can go in\n            res/values-vXX/styles.xml, while customizations related to\n            backward-compatibility can go here.\n\n\n        Base application theme for API 11+. This theme completely replaces\n        AppBaseTheme from res/values/styles.xml on API 11+ devices.\n\n API 11 theme customizations can go here.\n\n        Base application theme for API 14+. This theme completely replaces\n        AppBaseTheme from BOTH res/values/styles.xml and\n        res/values-v11/styles.xml on API 14+ devices.\n\n API 14 theme customizations can go here.\n         */\n        public static final int AppBaseTheme=0x7f050000;\n        /**  Application theme.\n All customizations that are NOT specific to a particular API-level can go here.\n         */\n        public static final int AppTheme=0x7f050001;\n    }\n}\n", "ist;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.text.DecimalFormat;\n\n/**\n * 02/19/2017\n * MonopolyOdds.java\n * Monopoly odds\n *\n * @author Scott Wiedemann\n *\n */\npublic class MonopolyOdds {\n\n\t// Dice Sidedness\n\tprivate final int N;\n\tprivate final List<String> board;\n\tprivate final int boardLength;\n\tprivate final Map<String, RuleSet> ruleSets;\n\n\tpublic MonopolyOdds(int N) {\n\t\tthis.N = N;\n\t\tthis.board = new ArrayList<>(Arrays.asList(\"GO\", \"A1\", \"CC1\", \"A2\", \"T1\", \"R1\", \"B1\", \"CH1\", \"B2\", \"B3\", \"JAIL\", \"C1\", \"U1\", \"C2\", \"C3\", \"R2\", \"D1\", \"CC2\", \"D2\", \"D3\", \"FP\", \"E1\", \"CH2\", \"E2\", \"E3\", \"R3\", \"F1\", \"F2\", \"U2\", \"F3\", \"G2J\", \"G1\", \"G2\", \"CC3\", \"G3\", \"R4\", \"CH3\", \"H1\", \"T2\", \"H2\"));\n\t\tthis.boardLength = this.board.size();\n\t\tthis.ruleSets = new HashMap<>();\n\n\t\tRuleSet G2J = new RuleSet(\"G2J\", 1);\n\t\tG2J.rules.add(new Rule(this.board.indexOf(\"JAIL\")));\n\n\t\tthis.ruleSets.put(G2J.space, G2J);\n\n\t\tRuleSet CC = new RuleSet(\"CC\", 16);\n\t\tCC.rules.add(new Rule(this.board.indexOf(\"GO\")));\n\t\tCC.rules.add(new Rule(this.board.indexOf(\"JAIL\")));\n\n\t\tthis.ruleSets.put(CC.space, CC);\n\n\t\tRuleSet CH = new RuleSet(\"CH\", 16);\n\t\tCH.rules.add(new Rule(this.board.indexOf(\"GO\")));\n\t\tCH.rules.add(new Rule(this.board.indexOf(\"JAIL\")));\n\t\tCH.rules.add(new Rule(this.board.indexOf(\"C1\")));\n\t\tCH.rules.add(new Rule(this.board.indexOf(\"E3\")));\n\t\tCH.rules.add(new Rule(this.board.indexOf(\"H2\")));\n\t\tCH.rules.add(new Rule(this.board.indexOf(\"R1\")));\n\t\tCH.rules.add(new Rule(-1) {\n\t\t\t@Override\n\t\t\tpublic int apply(int currentSquare, List<String> board) {\n\t\t\t\tfor(int i = currentSquare+1; ; i=(i+1)%board.size()) {\n\t\t\t\t\tif(board.get(i).startsWith(\"R\")) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tCH.rules.add(new Rule(-1) {\n\t\t\t@Override\n\t\t\tpublic int apply(int currentSquare, List<String> board) {\n\t\t\t\tfor(int i = currentSquare+1; ; i=(i+1)%board.size()) {\n\t\t\t\t\tif(board.get(i).startsWith(\"R\")) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tCH.rules.add(new Rule(-1) {\n\t\t\t@Override\n\t\t\tpublic int apply(int currentSquare, List<String> board) {\n\t\t\t\tfor(int i = currentSquare+1; ; i=(i+1)%board.size()) {\n\t\t\t\t\tif(board.get(i).startsWith(\"U\")) {\n\t\t\t\t\t\treturn i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\tCH.rules.add(new Rule(-1) {\n\t\t\t@Override\n\t\t\tpublic int apply(int currentSquare, List<String> board) {\n\t\t\t\treturn (currentSquare-3)%board.size();\n\t\t\t}\n\t\t});\n\n\t\tthis.ruleSets.put(CH.space, CH);\n\t}\n\n\tprivate int roll() {\n\t\treturn (int)Math.min(Math.random()*N + 1, N);\n\t}\n\n\tprivate RuleSet getRuleSet(int currentSquare) {\n\t\tRuleSet ruleSet = null;\n\t\tString currentSpace = this.board.get(currentSquare);\n\t\tString prefix = currentSpace.substring(0, currentSpace.length()-1);\n\t\tString index = currentSpace;\n\t\tif(prefix.equals(\"CC\") || prefix.equals(\"CH\")) {\n\t\t\tindex = prefix;\n\t\t}\n\n\t\treturn this.ruleSets.get(index);\n\t}\n\n\tpublic String solve() {\n\t\tString solution = \"\";\n\n\t\tfinal int numberOfRolls = 10000000;\n\t\tint[] odds = new int[this.boardLength];\n\n\t\tint doublesCount = 0;\n\t\tfor(int i=0, currentSquare = 0; i<numberOfRolls; i++) {\n\t\t\todds[currentSquare]++;\n\t\t\tint dieOne = this.roll();\n\t\t\tint dieTwo = this.roll();\n\t\t\tif(dieOne == dieTwo) {\n\t\t\t\tdoublesCount++;\n\t\t\t} else {\n\t\t\t\tdoublesCount = 0;\n\t\t\t}\n\t\t\tif(doublesCount == 3) {\n\t\t\t\tdoublesCount = 0;\n\t\t\t\tcurrentSquare = this.board.indexOf(\"JAIL\");\n\t\t\t} else {\n\t\t\t\tint sumDice = dieOne + dieTwo;\n\t\t\t\tcurrentSquare += sumDice;\n\t\t\t\tcurrentSquare %= this.boardLength;\n\t\t\t}\n\n\t\t\tRuleSet ruleSet = this.getRuleSet(currentSquare);\n\t\t\twhile(ruleSet != null) {\n\t\t\t\tint newSquare = ruleSet.apply(currentSquare, this.board);\n\t\t\t\tif(newSquare == currentSquare) {\n\t\t\t\t\truleSet = null;\n\t\t\t\t} else {\n\t\t\t\t\tcurrentSquare = newSquare;\n\t\t\t\t\truleSet = this.getRuleSet(currentSquare);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tList<SquareOdd> squareOdds = new ArrayList<>();\n\t\tfor(int i=0; i<odds.length; i++) {\n\t\t\tsquareOdds.add(new SquareOdd(i, (((double)odds[i])/numberOfRolls)));\n\t\t}\n\t\tCollections.sort(squareOdds);\n\n\t\tDecimalFormat df = new DecimalFormat(\"0.00\");\n\t\tint s = 0;\n\t\tfor(SquareOdd squareOdd : squareOdds) {\n\t\t\tSystem.out.println(board.get(squareOdd.square) + \" \" + df.format(100*squareOdd.odds) + \"%\");\n\t\t\tif(s < 3) {\n\t\t\t\tsolution += String.format(\"%02d\", squareOdd.square);\n\t\t\t}\n\t\t\ts++;\n\t\t}\n\n\t\treturn solution;\n\t}\n\n\tpublic static void main(String[] args) {\n\t\tif (args.length != 1) {\n\t\t\tSystem.err.println(\"Incorrect number of arguments.\");\n\t\t\tSystem.err.println(\"Usage: ./monopolyodds.jar N\");\n\t\t\tSystem.exit(1);\n\t\t}\n\t\tfinal int N = Integer.parseInt(args[0]);\n\n\t\tSystem.out.println(new MonopolyOdds(N).solve());\n\t}\n}\n", "ackend;\nimport cucumber.runtime.HookDefinition;\nimport cucumber.runtime.Runtime;\nimport cucumber.runtime.RuntimeGlue;\nimport cucumber.runtime.RuntimeOptions;\nimport cucumber.runtime.StepDefinitionMatch;\nimport cucumber.runtime.TestHelper;\nimport cucumber.runtime.Utils;\nimport cucumber.runtime.io.ClasspathResourceLoader;\nimport cucumber.runtime.model.CucumberFeature;\nimport gherkin.I18n;\nimport gherkin.formatter.model.Feature;\nimport gherkin.formatter.model.Match;\nimport gherkin.formatter.model.Result;\nimport gherkin.formatter.model.Scenario;\nimport gherkin.formatter.model.Step;\nimport gherkin.formatter.model.Tag;\n\nimport org.custommonkey.xmlunit.Diff;\nimport org.custommonkey.xmlunit.XMLUnit;\nimport org.junit.Test;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.stubbing.Answer;\nimport org.xml.sax.SAXException;\n\nimport javax.xml.parsers.ParserConfigurationException;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.PrintWriter;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Scanner;\nimport java.util.Set;\n\nimport junit.framework.AssertionFailedError;\n\nimport static java.util.Arrays.asList;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyCollectionOf;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.argThat;\nimport static org.mockito.Mockito.doAnswer;\nimport static org.mockito.Mockito.doThrow;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class JUnitFormatterTest {\n\n    @Test\n    public void featureSimpleTest() throws Exception {\n        File report = runFeaturesWithJunitFormatter(asList(\"cucumber/runtime/formatter/JUnitFormatterTest_1.feature\"));\n        assertXmlEqual(\"cucumber/runtime/formatter/JUnitFormatterTest_1.report.xml\", report);\n    }\n\n    @Test\n    public void featureWithBackgroundTest() throws Exception {\n        File report = runFeaturesWithJunitFormatter(asList(\"cucumber/runtime/formatter/JUnitFormatterTest_2.feature\"));\n        assertXmlEqual(\"cucumber/runtime/formatter/JUnitFormatterTest_2.report.xml\", report);\n    }\n\n    @Test\n    public void featureWithOutlineTest() throws Exception {\n        File report = runFeaturesWithJunitFormatter(asList(\"cucumber/runtime/formatter/JUnitFormatterTest_3.feature\"));\n        assertXmlEqual(\"cucumber/runtime/formatter/JUnitFormatterTest_3.report.xml\", report);\n    }\n\n    @Test\n    public void featureSimpleStrictTest() throws Exception {\n        boolean strict = true;\n        File report = runFeaturesWithJunitFormatter(asList(\"cucumber/runtime/formatter/JUnitFormatterTest_1.feature\"), strict);\n        assertXmlEqual(\"cucumber/runtime/formatter/JUnitFormatterTest_1_strict.report.xml\", report);\n    }\n\n    @Test\n    public void should_format_passed_scenario() throws Throwable {\n        CucumberFeature feature = TestHelper.feature(\"path/test.feature\",\n                \"Feature: feature name\\n\" +\n                \"  Scenario: scenario name\\n\" +\n                \"    Given first step\\n\" +\n                \"    When second step\\n\" +\n                \"    Then third step\\n\");\n        Map<String, String> stepsToResult = new HashMap<String, String>();\n        stepsToResult.put(\"first step\", \"passed\");\n        stepsToResult.put(\"second step\", \"passed\");\n        stepsToResult.put(\"third step\", \"passed\");\n\n        String formatterOutput = runFeatureWithJUnitFormatter(feature, stepsToResult);\n\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite tests=\\\"1\\\" failures=\\\"0\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <system-out><![CDATA[\" +\n                \"Given first step............................................................passed\\n\" +\n                \"When second step............................................................passed\\n\" +\n                \"Then third step.............................................................passed\\n\" +\n                \"]]></system-out>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(formatterOutput));\n    }\n\n    @Test\n    public void should_format_pending_scenario() throws Throwable {\n        CucumberFeature feature = TestHelper.feature(\"path/test.feature\",\n                \"Feature: feature name\\n\" +\n                \"  Scenario: scenario name\\n\" +\n                \"    Given first step\\n\" +\n                \"    When second step\\n\" +\n                \"    Then third step\\n\");\n        Map<String, String> stepsToResult = new HashMap<String, String>();\n        stepsToResult.put(\"first step\", \"pending\");\n        stepsToResult.put(\"second step\", \"skipped\");\n        stepsToResult.put(\"third step\", \"undefined\");\n\n        String formatterOutput = runFeatureWithJUnitFormatter(feature, stepsToResult);\n\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite tests=\\\"1\\\" failures=\\\"0\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <skipped><![CDATA[\" +\n                \"Given first step............................................................pending\\n\" +\n                \"When second step............................................................skipped\\n\" +\n                \"Then third step.............................................................undefined\\n\" +\n                \"]]></skipped>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(formatterOutput));\n    }\n\n    @Test\n    public void should_format_failed_scenario() throws Throwable {\n        CucumberFeature feature = TestHelper.feature(\"path/test.feature\",\n                \"Feature: feature name\\n\" +\n                \"  Scenario: scenario name\\n\" +\n                \"    Given first step\\n\" +\n                \"    When second step\\n\" +\n                \"    Then third step\\n\");\n        Map<String, String> stepsToResult = new HashMap<String, String>();\n        stepsToResult.put(\"first step\", \"passed\");\n        stepsToResult.put(\"second step\", \"passed\");\n        stepsToResult.put(\"third step\", \"failed\");\n\n        String formatterOutput = runFeatureWithJUnitFormatter(feature, stepsToResult);\n\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite tests=\\\"1\\\" failures=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <failure message=\\\"the stack trace\\\"><![CDATA[\" +\n                \"Given first step............................................................passed\\n\" +\n                \"When second step............................................................passed\\n\" +\n                \"Then third step.............................................................failed\\n\" +\n                \"\\n\" +\n                \"StackTrace:\\n\" +\n                \"the stack trace\" +\n                \"]]></failure>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(formatterOutput));\n    }\n\n    @Test\n    public void should_handle_failure_in_before_hook() throws Throwable {\n        CucumberFeature feature = TestHelper.feature(\"path/test.feature\",\n                \"Feature: feature name\\n\" +\n                \"  Scenario: scenario name\\n\" +\n                \"    Given first step\\n\" +\n                \"    When second step\\n\" +\n                \"    Then third step\\n\");\n        Map<String, String> stepsToResult = new HashMap<String, String>();\n        stepsToResult.put(\"first step\", \"passed\");\n        stepsToResult.put(\"second step\", \"passed\");\n        stepsToResult.put(\"third step\", \"passed\");\n        Set<String> hooksFailures = new HashSet<String>();\n        hooksFailures.add(\"before\");\n\n        String formatterOutput = runFeatureWithJUnitFormatter(feature, stepsToResult, hooksFailures);\n\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite tests=\\\"1\\\" failures=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <failure message=\\\"the stack trace\\\"><![CDATA[\" +\n                \"Given first step............................................................skipped\\n\" +\n                \"When second step............................................................skipped\\n\" +\n                \"Then third step.............................................................skipped\\n\" +\n                \"\\n\" +\n                \"StackTrace:\\n\" +\n                \"the stack trace\" +\n                \"]]></failure>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(formatterOutput));\n    }\n\n    @Test\n    public void should_handle_failure_in_before_hook_with_background() throws Throwable {\n        CucumberFeature feature = TestHelper.feature(\"path/test.feature\",\n                \"Feature: feature name\\n\" +\n                \"  Background: background name\\n\" +\n                \"    Given first step\\n\" +\n                \"  Scenario: scenario name\\n\" +\n                \"    When second step\\n\" +\n                \"    Then third step\\n\");\n        Map<String, String> stepsToResult = new HashMap<String, String>();\n        stepsToResult.put(\"first step\", \"passed\");\n        stepsToResult.put(\"second step\", \"passed\");\n        stepsToResult.put(\"third step\", \"passed\");\n        Set<String> hooksFailures = new HashSet<String>();\n        hooksFailures.add(\"before\");\n\n        String formatterOutput = runFeatureWithJUnitFormatter(feature, stepsToResult, hooksFailures);\n\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite tests=\\\"1\\\" failures=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <failure message=\\\"the stack trace\\\"><![CDATA[\" +\n                \"Given first step............................................................skipped\\n\" +\n                \"When second step............................................................skipped\\n\" +\n                \"Then third step.............................................................skipped\\n\" +\n                \"\\n\" +\n                \"StackTrace:\\n\" +\n                \"the stack trace\" +\n                \"]]></failure>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(formatterOutput));\n    }\n\n    @Test\n    public void should_handle_failure_in_after_hook() throws Throwable {\n        CucumberFeature feature = TestHelper.feature(\"path/test.feature\",\n                \"Feature: feature name\\n\" +\n                \"  Scenario: scenario name\\n\" +\n                \"    Given first step\\n\" +\n                \"    When second step\\n\" +\n                \"    Then third step\\n\");\n        Map<String, String> stepsToResult = new HashMap<String, String>();\n        stepsToResult.put(\"first step\", \"passed\");\n        stepsToResult.put(\"second step\", \"passed\");\n        stepsToResult.put(\"third step\", \"passed\");\n        Set<String> hooksFailures = new HashSet<String>();\n        hooksFailures.add(\"after\");\n\n        String formatterOutput = runFeatureWithJUnitFormatter(feature, stepsToResult, hooksFailures);\n\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite tests=\\\"1\\\" failures=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <failure message=\\\"the stack trace\\\"><![CDATA[\" +\n                \"Given first step............................................................passed\\n\" +\n                \"When second step............................................................passed\\n\" +\n                \"Then third step.............................................................passed\\n\" +\n                \"\\n\" +\n                \"StackTrace:\\n\" +\n                \"the stack trace\" +\n                \"]]></failure>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(formatterOutput));\n    }\n\n    @Test\n    public void should_accumulate_time_from_steps_and_hooks() throws Exception {\n        final File report = File.createTempFile(\"cucumber-jvm-junit\", \".xml\");\n        final JUnitFormatter junitFormatter = createJUnitFormatter(report);\n\n        junitFormatter.uri(uri());\n        junitFormatter.feature(feature(\"feature name\"));\n        junitFormatter.before(match(), result(\"passed\", milliSeconds(1)));\n        junitFormatter.scenario(scenario(\"scenario name\"));\n        junitFormatter.step(step(\"keyword \", \"step name\"));\n        junitFormatter.match(match());\n        junitFormatter.result(result(\"passed\", milliSeconds(1)));\n        junitFormatter.step(step(\"keyword \", \"step name\"));\n        junitFormatter.match(match());\n        junitFormatter.result(result(\"passed\", milliSeconds(1)));\n        junitFormatter.after(match(), result(\"passed\", milliSeconds(1)));\n        junitFormatter.eof();\n        junitFormatter.done();\n        junitFormatter.close();\n\n        String actual = new Scanner(new FileInputStream(report), \"UTF-8\").useDelimiter(\"\\\\A\").next();\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite failures=\\\"0\\\" tests=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.004\\\">\\n\" +\n                \"        <system-out><![CDATA[\" +\n                \"keyword step name...........................................................passed\\n\" +\n                \"keyword step name...........................................................passed\\n\" +\n                \"]]></system-out>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, actual);\n    }\n\n    @Test\n    public void should_handle_all_step_calls_first_execution() throws Exception {\n        final File report = File.createTempFile(\"cucumber-jvm-junit\", \".xml\");\n        final JUnitFormatter junitFormatter = createJUnitFormatter(report);\n\n        junitFormatter.uri(uri());\n        junitFormatter.feature(feature(\"feature name\"));\n        junitFormatter.scenario(scenario(\"scenario name\"));\n        junitFormatter.step(step(\"keyword \", \"step name\"));\n        junitFormatter.step(step(\"keyword \", \"step name\"));\n        junitFormatter.match(match());\n        junitFormatter.result(result(\"passed\"));\n        junitFormatter.match(match());\n        junitFormatter.result(result(\"passed\"));\n        junitFormatter.eof();\n        junitFormatter.done();\n        junitFormatter.close();\n\n        String actual = new Scanner(new FileInputStream(report), \"UTF-8\").useDelimiter(\"\\\\A\").next();\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite failures=\\\"0\\\" tests=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <system-out><![CDATA[\" +\n                \"keyword step name...........................................................passed\\n\" +\n                \"keyword step name...........................................................passed\\n\" +\n                \"]]></system-out>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(actual));\n    }\n\n    @Test\n    public void should_handle_one_step_at_the_time_execution() throws Exception {\n        final File report = File.createTempFile(\"cucumber-jvm-junit\", \".xml\");\n        final JUnitFormatter junitFormatter = createJUnitFormatter(report);\n\n        junitFormatter.uri(uri());\n        junitFormatter.feature(feature(\"feature name\"));\n        junitFormatter.scenario(scenario(\"scenario name\"));\n        junitFormatter.step(step(\"keyword \", \"step name\"));\n        junitFormatter.match(match());\n        junitFormatter.result(result(\"passed\"));\n        junitFormatter.step(step(\"keyword \", \"step name\"));\n        junitFormatter.match(match());\n        junitFormatter.result(result(\"passed\"));\n        junitFormatter.eof();\n        junitFormatter.done();\n        junitFormatter.close();\n\n        String actual = new Scanner(new FileInputStream(report), \"UTF-8\").useDelimiter(\"\\\\A\").next();\n        String expected = \"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\" standalone=\\\"no\\\"?>\\n\" +\n                \"<testsuite failures=\\\"0\\\" tests=\\\"1\\\">\\n\" +\n                \"    <testcase classname=\\\"feature name\\\" name=\\\"scenario name\\\" time=\\\"0.0\\\">\\n\" +\n                \"        <system-out><![CDATA[\" +\n                \"keyword step name...........................................................passed\\n\" +\n                \"keyword step name...........................................................passed\\n\" +\n                \"]]></system-out>\\n\" +\n                \"    </testcase>\\n\" +\n                \"</testsuite>\\n\";\n        assertXmlEqual(expected, replaceTimeWithZeroTime(actual));\n    }\n\n    private File runFeaturesWithJunitFormatter(final List<String> featurePaths) throws IOException {\n        return runFeaturesWithJunitFormatter(featurePaths, false);\n    }\n\n    private File runFeaturesWithJunitFormatter(final List<String> featurePaths, boolean strict) throws IOException {\n        File report = File.createTempFile(\"cucumber-jvm-junit\", \"xml\");\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        final ClasspathResourceLoader resourceLoader = new ClasspathResourceLoader(classLoader);\n\n        List<String> args = new ArrayList<String>();\n        if (strict) {\n            args.add(\"--strict\");\n        }\n        args.add(\"--format\");\n        args.add(\"junit:\" + report.getAbsolutePath());\n        args.addAll(featurePaths);\n\n        RuntimeOptions runtimeOptions = new RuntimeOptions(new Properties(), args.toArray(new String[args.size()]));\n        Backend backend = mock(Backend.class);\n        when(backend.getSnippet(any(Step.class))).thenReturn(\"TEST SNIPPET\");\n        final cucumber.runtime.Runtime runtime = new Runtime(resourceLoader, classLoader, asList(backend), runtimeOptions);\n        runtime.run();\n        return report;\n    }\n\n    private String runFeatureWithJUnitFormatter(final CucumberFeature feature, final Map<String, String> stepsToResult)\n            throws Throwable {\n        return runFeatureWithJUnitFormatter(feature, stepsToResult, Collections.<String>emptySet());\n    }\n\n    private String runFeatureWithJUnitFormatter(final CucumberFeature feature, final Map<String, String> stepsToResult,\n            final Set<String> hookFailures) throws Throwable {\n        final RuntimeOptions runtimeOptions = new RuntimeOptions(new Properties());\n        final ClassLoader classLoader = Thread.currentThread().getContextClassLoader();\n        final ClasspathResourceLoader resourceLoader = new ClasspathResourceLoader(classLoader);\n        final RuntimeGlue glue = createMockedRuntimeGlueThatMatchesTheSteps(stepsToResult, hookFailures);\n        final Runtime runtime = new Runtime(resourceLoader, classLoader, asList(mock(Backend.class)), runtimeOptions, glue);\n        final File report = File.createTempFile(\"cucumber-jvm-junit\", \".xml\");\n        final JUnitFormatter junitFormatter = createJUnitFormatter(report);\n\n        feature.run(junitFormatter, junitFormatter, runtime);\n        junitFormatter.done();\n        junitFormatter.close();\n\n        return new Scanner(new FileInputStream(report), \"UTF-8\").useDelimiter(\"\\\\A\").next();\n    }\n\n    private void assertXmlEqual(String expectedPath, File actual) throws IOException, ParserConfigurationException, SAXException {\n        XMLUnit.setIgnoreWhitespace(true);\n        InputStreamReader control = new InputStreamReader(Thread.currentThread().getContextClassLoader().getResourceAsStream(expectedPath), \"UTF-8\");\n        Diff diff = new Diff(control, new FileReader(actual));\n        assertTrue(\"XML files are similar \" + diff, diff.identical());    }\n\n    private void assertXmlEqual(String expected, String actual) throws SAXException, IOException {\n        XMLUnit.setIgnoreWhitespace(true);\n        Diff diff = new Diff(expected, actual);\n        assertTrue(\"XML files are similar \" + diff, diff.identical());\n    }\n\n    private JUnitFormatter createJUnitFormatter(final File report) throws IOException {\n        return new JUnitFormatter(Utils.toURL(report.getAbsolutePath()));\n    }\n\n    private RuntimeGlue createMockedRuntimeGlueThatMatchesTheSteps(Map<String, String> stepsToResult,\n            final Set<String> hookFailures) throws Throwable {\n        RuntimeGlue glue = mock(RuntimeGlue.class);\n        mockSteps(glue, stepsToResult);\n        mockHooks(glue, hookFailures);\n        return glue;\n    }\n\n    private void mockSteps(RuntimeGlue glue, Map<String, String> stepsToResult) throws Throwable {\n        for (String stepName : stepsToResult.keySet()) {\n            if (!\"undefined\".equals(stepsToResult.get(stepName))) {\n                StepDefinitionMatch matchStep = mock(StepDefinitionMatch.class);\n                when(glue.stepDefinitionMatch(anyString(), stepWithName(stepName), (I18n)any())).thenReturn(matchStep);\n                if (\"pending\".equals(stepsToResult.get(stepName))) {\n                    doThrow(new PendingException()).when(matchStep).runStep((I18n)any());\n                } else if (\"failed\".equals(stepsToResult.get(stepName))) {\n                    AssertionFailedError error = mockAssertionFailedError();\n                    doThrow(error).when(matchStep).runStep((I18n)any());\n                } else if (!\"passed\".equals(stepsToResult.get(stepName)) &&\n                        !\"skipped\".equals(stepsToResult.get(stepName))) {\n                    fail(\"Cannot mock step to the result: \" + stepsToResult.get(stepName));\n                }\n            }\n        }\n    }\n\n    private void mockHooks(RuntimeGlue glue, final Set<String> hookFailures) throws Throwable {\n        for (String hookType : hookFailures) {\n            HookDefinition hook = mock(HookDefinition.class);\n            when(hook.matches(anyCollectionOf(Tag.class))).thenReturn(true);\n            AssertionFailedError error = mockAssertionFailedError();\n            doThrow(error).when(hook).execute((cucumber.api.Scenario)any());\n            if (\"before\".equals(hookType)) {\n                when(glue.getBeforeHooks()).thenReturn(Arrays.asList(hook));\n            } else if (\"after\".equals(hookType)) {\n                when(glue.getAfterHooks()).thenReturn(Arrays.asList(hook));\n            } else {\n                fail(\"Only before and after hooks are allowed, hook type found was: \" + hookType);\n            }\n        }\n    }\n\n    private Step stepWithName(String name) {\n        return argThat(new StepMatcher(name));\n    }\n\n    private AssertionFailedError mockAssertionFailedError() {\n        AssertionFailedError error = mock(AssertionFailedError.class);\n        Answer<Object> printStackTraceHandler = new Answer<Object>() {\n            @Override\n            public Object answer(InvocationOnMock invocation) throws Throwable {\n                PrintWriter writer = (PrintWriter) invocation.getArguments()[0];\n                writer.print(\"the stack trace\");\n                return null;\n            }\n        };\n        doAnswer(printStackTraceHandler).when(error).printStackTrace((PrintWriter)any());\n        return error;\n    }\n\n    private String replaceTimeWithZeroTime(String formatterOutput) {\n        return formatterOutput.replaceAll(\"time=\\\".*\\\"\", \"time=\\\"0.0\\\"\");\n    }\n\n    private String uri() {\n        return \"uri\";\n    }\n\n    private Feature feature(String featureName) {\n        Feature feature = mock(Feature.class);\n        when(feature.getName()).thenReturn(featureName);\n        return feature;\n    }\n\n    private Scenario scenario(String scenarioName) {\n        Scenario scenario = mock(Scenario.class);\n        when(scenario.getName()).thenReturn(scenarioName);\n        return scenario;\n    }\n\n    private Step step(String keyword, String stepName) {\n        Step step = mock(Step.class);\n        when(step.getKeyword()).thenReturn(keyword);\n        when(step.getName()).thenReturn(stepName);\n        return step;\n    }\n\n    private Match match() {\n        return mock(Match.class);\n    }\n\n    private Result result(String status) {\n        return result(status, null);\n    }\n\n    private Result result(String status, Long duration) {\n        return new Result(status, duration, null);\n    }\n\n    private Long milliSeconds(int milliSeconds) {\n        return milliSeconds * 1000000L;\n    }\n}\n", "util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\nimport de.bokeh.skred.red.AppFactory;\nimport de.bokeh.skred.red.Data;\nimport de.bokeh.skred.red.Function;\nimport de.bokeh.skred.red.Node;\nimport de.bokeh.skred.red.Symbol;\n\nabstract public class AbstractSkReader implements SkReader {\n\n    protected final AppFactory appFactory;\n    private final Map<String, Node> defns = new HashMap<>();\n    private final Set<String> rewritten = new HashSet<>();\n\n    public AbstractSkReader(AppFactory appFactory) {\n        this.appFactory = appFactory;\n    }\n    \n    @Override\n    public void dumpDefns(String root, PrintStream out) {\n        Set<String> printed = new HashSet<>();\n        Deque<String> toPrint = new ArrayDeque<>();\n        toPrint.push(root);\n        while (!toPrint.isEmpty()) {\n            String d = toPrint.pop();\n            if (!printed.contains(d)) {\n                Node e = defns.get(d);\n                if (e == null) {\n                    System.err.println(\"error: undefined: \" + d);\n                    System.exit(1);\n                } else {\n                    printed.add(d);\n                    out.print(d);\n                    out.print(\" = \");\n                    out.print(e.toString(false, Integer.MAX_VALUE));\n                    out.println(';');\n                    for (String v : freeVars(e)) {\n                        if (!printed.contains(v) && Function.valueOf(v) == null) {\n                            toPrint.push(v);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    private static Set<String> freeVars(Node e) {\n        Set<String> result = new HashSet<>();\n        freeVars(result, e);\n        return result;\n    }\n\n    private static void freeVars(Set<String> result, Node e) {\n        while (e.isApp()) {\n            freeVars(result, e.getArg());\n            e = e.getFun();\n        }\n        if (e instanceof Symbol) {\n            result.add(e.toString());\n        }\n        else if (e instanceof Data) {\n            Data d = (Data) e;\n            for (int i = d.getNumFields() - 1; i >= 0; i--) {\n                freeVars(result, d.getField(i));\n            }\n        }\n    }\n\n    @Override\n    public void addDefn(String name, Node value) {\n        defns.put(name, value);\n    }\n\n    @Override\n    public Node getGraph(String name) throws SkFileCorruptException {\n        linkDefn(name);\n        return defns.get(name);\n    }\n\n    private void linkDefn(String name) throws SkFileCorruptException {\n        if (rewritten.contains(name))\n            return;\n        Node d = defns.get(name);\n        if (d == null)\n            throw new SkFileCorruptException(\"undefined: \" + name);\n        rewritten.add(name);\n        if (d instanceof Symbol)\n            return;\n        if (d.isApp()) {\n            d.overwriteApp(link(d.getFun()), link(d.getArg()));\n        }\n    }\n\n    private Node link(Node e) throws SkFileCorruptException {\n        if (e instanceof Symbol) {\n            Node d = defns.get(e.toString());\n            while (d instanceof Symbol) {\n                e = d;\n                d = defns.get(e.toString());\n            }\n            if (d == null) {\n                d = Function.valueOf(e.toString());\n            }\n            if (d == null)\n                throw new SkFileCorruptException(\"function \" + e + \" not found\");\n            if (!(d instanceof Function)) {\n                linkDefn(e.toString());\n                d = defns.get(e.toString());\n                if (d.isApp()) {\n                    return appFactory.mkApp(Function.I_FOR_IND, d);\n                }\n            }\n            return d;\n        }\n        else if (e.isApp()) {\n            e.overwriteApp(link(e.getFun()), link(e.getArg()));\n            return e;\n        }\n        else\n            return e;\n    }\n\n}", "tion and use in source and binary forms, with or without\r\n * modification, are permitted provided that the following conditions are\r\n * met:\r\n * \r\n * 1. Redistributions of source code must retain the above copyright\r\n *    notice, this list of conditions and the following disclaimer.\r\n * \r\n * 2. Redistributions in binary form must reproduce the above copyright\r\n *    notice, this list of conditions and the following disclaimer in the\r\n *    documentation and/or other materials provided with the distribution.\r\n * \r\n * 3. Products derived from the software may not be called \"Alice\",\r\n *    nor may \"Alice\" appear in their name, without prior written\r\n *    permission of Carnegie Mellon University.\r\n * \r\n * 4. All advertising materials mentioning features or use of this software\r\n *    must display the following acknowledgement:\r\n *    \"This product includes software developed by Carnegie Mellon University\"\r\n */\r\n\r\npackage edu.cmu.cs.stage3.alice.authoringtool.util.event;\r\n\r\n/**\r\n * @author Jason Pratt\r\n */\r\npublic class RenderTargetPickManipulatorEvent {\r\n\tprivate edu.cmu.cs.stage3.alice.scenegraph.renderer.RenderTarget renderTarget;\r\n\tprivate edu.cmu.cs.stage3.alice.scenegraph.renderer.PickInfo pickInfo;\r\n\r\n\tpublic RenderTargetPickManipulatorEvent( edu.cmu.cs.stage3.alice.scenegraph.renderer.RenderTarget renderTarget, edu.cmu.cs.stage3.alice.scenegraph.renderer.PickInfo pickInfo ) {\r\n\t\tthis.renderTarget = renderTarget;\r\n\t\tthis.pickInfo = pickInfo;\r\n\t}\r\n\r\n\tpublic edu.cmu.cs.stage3.alice.scenegraph.renderer.RenderTarget getRenderTarget() {\r\n\t\treturn renderTarget;\r\n\t}\r\n\r\n\tpublic edu.cmu.cs.stage3.alice.scenegraph.renderer.PickInfo getPickInfo() {\r\n\t\treturn pickInfo;\r\n\t}\r\n}", "ter1.Album;\nimport com.insightfullogic.java8.examples.chapter1.Artist;\n\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.regex.Pattern;\nimport java.util.stream.Stream;\n\nimport static com.insightfullogic.java8.examples.chapter5.CollectorExamples.countWords;\nimport static java.nio.charset.Charset.defaultCharset;\nimport static java.util.stream.Collectors.groupingBy;\n\npublic class MethodReferences {\n\n    public Map<Artist, List<Album>> albumsByArtist(Stream<Album> albums) {\n        return albums.collect(groupingBy(Album::getMainMusician));\n    }\n\n    private static final Pattern SPACES = Pattern.compile(\"\\\\w+\");\n\n    public static Map<String, Long> countWordsIn(Path path) throws IOException {\n        Stream<String> words = Files.readAllLines(path, defaultCharset())\n                                    .stream()\n                                    .flatMap(SPACES::splitAsStream);\n\n        return countWords(words);\n    }\n\n}\n", "xception;\n\n/**\n * Name morphed into description\n * Represents a Task's name in the address book.\n * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}\n */\npublic class TaskName {\n\n    public static final String MESSAGE_TASKNAME_CONSTRAINTS =\n            \"Task names should only contain alphanumeric characters and spaces, and it should not be blank\";\n\n    /*\n     * The first character of the address must not be a whitespace,\n     * otherwise \" \" (a blank string) becomes a valid input.\n     */\n    public static final String TASKNAME_VALIDATION_REGEX = \"[\\\\p{Alnum}][\\\\p{Alnum} ]*\";\n\n    public final String fullName;\n\n    /**\n     * Validates given name.\n     *\n     * @throws IllegalValueException if given name string is invalid.\n     */\n    public TaskName(String name) throws IllegalValueException {\n        assert name != null;\n        String trimmedName = name.trim();\n        if (!isValidName(trimmedName)) {\n            throw new IllegalValueException(MESSAGE_TASKNAME_CONSTRAINTS);\n        }\n        this.fullName = trimmedName;\n    }\n\n    /**\n     * Returns true if a given string is a valid task name.\n     */\n    public static boolean isValidName(String test) {\n        return test.matches(TASKNAME_VALIDATION_REGEX);\n    }\n\n\n    @Override\n    public String toString() {\n        return fullName;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n        return other == this // short circuit if same object\n                || (other instanceof TaskName // instanceof handles nulls\n                && this.fullName.equals(((TaskName) other).fullName)); // state check\n    }\n\n    @Override\n    public int hashCode() {\n        return fullName.hashCode();\n    }\n\n}\n", "guage!*/\r\n\r\n\r\n\r\n// line 90 \"DMMRelationshipHierarchy.ump\"\r\n// line 227 \"DMMRelationshipHierarchy.ump\"\r\npublic class IsFieldOf extends IsPartOf\r\n{\n\n  //------------------------\n  // MEMBER VARIABLES\n  //------------------------\r\n\r\n  //------------------------\r\n  // CONSTRUCTOR\r\n  //------------------------\r\n\n  public IsFieldOf()\n  {\n    super();\n  }\r\n\r\n  //------------------------\r\n  // INTERFACE\r\n  //------------------------\r\n\n  public void delete()\n  {\n    super.delete();\n  }\n\r\n}", "eWriter;\r\nimport java.io.IOException;\r\nimport java.text.SimpleDateFormat;\r\nimport java.util.Date;\r\n\r\nimport fr.esiea.CanadianLoggerjack.Target;\r\n\r\n/**\r\n * Saves messages in a rollover file.\r\n * <br> When the file reaches a certain size, a new file is created automatically.\r\n * \r\n * @author M. Bougeret &amp; L. Cousi &amp; G. Philippot\r\n */\r\npublic class TargetRolloverFile implements Target{\r\n\r\n\t\r\n\tprivate File file;\r\n\tprivate String name;\r\n\tprivate int maxSize;\r\n\t\r\n\t\r\n\t/**\r\n\t * Creates a rollover file with default values:\r\n\t * <br> name: rollover_file.log\r\n\t * <br> max size of the file: 10MB\r\n\t */\r\n\tpublic TargetRolloverFile(){\r\n\t\tthis.maxSize = 10 * 1024;\r\n\t\tthis.name = \"rollover_file\";\r\n\t\tfile = new File(name + \".log\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates a rollover file with a default maxSize and a chosen name\r\n\t * \r\n\t * @param name The name of the file\r\n\t */\r\n\tpublic TargetRolloverFile(String name){\r\n\t\tthis.maxSize = 10 * 1024;\r\n\t\tthis.name = name;\r\n\t\tfile = new File(name + \".log\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates a rollover file with a chosen maxSize and a default name\r\n\t * \r\n\t * @param maxSize The maximum size of the file in kB.\r\n\t */\r\n\tpublic TargetRolloverFile(int maxSize){\r\n\t\tthis.maxSize = maxSize * 1024;\r\n\t\tthis.name = \"rollover_file\";\r\n\t\tfile = new File(name + \".log\");\r\n\t}\r\n\t\r\n\t/**\r\n\t * Creates a rollover file with a chosen maxSize and a chosen name\r\n\t * \r\n\t * @param name The name of the file\r\n\t * @param maxSize The maximum size of the file\r\n\t */\r\n\tpublic TargetRolloverFile(String name, int maxSize){\r\n\t\tthis.maxSize = maxSize * 1024;\r\n\t\tthis.name = name;\r\n\t\tfile = new File(name + \".log\");\r\n\t}\r\n\t\r\n\t\r\n\t/**\r\n\t * Saves a message in a rollover file\r\n\t * \r\n\t * @param message The message that will be saved in the rollover file\r\n\t */\r\n\t@Override\r\n\tpublic void record(String message) {\t\t\r\n\t\tint fileSize = message.getBytes().length + (int)file.length();\r\n\t\tFile newName;\r\n\t\tFileWriter fileWriter;\t\t\r\n\t\t\r\n\t\ttry {\r\n\t\t\tif(fileSize < this.maxSize){\r\n\t\t\t\tfileWriter = new FileWriter(file, true);\r\n\t\t\t\tfileWriter.write(message);\r\n\t\t\t\tfileWriter.write(\"\\n\");\r\n\t\t\t\tfileWriter.close();\r\n\t\t\t}\r\n\t\t\telse if (fileSize == this.maxSize){\r\n\t\t\t\tfileWriter = new FileWriter(file, true);\r\n\t\t\t\tfileWriter.write(message);\r\n\t\t\t\tfileWriter.write(\"\\n\");\r\n\t\t\t\tfileWriter.close();\r\n\t\t\t\tnewName = new File(new SimpleDateFormat(name + \"yyyy/MM/dd_HH-mm-ss\").format(new Date()).toString() + \".txt\");\r\n\t\t\t\tfile.renameTo(newName);\r\n\t\t\t}\r\n\t\t\telse{\r\n\t\t\t\tnewName = new File(new SimpleDateFormat(name + \"yyyy/MM/dd_HH-mm-ss\").format(new Date()).toString() + \".txt\");\r\n\t\t\t\tfile.renameTo(newName);\r\n\t\t\t\tfileWriter = new FileWriter(file, true);\r\n\t\t\t\tfileWriter.write(message);\r\n\t\t\t\tfileWriter.write(\"\\n\");\r\n\t\t\t\tfileWriter.close();\r\n\t\t\t}\r\n\t\t} catch (IOException e) {\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\t}\r\n\t\r\n}\r\n", "lObject;\nimport com.geophile.z.SpatialObjectException;\nimport com.geophile.z.space.Region;\nimport com.geophile.z.space.RegionComparison;\nimport com.geophile.z.space.SpaceImpl;\nimport com.vividsolutions.jts.geom.Coordinate;\nimport com.vividsolutions.jts.geom.Geometry;\nimport com.vividsolutions.jts.io.ParseException;\nimport com.vividsolutions.jts.io.WKBReader;\nimport com.vividsolutions.jts.io.WKBWriter;\n\nimport java.nio.ByteBuffer;\n\npublic abstract class JTSSpatialObject implements SpatialObject\n{\n    // Object interface\n\n    @Override\n    public final String toString()\n    {\n        return geometry.toString();\n    }\n\n    @Override\n    public final int hashCode()\n    {\n        if (!hashCodeKnown) {\n            hashCode = geometry.getEnvelopeInternal().hashCode();\n            hashCodeKnown = true;\n        }\n        return hashCode;\n    }\n\n    @Override\n    public final boolean equals(Object obj)\n    {\n        boolean eq = this == obj;\n        if (!eq && obj != null && obj instanceof JTSSpatialObject) {\n            JTSSpatialObject that = (JTSSpatialObject) obj;\n            this.ensureGeometry();\n            that.ensureGeometry();\n            eq = this.geometry.equals(that.geometry);\n        }\n        return eq;\n    }\n\n    // SpatialObject interface\n\n    @Override\n    public final double[] arbitraryPoint()\n    {\n        double[] point = new double[2];\n        Coordinate coordinate = geometry.getCoordinate();\n        point[0] = coordinate.x;\n        point[1] = coordinate.y;\n        return point;\n    }\n\n\n    @Override\n    public int maxZ()\n    {\n        return MAX_Z;\n    }\n\n    @Override\n    public abstract boolean containedBy(Space space);\n\n    @Override\n    public abstract boolean containedBy(Region region);\n\n    @Override\n    public abstract RegionComparison compare(Region region);\n\n    @Override\n    public final void readFrom(ByteBuffer buffer)\n    {\n        read(buffer);\n    }\n\n    @Override\n    public void writeTo(ByteBuffer buffer)\n    {\n        write(buffer);\n    }\n\n    // JTSBase interface\n\n    public final Geometry geometry()\n    {\n        return geometry;\n    }\n\n    // For use by subclasses\n\n    protected void ensureGeometry()\n    {\n        if (geometry == null) {\n            assert wkb != null;\n            try {\n                geometry = io().reader().read(wkb);\n            } catch (ParseException e) {\n                throw new SpatialObjectException(e);\n            }\n        }\n    }\n\n    protected JTSSpatialObject(Space space, Geometry geometry)\n    {\n        this.space = (SpaceImpl) space;\n        this.geometry = geometry;\n    }\n\n    // Used during deserialization\n    protected JTSSpatialObject()\n    {\n        this.space = null;\n    }\n\n    protected void read(ByteBuffer input)\n    {\n        // WKB\n        int size = input.getInt();\n        wkb = new byte[size];\n        input.get(wkb);\n        // geometry\n        geometry = null;\n    }\n\n    protected void write(ByteBuffer output)\n    {\n        // WKB\n        ensureWKB();\n        output.putInt(wkb.length);\n        output.put(wkb);\n        // geometry: nothing to do\n    }\n\n    // For use by this class\n\n    private IO io()\n    {\n        return THREAD_IO.get();\n    }\n\n    private void ensureWKB()\n    {\n        if (wkb == null) {\n            assert geometry != null;\n            wkb = io().writer().write(geometry);\n        }\n    }\n\n    // Class state\n\n    private static final int MAX_Z = 8;\n    private static final ThreadLocal<IO> THREAD_IO =\n        new ThreadLocal<IO>()\n        {\n            @Override\n            protected IO initialValue()\n            {\n                return new IO();\n            }\n        };\n\n    // Object state\n\n    protected final SpaceImpl space;\n    // Caching of hashCode\n    private boolean hashCodeKnown = false;\n    private int hashCode;\n    //\n    protected Geometry geometry;\n    // Well Known Binary representation, (i.e., serialized)\n    private byte[] wkb;\n    // Derivation of state (bounding boxes handled by subclass JTSBaseWithBoundingBox):\n    // - New spatial object:\n    //    - Start with geometry\n    //    - Generate bounding box on addition to index.\n    //    - Generate wkb on durability.\n    // - Read spatial object from index:\n    //    - Start with bounding box and wkb.\n    //    - Generate geometry lazily.\n\n    // Inner classes\n    \n    private static class IO\n    {\n        WKBReader reader()\n        {\n            if (reader == null) {\n                reader = new WKBReader();\n            }\n            return reader;\n        }\n\n        WKBWriter writer()\n        {\n            if (writer == null) {\n                writer = new WKBWriter();\n            }\n            return writer;\n        }\n\n        private WKBReader reader;\n        private WKBWriter writer;\n    }\n}\n", "ability library for Java Copyright (C) 2004, 2012 Artois University and CNRS\n *\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n *  http://www.eclipse.org/legal/epl-v10.html\n *\n * Alternatively, the contents of this file may be used under the terms of\n * either the GNU Lesser General Public License Version 2.1 or later (the\n * \"LGPL\"), in which case the provisions of the LGPL are applicable instead\n * of those above. If you wish to allow use of your version of this file only\n * under the terms of the LGPL, and not to allow others to use your version of\n * this file under the terms of the EPL, indicate your decision by deleting\n * the provisions above and replace them with the notice and other provisions\n * required by the LGPL. If you do not delete the provisions above, a recipient\n * may use your version of this file under the terms of the EPL or the LGPL.\n *\n * Based on the original MiniSat specification from:\n *\n * An extensible SAT solver. Niklas Een and Niklas Sorensson. Proceedings of the\n * Sixth International Conference on Theory and Applications of Satisfiability\n * Testing, LNCS 2919, pp 502-518, 2003.\n *\n * See www.minisat.se for the original solver in C++.\n *\n * Contributors:\n *   CRIL - initial API and implementation\n *******************************************************************************/\npackage org.sat4j.tools;\n\nimport org.sat4j.specs.IConstr;\nimport org.sat4j.specs.ISolverService;\nimport org.sat4j.specs.Lbool;\n\n/**\n * @since 2.3.2\n */\npublic class LearnedClausesSizeTracing extends\n        SearchListenerAdapter<ISolverService> {\n\n    /**\n\t * \n\t */\n    private static final long serialVersionUID = 1L;\n\n    private final IVisualizationTool visuTool;\n    private final IVisualizationTool restartTool;\n    private final IVisualizationTool cleanTool;\n    private int counter;\n    private int maxSize;\n\n    public LearnedClausesSizeTracing(IVisualizationTool visuTool,\n            IVisualizationTool restartTool, IVisualizationTool cleanTool) {\n        this.visuTool = visuTool;\n        this.restartTool = restartTool;\n        this.cleanTool = cleanTool;\n        this.counter = 0;\n        this.maxSize = 0;\n    }\n\n    @Override\n    public void end(Lbool result) {\n        this.visuTool.end();\n        this.restartTool.end();\n        this.cleanTool.end();\n    }\n\n    @Override\n    public void learn(IConstr c) {\n        int s = c.size();\n        if (s > this.maxSize) {\n            this.maxSize = s;\n        }\n        this.visuTool.addPoint(this.counter, s);\n        this.restartTool.addInvisiblePoint(this.counter, 0);\n        this.cleanTool.addInvisiblePoint(this.counter, 0);\n        this.counter++;\n    }\n\n    @Override\n    public void start() {\n        this.visuTool.init();\n        this.restartTool.init();\n        this.cleanTool.init();\n        this.counter = 0;\n        this.maxSize = 0;\n    }\n\n    @Override\n    public void restarting() {\n        this.visuTool.addInvisiblePoint(this.counter, 0);\n        this.restartTool.addPoint(this.counter, this.maxSize);\n        this.cleanTool.addPoint(this.counter, 0);\n    }\n\n    @Override\n    public void cleaning() {\n        this.visuTool.addInvisiblePoint(this.counter, 0);\n        this.restartTool.addPoint(this.counter, 0);\n        this.cleanTool.addPoint(this.counter, this.maxSize);\n    }\n}\n", "@Embeddable\npublic class Name {\n\n    @Column(name = \"GIVEN_NAME\")\n    private String givenName;\n\n    @Column(name = \"MIDDLE_NAME\")\n    private String middleName;\n\n    @Column(name = \"SURNAME\")\n    private String surname;\n\n    public String toString() {\n        StringBuilder string = new StringBuilder();\n        if (null != surname) {\n            string.append(surname).append(\", \");\n        }\n        if (null != givenName) {\n            string.append(givenName).append(\" \");\n        }\n        if (null != middleName) {\n            string.append(middleName);\n        }\n        return string.toString();\n    }\n\n    public String getGivenName() {\n        return givenName;\n    }\n\n    public void setGivenName(String givenName) {\n        this.givenName = givenName;\n    }\n\n    public String getMiddleName() {\n        return middleName;\n    }\n\n    public void setMiddleName(String middleName) {\n        this.middleName = middleName;\n    }\n\n    public String getSurname() {\n        return surname;\n    }\n\n    public void setSurname(String surname) {\n        this.surname = surname;\n    }\n}\n", "c version: 5.0.813\n * \n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage net.leanix.api.models;\n\nimport java.util.Objects;\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\n\n/**\n * ReportConfiguration\n */\n\npublic class ReportConfiguration {\n  @JsonProperty(\"id\")\n  private String id = null;\n\n  @JsonProperty(\"version\")\n  private String version = null;\n\n  @JsonProperty(\"config\")\n  private Object config = null;\n\n  public ReportConfiguration id(String id) {\n    this.id = id;\n    return this;\n  }\n\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(example = \"null\", value = \"\")\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public ReportConfiguration version(String version) {\n    this.version = version;\n    return this;\n  }\n\n   /**\n   * Get version\n   * @return version\n  **/\n  @ApiModelProperty(example = \"null\", value = \"\")\n  public String getVersion() {\n    return version;\n  }\n\n  public void setVersion(String version) {\n    this.version = version;\n  }\n\n  public ReportConfiguration config(Object config) {\n    this.config = config;\n    return this;\n  }\n\n   /**\n   * Get config\n   * @return config\n  **/\n  @ApiModelProperty(example = \"null\", value = \"\")\n  public Object getConfig() {\n    return config;\n  }\n\n  public void setConfig(Object config) {\n    this.config = config;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    ReportConfiguration reportConfiguration = (ReportConfiguration) o;\n    return Objects.equals(this.id, reportConfiguration.id) &&\n        Objects.equals(this.version, reportConfiguration.version) &&\n        Objects.equals(this.config, reportConfiguration.config);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(id, version, config);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class ReportConfiguration {\\n\");\n    \n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    version: \").append(toIndentedString(version)).append(\"\\n\");\n    sb.append(\"    config: \").append(toIndentedString(config)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n  \n}\n\n", "y;\nimport mineapi.product.FluidFactoryProduct;\nimport net.minecraft.block.Block;\nimport net.minecraft.util.Icon;\nimport net.minecraftforge.fluids.Fluid;\n\n\npublic class FluidTemplate extends Fluid\n{\n    private FluidFactoryProduct registeredFluid = null;\n\n    private String registeredFluidName;\n\n    public FluidTemplate(FluidFactoryProduct fluidFactoryProduct)\n    {\n        super( fluidFactoryProduct.getFluidName() );\n\n        this.registeredFluid = fluidFactoryProduct;\n        this.registeredFluidName = fluidFactoryProduct.getFluidName();\n\n        this.setUnlocalizedName( fluidFactoryProduct.getFluidName() );\n\n        // Give the classic minecraft fluid the same ID as our forge fluid registry class.\n        this.setBlockID( fluidFactoryProduct.getFluidID() );\n\n        // used by the block to work out how much it slows entities.\n        // Example: 3\n        this.setDensity( fluidFactoryProduct.getDensity() );\n\n        // used by the block to work out how fast it flows\n        // Example: 4000\n        this.setViscosity( fluidFactoryProduct.getViscosity() );\n\n        // Set how well light can pass through this block.\n        // Example: 5\n        this.setLuminosity( fluidFactoryProduct.getLuminosity() );\n    }\n\n    public FluidFactoryProduct getRegisteredFluid()\n    {\n        return this.registeredFluid;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public Icon getIcon(int side, int meta) // NO_UCD (unused code)\n    {\n        // Use the same default minecraft icon for water (for now).\n        return Block.waterMoving.getIcon( side,\n                                          meta );\n    }\n\n    /**\n     * Returns the unlocalized name of this fluid.\n     */\n    @Override\n    public String getUnlocalizedName()\n    {\n        return \"tile.\" + this.unlocalizedName + \".name\";\n    }\n}\n", " template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\npackage institucion.Views.Teacher;\n\nimport config.Sound;\nimport config.Tiempo;\nimport institucion.Controllers.CtrlTeacher;\nimport institucion.Views.Loggin.Loggin;\nimport java.util.Hashtable;\n\n/**\n *\n * @author master\n */\npublic class WelcomeT extends javax.swing.JFrame implements Runnable {\n\n    /**\n     * Creates new form welcome\n     */\n    public int teacher_id;\n    \n    private CtrlTeacher ctrlT;\n    private Sound s;\n    private Tiempo t;\n    private Thread h1;\n    \n    public WelcomeT() {\n        this.setUndecorated(true);\n        initComponents();\n        this.setSize(1500,700);\n        this.setLocationRelativeTo(null);\n\t\t\n        s = new Sound();\n        t = new Tiempo();\n        ctrlT = new CtrlTeacher();\n\n        h1 = new Thread(this);\n        h1.start();\n    }\n\n    /**\n     * This method is called from within the constructor to initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is always\n     * regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        jPanel1 = new javax.swing.JPanel();\n        btnPerfil = new javax.swing.JButton();\n        btnActualizar = new javax.swing.JButton();\n        btnNotificaciones = new javax.swing.JButton();\n        jPanel2 = new javax.swing.JPanel();\n        lblWelcome = new javax.swing.JLabel();\n        btnClose = new javax.swing.JButton();\n        lblTime = new javax.swing.JLabel();\n        jPanel3 = new javax.swing.JPanel();\n        btnAlumnado = new javax.swing.JButton();\n        btnAsistencia = new javax.swing.JButton();\n        btnMaterias = new javax.swing.JButton();\n        btnSchedule = new javax.swing.JButton();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);\n        addWindowListener(new java.awt.event.WindowAdapter() {\n            public void windowOpened(java.awt.event.WindowEvent evt) {\n                formWindowOpened(evt);\n            }\n        });\n        getContentPane().setLayout(null);\n\n        jPanel1.setBackground(new java.awt.Color(0, 0, 0));\n\n        btnPerfil.setBackground(new java.awt.Color(0, 0, 0));\n        btnPerfil.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnPerfil.setForeground(new java.awt.Color(255, 255, 255));\n        btnPerfil.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/manager.png\"))); // NOI18N\n        btnPerfil.setText(\"Ver Perfil\");\n        btnPerfil.setBorder(null);\n        btnPerfil.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnPerfil.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnPerfil.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnPerfil.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnPerfilActionPerformed(evt);\n            }\n        });\n\n        btnActualizar.setBackground(new java.awt.Color(0, 0, 0));\n        btnActualizar.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnActualizar.setForeground(new java.awt.Color(255, 255, 255));\n        btnActualizar.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/edit.png\"))); // NOI18N\n        btnActualizar.setText(\"Editar Mi Perfil\");\n        btnActualizar.setBorder(null);\n        btnActualizar.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnActualizar.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnActualizar.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnActualizar.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnActualizarActionPerformed(evt);\n            }\n        });\n\n        btnNotificaciones.setBackground(new java.awt.Color(0, 0, 0));\n        btnNotificaciones.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnNotificaciones.setForeground(new java.awt.Color(255, 255, 255));\n        btnNotificaciones.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/notifications.png\"))); // NOI18N\n        btnNotificaciones.setText(\"Notificaciones\");\n        btnNotificaciones.setBorder(null);\n        btnNotificaciones.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnNotificaciones.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnNotificaciones.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnNotificaciones.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnNotificacionesActionPerformed(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);\n        jPanel1.setLayout(jPanel1Layout);\n        jPanel1Layout.setHorizontalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel1Layout.createSequentialGroup()\n                .addContainerGap(32, Short.MAX_VALUE)\n                .addGroup(jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING, false)\n                    .addComponent(btnActualizar, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(btnPerfil, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                    .addComponent(btnNotificaciones, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n                .addGap(23, 23, 23))\n        );\n        jPanel1Layout.setVerticalGroup(\n            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel1Layout.createSequentialGroup()\n                .addGap(56, 56, 56)\n                .addComponent(btnPerfil)\n                .addGap(124, 124, 124)\n                .addComponent(btnActualizar)\n                .addGap(116, 116, 116)\n                .addComponent(btnNotificaciones)\n                .addContainerGap(135, Short.MAX_VALUE))\n        );\n\n        getContentPane().add(jPanel1);\n        jPanel1.setBounds(0, 0, 180, 710);\n\n        jPanel2.setBackground(new java.awt.Color(0, 0, 102));\n\n        lblWelcome.setBackground(new java.awt.Color(255, 255, 255));\n        lblWelcome.setFont(new java.awt.Font(\"Loma\", 0, 55)); // NOI18N\n        lblWelcome.setForeground(new java.awt.Color(255, 255, 255));\n        lblWelcome.setText(\"Bienvenido\");\n        lblWelcome.setToolTipText(\"\");\n\n        btnClose.setBackground(new java.awt.Color(0, 0, 102));\n        btnClose.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/close.png\"))); // NOI18N\n        btnClose.setText(\" \");\n        btnClose.setBorder(null);\n        btnClose.setContentAreaFilled(false);\n        btnClose.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnClose.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnClose.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                btnCloseMouseClicked(evt);\n            }\n        });\n\n        lblTime.setFont(new java.awt.Font(\"Loma\", 1, 48)); // NOI18N\n        lblTime.setForeground(new java.awt.Color(255, 255, 255));\n        lblTime.setText(\"jLabel1\");\n\n        javax.swing.GroupLayout jPanel2Layout = new javax.swing.GroupLayout(jPanel2);\n        jPanel2.setLayout(jPanel2Layout);\n        jPanel2Layout.setHorizontalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, jPanel2Layout.createSequentialGroup()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)\n                        .addComponent(lblTime))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(47, 47, 47)\n                        .addComponent(lblWelcome)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 886, Short.MAX_VALUE)\n                        .addComponent(btnClose)))\n                .addGap(159, 159, 159))\n        );\n        jPanel2Layout.setVerticalGroup(\n            jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel2Layout.createSequentialGroup()\n                .addGroup(jPanel2Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(40, 40, 40)\n                        .addComponent(lblWelcome))\n                    .addGroup(jPanel2Layout.createSequentialGroup()\n                        .addGap(32, 32, 32)\n                        .addComponent(btnClose)))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 207, Short.MAX_VALUE)\n                .addComponent(lblTime)\n                .addContainerGap())\n        );\n\n        getContentPane().add(jPanel2);\n        jPanel2.setBounds(180, 0, 1430, 420);\n\n        jPanel3.setBackground(new java.awt.Color(0, 0, 51));\n\n        btnAlumnado.setBackground(new java.awt.Color(51, 25, 230));\n        btnAlumnado.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnAlumnado.setForeground(new java.awt.Color(255, 255, 255));\n        btnAlumnado.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/classmate.png\"))); // NOI18N\n        btnAlumnado.setText(\"Alumnado\");\n        btnAlumnado.setBorder(null);\n        btnAlumnado.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnAlumnado.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnAlumnado.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnAlumnado.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnAlumnadoActionPerformed(evt);\n            }\n        });\n\n        btnAsistencia.setBackground(new java.awt.Color(51, 25, 230));\n        btnAsistencia.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnAsistencia.setForeground(new java.awt.Color(255, 255, 255));\n        btnAsistencia.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/attendance.png\"))); // NOI18N\n        btnAsistencia.setText(\"Control de Asistencias\");\n        btnAsistencia.setBorder(null);\n        btnAsistencia.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnAsistencia.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnAsistencia.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnAsistencia.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnAsistenciaActionPerformed(evt);\n            }\n        });\n\n        btnMaterias.setBackground(new java.awt.Color(51, 25, 230));\n        btnMaterias.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnMaterias.setForeground(new java.awt.Color(255, 255, 255));\n        btnMaterias.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/subject.png\"))); // NOI18N\n        btnMaterias.setText(\"Mis Materias\");\n        btnMaterias.setBorder(null);\n        btnMaterias.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnMaterias.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnMaterias.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnMaterias.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                btnMateriasActionPerformed(evt);\n            }\n        });\n\n        btnSchedule.setBackground(new java.awt.Color(51, 25, 230));\n        btnSchedule.setFont(new java.awt.Font(\"Lao UI\", 1, 18)); // NOI18N\n        btnSchedule.setForeground(new java.awt.Color(255, 255, 255));\n        btnSchedule.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/images/icons/schedule.png\"))); // NOI18N\n        btnSchedule.setText(\"Horarios\");\n        btnSchedule.setBorder(null);\n        btnSchedule.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));\n        btnSchedule.setHorizontalTextPosition(javax.swing.SwingConstants.CENTER);\n        btnSchedule.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        btnSchedule.addMouseListener(new java.awt.event.MouseAdapter() {\n            public void mouseClicked(java.awt.event.MouseEvent evt) {\n                btnScheduleMouseClicked(evt);\n            }\n        });\n\n        javax.swing.GroupLayout jPanel3Layout = new javax.swing.GroupLayout(jPanel3);\n        jPanel3.setLayout(jPanel3Layout);\n        jPanel3Layout.setHorizontalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel3Layout.createSequentialGroup()\n                .addContainerGap(83, Short.MAX_VALUE)\n                .addComponent(btnAlumnado, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(86, 86, 86)\n                .addComponent(btnMaterias, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(83, 83, 83)\n                .addComponent(btnAsistencia, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(61, 61, 61)\n                .addComponent(btnSchedule, javax.swing.GroupLayout.PREFERRED_SIZE, 216, javax.swing.GroupLayout.PREFERRED_SIZE)\n                .addGap(253, 253, 253))\n        );\n        jPanel3Layout.setVerticalGroup(\n            jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(jPanel3Layout.createSequentialGroup()\n                .addGap(37, 37, 37)\n                .addGroup(jPanel3Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(btnSchedule, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(btnAsistencia, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(btnMaterias, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(btnAlumnado, javax.swing.GroupLayout.PREFERRED_SIZE, 180, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(73, Short.MAX_VALUE))\n        );\n\n        getContentPane().add(jPanel3);\n        jPanel3.setBounds(180, 420, 1430, 290);\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void btnAsistenciaActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAsistenciaActionPerformed\n        s.reproduce(\"bep.mp3\");\n        Attendance ctrl_attendance = new Attendance();\n        ctrl_attendance.teacher_id = this.teacher_id;\n        ctrl_attendance.setVisible(true);\n    }//GEN-LAST:event_btnAsistenciaActionPerformed\n\n    private void btnPerfilActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnPerfilActionPerformed\n        s.reproduce(\"bep.mp3\");\n        Profile p = new Profile();\n        p.setTeacherId(this.teacher_id);\n        p.setVisible(true);\n    }//GEN-LAST:event_btnPerfilActionPerformed\n\n    private void btnActualizarActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnActualizarActionPerformed\n        int teacher_id = this.teacher_id;\n        s.reproduce(\"bep.mp3\");\n        Edit e = new Edit();\n        e.setTeacherId(teacher_id);\n        e.setVisible(true);\n    }//GEN-LAST:event_btnActualizarActionPerformed\n\n    private void btnNotificacionesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnNotificacionesActionPerformed\n        s.reproduce(\"bep.mp3\"); \n        Notification n = new Notification();\n        n.setVisible(true);\n    }//GEN-LAST:event_btnNotificacionesActionPerformed\n\n    private void btnMateriasActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnMateriasActionPerformed\n        int teacherId = this.teacher_id;\n        s.reproduce(\"bep.mp3\");\n        Subject s = new Subject();\n        s.setTeacherId(teacherId);\n        s.setVisible(true);\n    }//GEN-LAST:event_btnMateriasActionPerformed\n\n    private void btnAlumnadoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_btnAlumnadoActionPerformed\n        s.reproduce(\"bep.mp3\");\n        Classmate c = new Classmate();\n        c.setVisible(true);\n    }//GEN-LAST:event_btnAlumnadoActionPerformed\n\n    private void btnCloseMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnCloseMouseClicked\n        Loggin loggin = new Loggin();\n        loggin.setVisible(true);\n        this.setVisible(false);\n    }//GEN-LAST:event_btnCloseMouseClicked\n\n    private void formWindowOpened(java.awt.event.WindowEvent evt) {//GEN-FIRST:event_formWindowOpened\n        int teacher_id = this.teacher_id;\n        Hashtable teacher = ctrlT.getTeacherData(teacher_id);\n        String fullname = teacher.get(\"first_name\") + \" \" + teacher.get(\"last_name\");\n        lblWelcome.setText(\"Bienvenido \" + fullname);\n    }//GEN-LAST:event_formWindowOpened\n\n    private void btnScheduleMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_btnScheduleMouseClicked\n        s.reproduce(\"bep.mp3\");\n        Schedule s = new Schedule();\n        s.teacher_id = this.teacher_id;\n        s.setVisible(true);\n    }//GEN-LAST:event_btnScheduleMouseClicked\n\n    /**\n     * @param args the command line arguments\n     */\n    public static void main(String args[]) {\n        /* Set the Nimbus look and feel */\n        //<editor-fold defaultstate=\"collapsed\" desc=\" Look and feel setting code (optional) \">\n        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.\n         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html \n         */\n        try {\n            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {\n                if (\"Nimbus\".equals(info.getName())) {\n                    javax.swing.UIManager.setLookAndFeel(info.getClassName());\n                    break;\n                }\n            }\n        } catch (ClassNotFoundException ex) {\n            java.util.logging.Logger.getLogger(WelcomeT.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (InstantiationException ex) {\n            java.util.logging.Logger.getLogger(WelcomeT.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (IllegalAccessException ex) {\n            java.util.logging.Logger.getLogger(WelcomeT.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        } catch (javax.swing.UnsupportedLookAndFeelException ex) {\n            java.util.logging.Logger.getLogger(WelcomeT.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);\n        }\n        //</editor-fold>\n\n        /* Create and display the form */\n        java.awt.EventQueue.invokeLater(new Runnable() {\n            public void run() {\n                new WelcomeT().setVisible(true);\n            }\n        });\n    }\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JButton btnActualizar;\n    private javax.swing.JButton btnAlumnado;\n    private javax.swing.JButton btnAsistencia;\n    private javax.swing.JButton btnClose;\n    private javax.swing.JButton btnMaterias;\n    private javax.swing.JButton btnNotificaciones;\n    private javax.swing.JButton btnPerfil;\n    private javax.swing.JButton btnSchedule;\n    private javax.swing.JPanel jPanel1;\n    private javax.swing.JPanel jPanel2;\n    private javax.swing.JPanel jPanel3;\n    private javax.swing.JLabel lblTime;\n    private javax.swing.JLabel lblWelcome;\n    // End of variables declaration//GEN-END:variables\n\n\t@Override\n\tpublic void run() {\n            Thread ct = Thread.currentThread();\n            while(ct == h1) {\n                lblTime.setText(t.calcular());\n                try {\n                        Thread.sleep(1000);\n                }catch(InterruptedException e) {\n                        System.out.println(e);\n                }\n            }\n\t}\n}\n", "t;\nimport com.space.invaders.controladores.base.ControladorEstadoJuegoBase;\nimport com.space.invaders.entidades.menu.OpcionMenu;\nimport com.space.invaders.interfaces.mensajes.IColega;\nimport com.space.invaders.interfaces.mensajes.IMediador;\nimport com.space.invaders.modelos.ModeloMenuJuegoCompletado;\nimport com.space.invaders.modelos.ModeloPartidaJuego;\nimport com.space.invaders.navegacion.NombreEstado;\nimport com.space.invaders.recursos.sonido.NombreSonido;\nimport com.space.invaders.vistas.VistaEstadoMenu;\n\npublic class ControladorEstadoJuegoCompletado extends ControladorEstadoJuegoBase implements IColega{\n\n\tprivate VistaEstadoMenu vista;\n\tpublic ModeloMenuJuegoCompletado modelo;\n\tprivate final String textoTitulo = \"\u00a1Has salvado el universo!\";\n\tprivate final String FORMATO_PUNTOS = \"Tu recompenza: $%s\";\n\t\n\tpublic ControladorEstadoJuegoCompletado() {\n\t\tvista = new VistaEstadoMenu(this, textoTitulo);\n\t\tmodelo = new ModeloMenuJuegoCompletado(); \n\t}\n\t\n\t@Override\n\tpublic void actualizar(float deltaTiempo) {\n\t\tvista.actualizar(deltaTiempo);\n\t}\n\n\t@Override\n\tpublic void renderizar() {\n\t\tvista.renderizar();\n\t}\n\n\t@Override\n\tpublic void manejarEntradas() {\n\t\t\n\t\tif (Gdx.input.isKeyJustPressed(Input.Keys.ENTER)) {\n\t\t\treproducirSonido(NombreSonido.MENU_SELECCIONAR);\n\t\t\tOpcionMenu elementoMenuActual = modelo.getElementoMenuActual();\n\n\t\t\tif (elementoMenuActual != null) {\n\t\t\t\tNombreEstado nombreEstado = elementoMenuActual.getNombreRuta();\n\n\t\t\t\tswitch (nombreEstado) {\n\t\t\t\tcase Juego:\n\t\t\t\t\tcambiarEstado(NombreEstado.Juego);\n\t\t\t\t\tmediador.enviarMensaje(this,\"IniciarJuego\", null);\n\t\t\t\t\tbreak;\n\t\t\t\tcase MenuPrincipal:\n\t\t\t\t\tcambiarEstado(NombreEstado.MenuPrincipal);\n\t\t\t\t\tbreak;\n\t\t\t\tcase Salir:\n\t\t\t\t\tGdx.app.exit();\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (Gdx.input.isKeyJustPressed(Input.Keys.UP)) {\n\t\t\treproducirSonido(NombreSonido.MENU_MOVER);\n\t\t\tmodelo.moverElementoAnterior();\n\t\t}\n\n\t\tif (Gdx.input.isKeyJustPressed(Input.Keys.DOWN)) {\n\t\t\treproducirSonido(NombreSonido.MENU_MOVER);\n\t\t\tmodelo.moverElementoSiguiente();\n\t\t}\n\t\t\n\t}\n\n\t@Override\n\tpublic void dispose() {\n\t\tvista.dispose();\n\t}\n\n\t@Override\n\tpublic void inicializar() {\n\t\tvista.inicializar();\n\t\tModeloPartidaJuego modeloPartidaJuego = ModeloPartidaJuego.getInstancia();\n\t\tvista.setSubTitulo(String.format(FORMATO_PUNTOS,modeloPartidaJuego.getPuntos()));\n\t\tvista.setOpcionesMenu(modelo.getElementosMenu());\n\t}\n\n\tprivate IMediador mediador;\n\t\n\t@Override\n\tpublic void setMediador(IMediador mediador) {\n\t\tthis.mediador = mediador;\n\t}\n\n\t@Override\n\tpublic void recibirMensaje(String mensaje, Object data) {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n", "ion, v2.2.8-b130911.1802 \n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \n// Any modifications to this file will be lost upon recompilation of the source schema. \n// Generated on: 2017.11.30 at 08:24:17 PM JST \n//\n\n\npackage uk.org.siri.siri;\n\nimport javax.xml.bind.annotation.XmlEnum;\nimport javax.xml.bind.annotation.XmlEnumValue;\nimport javax.xml.bind.annotation.XmlType;\n\n\n/**\n * <p>Java class for FacilityStatusChangeEnumeration.\n * \n * <p>The following schema fragment specifies the expected content contained within this class.\n * <p>\n * <pre>\n * &lt;simpleType name=\"FacilityStatusChangeEnumeration\">\n *   &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}NMTOKEN\">\n *     &lt;enumeration value=\"unknown\"/>\n *     &lt;enumeration value=\"added\"/>\n *     &lt;enumeration value=\"removed\"/>\n *   &lt;/restriction>\n * &lt;/simpleType>\n * </pre>\n * \n */\n@XmlType(name = \"FacilityStatusChangeEnumeration\")\n@XmlEnum\npublic enum FacilityStatusChangeEnumeration {\n\n    @XmlEnumValue(\"unknown\")\n    UNKNOWN(\"unknown\"),\n    @XmlEnumValue(\"added\")\n    ADDED(\"added\"),\n    @XmlEnumValue(\"removed\")\n    REMOVED(\"removed\");\n    private final String value;\n\n    FacilityStatusChangeEnumeration(String v) {\n        value = v;\n    }\n\n    public String value() {\n        return value;\n    }\n\n    public static FacilityStatusChangeEnumeration fromValue(String v) {\n        for (FacilityStatusChangeEnumeration c: FacilityStatusChangeEnumeration.values()) {\n            if (c.value.equals(v)) {\n                return c;\n            }\n        }\n        throw new IllegalArgumentException(v);\n    }\n\n}\n", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springframework.messaging.handler.invocation;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\nimport java.util.Arrays;\n\nimport org.springframework.core.DefaultParameterNameDiscoverer;\nimport org.springframework.core.GenericTypeResolver;\nimport org.springframework.core.MethodParameter;\nimport org.springframework.core.ParameterNameDiscoverer;\nimport org.springframework.core.ResolvableType;\nimport org.springframework.messaging.Message;\nimport org.springframework.messaging.handler.HandlerMethod;\nimport org.springframework.util.ClassUtils;\nimport org.springframework.util.ReflectionUtils;\n\n/**\n * Provides a method for invoking the handler method for a given message after resolving its\n * method argument values through registered {@link HandlerMethodArgumentResolver}s.\n *\n * <p>Use {@link #setMessageMethodArgumentResolvers} to customize the list of argument resolvers.\n *\n * @author Rossen Stoyanchev\n * @author Juergen Hoeller\n * @since 4.0\n */\npublic class InvocableHandlerMethod extends HandlerMethod {\n\n\tprivate HandlerMethodArgumentResolverComposite argumentResolvers = new HandlerMethodArgumentResolverComposite();\n\n\tprivate ParameterNameDiscoverer parameterNameDiscoverer = new DefaultParameterNameDiscoverer();\n\n\n\t/**\n\t * Create an instance from a {@code HandlerMethod}.\n\t */\n\tpublic InvocableHandlerMethod(HandlerMethod handlerMethod) {\n\t\tsuper(handlerMethod);\n\t}\n\n\t/**\n\t * Create an instance from a bean instance and a method.\n\t */\n\tpublic InvocableHandlerMethod(Object bean, Method method) {\n\t\tsuper(bean, method);\n\t}\n\n\t/**\n\t * Construct a new handler method with the given bean instance, method name and parameters.\n\t * @param bean the object bean\n\t * @param methodName the method name\n\t * @param parameterTypes the method parameter types\n\t * @throws NoSuchMethodException when the method cannot be found\n\t */\n\tpublic InvocableHandlerMethod(Object bean, String methodName, Class<?>... parameterTypes)\n\t\t\tthrows NoSuchMethodException {\n\n\t\tsuper(bean, methodName, parameterTypes);\n\t}\n\n\n\t/**\n\t * Set {@link HandlerMethodArgumentResolver}s to use to use for resolving method argument values.\n\t */\n\tpublic void setMessageMethodArgumentResolvers(HandlerMethodArgumentResolverComposite argumentResolvers) {\n\t\tthis.argumentResolvers = argumentResolvers;\n\t}\n\n\t/**\n\t * Set the ParameterNameDiscoverer for resolving parameter names when needed\n\t * (e.g. default request attribute name).\n\t * <p>Default is a {@link org.springframework.core.DefaultParameterNameDiscoverer}.\n\t */\n\tpublic void setParameterNameDiscoverer(ParameterNameDiscoverer parameterNameDiscoverer) {\n\t\tthis.parameterNameDiscoverer = parameterNameDiscoverer;\n\t}\n\n\n\t/**\n\t * Invoke the method after resolving its argument values in the context of the given message.\n\t * <p>Argument values are commonly resolved through {@link HandlerMethodArgumentResolver}s.\n\t * The {@code providedArgs} parameter however may supply argument values to be used directly,\n\t * i.e. without argument resolution.\n\t * @param message the current message being processed\n\t * @param providedArgs \"given\" arguments matched by type, not resolved\n\t * @return the raw value returned by the invoked method\n\t * @exception Exception raised if no suitable argument resolver can be found,\n\t * or if the method raised an exception\n\t */\n\tpublic Object invoke(Message<?> message, Object... providedArgs) throws Exception {\n\t\tObject[] args = getMethodArgumentValues(message, providedArgs);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Invoking '\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n\t\t\t\t\t\"' with arguments \" + Arrays.toString(args));\n\t\t}\n\t\tObject returnValue = doInvoke(args);\n\t\tif (logger.isTraceEnabled()) {\n\t\t\tlogger.trace(\"Method [\" + ClassUtils.getQualifiedMethodName(getMethod(), getBeanType()) +\n\t\t\t\t\t\"] returned [\" + returnValue + \"]\");\n\t\t}\n\t\treturn returnValue;\n\t}\n\n\t/**\n\t * Get the method argument values for the current request.\n\t */\n\tprivate Object[] getMethodArgumentValues(Message<?> message, Object... providedArgs) throws Exception {\n\t\tMethodParameter[] parameters = getMethodParameters();\n\t\tObject[] args = new Object[parameters.length];\n\t\tfor (int i = 0; i < parameters.length; i++) {\n\t\t\tMethodParameter parameter = parameters[i];\n\t\t\tparameter.initParameterNameDiscovery(this.parameterNameDiscoverer);\n\t\t\tGenericTypeResolver.resolveParameterType(parameter, getBean().getClass());\n\t\t\targs[i] = resolveProvidedArgument(parameter, providedArgs);\n\t\t\tif (args[i] != null) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (this.argumentResolvers.supportsParameter(parameter)) {\n\t\t\t\ttry {\n\t\t\t\t\targs[i] = this.argumentResolvers.resolveArgument(parameter, message);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tif (logger.isDebugEnabled()) {\n\t\t\t\t\t\tlogger.debug(getArgumentResolutionErrorMessage(\"Error resolving argument\", i), ex);\n\t\t\t\t\t}\n\t\t\t\t\tthrow ex;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (args[i] == null) {\n\t\t\t\tString msg = getArgumentResolutionErrorMessage(\"No suitable resolver for argument\", i);\n\t\t\t\tthrow new IllegalStateException(msg);\n\t\t\t}\n\t\t}\n\t\treturn args;\n\t}\n\n\tprivate String getArgumentResolutionErrorMessage(String message, int index) {\n\t\tMethodParameter param = getMethodParameters()[index];\n\t\tmessage += \" [\" + index + \"] [type=\" + param.getParameterType().getName() + \"]\";\n\t\treturn getDetailedErrorMessage(message);\n\t}\n\n\t/**\n\t * Adds HandlerMethod details such as the controller type and method\n\t * signature to the given error message.\n\t * @param message error message to append the HandlerMethod details to\n\t */\n\tprotected String getDetailedErrorMessage(String message) {\n\t\tStringBuilder sb = new StringBuilder(message).append(\"\\n\");\n\t\tsb.append(\"HandlerMethod details: \\n\");\n\t\tsb.append(\"Controller [\").append(getBeanType().getName()).append(\"]\\n\");\n\t\tsb.append(\"Method [\").append(getBridgedMethod().toGenericString()).append(\"]\\n\");\n\t\treturn sb.toString();\n\t}\n\n\t/**\n\t * Attempt to resolve a method parameter from the list of provided argument values.\n\t */\n\tprivate Object resolveProvidedArgument(MethodParameter parameter, Object... providedArgs) {\n\t\tif (providedArgs == null) {\n\t\t\treturn null;\n\t\t}\n\t\tfor (Object providedArg : providedArgs) {\n\t\t\tif (parameter.getParameterType().isInstance(providedArg)) {\n\t\t\t\treturn providedArg;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t/**\n\t * Invoke the handler method with the given argument values.\n\t */\n\tprotected Object doInvoke(Object... args) throws Exception {\n\t\tReflectionUtils.makeAccessible(getBridgedMethod());\n\t\ttry {\n\t\t\treturn getBridgedMethod().invoke(getBean(), args);\n\t\t}\n\t\tcatch (IllegalArgumentException ex) {\n\t\t\tassertTargetBean(getBridgedMethod(), getBean(), args);\n\t\t\tString message = (ex.getMessage() != null ? ex.getMessage() : \"Illegal argument\");\n\t\t\tthrow new IllegalStateException(getInvocationErrorMessage(message, args), ex);\n\t\t}\n\t\tcatch (InvocationTargetException ex) {\n\t\t\t// Unwrap for HandlerExceptionResolvers ...\n\t\t\tThrowable targetException = ex.getTargetException();\n\t\t\tif (targetException instanceof RuntimeException) {\n\t\t\t\tthrow (RuntimeException) targetException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Error) {\n\t\t\t\tthrow (Error) targetException;\n\t\t\t}\n\t\t\telse if (targetException instanceof Exception) {\n\t\t\t\tthrow (Exception) targetException;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tString msg = getInvocationErrorMessage(\"Failed to invoke controller method\", args);\n\t\t\t\tthrow new IllegalStateException(msg, targetException);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Assert that the target bean class is an instance of the class where the given\n\t * method is declared. In some cases the actual controller instance at request-\n\t * processing time may be a JDK dynamic proxy (lazy initialization, prototype\n\t * beans, and others). {@code @Controller}'s that require proxying should prefer\n\t * class-based proxy mechanisms.\n\t */\n\tprivate void assertTargetBean(Method method, Object targetBean, Object[] args) {\n\t\tClass<?> methodDeclaringClass = method.getDeclaringClass();\n\t\tClass<?> targetBeanClass = targetBean.getClass();\n\t\tif (!methodDeclaringClass.isAssignableFrom(targetBeanClass)) {\n\t\t\tString msg = \"The mapped controller method class '\" + methodDeclaringClass.getName() +\n\t\t\t\t\t\"' is not an instance of the actual controller bean class '\" +\n\t\t\t\t\ttargetBeanClass.getName() + \"'. If the controller requires proxying \" +\n\t\t\t\t\t\"(e.g. due to @Transactional), please use class-based proxying.\";\n\t\t\tthrow new IllegalStateException(getInvocationErrorMessage(msg, args));\n\t\t}\n\t}\n\n\tprivate String getInvocationErrorMessage(String message, Object[] resolvedArgs) {\n\t\tStringBuilder sb = new StringBuilder(getDetailedErrorMessage(message));\n\t\tsb.append(\"Resolved arguments: \\n\");\n\t\tfor (int i = 0; i < resolvedArgs.length; i++) {\n\t\t\tsb.append(\"[\").append(i).append(\"] \");\n\t\t\tif (resolvedArgs[i] == null) {\n\t\t\t\tsb.append(\"[null] \\n\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsb.append(\"[type=\").append(resolvedArgs[i].getClass().getName()).append(\"] \");\n\t\t\t\tsb.append(\"[value=\").append(resolvedArgs[i]).append(\"]\\n\");\n\t\t\t}\n\t\t}\n\t\treturn sb.toString();\n\t}\n\n\tMethodParameter getAsyncReturnValueType(Object returnValue) {\n\t\treturn new AsyncResultMethodParameter(returnValue);\n\t}\n\n\n\tprivate class AsyncResultMethodParameter extends HandlerMethodParameter {\n\n\t\tprivate final Object returnValue;\n\n\t\tprivate final ResolvableType returnType;\n\n\t\tpublic AsyncResultMethodParameter(Object returnValue) {\n\t\t\tsuper(-1);\n\t\t\tthis.returnValue = returnValue;\n\t\t\tthis.returnType = ResolvableType.forType(super.getGenericParameterType()).getGeneric(0);\n\t\t}\n\n\t\tprotected AsyncResultMethodParameter(AsyncResultMethodParameter original) {\n\t\t\tsuper(original);\n\t\t\tthis.returnValue = original.returnValue;\n\t\t\tthis.returnType = original.returnType;\n\t\t}\n\n\t\t@Override\n\t\tpublic Class<?> getParameterType() {\n\t\t\tif (this.returnValue != null) {\n\t\t\t\treturn this.returnValue.getClass();\n\t\t\t}\n\t\t\tif (!ResolvableType.NONE.equals(this.returnType)) {\n\t\t\t\treturn this.returnType.getRawClass();\n\t\t\t}\n\t\t\treturn super.getParameterType();\n\t\t}\n\n\t\t@Override\n\t\tpublic Type getGenericParameterType() {\n\t\t\treturn this.returnType.getType();\n\t\t}\n\n\t\t@Override\n\t\tpublic AsyncResultMethodParameter clone() {\n\t\t\treturn new AsyncResultMethodParameter(this);\n\t\t}\n\t}\n\n}\n", ";\nimport net.myrrix.client.ClientRecommender;\nimport net.myrrix.client.MyrrixClientConfiguration;\nimport net.myrrix.client.translating.TranslatingClientRecommender;\nimport org.wikimedia.wikibase.entitysuggester.client.EntityType;\nimport org.wikimedia.wikibase.entitysuggester.client.recommenders.Recommender;\nimport org.wikimedia.wikibase.entitysuggester.client.recommenders.impl.MultiMapRecommender;\nimport org.wikimedia.wikibase.entitysuggester.client.recommenders.impl.PropertyRecommender;\n\n/**\n * Factory class with static method for creating recommenders for different\n * entity types.\n *\n * @author Nilesh Chakraborty\n */\npublic class RecommenderFactory {\n\n    private RecommenderFactory() {\n    }\n\n    /**\n     * @param entityType\n     * @param host\n     * @param port\n     * @return Recommender created according to entityType\n     * @throws IOException\n     */\n    public static Recommender create(EntityType entityType, String host, int port) throws IOException {\n        Recommender recommender = null;\n        switch (entityType) {\n            case CLAIM_PROPERTY:\n                recommender = createPropertyRecommender(host, port, \"myrrix-claimprops\");\n                break;\n            case REF_PROPERTY:\n                recommender = createPropertyRecommender(host, port, \"myrrix-refprops\");\n                break;\n            case QUALIFIER:\n            case VALUE:\n                recommender = new MultiMapRecommender();\n        }\n        return recommender;\n    }\n\n    /**\n     * @param host\n     * @param port\n     * @param contextPath\n     * @return PropertyRecommender by configuring a Myrrix client with the given\n     * host, port and contextPath.\n     * @throws IOException\n     */\n    public static PropertyRecommender createPropertyRecommender(String host, int port, String contextPath) throws IOException {\n        MyrrixClientConfiguration config = new MyrrixClientConfiguration();\n        config.setHost(host);\n        config.setPort(port);\n        config.setContextPath(contextPath);\n        return new PropertyRecommender(new TranslatingClientRecommender(new ClientRecommender(config)));\n    }\n}\n", "ntent.Intent;\nimport android.content.SharedPreferences;\nimport android.os.Binder;\nimport android.os.IBinder;\n\n\n/*\n * You have to add this in your manifest\n \n<service android:name=\"org.OpenUDID.OpenUDID_service\">\n\t<intent-filter>\n\t\t<action android:name=\"org.OpenUDID.GETUDID\" />\n\t</intent-filter>\n</service>\n\n*/\n\n\npublic class OpenUDID_service extends Service{\n\t@Override\n\tpublic IBinder onBind(Intent arg0) {\n\t\treturn new  Binder() {\n\t\t\t@Override\n\t\t\tpublic boolean onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags) {\n\t\t\t\tfinal SharedPreferences preferences = getSharedPreferences(OpenUDID_manager.PREFS_NAME, Context.MODE_PRIVATE);\n\t\t\n\t\t\t\treply.writeInt(data.readInt()); //Return to the sender the input random number\n\t\t\t\treply.writeString(preferences.getString(OpenUDID_manager.PREF_KEY, null));\n\t\t\t\treturn true;\n\t\t\t}\n\t\t};\n\t}\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.machinelearning;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Asset output port.\n */\npublic class OutputPort {\n    /**\n     * Port data type. Possible values include: 'Dataset'.\n     */\n    @JsonProperty(value = \"type\")\n    private OutputPortType type;\n\n    /**\n     * Get the type value.\n     *\n     * @return the type value\n     */\n    public OutputPortType type() {\n        return this.type;\n    }\n\n    /**\n     * Set the type value.\n     *\n     * @param type the type value to set\n     * @return the OutputPort object itself.\n     */\n    public OutputPort withType(OutputPortType type) {\n        this.type = type;\n        return this;\n    }\n\n}\n", "g.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.Matchers.equalTo;\n\npublic class UploadFileTest {\n    public static WebLocator container = new WebLocator().setId(\"ID\");\n\n    @DataProvider\n    public static Object[][] testConstructorPathDataProvider() {\n        return new Object[][]{\n                {new UploadFile(),                          \"//div[contains(concat(' ', @class, ' '), ' fileupload ')]\"},\n                {new UploadFile(container),                 \"//*[@id='ID']//div[contains(concat(' ', @class, ' '), ' fileupload ')]\"},\n                {new UploadFile(container, \"ButtonLabel\"),  \"//*[@id='ID']//label[text()='ButtonLabel']//following-sibling::*//div[contains(concat(' ', @class, ' '), ' fileupload ')]\"},\n                {new UploadFile(container).setId(\"ID\"),     \"//*[@id='ID']//div[@id='ID' and contains(concat(' ', @class, ' '), ' fileupload ')]\"},\n        };\n    }\n\n    @Test(dataProvider = \"testConstructorPathDataProvider\")\n    public void getPathSelectorCorrectlyFromConstructors(UploadFile uploadFile, String expectedXpath) {\n        assertThat(uploadFile.getXPath(), equalTo(expectedXpath));\n    }\n}", "sonProperty;\nimport org.apache.commons.lang3.StringUtils;\nimport org.json.JSONObject;\n\nimport java.time.OffsetDateTime;\n\n/**\n * Change event's payload.  Created to properly nest the payload field.\n */\npublic class ChangeEventPayload {\n    @JsonProperty(\"summary\")\n    private final String summary;\n    @JsonProperty(\"source\")\n    private final String source;\n    @JsonProperty(\"timestamp\")\n    private final String timestamp;\n    @JsonProperty(\"custom_details\")\n    private final JSONObject customDetails;\n\n    private ChangeEventPayload(Builder builder) {\n        this.summary = builder.getSummary();\n        this.source = builder.getSource();\n        this.timestamp = builder.getTimestamp() != null ? builder.getTimestamp().toString() : null;\n        this.customDetails = builder.getCustomDetails();\n    }\n\n    @Override\n    public String toString() {\n        return \"ChangeEventPayload { \" +\n                \"summary=\" + summary +\n                \", source=\" + source +\n                \", timestamp=\" + timestamp +\n                \", custom_details=\" + customDetails +\n                \" }\";\n    }\n\n    public String getSummary() {\n        return summary;\n    }\n\n    public String getSource() {\n        return source;\n    }\n\n    public String getTimestamp() {\n        return timestamp;\n    }\n\n    public Object getCustomDetails() {\n        return customDetails;\n    }\n\n    public static class Builder {\n        private String summary;\n        private String source;\n        private OffsetDateTime timestamp;\n        private JSONObject customDetails;\n\n        /**\n         * Builder which helps constructing new change event payload instances\n         */\n        private Builder() {\n        }\n\n        public static Builder newBuilder() {\n            return new Builder();\n        }\n\n        /**\n         * @param summary A brief text summary of the change event.\n         * @return ChangeEventPayload Builder with the summary field populated to be able to keep populating the instance\n         */\n        public Builder setSummary(String summary) {\n            this.summary = summary;\n            return this;\n        }\n\n        /**\n         * @param source Where the change event originated from.\n         * @return ChangeEventPayload Builder with the source field populated to be able to keep populating the instance\n         */\n        public Builder setSource(String source) {\n            this.source = source;\n            return this;\n        }\n\n        /**\n         * @param timestamp The time at which the change took place, in ISO 8601 format.\n         * @return ChangeEventPayload Builder with the timestamp field populated to be able to keep populating the instance\n         */\n        public Builder setTimestamp(OffsetDateTime timestamp) {\n            this.timestamp = timestamp;\n            return this;\n        }\n\n        /**\n         * @param customDetails An arbitrary JSON object containing any data you'd like included with the change event.\n         * @return ChangeEventPayload Builder with the customDetails field populated to be able to keep populating the instance\n         */\n        public Builder setCustomDetails(JSONObject customDetails) {\n            this.customDetails = customDetails;\n            return this;\n        }\n\n        public String getSummary() {\n            return summary;\n        }\n\n        public String getSource() {\n            return source;\n        }\n\n        public OffsetDateTime getTimestamp() {\n            return timestamp;\n        }\n\n        public JSONObject getCustomDetails() {\n            return customDetails;\n        }\n\n        /**\n         * Make sure the required fields are not empty, then create a payload.\n         */\n        public ChangeEventPayload build() {\n            if (StringUtils.isBlank(getSummary())) {\n                throw new IllegalArgumentException(\"summary cannot be blank.\");\n            }\n\n            return new ChangeEventPayload(this);\n        }\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) {\n            return true;\n        }\n\n        if (o == null || getClass() != o.getClass()) {\n            return false;\n        }\n\n        ChangeEventPayload payload = (ChangeEventPayload) o;\n\n        if (summary != null ? !summary.equals(payload.getSummary()) : payload.getSummary() != null) {\n            return false;\n        }\n\n        if (source != null ? !source.equals(payload.getSource()) : payload.getSource() != null) {\n            return false;\n        }\n\n        if (timestamp != null ? !timestamp.equals(payload.getTimestamp()) : payload.getTimestamp() != null) {\n            return false;\n        }\n\n        if (customDetails != null ? !customDetails.equals(payload.getCustomDetails()) : payload.getCustomDetails() != null) {\n            return false;\n        }\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = summary != null ? summary.hashCode() : 0;\n        result = 31 * result + (source != null ? source.hashCode() : 0);\n        result = 31 * result + (timestamp != null ? timestamp.hashCode() : 0);\n        result = 31 * result + (customDetails != null ? customDetails.hashCode() : 0);\n        return result;\n    }\n}\n", "final long serialVersionUID = -8977609633958010959L;\n\n\tpublic CareerHubApiException(String message) {\n\t\tsuper(message);\n\t}\n\t\n\tpublic CareerHubApiException(Throwable inner) {\n\t\tsuper(inner);\n\t}\n\n\tpublic CareerHubApiException(String message, Throwable inner) {\n\t\tsuper(message, inner);\n\t}\n}\n", ".version_1.structure.IncomingExtraUserMonitorAgent;\n\nimport com.bitdubai.fermat_pip_api.layer.pip_platform_service.error_manager.ErrorManager;\nimport com.bitdubai.fermat_cry_api.layer.crypto_router.incoming_crypto.IncomingCryptoManager;\nimport com.bitdubai.fermat_dmp_plugin.layer.transaction.incoming_extra_user.developer.bitdubai.version_1.structure.IncomingExtraUserMonitorAgent;\nimport com.bitdubai.fermat_dmp_plugin.layer.transaction.incoming_extra_user.developer.bitdubai.version_1.structure.IncomingExtraUserRegistry;\n\nimport static org.fest.assertions.api.Assertions.*;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\n/**\n * Created by jorgegonzalez on 2015.07.02..\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class ConstructionTest {\n\n    @Mock\n    private ErrorManager mockErrorManager;\n\n    @Mock\n    private IncomingCryptoManager mockIncomingCryptoManager;\n\n    @Mock\n    private IncomingExtraUserRegistry mockRegistry;\n\n    private IncomingExtraUserMonitorAgent testMonitorAgent;\n\n    @Test\n    public void Construction_ValidParameters_NewObjectCreated() {\n        testMonitorAgent = new IncomingExtraUserMonitorAgent(mockErrorManager, mockIncomingCryptoManager, mockRegistry);\n        assertThat(testMonitorAgent).isNotNull();\n    }\n}\n", ".*;\n\n// https://www.hackerrank.com/challenges/alternating-characters\npublic class Solution {\n\n    static int alternatingCharacters(String s){\n        // Complete this function\n        int count = 0;\n        // save the last character seen\n        char lastCharacter = s.charAt(0);\n        \n        // compare the current character with the last seen one\n        for (int i = 1; i < s.length(); i++) {\n            // if equal then count++\n            if (s.charAt(i) == lastCharacter)\n                count++;\n            else // else update the last character seen\n                lastCharacter = s.charAt(i);\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Scanner in = new Scanner(System.in);\n        int q = in.nextInt();\n        for(int a0 = 0; a0 < q; a0++){\n            String s = in.next();\n            int result = alternatingCharacters(s);\n            System.out.println(result);\n        }\n    }\n}\n", "", "bok.Data;\nimport org.timothyb89.lifx.net.field.MACAddress;\nimport org.timothyb89.lifx.net.packet.Packet;\n\n/**\n * Represents a packet response. By default responses consist of packet types\n * defined in {@link Packet#expectedResponses()}, but additional expectations\n * may be defined at sending time with {@link #expect(int)} and\n * {@link #expect(int, MACAddress)}.\n * @author tim\n */\n@Data\npublic class PacketResponse {\n\t\n\tprivate final Packet packet;\n\t\n\tprivate List<Integer> expecting;\n\tprivate List<SourcedExpectation> expectingSourced;\n\tprivate List<Packet> responses;\n\n\tpublic PacketResponse(Packet packet) {\n\t\tthis.packet = packet;\n\t\t\n\t\texpecting = new LinkedList<>();\n\t\tfor (int type : packet.expectedResponses()) {\n\t\t\texpecting.add(type);\n\t\t}\n\t\t\n\t\texpectingSourced = new LinkedList<>();\n\t\t\n\t\tresponses = new LinkedList<>();\n\t}\n\t\n\tprivate SourcedExpectation getExpectation(int type, MACAddress address) {\n\t\tfor (SourcedExpectation e : expectingSourced) {\n\t\t\tif (e.type == type && e.address.equals(address)) {\n\t\t\t\treturn e;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tpublic boolean isExpecting(int packetType) {\n\t\treturn expecting.contains(packetType);\n\t}\n\t\n\tpublic boolean isExpecting(int packetType, MACAddress address) {\n\t\treturn isExpecting(packetType)\n\t\t\t\t|| getExpectation(packetType, address) != null;\n\t}\n\t\n\tpublic boolean isFulfilled() {\n\t\treturn expecting.isEmpty() && expectingSourced.isEmpty();\n\t}\n\t\n\tpublic void addResponse(Packet response) {\n\t\tint type = response.getPacketType();\n\t\t\n\t\tif (expecting.contains(type)) {\n\t\t\texpecting.remove((Integer) response.getPacketType());\n\t\t\tresponses.add(response);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tSourcedExpectation ex = getExpectation(type, response.getBulbAddress());\n\t\tif (ex != null) {\n\t\t\texpectingSourced.remove(ex);\n\t\t\tresponses.add(response);\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tthrow new IllegalArgumentException(String.format(\n\t\t\t\t\"Unexpected response: 0x%02X\", response.getPacketType()));\n\t}\n\t\n\t/**\n\t * Expects a response with a packet type of {@code type}.\n\t * @param type the type to match\n\t * @return this PacketResponse\n\t */\n\tpublic PacketResponse expect(int type) {\n\t\texpecting.add(type);\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Expects a response with a packet type of {@code type} and a matching\n\t * {@code bulbAddress}.\n\t * @param type the type to match\n\t * @param address the bulb MAC address to match\n\t * @return this PacketResponse\n\t */\n\tpublic PacketResponse expect(int type, MACAddress address) {\n\t\texpectingSourced.add(new SourcedExpectation(address, type));\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Gets the first packet of the given type from the list of responses. If no\n\t * matching packet is found, {@code null} is returned. Note that order is\n\t * not guaranteed; response ordering is \"best effort\".\n\t * @param <T> the packet type\n\t * @param type the type of the packet to \n\t * @return a matching packet instance, if any\n\t */\n\tpublic <T extends Packet> T get(Class<T> type) {\n\t\tfor (Packet response : responses) {\n\t\t\tif (type.isInstance(response)) {\n\t\t\t\treturn (T) response;\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate class SourcedExpectation {\n\t\t\n\t\tprivate final MACAddress address;\n\t\tprivate final int type;\n\n\t\tprivate SourcedExpectation(MACAddress address, int type) {\n\t\t\tthis.address = address;\n\t\t\tthis.type = type;\n\t\t}\n\t\t\n\t}\n\t\n}\n", " org.apache.commons.lang3.builder.ToStringStyle;\n\npublic final class ClickEvent\n{\n    private final Action action;\n    private final String value;\n\n    public ClickEvent(final Action action, final String value)\n    {\n        this.action = action;\n        this.value = value;\n    }\n\n    public Action getAction()\n    {\n        return this.action;\n    }\n\n    public String getValue()\n    {\n        return this.value;\n    }\n\n    @Override\n    public String toString()\n    {\n        return new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE).appendSuper(super.toString()).append(\"action\", this.action).append(\"value\", this.value).toString();\n    }\n\n    public enum Action\n    {\n        OPEN_URL,\n        OPEN_FILE,\n        RUN_COMMAND,\n        SUGGEST_COMMAND;\n\n        Action()\n        {\n        }\n    }\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.synapse.generated;\n\nimport com.azure.core.util.Context;\n\n/** Samples for KustoPools Stop. */\npublic final class KustoPoolsStopSamples {\n    /*\n     * x-ms-original-file: specification/synapse/resource-manager/Microsoft.Synapse/preview/2021-06-01-preview/examples/KustoPoolsStop.json\n     */\n    /**\n     * Sample code: kustoPoolsStop.\n     *\n     * @param manager Entry point to SynapseManager.\n     */\n    public static void kustoPoolsStop(com.azure.resourcemanager.synapse.SynapseManager manager) {\n        manager.kustoPools().stop(\"kustorptest\", \"kustoclusterrptest4\", \"kustorptest\", Context.NONE);\n    }\n}\n", "\n/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, 2 + 2);\n    }\n}", "ssagesModel.ModelFactory;\nimport MessagesModel.TeamScoredMessage;\n\npublic class TeamScoredRegex implements IRegex\n{\n\tprivate static final String regex = \"Team \\\"(?<team>CT|TERRORIST)\\\" scored \\\"(?<score>\\\\d+)\\\" with \\\"(?<players>\\\\d+)\\\" players\";\n\n\tpublic TeamScoredRegex()\n\t{\n\t\tRegexParser.getInstance().registerRegex(this);\n\t}\n\t\n\t@Override\n\tpublic Message tryCreatingMessage(String input)\n\t{\n\t\tPattern p = Pattern.compile(regex);\n\t\tMatcher m = p.matcher(input);\n\t\tTeamScoredMessage message = null;\n\t\t\n\t\tif(m.find())\n\t\t{\n\t\t\tmessage = ModelFactory.eINSTANCE.createTeamScoredMessage();\n\t\t\t\n\t\t\tmessage.setTeam(m.group(\"team\"));\n\t\t\tmessage.setScore(m.group(\"score\"));\n\t\t\tmessage.setPlayers(m.group(\"players\"));\n\t\t}\n\t\t\n\t\treturn message;\n\t}\n}\n", "r;\n\nimport org.seqcode.ml.clustering.Cluster;\nimport org.seqcode.ml.clustering.ClusterRepresentative;\nimport org.seqcode.ml.clustering.ClusteringMethod;\nimport org.seqcode.ml.clustering.PairwiseElementMetric;\nimport org.seqcode.ml.clustering.SingletonCluster;\n\n\n/**\n * @author Timothy Danford\n *\n */\npublic class HierarchicalClustering<X> implements ClusteringMethod<X> {\n    \n    private ClusterRepresentative<X> repr;\n    private PairwiseElementMetric<X> metric;\n    private double maxDistanceToAccept;\n\t\n    public HierarchicalClustering(ClusterRepresentative<X> rep, PairwiseElementMetric<X> m) { \n        repr = rep;\n        metric = m;\n        maxDistanceToAccept = Double.MAX_VALUE;\n    }\n\n    public void setMaxDistanceToAccept(double d) {\n        maxDistanceToAccept = d;\n    }\n\n    /* (non-Javadoc)\n     * @see org.seqcode.gse.clustering.ClusteringMethod#clusterElements(java.util.Collection)\n     */\n    public Collection<Cluster<X>> clusterElements(Collection<X> elmts) {\n        Vector<Cluster<X>> clusters = new Vector<Cluster<X>>();\n        Vector<X> reps = new Vector<X>();\n        Double distances[][] = new Double[elmts.size()][elmts.size()];\n        for(X ce : elmts) { \n            Cluster<X> c= new SingletonCluster<X>(ce);\n            clusters.add(c);\n            X repMember = repr.getRepresentative(c);\n            reps.add(repMember);\n        }\n        for (int i = 0; i < elmts.size(); i++) {\n            for (int j = 0; j < elmts.size(); j++) {\n                X r1 = reps.get(i);\n                X r2 = reps.get(j);\n                distances[i][j] = metric.evaluate(r1,r2);\n            }\n        }\n        \n        int nclusters = clusters.size();\n        while(nclusters > 1) { \n            int mini = -1, minj = -1;\n            double mindist = Double.MAX_VALUE;\n\n            for(int i = 0; i < clusters.size() - 1; i++) { \n                if (clusters.get(i) == null) {continue;}\n                for(int j = i + 1; j < clusters.size(); j++) {\n                    if (clusters.get(j) == null) {continue;}\n                    double d;\n                    if (Double.isNaN(distances[i][j])) {\n                        X r1 = reps.get(i);\n                        X r2 = reps.get(j);\n                        d = metric.evaluate(r1, r2);\n                        distances[i][j] = d;\n                    } else {\n                        d = distances[i][j];\n                    }\n                    if(!Double.isNaN(d) && d < mindist) { \n                        mindist = d;\n                        mini = i; minj = j;\n                    }\n                }\n            }\n\t\t\n            if (mini == -1) {\n                break;\n            }\n            if (mindist > maxDistanceToAccept) {\n                break;\n            }\n            Cluster<X> left = clusters.get(mini), right = clusters.get(minj);\n            if (left == null || right == null) {\n                throw new NullPointerException(\"left is \" + left + \" + from \" + mini +\".  right is \" + right\n                                               + \" from \" + minj);\n            }\n            ClusterNode<X> node = new ClusterNode<X>(left, right);\n            clusters.set(minj,null);\n            reps.set(minj,null);\n            for (int i = 0; i < elmts.size(); i++) {\n                distances[i][minj] = Double.NaN;\n                distances[minj][i] = Double.NaN;\n                distances[i][mini] = Double.NaN;\n                distances[mini][i] = Double.NaN;\n            }\n            clusters.set(mini,node);\n            reps.set(mini,repr.getRepresentative(node));\n            nclusters--;\n            //System.out.println(\"# Clusters: \" + nclusters + \"(\" + mindist + \")\");\n        }\n        Vector<Cluster<X>> output = new Vector<Cluster<X>>();\n        for (int i = 0; i < clusters.size(); i++) {\n            if (clusters.get(i) != null) {\n                output.add(clusters.get(i));\n            }\n        }\n        return output;\n    }\n\n}\n", "onfig {\n    public final static boolean DEBUG = true;\n}", "is template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage StockManamgement.Web.Beans;\r\n\r\nimport StockManagement.ObjectModel.ValueObject.Company;\r\nimport javax.faces.context.FacesContext;\r\nimport javax.servlet.http.HttpServletRequest;\r\nimport javax.servlet.http.HttpSession;\r\n\r\npublic class SessionUtils {\r\n\r\n\tpublic static HttpSession getSession() {\r\n\t\treturn (HttpSession) FacesContext.getCurrentInstance()\r\n\t\t\t\t.getExternalContext().getSession(false);\r\n\t}\r\n\r\n\tpublic static HttpServletRequest getRequest() {\r\n\t\treturn (HttpServletRequest) FacesContext.getCurrentInstance()\r\n\t\t\t\t.getExternalContext().getRequest();\r\n\t}\r\n\r\n\tpublic static String getUserName() {\r\n\t\tHttpSession session = (HttpSession) FacesContext.getCurrentInstance()\r\n\t\t\t\t.getExternalContext().getSession(false);\r\n\t\treturn session.getAttribute(\"username\").toString();\r\n\t}\r\n\r\n\tpublic static String getUserId() {\r\n\t\tHttpSession session = getSession();\r\n\t\tif (session != null)\r\n\t\t\treturn (String) session.getAttribute(\"userid\");\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n        public static Company getSelectedCompany() {\r\n\t\tHttpSession session = getSession();\r\n\t\tif (session != null)\r\n\t\t\treturn (Company)session.getAttribute(\"SelectedCompany\");\r\n\t\telse\r\n\t\t\treturn null;\r\n\t}\r\n}", "er(\"span\");\n\t}\n\t\n}\n", "public class Y {\n\t\n\tpublic static void main(String[] args) {\n\t\tZ2 z = new Z2();\n\t\tX x = new X();\n\t\tN n = new N();\n\t\t//n.k = 9;\n\t\t//n.fooo();\n\t\tn.e\n\t}\n\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n * def\n */\n\npackage com.microsoft.azure.management.datamigration.v2017_11_15_preview.implementation;\n\nimport com.microsoft.azure.arm.resources.collection.implementation.GroupableResourcesCoreImpl;\nimport com.microsoft.azure.management.datamigration.v2017_11_15_preview.Services;\nimport com.microsoft.azure.management.datamigration.v2017_11_15_preview.DataMigrationService;\nimport rx.Observable;\nimport rx.Completable;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport com.microsoft.azure.arm.resources.ResourceUtilsCore;\nimport com.microsoft.azure.arm.utils.RXMapper;\nimport rx.functions.Func1;\nimport com.microsoft.azure.PagedList;\nimport com.microsoft.azure.Page;\nimport com.microsoft.azure.management.datamigration.v2017_11_15_preview.DataMigrationServiceStatusResponse;\nimport com.microsoft.azure.management.datamigration.v2017_11_15_preview.NameAvailabilityResponse;\nimport com.microsoft.azure.management.datamigration.v2017_11_15_preview.NameAvailabilityRequest;\nimport com.microsoft.azure.management.datamigration.v2017_11_15_preview.AvailableServiceSku;\n\nclass ServicesImpl extends GroupableResourcesCoreImpl<DataMigrationService, DataMigrationServiceImpl, DataMigrationServiceInner, ServicesInner, DataMigrationManager>  implements Services {\n    protected ServicesImpl(DataMigrationManager manager) {\n        super(manager.inner().services(), manager);\n    }\n\n    @Override\n    protected Observable<DataMigrationServiceInner> getInnerAsync(String resourceGroupName, String name) {\n        ServicesInner client = this.inner();\n        return client.getByResourceGroupAsync(resourceGroupName, name);\n    }\n\n    @Override\n    protected Completable deleteInnerAsync(String resourceGroupName, String name) {\n        ServicesInner client = this.inner();\n        return client.deleteAsync(resourceGroupName, name).toCompletable();\n    }\n\n    @Override\n    public Observable<String> deleteByIdsAsync(Collection<String> ids) {\n        if (ids == null || ids.isEmpty()) {\n            return Observable.empty();\n        }\n        Collection<Observable<String>> observables = new ArrayList<>();\n        for (String id : ids) {\n            final String resourceGroupName = ResourceUtilsCore.groupFromResourceId(id);\n            final String name = ResourceUtilsCore.nameFromResourceId(id);\n            Observable<String> o = RXMapper.map(this.inner().deleteAsync(resourceGroupName, name), id);\n            observables.add(o);\n        }\n        return Observable.mergeDelayError(observables);\n    }\n\n    @Override\n    public Observable<String> deleteByIdsAsync(String...ids) {\n        return this.deleteByIdsAsync(new ArrayList<String>(Arrays.asList(ids)));\n    }\n\n    @Override\n    public void deleteByIds(Collection<String> ids) {\n        if (ids != null && !ids.isEmpty()) {\n            this.deleteByIdsAsync(ids).toBlocking().last();\n        }\n    }\n\n    @Override\n    public void deleteByIds(String...ids) {\n        this.deleteByIds(new ArrayList<String>(Arrays.asList(ids)));\n    }\n\n    @Override\n    public PagedList<DataMigrationService> listByResourceGroup(String resourceGroupName) {\n        ServicesInner client = this.inner();\n        return this.wrapList(client.listByResourceGroup(resourceGroupName));\n    }\n\n    @Override\n    public Observable<DataMigrationService> listByResourceGroupAsync(String resourceGroupName) {\n        ServicesInner client = this.inner();\n        return client.listByResourceGroupAsync(resourceGroupName)\n        .flatMapIterable(new Func1<Page<DataMigrationServiceInner>, Iterable<DataMigrationServiceInner>>() {\n            @Override\n            public Iterable<DataMigrationServiceInner> call(Page<DataMigrationServiceInner> page) {\n                return page.items();\n            }\n        })\n        .map(new Func1<DataMigrationServiceInner, DataMigrationService>() {\n            @Override\n            public DataMigrationService call(DataMigrationServiceInner inner) {\n                return wrapModel(inner);\n            }\n        });\n    }\n\n    @Override\n    public PagedList<DataMigrationService> list() {\n        ServicesInner client = this.inner();\n        return this.wrapList(client.list());\n    }\n\n    @Override\n    public Observable<DataMigrationService> listAsync() {\n        ServicesInner client = this.inner();\n        return client.listAsync()\n        .flatMapIterable(new Func1<Page<DataMigrationServiceInner>, Iterable<DataMigrationServiceInner>>() {\n            @Override\n            public Iterable<DataMigrationServiceInner> call(Page<DataMigrationServiceInner> page) {\n                return page.items();\n            }\n        })\n        .map(new Func1<DataMigrationServiceInner, DataMigrationService>() {\n            @Override\n            public DataMigrationService call(DataMigrationServiceInner inner) {\n                return wrapModel(inner);\n            }\n        });\n    }\n\n    @Override\n    public DataMigrationServiceImpl define(String name) {\n        return wrapModel(name);\n    }\n\n    @Override\n    public Observable<DataMigrationServiceStatusResponse> checkStatusAsync(String groupName, String serviceName) {\n        ServicesInner client = this.inner();\n        return client.checkStatusAsync(groupName, serviceName)\n        .map(new Func1<DataMigrationServiceStatusResponseInner, DataMigrationServiceStatusResponse>() {\n            @Override\n            public DataMigrationServiceStatusResponse call(DataMigrationServiceStatusResponseInner inner) {\n                return new DataMigrationServiceStatusResponseImpl(inner, manager());\n            }\n        });\n    }\n\n    @Override\n    public Completable startAsync(String groupName, String serviceName) {\n        ServicesInner client = this.inner();\n        return client.startAsync(groupName, serviceName).toCompletable();\n    }\n\n    @Override\n    public Completable stopAsync(String groupName, String serviceName) {\n        ServicesInner client = this.inner();\n        return client.stopAsync(groupName, serviceName).toCompletable();\n    }\n\n    @Override\n    public Observable<NameAvailabilityResponse> checkChildrenNameAvailabilityAsync(String groupName, String serviceName, NameAvailabilityRequest parameters) {\n        ServicesInner client = this.inner();\n        return client.checkChildrenNameAvailabilityAsync(groupName, serviceName, parameters)\n        .map(new Func1<NameAvailabilityResponseInner, NameAvailabilityResponse>() {\n            @Override\n            public NameAvailabilityResponse call(NameAvailabilityResponseInner inner) {\n                return new NameAvailabilityResponseImpl(inner, manager());\n            }\n        });\n    }\n\n    @Override\n    protected DataMigrationServiceImpl wrapModel(DataMigrationServiceInner inner) {\n        return  new DataMigrationServiceImpl(inner.name(), inner, manager());\n    }\n\n    @Override\n    protected DataMigrationServiceImpl wrapModel(String name) {\n        return new DataMigrationServiceImpl(name, new DataMigrationServiceInner(), this.manager());\n    }\n\n    private AvailableServiceSkuImpl wrapAvailableServiceSkuModel(AvailableServiceSkuInner inner) {\n        return  new AvailableServiceSkuImpl(inner, manager());\n    }\n\n    @Override\n    public Observable<AvailableServiceSku> listSkusAsync(final String groupName, final String serviceName) {\n        ServicesInner client = this.inner();\n        return client.listSkusAsync(groupName, serviceName)\n        .flatMapIterable(new Func1<Page<AvailableServiceSkuInner>, Iterable<AvailableServiceSkuInner>>() {\n            @Override\n            public Iterable<AvailableServiceSkuInner> call(Page<AvailableServiceSkuInner> page) {\n                return page.items();\n            }\n        })\n        .map(new Func1<AvailableServiceSkuInner, AvailableServiceSku>() {\n            @Override\n            public AvailableServiceSku call(AvailableServiceSkuInner inner) {\n                return wrapAvailableServiceSkuModel(inner);\n            }\n        });\n    }\n\n    @Override\n    public Observable<NameAvailabilityResponse> checkNameAvailabilityAsync(String location, NameAvailabilityRequest parameters) {\n        ServicesInner client = this.inner();\n        return client.checkNameAvailabilityAsync(location, parameters)\n        .map(new Func1<NameAvailabilityResponseInner, NameAvailabilityResponse>() {\n            @Override\n            public NameAvailabilityResponse call(NameAvailabilityResponseInner inner) {\n                return new NameAvailabilityResponseImpl(inner, manager());\n            }\n        });\n    }\n\n}\n", "ava.util.regex.*;\r\n\r\npublic class Solution {\r\n    public static void main(String[] args) {\r\n        Scanner in = new Scanner(System.in);\r\n        Matcher matcher = Pattern.compile(\r\n            \"[a-z]{0,3}[0-9]{2,8}[A-Z]{3,}\"\r\n        ).matcher(\"\");\r\n        for (int N = Integer.parseInt(in.nextLine()); N > 0; --N) {\r\n            String id = in.nextLine();\r\n            matcher.reset(id);\r\n            System.out.println(matcher.matches() ? \"VALID\" : \"INVALID\");\r\n        }\r\n    }\r\n}", "ion;\n\npublic class RuleFactoryException extends FatalSpineFMException {\n\n\tpublic RuleFactoryException(String msg) {\n\t\tsuper(msg);\n\t}\n}\n", "licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\npackage com.facebook.react.uimanager;\n\nimport android.support.v4.util.Pools;\n\nimport com.facebook.react.bridge.Arguments;\nimport com.facebook.react.bridge.WritableMap;\nimport com.facebook.react.common.SystemClock;\nimport com.facebook.react.uimanager.events.Event;\nimport com.facebook.react.uimanager.events.RCTEventEmitter;\n\n/**\n * Event used to notify JS component about changes of its position or dimensions\n */\npublic class OnLayoutEvent extends Event<OnLayoutEvent> {\n\n  private static final Pools.SynchronizedPool<OnLayoutEvent> EVENTS_POOL =\n      new Pools.SynchronizedPool<>(20);\n\n  private int mX, mY, mWidth, mHeight;\n\n  public static OnLayoutEvent obtain(int viewTag, int x, int y, int width, int height) {\n    OnLayoutEvent event = EVENTS_POOL.acquire();\n    if (event == null) {\n      event = new OnLayoutEvent();\n    }\n    event.init(viewTag, x, y, width, height);\n    return event;\n  }\n\n  @Override\n  public void onDispose() {\n    EVENTS_POOL.release(this);\n  }\n\n  private OnLayoutEvent() {\n  }\n\n  protected void init(int viewTag, int x, int y, int width, int height) {\n    super.init(viewTag, SystemClock.nanoTime());\n    mX = x;\n    mY = y;\n    mWidth = width;\n    mHeight = height;\n  }\n\n  @Override\n  public String getEventName() {\n    return \"topLayout\";\n  }\n\n  @Override\n  public void dispatch(RCTEventEmitter rctEventEmitter) {\n    WritableMap layout = Arguments.createMap();\n    layout.putDouble(\"x\", PixelUtil.toDIPFromPixel(mX));\n    layout.putDouble(\"y\", PixelUtil.toDIPFromPixel(mY));\n    layout.putDouble(\"width\", PixelUtil.toDIPFromPixel(mWidth));\n    layout.putDouble(\"height\", PixelUtil.toDIPFromPixel(mHeight));\n\n    WritableMap event = Arguments.createMap();\n    event.putMap(\"layout\", layout);\n    event.putInt(\"target\", getViewTag());\n\n    rctEventEmitter.receiveEvent(getViewTag(), getEventName(), event);\n  }\n}\n", "ava.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.stream.IntStream;\n\nimport com.google.common.base.Joiner;\nimport com.google.common.base.Strings;\n\npublic class AsciiArtTable {\n\n  private AsciiArtRow header = null;\n  private List<AsciiArtRow> rows = new ArrayList<>();\n  private Map<Integer, Integer> columnsLength = new HashMap<>();\n\n  public AsciiArtTable(String... headers) {\n    header = new AsciiArtRow();\n    Arrays.asList(headers).stream().forEach(h -> {\n      header.addCell(h);\n    });\n  }\n\n  public void addRow(AsciiArtRow row) {\n    rows.add(row);\n    IntStream.range(0, row.getCells().size()).forEach(i -> {\n      Integer currentCellLength = row.getCells().get(i).length();\n      if (columnsLength.get(i) == null || columnsLength.get(i) < currentCellLength) {\n        columnsLength.put(i, currentCellLength);\n      }\n    });\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    String newLine = System.getProperty(\"line.separator\");\n    // Header\n    sb.append(\"| \").append(Joiner.on(\" | \").join(getCellsWithPadding(header))).append(\" |\");\n    Integer lineLength = sb.length();\n    sb.append(newLine).append(Strings.repeat(\"-\", lineLength)).append(newLine);\n    // Row\n    rows.stream().forEach(r -> {\n      sb.append(\"| \").append(Joiner.on(\" | \").join(getCellsWithPadding(r))).append(\" |\");\n      sb.append(newLine);\n    });\n    return sb.toString();\n  }\n\n  private List<String> getCellsWithPadding(AsciiArtRow r) {\n    List<String> padded = new ArrayList<>();\n    IntStream.range(0, r.getCells().size()).forEach(i -> {\n      padded.add(String.format(\"%-\" + (columnsLength.get(i) + 2) + \"s\", r.getCells().get(i)));\n    });\n    return padded;\n  }\n\n}\n", "d51e982e6e7b340b73e88efe666e.VisualElementRenderer_1\n\timplements\n\t\tmono.android.IGCUserPeer,\n\t\tandroid.view.View.OnFocusChangeListener\n{\n\tstatic final String __md_methods;\n\tstatic {\n\t\t__md_methods = \n\t\t\t\"n_onLayout:(ZIIII)V:GetOnLayout_ZIIIIHandler\\n\" +\n\t\t\t\"n_onFocusChange:(Landroid/view/View;Z)V:GetOnFocusChange_Landroid_view_View_ZHandler:Android.Views.View/IOnFocusChangeListenerInvoker, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\\n\" +\n\t\t\t\"\";\n\t\tmono.android.Runtime.register (\"Xamarin.Forms.Platform.Android.ViewRenderer`2, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", ViewRenderer_2.class, __md_methods);\n\t}\n\n\n\tpublic ViewRenderer_2 (android.content.Context p0, android.util.AttributeSet p1, int p2) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1, p2);\n\t\tif (getClass () == ViewRenderer_2.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.ViewRenderer`2, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:System.Int32, mscorlib, Version=2.0.5.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e\", this, new java.lang.Object[] { p0, p1, p2 });\n\t}\n\n\n\tpublic ViewRenderer_2 (android.content.Context p0, android.util.AttributeSet p1) throws java.lang.Throwable\n\t{\n\t\tsuper (p0, p1);\n\t\tif (getClass () == ViewRenderer_2.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.ViewRenderer`2, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065:Android.Util.IAttributeSet, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0, p1 });\n\t}\n\n\n\tpublic ViewRenderer_2 (android.content.Context p0) throws java.lang.Throwable\n\t{\n\t\tsuper (p0);\n\t\tif (getClass () == ViewRenderer_2.class)\n\t\t\tmono.android.TypeManager.Activate (\"Xamarin.Forms.Platform.Android.ViewRenderer`2, Xamarin.Forms.Platform.Android, Version=1.4.0.0, Culture=neutral, PublicKeyToken=null\", \"Android.Content.Context, Mono.Android, Version=0.0.0.0, Culture=neutral, PublicKeyToken=84e04ff9cfb79065\", this, new java.lang.Object[] { p0 });\n\t}\n\n\n\tpublic void onLayout (boolean p0, int p1, int p2, int p3, int p4)\n\t{\n\t\tn_onLayout (p0, p1, p2, p3, p4);\n\t}\n\n\tprivate native void n_onLayout (boolean p0, int p1, int p2, int p3, int p4);\n\n\n\tpublic void onFocusChange (android.view.View p0, boolean p1)\n\t{\n\t\tn_onFocusChange (p0, p1);\n\t}\n\n\tprivate native void n_onFocusChange (android.view.View p0, boolean p1);\n\n\tjava.util.ArrayList refList;\n\tpublic void monodroidAddReference (java.lang.Object obj)\n\t{\n\t\tif (refList == null)\n\t\t\trefList = new java.util.ArrayList ();\n\t\trefList.add (obj);\n\t}\n\n\tpublic void monodroidClearReferences ()\n\t{\n\t\tif (refList != null)\n\t\t\trefList.clear ();\n\t}\n}\n", "n;\n\nimport lombok.AllArgsConstructor;\nimport lombok.Builder;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\nimport pl.java.scalatech.domain.common.AbstractEntity;\n\n//@Entity\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\n@Builder\npublic class Offer extends AbstractEntity{\n\n    private static final long serialVersionUID = 4367131894333818343L;\n    @Column(name=\"offer_value\")\n    private BigDecimal value;\n\n\n\n}", "ation.Autowired;\r\n\r\nimport com.training.jpa.domain.AccountInfo;\r\nimport com.training.jpa.domain.UserInfo;\r\nimport com.training.jpa.service.UserService;\r\n\r\npublic class JPATest extends BaseTest {\r\n\t\r\n\t@Autowired\r\n\tprivate UserService userService;\r\n\t\r\n\t@Test\r\n\tpublic void getAccountInfo(){\r\n\t\tAccountInfo account = userService.findAccountInfoById(1L);\r\n\t\tSystem.out.println(\"Account \u4f59\u989d: \" + account.getBalance());\r\n\t\tUserInfo user = account.getUserInfo();\r\n\t\tSystem.out.println(\"\u8d26\u6237\u6240\u6709\u4eba: \" + user.getUsername());\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void createAccountInfo(){\r\n\t\tuserService.createNewAccount(\"sam\", \"password\", 999999999);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void updateAccountInfo(){\r\n\t\tUserInfo user = new UserInfo();\r\n\t\tuser.setPassword(\"password\");\r\n\t\tuser.setUsername(\"david\");\r\n\t\tuserService.updateAccountInfo(1L, user);\r\n\t}\r\n\t\r\n\t@Test\r\n\tpublic void deleteAccountInfo(){\r\n\t\tuserService.deleteAccountInfo(1L);\r\n\t}\r\n\r\n}\r\n", "\r\nimport models.DriverModel;\r\n\r\nimport utilities.Position;\r\nimport utilities.Vector;\r\nimport views.DriverView;\r\n\r\n/**\r\n * creates a projectile that hits all surrounding mobs \r\n * stopping them in place\r\n * \r\n * @author Scorpion\r\n *\r\n */\r\n\r\npublic class DeepFreeze extends Projectile {\r\n\r\n\tprivate static String PROJECTILE_IMAGE = \"Ring of Ice.png\";\r\n\tpublic final static int PROJECTILE_WIDTH = 50;\r\n\tpublic final static int PROJECTILE_HEIGHT = 50;\r\n\tpublic final static String FIRE_IMAGE = null;\r\n\tpublic final static int FIRE_WIDTH = 0;\r\n\tpublic final static int FIRE_HEIGHT = 0;\r\n\tpublic final static String IMPACT_IMAGE = null;\r\n\tpublic final static int IMPACT_WIDTH = 0;\r\n\tpublic final static int IMPACT_HEIGHT = 0;\r\n\tpublic final static int PROJECTILE_SPEED = 25;\r\n\tpublic final static int PROJECTILE_RADIUS = 75;\r\n\tpublic final static int PROJECTILE_DAMAGE = 100;\r\n\tpublic final static int DAMAGE_DURATION = 1;\r\n\tpublic final static int SLOW_POTENTCY = 1;\r\n\tpublic final static int SLOW_DURATION = 5;\r\n\tpublic final static int PROJECTILE_HITS = -1;\r\n\tpublic final static int PROJECTILE_MOVEMENTS = 3;\r\n\t\r\n\tpublic Position startingPosition;\r\n\tpublic int width = PROJECTILE_WIDTH;\r\n\tpublic int height = PROJECTILE_HEIGHT;\r\n\t\r\n\t/**\r\n\t * constructor for DeepFreeze\r\n\t * \r\n\t * @param model\r\n\t * @param startingPosition\r\n\t * @param vector\r\n\t * @param rangeBoostLevel\r\n\t * @param durationBoostLevel\r\n\t */\r\n\t\r\n\tpublic DeepFreeze(final DriverModel model, final Position startingPosition, \r\n\t\t\tfinal Vector vector, final int rangeBoostLevel, final int durationBoostLevel) {\r\n\t\tsuper(model, startingPosition, PROJECTILE_IMAGE, vector, PROJECTILE_WIDTH, PROJECTILE_HEIGHT);\r\n\t\tthis.speed = PROJECTILE_SPEED;\r\n\t\tthis.radius = PROJECTILE_RADIUS + (25 * rangeBoostLevel);\r\n\t\tthis.damage = 0;\r\n\t\tthis.damageDuration = DAMAGE_DURATION;\r\n\t\tthis.slowPotency = SLOW_POTENTCY;\r\n\t\tthis.slowDuration = SLOW_DURATION + (5 * durationBoostLevel);\r\n\t\tthis.startingPosition = startingPosition;\r\n\t\tthis.movements = 0;\r\n\t\tthis.maxMovements = PROJECTILE_MOVEMENTS + rangeBoostLevel;\r\n\t\tthis.stillAlive = true;\r\n\t\tthis.drawRounds = new ArrayList<Position>();\r\n\t\tthis.drawRounds.add(this.position);\r\n\t}\r\n\t\r\n\t/**\r\n\t * returns how long the projectile lasts for\r\n\t * \r\n\t * @param level\r\n\t * @return\r\n\t */\r\n\t\r\n\tpublic static int getDurationLevelBoost(final int level) {\r\n\t\treturn SLOW_DURATION + (5 * level);\r\n\t}\r\n\t\r\n\t/**\r\n\t * adds the image(s) of any projectile\r\n\t * that needs to be drawn to the map\r\n\t * \r\n\t * @param imageGraphics\r\n\t */\r\n\t\r\n\tpublic void addImages(final Graphics imageGraphics) {\r\n\t\tfor (Position position : this.drawRounds) {\r\n\t\t\timageGraphics.drawImage(this.projectileImage, (int) position.getXCord(), \r\n\t\t\t\t\t(int) position.getYCord(), null);\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * checks to see if the projectile is\r\n\t * still alive\r\n\t */\r\n\t\r\n\tpublic void setAlive() {\r\n\t\tint increase = 0;\r\n\t\tif (rangeBoost == true) {\r\n\t\t\tincrease = 1;\r\n\t\t}\r\n\t\t\r\n\t\tif (this.movements >= this.maxMovements + increase) {\r\n\t\t\tthis.stillAlive = false;\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * moves the projectile and checks whether its\r\n\t * impacted a mob\r\n\t */\r\n\t\r\n\tpublic void updateProjectile() {\r\n\t\tthis.setAlive();\r\n\t\tthis.width += PROJECTILE_SPEED;\r\n\t\tthis.height += PROJECTILE_SPEED;\r\n\t\tthis.projectileImage = DriverView.getImage(PROJECTILE_IMAGE, width, height);\r\n\t\tthis.position = new Position(this.startingPosition.getXCord() - (width/2), this.startingPosition.getYCord() - (height/2));\r\n\t\tthis.drawRounds.clear();\r\n\t\tthis.drawRounds.add(this.position);\r\n\t\tthis.movements++;\r\n\t\tif (this.movements > 0) {\r\n\t\t\tthis.firePosition = null;\r\n\t\t\tthis.impactPosition = null;\r\n\t\t\tthis.endPosition = null;\r\n\t\t}\r\n\t\t\r\n\t\tif (this.movements == 2) {\r\n\t\t\tfor (Mob mob : this.model.allMobs()) \r\n\t\t\t{\r\n\t\t\t\tif (mob.getPosition().getDistance(this.startingPosition) < (mob.getRadius() + this.radius) && mob.isVisible()) {\r\n\t\t\t\t\tmob.mobHitBy(this);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * returns true if the projectile\r\n\t * is ice\r\n\t * \r\n\t * @return boolean\r\n\t */\r\n\t\r\n\tpublic boolean isIce() {\r\n\t\treturn true;\r\n\t}\r\n}\r\n", "private String command;\n\n\t/**\n\t * MML command parameters.\n\t */\n\tprivate String[] params;\n\n\t/**\n\t * Construct a new MML event.\n\t */\n\tpublic MMLEvent()\n\t{\n\t\tthis(null, null);\n\t}\n\n\t/**\n\t * Construct a new MML event.\n\t * @param command MML command text.\n\t */\n\tpublic MMLEvent(String command) {\n\t\tthis(command, null);\n\t}\n\n\t/**\n\t * Construct a new MML event.\n\t * @param command MML command text.\n\t * @param params MML command parameters.\n\t */\n\tpublic MMLEvent(String command, String[] params) {\n\t\tthis.command = command;\n\t\tthis.params = params;\n\t}\n\n\t/**\n\t * Get command text.\n\t * @return MML command text without parameters.\n\t */\n\tpublic String getCommand() {\n\t\treturn command;\n\t}\n\n\t/**\n\t * Set command text.\n\t * @param command MML commend text.\n\t */\n\tpublic void setCommand(String command) {\n\t\tthis.command = command;\n\t}\n\n\t/**\n\t * Get MML command parameter texts.\n\t * @return Array of MML command parameters.\n\t */\n\tpublic String[] getParams() {\n\t\treturn params;\n\t}\n\n\t/**\n\t * Set MML command parameter texts.\n\t * @param params Array of MML command parameters.\n\t */\n\tpublic void setParams(String[] params) {\n\t\tthis.params = params;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tStringBuffer buf = new StringBuffer();\n\t\tif (command != null) {\n\t\t\tbuf.append(command);\n\t\t}\n\t\tif (params != null) {\n\t\t\tfor (int i = 0; i < params.length; i++) {\n\t\t\t\tif (i != 0)\n\t\t\t\t\tbuf.append(\",\");\n\t\t\t\tbuf.append(params[i]);\n\t\t\t}\n\t\t}\n\t\treturn buf.toString();\n\t}\n}\n", "roid.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ImageView;\nimport android.widget.TextView;\n\nimport com.squareup.picasso.Picasso;\n\nimport net.gouline.dagger2demo.R;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by clkim on 9/22/15\n */\npublic class AlbumViewAdapter extends RecyclerView.Adapter<AlbumViewAdapter.ViewHolder> {\n\n    class ViewHolder extends RecyclerView.ViewHolder{\n\n        public ImageView imgThumbnail;\n        public TextView textView;\n\n        public ViewHolder(View itemView) {\n            super(itemView);\n            imgThumbnail = (ImageView)itemView.findViewById(R.id.thumbnail);\n            textView = (TextView)itemView.findViewById(R.id.title);\n        }\n    }\n\n    private List<AlbumItem> albumItems;\n\n    public AlbumViewAdapter() {\n        super();\n        albumItems = new ArrayList<>();\n    }\n\n    public void clear() {\n        albumItems.clear();\n    }\n\n    public void addAlbumItem(AlbumItem item) {\n        albumItems.add(item);\n    }\n\n    @Override\n    public AlbumViewAdapter.ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n        View v = LayoutInflater.from(parent.getContext())\n                .inflate(R.layout.list_row, parent, false);\n        return new ViewHolder(v);\n    }\n\n    @Override\n    public void onBindViewHolder(AlbumViewAdapter.ViewHolder holder, int position) {\n        AlbumItem albumItem = albumItems.get(position);\n        holder.textView.setText(albumItem.getName());\n        Picasso.with(holder.imgThumbnail.getContext())\n                .load(albumItem.getUrl())\n                .placeholder(R.drawable.placeholder)\n                .error(R.drawable.placeholder)\n                .into(holder.imgThumbnail);\n    }\n\n    @Override\n    public int getItemCount() {\n        return albumItems.size();\n    }\n}\n", "ting.controllers;\n\nimport play.mvc.Controller;\nimport play.mvc.Result;\n\npublic class Application extends Controller {\n\n    public Result download(String path) {\n        return ok(\"download \" + path);\n    }\n\n    public Result homePage() {\n        return ok(\"home page\");\n    }\n\n    //#show-page-action\n    public Result show(String page) {\n        String content = Page.getContentOf(page);\n        response().setContentType(\"text/html\");\n        return ok(content);\n    }\n    //#show-page-action\n\n    static class Page {\n        static String getContentOf(String page) {\n            return \"showing page \" + page;\n        }\n    }\n\n    //#reverse-redirect\n    // Redirect to /hello/Bob\n    public Result index() {\n        return redirect(controllers.routes.Application.hello(\"Bob\"));\n    }\n    //#reverse-redirect\n\n    static class controllers {\n        static javaguide.http.routing.reverse.controllers.routes routes = new javaguide.http.routing.reverse.controllers.routes();\n    }\n}\n", "kage com.azure.security.keyvault.keys.models;\n\nimport com.azure.core.annotation.Fluent;\n\nimport java.time.OffsetDateTime;\nimport java.util.Arrays;\nimport java.util.Map;\n\n/**\n * Represents the configurable options to create an Rsa key.\n */\n@Fluent\npublic class CreateRsaKeyOptions extends CreateKeyOptions {\n\n    /**\n     * The Rsa key size.\n     */\n    private Integer keySize;\n\n    /**\n     * The hardware protected indicator for the key.\n     */\n    private boolean hardwareProtected;\n\n    /**\n     * Creates a RsaKeyCreateOptions with {@code name} as name of the Rsa key.\n     * @param name The name of the key.\n     */\n    public CreateRsaKeyOptions(String name) {\n        super.name = name;\n        this.keyType = KeyType.RSA;\n    }\n\n    /**\n     * Get the keySize value.\n     *\n     * @return the keySize value\n     */\n    public Integer getKeySize() {\n        return this.keySize;\n    }\n\n    /**\n     * Set the keySize value.\n     *\n     * @param keySize The keySize value to set\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    public CreateRsaKeyOptions setKeySize(Integer keySize) {\n        this.keySize = keySize;\n        return this;\n    }\n\n    /**\n     * Set the key operations value.\n     *\n     * @param keyOperations The key operations value to set\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    @Override\n    public CreateRsaKeyOptions setKeyOperations(KeyOperation... keyOperations) {\n        this.keyOperations = Arrays.asList(keyOperations);\n        return this;\n    }\n\n    /**\n     * Set the {@link OffsetDateTime notBefore} UTC time.\n     *\n     * @param notBefore The notBefore UTC time to set\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    @Override\n    public CreateRsaKeyOptions setNotBefore(OffsetDateTime notBefore) {\n        super.setNotBefore(notBefore);\n        return this;\n    }\n\n    /**\n     * Set the {@link OffsetDateTime expires} UTC time.\n     *\n     * @param expiresOn The expiry time to set for the key.\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    @Override\n    public CreateRsaKeyOptions setExpiresOn(OffsetDateTime expiresOn) {\n        super.setExpiresOn(expiresOn);\n        return this;\n    }\n\n    /**\n     * Set the tags to be associated with the key.\n     *\n     * @param tags The tags to set\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    @Override\n    public CreateRsaKeyOptions setTags(Map<String, String> tags) {\n        super.setTags(tags);\n        return this;\n    }\n\n    /**\n     * Set the enabled value.\n     *\n     * @param enabled The enabled value to set\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    public CreateRsaKeyOptions setEnabled(Boolean enabled) {\n        super.setEnabled(enabled);\n        return this;\n    }\n\n    /**\n     * Set whether the key being created is of hsm type or not.\n     * @param hardwareProtected The hsm value to set.\n     * @return the RsaKeyCreateOptions object itself.\n     */\n    public CreateRsaKeyOptions setHardwareProtected(Boolean hardwareProtected) {\n        this.hardwareProtected = hardwareProtected;\n        this.keyType = hardwareProtected ? KeyType.RSA_HSM : KeyType.RSA;\n        return this;\n    }\n\n    /**\n     * Get the hsm value of the key being created.\n     * @return the hsm value.\n     */\n    public Boolean isHardwareProtected() {\n        return this.hardwareProtected;\n    }\n}\n", "sco.miab.init.MemeLoot;\nimport com.mrbysco.miab.init.MemeSounds;\nimport net.minecraft.entity.SharedMonsterAttributes;\nimport net.minecraft.entity.ai.EntityAIAttackMelee;\nimport net.minecraft.entity.ai.EntityAIHurtByTarget;\nimport net.minecraft.entity.ai.EntityAILookIdle;\nimport net.minecraft.entity.ai.EntityAISwimming;\nimport net.minecraft.entity.ai.EntityAIWander;\nimport net.minecraft.entity.ai.EntityAIWatchClosest;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.util.DamageSource;\nimport net.minecraft.util.ResourceLocation;\nimport net.minecraft.util.SoundEvent;\nimport net.minecraft.world.World;\n\npublic class EntityPPAP extends AbstractMeme{\n\n\tpublic EntityPPAP(World worldIn) {\n\t\tsuper(worldIn);\n\t}\n\n\tprotected void initEntityAI()\n\t{\n\t\tthis.tasks.addTask(1, new EntityAISwimming(this));\n\t\tthis.tasks.addTask(4, new EntityAIAttackMelee(this, 1.0D, false));\n\t\tthis.tasks.addTask(5, new EntityAIWander(this, 0.8D));\n\t\tthis.tasks.addTask(6, new EntityAIWatchClosest(this, EntityPlayer.class, 8.0F));\n\t\tthis.tasks.addTask(6, new EntityAILookIdle(this));\n\t\tthis.applyEntityAI();\n\t}\n\n\tprivate void applyEntityAI() {\n\t\tthis.targetTasks.addTask(2, new EntityAIHurtByTarget(this, false, new Class[0]));\n\t}\n\t\n\t@Override\n\tprotected void applyEntityAttributes() \n\t{\n\t\tsuper.applyEntityAttributes();\n\t\t\n\t\tgetEntityAttribute(SharedMonsterAttributes.MAX_HEALTH).setBaseValue(22.0D);\n\t\tgetEntityAttribute(SharedMonsterAttributes.MOVEMENT_SPEED).setBaseValue(0.23D);\n\t\tgetEntityAttribute(SharedMonsterAttributes.KNOCKBACK_RESISTANCE).setBaseValue(0.4D);\n\t\tgetEntityAttribute(SharedMonsterAttributes.FOLLOW_RANGE).setBaseValue(30.0D);\n\t\tgetEntityAttribute(SharedMonsterAttributes.ATTACK_DAMAGE).setBaseValue(3.0D);\n\t}\n\t\n\t@Override\n    protected SoundEvent getAmbientSound()\n    {\n        return MemeSounds.ppap_sound;\n    }\n\t\n\t@Override\n    protected SoundEvent getHurtSound(DamageSource source)\n    {\n        return MemeSounds.ppap_sound;\n    }\n\t\n\t@Override\n    protected SoundEvent getDeathSound()\n    {\n        return MemeSounds.ppap_death;\n    }\n\t\n\t@Override\n\tpublic boolean canPickupItems() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tprotected ResourceLocation getLootTable()\n\t{\n\t\treturn MemeLoot.PPAP_LOOT;\n\t}\n}\n", "alent.npclib.NPCLib;\nimport org.inventivetalent.npclib.ObjectContainer;\nimport org.inventivetalent.npclib.Reflection;\nimport org.inventivetalent.npclib.SuperSwitch;\nimport org.inventivetalent.reflection.resolver.wrapper.MethodWrapper;\n\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic class AnnotatedMethodWatcher extends MethodWatcher {\n\n\tObject toWatch;\n\tMap<MethodWrapper.MethodSignature, WatchedMethod> watchedMethods = new ConcurrentHashMap<>();\n\n\tpublic AnnotatedMethodWatcher(Object toWatch) {\n\t\tthis(toWatch, true);\n\t}\n\n\tpublic AnnotatedMethodWatcher(Object toWatch, boolean searchSuper) {\n\t\tthis.toWatch = toWatch;\n\t\tif (searchSuper) {\n\t\t\tClass<?> superClazz = toWatch.getClass();\n\t\t\twhile (superClazz != null) {\n\t\t\t\tregister(superClazz);\n\t\t\t\tsuperClazz = superClazz.getSuperclass();\n\t\t\t}\n\t\t} else {\n\t\t\tregister(toWatch.getClass());\n\t\t}\n\t}\n\n\tvoid register(Class<?> clazz) {\n\t\tfor (Method method : clazz.getMethods()) {\n\t\t\tWatch annotation = method.getAnnotation(Watch.class);\n\t\t\tif (annotation != null) {\n\t\t\t\tString[] signatures = annotation.value();\n\t\t\t\tif (signatures.length == 0) {signatures = new String[] { Reflection.getMethodSignature(method) }; }\n\t\t\t\tboolean passThrough = true;\n\t\t\t\tif (method.getReturnType().equals(Void.TYPE)) { passThrough = annotation.passThrough(); }\n\t\t\t\tboolean containers = annotation.containers();\n\t\t\t\t//\t\t\t\tboolean ignoreThiz = annotation.ignoreThiz();\n\n\t\t\t\tfor (String signature : signatures) {\n\t\t\t\t\tMethodWrapper.MethodSignature methodSignature = MethodWrapper.MethodSignature.fromString(signature);\n\t\t\t\t\tif (!watchedMethods.containsKey(methodSignature)) {\n\t\t\t\t\t\tNPCLib.debug(\"@Watching method\", methodSignature.getSignature(), \"in\", clazz.getName());\n\t\t\t\t\t\tboolean hasSwitch = false;\n\t\t\t\t\t\tif (method.getParameterTypes().length >= 1) {\n\t\t\t\t\t\t\tif (SuperSwitch.class.isAssignableFrom(method.getParameterTypes()[method.getParameterTypes().length - 1])) {\n\t\t\t\t\t\t\t\thasSwitch = true;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tboolean hasWildcards = signature.contains(\"*\") || signature.contains(\"?\");\n\t\t\t\t\t\twatchedMethods.put(methodSignature, new WatchedMethod(signature, passThrough, containers,/*ignoreThiz,*/method.getReturnType().equals(Void.TYPE), hasSwitch, hasWildcards, method));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t//\t@Override\n\t//\tpublic boolean methodCalled(Object thiz, String methodSignature, ObjectContainer[] containers) {\n\t//\t\tWatchedMethod watchedMethod = watchedMethods.get(methodSignature);\n\t//\t\tif (watchedMethod == null) {\n\t//\t\t\treturn super.methodCalled(thiz, methodSignature, containers);\n\t//\t\t}\n\t//\t\tObject[] args = watchedMethod.containers ? containers : ObjectContainer.toObjects(containers);\n\t//\t\ttry {\n\t//\t\t\tObject returned = watchedMethod.method.invoke(toWatch, args);\n\t//\t\t\tif (watchedMethod.isVoid) {\n\t//\t\t\t\treturn watchedMethod.passThrough;\n\t//\t\t\t}\n\t//\t\t\treturn (boolean) returned;\n\t//\t\t} catch (Exception e) {\n\t//\t\t\tthrow new RuntimeException(\"Failed to invoke @Watch method \" + methodSignature + \" with args: \" + Arrays.toString(args), e);\n\t//\t\t}\n\t//\t}\n\n\t@Override\n\tpublic Object methodCalled(Object thiz, String methodSignature, SuperSwitch superSwitch, ObjectContainer[] containers) {\n\t\tMethodWrapper.MethodSignature calledSignature = MethodWrapper.MethodSignature.fromString(methodSignature);\n\t\tWatchedMethod watchedMethod = null;\n\t\tfor (Map.Entry<MethodWrapper.MethodSignature, WatchedMethod> entry : this.watchedMethods.entrySet()) {\n\t\t\tif (entry.getKey().matches(calledSignature)) {\n\t\t\t\twatchedMethod = entry.getValue();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (watchedMethod == null) {\n\t\t\treturn super.methodCalled(thiz, methodSignature, superSwitch, containers);\n\t\t}\n\t\tObject[] args = watchedMethod.containers ? containers : ObjectContainer.toObjects(containers);\n\t\ttry {\n\t\t\tif (watchedMethod.hasSwitch) {\n\t\t\t\targs = Arrays.copyOf(args, args.length + 1, Object[].class);\n\t\t\t\targs[args.length - 1] = superSwitch;\n\t\t\t}\n\t\t\treturn watchedMethod.method.invoke(toWatch, args);\n\t\t} catch (Exception e) {\n\t\t\tthrow new RuntimeException(\"Failed to invoke @Watch method \" + methodSignature + \" in \" + toWatch.getClass() + \" with args: \" + Arrays.toString(args), e);\n\t\t}\n\t}\n\n\t@AllArgsConstructor\n\tclass WatchedMethod {\n\t\tString  signature;\n\t\tboolean passThrough;\n\t\tboolean containers;\n\t\t//\t\tboolean ignoreThiz;\n\t\tboolean isVoid;\n\t\tboolean hasSwitch;\n\t\tboolean hasWildcards;\n\t\tMethod  method;\n\t}\n\n}\n", "ientos extends Paquete implements Serializable, Cloneable {\n\n\tprivate Map<Integer, PaqueteMovimiento> personajes;\n\n\tpublic PaqueteDeMovimientos(){\n\n\t}\n\n\tpublic PaqueteDeMovimientos(Map<Integer, PaqueteMovimiento> personajes){\n\t\tthis.personajes = personajes;\n\t}\n\n\tpublic Map<Integer, PaqueteMovimiento> getPersonajes(){\n\t\treturn personajes;\n\t}\n\n\t@Override\n\tpublic Object clone() {\n\t\tObject obj = null;\n\t\tobj = super.clone();\n\t\treturn obj;\n\t}\n\n}", "csearch.common.Pagination;\n\npublic class QueryResults<T> {\n    private Pagination pagination;\n\n    private Float maxScore;\n\n    private List<QueryResult<T>> results;\n\n    private List<Long> partialTotalHits;\n\n    public Pagination getPagination() {\n        return this.pagination;\n    }\n\n    public void setPagination(Pagination pagination) {\n        this.pagination = pagination;\n    }\n\n    public Float getMaxScore() {\n        return this.maxScore;\n    }\n\n    public void setMaxScore(Float maxScore) {\n        this.maxScore = maxScore;\n    }\n\n    public List<QueryResult<T>> getResults() {\n        return this.results;\n    }\n\n    public void setResults(List<QueryResult<T>> results) {\n        this.results = results;\n    }\n\n    public List<Long> getPartialTotalHits() {\n        return this.partialTotalHits;\n    }\n\n    public void setPartialTotalHits(List<Long> partialTotalHits) {\n        this.partialTotalHits = partialTotalHits;\n    }\n}\n", "charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage hudson.model;\n\nimport java.io.File;\nimport java.io.IOException;\nimport jenkins.model.Jenkins;\nimport static org.junit.Assert.*;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.jvnet.hudson.test.Issue;\nimport org.jvnet.hudson.test.JenkinsRule;\nimport org.jvnet.hudson.test.TestExtension;\n\npublic class ViewJobTest {\n\n    @Rule public JenkinsRule rule = new JenkinsRule();\n\n    @Issue(\"JENKINS-19377\")\n    @Test public void removeRun() throws Exception {\n        J j = rule.jenkins.createProject(J.class, \"j\");\n        R r1 = j.nue();\n        R r2 = j.nue();\n        assertEquals(\"[2, 1]\", j.getBuildsAsMap().keySet().toString());\n        j.removeRun(r1);\n        assertEquals(\"[2]\", j.getBuildsAsMap().keySet().toString());\n    }\n\n    @SuppressWarnings({\"rawtypes\", \"unchecked\", \"deprecation\"})\n    public static final class J extends ViewJob<J,R> implements TopLevelItem {\n\n        public J(ItemGroup parent, String name) {\n            super(parent, name);\n        }\n\n        @Override protected void reload() {\n            runs.load(this, new RunMap.Constructor<R>() {\n                @Override public R create(File d) throws IOException {\n                    return new R(J.this, d);\n                }\n            });\n        }\n\n        @Override public TopLevelItemDescriptor getDescriptor() {\n            return Jenkins.get().getDescriptorByType(DescriptorImpl.class);\n        }\n\n        @TestExtension public static final class DescriptorImpl extends TopLevelItemDescriptor {\n\n            @Override public TopLevelItem newInstance(ItemGroup parent, String name) {\n                return new J(parent, name);\n            }\n\n        }\n\n        R nue() throws IOException {\n            R r = new R(this);\n            _getRuns();\n            runs.put(r);\n            return r;\n        }\n\n    }\n\n    public static final class R extends Run<J,R> {\n\n        public R(J j) throws IOException {\n            super(j);\n        }\n\n        public R(J j, File d) throws IOException {\n            super(j, d);\n        }\n\n    }\n\n}\n", "s getHits() {\n        return hits;\n    }\n\n    public void setHits(Hits hits) {\n        this.hits = hits;\n    }\n}\n", "Suite.class)\n@Suite.SuiteClasses(value = {\n        DataCollectionTest.class})\npublic class AllTests {\n}\n", "iew.java\r\n *\r\n * Author\t:\tBob Brady, rpbrady@gmail.com\r\n * \r\n * Contents\t:\tProvides a view of all TPEvents received by TPBuddy\r\n * \r\n ********************************************************************/\r\npackage edu.harvard.fas.rbrady.tpteam.tpbuddy.views;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Observable;\r\nimport java.util.Observer;\r\nimport org.eclipse.jface.viewers.ArrayContentProvider;\r\nimport org.eclipse.jface.viewers.TableViewer;\r\nimport org.eclipse.swt.SWT;\r\nimport org.eclipse.swt.widgets.Composite;\r\nimport org.eclipse.swt.widgets.Display;\r\nimport org.eclipse.swt.widgets.Table;\r\nimport org.eclipse.swt.widgets.TableColumn;\r\nimport org.eclipse.ui.part.ViewPart;\r\nimport edu.harvard.fas.rbrady.tpteam.tpbridge.model.TPEvent;\r\nimport edu.harvard.fas.rbrady.tpteam.tpbuddy.Activator;\r\nimport edu.harvard.fas.rbrady.tpteam.tpbuddy.eventadmin.EventAdminHandler;\r\nimport edu.harvard.fas.rbrady.tpteam.tpbuddy.tpbridge.TPBridgeClient;\r\n\r\n/*******************************************************************************\r\n * File \t\t: \tEventHistoryView.java\r\n * \r\n * Description \t: \tProvides a view of all TPEvents received by TPBuddy\r\n * \r\n * @author Bob Brady, rpbrady@gmail.com\r\n * @version $Revision$\r\n * @date $Date$ Copyright (c) 2007 Bob Brady\r\n ******************************************************************************/\r\npublic class EventHistoryView extends ViewPart implements Observer {\r\n\t/** The view ID */\r\n\tpublic static final String ID = \"edu.harvard.fas.rbrady.tpteam.tpbuddy.eventhistview\";\r\n\t/** The encapsulated SWT Table used */\r\n\tprivate Table mTable;\r\n\t/** The TableViewer that renders the TPEvents */\r\n\tprivate TableViewer mTableViewer;\r\n\t/** Helper class for updating view */\r\n\tprivate TableUpdater mTableUpdater;\r\n\t/** Reference to the TPBuddy TPBridge client */\r\n\tprivate TPBridgeClient mTPBridgeClient;\r\n\r\n\t/**\r\n\t * Constructor\r\n\t * \r\n\t * Adds this view as an observer to the\r\n\t * TPBuddy EventAdminHandler and gets a handle to\r\n\t * the TPBuddy TPBridge client\r\n\t */\r\n\tpublic EventHistoryView() {\r\n\t\tmTPBridgeClient = Activator.getDefault().getTPBridgeClient();\r\n\t\tActivator.getDefault().getEventAdminHandler().addObserver(this);\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void createPartControl(Composite parent) {\r\n\t\tinitTableViewer(parent);\r\n\t\tmTableUpdater = new TableUpdater(mTableViewer);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes the TableViewer\r\n\t * @param parent the Composite parent of the view\r\n\t */\r\n\tprivate void initTableViewer(Composite parent) {\r\n\t\tmTableViewer = new TableViewer(parent, SWT.SINGLE | SWT.FULL_SELECTION);\r\n\t\tinitTable();\r\n\t\tinitColumns();\r\n\t\tmTableViewer.setLabelProvider(new TPEventLabelProvider());\r\n\t\tmTableViewer.setContentProvider(new ArrayContentProvider());\r\n\t\tmTableViewer.setInput(getTPBridgeEvents());\r\n\t}\r\n\r\n\tprivate void initTable() {\r\n\t\tmTable = mTableViewer.getTable();\r\n\t\tmTable.setHeaderVisible(true);\r\n\t\tmTable.setLinesVisible(true);\r\n\t}\r\n\r\n\t/**\r\n\t * Initializes column display properties\r\n\t */\r\n\tprivate void initColumns() {\r\n\t\tString[] columnNames = new String[] { \"From\", \"To\", \"Topic\", \"Project\", \"Test\", \"ID\", \"Status\" };\r\n\t\tint[] columnWidths = new int[] { 150, 150, 150, 150, 150, 150, 150 };\r\n\t\tint[] columnAlignments = new int[] { SWT.LEFT, SWT.LEFT, SWT.LEFT, SWT.LEFT,\r\n\t\t\t\tSWT.LEFT, SWT.LEFT, SWT.LEFT };\r\n\t\tfor (int i = 0; i < columnNames.length; i++) {\r\n\t\t\tTableColumn tableColumn = new TableColumn(mTable,\r\n\t\t\t\t\tcolumnAlignments[i]);\r\n\t\t\ttableColumn.setText(columnNames[i]);\r\n\t\t\ttableColumn.setWidth(columnWidths[i]);\r\n\t\t}\r\n\r\n\t}\r\n\r\n\t@Override\r\n\tpublic void setFocus() {\r\n\t}\r\n\r\n\t/**\r\n\t * Helper class\r\n\t * \r\n\t * Adds TPEvents to the view's table as they \r\n\t * are received in real time.\r\n\t *\r\n\t */\r\n\tprivate static class TableUpdater implements Runnable {\r\n\r\n\t\tprivate Object mTableViewerObject = null;\r\n\r\n\t\tprivate TableViewer mTableViewer;\r\n\r\n\t\tpublic TableUpdater(TableViewer tableViewer) {\r\n\t\t\tmTableViewer = tableViewer;\r\n\t\t}\r\n\r\n\t\tpublic void insertObject(Object objectToInsert) {\r\n\t\t\tmTableViewerObject = objectToInsert;\r\n\t\t\tDisplay.getDefault().syncExec(this);\r\n\t\t}\r\n\r\n\t\tpublic void run() {\r\n\t\t\tmTableViewer.add(mTableViewerObject);\r\n\t\t}\r\n\t}\r\n\r\n\tprivate ArrayList<TPEvent> getTPBridgeEvents() {\r\n\t\treturn mTPBridgeClient.getEventLog();\r\n\t}\r\n\r\n\tpublic void dispose() {\r\n\t\tsuper.dispose();\r\n\t\tActivator.getDefault().getEventAdminHandler().deleteObserver(this);\r\n\t}\r\n\r\n\t/**\r\n\t * Update called when TPBuddy EventAdminHandler receives \r\n\t * a TPTeam event.  All received TPEvents will be added\r\n\t * to the view's table\r\n\t * \r\n\t * @param observable the object that called the update\r\n\t * @param object the TPEvent to be handled\r\n\t */\r\n\tpublic void update(Observable observable, Object object) {\r\n\t\tif (observable instanceof EventAdminHandler && object instanceof TPEvent) {\r\n\t\t\tTPEvent tpEvent = (TPEvent) object;\r\n\t\t\tSystem.out.println(\"EventHistoryView: update called for \"\r\n\t\t\t\t\t+ tpEvent.getTopic() + \" Event for \"\r\n\t\t\t\t\t+ tpEvent.getTestName());\r\n\t\t\tmTableUpdater.insertObject(tpEvent);\r\n\t\t}\r\n\t}\r\n}\r\n", "der;\nimport com.google.common.cache.LoadingCache;\nimport rewriting.RewriteEngine;\nimport rewriting.RewriteMethod;\nimport rewriting.internal.InternalEngine;\nimport rewriting.maude.MaudeEngine;\nimport rewriting.terms.Term;\n\nimport java.util.concurrent.ExecutionException;\n\n/**\n * SPAN - Stochastic Protocol Analyzer\n * <p>\n * Created: 8/16/17\n *\n * @author Matthew S. Bauer\n * @version 1.0\n */\npublic class RewritingCache {\n\n    private static final int DEFAULT_CACHE_SIZE = 20000;\n\n    private static final LoadingCache<Term, Term> REDUCED_TERMS;\n    private static final RewriteEngine REWRITE_ENGINE;\n\n    private static long cacheLoads;\n    private static long cacheCalls;\n    private static int cacheSize;\n\n    static {\n\n        cacheLoads = 0;\n        cacheCalls = 0;\n\n        if (RunConfiguration.getRewritingCacheSize().isPresent()) {\n            cacheSize = RunConfiguration.getRewritingCacheSize().get();\n        } else {\n            cacheSize = DEFAULT_CACHE_SIZE;\n        }\n\n        if (RunConfiguration.getRewriteMethod().equals(RewriteMethod.MAUDE)) {\n            REWRITE_ENGINE = new MaudeEngine();\n        } else if (RunConfiguration.getRewriteMethod().equals(RewriteMethod.INTERNAL)) {\n            REWRITE_ENGINE = new InternalEngine();\n        } else {\n            // TODO: Exception\n            REWRITE_ENGINE = null;\n        }\n\n        REDUCED_TERMS = CacheBuilder.newBuilder()\n                .maximumSize(cacheSize)\n                .build(\n                        new CacheLoader<Term, Term>() {\n                            // TODO: tighten exception\n                            public Term load(Term term) throws Exception {\n                                cacheLoads++;\n                                return REWRITE_ENGINE.reduce(term, true);\n                            }\n                        });\n    }\n\n    public static Term reduce(Term term) throws ExecutionException {\n        cacheCalls++;\n        return REDUCED_TERMS.get(term);\n    }\n\n    public static long getCacheLoads() {\n        return cacheLoads;\n    }\n\n    public static long getCacheCalls() {\n        return cacheCalls;\n    }\n\n    public static int getCacheSize() {\n        return cacheSize;\n    }\n}\n", "ny Blue,achellies\n * <p>\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * <p>\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n * <p>\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * @author BunnyBlue\n **/\npackage com.openatlas.framework;\n\nimport android.annotation.SuppressLint;\nimport android.os.Build;\nimport android.os.Build.VERSION;\nimport android.os.Process;\n\nimport com.openatlas.boot.PlatformConfigure;\nimport com.openatlas.framework.bundlestorage.BundleArchive;\nimport com.openatlas.log.Logger;\nimport com.openatlas.log.LoggerFactory;\nimport com.openatlas.log.OpenAtlasMonitor;\nimport com.openatlas.runtime.ClassNotFoundInterceptorCallback;\nimport com.openatlas.runtime.RuntimeVariables;\nimport com.openatlas.util.BundleLock;\nimport com.openatlas.util.FileUtils;\nimport com.openatlas.util.OpenAtlasFileLock;\nimport com.openatlas.util.OpenAtlasUtils;\nimport com.openatlas.util.StringUtils;\n\nimport org.osgi.framework.AdminPermission;\nimport org.osgi.framework.Bundle;\nimport org.osgi.framework.BundleEvent;\nimport org.osgi.framework.BundleException;\nimport org.osgi.framework.BundleListener;\nimport org.osgi.framework.Constants;\nimport org.osgi.framework.Filter;\nimport org.osgi.framework.FrameworkEvent;\nimport org.osgi.framework.FrameworkListener;\nimport org.osgi.framework.InvalidSyntaxException;\nimport org.osgi.framework.ServiceEvent;\nimport org.osgi.framework.ServiceListener;\nimport org.osgi.framework.ServiceReference;\nimport org.osgi.service.packageadmin.ExportedPackage;\nimport org.osgi.service.packageadmin.PackageAdmin;\nimport org.osgi.service.startlevel.StartLevel;\n\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.FilenameFilter;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.net.URL;\nimport java.security.AccessController;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Dictionary;\nimport java.util.EventListener;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Hashtable;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.StringTokenizer;\nimport java.util.concurrent.ConcurrentHashMap;\n\npublic final class Framework {\n    private static final AdminPermission ADMIN_PERMISSION = new AdminPermission();\n    private static String BASEDIR = null;\n    private static String BUNDLE_LOCATION = null;\n    static int CLASSLOADER_BUFFER_SIZE = 0;\n    static boolean DEBUG_BUNDLES = true;\n    static boolean DEBUG_CLASSLOADING = true;\n    static boolean DEBUG_PACKAGES = true;\n    static boolean DEBUG_SERVICES = true;\n    static final String FRAMEWORK_VERSION = \"1.0.0\";\n    private static final String DOWN_GRADE_FILE = \"down_grade_list\";\n    static int LOG_LEVEL;\n    static String STORAGE_LOCATION;\n    @SuppressWarnings(\"unused\")\n    private static boolean STRICT_STARTUP;\n    static List<BundleListener> bundleListeners = new ArrayList<BundleListener>();\n    static Map<String, Bundle> bundles = new ConcurrentHashMap<String, Bundle>();\n    private static ClassNotFoundInterceptorCallback classNotFoundCallback;\n    static Map<String, List<ServiceReference>> classes_services = new HashMap<String, List<ServiceReference>>();\n    static Map<Package, Package> exportedPackages = new ConcurrentHashMap<Package, Package>();\n    static List<FrameworkListener> frameworkListeners = new ArrayList<FrameworkListener>();\n    static boolean frameworkStartupShutdown = false;\n    static int initStartlevel = 1;\n    static final Logger log = LoggerFactory.getInstance(\"Framework\");\n    static boolean mIsEnableBundleInstallWhenFindClass = false;\n    static Map<String, String> mMapForComAndBundles = new HashMap<String, String>();\n    static Properties properties;\n    static boolean restart = false;\n    static List<ServiceListenerEntry> serviceListeners = new ArrayList<ServiceListenerEntry>();\n    static List<ServiceReference> services = new ArrayList<ServiceReference>();\n    static int startlevel = 0;\n    static List<BundleListener> syncBundleListeners = new ArrayList<BundleListener>();\n    static SystemBundle systemBundle;\n    static ClassLoader systemClassLoader;\n    static List<String> writeAheads = new ArrayList<String>();\n\n\n    static final class ServiceListenerEntry implements EventListener {\n        final Filter filter;\n        final ServiceListener listener;\n\n        ServiceListenerEntry(ServiceListener serviceListener, String str) throws InvalidSyntaxException {\n            this.listener = serviceListener;\n            this.filter = str == null ? null : RFC1960Filter.fromString(str);\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (!(obj instanceof ServiceListenerEntry)) {\n                return false;\n            }\n            return this.listener.equals(((ServiceListenerEntry) obj).listener);\n        }\n\n        @Override\n        public int hashCode() {\n            return (this.filter != null ? this.filter.hashCode() >> 8 : 0) + this.listener.hashCode();\n        }\n\n        @Override\n        public String toString() {\n            return this.listener + \" \" + this.filter;\n        }\n    }\n\n    private static final class SystemBundle implements Bundle, PackageAdmin, StartLevel {\n        private final Dictionary<String, String> props;\n        private final ServiceReference[] registeredServices;\n        int state;\n\n        class ShutdownThread extends Thread {\n            final boolean restart;\n\n            ShutdownThread(boolean restart) {\n                this.restart = restart;\n            }\n\n            @Override\n            public void run() {\n                Framework.shutdown(this.restart);\n            }\n        }\n\n        class UpdateLevelThread extends Thread {\n            final int targetLevel;\n\n            UpdateLevelThread(int i) {\n                this.targetLevel = i;\n            }\n\n            @Override\n            public void run() {\n                List bundles = Framework.getBundles();\n                SystemBundle.this.setLevel((Bundle[]) bundles.toArray(new Bundle[bundles.size()]), this.targetLevel, false);\n                Framework.notifyFrameworkListeners(8, Framework.systemBundle, null);\n                Framework.storeMetadata();\n            }\n        }\n\n        // TODO this is Component old version impl\n        class RefreshBundlesThread extends Thread {\n            final Bundle[] bundleArray;\n\n            RefreshBundlesThread(Bundle[] bundleArr) {\n                this.bundleArray = bundleArr;\n            }\n\n            @Override\n            public void run() {\n                synchronized (exportedPackages) {\n                    try {\n                        List<?> bundles;\n                        Bundle[] bundleArr;\n                        int i;\n                        BundleImpl bundleImpl;\n                        if (this.bundleArray == null) {\n                            bundles = Framework.getBundles();\n                            bundleArr = bundles.toArray(new Bundle[bundles.size()]);\n                        } else {\n                            bundleArr = this.bundleArray;\n                        }\n                        List<Bundle> arrayList = new ArrayList<Bundle>(bundleArr.length);\n                        for (i = 0; i < bundleArr.length; i++) {\n                            if (bundleArr[i] != systemBundle) {\n                                bundleImpl = (BundleImpl) bundleArr[i];\n                                if (bundleImpl.classloader == null || bundleImpl.classloader.originalExporter != null) {\n                                    arrayList.add(bundleArr[i]);\n                                }\n                            }\n                        }\n                        if (arrayList.isEmpty()) {\n                            return;\n                        }\n                        int i2;\n                        if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n                            log.debug(\"REFRESHING PACKAGES FROM BUNDLES \" + arrayList);\n                        }\n                        Set hashSet = new HashSet();\n                        while (!arrayList.isEmpty()) {\n                            bundleImpl = (BundleImpl) arrayList.remove(0);\n                            if (!hashSet.contains(bundleImpl)) {\n                                ExportedPackage[] access$100 = SystemBundle.this.getExportedPackages(bundleImpl, true);\n                                if (access$100 != null) {\n                                    for (ExportedPackage exportedPackage : access$100) {\n                                        Package packageR = (Package) exportedPackage;\n                                        if (packageR.importingBundles != null) {\n                                            arrayList.addAll(Arrays.asList(packageR.importingBundles.toArray(new Bundle[packageR.importingBundles.size()])));\n                                        }\n                                    }\n                                }\n                                if (bundleImpl.classloader != null) {\n                                    hashSet.add(bundleImpl);\n                                }\n                            }\n                        }\n                        if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n                            log.debug(\"UPDATE GRAPH IS \" + hashSet);\n                        }\n                        Bundle[] bundleArr2 = new Bundle[hashSet.size()];\n                        i = -1;\n                        bundles = Framework.getBundles();\n                        Bundle[] bundleArr3 = bundles.toArray(new Bundle[bundles.size()]);\n                        for (i2 = 0; i2 < bundleArr3.length; i2++) {\n                            if (hashSet.contains(bundleArr3[i2])) {\n                                i++;\n                                bundleArr2[i] = bundleArr3[i2];\n                            }\n                        }\n                        i2 = startlevel;\n                        SystemBundle.this.setLevel(bundleArr2, 0, true);\n                        for (i = 0; i < bundleArr2.length; i++) {\n                            ((BundleImpl) bundleArr2[i]).classloader.cleanup(false);\n                            ((BundleImpl) bundleArr2[i]).staleExportedPackages = null;\n                        }\n                        for (Bundle bundle : bundleArr2) {\n                            BundleClassLoader bundleClassLoader = ((BundleImpl) bundle).classloader;\n                            if (bundleClassLoader.exports.length > 0) {\n                                Framework.export(bundleClassLoader, bundleClassLoader.exports, false);\n                            }\n                        }\n                        for (Bundle bundle2 : bundleArr2) {\n                            try {\n                                ((BundleImpl) bundle2).classloader.resolveBundle(true, new HashSet<BundleClassLoader>());\n                            } catch (BundleException e) {\n                                e.printStackTrace();\n                            }\n                        }\n                        SystemBundle.this.setLevel(bundleArr2, i2, true);\n                        Framework.notifyFrameworkListeners(4, systemBundle, null);\n                    } catch (Exception e2) {\n                        e2.printStackTrace();\n                    } catch (Throwable th) {\n                    }\n                }\n            }\n        }\n\n        SystemBundle() {\n            this.props = new Hashtable<String, String>();\n            this.props.put(Constants.BUNDLE_NAME, Constants.SYSTEM_BUNDLE_LOCATION);\n            this.props.put(Constants.BUNDLE_VERSION, Framework.FRAMEWORK_VERSION);\n            this.props.put(Constants.BUNDLE_VENDOR, \"Atlas\");\n            ServiceReferenceImpl serviceReferenceImpl = new ServiceReferenceImpl(this, this, null, new String[]{StartLevel.class.getName(), PackageAdmin.class.getName()});\n            Framework.addValue(Framework.classes_services, StartLevel.class.getName(), serviceReferenceImpl);\n            Framework.addValue(Framework.classes_services, PackageAdmin.class.getName(), serviceReferenceImpl);\n            Framework.services.add(serviceReferenceImpl);\n            this.registeredServices = new ServiceReference[]{serviceReferenceImpl};\n        }\n\n        @Override\n        public long getBundleId() {\n            return 0;\n        }\n\n        @Override\n        public Dictionary<String, String> getHeaders() {\n            return this.props;\n        }\n\n        @Override\n        public String getLocation() {\n            return Constants.SYSTEM_BUNDLE_LOCATION;\n        }\n\n        @Override\n        public ServiceReference[] getRegisteredServices() {\n            return this.registeredServices;\n        }\n\n        @Override\n        public URL getResource(String name) {\n            return getClass().getResource(name);\n        }\n\n        @Override\n        public ServiceReference[] getServicesInUse() {\n            return null;\n        }\n\n        @Override\n        public int getState() {\n            return this.state;\n        }\n\n        @Override\n        public boolean hasPermission(Object permission) {\n            return true;\n        }\n\n        @Override\n        public void start() throws BundleException {\n        }\n\n        @Override\n        public void stop() throws BundleException {\n            shutdownThread(false);\n        }\n\n        @Override\n        public void uninstall() throws BundleException {\n            throw new BundleException(\"Cannot uninstall the System Bundle\");\n        }\n\n        @Override\n        public void update() throws BundleException {\n            shutdownThread(true);\n        }\n\n        private void shutdownThread(boolean z) {\n            new ShutdownThread(z).start();\n        }\n\n        @Override\n        public void update(InputStream inputStream) throws BundleException {\n            shutdownThread(true);\n        }\n\n        @Override\n        public void update(File file) throws BundleException {\n            shutdownThread(true);\n        }\n\n        @Override\n        public int getBundleStartLevel(Bundle bundle) {\n            if (bundle == this) {\n                return 0;\n            }\n            BundleImpl bundleImpl = (BundleImpl) bundle;\n            if (bundleImpl.state != BundleEvent.INSTALLED) {\n                return bundleImpl.currentStartlevel;\n            }\n            throw new IllegalArgumentException(\"Bundle \" + bundle + \" has been uninstalled\");\n        }\n\n        @Override\n        public int getInitialBundleStartLevel() {\n            return Framework.initStartlevel;\n        }\n\n        @Override\n        public int getStartLevel() {\n            return Framework.startlevel;\n        }\n\n        @Override\n        public boolean isBundlePersistentlyStarted(Bundle bundle) {\n            if (bundle == this) {\n                return true;\n            }\n            BundleImpl bundleImpl = (BundleImpl) bundle;\n            if (bundleImpl.state != BundleEvent.INSTALLED) {\n                return bundleImpl.persistently;\n            }\n            throw new IllegalArgumentException(\"Bundle \" + bundle + \" has been uninstalled\");\n        }\n\n        @Override\n        public void setBundleStartLevel(Bundle bundle, int level) {\n            if (bundle == this) {\n                throw new IllegalArgumentException(\"Cannot set the start level for the system bundle.\");\n            }\n            BundleImpl bundleImpl = (BundleImpl) bundle;\n            if (bundleImpl.state == BundleEvent.INSTALLED) {\n                throw new IllegalArgumentException(\"Bundle \" + bundle + \" has been uninstalled\");\n            } else if (level <= 0) {\n                throw new IllegalArgumentException(\"Start level \" + level + \" is not Component valid level\");\n            } else {\n                bundleImpl.currentStartlevel = level;\n                bundleImpl.updateMetadata();\n                if (level <= Framework.startlevel && bundle.getState() != BundleEvent.RESOLVED && bundleImpl.persistently) {\n                    try {\n                        bundleImpl.startBundle();\n                    } catch (Throwable e) {\n                        e.printStackTrace();\n                        Framework.notifyFrameworkListeners(BundleEvent.STARTED, bundle, e);\n                    }\n                } else if (level <= Framework.startlevel) {\n                } else {\n                    if (bundle.getState() != BundleEvent.STOPPED || bundle.getState() != BundleEvent.STARTED) {\n                        try {\n                            bundleImpl.stopBundle();\n                        } catch (Throwable e2) {\n                            Framework.notifyFrameworkListeners(BundleEvent.STARTED, bundle, e2);\n                        }\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void setInitialBundleStartLevel(int i) {\n            if (i <= 0) {\n                throw new IllegalArgumentException(\"Start level \" + i + \" is not Component valid level\");\n            }\n            Framework.initStartlevel = i;\n        }\n\n        @Override\n        public void setStartLevel(int i) {\n            if (i <= 0) {\n                throw new IllegalArgumentException(\"Start level \" + i + \" is not Component valid level\");\n            }\n            new UpdateLevelThread(i).start();\n        }\n\n        @SuppressLint({\"UseSparseArrays\"})\n        private void setLevel(Bundle[] bundleArr, int i, boolean z) {\n            if (Framework.startlevel != i) {\n                int i2 = i > Framework.startlevel ? 1 : 0;\n                int i3 = i2 != 0 ? i - Framework.startlevel : Framework.startlevel - i;\n                Map hashMap = new HashMap(0);\n                int i4 = 0;\n                while (i4 < bundleArr.length) {\n                    if (bundleArr[i4] != Framework.systemBundle && (z || ((BundleImpl) bundleArr[i4]).persistently)) {\n                        int i5;\n                        BundleImpl bundleImpl = (BundleImpl) bundleArr[i4];\n                        if (i2 != 0) {\n                            i5 = (bundleImpl.currentStartlevel - Framework.startlevel) - 1;\n                        } else {\n                            i5 = Framework.startlevel - bundleImpl.currentStartlevel;\n                        }\n                        if (i5 >= 0 && i5 < i3) {\n                            Framework.addValue(hashMap, Integer.valueOf(i5), bundleImpl);\n                        }\n                    }\n                    i4++;\n                }\n                for (int i6 = 0; i6 < i3; i6++) {\n                    if (i2 != 0) {\n                        Framework.startlevel++;\n                    } else {\n                        Framework.startlevel--;\n                    }\n                    List list = (List) hashMap.get(Integer.valueOf(i6));\n                    if (list != null) {\n                        BundleImpl[] bundleImplArr = (BundleImpl[]) list.toArray(new BundleImpl[list.size()]);\n                        for (i4 = 0; i4 < bundleImplArr.length; i4++) {\n                            if (i2 != 0) {\n                                try {\n                                    System.out.println(\"STARTING \" + bundleImplArr[i4].location);\n                                    bundleImplArr[i4].startBundle();\n                                } catch (Throwable e) {\n                                    e.printStackTrace();\n                                    e.printStackTrace();\n                                    Framework.notifyFrameworkListeners(2, Framework.systemBundle, e);\n                                }\n                            } else if (bundleImplArr[i4].getState() != 1) {\n                                System.out.println(\"STOPPING \" + bundleImplArr[i4].location);\n                                try {\n                                    bundleImplArr[(bundleImplArr.length - i4) - 1].stopBundle();\n                                } catch (BundleException e) {\n                                    // TODO Auto-generated catch block\n                                    e.printStackTrace();\n                                }\n                            }\n                        }\n                    }\n                }\n                Framework.startlevel = i;\n            }\n        }\n\n        @Override\n        public ExportedPackage[] getExportedPackages(Bundle bundle) {\n            return getExportedPackages(bundle, false);\n        }\n\n        private ExportedPackage[] getExportedPackages(Bundle bundle, boolean z) {\n            synchronized (Framework.exportedPackages) {\n                if (bundle != null) {\n                    if (bundle != Framework.systemBundle) {\n                        BundleImpl bundleImpl = (BundleImpl) bundle;\n                        if (bundleImpl.state == 1) {\n                            ExportedPackage[] exportedPackageArr;\n                            if (z) {\n                                exportedPackageArr = bundleImpl.staleExportedPackages;\n                            } else {\n                                exportedPackageArr = null;\n                            }\n                            return exportedPackageArr;\n                        }\n                        String[] strArr = bundleImpl.classloader.exports;\n                        if (strArr == null) {\n                            return null;\n                        }\n                        ArrayList arrayList = new ArrayList();\n                        for (String str : strArr) {\n                            Package packageR = Framework.exportedPackages.get(new Package(str, null, false));\n                            if (packageR != null && packageR.classloader == bundleImpl.classloader) {\n                                if (packageR.resolved) {\n                                    arrayList.add(packageR);\n                                } else {\n                                    try {\n                                        packageR.classloader.resolveBundle(true, new HashSet());\n                                        arrayList.add(packageR);\n                                    } catch (BundleException e) {\n                                    }\n                                }\n                            }\n                        }\n                        if (bundleImpl.staleExportedPackages != null) {\n                            arrayList.addAll(Arrays.asList(bundleImpl.staleExportedPackages));\n                        }\n                        System.out.println(\"\\tBundle \" + bundleImpl + \" has exported packages \" + arrayList);\n                        return arrayList.isEmpty() ? null : (ExportedPackage[]) arrayList.toArray(new ExportedPackage[arrayList.size()]);\n                    }\n                }\n                return Framework.exportedPackages.keySet().toArray(new ExportedPackage[Framework.exportedPackages.size()]);\n            }\n        }\n\n        @Override\n        public ExportedPackage getExportedPackage(String name) {\n            synchronized (exportedPackages) {\n                try {\n                    Package packageR = exportedPackages.get(new Package(name, null, false));\n                    if (packageR == null) {\n                        return null;\n                    }\n                    if (!packageR.resolved) {\n                        packageR.classloader.resolveBundle(true, new HashSet());\n                    }\n                    return packageR;\n                } catch (BundleException e) {\n                    return null;\n                } catch (Throwable th) {\n                }\n            }\n            return null;\n        }\n\n        @Override\n        public void refreshPackages(Bundle[] bundleArr) {\n            new RefreshBundlesThread(bundleArr).start();\n        }\n\n        @Override\n        public String toString() {\n            return \"SystemBundle\";\n        }\n    }\n\n    //TODO // FIXME: 7/18/15\n    static BundleImpl installNewBundle(String location, File apkFile) throws BundleException {\n        BundleImpl bundleImpl;\n        File mBundleArchiveFile = null;\n        try {\n            BundleLock.WriteLock(location);\n            bundleImpl = (BundleImpl) Framework.getBundle(location);\n            if (bundleImpl != null) {\n                BundleLock.WriteUnLock(location);\n            } else {\n                mBundleArchiveFile = new File(STORAGE_LOCATION, location);\n\n                OpenAtlasFileLock.getInstance().LockExclusive(mBundleArchiveFile);\n                if (mBundleArchiveFile.exists()) {\n                    bundleImpl = restoreFromExistedBundle(location, mBundleArchiveFile);\n                    if (bundleImpl != null) {\n                        BundleLock.WriteUnLock(location);\n                        if (mBundleArchiveFile != null) {\n                            OpenAtlasFileLock.getInstance().unLock(mBundleArchiveFile);\n                        }\n                    }\n                }\n                bundleImpl = new BundleImpl(mBundleArchiveFile, location, new BundleContextImpl(), null, apkFile, true);\n                storeMetadata();\n                BundleLock.WriteUnLock(location);\n                if (mBundleArchiveFile != null) {\n                    OpenAtlasFileLock.getInstance().unLock(mBundleArchiveFile);\n                }\n            }\n        } catch (Throwable e) {\n\n            e.printStackTrace();\n            BundleLock.WriteUnLock(location);\n            throw new BundleException(e.getMessage());\n        }\n\n        return bundleImpl;\n    }\n\n    static boolean restoreBundle(String[] packageNames) {\n\n        try {\n            for (String pkgName : packageNames) {\n                File archiveFile = new File(STORAGE_LOCATION, pkgName);\n                if (!archiveFile.exists() || !BundleArchive.downgradeRevision(archiveFile)) {\n                    return false;\n                }\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    static BundleImpl installNewBundle(String location, InputStream archiveInputStream) throws BundleException {\n        BundleImpl bundleImpl = null;\n        File mBundleArchiveFile = null;\n        try {\n            BundleLock.WriteLock(location);\n            bundleImpl = (BundleImpl) getBundle(location);\n            if (bundleImpl != null) {\n                BundleLock.WriteUnLock(location);\n\n            } else {\n                mBundleArchiveFile = new File(STORAGE_LOCATION, location);\n                OpenAtlasFileLock.getInstance().LockExclusive(mBundleArchiveFile);\n                if (mBundleArchiveFile.exists()) {\n                    bundleImpl = restoreFromExistedBundle(location, mBundleArchiveFile);\n                    if (bundleImpl != null) {\n                        BundleLock.WriteUnLock(location);\n                        if (location != null) {\n                            OpenAtlasFileLock.getInstance().unLock(mBundleArchiveFile);\n                        }\n                    }\n                }\n                bundleImpl = new BundleImpl(mBundleArchiveFile, location, new BundleContextImpl(), archiveInputStream, null, true);\n                storeMetadata();\n                BundleLock.WriteUnLock(location);\n                if (mBundleArchiveFile != null) {\n                    OpenAtlasFileLock.getInstance().unLock(mBundleArchiveFile);\n                }\n\n            }\n        } catch (Throwable v0) {\n            BundleLock.WriteUnLock(location);\n        }\n\n        return bundleImpl;\n    }\n\n\n    private Framework() {\n    }\n\n    static void startup(Properties properties) throws BundleException {\n        if (properties == null) {\n            properties = new Properties();\n        }\n        Framework.properties = properties;\n        startup();\n    }\n\n    private static void startup() throws BundleException {\n        int i;\n        int property;\n        frameworkStartupShutdown = true;\n        System.out.println(\"---------------------------------------------------------\");\n        System.out.println(\"  OpenAtlas OSGi 1.0.0  Pre-Release on \" + Build.MODEL + \"/\" + Build.CPU_ABI + \"/\"\n                + VERSION.RELEASE + \" starting ...\");\n        System.out.println(\"---------------------------------------------------------\");\n        long currentTimeMillis = System.currentTimeMillis();\n        initialize();\n        Framework.launch();\n        boolean property2 = getProperty(\"osgi.init\", false);\n        if (property2) {\n            i = -1;\n        } else {\n            i = restoreProfile();\n            restart = true;\n        }\n        if (i == -1) {\n            restart = false;\n            File file = new File(STORAGE_LOCATION);\n            if (property2 && file.exists()) {\n                System.out.println(\"Purging storage ...\");\n                try {\n                    deleteDirectory(file);\n                } catch (Throwable e) {\n                    throw new RuntimeException(\"deleteDirectory failed\", e);\n                }\n            }\n            try {\n                file.mkdirs();\n                Integer.getInteger(\"osgi.maxLevel\", Integer.valueOf(1)).intValue();\n                initStartlevel = getProperty(\"osgi.startlevel.bundle\", 1);\n                property = getProperty(\"osgi.startlevel.framework\", 1);\n            } catch (Throwable e2) {\n                throw new RuntimeException(\"mkdirs failed\", e2);\n            }\n        }\n        property = i;\n        notifyFrameworkListeners(0, systemBundle, null);\n        systemBundle.setLevel(getBundles().toArray(new Bundle[bundles.size()]), property, false);\n        frameworkStartupShutdown = false;\n        if (!restart) {\n            try {\n                storeProfile();\n            } catch (Throwable e22) {\n                throw new RuntimeException(\"storeProfile failed\", e22);\n            }\n        }\n        long currentTimeMillis2 = System.currentTimeMillis() - currentTimeMillis;\n        System.out.println(\"---------------------------------------------------------\");\n        System.out.println(\"  Framework \" + (restart ? \"restarted\" : \"started\") + \" in \" + currentTimeMillis2 + \" milliseconds.\");\n        System.out.println(\"---------------------------------------------------------\");\n        System.out.flush();\n        systemBundle.state = BundleEvent.RESOLVED;\n        try {\n            notifyFrameworkListeners(FrameworkEvent.STARTED, systemBundle, null);\n        } catch (Throwable e222) {\n            throw new RuntimeException(\"notifyFrameworkListeners failed\", e222);\n        }\n    }\n\n    public static ClassLoader getSystemClassLoader() {\n        return systemClassLoader;\n    }\n\n    public static List<Bundle> getBundles() {\n        List<Bundle> arrayList = new ArrayList<Bundle>(bundles.size());\n        synchronized (bundles) {\n            arrayList.addAll(bundles.values());\n        }\n        return arrayList;\n    }\n\n    public static Bundle getBundle(String location) {\n        return bundles.get(location);\n    }\n\n    public static Bundle getBundle(long j) {\n        return null;\n    }\n\n    static void shutdown(boolean restart) {\n        System.out.println(\"---------------------------------------------------------\");\n        System.out.println(\"  Atlas OSGi shutting down ...\");\n        System.out.println(\"  Bye !\");\n        System.out.println(\"---------------------------------------------------------\");\n        systemBundle.state = BundleEvent.UNINSTALLED;\n        systemBundle.setLevel(getBundles().toArray(new Bundle[bundles.size()]), 0, true);\n        bundles.clear();\n        systemBundle.state = BundleEvent.INSTALLED;\n        if (restart) {\n            try {\n                startup();\n            } catch (Throwable th) {\n                th.printStackTrace();\n            }\n        }\n    }\n\n    public static void initialize() {\n\n        File filesDir = RuntimeVariables.androidApplication.getFilesDir();\n        if (filesDir == null || !filesDir.exists()) {\n            filesDir = RuntimeVariables.androidApplication.getFilesDir();\n        }\n        BASEDIR = properties.getProperty(PlatformConfigure.OPENATLAS_BASEDIR, filesDir.getAbsolutePath());\n        BUNDLE_LOCATION = properties.getProperty(PlatformConfigure.OPENATLAS_BUNDLE_LOCATION, \"file:\" + BASEDIR);\n        CLASSLOADER_BUFFER_SIZE = getProperty(PlatformConfigure.OPENATLAS_CLASSLOADER_BUFFER_SIZE, 1024 * 10);\n        LOG_LEVEL = getProperty(PlatformConfigure.OPENATLAS_LOG_LEVEL, 6);\n        DEBUG_BUNDLES = getProperty(PlatformConfigure.OPENATLAS_DEBUG_BUNDLES, false);\n        DEBUG_PACKAGES = getProperty(PlatformConfigure.OPENATLAS_DEBUG_PACKAGES, false);\n        DEBUG_SERVICES = getProperty(PlatformConfigure.OPENATLAS_DEBUG_SERVICES, false);\n        DEBUG_CLASSLOADING = getProperty(PlatformConfigure.OPENATLAS_DEBUG_CLASSLOADING, false);\n        if (getProperty(PlatformConfigure.OPENATLAS_DEBUG, false)) {\n            System.out.println(\"SETTING ALL DEBUG FLAGS\");\n            LOG_LEVEL = 3;\n            DEBUG_BUNDLES = true;\n            DEBUG_PACKAGES = true;\n            DEBUG_SERVICES = true;\n            DEBUG_CLASSLOADING = true;\n        }\n        STRICT_STARTUP = getProperty(PlatformConfigure.OPENATLAS_STRICT_STARTUP, false);\n        String property = properties.getProperty(\"org.osgi.framework.system.packages\");\n        if (property != null) {\n            StringTokenizer stringTokenizer = new StringTokenizer(property, \",\");\n            int countTokens = stringTokenizer.countTokens();\n            for (int i = 0; i < countTokens; i++) {\n                BundleClassLoader.FRAMEWORK_PACKAGES.add(stringTokenizer.nextToken().trim());\n            }\n        }\n        properties.put(Constants.FRAMEWORK_EXECUTIONENVIRONMENT, System.getProperty(\"java.specification.name\") + \"/\" + System.getProperty(\"java.specification.version\"));\n        Properties properties2 = properties;\n        String str = Constants.FRAMEWORK_OS_NAME;\n        Object property2 = System.getProperty(\"os.name\");\n        if (property2 == null) {\n            property2 = \"undefined\";\n        }\n        properties2.put(str, property2);\n        properties2 = properties;\n        str = Constants.FRAMEWORK_OS_VERSION;\n        property2 = System.getProperty(\"os.version\");\n        if (property2 == null) {\n            property2 = \"undefined\";\n        }\n        properties2.put(str, property2);\n        properties2 = properties;\n        str = Constants.FRAMEWORK_PROCESSOR;\n        property2 = System.getProperty(\"os.arch\");\n        if (property2 == null) {\n            property2 = \"undefined\";\n        }\n        properties2.put(str, property2);\n        properties.put(Constants.FRAMEWORK_VERSION, FRAMEWORK_VERSION);\n        properties.put(Constants.FRAMEWORK_VENDOR, \"Atlas\");\n        property2 = Locale.getDefault().getLanguage();\n        properties2 = properties;\n        str = Constants.FRAMEWORK_LANGUAGE;\n        if (property2 == null) {\n            property2 = \"en\";\n        }\n        properties2.put(str, property2);\n\n\n    }\n\n    private static void launch() {\n        STORAGE_LOCATION = properties.getProperty(PlatformConfigure.INSTALL_LOACTION, properties.getProperty(\"org.osgi.framework.dir\", BASEDIR + File.separatorChar + \"storage\"))\n                + File.separatorChar;\n        systemBundle = new SystemBundle();\n        systemBundle.state = BundleEvent.UPDATED;\n    }\n\n    public static boolean getProperty(String key, boolean defaultValue) {\n        if (properties == null) {\n            return defaultValue;\n        }\n        String str2 = (String) properties.get(key);\n        return str2 != null ? Boolean.valueOf(str2).booleanValue() : defaultValue;\n    }\n\n    public static int getProperty(String key, int defaultValue) {\n        if (properties == null) {\n            return defaultValue;\n        }\n        String str2 = (String) properties.get(key);\n        return str2 != null ? Integer.parseInt(str2) : defaultValue;\n    }\n\n    public static String getProperty(String key) {\n        if (properties == null) {\n            return null;\n        }\n        return (String) properties.get(key);\n    }\n\n    public static String getProperty(String key, String defaultValue) {\n        return properties == null ? defaultValue : (String) properties.get(key);\n    }\n\n    protected static void warning(String str) throws RuntimeException {\n        if (getProperty(PlatformConfigure.OPENATLAS_STRICT_STARTUP, false)) {\n            throw new RuntimeException(str);\n        }\n        System.err.println(\"WARNING: \" + str);\n    }\n\n    private static void storeProfile() {\n        BundleImpl[] bundleImplArr = getBundles().toArray(new BundleImpl[bundles.size()]);\n        for (BundleImpl updateMetadata : bundleImplArr) {\n            updateMetadata.updateMetadata();\n        }\n        storeMetadata();\n    }\n\n    static void storeMetadata() {\n\n        try {\n            File metaFile = new File(STORAGE_LOCATION, \"meta\");\n\n            DataOutputStream dataOutputStream = new DataOutputStream(new FileOutputStream(metaFile));\n            dataOutputStream.writeInt(startlevel);\n            String join = StringUtils.join(writeAheads.toArray(), \",\");\n            if (join == null) {\n                join = \"\";\n            }\n            dataOutputStream.writeUTF(join);\n            dataOutputStream.flush();\n            dataOutputStream.close();\n\n        } catch (IOException e) {\n            OpenAtlasMonitor.getInstance().trace(Integer.valueOf(OpenAtlasMonitor.WRITE_META_FAIL), \"\", \"\", \"storeMetadata failed \", e);\n            log.error(\"Could not save meta data.\", e);\n        }\n    }\n\n\n    private static int restoreProfile() {\n        try {\n            System.out.println(\"Restoring profile\");\n            File file = new File(STORAGE_LOCATION, \"meta\");\n            if (file.exists()) {\n                DataInputStream dataInputStream = new DataInputStream(new FileInputStream(file));\n                int readInt = dataInputStream.readInt();\n                String[] split = StringUtils.split(dataInputStream.readUTF(), \",\");\n                if (split != null) {\n                    writeAheads.addAll(Arrays.asList(split));\n                }\n                dataInputStream.close();\n                if (!getProperty(PlatformConfigure.OPENATLAS_AUTO_LOAD, true)) {\n                    return readInt;\n                }\n                File file2 = new File(STORAGE_LOCATION);\n                mergeWalsDir(new File(STORAGE_LOCATION, \"wal\"), file2);\n                MergeWirteAheads(file2);\n                File[] listFiles = file2.listFiles(new FilenameFilter() {\n                    @Override\n                    public boolean accept(File file, String str) {\n                        return !str.matches(\"^[0-9]*\");\n                    }\n                });\n                int i = 0;\n                while (i < listFiles.length) {\n                    if (listFiles[i].isDirectory() && new File(listFiles[i], \"meta\").exists()) {\n                        try {\n                            System.out.println(\"RESTORED BUNDLE \" + new BundleImpl(listFiles[i], new BundleContextImpl()).location);\n                        } catch (Exception e) {\n                            log.error(e.getMessage(), e.getCause());\n                        }\n                    }\n                    i++;\n                }\n                return readInt;\n            }\n            System.out.println(\"Profile not found, performing clean start ...\");\n            return -1;\n        } catch (Exception e2) {\n            e2.printStackTrace();\n            return 0;\n        }\n    }\n\n    private static void mergeWalsDir(File file, File file2) {\n        if (writeAheads != null && writeAheads.size() > 0) {\n            for (int i = 0; i < writeAheads.size(); i++) {\n                if (writeAheads.get(i) != null) {\n                    File file3 = new File(file, writeAheads.get(i));\n                    if (file3 != null) {\n                        try {\n                            if (file3.exists()) {\n                                File[] listFiles = file3.listFiles();\n                                if (listFiles != null) {\n                                    for (File file4 : listFiles) {\n                                        if (file4.isDirectory()) {\n                                            File file5 = new File(file2, file4.getName());\n                                            if (file5.exists()) {\n                                                File[] listFiles2 = file4.listFiles(new FilenameFilter() {\n                                                    @Override\n                                                    public boolean accept(File file, String str) {\n                                                        return str.startsWith(BundleArchive.REVISION_DIRECTORY);\n                                                    }\n                                                });\n                                                if (listFiles2 != null) {\n                                                    for (File file6 : listFiles2) {\n                                                        if (new File(file6, \"meta\").exists()) {\n                                                            file6.renameTo(new File(file5, file6.getName()));\n                                                        }\n                                                    }\n                                                }\n                                            } else {\n                                                file4.renameTo(file5);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        } catch (Throwable e) {\n                            log.error(\"Error while merge wal dir\", e);\n                        }\n                    }\n                    writeAheads.set(i, null);\n                }\n            }\n        }\n        if (file.exists()) {\n            file.delete();\n        }\n    }\n\n    public static void deleteDirectory(File mDirectory) {\n        File[] listFiles = mDirectory.listFiles();\n        for (int i = 0; i < listFiles.length; i++) {\n            if (listFiles[i].isDirectory()) {\n                deleteDirectory(listFiles[i]);\n            } else {\n                listFiles[i].delete();\n            }\n        }\n        mDirectory.delete();\n    }\n\n    static void checkAdminPermission() {\n        AccessController.checkPermission(ADMIN_PERMISSION);\n    }\n\n    static BundleImpl installNewBundle(String bundleName) throws BundleException {\n        try {\n            String str2 = bundleName.indexOf(\":\") > -1 ? bundleName : BUNDLE_LOCATION + File.separatorChar + bundleName;\n            return installNewBundle(str2, new URL(str2).openConnection().getInputStream());\n        } catch (Throwable e) {\n            throw new BundleException(\"Cannot retrieve bundle from \" + bundleName, e);\n        }\n    }\n\n    private static BundleImpl restoreFromExistedBundle(String location, File file) {\n\n        try {\n            return new BundleImpl(file, new BundleContextImpl());\n        } catch (Throwable e) {\n            OpenAtlasMonitor.getInstance().trace(Integer.valueOf(-1), \"\", \"\", \"restore bundle failed \" + location + e);\n            log.error(\"restore bundle failed\" + location, e);\n            return null;\n        }\n    }\n\n    static void installOrUpdate(String[] locations, File[] archiveFiles) throws BundleException {\n        if (locations == null || archiveFiles == null || locations.length != archiveFiles.length) {\n            throw new IllegalArgumentException(\"locations and files must not be null and must be same length\");\n        }\n        String valueOf = String.valueOf(System.currentTimeMillis());\n        File file = new File(new File(STORAGE_LOCATION, \"wal\"), valueOf);\n        file.mkdirs();\n        int i = 0;\n        while (i < locations.length) {\n            if (!(locations[i] == null || archiveFiles[i] == null)) {\n                try {\n                    BundleLock.WriteLock(locations[i]);\n                    Bundle bundle = getBundle(locations[i]);\n                    if (bundle != null) {\n                        bundle.update(archiveFiles[i]);\n                    } else {\n                        BundleImpl bundleImpl = new BundleImpl(new File(file, locations[i]), locations[i], new BundleContextImpl(), null, archiveFiles[i], false);\n                    }\n                    BundleLock.WriteUnLock(locations[i]);\n                } catch (Throwable th) {\n                    BundleLock.WriteUnLock(locations[i]);\n                }\n            }\n            i++;\n        }\n        writeAheads.add(valueOf);\n        storeMetadata();\n    }\n\n    static void unregisterService(ServiceReference serviceReference) {\n        services.remove(serviceReference);\n        removeValue(classes_services, (String[]) serviceReference.getProperty(Constants.OBJECTCLASS), serviceReference);\n        BundleImpl bundleImpl = (BundleImpl) serviceReference.getBundle();\n        bundleImpl.registeredServices.remove(serviceReference);\n        if (bundleImpl.registeredServices.isEmpty()) {\n            bundleImpl.registeredServices = null;\n        }\n        notifyServiceListeners(BundleEvent.STOPPED, serviceReference);\n        if (DEBUG_SERVICES && log.isInfoEnabled()) {\n            log.info(\"Framework: UNREGISTERED SERVICE \" + serviceReference);\n        }\n    }\n\n    static void notifyBundleListeners(int event, Bundle bundle) {\n\n        if (!syncBundleListeners.isEmpty() || !bundleListeners.isEmpty()) {\n            BundleEvent bundleEvent = new BundleEvent(event, bundle);\n            BundleListener[] bundleListenerArr = syncBundleListeners.toArray(new BundleListener[syncBundleListeners.size()]);\n            for (BundleListener bundleChanged : bundleListenerArr) {\n                bundleChanged.bundleChanged(bundleEvent);\n            }\n            if (!bundleListeners.isEmpty()) {\n                bundleListenerArr = bundleListeners.toArray(new BundleListener[bundleListeners.size()]);\n                for (BundleListener bundleListener : bundleListenerArr) {\n                    bundleListener.bundleChanged(bundleEvent);\n                }\n\n            }\n        }\n    }\n\n    static void addFrameworkListener(FrameworkListener frameworkListener) {\n        frameworkListeners.add(frameworkListener);\n    }\n\n    static void removeFrameworkListener(FrameworkListener frameworkListener) {\n        frameworkListeners.remove(frameworkListener);\n    }\n\n    private static void restoreBundles() throws IOException {\n        File file = new File(STORAGE_LOCATION, DOWN_GRADE_FILE);\n        for (String pkg : FileUtils.getStrings(file)) {\n\n            File locationFolder = new File(STORAGE_LOCATION, pkg);\n            if (locationFolder.exists()) {\n                String[] list = locationFolder.list();\n                String version = null;\n                if (list != null) {\n                    for (String string : list) {\n                        if (string.startsWith(\"version\")\n                                || Long.parseLong(StringUtils.substringAfter(string, \".\")) <= 0) {\n                            version = string;\n                        }\n                    }\n\n                }\n                if (version == null) {\n                    FileUtils.deleteFile(locationFolder.getAbsolutePath());\n                } else {\n                    File tmp = new File(locationFolder, version);\n                    if (tmp.exists()) {\n                        FileUtils.deleteFile(tmp.getAbsolutePath());\n                    }\n                }\n            }\n        }\n        if (file.exists()) {\n            FileUtils.deleteFile(file.getAbsolutePath());\n        }\n    }\n\n    private static void MergeWirteAheads(File file) {\n        try {\n            File file2 = new File(STORAGE_LOCATION, \"wal\");\n            String curProcessName = OpenAtlasUtils.getProcessNameByPID(Process.myPid());\n            log.debug(\"restoreProfile in process \" + curProcessName);\n            String packageName = RuntimeVariables.androidApplication.getPackageName();\n            if (curProcessName != null && packageName != null && curProcessName.equals(packageName)) {\n                mergeWalsDir(file2, file);\n            }\n        } catch (Throwable th) {\n            if (Build.MODEL == null || !Build.MODEL.equals(\"HTC 802w\")) {\n                log.error(th.getMessage(), th.getCause());\n                return;\n            }\n            RuntimeException runtimeException = new RuntimeException(th);\n        }\n    }\n\n    static void addBundleListener(BundleListener bundleListener) {\n        bundleListeners.add(bundleListener);\n    }\n\n    static void removeBundleListener(BundleListener bundleListener) {\n        bundleListeners.remove(bundleListener);\n    }\n\n    static void notifyFrameworkListeners(int event, Bundle bundle, Throwable th) {\n        if (!frameworkListeners.isEmpty()) {\n            FrameworkEvent frameworkEvent = new FrameworkEvent(event, bundle, th);\n            FrameworkListener[] frameworkListenerArr = frameworkListeners.toArray(new FrameworkListener[frameworkListeners.size()]);\n            for (FrameworkListener frameworkListener : frameworkListenerArr) {\n                frameworkListener.frameworkEvent(frameworkEvent);\n            }\n        }\n    }\n\n    static void notifyServiceListeners(int event, ServiceReference serviceReference) {\n        if (!serviceListeners.isEmpty()) {\n            ServiceEvent serviceEvent = new ServiceEvent(event, serviceReference);\n            ServiceListenerEntry[] serviceListenerEntryArr = serviceListeners.toArray(new ServiceListenerEntry[serviceListeners.size()]);\n            for (int i = 0; i < serviceListenerEntryArr.length; i++) {\n                if (serviceListenerEntryArr[i].filter == null || serviceListenerEntryArr[i].filter.match(((ServiceReferenceImpl) serviceReference).properties)) {\n                    serviceListenerEntryArr[i].listener.serviceChanged(serviceEvent);\n                }\n            }\n\n        }\n    }\n\n    static void clearBundleTrace(BundleImpl bundleImpl) {\n\n        if (bundleImpl.registeredFrameworkListeners != null) {\n            frameworkListeners.removeAll(bundleImpl.registeredFrameworkListeners);\n            bundleImpl.registeredFrameworkListeners = null;\n        }\n        if (bundleImpl.registeredServiceListeners != null) {\n            serviceListeners.removeAll(bundleImpl.registeredServiceListeners);\n            bundleImpl.registeredServiceListeners = null;\n        }\n        if (bundleImpl.registeredBundleListeners != null) {\n            bundleListeners.removeAll(bundleImpl.registeredBundleListeners);\n            syncBundleListeners.removeAll(bundleImpl.registeredBundleListeners);\n            bundleImpl.registeredBundleListeners = null;\n        }\n        ServiceReference[] registeredServices = bundleImpl.getRegisteredServices();\n        if (registeredServices != null) {\n            for (ServiceReference serviceReference : registeredServices) {\n                unregisterService(serviceReference);\n                ((ServiceReferenceImpl) serviceReference).invalidate();\n            }\n\n            bundleImpl.registeredServices = null;\n        }\n        ServiceReference[] servicesInUse = bundleImpl.getServicesInUse();\n        for (ServiceReference serviceReference : servicesInUse) {\n            ((ServiceReferenceImpl) serviceReference).ungetService(bundleImpl);\n        }\n\n    }\n\n    static void addValue(Map map, Object obj, Object obj2) {\n        List list = (List) map.get(obj);\n        if (list == null) {\n            list = new ArrayList();\n        }\n        list.add(obj2);\n        map.put(obj, list);\n    }\n\n    static void removeValue(Map map, Object[] objArr, Object obj) {\n        for (int i = 0; i < objArr.length; i++) {\n            List list = (List) map.get(objArr[i]);\n            if (list != null) {\n                list.remove(obj);\n                if (list.isEmpty()) {\n                    map.remove(objArr[i]);\n                } else {\n                    map.put(objArr[i], list);\n                }\n            }\n        }\n    }\n\n    static void export(BundleClassLoader bundleClassLoader, String[] packageNames, boolean resolved) {\n        synchronized (exportedPackages) {\n            if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n                log.debug(\"Bundle \" + bundleClassLoader.bundle + \" registers \" + (resolved ? \"resolved\" : \"unresolved\") + \" packages \" + Arrays.asList(packageNames));\n            }\n            for (String packageName : packageNames) {\n                Package packageR = new Package(packageName, bundleClassLoader, resolved);\n                Package packageR2 = exportedPackages.get(packageR);\n                if (packageR2 == null) {\n                    exportedPackages.put(packageR, packageR);\n                    if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n                        log.debug(\"REGISTERED PACKAGE \" + packageR);\n                    }\n                } else if (packageR2.importingBundles == null && packageR.updates(packageR2)) {\n                    exportedPackages.remove(packageR2);\n                    exportedPackages.put(packageR, packageR);\n                    if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n                        log.debug(\"REPLACED PACKAGE \" + packageR2 + \" WITH \" + packageR);\n                    }\n                }\n            }\n        }\n    }\n\n    static BundleClassLoader getImport(BundleImpl bundleImpl, String packageName, boolean resolve, HashSet<BundleClassLoader> hashSet) {\n        if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n            log.debug(\"Bundle \" + bundleImpl + \" requests package \" + packageName);\n        }\n        synchronized (exportedPackages) {\n            try {\n                Package packageR = exportedPackages.get(new Package(packageName, null, false));\n                if (packageR == null || !(packageR.resolved || resolve)) {\n                    return null;\n                }\n                BundleClassLoader bundleClassLoader = packageR.classloader;\n                if (bundleClassLoader == bundleImpl.classloader) {\n                    return bundleClassLoader;\n                }\n                if (!(!resolve || packageR.resolved || hashSet.contains(packageR.classloader))) {\n                    hashSet.add(bundleImpl.classloader);\n                    packageR.classloader.resolveBundle(true, hashSet);\n                }\n                if (packageR.importingBundles == null) {\n                    packageR.importingBundles = new ArrayList();\n                }\n                if (!packageR.importingBundles.contains(bundleImpl)) {\n                    packageR.importingBundles.add(bundleImpl);\n                }\n                if (DEBUG_PACKAGES && log.isDebugEnabled()) {\n                    log.debug(\"REQUESTED PACKAGE \" + packageName + \", RETURNED DELEGATION TO \" + bundleClassLoader.bundle);\n                }\n                return bundleClassLoader;\n            } catch (Exception e) {\n                e.printStackTrace();\n                return null;\n            } catch (Throwable th) {\n            }\n        }\n        return null;\n    }\n\n    public static boolean isFrameworkStartupShutdown() {\n        return frameworkStartupShutdown;\n    }\n\n    public static ClassNotFoundInterceptorCallback getClassNotFoundCallback() {\n        return classNotFoundCallback;\n    }\n\n    public static void setClassNotFoundCallback(ClassNotFoundInterceptorCallback classNotFoundInterceptorCallback) {\n        classNotFoundCallback = classNotFoundInterceptorCallback;\n    }\n\n\n}\n", "ity.betweenness.SVBetweennessCentrality;\nimport edu.pw.elka.gtna.centrality.interfaces.Centrality;\nimport edu.pw.elka.gtna.graph.GraphFactory;\nimport edu.pw.elka.gtna.graph.creator.TGFReader;\nimport edu.pw.elka.gtna.graph.interfaces.Edge;\nimport edu.pw.elka.gtna.graph.interfaces.Graph;\nimport edu.pw.elka.gtna.graph.interfaces.GraphType;\nimport edu.pw.elka.gtna.graph.interfaces.Node;\n\n\npublic class SVBetweennessCentralityExample {\n\t\n\tpublic static void main(String[] args) {\n\t\t\n\t\t// the file in trivial graph format\n\t\tString tgfFile = \"example.tgf\";\n\t\t\n\t\t// creating new undirected graph\n\t\tGraph<Node,Edge<Node>> g = \n\t\t\t\tGraphFactory.<Node,Edge<Node>>newSimpleInstance(new TGFReader(tgfFile),GraphType.SIMPLE);\n\t\t\n\t\t// creating new centrality metric (Shapley value based betweenness centrality)\n\t\tCentrality<Node> bc = new SVBetweennessCentrality<Node>(g);\n\t\tbc.computeCentrality();\n\t\tbc.printCentralities();\n\t\t\n\t\t\n\t\tdouble sum = 0.0;\n\t\tfor (Node n: g.getNodes()){\n\t\t\tsum+=bc.getCentrality(n);\n\t\t}\n\t\t\n\t\tDecimalFormat df=new DecimalFormat(\"0.0000\");\n\t\tString formate = df.format(sum); \n\t\tSystem.out.println(\"\\n\\nSum: \"+formate);\n\t\t\n\t}\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.network.v2020_05_01.implementation;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * P2S Vpn connection detailed health written to sas url.\n */\npublic class P2SVpnConnectionHealthInner {\n    /**\n     * Returned sas url of the blob to which the p2s vpn connection detailed\n     * health will be written.\n     */\n    @JsonProperty(value = \"sasUrl\")\n    private String sasUrl;\n\n    /**\n     * Get returned sas url of the blob to which the p2s vpn connection detailed health will be written.\n     *\n     * @return the sasUrl value\n     */\n    public String sasUrl() {\n        return this.sasUrl;\n    }\n\n    /**\n     * Set returned sas url of the blob to which the p2s vpn connection detailed health will be written.\n     *\n     * @param sasUrl the sasUrl value to set\n     * @return the P2SVpnConnectionHealthInner object itself.\n     */\n    public P2SVpnConnectionHealthInner withSasUrl(String sasUrl) {\n        this.sasUrl = sasUrl;\n        return this;\n    }\n\n}\n", ";\nimport com.example.example.with.key.InfantType;\nimport com.example.example.with.key.KeyFactory;\nimport com.example.example.with.key.KeyPackage;\nimport com.example.example.with.key.PassengerType;\nimport com.example.example.with.key.PassengersType;\n\nimport org.eclipse.emf.ecore.EAttribute;\nimport org.eclipse.emf.ecore.EClass;\nimport org.eclipse.emf.ecore.EPackage;\nimport org.eclipse.emf.ecore.EReference;\n\nimport org.eclipse.emf.ecore.impl.EPackageImpl;\n\nimport org.eclipse.emf.ecore.xml.type.XMLTypePackage;\n\n/**\n * <!-- begin-user-doc -->\n * An implementation of the model <b>Package</b>.\n * <!-- end-user-doc -->\n * @generated\n */\npublic class KeyPackageImpl extends EPackageImpl implements KeyPackage {\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate EClass documentRootEClass = null;\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate EClass infantTypeEClass = null;\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate EClass passengersTypeEClass = null;\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate EClass passengerTypeEClass = null;\n\n\t/**\n\t * Creates an instance of the model <b>Package</b>, registered with\n\t * {@link org.eclipse.emf.ecore.EPackage.Registry EPackage.Registry} by the package\n\t * package URI value.\n\t * <p>Note: the correct way to create the package is via the static\n\t * factory method {@link #init init()}, which also performs\n\t * initialization of the package, or returns the registered package,\n\t * if one already exists.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see org.eclipse.emf.ecore.EPackage.Registry\n\t * @see com.example.example.with.key.KeyPackage#eNS_URI\n\t * @see #init()\n\t * @generated\n\t */\n\tprivate KeyPackageImpl() {\n\t\tsuper(eNS_URI, KeyFactory.eINSTANCE);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate static boolean isInited = false;\n\n\t/**\n\t * Creates, registers, and initializes the <b>Package</b> for this model, and for any others upon which it depends.\n\t * \n\t * <p>This method is used to initialize {@link KeyPackage#eINSTANCE} when that field is accessed.\n\t * Clients should not invoke it directly. Instead, they should simply access that field to obtain the package.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @see #eNS_URI\n\t * @see #createPackageContents()\n\t * @see #initializePackageContents()\n\t * @generated\n\t */\n\tpublic static KeyPackage init() {\n\t\tif (isInited) return (KeyPackage)EPackage.Registry.INSTANCE.getEPackage(KeyPackage.eNS_URI);\n\n\t\t// Obtain or create and register package\n\t\tKeyPackageImpl theKeyPackage = (KeyPackageImpl)(EPackage.Registry.INSTANCE.get(eNS_URI) instanceof KeyPackageImpl ? EPackage.Registry.INSTANCE.get(eNS_URI) : new KeyPackageImpl());\n\n\t\tisInited = true;\n\n\t\t// Initialize simple dependencies\n\t\tXMLTypePackage.eINSTANCE.eClass();\n\n\t\t// Create package meta-data objects\n\t\ttheKeyPackage.createPackageContents();\n\n\t\t// Initialize created meta-data\n\t\ttheKeyPackage.initializePackageContents();\n\n\t\t// Mark meta-data to indicate it can't be changed\n\t\ttheKeyPackage.freeze();\n\n  \n\t\t// Update the registry and return the package\n\t\tEPackage.Registry.INSTANCE.put(KeyPackage.eNS_URI, theKeyPackage);\n\t\treturn theKeyPackage;\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getDocumentRoot() {\n\t\treturn documentRootEClass;\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getDocumentRoot_Mixed() {\n\t\treturn (EAttribute)documentRootEClass.getEStructuralFeatures().get(0);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getDocumentRoot_XMLNSPrefixMap() {\n\t\treturn (EReference)documentRootEClass.getEStructuralFeatures().get(1);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getDocumentRoot_XSISchemaLocation() {\n\t\treturn (EReference)documentRootEClass.getEStructuralFeatures().get(2);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getDocumentRoot_Passengers() {\n\t\treturn (EReference)documentRootEClass.getEStructuralFeatures().get(3);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getInfantType() {\n\t\treturn infantTypeEClass;\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getInfantType_FullName() {\n\t\treturn (EAttribute)infantTypeEClass.getEStructuralFeatures().get(0);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getInfantType_AssociatedPassengerID() {\n\t\treturn (EAttribute)infantTypeEClass.getEStructuralFeatures().get(1);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getInfantType_ID() {\n\t\treturn (EAttribute)infantTypeEClass.getEStructuralFeatures().get(2);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getInfantType_SequenceNo() {\n\t\treturn (EAttribute)infantTypeEClass.getEStructuralFeatures().get(3);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getPassengersType() {\n\t\treturn passengersTypeEClass;\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getPassengersType_Group() {\n\t\treturn (EAttribute)passengersTypeEClass.getEStructuralFeatures().get(0);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getPassengersType_Passenger() {\n\t\treturn (EReference)passengersTypeEClass.getEStructuralFeatures().get(1);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EReference getPassengersType_Infant() {\n\t\treturn (EReference)passengersTypeEClass.getEStructuralFeatures().get(2);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EClass getPassengerType() {\n\t\treturn passengerTypeEClass;\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getPassengerType_FullName() {\n\t\treturn (EAttribute)passengerTypeEClass.getEStructuralFeatures().get(0);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getPassengerType_AssociatedInfantID() {\n\t\treturn (EAttribute)passengerTypeEClass.getEStructuralFeatures().get(1);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getPassengerType_ID() {\n\t\treturn (EAttribute)passengerTypeEClass.getEStructuralFeatures().get(2);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic EAttribute getPassengerType_SequenceNo() {\n\t\treturn (EAttribute)passengerTypeEClass.getEStructuralFeatures().get(3);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic KeyFactory getKeyFactory() {\n\t\treturn (KeyFactory)getEFactoryInstance();\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate boolean isCreated = false;\n\n\t/**\n\t * Creates the meta-model objects for the package.  This method is\n\t * guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void createPackageContents() {\n\t\tif (isCreated) return;\n\t\tisCreated = true;\n\n\t\t// Create classes and their features\n\t\tdocumentRootEClass = createEClass(DOCUMENT_ROOT);\n\t\tcreateEAttribute(documentRootEClass, DOCUMENT_ROOT__MIXED);\n\t\tcreateEReference(documentRootEClass, DOCUMENT_ROOT__XMLNS_PREFIX_MAP);\n\t\tcreateEReference(documentRootEClass, DOCUMENT_ROOT__XSI_SCHEMA_LOCATION);\n\t\tcreateEReference(documentRootEClass, DOCUMENT_ROOT__PASSENGERS);\n\n\t\tinfantTypeEClass = createEClass(INFANT_TYPE);\n\t\tcreateEAttribute(infantTypeEClass, INFANT_TYPE__FULL_NAME);\n\t\tcreateEAttribute(infantTypeEClass, INFANT_TYPE__ASSOCIATED_PASSENGER_ID);\n\t\tcreateEAttribute(infantTypeEClass, INFANT_TYPE__ID);\n\t\tcreateEAttribute(infantTypeEClass, INFANT_TYPE__SEQUENCE_NO);\n\n\t\tpassengersTypeEClass = createEClass(PASSENGERS_TYPE);\n\t\tcreateEAttribute(passengersTypeEClass, PASSENGERS_TYPE__GROUP);\n\t\tcreateEReference(passengersTypeEClass, PASSENGERS_TYPE__PASSENGER);\n\t\tcreateEReference(passengersTypeEClass, PASSENGERS_TYPE__INFANT);\n\n\t\tpassengerTypeEClass = createEClass(PASSENGER_TYPE);\n\t\tcreateEAttribute(passengerTypeEClass, PASSENGER_TYPE__FULL_NAME);\n\t\tcreateEAttribute(passengerTypeEClass, PASSENGER_TYPE__ASSOCIATED_INFANT_ID);\n\t\tcreateEAttribute(passengerTypeEClass, PASSENGER_TYPE__ID);\n\t\tcreateEAttribute(passengerTypeEClass, PASSENGER_TYPE__SEQUENCE_NO);\n\t}\n\n\t/**\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprivate boolean isInitialized = false;\n\n\t/**\n\t * Complete the initialization of the package and its meta-model.  This\n\t * method is guarded to have no affect on any invocation but its first.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic void initializePackageContents() {\n\t\tif (isInitialized) return;\n\t\tisInitialized = true;\n\n\t\t// Initialize package\n\t\tsetName(eNAME);\n\t\tsetNsPrefix(eNS_PREFIX);\n\t\tsetNsURI(eNS_URI);\n\n\t\t// Obtain other dependent packages\n\t\tXMLTypePackage theXMLTypePackage = (XMLTypePackage)EPackage.Registry.INSTANCE.getEPackage(XMLTypePackage.eNS_URI);\n\n\t\t// Create type parameters\n\n\t\t// Set bounds for type parameters\n\n\t\t// Add supertypes to classes\n\n\t\t// Initialize classes, features, and operations; add parameters\n\t\tinitEClass(documentRootEClass, DocumentRoot.class, \"DocumentRoot\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getDocumentRoot_Mixed(), ecorePackage.getEFeatureMapEntry(), \"mixed\", null, 0, -1, null, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, !IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getDocumentRoot_XMLNSPrefixMap(), ecorePackage.getEStringToStringMapEntry(), null, \"xMLNSPrefixMap\", null, 0, -1, null, IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getDocumentRoot_XSISchemaLocation(), ecorePackage.getEStringToStringMapEntry(), null, \"xSISchemaLocation\", null, 0, -1, null, IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getDocumentRoot_Passengers(), this.getPassengersType(), null, \"passengers\", null, 0, -2, null, IS_TRANSIENT, IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(infantTypeEClass, InfantType.class, \"InfantType\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getInfantType_FullName(), theXMLTypePackage.getString(), \"fullName\", null, 1, 1, InfantType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getInfantType_AssociatedPassengerID(), theXMLTypePackage.getInt(), \"associatedPassengerID\", null, 1, 1, InfantType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getInfantType_ID(), theXMLTypePackage.getInt(), \"iD\", null, 1, 1, InfantType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getInfantType_SequenceNo(), theXMLTypePackage.getInt(), \"sequenceNo\", null, 1, 1, InfantType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(passengersTypeEClass, PassengersType.class, \"PassengersType\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getPassengersType_Group(), ecorePackage.getEFeatureMapEntry(), \"group\", null, 0, -1, PassengersType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, !IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getPassengersType_Passenger(), this.getPassengerType(), null, \"passenger\", null, 0, -1, PassengersType.class, IS_TRANSIENT, IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, IS_DERIVED, IS_ORDERED);\n\t\tinitEReference(getPassengersType_Infant(), this.getInfantType(), null, \"infant\", null, 0, -1, PassengersType.class, IS_TRANSIENT, IS_VOLATILE, IS_CHANGEABLE, IS_COMPOSITE, !IS_RESOLVE_PROXIES, !IS_UNSETTABLE, IS_UNIQUE, IS_DERIVED, IS_ORDERED);\n\n\t\tinitEClass(passengerTypeEClass, PassengerType.class, \"PassengerType\", !IS_ABSTRACT, !IS_INTERFACE, IS_GENERATED_INSTANCE_CLASS);\n\t\tinitEAttribute(getPassengerType_FullName(), theXMLTypePackage.getString(), \"fullName\", null, 1, 1, PassengerType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, !IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getPassengerType_AssociatedInfantID(), theXMLTypePackage.getInt(), \"associatedInfantID\", null, 0, 1, PassengerType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getPassengerType_ID(), theXMLTypePackage.getInt(), \"iD\", null, 1, 1, PassengerType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\t\tinitEAttribute(getPassengerType_SequenceNo(), theXMLTypePackage.getInt(), \"sequenceNo\", null, 1, 1, PassengerType.class, !IS_TRANSIENT, !IS_VOLATILE, IS_CHANGEABLE, IS_UNSETTABLE, !IS_ID, IS_UNIQUE, !IS_DERIVED, IS_ORDERED);\n\n\t\t// Create resource\n\t\tcreateResource(eNS_URI);\n\n\t\t// Create annotations\n\t\t// http:///org/eclipse/emf/ecore/util/ExtendedMetaData\n\t\tcreateExtendedMetaDataAnnotations();\n\t}\n\n\t/**\n\t * Initializes the annotations for <b>http:///org/eclipse/emf/ecore/util/ExtendedMetaData</b>.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprotected void createExtendedMetaDataAnnotations() {\n\t\tString source = \"http:///org/eclipse/emf/ecore/util/ExtendedMetaData\";\t\n\t\taddAnnotation\n\t\t  (documentRootEClass, \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"name\", \"\",\n\t\t\t \"kind\", \"mixed\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getDocumentRoot_Mixed(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"elementWildcard\",\n\t\t\t \"name\", \":mixed\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getDocumentRoot_XMLNSPrefixMap(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"xmlns:prefix\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getDocumentRoot_XSISchemaLocation(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"xsi:schemaLocation\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getDocumentRoot_Passengers(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"element\",\n\t\t\t \"name\", \"Passengers\",\n\t\t\t \"namespace\", \"##targetNamespace\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (infantTypeEClass, \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"name\", \"InfantType\",\n\t\t\t \"kind\", \"elementOnly\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getInfantType_FullName(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"element\",\n\t\t\t \"name\", \"FullName\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getInfantType_AssociatedPassengerID(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"AssociatedPassengerID\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getInfantType_ID(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"ID\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getInfantType_SequenceNo(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"SequenceNo\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (passengersTypeEClass, \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"name\", \"Passengers_._type\",\n\t\t\t \"kind\", \"elementOnly\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengersType_Group(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"group\",\n\t\t\t \"name\", \"group:0\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengersType_Passenger(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"element\",\n\t\t\t \"name\", \"Passenger\",\n\t\t\t \"group\", \"#group:0\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengersType_Infant(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"element\",\n\t\t\t \"name\", \"Infant\",\n\t\t\t \"group\", \"#group:0\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (passengerTypeEClass, \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"name\", \"PassengerType\",\n\t\t\t \"kind\", \"elementOnly\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengerType_FullName(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"element\",\n\t\t\t \"name\", \"FullName\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengerType_AssociatedInfantID(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"AssociatedInfantID\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengerType_ID(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"ID\"\n\t\t   });\t\n\t\taddAnnotation\n\t\t  (getPassengerType_SequenceNo(), \n\t\t   source, \n\t\t   new String[] {\n\t\t\t \"kind\", \"attribute\",\n\t\t\t \"name\", \"SequenceNo\"\n\t\t   });\n\t}\n\n} //KeyPackageImpl\n", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.mixin.core.server.management;\n\nimport com.flowpowered.math.vector.Vector3d;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.BlockChest;\nimport net.minecraft.block.BlockCommandBlock;\nimport net.minecraft.block.BlockDoor;\nimport net.minecraft.block.BlockStructure;\nimport net.minecraft.block.state.IBlockState;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.entity.player.EntityPlayerMP;\nimport net.minecraft.init.Blocks;\nimport net.minecraft.inventory.Container;\nimport net.minecraft.inventory.IInventory;\nimport net.minecraft.item.Item;\nimport net.minecraft.item.ItemBlock;\nimport net.minecraft.item.ItemDoor;\nimport net.minecraft.item.ItemStack;\nimport net.minecraft.network.play.server.SPacketBlockChange;\nimport net.minecraft.network.play.server.SPacketCloseWindow;\nimport net.minecraft.server.management.PlayerInteractionManager;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.tileentity.TileEntityChest;\nimport net.minecraft.util.EnumActionResult;\nimport net.minecraft.util.EnumFacing;\nimport net.minecraft.util.EnumHand;\nimport net.minecraft.util.math.BlockPos;\nimport net.minecraft.world.GameType;\nimport net.minecraft.world.ILockableContainer;\nimport org.spongepowered.api.block.BlockSnapshot;\nimport org.spongepowered.api.event.block.InteractBlockEvent;\nimport org.spongepowered.api.event.cause.Cause;\nimport org.spongepowered.api.event.cause.NamedCause;\nimport org.spongepowered.api.util.Tristate;\nimport org.spongepowered.api.world.World;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Overwrite;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.common.event.SpongeCommonEventFactory;\nimport org.spongepowered.common.interfaces.server.management.IMixinPlayerInteractionManager;\nimport org.spongepowered.common.registry.provider.DirectionFacingProvider;\n\nimport java.util.Optional;\n\nimport javax.annotation.Nullable;\n\n@Mixin(value = PlayerInteractionManager.class)\npublic abstract class MixinPlayerInteractionManager implements IMixinPlayerInteractionManager {\n\n    @Shadow public EntityPlayerMP player;\n    @Shadow public net.minecraft.world.World world;\n    @Shadow private GameType gameType;\n\n    @Shadow public abstract boolean isCreative();\n\n    /**\n     * @author Aaron1011\n     * @author gabizou - May 28th, 2016 - Rewritten for 1.9.4\n     *\n     * @reason Fire interact block event.\n     */\n    @Overwrite\n    public EnumActionResult processRightClickBlock(EntityPlayer player, net.minecraft.world.World worldIn, @Nullable ItemStack stack, EnumHand hand, BlockPos pos, EnumFacing facing, float offsetX, float offsetY, float offsetZ) {\n        if (this.gameType == GameType.SPECTATOR) {\n            TileEntity tileentity = worldIn.getTileEntity(pos);\n\n            if (tileentity instanceof ILockableContainer) {\n                Block block = worldIn.getBlockState(pos).getBlock();\n                ILockableContainer ilockablecontainer = (ILockableContainer) tileentity;\n\n                if (ilockablecontainer instanceof TileEntityChest && block instanceof BlockChest) {\n                    ilockablecontainer = ((BlockChest) block).getLockableContainer(worldIn, pos);\n                }\n\n                if (ilockablecontainer != null) {\n                    // TODO - fire event\n                    player.displayGUIChest(ilockablecontainer);\n                    return EnumActionResult.SUCCESS;\n                }\n            } else if (tileentity instanceof IInventory) {\n                // TODO - fire event\n                player.displayGUIChest((IInventory) tileentity);\n                return EnumActionResult.SUCCESS;\n            }\n\n            return EnumActionResult.PASS;\n\n        } // else { // Sponge - Remove unecessary else\n        // Sponge Start - Create an interact block event before something happens.\n        @Nullable final ItemStack oldStack = stack.copy();\n\n        final BlockSnapshot currentSnapshot = ((World) worldIn).createSnapshot(pos.getX(), pos.getY(), pos.getZ());\n        final InteractBlockEvent.Secondary event = SpongeCommonEventFactory.callInteractBlockEventSecondary(Cause.of(NamedCause.source(player)),\n                Optional.of(new Vector3d(offsetX, offsetY, offsetZ)), currentSnapshot,\n                DirectionFacingProvider.getInstance().getKey(facing).get(), hand);\n        if (!ItemStack.areItemStacksEqual(oldStack, this.player.getHeldItem(hand))) {\n            SpongeCommonEventFactory.playerInteractItemChanged = true;\n        }\n\n        if (event.isCancelled()) {\n            final IBlockState state = (IBlockState) currentSnapshot.getState();\n\n            if (state.getBlock() == Blocks.COMMAND_BLOCK) {\n                // CommandBlock GUI opens solely on the client, we need to force it close on cancellation\n                this.player.connection.sendPacket(new SPacketCloseWindow(0));\n\n            } else if (state.getProperties().containsKey(BlockDoor.HALF)) {\n                // Stopping a door from opening while `g the top part will allow the door to open, we need to update the\n                // client to resolve this\n                if (state.getValue(BlockDoor.HALF) == BlockDoor.EnumDoorHalf.LOWER) {\n                    this.player.connection.sendPacket(new SPacketBlockChange(worldIn, pos.up()));\n                } else {\n                    this.player.connection.sendPacket(new SPacketBlockChange(worldIn, pos.down()));\n                }\n\n            } else if (!oldStack.isEmpty()) {\n                // Stopping the placement of a door or double plant causes artifacts (ghosts) on the top-side of the block. We need to remove it\n                final Item item = oldStack.getItem();\n                if (item instanceof ItemDoor || (item instanceof ItemBlock && ((ItemBlock) item).getBlock().equals(Blocks.DOUBLE_PLANT))) {\n                    this.player.connection.sendPacket(new SPacketBlockChange(worldIn, pos.up(2)));\n                }\n            }\n\n            SpongeCommonEventFactory.interactBlockEventCancelled = true;\n            return EnumActionResult.FAIL;\n        }\n        // Sponge End\n\n        if (!player.isSneaking() || player.getHeldItemMainhand().isEmpty() && player.getHeldItemOffhand().isEmpty()) {\n            // Sponge start - check event useBlockResult, and revert the client if it's FALSE.\n            // Also, store the result instead of returning immediately\n            if (event.getUseBlockResult() != Tristate.FALSE) {\n                IBlockState iblockstate = (IBlockState) currentSnapshot.getState();\n                Container lastOpenContainer = player.openContainer;\n\n                EnumActionResult result = iblockstate.getBlock().onBlockActivated(worldIn, pos, iblockstate, player, hand, facing, offsetX, offsetY, offsetZ)\n                         ? EnumActionResult.SUCCESS\n                         : EnumActionResult.PASS;\n                // if itemstack changed, avoid restore\n                if (!ItemStack.areItemStacksEqual(oldStack, this.player.getHeldItem(hand))) {\n                    SpongeCommonEventFactory.playerInteractItemChanged = true;\n                }\n\n                result = this.handleOpenEvent(lastOpenContainer, this.player, currentSnapshot, result);\n\n                if (result != EnumActionResult.PASS) {\n\n                    return result;\n                }\n            } else {\n                // Need to send a block change to the client, because otherwise, they are not\n                // going to be told about the block change.\n                this.player.connection.sendPacket(new SPacketBlockChange(this.world, pos));\n                // Since the event was explicitly set to fail, we need to respect it and treat it as if\n                // it wasn't cancelled, but perform no further processing.\n                return EnumActionResult.FAIL;\n            }\n            // Sponge End\n        }\n\n        if (stack.isEmpty()) {\n            return EnumActionResult.PASS;\n        } else if (player.getCooldownTracker().hasCooldown(stack.getItem())) {\n            return EnumActionResult.PASS;\n        } else if (stack.getItem() instanceof ItemBlock && !player.canUseCommandBlock()) {\n            Block block = ((ItemBlock)stack.getItem()).getBlock();\n\n            if (block instanceof BlockCommandBlock || block instanceof BlockStructure)\n            {\n                return EnumActionResult.FAIL;\n            }\n        } // else if (this.isCreative()) { // Sponge - Rewrite this to handle an isCreative check after the result, since we have a copied stack at the top of this method.\n        //    int j = stack.getMetadata();\n        //    int i = stack.stackSize;\n        //    EnumActionResult enumactionresult = stack.onItemUse(player, worldIn, pos, hand, facing, offsetX, offsetY, offsetZ);\n        //    stack.setItemDamage(j);\n        //    stack.stackSize = i;\n        //    return enumactionresult;\n        // } else {\n        //    return stack.onItemUse(player, worldIn, pos, hand, facing, offsetX, offsetY, offsetZ);\n        // }\n        // } // Sponge - Remove unecessary else bracket\n        // Sponge Start - complete the method with the micro change of resetting item damage and quantity from the copied stack.\n        final EnumActionResult result = stack.onItemUse(player, worldIn, pos, hand, facing, offsetX, offsetY, offsetZ);\n        if (this.isCreative()) {\n            stack.setItemDamage(oldStack.getItemDamage());\n            stack.setCount(oldStack.getCount());\n        }\n\n        if (!ItemStack.areItemStacksEqual(player.getHeldItem(hand), oldStack) || result != EnumActionResult.SUCCESS) {\n            player.openContainer.detectAndSendChanges();\n        }\n\n        return result;\n        // Sponge end\n        // } // Sponge - Remove unecessary else bracket\n    }\n\n    @Override\n    public EnumActionResult handleOpenEvent(Container lastOpenContainer, EntityPlayerMP player, BlockSnapshot blockSnapshot, EnumActionResult result) {\n\n        if (lastOpenContainer != player.openContainer) {\n            if (!SpongeCommonEventFactory.callInteractInventoryOpenEvent(Cause.of(NamedCause.source(player), NamedCause.hitTarget(blockSnapshot)), player)) {\n                result = EnumActionResult.FAIL;\n                SpongeCommonEventFactory.interactBlockEventCancelled = true;\n            }\n        }\n        return result;\n    }\n}\n", "kage com.azure.core.implementation.serializer;\n\nimport com.azure.core.annotation.ReturnValueWireType;\nimport com.azure.core.exception.HttpResponseException;\nimport com.azure.core.http.HttpMethod;\nimport com.azure.core.http.HttpResponse;\nimport com.azure.core.http.rest.Page;\nimport com.azure.core.http.rest.Response;\nimport com.azure.core.http.rest.ResponseBase;\nimport com.azure.core.http.rest.SimpleResponse;\nimport com.azure.core.util.serializer.SerializerAdapter;\nimport com.azure.core.util.serializer.SerializerEncoding;\nimport com.azure.core.util.Base64Url;\nimport com.azure.core.util.DateTimeRfc1123;\nimport com.azure.core.implementation.UnixTime;\nimport com.azure.core.http.rest.PagedResponseBase;\nimport com.azure.core.util.FluxUtil;\nimport com.azure.core.implementation.TypeUtil;\nimport com.azure.core.util.logging.ClientLogger;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Mono;\n\nimport java.io.IOException;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.time.OffsetDateTime;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\n\n/**\n * Decoder to decode body of HTTP response.\n */\nfinal class HttpResponseBodyDecoder {\n    /**\n     * Decodes body of a http response.\n     *\n     * The content reading and decoding happens when caller subscribe to the returned {@code Mono<Object>},\n     * if the response body is not decodable then {@code Mono.empty()} will be returned.\n     *\n     * @param httpResponse the response containing the body to be decoded\n     * @param serializer the adapter to use for decoding\n     * @param decodeData the necessary data required to decode a Http response\n     * @return publisher that emits decoded response body upon subscription if body is decodable,\n     *     no emission if the body is not-decodable\n     */\n    static Mono<Object> decode(HttpResponse httpResponse, SerializerAdapter serializer,\n                               HttpResponseDecodeData decodeData) {\n        ensureRequestSet(httpResponse);\n        final ClientLogger logger = new ClientLogger(HttpResponseBodyDecoder.class);\n        //\n        return Mono.defer(() -> {\n            if (isErrorStatus(httpResponse, decodeData)) {\n                return httpResponse.getBodyAsString()\n                    .flatMap(bodyString -> {\n                        try {\n                            final Object decodedErrorEntity = deserializeBody(bodyString,\n                                decodeData.getUnexpectedException(httpResponse.getStatusCode()).getExceptionBodyType(),\n                                null, serializer, SerializerEncoding.fromHeaders(httpResponse.getHeaders()));\n                            return decodedErrorEntity == null ? Mono.empty() : Mono.just(decodedErrorEntity);\n                        } catch (IOException | MalformedValueException ex) {\n                            // This translates in RestProxy as a RestException with no deserialized body.\n                            // The response content will still be accessible via the .response() member.\n                            logger.warning(\"Failed to deserialize the error entity.\", ex);\n                        }\n                        return Mono.empty();\n                    });\n            } else if (httpResponse.getRequest().getHttpMethod() == HttpMethod.HEAD) {\n                // RFC: A response to a HEAD method should not have a body. If so, it must be ignored\n                return Mono.empty();\n            } else if (!isReturnTypeDecodable(decodeData)) {\n                return Mono.empty();\n            } else {\n                return httpResponse.getBodyAsString()\n                    .flatMap(bodyString -> {\n                        try {\n                            final Object decodedSuccessEntity = deserializeBody(bodyString,\n                                extractEntityTypeFromReturnType(decodeData),\n                                decodeData.getReturnValueWireType(),\n                                serializer,\n                                SerializerEncoding.fromHeaders(httpResponse.getHeaders()));\n                            return decodedSuccessEntity == null ? Mono.empty() : Mono.just(decodedSuccessEntity);\n                        } catch (MalformedValueException e) {\n                            return Mono.error(new HttpResponseException(\"HTTP response has a malformed body.\",\n                                httpResponse, e));\n                        } catch (IOException e) {\n                            return Mono.error(new HttpResponseException(\"Deserialization Failed.\", httpResponse, e));\n                        }\n                    });\n            }\n        });\n    }\n\n    /**\n     * @return true if the body is decodable, false otherwise\n     */\n    static boolean isDecodable(HttpResponse httpResponse, HttpResponseDecodeData decodeData) {\n        ensureRequestSet(httpResponse);\n        //\n        if (isErrorStatus(httpResponse, decodeData)) {\n            // For error cases we always try to decode the non-empty response body\n            // either to a strongly typed exception model or to Object\n            return true;\n        } else if (httpResponse.getRequest().getHttpMethod() == HttpMethod.HEAD) {\n            // RFC: A response to a HEAD method should not have a body. If so, it must be ignored\n            return false;\n        } else {\n            return isReturnTypeDecodable(decodeData);\n        }\n    }\n\n    /**\n     * @return the decoded type used to decode the response body, null if the body is not decodable.\n     */\n    static Type decodedType(HttpResponse httpResponse, HttpResponseDecodeData decodeData) {\n        ensureRequestSet(httpResponse);\n        //\n        if (isErrorStatus(httpResponse, decodeData)) {\n            // For error cases we always try to decode the non-empty response body\n            // either to a strongly typed exception model or to Object\n            return decodeData.getUnexpectedException(httpResponse.getStatusCode()).getExceptionBodyType();\n        } else if (httpResponse.getRequest().getHttpMethod() == HttpMethod.HEAD) {\n            // RFC: A response to a HEAD method should not have a body. If so, it must be ignored\n            return null;\n        } else if (!isReturnTypeDecodable(decodeData)) {\n            return null;\n        } else {\n            return extractEntityTypeFromReturnType(decodeData);\n        }\n    }\n\n    /**\n     * Checks the response status code is considered as error.\n     *\n     * @param httpResponse the response to check\n     * @param decodeData the response metadata\n     * @return true if the response status code is considered as error, false otherwise.\n     */\n    static boolean isErrorStatus(HttpResponse httpResponse, HttpResponseDecodeData decodeData) {\n        final int[] expectedStatuses = decodeData.getExpectedStatusCodes();\n        if (expectedStatuses != null) {\n            return !contains(expectedStatuses, httpResponse.getStatusCode());\n        } else {\n            return httpResponse.getStatusCode() / 100 != 2;\n        }\n    }\n\n    /**\n     * Deserialize the given string value representing content of a REST API response.\n     *\n     * If the {@link ReturnValueWireType} is of type {@link Page}, then the returned object will be an instance of that\n     * {@param wireType}. Otherwise, the returned object is converted back to its {@param resultType}.\n     *\n     * @param value the string value to deserialize\n     * @param resultType the return type of the java proxy method\n     * @param wireType value of optional {@link ReturnValueWireType} annotation present in java proxy method\n     *     indicating 'entity type' (wireType) of REST API wire response body\n     * @param encoding the encoding format of value\n     * @return Deserialized object\n     * @throws IOException When the body cannot be deserialized\n     */\n    private static Object deserializeBody(String value, Type resultType, Type wireType, SerializerAdapter serializer,\n                                          SerializerEncoding encoding) throws IOException {\n        if (wireType == null) {\n            return serializer.deserialize(value, resultType, encoding);\n        } else if (TypeUtil.isTypeOrSubTypeOf(wireType, Page.class)) {\n            return deserializePage(value, resultType, wireType, serializer, encoding);\n        } else {\n            final Type wireResponseType = constructWireResponseType(resultType, wireType);\n            final Object wireResponse = serializer.deserialize(value, wireResponseType, encoding);\n\n            return convertToResultType(wireResponse, resultType, wireType);\n        }\n    }\n\n    /**\n     * Given:\n     * (1). the {@code java.lang.reflect.Type} (resultType) of java proxy method return value\n     * (2). and {@link ReturnValueWireType} annotation value indicating 'entity type' (wireType)\n     * of same REST API's wire response body\n     * this method construct 'response body Type'.\n     *\n     * Note: When {@link ReturnValueWireType} annotation is applied to a proxy method, then the raw\n     * HTTP response content will need to parsed using the derived 'response body Type' then converted\n     * to actual {@code returnType}.\n     *\n     * @param resultType the {@code java.lang.reflect.Type} of java proxy method return value\n     * @param wireType the {@code java.lang.reflect.Type} of entity in REST API response body\n     * @return the {@code java.lang.reflect.Type} of REST API response body\n     */\n    private static Type constructWireResponseType(Type resultType, Type wireType) {\n        Objects.requireNonNull(resultType);\n        Objects.requireNonNull(wireType);\n        //\n        Type wireResponseType = resultType;\n\n        if (resultType == byte[].class) {\n            if (wireType == Base64Url.class) {\n                wireResponseType = Base64Url.class;\n            }\n        } else if (resultType == OffsetDateTime.class) {\n            if (wireType == DateTimeRfc1123.class) {\n                wireResponseType = DateTimeRfc1123.class;\n            } else if (wireType == UnixTime.class) {\n                wireResponseType = UnixTime.class;\n            }\n        } else {\n            if (TypeUtil.isTypeOrSubTypeOf(resultType, List.class)) {\n                final Type resultElementType = TypeUtil.getTypeArgument(resultType);\n                final Type wireResponseElementType = constructWireResponseType(resultElementType, wireType);\n\n                wireResponseType = TypeUtil.createParameterizedType(\n                    (Class<?>) ((ParameterizedType) resultType).getRawType(), wireResponseElementType);\n            } else if (TypeUtil.isTypeOrSubTypeOf(resultType, Map.class) || TypeUtil.isTypeOrSubTypeOf(resultType,\n                Response.class)) {\n                Type[] typeArguments = TypeUtil.getTypeArguments(resultType);\n                final Type resultValueType = typeArguments[1];\n                final Type wireResponseValueType = constructWireResponseType(resultValueType, wireType);\n\n                wireResponseType = TypeUtil.createParameterizedType(\n                    (Class<?>) ((ParameterizedType) resultType).getRawType(), typeArguments[0], wireResponseValueType);\n            }\n        }\n        return wireResponseType;\n    }\n\n    /**\n     * Deserializes a response body as a Page&lt;T&gt; given that {@param wireType} is either:\n     * 1. A type that implements the interface\n     * 2. Is of {@link Page}\n     *\n     * @param value The string to deserialize\n     * @param resultType The type T, of the page contents.\n     * @param wireType The {@link Type} that either is, or implements {@link Page}\n     * @param serializer The serializer used to deserialize the value.\n     * @param encoding Encoding used to deserialize string\n     * @return An object representing an instance of {@param wireType}\n     * @throws IOException if the serializer is unable to deserialize the value.\n     */\n    private static Object deserializePage(String value, Type resultType, Type wireType, SerializerAdapter serializer,\n                                          SerializerEncoding encoding) throws IOException {\n        final Type wireResponseType;\n\n        if (wireType == Page.class) {\n            // If the type is the 'Page' interface [i.e. `@ReturnValueWireType(Page.class)`], we will use the\n            // 'ItemPage' class instead.\n            wireResponseType = TypeUtil.createParameterizedType(ItemPage.class, resultType);\n        } else {\n            wireResponseType = wireType;\n        }\n\n        return serializer.deserialize(value, wireResponseType, encoding);\n    }\n\n    /**\n     * Converts the object {@code wireResponse} that was deserialized using 'response body Type'\n     * (produced by {@code constructWireResponseType(args)} method) to resultType.\n     *\n     * @param wireResponse the object to convert\n     * @param resultType the {@code java.lang.reflect.Type} to convert wireResponse to\n     * @param wireType the {@code java.lang.reflect.Type} of the wireResponse\n     * @return converted object\n     */\n    private static Object convertToResultType(Object wireResponse, Type resultType, Type wireType) {\n        Object result = wireResponse;\n\n        if (wireResponse != null) {\n            if (resultType == byte[].class) {\n                if (wireType == Base64Url.class) {\n                    result = ((Base64Url) wireResponse).decodedBytes();\n                }\n            } else if (resultType == OffsetDateTime.class) {\n                if (wireType == DateTimeRfc1123.class) {\n                    result = ((DateTimeRfc1123) wireResponse).getDateTime();\n                } else if (wireType == UnixTime.class) {\n                    result = ((UnixTime) wireResponse).getDateTime();\n                }\n            } else {\n                if (TypeUtil.isTypeOrSubTypeOf(resultType, List.class)) {\n                    final Type resultElementType = TypeUtil.getTypeArgument(resultType);\n\n                    @SuppressWarnings(\"unchecked\") final List<Object> wireResponseList = (List<Object>) wireResponse;\n\n                    final int wireResponseListSize = wireResponseList.size();\n                    for (int i = 0; i < wireResponseListSize; ++i) {\n                        final Object wireResponseElement = wireResponseList.get(i);\n                        final Object resultElement =\n                            convertToResultType(wireResponseElement, resultElementType, wireType);\n                        if (wireResponseElement != resultElement) {\n                            wireResponseList.set(i, resultElement);\n                        }\n                    }\n                    //\n                    result = wireResponseList;\n                } else if (TypeUtil.isTypeOrSubTypeOf(resultType, Map.class)) {\n                    final Type resultValueType = TypeUtil.getTypeArguments(resultType)[1];\n\n                    @SuppressWarnings(\"unchecked\") final Map<String, Object> wireResponseMap =\n                        (Map<String, Object>) wireResponse;\n\n                    final Set<Map.Entry<String, Object>> wireResponseEntries = wireResponseMap.entrySet();\n                    for (Map.Entry<String, Object> wireResponseEntry : wireResponseEntries) {\n                        final Object wireResponseValue = wireResponseEntry.getValue();\n                        final Object resultValue = convertToResultType(wireResponseValue, resultValueType, wireType);\n                        if (wireResponseValue != resultValue) {\n                            wireResponseMap.put(wireResponseEntry.getKey(), resultValue);\n                        }\n                    }\n                    //\n                    result = wireResponseMap;\n                } else if (TypeUtil.isTypeOrSubTypeOf(resultType, PagedResponseBase.class)) {\n                    PagedResponseBase<?, ?> restResponse = (PagedResponseBase<?, ?>) wireResponse;\n                    result =\n                        new PagedResponseBase<>(restResponse.getRequest(), restResponse.getStatusCode(),\n                            restResponse.getHeaders(), restResponse.getItems(), restResponse.getContinuationToken(),\n                            restResponse.getDeserializedHeaders());\n                } else if (TypeUtil.isTypeOrSubTypeOf(resultType, ResponseBase.class)) {\n                    ResponseBase<?, ?> restResponseBase = (ResponseBase<?, ?>) wireResponse;\n                    Object wireResponseBody = restResponseBase.getValue();\n\n                    // TODO: anuchan - RestProxy is always in charge of creating RestResponseBase--so this doesn't\n                    //  seem right\n                    Object resultBody =\n                        convertToResultType(wireResponseBody, TypeUtil.getTypeArguments(resultType)[1], wireType);\n                    if (wireResponseBody != resultBody) {\n                        result =\n                            new ResponseBase<>(restResponseBase.getRequest(), restResponseBase.getStatusCode(),\n                                restResponseBase.getHeaders(), resultBody, restResponseBase.getDeserializedHeaders());\n                    } else {\n                        result = restResponseBase;\n                    }\n                } else if (TypeUtil.isTypeOrSubTypeOf(resultType, Response.class)) {\n                    Response<?> restResponse = (Response<?>) wireResponse;\n                    Object wireResponseBody = restResponse.getValue();\n\n                    // TODO: anuchan - RestProxy is always in charge of creating RestResponseBase--so this doesn't\n                    //  seem right\n                    Object resultBody =\n                        convertToResultType(wireResponseBody, TypeUtil.getTypeArguments(resultType)[1], wireType);\n                    if (wireResponseBody != resultBody) {\n                        result =\n                            new SimpleResponse<>(restResponse.getRequest(), restResponse.getStatusCode(),\n                                restResponse.getHeaders(), resultBody);\n                    } else {\n                        result = restResponse;\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Get the {@link Type} of the REST API 'returned entity'.\n     *\n     * In the declaration of a java proxy method corresponding to the REST API, the 'returned entity' can be:\n     *\n     * 1. emission value of the reactor publisher returned by proxy method\n     *\n     * e.g. {@code Mono<Foo> getFoo(args);}\n     * {@code Flux<Foo> getFoos(args);}\n     * where Foo is the REST API 'returned entity'.\n     *\n     * 2. OR content (value) of {@link ResponseBase} emitted by the reactor publisher returned from proxy method\n     *\n     * e.g. {@code Mono<RestResponseBase<headers, Foo>> getFoo(args);}\n     * {@code Flux<RestResponseBase<headers, Foo>> getFoos(args);}\n     * where Foo is the REST API return entity.\n     *\n     * @return the entity type.\n     */\n    private static Type extractEntityTypeFromReturnType(HttpResponseDecodeData decodeData) {\n        Type token = decodeData.getReturnType();\n        final ClientLogger logger = new ClientLogger(HttpResponseBodyDecoder.class);\n        if (token != null) {\n            if (TypeUtil.isTypeOrSubTypeOf(token, Mono.class)) {\n                token = TypeUtil.getTypeArgument(token);\n            } else if (TypeUtil.isTypeOrSubTypeOf(token, Flux.class)) {\n                Type t = TypeUtil.getTypeArgument(token);\n                try {\n                    // TODO: anuchan - unwrap OperationStatus a different way\n                    // Check for OperationStatus<?>\n                    if (TypeUtil.isTypeOrSubTypeOf(t, Class.forName(\n                        \"com.azure.core.management.implementation.OperationStatus\"))) {\n                        token = t;\n                    }\n                } catch (ClassNotFoundException ignored) {\n                    logger.warning(\"Failed to find class 'com.azure.core.management.implementation.OperationStatus'.\");\n                }\n            }\n\n            if (TypeUtil.isTypeOrSubTypeOf(token, Response.class)) {\n                token = TypeUtil.getRestResponseBodyType(token);\n            }\n\n            try {\n                // TODO: anuchan - unwrap OperationStatus a different way\n                if (TypeUtil.isTypeOrSubTypeOf(token, Class.forName(\n                    \"com.azure.core.management.implementation.OperationStatus\"))) {\n                    // Get Type of 'T' from OperationStatus<T>\n                    token = TypeUtil.getTypeArgument(token);\n                }\n            } catch (ClassNotFoundException ignored) {\n                logger.warning(\"Failed to find class 'com.azure.core.management.implementation.OperationStatus'.\");\n            }\n        }\n        return token;\n    }\n\n    /**\n     * Checks the return type represents a decodable type.\n     *\n     * @param decodeData the decode metadata\n     * @return true if decodable, false otherwise.\n     */\n    private static boolean isReturnTypeDecodable(HttpResponseDecodeData decodeData) {\n        Type returnType = decodeData.getReturnType();\n        if (returnType == null) {\n            return false;\n        }\n\n        // Unwrap from Mono\n        if (TypeUtil.isTypeOrSubTypeOf(returnType, Mono.class)) {\n            returnType = TypeUtil.getTypeArgument(returnType);\n        }\n\n        // Find body for complex responses\n        if (TypeUtil.isTypeOrSubTypeOf(returnType, ResponseBase.class)) {\n            ParameterizedType parameterizedType =\n                (ParameterizedType) TypeUtil.getSuperType(returnType, ResponseBase.class);\n            if (parameterizedType.getActualTypeArguments().length == 2) {\n                // check body type\n                returnType = parameterizedType.getActualTypeArguments()[1];\n            }\n        }\n\n        return !FluxUtil.isFluxByteBuffer(returnType)\n                && !TypeUtil.isTypeOrSubTypeOf(returnType, byte[].class)\n                && !TypeUtil.isTypeOrSubTypeOf(returnType, Void.TYPE)\n                && !TypeUtil.isTypeOrSubTypeOf(returnType, Void.class);\n    }\n\n    /**\n     * Checks an given value exists in an array.\n     *\n     * @param values array of ints\n     * @param searchValue value to check for existence\n     * @return true if value exists in the array, false otherwise\n     */\n    private static boolean contains(int[] values, int searchValue) {\n        Objects.requireNonNull(values);\n        for (int value : values) {\n            if (searchValue == value) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Ensure that request property and method is set in the response.\n     *\n     * @param httpResponse the response to validate\n     * @return the validated response\n     */\n    private static HttpResponse ensureRequestSet(HttpResponse httpResponse) {\n        Objects.requireNonNull(httpResponse.getRequest());\n        Objects.requireNonNull(httpResponse.getRequest().getHttpMethod());\n        return httpResponse;\n    }\n}\n\n", "Object json);\n}\n", " org.springframework.stereotype.Component;\r\n\r\nimport com.budget.service.IDepenseService;\r\nimport com.budget.service.IEntreeService;\r\nimport com.budget.service.ISalaireService;\r\n\r\n@Component(\"facade\")\r\npublic class FacadeImpl implements Facade {\r\n\r\n\t@Autowired\r\n\tprivate ISalaireService salaireService;\r\n\t\r\n\t@Autowired\r\n\tprivate IEntreeService entreeService;\r\n\t\r\n\t@Autowired\r\n\tprivate IDepenseService depenseService;\r\n\t\r\n\t@Override\r\n\tpublic ISalaireService getSalaireService() {\r\n\t\treturn salaireService;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IDepenseService getDepenseService() {\r\n\t\treturn depenseService;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic IEntreeService getEntreeService() {\r\n\t\treturn entreeService;\r\n\t}\r\n\r\n}\r\n", "ringWriter;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport org.geometrycommands.SymDifferenceCommand.SymDifferenceOptions;\n\n/**\n * The SymDifferenceCommand UnitTest\n * @author Jared Erickson\n */\npublic class SymDifferenceCommandTest extends BaseTest {\n\n    @Test\n    public void execute() throws Exception {\n\n        String inputGeometry = \"POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))\";\n        String otherGeometry = \"POLYGON ((5 5, 5 20, 20 20, 20 5, 5 5))\";\n        SymDifferenceOptions options = new SymDifferenceOptions();\n        options.setGeometry(inputGeometry);\n        options.setOtherGeometry(otherGeometry);\n\n        Reader reader = new StringReader(inputGeometry);\n        StringWriter writer = new StringWriter();\n\n        SymDifferenceCommand command = new SymDifferenceCommand();\n        command.execute(options, reader, writer);\n        assertEquals(\"MULTIPOLYGON (((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0)), \"\n                + \"((10 5, 10 10, 5 10, 5 20, 20 20, 20 5, 10 5)))\",\n                writer.getBuffer().toString());\n    }\n\n    @Test\n    public void run() throws Exception {\n\n        String inputGeometry = \"POLYGON ((0 0, 0 10, 10 10, 10 0, 0 0))\";\n        String otherGeometry = \"POLYGON ((5 5, 5 20, 20 20, 20 5, 5 5))\";\n        String resultGeometry = \"MULTIPOLYGON (((0 0, 0 10, 5 10, 5 5, 10 5, 10 0, 0 0)), \"\n                + \"((10 5, 10 10, 5 10, 5 20, 20 20, 20 5, 10 5)))\";\n\n        // Geometry from options\n        String result = runApp(new String[]{\n                \"symdifference\",\n                \"-g\", inputGeometry,\n                \"-o\", otherGeometry\n        }, null);\n        assertEquals(resultGeometry, result);\n\n        // Geometry from input stream\n        result = runApp(new String[]{\n                \"symdifference\",\n                \"-o\", otherGeometry\n        }, inputGeometry);\n        assertEquals(resultGeometry, result);\n    }\n}\n", "m.badlogic.gdx.graphics.g2d.TextureRegion;\nimport com.badlogic.gdx.physics.box2d.Body;\nimport com.spiritatlas.flourishblade.util.SpriteAnimation;\nimport com.spiritatlas.flourishblade.views.EntityView;\nimport com.spiritatlas.flourishblade.views.ViewWalking;\n\npublic class PlayerEntity extends Entity {\n    protected final EntityView view;\n\n    public static final String cSpritesheetKey = \"CharacterSpritesheet\";\n\n    private boolean disposed = false;\n\n    public PlayerEntity(Body body, EntityView view) {\n        super(body);\n        this.view = view;\n    }\n\n    public EntityView getView() {\n        return view;\n    }\n\n    public static EntityView createView(Texture tex) {\n        SpriteAnimation walkingDown = new SpriteAnimation(tex,\n                new float[]{0.08f, 0.08f, 0.08f, 0.08f}, 0.08f * 4.0f, new TextureRegion[]{\n                new TextureRegion(tex, 32, 0, 32, 32), new TextureRegion(tex, 64, 0, 32, 32),\n                new TextureRegion(tex, 32, 0, 32, 32), new TextureRegion(tex, 0, 0, 32, 32)}, \"walkingDown\"\n        );\n        SpriteAnimation walkingLeft = new SpriteAnimation(tex,\n                new float[]{0.08f, 0.08f, 0.08f, 0.08f}, 0.08f * 4.0f, new TextureRegion[]{\n                new TextureRegion(tex, 32, 32, 32, 32), new TextureRegion(tex, 64, 32, 32, 32),\n                new TextureRegion(tex, 0, 32, 32, 32), new TextureRegion(tex, 32, 32, 32, 32)}, \"walkingLeft\"\n        );\n        SpriteAnimation walkingRight = new SpriteAnimation(tex,\n                new float[]{0.08f, 0.08f, 0.08f, 0.08f}, 0.08f * 4.0f, new TextureRegion[]{\n                new TextureRegion(tex, 32, 64, 32, 32), new TextureRegion(tex, 64, 64, 32, 32),\n                new TextureRegion(tex, 32, 64, 32, 32), new TextureRegion(tex, 0, 64, 32, 32)}, \"walkingRight\"\n        );\n\n        SpriteAnimation walkingUp = new SpriteAnimation(tex,\n                new float[]{0.08f, 0.08f, 0.08f, 0.08f}, 0.08f * 4.0f, new TextureRegion[]{\n                new TextureRegion(tex, 32, 96, 32, 32), new TextureRegion(tex, 64, 96, 32, 32),\n                new TextureRegion(tex, 32, 96, 32, 32), new TextureRegion(tex, 0, 96, 32, 32)}, \"walkingUp\"\n        );\n        return new ViewWalking(1f, 0f, 0.2f, new SpriteAnimation[]{walkingRight, walkingUp, walkingLeft, walkingDown});\n    }\n}\n", "apphire Compiler (sc).\n */\npackage sapphire.policy.stubs;\n\n\npublic final class CacheLeasePolicy$CacheLeaseServerPolicy_Stub extends sapphire.policy.cache.CacheLeasePolicy.CacheLeaseServerPolicy implements sapphire.kernel.common.KernelObjectStub {\n\n    sapphire.kernel.common.KernelOID $__oid = null;\n    java.net.InetSocketAddress $__hostname = null;\n\n    public CacheLeasePolicy$CacheLeaseServerPolicy_Stub(sapphire.kernel.common.KernelOID oid) {\n        this.$__oid = oid;\n    }\n\n    public sapphire.kernel.common.KernelOID $__getKernelOID() {\n        return this.$__oid;\n    }\n\n    public java.net.InetSocketAddress $__getHostname() {\n        return this.$__hostname;\n    }\n\n    public void $__updateHostname(java.net.InetSocketAddress hostname) {\n        this.$__hostname = hostname;\n    }\n\n    public Object $__makeKernelRPC(java.lang.String method, java.util.ArrayList<Object> params) throws java.rmi.RemoteException, java.lang.Exception {\n        sapphire.kernel.common.KernelRPC rpc = new sapphire.kernel.common.KernelRPC($__oid, method, params);\n        try {\n            return sapphire.kernel.common.GlobalKernelReferences.nodeServer.getKernelClient().makeKernelRPC(this, rpc);\n        } catch (sapphire.kernel.common.KernelObjectNotFoundException e) {\n            throw new java.rmi.RemoteException();\n        }\n    }\n\n    @Override\n    public boolean equals(Object obj) { \n        CacheLeasePolicy$CacheLeaseServerPolicy_Stub other = (CacheLeasePolicy$CacheLeaseServerPolicy_Stub) obj;\n        if (! other.$__oid.equals($__oid))\n            return false;\n        return true;\n    }\n    @Override\n    public int hashCode() { \n        return $__oid.getID();\n    }\n\n\n    // Implementation of syncObject(Integer, Serializable)\n    public void syncObject(java.lang.Integer $param_Integer_1, java.io.Serializable $param_Serializable_2) {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public void sapphire.policy.cache.CacheLeasePolicy$CacheLeaseServerPolicy.syncObject(java.lang.Integer,java.io.Serializable)\";\n        $__params.add($param_Integer_1);\n        $__params.add($param_Serializable_2);\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Implementation of onRPC(String, ArrayList)\n    public java.lang.Object onRPC(java.lang.String $param_String_1, java.util.ArrayList $param_ArrayList_2)\n            throws java.lang.Exception {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public java.lang.Object sapphire.policy.DefaultSapphirePolicyUpcallImpl$DefaultSapphireServerPolicyUpcallImpl.onRPC(java.lang.String,java.util.ArrayList<java.lang.Object>) throws java.lang.Exception\";\n        $__params.add($param_String_1);\n        $__params.add($param_ArrayList_2);\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return $__result;\n    }\n\n    // Implementation of onMembershipChange()\n    public void onMembershipChange() {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public void sapphire.policy.cache.CacheLeasePolicy$CacheLeaseServerPolicy.onMembershipChange()\";\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Implementation of onCreate(SapphirePolicy.SapphireGroupPolicy)\n    public void onCreate(sapphire.policy.SapphirePolicy.SapphireGroupPolicy $param_SapphirePolicy$SapphireGroupPolicy_1) {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public void sapphire.policy.cache.CacheLeasePolicy$CacheLeaseServerPolicy.onCreate(sapphire.policy.SapphirePolicy$SapphireGroupPolicy)\";\n        $__params.add($param_SapphirePolicy$SapphireGroupPolicy_1);\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n    }\n\n    // Implementation of getLease(Integer)\n    public sapphire.policy.cache.CacheLeasePolicy.CacheLease getLease(java.lang.Integer $param_Integer_1)\n            throws java.lang.Exception {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public sapphire.policy.cache.CacheLeasePolicy$CacheLease sapphire.policy.cache.CacheLeasePolicy$CacheLeaseServerPolicy.getLease(java.lang.Integer) throws java.lang.Exception\";\n        $__params.add($param_Integer_1);\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ((sapphire.policy.cache.CacheLeasePolicy.CacheLease) $__result);\n    }\n\n    // Implementation of getLease()\n    public sapphire.policy.cache.CacheLeasePolicy.CacheLease getLease()\n            throws java.lang.Exception {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public sapphire.policy.cache.CacheLeasePolicy$CacheLease sapphire.policy.cache.CacheLeasePolicy$CacheLeaseServerPolicy.getLease() throws java.lang.Exception\";\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ((sapphire.policy.cache.CacheLeasePolicy.CacheLease) $__result);\n    }\n\n    // Implementation of getGroup()\n    public sapphire.policy.SapphirePolicy.SapphireGroupPolicy getGroup() {\n        java.util.ArrayList<Object> $__params = new java.util.ArrayList<Object>();\n        String $__method = \"public sapphire.policy.SapphirePolicy$SapphireGroupPolicy sapphire.policy.cache.CacheLeasePolicy$CacheLeaseServerPolicy.getGroup()\";\n        java.lang.Object $__result = null;\n        try {\n            $__result = $__makeKernelRPC($__method, $__params);\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return ((sapphire.policy.SapphirePolicy.SapphireGroupPolicy) $__result);\n    }\n}\n", "8 Evgeny Pakhomov <eugene.pakhomov@ubitricity.com>\n\n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in all\n copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n SOFTWARE.\n*/\n\nimport java.io.IOException;\nimport java.net.InetSocketAddress;\nimport java.net.Proxy;\nimport java.net.Socket;\nimport java.net.URI;\nimport javax.net.ssl.SSLSocketFactory;\n\n/** Base implementation of WssSocketBuilder. */\npublic class BaseWssSocketBuilder implements WssSocketBuilder {\n\n  public static final int DEFAULT_WSS_PORT = 443;\n  private Proxy proxy = Proxy.NO_PROXY;\n  private SocketFactory socketFactory = Socket::new;\n  private SSLSocketFactory sslSocketFactory;\n  private boolean tcpNoDelay;\n  private boolean reuseAddr;\n  private boolean autoClose = true;\n  private URI uri;\n  private InetSocketAddressFactory inetSocketAddressFactory =\n      (host, port) -> new InetSocketAddress(host, port);\n\n  // 0 for infinite timeout\n  private int connectionTimeout = 0;\n\n  private BaseWssSocketBuilder() {}\n\n  public static BaseWssSocketBuilder builder() {\n    return new BaseWssSocketBuilder();\n  }\n\n  public BaseWssSocketBuilder proxy(Proxy proxy) {\n    this.proxy = proxy;\n    return this;\n  }\n\n  public BaseWssSocketBuilder sslSocketFactory(SSLSocketFactory sslSocketFactory) {\n    this.sslSocketFactory = sslSocketFactory;\n    return this;\n  }\n\n  public BaseWssSocketBuilder socketFactory(SocketFactory socketFactory) {\n    this.socketFactory = socketFactory;\n    return this;\n  }\n\n  public BaseWssSocketBuilder inetSocketAddressFactory(\n      InetSocketAddressFactory inetSocketAddressFactory) {\n    this.inetSocketAddressFactory = inetSocketAddressFactory;\n    return this;\n  }\n\n  public BaseWssSocketBuilder tcpNoDelay(boolean tcpNoDelay) {\n    this.tcpNoDelay = tcpNoDelay;\n    return this;\n  }\n\n  public BaseWssSocketBuilder reuseAddr(boolean reuseAddr) {\n    this.reuseAddr = reuseAddr;\n    return this;\n  }\n\n  public BaseWssSocketBuilder autoClose(boolean autoClose) {\n    this.autoClose = autoClose;\n    return this;\n  }\n\n  @Override\n  public BaseWssSocketBuilder uri(URI uri) {\n    this.uri = uri;\n    return this;\n  }\n\n  public BaseWssSocketBuilder connectionTimeout(int connectionTimeout) {\n    this.connectionTimeout = connectionTimeout;\n    return this;\n  }\n\n  @Override\n  public Socket build() throws IOException {\n    verify(true);\n\n    Socket socket = socketFactory.getSocket(proxy);\n    socket.setTcpNoDelay(tcpNoDelay);\n    socket.setReuseAddress(reuseAddr);\n\n    if (!socket.isBound()) {\n      socket.connect(\n          inetSocketAddressFactory.getInetSocketAddress(uri.getHost(), getPort(uri)),\n          connectionTimeout);\n    }\n\n    return sslSocketFactory.createSocket(socket, uri.getHost(), getPort(uri), autoClose);\n  }\n\n  @Override\n  public void verify() {\n    verify(false);\n  }\n\n  public interface SocketFactory {\n    Socket getSocket(Proxy proxy);\n  }\n\n  public interface InetSocketAddressFactory {\n    InetSocketAddress getInetSocketAddress(String host, int port);\n  }\n\n  private void verify(boolean complete) {\n    if (sslSocketFactory == null) {\n      throw new IllegalStateException(\"sslSocketFactory must be set\");\n    }\n\n    if (complete) {\n      if (uri == null) {\n        throw new IllegalStateException(\"uri must be set\");\n      }\n    }\n  }\n\n  private int getPort(URI uri) {\n    int port = uri.getPort();\n    if (port == -1) {\n      String scheme = uri.getScheme();\n      if (\"wss\".equals(scheme)) {\n        return DEFAULT_WSS_PORT;\n      } else if (\"ws\".equals(scheme)) {\n        throw new IllegalArgumentException(\"Not supported scheme: \" + scheme);\n      } else {\n        throw new IllegalArgumentException(\"Unknown scheme: \" + scheme);\n      }\n    }\n    return port;\n  }\n}\n", "domisum.exziff.map.transformer.Transformer;\n\npublic class BooleanMapInvert implements Transformer<BooleanMap>\n{\n\n\t// TRANSFORMATION\n\t@Override\n\tpublic BooleanMap transform(BooleanMap input)\n\t{\n\t\tboolean[][] pixels = new boolean[input.getHeight()][input.getWidth()];\n\n\t\tfor(int y = 0; y < input.getHeight(); y++)\n\t\t\tfor(int x = 0; x < input.getWidth(); x++)\n\t\t\t\tpixels[y][x] = !input.get(x, y);\n\n\t\treturn new BooleanMap(pixels);\n\t}\n\n}\n", "10-2017. Lapinin \"lastrix\" Sergey.                          /\n//                                                                             /\n// Permission is hereby granted, free of charge, to any person                 /\n// obtaining a copy of this software and associated documentation              /\n// files (the \"Software\"), to deal in the Software without                     /\n// restriction, including without limitation the rights to use,                /\n// copy, modify, merge, publish, distribute, sublicense, and/or                /\n// sell copies of the Software, and to permit persons to whom the              /\n// Software is furnished to do so, subject to the following                    /\n// conditions:                                                                 /\n//                                                                             /\n// The above copyright notice and this permission notice shall be              /\n// included in all copies or substantial portions of the Software.             /\n//                                                                             /\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,             /\n// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES             /\n// OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                    /\n// NON INFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT                /\n// HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,                /\n// WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING                /\n// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE                  /\n// OR OTHER DEALINGS IN THE SOFTWARE.                                          /\n////////////////////////////////////////////////////////////////////////////////\n\npackage org.asn1s.io.ber.output;\n\nimport org.asn1s.api.Asn1Factory;\nimport org.asn1s.api.Ref;\nimport org.asn1s.api.Scope;\nimport org.asn1s.api.UniversalType;\nimport org.asn1s.api.constraint.ConstraintTemplate;\nimport org.asn1s.api.encoding.tag.TagClass;\nimport org.asn1s.api.encoding.tag.TagEncoding;\nimport org.asn1s.api.encoding.tag.TagMethod;\nimport org.asn1s.api.module.Module;\nimport org.asn1s.api.type.CollectionType;\nimport org.asn1s.api.type.ComponentType.Kind;\nimport org.asn1s.api.type.DefinedType;\nimport org.asn1s.api.type.Type;\nimport org.asn1s.api.type.Type.Family;\nimport org.asn1s.api.type.TypeFactory;\nimport org.asn1s.api.value.Value;\nimport org.asn1s.api.value.x680.ValueCollection;\nimport org.asn1s.core.DefaultAsn1Factory;\nimport org.asn1s.core.type.CoreTypeFactory;\nimport org.asn1s.core.value.CoreValueFactory;\nimport org.asn1s.core.value.x680.IntegerValueInt;\nimport org.asn1s.core.value.x680.RealValueBig;\nimport org.asn1s.core.value.x680.RealValueFloat;\nimport org.asn1s.io.Asn1Reader;\nimport org.asn1s.io.Asn1Writer;\nimport org.asn1s.io.ber.BerRules;\nimport org.asn1s.io.ber.input.DefaultBerReader;\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.math.BigDecimal;\nimport java.math.BigInteger;\n\npublic class DefaultBerWriterTest\n{\n\t@Test\n\tpublic void writeHugeReal() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\t\tScope scope = module.createScope();\n\n\t\tConstraintTemplate constraintTemplate = factory.constraints().valueRange( new RealValueFloat( 0.0f ), false, null, false );\n\t\tType tagged = factory.types().constrained( constraintTemplate, UniversalType.REAL.ref() );\n\t\tType defined = factory.types().define( \"MyReal\", tagged, null );\n\t\tmodule.validate();\n\t\tValue value = new RealValueBig( new BigDecimal( BigInteger.valueOf( 34645344 ).pow( 15636 ) ) );\n\t\ttry( Asn1Writer writer = new DefaultBerWriter( BerRules.DER ) )\n\t\t{\n\t\t\twriter.write( scope, defined, value );\n\t\t\tAssert.assertEquals( \"Arrays have different length\", 117900, writer.toByteArray().length );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testHugeTagNumber() throws Exception\n\t{\n\t\tTypeFactory factory = new CoreTypeFactory();\n\t\tModule module = factory.dummyModule();\n\t\tScope scope = module.createScope();\n\n\t\tType tagged = factory.tagged( TagEncoding.application( 2048 ), UniversalType.INTEGER.ref() );\n\t\tType defined = factory.define( \"MyTagged\", tagged, null );\n\t\tmodule.validate();\n\t\ttry( Asn1Writer writer = new DefaultBerWriter( BerRules.DER ) )\n\t\t{\n\t\t\twriter.write( scope, defined, new IntegerValueInt( 0 ) );\n\n\t\t\t//7F900003020100\n\t\t\tAssert.assertArrayEquals( \"\", new byte[]{0x7F, (byte)0x90, 0x00, 0x03, 0x02, 0x01, 0x00}, writer.toByteArray() );\n\t\t}\n\t}\n\n\t@Test( expected = IOException.class )\n\tpublic void testNonInternalOsFail() throws Exception\n\t{\n\t\tTypeFactory factory = new CoreTypeFactory();\n\t\tModule module = factory.dummyModule();\n\t\tScope scope = module.createScope();\n\n\t\ttry( ByteArrayOutputStream os = new ByteArrayOutputStream();\n\t\t     Asn1Writer writer = new DefaultBerWriter( BerRules.DER, os ) )\n\t\t{\n\t\t\twriter.write( scope, UniversalType.INTEGER.ref().resolve( scope ), new IntegerValueInt( 0 ) );\n\t\t\twriter.toByteArray();\n\t\t\tAssert.fail( \"Must fail!\" );\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testChoiceReadWrite() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\t\tScope scope = module.createScope();\n\n\t\tCollectionType choiceType = factory.types().collection( Family.CHOICE );\n\n\t\tCollectionType sequenceType = factory.types().collection( Family.SEQUENCE );\n\t\tsequenceType.addComponent( Kind.PRIMARY, \"a\", UniversalType.INTEGER.ref() );\n\t\tsequenceType.addComponent( Kind.PRIMARY, \"b\", UniversalType.REAL.ref() );\n\n\t\tchoiceType.addComponent( Kind.PRIMARY, \"seq\", sequenceType );\n\t\tchoiceType.addComponent( Kind.PRIMARY, \"b\", UniversalType.REAL.ref() );\n\n\t\tDefinedType type = factory.types().define( \"My-Choice\", choiceType, null );\n\t\tmodule.validate();\n\n\t\tValueCollection collection = factory.values().collection( true );\n\t\tcollection.addNamed( \"a\", factory.values().integer( 1 ) );\n\t\tcollection.addNamed( \"b\", factory.values().rZero() );\n\t\tValue value = factory.values().named( \"seq\", collection );\n\n\t\tperformReadTest( type.createScope(), \"Unable to read choice value\", type, value );\n\t}\n\n\n\t@Test\n\tpublic void testTaggedReadWrite() throws Exception\n\t{\n\t\tAsn1Factory factory = new DefaultAsn1Factory();\n\t\tModule module = factory.types().dummyModule();\n\t\tScope scope = module.createScope();\n\n\t\tRef<Type> type1 = factory.types().builtin( \"INTEGER\" );\n\n\t\tTagEncoding type2Encoding = TagEncoding.create( module.getTagMethod(), TagMethod.IMPLICIT, TagClass.APPLICATION, 3 );\n\t\tDefinedType type2 = factory.types().define( \"Type2\",\n\t\t                                            factory.types().tagged( type2Encoding, type1 ),\n\t\t                                            null );\n\n\t\tTagEncoding type3Encoding = TagEncoding.create( module.getTagMethod(), TagMethod.EXPLICIT, TagClass.CONTEXT_SPECIFIC, 2 );\n\n\t\tDefinedType type3 = factory.types().define( \"Type3\",\n\t\t                                            factory.types().tagged( type3Encoding, type2 ),\n\t\t                                            null );\n\n\t\tTagEncoding type4Encoding = TagEncoding.create( module.getTagMethod(), TagMethod.IMPLICIT, TagClass.APPLICATION, 7 );\n\n\t\tDefinedType type4 = factory.types().define( \"Type4\",\n\t\t                                            factory.types().tagged( type4Encoding, type3 ),\n\t\t                                            null );\n\n\t\tTagEncoding type5Encoding = TagEncoding.create( module.getTagMethod(), TagMethod.IMPLICIT, TagClass.CONTEXT_SPECIFIC, 2 );\n\n\t\tDefinedType type5 = factory.types().define( \"Type5\",\n\t\t                                            factory.types().tagged( type5Encoding, type2 ),\n\t\t                                            null );\n\n\t\tValue value = factory.values().integer( 100 );\n\n\t\tmodule.validate();\n\n\t\tperformReadTest( type2.createScope(), \"Encoding of [APPLICATION 3] IMPLICIT INTEGER failed\", type2, value );\n\t\tperformReadTest( type3.createScope(), \"Encoding of [2] type2 failed\", type3, value );\n\t\tperformReadTest( type4.createScope(), \"Encoding of [APPLICATION 7] IMPLICIT type3 failed\", type4, value );\n\t\tperformReadTest( type5.createScope(), \"Encoding of [2] IMPLICIT type2 failed\", type5, value );\n\t}\n\n\tprivate static void performReadTest( Scope scope, String message, Ref<Type> type, Value value ) throws Exception\n\t{\n\t\tbyte[] expected = writeValue( scope, type, value );\n\t\tValue iValue;\n\t\ttry( ByteArrayInputStream bis = new ByteArrayInputStream( expected );\n\t\t     Asn1Reader is = new DefaultBerReader( bis, new CoreValueFactory() ) )\n\t\t{\n\t\t\tiValue = is.read( scope, type );\n\t\t}\n\t\tbyte[] actual = writeValue( scope, type, iValue );\n\t\tAssert.assertArrayEquals( message, expected, actual );\n\t}\n\n\tprivate static byte[] writeValue( Scope scope, Ref<Type> type, Value value ) throws Exception\n\t{\n\t\tbyte[] result;\n\t\ttry( Asn1Writer writer = new DefaultBerWriter( BerRules.DER ) )\n\t\t{\n\t\t\twriter.write( scope, type, value );\n\t\t\tresult = writer.toByteArray();\n\t\t}\n\t\treturn result;\n\t}\n}\n", ".util.stream.Collectors;\n\n\npublic class Main {\n\n    public static final String INVALID_INPUT = \"Invalid input! The argument can only contain numbers.\";\n\n    public static void main(String... args) {\n        QuickSort quickSort = new QuickSort();\n        for (String arg : args) {\n            try {\n                String[] values = arg.split(\" \");\n                List<Integer> numbers = Arrays.stream(values).parallel().map(s -> Integer.parseInt(s))\n                        .collect(Collectors.toList());\n                List<Integer> sortedNumbers = quickSort.sort(numbers);\n                System.out.println(sortedNumbers.stream().map(Object::toString).collect(Collectors.joining(\" \")));\n            } catch (NumberFormatException e) {\n                System.err.println(INVALID_INPUT);\n            }\n        }\n    }\n\n}\n", " Locales: cs sk\n *\n * Languages:\n * - Czech (cs)\n * - Slovak (sk)\n *\n * Rules:\n * \tone \u2192 n is 1;\n * \tfew \u2192 n in 2..4;\n * \tother \u2192 everything else\n *\n * Reference CLDR Version 1.9 beta (2010-11-16 21:48:45 GMT)\n * @see http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\n * @see http://unicode.org/repos/cldr/trunk/common/supplemental/plurals.xml\n * @see plurals.xml (local copy)\n *\n * @package    I18n_Plural\n * @category   Plural Rules\n * @author     Korney Czukowski\n * @copyright  (c) 2011 Korney Czukowski\n * @license    MIT License\n */\n\n/**\n * Converted to Java by Sam Marshak, 2012 \n */\npublic class PluralRules_Czech extends PluralRules\n{\n\tpublic int quantityForNumber(int count)\n\t{\n\t\tif (count == 1)\n\t\t{\n\t\t\treturn QUANTITY_ONE;\n\t\t}\n\t\telse if (count >= 2 && count <= 4)\n\t\t{\n\t\t\treturn QUANTITY_FEW;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn QUANTITY_OTHER;\n\t\t}\n\t}\n}", "charset.StandardCharsets;\n\n/**\n * Created by ehernandez on 28/04/16.\n */\npublic class PageModel {\n\n    private final String title;\n\n    private final String body;\n\n    private final String urlTag;\n\n    public PageModel(File pageFile) throws ParsingFileException {\n        String content;\n        try{\n            content = Utils.readFile(pageFile.getPath(), StandardCharsets.UTF_8);\n        }catch(Exception ex)\n        {\n            throw new ParsingFileException(String.format(\"Error while reading file '%s': %s\", pageFile.getName(), ex.getMessage()));\n        }\n        //Parseando contenido\n        Pair<String, String> split = Utils.extractFirstLineFromString(content);\n        title = Utils.removeMarkdown(split.getKey());\n        body = Utils.formatMarkdownContent(split.getValue());\n        urlTag = \"urlTag\";\n    }\n\n    public String getBody() {\n        return body;\n    }\n\n\n    public String getUrlTag()\n    {\n        return urlTag;\n    }\n\n    public String getTitle()\n    {\n        return title;\n    }\n\n    @Override\n    public String toString() {\n        return getTitle();\n    }\n}\n", "reements. See the NOTICE file\r\n * distributed with this work for additional information\r\n * regarding copyright ownership. The ASF licenses this file\r\n * to you under the Apache License, Version 2.0 (the  \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *     http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n/*\r\n * $Id: FuncNormalizeSpace.java 468655 2006-10-28 07:12:06Z minchau $\r\n */\r\npackage org.apache.xpath.functions;\r\n\r\nimport org.apache.xml.dtm.DTM;\r\nimport org.apache.xml.utils.XMLString;\r\nimport org.apache.xpath.XPathContext;\r\nimport org.apache.xpath.objects.XObject;\r\nimport org.apache.xpath.objects.XString;\r\nimport org.xml.sax.ContentHandler;\r\n\r\n/**\r\n * Execute the normalize-space() function.\r\n * @xsl.usage advanced\r\n */\r\npublic class FuncNormalizeSpace extends FunctionDef1Arg\r\n{\r\n    static final long serialVersionUID = -3377956872032190880L;\r\n\r\n  /**\r\n   * Execute the function.  The function must return\r\n   * a valid object.\r\n   * @param xctxt The current execution context.\r\n   * @return A valid XObject.\r\n   *\r\n   * @throws javax.xml.transform.TransformerException\r\n   */\r\n  public XObject execute(XPathContext xctxt) throws javax.xml.transform.TransformerException\r\n  {\r\n    XMLString s1 = getArg0AsString(xctxt);\r\n\r\n    return (XString)s1.fixWhiteSpace(true, true, false);\r\n  }\r\n  \r\n  /**\r\n   * Execute an expression in the XPath runtime context, and return the \r\n   * result of the expression.\r\n   *\r\n   *\r\n   * @param xctxt The XPath runtime context.\r\n   *\r\n   * @return The result of the expression in the form of a <code>XObject</code>.\r\n   *\r\n   * @throws javax.xml.transform.TransformerException if a runtime exception \r\n   *         occurs.\r\n   */\r\n  public void executeCharsToContentHandler(XPathContext xctxt, \r\n                                              ContentHandler handler)\r\n    throws javax.xml.transform.TransformerException,\r\n           org.xml.sax.SAXException\r\n  {\r\n    if(Arg0IsNodesetExpr())\r\n    {\r\n      int node = getArg0AsNode(xctxt);\r\n      if(DTM.NULL != node)\r\n      {\r\n        DTM dtm = xctxt.getDTM(node);\r\n        dtm.dispatchCharactersEvents(node, handler, true);\r\n      }\r\n    }\r\n    else\r\n    {\r\n      XObject obj = execute(xctxt);\r\n      obj.dispatchCharactersEvents(handler);\r\n    }\r\n  }\r\n\r\n}\r\n", "of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage lombok.javac;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.PrintWriter;\nimport java.lang.reflect.Field;\nimport java.util.ArrayDeque;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.Queue;\n\nimport javax.lang.model.type.TypeKind;\nimport javax.tools.DiagnosticListener;\n\nimport com.sun.tools.javac.code.BoundKind;\nimport com.sun.tools.javac.code.Symbol.TypeSymbol;\nimport com.sun.tools.javac.code.Symtab;\nimport com.sun.tools.javac.code.Type;\nimport com.sun.tools.javac.code.Type.ArrayType;\nimport com.sun.tools.javac.code.Type.CapturedType;\nimport com.sun.tools.javac.code.Type.ClassType;\nimport com.sun.tools.javac.code.Type.WildcardType;\nimport com.sun.tools.javac.code.TypeTags;\nimport com.sun.tools.javac.code.Types;\nimport com.sun.tools.javac.comp.Attr;\nimport com.sun.tools.javac.comp.AttrContext;\nimport com.sun.tools.javac.comp.Enter;\nimport com.sun.tools.javac.comp.Env;\nimport com.sun.tools.javac.comp.MemberEnter;\nimport com.sun.tools.javac.tree.JCTree;\nimport com.sun.tools.javac.tree.JCTree.JCBlock;\nimport com.sun.tools.javac.tree.JCTree.JCClassDecl;\nimport com.sun.tools.javac.tree.JCTree.JCCompilationUnit;\nimport com.sun.tools.javac.tree.JCTree.JCExpression;\nimport com.sun.tools.javac.tree.JCTree.JCMethodDecl;\nimport com.sun.tools.javac.tree.JCTree.JCVariableDecl;\nimport com.sun.tools.javac.tree.TreeMaker;\nimport com.sun.tools.javac.util.Context;\nimport com.sun.tools.javac.util.List;\nimport com.sun.tools.javac.util.ListBuffer;\nimport com.sun.tools.javac.util.Log;\n\npublic class JavacResolution {\n\tprivate final Attr attr;\n\tprivate final LogDisabler logDisabler;\n\t\n\tpublic JavacResolution(Context context) {\n\t\tattr = Attr.instance(context);\n\t\tlogDisabler = new LogDisabler(context);\n\t}\n\t\n\t/**\n\t * During resolution, the resolver will emit resolution errors, but without appropriate file names and line numbers. If these resolution errors stick around\n\t * then they will be generated AGAIN, this time with proper names and line numbers, at the end. Therefore, we want to suppress the logger.\n\t */\n\tprivate static final class LogDisabler {\n\t\tprivate final Log log;\n\t\tprivate static final Field errWriterField, warnWriterField, noticeWriterField, dumpOnErrorField, promptOnErrorField, diagnosticListenerField;\n\t\tprivate static final Field deferDiagnosticsField, deferredDiagnosticsField;\n\t\tprivate PrintWriter errWriter, warnWriter, noticeWriter;\n\t\tprivate Boolean dumpOnError, promptOnError;\n\t\tprivate DiagnosticListener<?> contextDiagnosticListener, logDiagnosticListener;\n\t\tprivate final Context context;\n\t\t\n\t\t// If this is true, the fields changed. Better to print weird error messages than to fail outright.\n\t\tprivate static final boolean dontBother;\n\t\t\n\t\tprivate static final ThreadLocal<Queue<?>> queueCache = new ThreadLocal<Queue<?>>();\n\t\t\n\t\tstatic {\n\t\t\tboolean z;\n\t\t\tField a = null, b = null, c = null, d = null, e = null, f = null, g = null, h = null;\n\t\t\ttry {\n\t\t\t\ta = Log.class.getDeclaredField(\"errWriter\");\n\t\t\t\tb = Log.class.getDeclaredField(\"warnWriter\");\n\t\t\t\tc = Log.class.getDeclaredField(\"noticeWriter\");\n\t\t\t\td = Log.class.getDeclaredField(\"dumpOnError\");\n\t\t\t\te = Log.class.getDeclaredField(\"promptOnError\");\n\t\t\t\tf = Log.class.getDeclaredField(\"diagListener\");\n\t\t\t\tz = false;\n\t\t\t\ta.setAccessible(true);\n\t\t\t\tb.setAccessible(true);\n\t\t\t\tc.setAccessible(true);\n\t\t\t\td.setAccessible(true);\n\t\t\t\te.setAccessible(true);\n\t\t\t\tf.setAccessible(true);\n\t\t\t} catch (Exception x) {\n\t\t\t\tz = true;\n\t\t\t}\n\t\t\t\n\t\t\ttry {\n\t\t\t\tg = Log.class.getDeclaredField(\"deferDiagnostics\");\n\t\t\t\th = Log.class.getDeclaredField(\"deferredDiagnostics\");\n\t\t\t\tg.setAccessible(true);\n\t\t\t\th.setAccessible(true);\n\t\t\t} catch (Exception x) {\n\t\t\t}\n\t\t\t\n\t\t\terrWriterField = a;\n\t\t\twarnWriterField = b;\n\t\t\tnoticeWriterField = c;\n\t\t\tdumpOnErrorField = d;\n\t\t\tpromptOnErrorField = e;\n\t\t\tdiagnosticListenerField = f;\n\t\t\tdeferDiagnosticsField = g;\n\t\t\tdeferredDiagnosticsField = h;\n\t\t\tdontBother = z;\n\t\t}\n\t\t\n\t\tLogDisabler(Context context) {\n\t\t\tthis.log = Log.instance(context);\n\t\t\tthis.context = context;\n\t\t}\n\t\t\n\t\tboolean disableLoggers() {\n\t\t\tcontextDiagnosticListener = context.get(DiagnosticListener.class);\n\t\t\tcontext.put(DiagnosticListener.class, (DiagnosticListener<?>) null);\n\t\t\tif (dontBother) return false;\n\t\t\tboolean dontBotherInstance = false;\n\t\t\t\n\t\t\tPrintWriter dummyWriter = new PrintWriter(new OutputStream() {\n\t\t\t\t@Override public void write(int b) throws IOException {\n\t\t\t\t\t// Do nothing on purpose\n\t\t\t\t}\n\t\t\t});\n\t\t\t\n\t\t\tif (deferDiagnosticsField != null) try {\n\t\t\t\tif (Boolean.TRUE.equals(deferDiagnosticsField.get(log))) {\n\t\t\t\t\tqueueCache.set((Queue<?>) deferredDiagnosticsField.get(log));\n\t\t\t\t\tQueue<?> empty = new LinkedList<Object>();\n\t\t\t\t\tdeferredDiagnosticsField.set(log, empty);\n\t\t\t\t}\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (!dontBotherInstance) try {\n\t\t\t\terrWriter = (PrintWriter) errWriterField.get(log);\n\t\t\t\terrWriterField.set(log, dummyWriter);\n\t\t\t} catch (Exception e) {\n\t\t\t\tdontBotherInstance = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!dontBotherInstance) try {\n\t\t\t\twarnWriter = (PrintWriter) warnWriterField.get(log);\n\t\t\t\twarnWriterField.set(log, dummyWriter);\n\t\t\t} catch (Exception e) {\n\t\t\t\tdontBotherInstance = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!dontBotherInstance) try {\n\t\t\t\tnoticeWriter = (PrintWriter) noticeWriterField.get(log);\n\t\t\t\tnoticeWriterField.set(log, dummyWriter);\n\t\t\t} catch (Exception e) {\n\t\t\t\tdontBotherInstance = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!dontBotherInstance) try {\n\t\t\t\tdumpOnError = (Boolean) dumpOnErrorField.get(log);\n\t\t\t\tdumpOnErrorField.set(log, false);\n\t\t\t} catch (Exception e) {\n\t\t\t\tdontBotherInstance = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!dontBotherInstance) try {\n\t\t\t\tpromptOnError = (Boolean) promptOnErrorField.get(log);\n\t\t\t\tpromptOnErrorField.set(log, false);\n\t\t\t} catch (Exception e) {\n\t\t\t\tdontBotherInstance = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (!dontBotherInstance) try {\n\t\t\t\tlogDiagnosticListener = (DiagnosticListener<?>) diagnosticListenerField.get(log);\n\t\t\t\tdiagnosticListenerField.set(log, null);\n\t\t\t} catch (Exception e) {\n\t\t\t\tdontBotherInstance = true;\n\t\t\t}\n\t\t\t\n\t\t\tif (dontBotherInstance) enableLoggers();\n\t\t\treturn !dontBotherInstance;\n\t\t}\n\t\t\n\t\tvoid enableLoggers() {\n\t\t\tif (contextDiagnosticListener != null) {\n\t\t\t\tcontext.put(DiagnosticListener.class, contextDiagnosticListener);\n\t\t\t\tcontextDiagnosticListener = null;\n\t\t\t}\n\t\t\t\n\t\t\tif (errWriter != null) try {\n\t\t\t\terrWriterField.set(log, errWriter);\n\t\t\t\terrWriter = null;\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (warnWriter != null) try {\n\t\t\t\twarnWriterField.set(log, warnWriter);\n\t\t\t\twarnWriter = null;\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (noticeWriter != null) try {\n\t\t\t\tnoticeWriterField.set(log, noticeWriter);\n\t\t\t\tnoticeWriter = null;\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (dumpOnError != null) try {\n\t\t\t\tdumpOnErrorField.set(log, dumpOnError);\n\t\t\t\tdumpOnError = null;\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (promptOnError != null) try {\n\t\t\t\tpromptOnErrorField.set(log, promptOnError);\n\t\t\t\tpromptOnError = null;\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (logDiagnosticListener != null) try {\n\t\t\t\tdiagnosticListenerField.set(log, logDiagnosticListener);\n\t\t\t\tlogDiagnosticListener = null;\n\t\t\t} catch (Exception e) {}\n\t\t\t\n\t\t\tif (deferDiagnosticsField != null && queueCache.get() != null) try {\n\t\t\t\tdeferredDiagnosticsField.set(log, queueCache.get());\n\t\t\t\tqueueCache.set(null);\n\t\t\t} catch (Exception e) {}\n\t\t}\n\t}\n\t\n\t/*\n\t * We need to dig down to the level of the method or field declaration or (static) initializer block, then attribute that entire method/field/block using\n\t * the appropriate environment. So, we start from the top and walk down the node tree until we hit that method/field/block and stop there, recording both\n\t * the environment object (`env`) and the exact tree node (`copyAt`) at which to begin the attr process.\n\t */\n\tprivate static final class EnvFinder extends JCTree.Visitor {\n\t\tprivate Env<AttrContext> env = null;\n\t\tprivate Enter enter;\n\t\tprivate MemberEnter memberEnter;\n\t\tprivate JCTree copyAt = null;\n\t\t\n\t\tEnvFinder(Context context) {\n\t\t\tthis.enter = Enter.instance(context);\n\t\t\tthis.memberEnter = MemberEnter.instance(context);\n\t\t}\n\t\t\n\t\tEnv<AttrContext> get() {\n\t\t\treturn env;\n\t\t}\n\t\t\n\t\tJCTree copyAt() {\n\t\t\treturn copyAt;\n\t\t}\n\t\t\n\t\t@Override public void visitTopLevel(JCCompilationUnit tree) {\n\t\t\tif (copyAt != null) return;\n\t\t\tenv = enter.getTopLevelEnv(tree);\n\t\t}\n\t\t\n\t\t@Override public void visitClassDef(JCClassDecl tree) {\n\t\t\tif (copyAt != null) return;\n\t\t\t// The commented out stuff requires reflection tricks to avoid leaving lint unset which causes NPEs during attrib. So, we use the other one, much less code.\n//\t\t\tenv = enter.classEnv((JCClassDecl) tree, env);\n//\t\t\ttry {\n//\t\t\t\tField f = env.info.getClass().getDeclaredField(\"lint\");\n//\t\t\t\tf.setAccessible(true);\n//\t\t\t\tConstructor<?> c = Lint.class.getDeclaredConstructor(Lint.class);\n//\t\t\t\tc.setAccessible(true);\n//\t\t\t\tf.set(env.info, c.newInstance(lint));\n//\t\t\t} catch (Exception e) {\n//\t\t\t\tthrow Lombok.sneakyThrow(e);\n//\t\t\t}\n\t\t\tenv = enter.getClassEnv(tree.sym);\n\t\t}\n\t\t\n\t\t@Override public void visitMethodDef(JCMethodDecl tree) {\n\t\t\tif (copyAt != null) return;\n\t\t\tenv = memberEnter.getMethodEnv(tree, env);\n\t\t\tcopyAt = tree;\n\t\t}\n\t\t\n\t\tpublic void visitVarDef(JCVariableDecl tree) {\n\t\t\tif (copyAt != null) return;\n\t\t\tenv = memberEnter.getInitEnv(tree, env);\n\t\t\tcopyAt = tree;\n\t\t}\n\t\t\n\t\t@Override public void visitBlock(JCBlock tree) {\n\t\t\tif (copyAt != null) return;\n\t\t\tcopyAt = tree;\n\t\t}\n\t\t\n\t\t@Override public void visitTree(JCTree that) {\n\t\t}\n\t}\n\t\n\tpublic Map<JCTree, JCTree> resolveMethodMember(JavacNode node) {\n\t\tArrayDeque<JCTree> stack = new ArrayDeque<JCTree>();\n\t\t\n\t\t{\n\t\t\tJavacNode n = node;\n\t\t\twhile (n != null) {\n\t\t\t\tstack.push(n.get());\n\t\t\t\tn = n.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tlogDisabler.disableLoggers();\n\t\ttry {\n\t\t\tEnvFinder finder = new EnvFinder(node.getContext());\n\t\t\twhile (!stack.isEmpty()) stack.pop().accept(finder);\n\t\t\t\n\t\t\tTreeMirrorMaker mirrorMaker = new TreeMirrorMaker(node.getTreeMaker());\n\t\t\tJCTree copy = mirrorMaker.copy(finder.copyAt());\n\t\t\t\n\t\t\tattrib(copy, finder.get());\n\t\t\treturn mirrorMaker.getOriginalToCopyMap();\n\t\t} finally {\n\t\t\tlogDisabler.enableLoggers();\n\t\t}\n\t}\n\t\n\tpublic void resolveClassMember(JavacNode node) {\n\t\tArrayDeque<JCTree> stack = new ArrayDeque<JCTree>();\n\t\t\n\t\t{\n\t\t\tJavacNode n = node;\n\t\t\twhile (n != null) {\n\t\t\t\tstack.push(n.get());\n\t\t\t\tn = n.up();\n\t\t\t}\n\t\t}\n\t\t\n\t\tlogDisabler.disableLoggers();\n\t\ttry {\n\t\t\tEnvFinder finder = new EnvFinder(node.getContext());\n\t\t\twhile (!stack.isEmpty()) stack.pop().accept(finder);\n\t\t\t\n\t\t\tattrib(node.get(), finder.get());\n\t\t} finally {\n\t\t\tlogDisabler.enableLoggers();\n\t\t}\n\t}\n\t\n\tprivate void attrib(JCTree tree, Env<AttrContext> env) {\n\t\tif (tree instanceof JCBlock) attr.attribStat(tree, env);\n\t\telse if (tree instanceof JCMethodDecl) attr.attribStat(((JCMethodDecl)tree).body, env);\n\t\telse if (tree instanceof JCVariableDecl) attr.attribStat(tree, env);\n\t\telse throw new IllegalStateException(\"Called with something that isn't a block, method decl, or variable decl\");\n\t}\n\t\n\tpublic static class TypeNotConvertibleException extends Exception {\n\t\tpublic TypeNotConvertibleException(String msg) {\n\t\t\tsuper(msg);\n\t\t}\n\t}\n\t\n\tpublic static Type ifTypeIsIterableToComponent(Type type, JavacAST ast) {\n\t\tTypes types = Types.instance(ast.getContext());\n\t\tSymtab syms = Symtab.instance(ast.getContext());\n\t\tType boundType = types.upperBound(type);\n\t\tType elemTypeIfArray = types.elemtype(boundType);\n\t\tif (elemTypeIfArray != null) return elemTypeIfArray;\n\t\t\n\t\tType base = types.asSuper(boundType, syms.iterableType.tsym);\n\t\tif (base == null) return syms.objectType;\n\t\t\n\t\tList<Type> iterableParams = base.allparams();\n\t\treturn iterableParams.isEmpty() ? syms.objectType : types.upperBound(iterableParams.head);\n\t}\n\t\n\tpublic static JCExpression typeToJCTree(Type type, JavacAST ast, boolean allowVoid) throws TypeNotConvertibleException {\n\t\treturn typeToJCTree(type, ast, false, allowVoid);\n\t}\n\t\n\tpublic static JCExpression createJavaLangObject(JavacAST ast) {\n\t\tTreeMaker maker = ast.getTreeMaker();\n\t\tJCExpression out = maker.Ident(ast.toName(\"java\"));\n\t\tout = maker.Select(out, ast.toName(\"lang\"));\n\t\tout = maker.Select(out, ast.toName(\"Object\"));\n\t\treturn out;\n\t}\n\t\n\tprivate static JCExpression typeToJCTree(Type type, JavacAST ast, boolean allowCompound, boolean allowVoid) throws TypeNotConvertibleException {\n\t\tint dims = 0;\n\t\tType type0 = type;\n\t\twhile (type0 instanceof ArrayType) {\n\t\t\tdims++;\n\t\t\ttype0 = ((ArrayType)type0).elemtype;\n\t\t}\n\t\t\n\t\tJCExpression result = typeToJCTree0(type0, ast, allowCompound, allowVoid);\n\t\twhile (dims > 0) {\n\t\t\tresult = ast.getTreeMaker().TypeArray(result);\n\t\t\tdims--;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tprivate static JCExpression typeToJCTree0(Type type, JavacAST ast, boolean allowCompound, boolean allowVoid) throws TypeNotConvertibleException {\n\t\t// NB: There's such a thing as maker.Type(type), but this doesn't work very well; it screws up anonymous classes, captures, and adds an extra prefix dot for some reason too.\n\t\t//  -- so we write our own take on that here.\n\t\t\n\t\tTreeMaker maker = ast.getTreeMaker();\n\t\t\n\t\tif (type.tag == Javac.getCtcInt(TypeTags.class, \"BOT\")) return createJavaLangObject(ast);\n\t\tif (type.tag == Javac.getCtcInt(TypeTags.class, \"VOID\")) return allowVoid ? primitiveToJCTree(type.getKind(), maker) : createJavaLangObject(ast);\n\t\tif (type.isPrimitive()) return primitiveToJCTree(type.getKind(), maker);\n\t\tif (type.isErroneous()) throw new TypeNotConvertibleException(\"Type cannot be resolved\");\n\t\t\n\t\tTypeSymbol symbol = type.asElement();\n\t\tList<Type> generics = type.getTypeArguments();\n\t\t\n\t\tJCExpression replacement = null;\n\t\t\n\t\tif (symbol == null) throw new TypeNotConvertibleException(\"Null or compound type\");\n\t\t\n\t\tif (symbol.name.length() == 0) {\n\t\t\t// Anonymous inner class\n\t\t\tif (type instanceof ClassType) {\n\t\t\t\tList<Type> ifaces = ((ClassType)type).interfaces_field;\n\t\t\t\tType supertype = ((ClassType)type).supertype_field;\n\t\t\t\tif (ifaces != null && ifaces.length() == 1) {\n\t\t\t\t\treturn typeToJCTree(ifaces.get(0), ast, allowCompound, allowVoid);\n\t\t\t\t}\n\t\t\t\tif (supertype != null) return typeToJCTree(supertype, ast, allowCompound, allowVoid);\n\t\t\t}\n\t\t\tthrow new TypeNotConvertibleException(\"Anonymous inner class\");\n\t\t}\n\t\t\n\t\tif (type instanceof CapturedType || type instanceof WildcardType) {\n\t\t\tType lower, upper;\n\t\t\tif (type instanceof WildcardType) {\n\t\t\t\tupper = ((WildcardType)type).getExtendsBound();\n\t\t\t\tlower = ((WildcardType)type).getSuperBound();\n\t\t\t} else {\n\t\t\t\tlower = type.getLowerBound();\n\t\t\t\tupper = type.getUpperBound();\n\t\t\t}\n\t\t\tif (allowCompound) {\n\t\t\t\tif (lower == null || lower.tag == Javac.getCtcInt(TypeTags.class, \"BOT\")) {\n\t\t\t\t\tif (upper == null || upper.toString().equals(\"java.lang.Object\")) {\n\t\t\t\t\t\treturn maker.Wildcard(maker.TypeBoundKind(BoundKind.UNBOUND), null);\n\t\t\t\t\t}\n\t\t\t\t\treturn maker.Wildcard(maker.TypeBoundKind(BoundKind.EXTENDS), typeToJCTree(upper, ast, false, false));\n\t\t\t\t} else {\n\t\t\t\t\treturn maker.Wildcard(maker.TypeBoundKind(BoundKind.SUPER), typeToJCTree(lower, ast, false, false));\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (upper != null) {\n\t\t\t\treturn typeToJCTree(upper, ast, allowCompound, allowVoid);\n\t\t\t}\n\t\t\t\n\t\t\treturn createJavaLangObject(ast);\n\t\t}\n\t\t\n\t\tString qName;\n\t\tif (symbol.isLocal()) {\n\t\t\tqName = symbol.getSimpleName().toString();\n\t\t} else if (symbol.type != null && symbol.type.getEnclosingType() != null && symbol.type.getEnclosingType().tag == TypeTags.CLASS) {\n\t\t\treplacement = typeToJCTree0(type.getEnclosingType(), ast, false, false);\n\t\t\tqName = symbol.getSimpleName().toString();\n\t\t} else {\n\t\t\tqName = symbol.getQualifiedName().toString();\n\t\t}\n\t\t\n\t\tif (qName.isEmpty()) throw new TypeNotConvertibleException(\"unknown type\");\n\t\tif (qName.startsWith(\"<\")) throw new TypeNotConvertibleException(qName);\n\t\tString[] baseNames = qName.split(\"\\\\.\");\n\t\tint i = 0;\n\t\t\n\t\tif (replacement == null) {\n\t\t\treplacement = maker.Ident(ast.toName(baseNames[0]));\n\t\t\ti = 1;\n\t\t}\n\t\tfor (; i < baseNames.length; i++) {\n\t\t\treplacement = maker.Select(replacement, ast.toName(baseNames[i]));\n\t\t}\n\t\t\n\t\treturn genericsToJCTreeNodes(generics, ast, replacement);\n\t}\n\t\n\tprivate static JCExpression genericsToJCTreeNodes(List<Type> generics, JavacAST ast, JCExpression rawTypeNode) throws TypeNotConvertibleException {\n\t\tif (generics != null && !generics.isEmpty()) {\n\t\t\tListBuffer<JCExpression> args = ListBuffer.lb();\n\t\t\tfor (Type t : generics) args.append(typeToJCTree(t, ast, true, false));\n\t\t\treturn ast.getTreeMaker().TypeApply(rawTypeNode, args.toList());\n\t\t}\n\t\t\n\t\treturn rawTypeNode;\n\t}\n\t\n\tprivate static JCExpression primitiveToJCTree(TypeKind kind, TreeMaker maker) throws TypeNotConvertibleException {\n\t\tswitch (kind) {\n\t\tcase BYTE:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"BYTE\"));\n\t\tcase CHAR:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"CHAR\"));\n\t\tcase SHORT:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"SHORT\"));\n\t\tcase INT:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"INT\"));\n\t\tcase LONG:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"LONG\"));\n\t\tcase FLOAT:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"FLOAT\"));\n\t\tcase DOUBLE:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"DOUBLE\"));\n\t\tcase BOOLEAN:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"BOOLEAN\"));\n\t\tcase VOID:\n\t\t\treturn maker.TypeIdent(Javac.getCtcInt(TypeTags.class, \"VOID\"));\n\t\tcase NULL:\n\t\tcase NONE:\n\t\tcase OTHER:\n\t\tdefault:\n\t\t\tthrow new TypeNotConvertibleException(\"Nulltype\");\n\t\t}\n\t}\n}\n", "t org.apache.commons.lang3.StringUtils;\nimport org.apache.wicket.AttributeModifier;\nimport org.apache.wicket.Component;\nimport org.apache.wicket.MarkupContainer;\nimport org.apache.wicket.WicketRuntimeException;\nimport org.apache.wicket.ajax.AjaxRequestTarget;\nimport org.apache.wicket.ajax.form.AjaxFormComponentUpdatingBehavior;\nimport org.apache.wicket.behavior.Behavior;\nimport org.apache.wicket.markup.ComponentTag;\nimport org.apache.wicket.markup.html.WebMarkupContainer;\nimport org.apache.wicket.markup.html.basic.Label;\nimport org.apache.wicket.markup.html.form.FormComponent;\nimport org.apache.wicket.markup.html.panel.Panel;\nimport org.apache.wicket.model.IModel;\nimport org.apache.wicket.model.LoadableDetachableModel;\nimport org.jhaws.common.web.wicket.AttributeRemover;\nimport org.jhaws.common.web.wicket.HtmlEvent.HtmlFormEvent;\nimport org.jhaws.common.web.wicket.WebHelper;\nimport org.jhaws.common.web.wicket.bootstrap.BootstrapFencedFeedbackPanel;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\n@SuppressWarnings(\"serial\")\npublic abstract class FormRowPanelParent<P, T, C extends FormComponent<T>, ElementSettings extends AbstractFormElementSettings<ElementSettings>> extends Panel implements FormConstants {\n    protected static final Logger logger = LoggerFactory.getLogger(FormRowPanelParent.class);\n\n    protected static final Logger loggerMissingLabel = LoggerFactory.getLogger(\"missinglabels\");\n\n    protected Label label;\n\n    protected IModel<String> labelModel;\n\n    protected IModel<String> titleModel;\n\n    protected IModel<T> valueModel;\n\n    /** normally a lambda path */\n    protected transient P propertyPath;\n\n    protected Class<T> propertyType;\n\n    protected String propertyName;\n\n    protected BootstrapFencedFeedbackPanel feedbackPanel;\n\n    protected C component;\n\n    protected FormSettings formSettings;\n\n    protected ElementSettings componentSettings;\n\n    protected FormRowPanelParent(IModel<?> model, P propertyPath, FormSettings formSettings, ElementSettings componentSettings) {\n        super(FormConstants.FORM_ELEMENT, model);\n        if (formSettings == null) {\n            throw new NullPointerException(\"formSettings\");\n        }\n        if (componentSettings == null) {\n            throw new NullPointerException(\"componentSettings\");\n        }\n        this.formSettings = formSettings;\n        this.componentSettings = componentSettings;\n        this.propertyPath = propertyPath;\n        WebHelper.hide(this);\n    }\n\n    public FormRowPanelParent(P propertyPath, IModel<T> valueModel, FormSettings formSettings, ElementSettings componentSettings) {\n        this(valueModel, propertyPath, formSettings, componentSettings);\n        this.valueModel = valueModel;\n    }\n\n    @Override\n    public MarkupContainer add(Component... childs) {\n        if ((childs == null) || (childs.length == 0) || ((childs.length == 1) && (childs[0] == null))) {\n            return this;\n        }\n        return super.add(childs);\n    }\n\n    public FormRowPanelParent<P, T, C, ElementSettings> addComponents(ElementSettings settings) {\n        add(getLabel(settings));\n        WebMarkupContainer _componentContainer = getComponentContainer(settings);\n        add(_componentContainer);\n        C _component = getComponent();\n        _componentContainer.add(_component);\n        _componentContainer.add(getRequiredMarker());\n        _componentContainer.add(getFeedback());\n        return this;\n    }\n\n    protected WebMarkupContainer componentContainer;\n\n    public String getLabelClass(ElementSettings settings) {\n        return null;\n    }\n\n    public String getComponentClass(ElementSettings settings) {\n        return null;\n    }\n\n    public WebMarkupContainer getComponentContainer(ElementSettings settings) {\n        if (componentContainer == null) {\n            componentContainer = new WebMarkupContainer(\"componentContainer\");\n            String componentClass = getComponentClass(settings);\n            if (componentClass != null) componentContainer.add(AttributeModifier.append(\"class\", componentClass));\n        }\n        return componentContainer;\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public FormRowPanelParent<P, T, C, ElementSettings> afterAddComponents() {\n        // jsr bean validation\n        // this.getComponent().add(new PropertyValidator<T>());\n        this.getComponent().setLabel((IModel<String>) this.getLabel(null).getDefaultModel());\n        this.setupRequiredBehavior();\n        this.setupId();\n        return this;\n    }\n\n    protected abstract C createComponent(IModel<T> model, Class<T> valueType);\n\n    public C getComponent() {\n        if (this.component == null) {\n            this.component = this.createComponent(this.getValueModel(), this.getPropertyType());\n            this.setupRequired(this.component);\n        }\n        return this.component;\n    }\n\n    public ElementSettings getComponentSettings() {\n        return this.componentSettings;\n    }\n\n    protected BootstrapFencedFeedbackPanel getFeedback() {\n        if (this.feedbackPanel == null) {\n            this.feedbackPanel = new BootstrapFencedFeedbackPanel(FormConstants.FEEDBACK_ID, this.component);\n        }\n        return this.feedbackPanel;\n    }\n\n    public C getFormComponent() {\n        return this.getComponent();\n    }\n\n    public Label getLabel(ElementSettings settings) {\n        if (this.label == null) {\n            this.label = new Label(FormConstants.LABEL, this.getLabelModel()) {\n                @Override\n                public boolean isVisible() {\n                    return super.isVisible() && settings.isShowLabel() && ((FormRowPanelParent.this.formSettings == null) || FormRowPanelParent.this.formSettings.isShowLabel());\n                }\n\n                @Override\n                protected void onComponentTag(ComponentTag tag) {\n                    super.onComponentTag(tag);\n                    String markupId = FormRowPanelParent.this.getComponent().getMarkupId();\n                    tag.getAttributes().put(FormConstants.FOR, markupId);\n                    tag.getAttributes().put(FormConstants.TITLE, getTitleModel().getObject());\n                }\n            };\n            prepareLabel(label, settings);\n        }\n        return this.label;\n    }\n\n    protected void prepareLabel(Label label, ElementSettings settings) {\n        label.setEscapeModelStrings(false);\n        if (formSettings.isTooltipToggle()) {\n            label.add(new AttributeModifier(\"data-toggle\", \"tooltip\"));\n            label.add(new AttributeModifier(\"data-placement\", \"top\"));\n        }\n        String labelClass = getLabelClass(settings);\n        if (labelClass != null) {\n            label.add(AttributeModifier.append(\"class\", labelClass));\n        }\n    }\n\n    public IModel<String> getLabelModel() {\n        if (this.labelModel == null) {\n            this.labelModel = new LoadableDetachableModel<String>() {\n                @Override\n                protected String load() {\n                    return FormRowPanelParent.this.getLabelText();\n                }\n            };\n        }\n        return this.labelModel;\n    }\n\n    public void setTitleModel(IModel<String> titleModel) {\n        this.titleModel = titleModel;\n    }\n\n    public IModel<String> getTitleModel() {\n        if (this.titleModel != null) {\n            return this.titleModel;\n        }\n        return getLabelModel();\n    }\n\n    protected String getLabelText() {\n        try {\n            return this.getString(this.getPropertyName());\n        } catch (MissingResourceException ex) {\n            loggerMissingLabel.error(this.getPropertyName() + \"=\" + this.getPropertyName().toLowerCase());\n            return \"[\" + this.getPropertyName() + \"_\" + this.getLocale() + \"]\";\n        }\n    }\n\n    protected String getPlaceholderText() {\n        try {\n            return this.getString(FormConstants.PLACEHOLDER);\n        } catch (MissingResourceException ex) {\n            logger.info(\"no translation for \" + FormConstants.PLACEHOLDER);\n            return null;\n        }\n    }\n\n    public String getPropertyName() {\n        if (this.propertyName == null) {\n            try {\n                this.propertyName = WebHelper.name(this.propertyPath);\n            } catch (ch.lambdaj.function.argument.ArgumentConversionException ex) {\n                this.propertyName = this.propertyPath == null ? null : this.propertyPath.toString();\n            }\n        }\n        return this.propertyName;\n    }\n\n    public Class<T> getPropertyType() {\n        if (this.propertyType == null) {\n            throw new NullPointerException();\n        }\n        return this.propertyType;\n    }\n\n    protected WebMarkupContainer getRequiredMarker() {\n        WebMarkupContainer requiredMarker = new WebMarkupContainer(\"requiredMarker\") {\n            @Override\n            public boolean isVisible() {\n                return super.isVisible() && FormRowPanelParent.this.componentSettings.isRequired();\n            }\n        };\n        return requiredMarker;\n    }\n\n    public IModel<T> getValueModel() {\n        if (this.valueModel == null) {\n            throw new NullPointerException();\n        }\n        return this.valueModel;\n    }\n\n    public FormRowPanelParent<P, T, C, ElementSettings> inheritId() {\n        // . is replaced because sql selectors don't work well with dot's\n        this.getComponent().setMarkupId(this.getPropertyName().toString().replace('.', FormConstants.DOT_REPLACER));\n        return this;\n    }\n\n    /**\n     * call this in overridden method:<br>\n     * forms.[Component]Panel. createComponent().new [Component]() {...}.onComponentTag(ComponentTag)\n     */\n    protected void onFormComponentTag(ComponentTag tag) {\n        this.setupPlaceholder(tag);\n        this.setupRequired(tag);\n        this.setupReadOnly(tag);\n    }\n\n    public FormRowPanelParent<P, T, C, ElementSettings> setLabelModel(IModel<String> labelModel) {\n        this.labelModel = labelModel;\n        return this;\n    }\n\n    public FormRowPanelParent<P, T, C, ElementSettings> setPropertyName(String propertyName) {\n        this.propertyName = propertyName;\n        return this;\n    }\n\n    public FormRowPanelParent<P, T, C, ElementSettings> setPropertyType(Class<T> propertyType) {\n        this.propertyType = propertyType;\n        return this;\n    }\n\n    // FIXME specific\n    protected Behavior setupDynamicRequiredBehavior() {\n        return new AjaxFormComponentUpdatingBehavior(HtmlFormEvent.BLUR) {\n            @Override\n            protected void onError(AjaxRequestTarget ajaxRequestTarget, RuntimeException e) {\n                C c = FormRowPanelParent.this.getComponent();\n                c.add(AttributeRemover.remove(\"class\", FormRowPanelParent.this.formSettings.getValidClass()));\n                c.add(AttributeModifier.append(\"class\", FormRowPanelParent.this.formSettings.getInvalidClass()));\n                ajaxRequestTarget.add(c, FormRowPanelParent.this.getFeedback());\n            }\n\n            @Override\n            protected void onUpdate(AjaxRequestTarget ajaxRequestTarget) {\n                C c = FormRowPanelParent.this.getComponent();\n                c.add(AttributeRemover.remove(\"class\", FormRowPanelParent.this.formSettings.getInvalidClass()));\n                c.add(AttributeModifier.append(\"class\", FormRowPanelParent.this.formSettings.getValidClass()));\n                ajaxRequestTarget.add(c, FormRowPanelParent.this.getFeedback());\n            }\n        };\n    }\n\n    protected void setupId() {\n        if (this.formSettings.isInheritId() || this.componentSettings.isInheritId()) {\n            this.inheritId();\n        }\n    }\n\n    protected void setupPlaceholder(ComponentTag tag) {\n        if ((this.componentSettings != null) && !this.componentSettings.isShowPlaceholder()) {\n            WebHelper.untag(tag, FormConstants.PLACEHOLDER);\n        } else if ((this.componentSettings != null) && this.componentSettings.isShowPlaceholder()) {\n            WebHelper.tag(tag, FormConstants.PLACEHOLDER, this.getPlaceholderText());\n        } else if ((this.formSettings != null) && this.formSettings.isShowPlaceholder()) {\n            WebHelper.tag(tag, FormConstants.PLACEHOLDER, this.getPlaceholderText());\n        } else {\n            WebHelper.untag(tag, FormConstants.PLACEHOLDER);\n        }\n        if (StringUtils.isNotBlank(getComponentSettings().getPlaceholder())) {\n            WebHelper.tag(tag, \"placeholder\", getComponentSettings().getPlaceholder());\n        }\n    }\n\n    protected void setupReadOnly(ComponentTag tag) {\n        if ((this.componentSettings != null) && this.componentSettings.isReadOnly()) {\n            WebHelper.tag(tag, FormConstants.READ_ONLY, FormConstants.READ_ONLY);\n        } else {\n            WebHelper.untag(tag, FormConstants.READ_ONLY);\n        }\n    }\n\n    protected void setupRequired(C component) {\n        try {\n            component.setRequired(this.componentSettings.isRequired());\n            if (StringUtils.isNotBlank(this.formSettings.getRequiredClass())) {\n                if (this.componentSettings.isRequired()) {\n                    component.add(AttributeModifier.append(\"class\", this.formSettings.getRequiredClass()));\n                } else {\n                    component.add(AttributeRemover.remove(\"class\", this.formSettings.getRequiredClass()));\n                }\n            }\n        } catch (WicketRuntimeException ex) {\n            // TODO primitive\n        }\n    }\n\n    protected void setupRequired(ComponentTag tag) {\n        if ((this.formSettings != null) && this.formSettings.isClientsideRequiredValidation() && (this.componentSettings != null) && this.componentSettings.isRequired()) {\n            WebHelper.tag(tag, FormConstants.REQUIRED, FormConstants.REQUIRED);\n        } else {\n            WebHelper.untag(tag, FormConstants.REQUIRED);\n        }\n    }\n\n    protected void setupRequiredBehavior() {\n        // C c = this.getComponent();\n        // if (this.formSettings.isAjax() &&\n        // this.formSettings.isLiveValidation() && !(c instanceof\n        // PasswordTextField)\n        // && !(c instanceof\n        // com.googlecode.wicket.jquery.ui.form.datepicker.DatePicker)) {\n        // // c.add(setupDynamicRequiredBehavior());\n        // }\n    }\n\n    public FormRowPanelParent<P, T, C, ElementSettings> setValueModel(IModel<T> valueModel) {\n        this.valueModel = valueModel;\n        return this;\n    }\n\n    public boolean takesUpSpace() {\n        return true;\n    }\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.azurestack.implementation;\n\nimport com.azure.core.annotation.ServiceClientBuilder;\nimport com.azure.core.http.HttpPipeline;\nimport com.azure.core.http.HttpPipelineBuilder;\nimport com.azure.core.http.policy.CookiePolicy;\nimport com.azure.core.http.policy.RetryPolicy;\nimport com.azure.core.http.policy.UserAgentPolicy;\nimport com.azure.core.management.AzureEnvironment;\nimport com.azure.core.management.serializer.SerializerFactory;\nimport com.azure.core.util.serializer.SerializerAdapter;\nimport java.time.Duration;\n\n/** A builder for creating a new instance of the AzureStackManagementClientImpl type. */\n@ServiceClientBuilder(serviceClients = {AzureStackManagementClientImpl.class})\npublic final class AzureStackManagementClientBuilder {\n    /*\n     * Subscription credentials that uniquely identify Microsoft Azure\n     * subscription. The subscription ID forms part of the URI for every\n     * service call.\n     */\n    private String subscriptionId;\n\n    /**\n     * Sets Subscription credentials that uniquely identify Microsoft Azure subscription. The subscription ID forms part\n     * of the URI for every service call.\n     *\n     * @param subscriptionId the subscriptionId value.\n     * @return the AzureStackManagementClientBuilder.\n     */\n    public AzureStackManagementClientBuilder subscriptionId(String subscriptionId) {\n        this.subscriptionId = subscriptionId;\n        return this;\n    }\n\n    /*\n     * server parameter\n     */\n    private String endpoint;\n\n    /**\n     * Sets server parameter.\n     *\n     * @param endpoint the endpoint value.\n     * @return the AzureStackManagementClientBuilder.\n     */\n    public AzureStackManagementClientBuilder endpoint(String endpoint) {\n        this.endpoint = endpoint;\n        return this;\n    }\n\n    /*\n     * The environment to connect to\n     */\n    private AzureEnvironment environment;\n\n    /**\n     * Sets The environment to connect to.\n     *\n     * @param environment the environment value.\n     * @return the AzureStackManagementClientBuilder.\n     */\n    public AzureStackManagementClientBuilder environment(AzureEnvironment environment) {\n        this.environment = environment;\n        return this;\n    }\n\n    /*\n     * The default poll interval for long-running operation\n     */\n    private Duration defaultPollInterval;\n\n    /**\n     * Sets The default poll interval for long-running operation.\n     *\n     * @param defaultPollInterval the defaultPollInterval value.\n     * @return the AzureStackManagementClientBuilder.\n     */\n    public AzureStackManagementClientBuilder defaultPollInterval(Duration defaultPollInterval) {\n        this.defaultPollInterval = defaultPollInterval;\n        return this;\n    }\n\n    /*\n     * The HTTP pipeline to send requests through\n     */\n    private HttpPipeline pipeline;\n\n    /**\n     * Sets The HTTP pipeline to send requests through.\n     *\n     * @param pipeline the pipeline value.\n     * @return the AzureStackManagementClientBuilder.\n     */\n    public AzureStackManagementClientBuilder pipeline(HttpPipeline pipeline) {\n        this.pipeline = pipeline;\n        return this;\n    }\n\n    /*\n     * The serializer to serialize an object into a string\n     */\n    private SerializerAdapter serializerAdapter;\n\n    /**\n     * Sets The serializer to serialize an object into a string.\n     *\n     * @param serializerAdapter the serializerAdapter value.\n     * @return the AzureStackManagementClientBuilder.\n     */\n    public AzureStackManagementClientBuilder serializerAdapter(SerializerAdapter serializerAdapter) {\n        this.serializerAdapter = serializerAdapter;\n        return this;\n    }\n\n    /**\n     * Builds an instance of AzureStackManagementClientImpl with the provided parameters.\n     *\n     * @return an instance of AzureStackManagementClientImpl.\n     */\n    public AzureStackManagementClientImpl buildClient() {\n        if (endpoint == null) {\n            this.endpoint = \"https://management.azure.com\";\n        }\n        if (environment == null) {\n            this.environment = AzureEnvironment.AZURE;\n        }\n        if (defaultPollInterval == null) {\n            this.defaultPollInterval = Duration.ofSeconds(30);\n        }\n        if (pipeline == null) {\n            this.pipeline =\n                new HttpPipelineBuilder()\n                    .policies(new UserAgentPolicy(), new RetryPolicy(), new CookiePolicy())\n                    .build();\n        }\n        if (serializerAdapter == null) {\n            this.serializerAdapter = SerializerFactory.createDefaultManagementSerializerAdapter();\n        }\n        AzureStackManagementClientImpl client =\n            new AzureStackManagementClientImpl(\n                pipeline, serializerAdapter, defaultPollInterval, environment, subscriptionId, endpoint);\n        return client;\n    }\n}\n", "ect;\nimport org.json.simple.parser.JSONParser;\nimport org.json.simple.parser.ParseException;\n\n/**\n * Data object for json transport\n */\npublic class OneDriveError {\n    InnerError error;\n\n    public static OneDriveError parseError(String json)  throws ParseException{\n        JSONParser parser = new JSONParser();\n        JSONObject root = (JSONObject) parser.parse(json);\n        if (root.containsKey(\"error\")) {\n            Gson gson = new Gson();\n            return gson.fromJson(json, OneDriveError.class);\n        }\n\n        return null;\n    }\n\n    @Override\n    public String toString() {\n        return \"Error: \" + error;\n    }\n}\n", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.util.gen;\n\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\nimport com.flowpowered.math.vector.Vector3i;\nimport net.minecraft.world.biome.Biome;\nimport org.spongepowered.api.util.DiscreteTransform3;\nimport org.spongepowered.api.world.biome.BiomeType;\nimport org.spongepowered.api.world.biome.BiomeTypes;\nimport org.spongepowered.api.world.extent.ImmutableBiomeVolume;\nimport org.spongepowered.api.world.extent.MutableBiomeVolume;\nimport org.spongepowered.api.world.extent.StorageType;\nimport org.spongepowered.api.world.extent.UnmodifiableBiomeVolume;\nimport org.spongepowered.api.world.extent.worker.MutableBiomeVolumeWorker;\nimport org.spongepowered.common.world.extent.MutableBiomeViewDownsize;\nimport org.spongepowered.common.world.extent.MutableBiomeViewTransform;\nimport org.spongepowered.common.world.extent.UnmodifiableBiomeVolumeWrapper;\nimport org.spongepowered.common.world.extent.worker.SpongeMutableBiomeVolumeWorker;\n\nimport java.util.Arrays;\n\n/**\n * Mutable biome volume backed by a byte array. Reusable.\n *\n * <p>Using {@link #detach()} the underlying byte array can be accessed.\n * The byte array can then be reused by calling {@link #reuse(Vector3i)}.</p>\n */\npublic final class ByteArrayMutableBiomeBuffer extends AbstractBiomeBuffer implements MutableBiomeVolume {\n\n    private boolean detached;\n    private final byte[] biomes;\n\n    private void checkOpen() {\n        checkState(!this.detached, \"trying to use buffer after it's closed\");\n    }\n\n    public ByteArrayMutableBiomeBuffer(Vector3i start, Vector3i size) {\n        this(new byte[size.getX() * size.getZ()], start, size);\n    }\n\n    public ByteArrayMutableBiomeBuffer(byte[] biomes, Vector3i start, Vector3i size) {\n        super(start, size);\n        this.biomes = biomes;\n    }\n\n    @Override\n    public void setBiome(int x, int y, int z, BiomeType biome) {\n        checkOpen();\n        checkRange(x, y, z);\n\n        this.biomes[getIndex(x, z)] = (byte) Biome.getIdForBiome((Biome) biome);\n    }\n\n    @Override\n    public BiomeType getBiome(int x, int y, int z) {\n        checkOpen();\n        checkRange(x, y, z);\n\n        byte biomeId = this.biomes[getIndex(x, z)];\n        BiomeType biomeType = (BiomeType) Biome.getBiomeForId(biomeId & 255);\n        return biomeType == null ? BiomeTypes.OCEAN : biomeType;\n    }\n\n    /**\n     * Gets the internal byte array, and prevents further of it through this\n     * object uses until {@link #reuse(Vector3i)} is called.\n     *\n     * @return The internal byte array.\n     */\n    public byte[] detach() {\n        checkOpen();\n\n        this.detached = true;\n        return this.biomes;\n    }\n\n    /**\n     * Gets whether this biome volume is currently detached. When detached, this\n     * object is available for reuse using {@link #reuse(Vector3i)}.\n     *\n     * @return Whether this biome volume is detached\n     */\n    public boolean isDetached() {\n        return this.detached;\n    }\n\n    /**\n     * Changes the bounds of this biome volume, so that it can be reused for\n     * another chunk.\n     *\n     * @param start New start position.\n     */\n    public void reuse(Vector3i start) {\n        checkState(this.detached, \"Cannot reuse while still in use\");\n\n        this.start = checkNotNull(start, \"start\");\n        this.end = this.start.add(this.size).sub(Vector3i.ONE);\n        Arrays.fill(this.biomes, (byte) 0);\n\n        this.detached = false;\n    }\n\n    @Override\n    public MutableBiomeVolume getBiomeView(Vector3i newMin, Vector3i newMax) {\n        checkRange(newMin.getX(), newMin.getY(), newMin.getZ());\n        checkRange(newMax.getX(), newMax.getY(), newMax.getZ());\n        return new MutableBiomeViewDownsize(this, newMin, newMax);\n    }\n\n    @Override\n    public MutableBiomeVolume getBiomeView(DiscreteTransform3 transform) {\n        return new MutableBiomeViewTransform(this, transform);\n    }\n\n    @Override\n    public MutableBiomeVolumeWorker<? extends MutableBiomeVolume> getBiomeWorker() {\n        return new SpongeMutableBiomeVolumeWorker<>(this);\n    }\n\n    @Override\n    public UnmodifiableBiomeVolume getUnmodifiableBiomeView() {\n        return new UnmodifiableBiomeVolumeWrapper(this);\n    }\n\n    @Override\n    public MutableBiomeVolume getBiomeCopy(StorageType type) {\n        checkOpen();\n        switch (type) {\n            case STANDARD:\n                return new ByteArrayMutableBiomeBuffer(this.biomes.clone(), this.start, this.size);\n            case THREAD_SAFE:\n            default:\n                throw new UnsupportedOperationException(type.name());\n        }\n    }\n\n    @Override\n    public ImmutableBiomeVolume getImmutableBiomeCopy() {\n        checkOpen();\n        return new ByteArrayImmutableBiomeBuffer(this.biomes, this.start, this.size);\n    }\n\n}\n", "son.JsonObject;\nimport com.slack.api.bolt.context.builtin.DefaultContext;\nimport com.slack.api.bolt.request.Request;\nimport com.slack.api.bolt.request.RequestHeaders;\nimport com.slack.api.bolt.request.RequestType;\nimport com.slack.api.util.json.GsonFactory;\nimport lombok.ToString;\n\n@ToString(callSuper = true)\npublic class UrlVerificationRequest extends Request<DefaultContext> {\n\n    private final String requestBody;\n    private final RequestHeaders headers;\n    private final String challenge;\n\n    public UrlVerificationRequest(\n            String requestBody,\n            RequestHeaders headers) {\n        this.requestBody = requestBody;\n        this.headers = headers;\n        JsonObject payload = GsonFactory.createSnakeCase().fromJson(requestBody, JsonElement.class).getAsJsonObject();\n        this.challenge = payload.get(\"challenge\").getAsString();\n    }\n\n    private DefaultContext context = new DefaultContext();\n\n    @Override\n    public DefaultContext getContext() {\n        return context;\n    }\n\n    @Override\n    public RequestType getRequestType() {\n        return RequestType.UrlVerification;\n    }\n\n    @Override\n    public String getRequestBodyAsString() {\n        return requestBody;\n    }\n\n    @Override\n    public RequestHeaders getHeaders() {\n        return this.headers;\n    }\n\n    public String getChallenge() {\n        return this.challenge;\n    }\n\n    @Override\n    public String getResponseUrl() {\n        return null;\n    }\n}\n", "ing a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * You should have received a copy of The MIT License (MIT) along with this\n * program. If not, see <http://opensource.org/licenses/MIT/>.\n */\n\npackage org.libx4j.xsb.compiler.processor.model;\n\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\nimport org.lib4j.pipeline.PipelineDirectory;\nimport org.lib4j.pipeline.PipelineProcessor;\nimport org.libx4j.xsb.compiler.lang.LexerFailureException;\nimport org.libx4j.xsb.compiler.lang.NamespaceURI;\nimport org.libx4j.xsb.compiler.processor.GeneratorContext;\nimport org.libx4j.xsb.compiler.processor.composite.SchemaComposite;\nimport org.libx4j.xsb.compiler.processor.composite.SchemaModelComposite;\nimport org.libx4j.xsb.compiler.processor.composite.SchemaNodeComposite;\nimport org.libx4j.xsb.compiler.processor.document.SchemaDocument;\nimport org.libx4j.xsb.compiler.processor.model.element.SchemaModel;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\npublic final class ModelProcessor implements PipelineProcessor<GeneratorContext,SchemaComposite,Model> {\n  private Model root;\n\n  @Override\n  public Collection<Model> process(final GeneratorContext pipelineContext, final Collection<SchemaComposite> documents, final PipelineDirectory<GeneratorContext,SchemaComposite,Model> directory) {\n    root = new Model(null, null) {};\n    // Then we parse all of the schemas that have been included and imported\n    final Collection<Model> schemaModels = new ArrayList<>();\n\n    for (final SchemaComposite schemaComposite : documents) {\n      final SchemaModelComposite schemaModelComposite = (SchemaModelComposite)schemaComposite;\n      final SchemaDocument schemaDocument = schemaModelComposite.getSchemaDocument();\n      final SchemaModel schemaModel = recurse(root, schemaDocument.getSchemaReference().getNamespaceURI(), schemaDocument.getDocument().getChildNodes(), schemaDocument.getSchemaReference().getURL(), directory);\n      if (schemaModel == null)\n        throw new LexerFailureException(\"We should have found a schema!\");\n\n      schemaModelComposite.setSchemaModel(schemaModel);\n      schemaModels.add(schemaModel);\n    }\n\n    return schemaModels;\n  }\n\n  private final SchemaModel recurse(final Model model, final NamespaceURI targetNamespace, NodeList children, URL url, final PipelineDirectory<GeneratorContext,SchemaComposite,Model> directory) {\n    if (children == null || children.getLength() == 0)\n      return null;\n\n    // FIXME: This looks ugly!\n    SchemaModel schema = null;\n    if (model instanceof SchemaModel) {\n      schema = (SchemaModel)model;\n      if (model.getTargetNamespace() == null) {\n        // This means that this is an included schema\n        schema.setTargetNamespace(targetNamespace);\n        URL schemaReference = model.lookupSchemaLocation(targetNamespace);\n        if (schemaReference == null)\n          model.registerSchemaLocation(targetNamespace, schemaReference = url);\n      }\n      else {\n        model.registerSchemaLocation(targetNamespace, url);\n      }\n\n      schema.setURL(url);\n      url = null;\n    }\n\n    Model current = null;\n    for (int i = 0; i < children.getLength(); i++) {\n      final Node child = children.item(i);\n      if (child.getLocalName() == null)\n        continue;\n\n      final SchemaNodeComposite nodeComposite = new SchemaNodeComposite(child);\n      final Model handler = (Model)directory.getEntity(nodeComposite, model);\n      if (current != null) {\n        handler.setPrevious(current);\n        current.setNext(handler);\n      }\n\n      current = handler;\n\n      final SchemaModel temp = recurse(handler, targetNamespace, child.getChildNodes(), url, directory);\n      if (temp != null)\n        schema = temp;\n    }\n\n    return schema;\n  }\n}", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.mixin.core.world;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\n\nimport com.flowpowered.math.vector.Vector2i;\nimport com.flowpowered.math.vector.Vector3d;\nimport com.flowpowered.math.vector.Vector3i;\nimport com.google.common.base.Predicate;\nimport com.google.common.collect.Maps;\nimport com.google.common.collect.Sets;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.state.IBlockState;\nimport net.minecraft.entity.Entity;\nimport net.minecraft.entity.item.EntityItem;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.init.Blocks;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.AxisAlignedBB;\nimport net.minecraft.util.BlockPos;\nimport net.minecraft.util.ClassInheritanceMultiMap;\nimport net.minecraft.util.MathHelper;\nimport net.minecraft.world.EnumDifficulty;\nimport net.minecraft.world.EnumSkyBlock;\nimport net.minecraft.world.World;\nimport net.minecraft.world.WorldServer;\nimport net.minecraft.world.biome.BiomeGenBase;\nimport net.minecraft.world.biome.WorldChunkManager;\nimport net.minecraft.world.chunk.Chunk.EnumCreateEntityType;\nimport net.minecraft.world.chunk.storage.ExtendedBlockStorage;\nimport org.spongepowered.api.block.BlockSnapshot;\nimport org.spongepowered.api.block.BlockState;\nimport org.spongepowered.api.block.BlockType;\nimport org.spongepowered.api.block.ScheduledBlockUpdate;\nimport org.spongepowered.api.data.DataContainer;\nimport org.spongepowered.api.entity.EntitySnapshot;\nimport org.spongepowered.api.entity.EntityType;\nimport org.spongepowered.api.entity.living.player.User;\nimport org.spongepowered.api.event.cause.Cause;\nimport org.spongepowered.api.event.cause.entity.spawn.BlockSpawnCause;\nimport org.spongepowered.api.event.cause.entity.spawn.SpawnTypes;\nimport org.spongepowered.api.event.entity.CollideEntityEvent;\nimport org.spongepowered.api.item.inventory.ItemStack;\nimport org.spongepowered.api.profile.GameProfile;\nimport org.spongepowered.api.service.user.UserStorageService;\nimport org.spongepowered.api.util.Direction;\nimport org.spongepowered.api.util.DiscreteTransform3;\nimport org.spongepowered.api.util.PositionOutOfBoundsException;\nimport org.spongepowered.api.util.annotation.NonnullByDefault;\nimport org.spongepowered.api.world.Chunk;\nimport org.spongepowered.api.world.Location;\nimport org.spongepowered.api.world.biome.BiomeType;\nimport org.spongepowered.api.world.extent.Extent;\nimport org.spongepowered.api.world.extent.worker.MutableBiomeAreaWorker;\nimport org.spongepowered.api.world.extent.worker.MutableBlockVolumeWorker;\nimport org.spongepowered.asm.mixin.Final;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.asm.mixin.Overwrite;\nimport org.spongepowered.asm.mixin.Shadow;\nimport org.spongepowered.asm.mixin.injection.At;\nimport org.spongepowered.asm.mixin.injection.Inject;\nimport org.spongepowered.asm.mixin.injection.callback.CallbackInfo;\nimport org.spongepowered.common.SpongeImpl;\nimport org.spongepowered.common.SpongeImplHooks;\nimport org.spongepowered.common.entity.PlayerTracker;\nimport org.spongepowered.common.event.CauseTracker;\nimport org.spongepowered.common.event.SpongeCommonEventFactory;\nimport org.spongepowered.common.interfaces.IMixinChunk;\nimport org.spongepowered.common.interfaces.entity.IMixinEntityItem;\nimport org.spongepowered.common.interfaces.world.IMixinWorld;\nimport org.spongepowered.common.interfaces.world.IMixinWorldInfo;\nimport org.spongepowered.common.interfaces.world.gen.IMixinChunkProviderServer;\nimport org.spongepowered.common.util.SpongeHooks;\nimport org.spongepowered.common.util.VecHelper;\nimport org.spongepowered.common.world.extent.ExtentViewDownsize;\nimport org.spongepowered.common.world.extent.ExtentViewTransform;\nimport org.spongepowered.common.world.extent.worker.SpongeMutableBiomeAreaWorker;\nimport org.spongepowered.common.world.extent.worker.SpongeMutableBlockVolumeWorker;\nimport org.spongepowered.common.world.storage.SpongeChunkLayout;\n\nimport java.util.Collection;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Optional;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport javax.annotation.Nullable;\n\n@NonnullByDefault\n@Mixin(net.minecraft.world.chunk.Chunk.class)\npublic abstract class MixinChunk implements Chunk, IMixinChunk {\n\n    public Map<Integer, PlayerTracker> trackedIntBlockPositions = Maps.newHashMap();\n    public Map<Short, PlayerTracker> trackedShortBlockPositions = Maps.newHashMap();\n    private Cause populateCause;\n    private org.spongepowered.api.world.World world;\n    private UUID uuid;\n    private Chunk[] clientNeighbors = new Chunk[4];\n    private Chunk[] neighbors = new Chunk[4];\n\n    private static final int NUM_XZ_BITS = 4;\n    private static final int NUM_SHORT_Y_BITS = 8;\n    private static final int NUM_INT_Y_BITS = 24;\n    private static final int Y_SHIFT = NUM_XZ_BITS;\n    private static final int Z_SHORT_SHIFT = Y_SHIFT + NUM_SHORT_Y_BITS;\n    private static final int Z_INT_SHIFT = Y_SHIFT + NUM_INT_Y_BITS;\n    private static final short XZ_MASK = 0xF;\n    private static final short Y_SHORT_MASK = 0xFF;\n    private static final int Y_INT_MASK = 0xFFFFFF;\n\n    private static final Vector2i BIOME_SIZE = SpongeChunkLayout.CHUNK_SIZE.toVector2(true);\n    private Vector3i chunkPos;\n    private Vector3i blockMin;\n    private Vector3i blockMax;\n    private Vector2i biomeMin;\n    private Vector2i biomeMax;\n\n    @Shadow @Final private World worldObj;\n    @Shadow @Final public int xPosition;\n    @Shadow @Final public int zPosition;\n    @Shadow @Final private ExtendedBlockStorage[] storageArrays;\n    @Shadow @Final private int[] precipitationHeightMap;\n    @Shadow @Final private int[] heightMap;\n    @Shadow @Final private ClassInheritanceMultiMap<Entity>[] entityLists;\n    @Shadow @Final private Map<BlockPos, TileEntity> chunkTileEntityMap;\n    @Shadow private long inhabitedTime;\n    @Shadow private boolean isChunkLoaded;\n    @Shadow private boolean isTerrainPopulated;\n    @Shadow private boolean isModified;\n\n    // @formatter:off\n    @Shadow @Nullable public abstract TileEntity getTileEntity(BlockPos pos, EnumCreateEntityType p_177424_2_);\n    @Shadow public abstract void generateSkylightMap();\n    @Shadow protected abstract void relightBlock(int x, int y, int z);\n    @Shadow public abstract int getLightFor(EnumSkyBlock p_177413_1_, BlockPos pos);\n    @Shadow protected abstract void propagateSkylightOcclusion(int x, int z);\n    @Shadow public abstract IBlockState getBlockState(BlockPos pos);\n    @Shadow public abstract BiomeGenBase getBiome(BlockPos pos, WorldChunkManager chunkManager);\n    @Shadow public abstract byte[] getBiomeArray();\n    @Shadow public abstract void setBiomeArray(byte[] biomeArray);\n    @Shadow(prefix = \"shadow$\")\n    public abstract Block shadow$getBlock(int x, int y, int z);\n    // @formatter:on\n\n    @Inject(method = \"<init>(Lnet/minecraft/world/World;II)V\", at = @At(\"RETURN\"), remap = false)\n    public void onConstructed(World world, int x, int z, CallbackInfo ci) {\n        this.chunkPos = new Vector3i(x, 0, z);\n        this.blockMin = SpongeChunkLayout.instance.toWorld(this.chunkPos).get();\n        this.blockMax = this.blockMin.add(SpongeChunkLayout.CHUNK_SIZE).sub(1, 1, 1);\n        this.biomeMin = this.blockMin.toVector2(true);\n        this.biomeMax = this.blockMax.toVector2(true);\n        this.world = (org.spongepowered.api.world.World) world;\n        if (this.world.getUniqueId() != null) { // Client worlds have no UUID\n            this.uuid = new UUID(this.world.getUniqueId().getMostSignificantBits() ^ (x * 2 + 1),\n                    this.world.getUniqueId().getLeastSignificantBits() ^ (z * 2 + 1));\n        }\n    }\n\n    @Inject(method = \"onChunkLoad()V\", at = @At(\"RETURN\"))\n    public void onChunkLoadInject(CallbackInfo ci) {\n        if (!this.worldObj.isRemote) {\n            SpongeHooks.logChunkLoad(this.worldObj, this.chunkPos);\n        }\n\n        Direction[] directions = {Direction.NORTH, Direction.SOUTH, Direction.EAST, Direction.WEST};\n        for (Direction direction : directions) {\n            Vector3i neighborPosition = this.getPosition().add(direction.toVector3d().toInt());\n            net.minecraft.world.chunk.Chunk neighbor = ((IMixinChunkProviderServer) this.worldObj.getChunkProvider()).getChunkIfLoaded\n                    (neighborPosition.getX(), neighborPosition.getZ());\n            if (neighbor != null) {\n                this.setNeighbor(direction, (Chunk) neighbor);\n                ((IMixinChunk) neighbor).setNeighbor(direction.getOpposite(), this);\n            }\n        }\n    }\n\n    @Inject(method = \"onChunkUnload()V\", at = @At(\"RETURN\"))\n    public void onChunkUnloadInject(CallbackInfo ci) {\n        if (!this.worldObj.isRemote) {\n            SpongeHooks.logChunkUnload(this.worldObj, this.chunkPos);\n        }\n\n        Direction[] directions = {Direction.NORTH, Direction.SOUTH, Direction.EAST, Direction.WEST};\n        for (Direction direction : directions) {\n            Vector3i neighborPosition = this.getPosition().add(direction.toVector3d().toInt());\n            net.minecraft.world.chunk.Chunk neighbor = ((IMixinChunkProviderServer) this.worldObj.getChunkProvider()).getChunkIfLoaded\n                    (neighborPosition.getX(), neighborPosition.getZ());\n            if (neighbor != null) {\n                this.setNeighbor(direction, null);\n                ((IMixinChunk) neighbor).setNeighbor(direction.getOpposite(), null);\n            }\n        }\n    }\n\n    @Override\n    public UUID getUniqueId() {\n        return this.uuid;\n    }\n\n    @Override\n    public Vector3i getPosition() {\n        return this.chunkPos;\n    }\n\n    @Override\n    public boolean isLoaded() {\n        return this.isChunkLoaded;\n    }\n\n    @Override\n    public boolean isPopulated() {\n        return this.isTerrainPopulated;\n    }\n\n    @Override\n    public boolean loadChunk(boolean generate) {\n        WorldServer worldserver = (WorldServer) this.worldObj;\n        net.minecraft.world.chunk.Chunk chunk = null;\n        if (worldserver.theChunkProviderServer.chunkExists(this.xPosition, this.zPosition) || generate) {\n            chunk = worldserver.theChunkProviderServer.loadChunk(this.xPosition, this.zPosition);\n        }\n\n        return chunk != null;\n    }\n\n    @Override\n    public int getInhabittedTime() {\n        return (int) this.inhabitedTime;\n    }\n\n    @Override\n    public double getRegionalDifficultyFactor() {\n        final boolean flag = this.worldObj.getDifficulty() == EnumDifficulty.HARD;\n        float moon = this.worldObj.getCurrentMoonPhaseFactor();\n        float f2 = MathHelper.clamp_float(((float) this.worldObj.getWorldTime() + -72000.0F) / 1440000.0F, 0.0F, 1.0F) * 0.25F;\n        float f3 = 0.0F;\n        f3 += MathHelper.clamp_float((float) this.inhabitedTime / 3600000.0F, 0.0F, 1.0F) * (flag ? 1.0F : 0.75F);\n        f3 += MathHelper.clamp_float(moon * 0.25F, 0.0F, f2);\n        return f3;\n    }\n\n    @Override\n    public double getRegionalDifficultyPercentage() {\n        final double region = getRegionalDifficultyFactor();\n        if (region < 2) {\n            return 0;\n        } else if (region > 4) {\n            return 1.0;\n        } else {\n            return (region - 2.0) / 2.0;\n        }\n    }\n\n    @Override\n    public org.spongepowered.api.world.World getWorld() {\n        return this.world;\n    }\n\n    @Override\n    public BiomeType getBiome(int x, int z) {\n        checkBiomeBounds(x, z);\n        return (BiomeType) getBiome(new BlockPos(x, 0, z), this.worldObj.getWorldChunkManager());\n    }\n\n    @Override\n    public void setBiome(int x, int z, BiomeType biome) {\n        checkBiomeBounds(x, z);\n        // Taken from Chunk#getBiome\n        byte[] biomeArray = getBiomeArray();\n        int i = x & 15;\n        int j = z & 15;\n        biomeArray[j << 4 | i] = (byte) (((BiomeGenBase) biome).biomeID & 255);\n        setBiomeArray(biomeArray);\n    }\n\n    @Override\n    public BlockState getBlock(int x, int y, int z) {\n        checkBlockBounds(x, y, z);\n        return (BlockState) getBlockState(new BlockPos(x, y, z));\n    }\n\n    @Override\n    public void setBlock(int x, int y, int z, BlockState block) {\n        checkBlockBounds(x, y, z);\n        SpongeHooks.setBlockState((net.minecraft.world.chunk.Chunk) (Object) this, x, y, z, block, false);\n    }\n\n    @Override\n    public void setBlock(int x, int y, int z, BlockState block, boolean notifyNeighbors) {\n        SpongeHooks.setBlockState((net.minecraft.world.chunk.Chunk) (Object) this, this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15),\n                block, notifyNeighbors);\n    }\n\n    @Override\n    public BlockType getBlockType(int x, int y, int z) {\n        checkBlockBounds(x, y, z);\n        return (BlockType) shadow$getBlock(x, y, z);\n    }\n\n    @Override\n    public BlockSnapshot createSnapshot(int x, int y, int z) {\n        return this.world.createSnapshot(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15));\n    }\n\n    @Override\n    public boolean restoreSnapshot(BlockSnapshot snapshot, boolean force, boolean notifyNeighbors) {\n        return this.world.restoreSnapshot(snapshot, force, notifyNeighbors);\n    }\n\n    @Override\n    public boolean restoreSnapshot(int x, int y, int z, BlockSnapshot snapshot, boolean force, boolean notifyNeighbors) {\n        return this.world.restoreSnapshot(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), snapshot, force, notifyNeighbors);\n    }\n\n    @Override\n    public Vector2i getBiomeMin() {\n        return this.biomeMin;\n    }\n\n    @Override\n    public Vector2i getBiomeMax() {\n        return this.biomeMax;\n    }\n\n    @Override\n    public Vector2i getBiomeSize() {\n        return BIOME_SIZE;\n    }\n\n    @Override\n    public Vector3i getBlockMin() {\n        return this.blockMin;\n    }\n\n    @Override\n    public Vector3i getBlockMax() {\n        return this.blockMax;\n    }\n\n    @Override\n    public Vector3i getBlockSize() {\n        return SpongeChunkLayout.CHUNK_SIZE;\n    }\n\n    @Override\n    public boolean containsBiome(int x, int z) {\n        return VecHelper.inBounds(x, z, this.biomeMin, this.biomeMax);\n    }\n\n    @Override\n    public boolean containsBlock(int x, int y, int z) {\n        return VecHelper.inBounds(x, y, z, this.blockMin, this.blockMax);\n    }\n\n    private void checkBiomeBounds(int x, int z) {\n        if (!containsBiome(x, z)) {\n            throw new PositionOutOfBoundsException(new Vector2i(x, z), this.biomeMin, this.biomeMax);\n        }\n    }\n\n    private void checkBlockBounds(int x, int y, int z) {\n        if (!containsBlock(x, y, z)) {\n            throw new PositionOutOfBoundsException(new Vector3i(x, y, z), this.blockMin, this.blockMax);\n        }\n    }\n\n    @Override\n    public Extent getExtentView(Vector3i newMin, Vector3i newMax) {\n        checkBlockBounds(newMin.getX(), newMin.getY(), newMin.getZ());\n        checkBlockBounds(newMax.getX(), newMax.getY(), newMax.getZ());\n        return new ExtentViewDownsize(this, newMin, newMax);\n    }\n\n    @Override\n    public Extent getExtentView(DiscreteTransform3 transform) {\n        return new ExtentViewTransform(this, transform);\n    }\n\n    @Override\n    public MutableBiomeAreaWorker<? extends Chunk> getBiomeWorker() {\n        return new SpongeMutableBiomeAreaWorker<>(this);\n    }\n\n    @Override\n    public MutableBlockVolumeWorker<? extends Chunk> getBlockWorker() {\n        return new SpongeMutableBlockVolumeWorker<>(this);\n    }\n\n    @SuppressWarnings({\"unchecked\"})\n    @Inject(method = \"getEntitiesWithinAABBForEntity\", at = @At(value = \"RETURN\"))\n    public void onGetEntitiesWithinAABBForEntity(Entity entityIn, AxisAlignedBB aabb, List<Entity> listToFill, Predicate<Entity> p_177414_4_,\n            CallbackInfo ci) {\n        final CauseTracker causeTracker = ((IMixinWorld) this.worldObj).getCauseTracker();\n        if (this.worldObj.isRemote || causeTracker.getCurrentCause() == null || causeTracker.isProcessingVanillaBlockEvent() || causeTracker.isRestoringBlocks() || causeTracker.isWorldSpawnerRunning() || causeTracker.isChunkSpawnerRunning()\n                || causeTracker.isCapturingTerrainGen()) {\n            return;\n        }\n\n        if (listToFill.size() == 0) {\n            return;\n        }\n\n        CollideEntityEvent event = SpongeCommonEventFactory.callCollideEntityEvent(this.worldObj, entityIn, listToFill);\n        if (event == null) {\n            return;\n        } else if (event.isCancelled()) {\n            listToFill.clear();\n        } else {\n            listToFill = (List<net.minecraft.entity.Entity>) (List<?>) event.getEntities();\n        }\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Inject(method = \"getEntitiesOfTypeWithinAAAB\", at = @At(value = \"RETURN\"))\n    public void onGetEntitiesOfTypeWithinAAAB(Class<? extends Entity> entityClass, AxisAlignedBB aabb, List listToFill, Predicate<Entity> p_177430_4_,\n            CallbackInfo ci) {\n        final CauseTracker causeTracker = ((IMixinWorld) this.worldObj).getCauseTracker();\n        if (this.worldObj.isRemote || causeTracker.getCurrentCause() == null || causeTracker.isProcessingVanillaBlockEvent() || causeTracker.isRestoringBlocks() || causeTracker.isWorldSpawnerRunning() || causeTracker.isChunkSpawnerRunning()\n                || causeTracker.isCapturingTerrainGen()) {\n            return;\n        }\n\n        if (listToFill.size() == 0) {\n            return;\n        }\n\n        CollideEntityEvent event = SpongeCommonEventFactory.callCollideEntityEvent(this.worldObj, null, listToFill);\n        if (event == null) {\n            return;\n        } else if (event.isCancelled()) {\n            listToFill.clear();\n        } else {\n            listToFill = (List<net.minecraft.entity.Entity>) (List<?>) event.getEntities();\n        }\n    }\n\n    @Override\n    public Cause getCurrentPopulateCause() {\n        return this.populateCause;\n    }\n\n    /**\n     * @author blood\n     * @reason cause tracking\n     *\n     * @param pos The position to set\n     * @param state The state to set\n     * @return The changed state\n     */\n    @Overwrite\n    public IBlockState setBlockState(BlockPos pos, IBlockState state) {\n        IBlockState iblockstate1 = this.getBlockState(pos);\n\n        if (iblockstate1 == state) {\n            return null;\n        }\n        // Sponge - reroute to new method that accepts snapshot to prevent a second snapshot from being created.\n        return setBlockState(pos, state, iblockstate1, null);\n    }\n\n    @Override\n    public IBlockState setBlockState(BlockPos pos, IBlockState newState, IBlockState currentState, BlockSnapshot originalBlockSnapshot) {\n        int i = pos.getX() & 15;\n        int j = pos.getY();\n        int k = pos.getZ() & 15;\n        int l = k << 4 | i;\n\n        if (j >= this.precipitationHeightMap[l] - 1) {\n            this.precipitationHeightMap[l] = -999;\n        }\n\n        int i1 = this.heightMap[l];\n\n        // Sponge - remove blockstate check as we handle it in world.setBlockState\n        Block block = newState.getBlock();\n        Block block1 = currentState.getBlock();\n        ExtendedBlockStorage extendedblockstorage = this.storageArrays[j >> 4];\n        boolean flag = false;\n\n        if (extendedblockstorage == null) {\n            if (block == Blocks.air) {\n                return null;\n            }\n\n            extendedblockstorage = this.storageArrays[j >> 4] = new ExtendedBlockStorage(j >> 4 << 4, !this.worldObj.provider.getHasNoSky());\n            flag = j >= i1;\n        }\n\n        int j1 = SpongeImplHooks.getBlockLightOpacity(block, this.worldObj, pos);\n\n        extendedblockstorage.set(i, j & 15, k, newState);\n\n        // if (block1 != block)\n        {\n            if (!this.worldObj.isRemote) {\n                // Only fire block breaks when the block changes.\n                if (currentState.getBlock() != newState.getBlock()) {\n                    final CauseTracker causeTracker = ((IMixinWorld) this.worldObj).getCauseTracker();\n                    if (causeTracker.isRestoringBlocks() || causeTracker.isCapturingTerrainGen()) {\n                        block1.breakBlock(this.worldObj, pos, currentState);\n                    } else {\n                        // Make sure to capture spawned items during block breaks so we can handle them properly after events\n                        int preSize = causeTracker.getCapturedSpawnedEntityItems().size();\n                        causeTracker.setCaptureSpawnedEntities(true);\n                        block1.breakBlock(this.worldObj, pos, currentState);\n                        int postSize = causeTracker.getCapturedSpawnedEntityItems().size();\n                        if (preSize != postSize && postSize > preSize) {\n                            // add spawn causes for newly captured items\n                            for (int x = preSize; x < postSize; x++) {\n                                EntityItem entityitem = (EntityItem) causeTracker.getCapturedSpawnedEntityItems().get(x);\n                                BlockSnapshot blockSnapshot = originalBlockSnapshot;\n                                if (blockSnapshot == null) {\n                                    Location<org.spongepowered.api.world.World> location = new Location<>((org.spongepowered.api.world.World) this.worldObj, VecHelper.toVector(pos));\n                                    blockSnapshot = BlockSnapshot.builder().from(location).blockState((BlockState) currentState).build();\n                                }\n                                BlockSpawnCause spawnCause = BlockSpawnCause.builder()\n                                        .block(blockSnapshot)\n                                        .type(SpawnTypes.DROPPED_ITEM)\n                                        .build();\n                                IMixinEntityItem spongeItem = (IMixinEntityItem) entityitem;\n                                spongeItem.setSpawnCause(spawnCause);\n                                spongeItem.setSpawnedFromBlockBreak(true);\n                            }\n                        }\n                        causeTracker.setCaptureSpawnedEntities(false);\n                    }\n                }\n                TileEntity te = this.getTileEntity(pos, EnumCreateEntityType.CHECK);\n                if (te != null && SpongeImplHooks.shouldRefresh(te, this.worldObj, pos, currentState, newState)) {\n                    this.worldObj.removeTileEntity(pos);\n                }\n            } else if (SpongeImplHooks.blockHasTileEntity(block1, currentState)) {\n                TileEntity te = this.getTileEntity(pos, EnumCreateEntityType.CHECK);\n                if (te != null && SpongeImplHooks.shouldRefresh(te, this.worldObj, pos, currentState, newState)) {\n                    this.worldObj.removeTileEntity(pos);\n                }\n            }\n        }\n\n        if (extendedblockstorage.getBlockByExtId(i, j & 15, k) != block) {\n            return null;\n        } else {\n            if (flag) {\n                this.generateSkylightMap();\n            } else {\n                int k1 = SpongeImplHooks.getBlockLightOpacity(block, this.worldObj, pos);\n\n                if (j1 > 0) {\n                    if (j >= i1) {\n                        this.relightBlock(i, j + 1, k);\n                    }\n                } else if (j == i1 - 1) {\n                    this.relightBlock(i, j, k);\n                }\n\n                if (j1 != k1 && (j1 < k1 || this.getLightFor(EnumSkyBlock.SKY, pos) > 0 || this.getLightFor(EnumSkyBlock.BLOCK, pos) > 0)) {\n                    this.propagateSkylightOcclusion(i, k);\n                }\n            }\n\n            TileEntity tileentity;\n\n            if (!this.worldObj.isRemote && block1 != block) {\n                // Sponge start - Ignore block activations during block placement captures unless it's\n                // a BlockContainer. Prevents blocks such as TNT from activating when\n                // cancelled.\n                if (!((IMixinWorld) this.worldObj).getCauseTracker().isCapturingBlocks() || SpongeImplHooks.blockHasTileEntity(block, newState)) {\n                    block.onBlockAdded(this.worldObj, pos, newState);\n                }\n                // Sponge end\n            }\n\n            if (SpongeImplHooks.blockHasTileEntity(block, newState)) {\n                tileentity = this.getTileEntity(pos, EnumCreateEntityType.CHECK);\n\n                if (tileentity == null) {\n                    tileentity = SpongeImplHooks.createTileEntity(block, this.worldObj, newState);\n                    this.worldObj.setTileEntity(pos, tileentity);\n                }\n\n                if (tileentity != null) {\n                    tileentity.updateContainingBlockInfo();\n                }\n            }\n\n            this.isModified = true;\n            return currentState;\n        }\n    }\n\n    @Override\n    public void addTrackedBlockPosition(Block block, BlockPos pos, User user, PlayerTracker.Type trackerType) {\n        if (this.worldObj.isRemote || !SpongeHooks.getActiveConfig(this.worldObj).getConfig().getBlockTracking().isEnabled()) {\n            return;\n        } else {\n            IMixinWorld spongeWorld = (IMixinWorld) this.worldObj;\n            if (spongeWorld.getCauseTracker().isCapturingTerrainGen()) {\n                // Don't track chunk gen\n                return;\n            }\n        }\n\n        if (!SpongeHooks.getActiveConfig(this.worldObj).getConfig().getBlockTracking().getBlockBlacklist().contains(((BlockType) block).getId())) {\n            SpongeHooks.logBlockTrack(this.worldObj, block, pos, user, true);\n        } else {\n            SpongeHooks.logBlockTrack(this.worldObj, block, pos, user, false);\n        }\n\n        if (pos.getY() <= 255) {\n            short blockPos = blockPosToShort(pos);\n            if (this.trackedShortBlockPositions.get(blockPos) != null) {\n                if (trackerType == PlayerTracker.Type.OWNER) {\n                    this.trackedShortBlockPositions.get(blockPos).ownerIndex =\n                            ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId());\n                    this.trackedShortBlockPositions.get(blockPos).notifierIndex =\n                            ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId());\n                } else {\n                    this.trackedShortBlockPositions.get(blockPos).notifierIndex =\n                            ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId());\n                }\n            } else {\n                this.trackedShortBlockPositions.put(blockPos,\n                        new PlayerTracker(((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId()), trackerType));\n            }\n        } else {\n            int blockPos = blockPosToInt(pos);\n            if (this.trackedIntBlockPositions.get(blockPos) != null) {\n                if (trackerType == PlayerTracker.Type.OWNER) {\n                    this.trackedIntBlockPositions.get(blockPos).ownerIndex =\n                            ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId());\n                } else {\n                    this.trackedIntBlockPositions.get(blockPos).notifierIndex =\n                            ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId());\n                }\n            } else {\n                this.trackedIntBlockPositions.put(blockPos,\n                        new PlayerTracker(((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(user.getUniqueId()), trackerType));\n            }\n        }\n    }\n\n    @Override\n    public Map<Integer, PlayerTracker> getTrackedIntPlayerPositions() {\n        return this.trackedIntBlockPositions;\n    }\n\n    @Override\n    public Map<Short, PlayerTracker> getTrackedShortPlayerPositions() {\n        return this.trackedShortBlockPositions;\n    }\n\n    @Override\n    public Optional<User> getBlockOwner(BlockPos pos) {\n        if (this.trackedIntBlockPositions.get(blockPosToInt(pos)) != null) {\n            PlayerTracker tracker = this.trackedIntBlockPositions.get(blockPosToInt(pos));\n            Optional<UUID> uuid = (((IMixinWorldInfo) this.worldObj.getWorldInfo()).getUniqueIdForIndex(tracker.ownerIndex));\n            if (uuid.isPresent()) {\n                // get player if online\n                EntityPlayer player = this.worldObj.getPlayerEntityByUUID(uuid.get());\n                if (player != null) {\n                    return Optional.of((User) player);\n                }\n                // player is not online, get or create user from storage\n                return Optional.of(this.userForUUID(uuid.get()));\n            }\n        } else if (this.trackedShortBlockPositions.get(blockPosToShort(pos)) != null) {\n            PlayerTracker tracker = this.trackedShortBlockPositions.get(blockPosToShort(pos));\n            Optional<UUID> uuid = (((IMixinWorldInfo) this.worldObj.getWorldInfo()).getUniqueIdForIndex(tracker.ownerIndex));\n            if (uuid.isPresent()) {\n                // get player if online\n                EntityPlayer player = this.worldObj.getPlayerEntityByUUID(uuid.get());\n                if (player != null) {\n                    return Optional.of((User) player);\n                }\n                // player is not online, get or create user from storage\n                return Optional.of(this.userForUUID(uuid.get()));\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    @Override\n    public Optional<User> getBlockNotifier(BlockPos pos) {\n        if (this.trackedIntBlockPositions.get(blockPosToInt(pos)) != null) {\n            PlayerTracker tracker = this.trackedIntBlockPositions.get(blockPosToInt(pos));\n            Optional<UUID> uuid = (((IMixinWorldInfo) this.worldObj.getWorldInfo()).getUniqueIdForIndex(tracker.notifierIndex));\n            if (uuid.isPresent()) {\n                // get player if online\n                EntityPlayer player = this.worldObj.getPlayerEntityByUUID(uuid.get());\n                if (player != null) {\n                    return Optional.of((User) player);\n                }\n                // player is not online, get or create user from storage\n                return Optional.of(this.userForUUID(uuid.get()));\n            }\n        } else if (this.trackedShortBlockPositions.get(blockPosToShort(pos)) != null) {\n            PlayerTracker tracker = this.trackedShortBlockPositions.get(blockPosToShort(pos));\n            Optional<UUID> uuid = (((IMixinWorldInfo) this.worldObj.getWorldInfo()).getUniqueIdForIndex(tracker.notifierIndex));\n            if (uuid.isPresent()) {\n                // get player if online\n                EntityPlayer player = this.worldObj.getPlayerEntityByUUID(uuid.get());\n                if (player != null) {\n                    return Optional.of((User) player);\n                }\n                // player is not online, get or create user from storage\n                return Optional.of(this.userForUUID(uuid.get()));\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    // Special setter used by API\n    @Override\n    public void setBlockNotifier(BlockPos pos, UUID uuid) {\n        if (pos.getY() <= 255) {\n            short blockPos = blockPosToShort(pos);\n            if (this.trackedShortBlockPositions.get(blockPos) != null) {\n                this.trackedShortBlockPositions.get(blockPos).notifierIndex = uuid == null ? -1 :\n                        ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(uuid);\n            } else {\n                this.trackedShortBlockPositions.put(blockPos,\n                        new PlayerTracker(uuid == null ? -1 : ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(uuid),\n                                PlayerTracker.Type.NOTIFIER));\n            }\n        } else {\n            int blockPos = blockPosToInt(pos);\n            if (this.trackedIntBlockPositions.get(blockPos) != null) {\n                this.trackedIntBlockPositions.get(blockPos).notifierIndex = uuid == null ? -1 :\n                        ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(uuid);\n            } else {\n                this.trackedIntBlockPositions.put(blockPos,\n                        new PlayerTracker(uuid == null ? -1 : ((IMixinWorldInfo) this.worldObj.getWorldInfo()).getIndexForUniqueId(uuid),\n                                PlayerTracker.Type.NOTIFIER));\n            }\n        }\n    }\n\n    // Special setter used by API\n    @Override\n    public void setBlockCreator(BlockPos pos, UUID uuid) {\n        if (pos.getY() <= 255) {\n            short blockPos = blockPosToShort(pos);\n            if (this.trackedShortBlockPositions.get(blockPos) != null) {\n                this.trackedShortBlockPositions.get(blockPos).ownerIndex = uuid == null ? -1 : ((IMixinWorldInfo) this.worldObj.getWorldInfo())\n                        .getIndexForUniqueId(uuid);\n            } else {\n                this.trackedShortBlockPositions.put(blockPos, new PlayerTracker(uuid == null ? -1 : ((IMixinWorldInfo) this.worldObj.getWorldInfo())\n                        .getIndexForUniqueId(uuid), PlayerTracker.Type.OWNER));\n            }\n        } else {\n            int blockPos = blockPosToInt(pos);\n            if (this.trackedIntBlockPositions.get(blockPos) != null) {\n                this.trackedIntBlockPositions.get(blockPos).ownerIndex = uuid == null ? -1 : ((IMixinWorldInfo) this.worldObj.getWorldInfo())\n                        .getIndexForUniqueId(uuid);\n            } else {\n                this.trackedIntBlockPositions.put(blockPos, new PlayerTracker(uuid == null ? -1 : ((IMixinWorldInfo) this.worldObj.getWorldInfo())\n                        .getIndexForUniqueId(uuid), PlayerTracker.Type.OWNER));\n            }\n        }\n    }\n\n    @Override\n    public void setTrackedIntPlayerPositions(Map<Integer, PlayerTracker> trackedPositions) {\n        this.trackedIntBlockPositions = trackedPositions;\n    }\n\n    @Override\n    public void setTrackedShortPlayerPositions(Map<Short, PlayerTracker> trackedPositions) {\n        this.trackedShortBlockPositions = trackedPositions;\n    }\n\n    /**\n     * Modifies bits in an integer.\n     *\n     * @param num Integer to modify\n     * @param data Bits of data to add\n     * @param which Index of nibble to start at\n     * @param bitsToReplace The number of bits to replace starting from nibble index\n     * @return The modified integer\n     */\n    public int setNibble(int num, int data, int which, int bitsToReplace) {\n        return (num & ~(bitsToReplace << (which * 4)) | (data << (which * 4)));\n    }\n\n    /**\n     * Serialize this BlockPos into a short value\n     */\n    public short blockPosToShort(BlockPos pos) {\n        short serialized = (short) setNibble(0, pos.getX() & XZ_MASK, 0, NUM_XZ_BITS);\n        serialized = (short) setNibble(serialized, pos.getY() & Y_SHORT_MASK, 1, NUM_SHORT_Y_BITS);\n        serialized = (short) setNibble(serialized, pos.getZ() & XZ_MASK, 3, NUM_XZ_BITS);\n        return serialized;\n    }\n\n    /**\n     * Create a BlockPos from a serialized chunk position\n     */\n    public BlockPos blockPosFromShort(short serialized) {\n        int x = this.xPosition * 16 + (serialized & XZ_MASK);\n        int y = (serialized >> Y_SHIFT) & Y_SHORT_MASK;\n        int z = this.zPosition * 16 + ((serialized >> Z_SHORT_SHIFT) & XZ_MASK);\n        return new BlockPos(x, y, z);\n    }\n\n    /**\n     * Serialize this BlockPos into an int value\n     */\n    public int blockPosToInt(BlockPos pos) {\n        int serialized = setNibble(0, pos.getX() & XZ_MASK, 0, NUM_XZ_BITS);\n        serialized = setNibble(serialized, pos.getY() & Y_INT_MASK, 1, NUM_INT_Y_BITS);\n        serialized = setNibble(serialized, pos.getZ() & XZ_MASK, 7, NUM_XZ_BITS);\n        return serialized;\n    }\n\n    /**\n     * Create a BlockPos from a serialized chunk position\n     */\n    public BlockPos blockPosFromInt(int serialized) {\n        int x = this.xPosition * 16 + (serialized & XZ_MASK);\n        int y = (serialized >> Y_SHIFT) & Y_INT_MASK;\n        int z = this.zPosition * 16 + ((serialized >> Z_INT_SHIFT) & XZ_MASK);\n        return new BlockPos(x, y, z);\n    }\n\n    @Override\n    public Optional<org.spongepowered.api.entity.Entity> createEntity(EntityType type, Vector3d position) {\n        return this.world.createEntity(type, this.chunkPos.mul(16).toDouble().add(position.min(15, this.blockMax.getY(), 15)));\n    }\n\n    @Override\n    public Optional<org.spongepowered.api.entity.Entity> createEntity(DataContainer entityContainer) {\n        return this.world.createEntity(entityContainer);\n    }\n\n    @Override\n    public Optional<org.spongepowered.api.entity.Entity> createEntity(DataContainer entityContainer, Vector3d position) {\n        return this.world.createEntity(entityContainer, this.chunkPos.mul(16).toDouble().add(position.min(15, this.blockMax.getY(), 15)));\n    }\n\n    @Override\n    public boolean spawnEntity(org.spongepowered.api.entity.Entity entity, Cause cause) {\n        return this.world.spawnEntity(entity, cause);\n    }\n\n    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n    @Override\n    public Collection<org.spongepowered.api.entity.Entity> getEntities() {\n        Set<org.spongepowered.api.entity.Entity> entities = Sets.newHashSet();\n        for (ClassInheritanceMultiMap entityList : this.entityLists) {\n            entities.addAll(entityList);\n        }\n        return entities;\n    }\n\n    @Override\n    public Collection<org.spongepowered.api.entity.Entity> getEntities(java.util.function.Predicate<org.spongepowered.api.entity.Entity> filter) {\n        Set<org.spongepowered.api.entity.Entity> entities = Sets.newHashSet();\n        for (ClassInheritanceMultiMap<Entity> entityClassMap : this.entityLists) {\n            for (Object entity : entityClassMap) {\n                if (filter.test((org.spongepowered.api.entity.Entity) entity)) {\n                    entities.add((org.spongepowered.api.entity.Entity) entity);\n                }\n            }\n        }\n        return entities;\n    }\n\n    @SuppressWarnings({\"rawtypes\", \"unchecked\"})\n    @Override\n    public Collection<org.spongepowered.api.block.tileentity.TileEntity> getTileEntities() {\n        return Sets.newHashSet((Collection) this.chunkTileEntityMap.values());\n    }\n\n    @Override\n    public Collection<org.spongepowered.api.block.tileentity.TileEntity>\n    getTileEntities(java.util.function.Predicate<org.spongepowered.api.block.tileentity.TileEntity> filter) {\n        Set<org.spongepowered.api.block.tileentity.TileEntity> tiles = Sets.newHashSet();\n        for (Entry<BlockPos, TileEntity> entry : this.chunkTileEntityMap.entrySet()) {\n            if (filter.test((org.spongepowered.api.block.tileentity.TileEntity) entry.getValue())) {\n                tiles.add((org.spongepowered.api.block.tileentity.TileEntity) entry.getValue());\n            }\n        }\n        return tiles;\n    }\n\n    @Override\n    public Optional<org.spongepowered.api.block.tileentity.TileEntity> getTileEntity(int x, int y, int z) {\n        return Optional.ofNullable((org.spongepowered.api.block.tileentity.TileEntity) this.getTileEntity(\n                new BlockPos(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15)), EnumCreateEntityType.CHECK));\n    }\n\n    @Override\n    public Optional<org.spongepowered.api.entity.Entity> restoreSnapshot(EntitySnapshot snapshot, Vector3d position) {\n        return this.world.restoreSnapshot(snapshot, position);\n    }\n\n    @Override\n    public Collection<ScheduledBlockUpdate> getScheduledUpdates(int x, int y, int z) {\n        return this.world.getScheduledUpdates(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15));\n    }\n\n    @Override\n    public ScheduledBlockUpdate addScheduledUpdate(int x, int y, int z, int priority, int ticks) {\n        return this.world.addScheduledUpdate(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), priority, ticks);\n    }\n\n    @Override\n    public void removeScheduledUpdate(int x, int y, int z, ScheduledBlockUpdate update) {\n        this.world.removeScheduledUpdate(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), update);\n    }\n\n    @Override\n    public boolean hitBlock(int x, int y, int z, Direction side, Cause cause) {\n        return this.world.hitBlock(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), side, cause);\n    }\n\n    @Override\n    public boolean interactBlock(int x, int y, int z, Direction side, Cause cause) {\n        return this.world.interactBlock(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), side, cause);\n    }\n\n    @Override\n    public boolean placeBlock(int x, int y, int z, BlockState block, Direction side, Cause cause) {\n        return this.world.placeBlock(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), block, side, cause);\n    }\n\n    @Override\n    public boolean interactBlockWith(int x, int y, int z, ItemStack itemStack, Direction side, Cause cause) {\n        return this.world.interactBlockWith(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), itemStack, side, cause);\n    }\n\n    @Override\n    public boolean digBlock(int x, int y, int z, Cause cause) {\n        return this.world.digBlock(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), cause);\n    }\n\n    @Override\n    public boolean digBlockWith(int x, int y, int z, ItemStack itemStack, Cause cause) {\n        return this.world.digBlockWith(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), itemStack, cause);\n    }\n\n    @Override\n    public int getBlockDigTimeWith(int x, int y, int z, ItemStack itemStack, Cause cause) {\n        return this.world.getBlockDigTimeWith(this.xPosition << 4 + (x & 15), y, this.zPosition << 4 + (z & 15), itemStack, cause);\n    }\n\n    private User userForUUID(UUID uuid) {\n        return SpongeImpl.getGame().getServiceManager().provide(UserStorageService.class).get().getOrCreate(GameProfile.of(uuid, null));\n    }\n\n    @Override\n    public void setNeighbor(Direction direction, @Nullable Chunk neighbor) {\n        if (this.worldObj.isRemote) {\n            this.clientNeighbors[directionToIndex(direction)] = neighbor;\n        } else {\n            this.neighbors[directionToIndex(direction)] = neighbor;\n        }\n    }\n\n    @Override\n    public Optional<Chunk> getNeighbor(Direction direction, boolean shouldLoad) {\n        checkNotNull(direction, \"direction\");\n        checkArgument(!direction.isSecondaryOrdinal(), \"Secondary cardinal directions can't be used here\");\n\n        if (direction.isUpright() || direction == Direction.NONE) {\n            return Optional.of(this);\n        }\n\n        int index = directionToIndex(direction);\n        Direction secondary = getSecondaryDirection(direction);\n        Chunk neighbor = null;\n        if (this.worldObj.isRemote) {\n            neighbor = this.clientNeighbors[index];\n        } else {\n            neighbor = this.neighbors[index];\n        }\n\n        if (neighbor == null && shouldLoad) {\n            Vector3i neighborPosition = this.getPosition().add(getCardinalDirection(direction).toVector3d().toInt());\n            Optional<Chunk> cardinal = this.getWorld().loadChunk(neighborPosition, true);\n            if (cardinal.isPresent()) {\n                neighbor = cardinal.get();\n            }\n        }\n\n        if (neighbor != null) {\n            if (secondary != Direction.NONE) {\n                return neighbor.getNeighbor(secondary, shouldLoad);\n            } else {\n                return Optional.of(neighbor);\n            }\n        }\n\n        return Optional.empty();\n    }\n\n    private static int directionToIndex(Direction direction) {\n        switch (direction) {\n            case NORTH:\n            case NORTHEAST:\n            case NORTHWEST:\n                return 0;\n            case SOUTH:\n            case SOUTHEAST:\n            case SOUTHWEST:\n                return 1;\n            case EAST:\n                return 2;\n            case WEST:\n                return 3;\n            default:\n                throw new IllegalArgumentException(\"Unexpected direction\");\n        }\n    }\n\n    private static Direction getCardinalDirection(Direction direction) {\n        switch (direction) {\n            case NORTH:\n            case NORTHEAST:\n            case NORTHWEST:\n                return Direction.NORTH;\n            case SOUTH:\n            case SOUTHEAST:\n            case SOUTHWEST:\n                return Direction.SOUTH;\n            case EAST:\n                return Direction.EAST;\n            case WEST:\n                return Direction.WEST;\n            default:\n                throw new IllegalArgumentException(\"Unexpected direction\");\n        }\n    }\n\n    private static Direction getSecondaryDirection(Direction direction) {\n        switch (direction) {\n            case NORTHEAST:\n            case SOUTHEAST:\n                return Direction.EAST;\n            case NORTHWEST:\n            case SOUTHWEST:\n                return Direction.WEST;\n            default:\n                return Direction.NONE;\n        }\n    }\n\n}\n", " of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.xeiam.xchange.anx.v2.dto.trade.polling;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Data object representing a response message from ANX after placing and order\n */\npublic final class ANXGenericResponse {\n\n  private final String result;\n  private final Object data;\n  private final String error;\n\n  /**\n   * Constructor\n   * \n   * @param result\n   * @param data\n   * @param error\n   */\n  public ANXGenericResponse(@JsonProperty(\"result\") String result, @JsonProperty(\"data\") Object data, @JsonProperty(\"error\") String error) {\n\n    this.result = result;\n    this.data = data;\n    this.error = error;\n  }\n\n  public String getResult() {\n\n    return result;\n  }\n\n  public Object getData() {\n\n    return data;\n  }\n\n  public String getError() {\n\n    return error;\n  }\n\n  public String getDataString() {\n\n    return data == null ? null : data.toString();\n  }\n\n  @Override\n  public String toString() {\n\n    return \"ANXGenericResponse [result=\" + result + \", data=\" + data + \", error=\" + error + \"]\";\n  }\n\n}\n", "CE: wilcox3g\n * MODEL: SM-G3818\n */\nfinal class wilcox3g {\n    public static final String DATA = \"Samsung|Galaxy Win Pro|\";\n}\n", " java.net.URISyntaxException;\nimport java.net.URL;\n\n/**\n * @author idok\n */\npublic final class TestUtils {\n\n    private TestUtils() {\n    }\n\n    private static final Logger LOG = Logger.getInstance(TestUtils.class);\n\n    private static String TEST_DATA_PATH;\n\n    public static String getTestDataPath() {\n        if (TEST_DATA_PATH == null) {\n            ClassLoader loader = TestUtils.class.getClassLoader();\n            URL resource = loader.getResource(\"testData\");\n            try {\n                TEST_DATA_PATH = new File(\"testData\").getAbsolutePath();\n                if (resource != null) {\n                    TEST_DATA_PATH = new File(resource.toURI()).getPath().replace(File.separatorChar, '/');\n                }\n            } catch (URISyntaxException e) {\n                LOG.error(e);\n                return null;\n            }\n        }\n        return TEST_DATA_PATH;\n    }\n}\n", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.lee.util.comparator;\n\nimport java.util.Comparator;\n\n/**\n * Comparator that adapts Comparables to the Comparator interface. Mainly for internal use in other Comparators, when\n * supposed to work on Comparables.\n *\n * @author Keith Donald\n * @since 1.2.2\n * @see Comparable\n */\npublic class ComparableComparator<T extends Comparable<T>> implements Comparator<T> {\n\n    @SuppressWarnings(\"rawtypes\")\n    public static final ComparableComparator INSTANCE = new ComparableComparator();\n\n    @Override\n    public int compare(T o1, T o2) {\n        return o1.compareTo(o2);\n    }\n\n}\n", "ject;\nimport CIM.IEC61970.Core.PowerSystemResource;\n\nimport CIM.IEC61970.SCADA.*;\n\nimport org.eclipse.emf.ecore.EObject;\nimport org.eclipse.emf.ecore.EPackage;\n\nimport org.eclipse.emf.ecore.util.Switch;\n\n/**\n * <!-- begin-user-doc -->\n * The <b>Switch</b> for the model's inheritance hierarchy.\n * It supports the call {@link #doSwitch(EObject) doSwitch(object)}\n * to invoke the <code>caseXXX</code> method for each class of the model,\n * starting with the actual class of the object\n * and proceeding up the inheritance hierarchy\n * until a non-null result is returned,\n * which is the result of the switch.\n * <!-- end-user-doc -->\n * @see CIM.IEC61970.SCADA.SCADAPackage\n * @generated\n */\npublic class SCADASwitch<T> extends Switch<T> {\n\t/**\n\t * The cached model package\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tprotected static SCADAPackage modelPackage;\n\n\t/**\n\t * Creates an instance of the switch.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @generated\n\t */\n\tpublic SCADASwitch() {\n\t\tif (modelPackage == null) {\n\t\t\tmodelPackage = SCADAPackage.eINSTANCE;\n\t\t}\n\t}\n\n\t/**\n\t * Checks whether this is a switch for the given package.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @param ePackage the package in question.\n\t * @return whether this is a switch for the given package.\n\t * @generated\n\t */\n\t@Override\n\tprotected boolean isSwitchFor(EPackage ePackage) {\n\t\treturn ePackage == modelPackage;\n\t}\n\n\t/**\n\t * Calls <code>caseXXX</code> for each class of the model until one returns a non null result; it yields that result.\n\t * <!-- begin-user-doc -->\n\t * <!-- end-user-doc -->\n\t * @return the first non-null result returned by a <code>caseXXX</code> call.\n\t * @generated\n\t */\n\t@Override\n\tprotected T doSwitch(int classifierID, EObject theEObject) {\n\t\tswitch (classifierID) {\n\t\t\tcase SCADAPackage.COMMUNICATION_LINK: {\n\t\t\t\tCommunicationLink communicationLink = (CommunicationLink)theEObject;\n\t\t\t\tT result = caseCommunicationLink(communicationLink);\n\t\t\t\tif (result == null) result = casePowerSystemResource(communicationLink);\n\t\t\t\tif (result == null) result = caseIdentifiedObject(communicationLink);\n\t\t\t\tif (result == null) result = caseElement(communicationLink);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase SCADAPackage.REMOTE_POINT: {\n\t\t\t\tRemotePoint remotePoint = (RemotePoint)theEObject;\n\t\t\t\tT result = caseRemotePoint(remotePoint);\n\t\t\t\tif (result == null) result = caseIdentifiedObject(remotePoint);\n\t\t\t\tif (result == null) result = caseElement(remotePoint);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase SCADAPackage.REMOTE_UNIT: {\n\t\t\t\tRemoteUnit remoteUnit = (RemoteUnit)theEObject;\n\t\t\t\tT result = caseRemoteUnit(remoteUnit);\n\t\t\t\tif (result == null) result = casePowerSystemResource(remoteUnit);\n\t\t\t\tif (result == null) result = caseIdentifiedObject(remoteUnit);\n\t\t\t\tif (result == null) result = caseElement(remoteUnit);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase SCADAPackage.REMOTE_CONTROL: {\n\t\t\t\tRemoteControl remoteControl = (RemoteControl)theEObject;\n\t\t\t\tT result = caseRemoteControl(remoteControl);\n\t\t\t\tif (result == null) result = caseRemotePoint(remoteControl);\n\t\t\t\tif (result == null) result = caseIdentifiedObject(remoteControl);\n\t\t\t\tif (result == null) result = caseElement(remoteControl);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tcase SCADAPackage.REMOTE_SOURCE: {\n\t\t\t\tRemoteSource remoteSource = (RemoteSource)theEObject;\n\t\t\t\tT result = caseRemoteSource(remoteSource);\n\t\t\t\tif (result == null) result = caseRemotePoint(remoteSource);\n\t\t\t\tif (result == null) result = caseIdentifiedObject(remoteSource);\n\t\t\t\tif (result == null) result = caseElement(remoteSource);\n\t\t\t\tif (result == null) result = defaultCase(theEObject);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t\tdefault: return defaultCase(theEObject);\n\t\t}\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Communication Link</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Communication Link</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseCommunicationLink(CommunicationLink object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Remote Point</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Remote Point</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseRemotePoint(RemotePoint object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Remote Unit</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Remote Unit</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseRemoteUnit(RemoteUnit object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Remote Control</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Remote Control</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseRemoteControl(RemoteControl object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Remote Source</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Remote Source</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseRemoteSource(RemoteSource object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Element</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Element</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseElement(Element object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Identified Object</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Identified Object</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T caseIdentifiedObject(IdentifiedObject object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>Power System Resource</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>Power System Resource</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject) doSwitch(EObject)\n\t * @generated\n\t */\n\tpublic T casePowerSystemResource(PowerSystemResource object) {\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the result of interpreting the object as an instance of '<em>EObject</em>'.\n\t * <!-- begin-user-doc -->\n\t * This implementation returns null;\n\t * returning a non-null result will terminate the switch, but this is the last case anyway.\n\t * <!-- end-user-doc -->\n\t * @param object the target of the switch.\n\t * @return the result of interpreting the object as an instance of '<em>EObject</em>'.\n\t * @see #doSwitch(org.eclipse.emf.ecore.EObject)\n\t * @generated\n\t */\n\t@Override\n\tpublic T defaultCase(EObject object) {\n\t\treturn null;\n\t}\n\n} //SCADASwitch\n", "ole;\n\nimport java.util.List;\n\n/**\n * Lookup Data Access Object (GenericDao) interface.  This is used to lookup values in\n * the database (i.e. for drop-downs).\n *\n * @author <a href=\"mailto:matt@raibledesigns.com\">Matt Raible</a>\n */\npublic interface LookupDao {\n    //~ Methods ================================================================\n\n    /**\n     * Returns all Roles ordered by name\n     * @return populated list of roles\n     */\n    List<Role> getRoles();\n}\n", "toUpperCase();\n  }\n  \n  public static int length( String x )\n  {\n    return x.length();\n  }\n}\n", "r;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.net.HttpURLConnection;\nimport java.net.MalformedURLException;\nimport java.net.URL;\n\nimport android.util.Log;\nimport r2b.apps.lib.taskmanager.BaseAsyncTask;\n\npublic class GoogleSearchAsyncTask extends BaseAsyncTask {\n\t\n\tprivate long threadId;\n\tprivate Updatable listener;\n\t\n\tpublic interface Updatable {\n\t\tpublic void update(String txt);\n\t};\n\t\n\tpublic GoogleSearchAsyncTask(Updatable listener) {\n\t\tsuper();\t\n\t\tthis.listener = listener;\n\t}\n\n\tpublic final long getThreadId() {\n\t\treturn threadId;\n\t}\n\t\n\t@Override\n\tprotected Void doInBackground() throws Exception {\n\t\t\n\t\tthreadId = Thread.currentThread().getId();\n\t\t\n\t\tInputStream in = null;\n\t\tHttpURLConnection urlConnection = null;\n\t\t\n\t\ttry {\n\t\t\tURL url = new URL(\"http://www.google.es/?gfe_rd=cr&ei=ddKhU5fEG4_A8gevsoGoAQ&gws_rd=ssl#q=r2b+apps+github\");\n\t\t\turlConnection = (HttpURLConnection) url.openConnection();\n\t\t\tin = new BufferedInputStream(urlConnection.getInputStream());\n\t\t\treadStream(in);\t\t\t\t\t\t\n\t\t} \n\t\tcatch (MalformedURLException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\tfinally {\n\t\t\t\n\t\t\tif(urlConnection != null) {\n\t\t\t\turlConnection.disconnect();\t\n\t\t\t}\n\t\t\t\n\t\t\tif(in != null) {\n\t\t\t\ttry {\n\t\t\t\t\tin.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\treturn null;\n\t}\n\t\n\tprivate void readStream(InputStream in) {\n\t\t\n\t\tBufferedReader r = null;\n\t\ttry {\n\t\t\tr = new BufferedReader(new InputStreamReader(in));\n\t\t\tString line;\n\t\t\twhile ((line = r.readLine()) != null) {\n\t\t\t    \n\t\t\t\tif(listener == null) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tlistener.update(line);\n\t\t\t\t\tLog.i(\"GET\", \"Reading...\" + line);\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t\n\t\t\tLog.i(\"GET\", \"End read\");\n\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t} finally {\n\t\t\tif(r != null) {\n\t\t\t\ttry {\n\t\t\t\t\tr.close();\n\t\t\t\t} catch (IOException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t}\n\n}\n", "erDAO;\nimport br.com.modelo.security.model.factory.UserFactory;\nimport br.com.modelo.util.Util;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.security.core.userdetails.UserDetails;\nimport org.springframework.security.core.userdetails.UserDetailsService;\nimport org.springframework.security.core.userdetails.UsernameNotFoundException;\nimport org.springframework.stereotype.Service;\nimport org.springframework.transaction.annotation.Propagation;\nimport org.springframework.transaction.annotation.Transactional;\n\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n@Service\npublic class UserDetailsServiceImpl implements UserDetailsService {\n\n    private final UserDAO userDAO;\n\n    @Autowired\n    public UserDetailsServiceImpl(UserDAO userDAO) {\n        this.userDAO = userDAO;\n    }\n\n    @Override\n    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {\n        return UserFactory.create(getUser(username));\n    }\n\n\n    @Transactional(readOnly = true)\n    public User getUser(String username) {\n        User user;\n        if (username.equalsIgnoreCase(\"admin\")) {\n            user = getAdmin();\n        } else {\n            user = userDAO.findByUsername(username);\n        }\n        if(user==null){\n            throw new RuntimeException(\"Usuario (\"+username+\") n\u00e3o Localizado\");\n        }\n        return user;\n    }\n\n\n    private User getAdmin() {\n        User user = new User();\n        user.setUsername(\"admin\");\n        user.setPassword(\"$2a$10$jbfBfx4zmbtPzgsB0QFudut6cHWUHwYH8spzDVGHldrdbXyKCSWOa\");//admin criptgrafado\n        user.setAuthorities(\"ADMIN,ROOT\");\n        return user;\n    }\n\n\n    @Transactional(readOnly = true)\n    public List<User> getList() {\n        return userDAO.findAll();\n    }\n\n\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void setUser(User user){\n        //se for novo usu\u00e1rio, verifica se o login j\u00e1 existe\n        if(user.getId()==null || user.getId().equals(0)){\n            if(userDAO.findByUsername(user.getUsername())!=null || user.getPassword().equalsIgnoreCase(\"admin\")){\n                throw new RuntimeException(\"Login j\u00e1 est\u00e1 em uso\");\n            }\n            user.setPassword(Util.enconder(user.getPassword()));\n        }\n        user.setAuthorities(\"ADMIN,ROOT\");//remove\n        userDAO.save(user);\n    }\n\n\n    @Transactional(propagation = Propagation.REQUIRED)\n    public void updatePassword(User user){\n        user.setLastPasswordReset(new Date());\n        user.setPassword(Util.enconder(user.getPassword()));\n        userDAO.save(user);\n    }\n\n\n\n\n\n}\n", "\npublic class IJEntityNotFoundException extends RuntimeException {\n\t\n\tpublic IJEntityNotFoundException() {\n        super();\n    }\n\n    public IJEntityNotFoundException(final String message, final Throwable cause) {\n        super(message, cause);\n    }\n\n    public IJEntityNotFoundException(final String message) {\n        super(message);\n    }\n\n    public IJEntityNotFoundException(final Throwable cause) {\n        super(cause);\n    }\n    \n}\n", "c final class UnitConverter {\n\n\tpublic static final Pattern HEIGHT_NUMBER = Pattern.compile(\"(\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+)\\\\s*((?:milli|centi|kilo)?met(?:er|re)s?|miles?|yards?|feet|foot|inch(?:es)?|mi\\\\.?|[kcm]?m|yd\\\\.?|ft\\\\.?|in\\\\.?|\\\"|\\'|)\");\n\tpublic static final Pattern TIME_NUMBER = Pattern.compile(\"(\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+)\\\\s*(years?|months?|weeks?|days?|hours?|y(?:rs?)?\\\\.?|mos?\\\\.?|wks?\\\\.?|d\\\\.?|h(?:rs?)?\\\\.?)\");\n\tpublic static final Pattern WEIGHT_NUMBER = Pattern.compile(\"(\\\\d+\\\\.?\\\\d*|\\\\d*\\\\.?\\\\d+)\\\\s*((?:metric\\\\s)?ton(?:ne)?s?|(?:(US|imperial|short|long)\\\\s)?tons?|(?:milli|kilo)?grams?|stones?|pounds?|ounces?|[ms]?t\\\\.?|[mM]T\\\\.?|[mk]?g\\\\.?|lbs?\\\\.?|oz\\\\.?)\");\n\n\tprivate UnitConverter() {}\n\n\tpublic static double toInches(final String height) {\n\t\tfinal Matcher m = UnitConverter.HEIGHT_NUMBER.matcher(height);\n\t\tif (!m.find()) throw new IllegalArgumentException();\n\t\tdouble value = 0;\n\t\tdo {\n\t\t\tvalue += Double.parseDouble(m.group(1)) * UnitConverter.inchesIn(m.group(2));\n\t\t} while (m.find());\n\t\treturn value;\n\t}\n\n\tpublic static double inchesIn(final String unit) {\n\t\tif (unit.matches(\"millimet(?:er|re)s?\")) {\n\t\t\treturn 0.0393701;\n\t\t} else if (unit.matches(\"centimet(?:er|re)s?\")) {\n\t\t\treturn 0.393701;\n\t\t} else if (unit.matches(\"kilomet(?:er|re)s?\")) {\n\t\t\treturn 39370.1;\n\t\t} else if (unit.matches(\"met(?:er|re)s?\")) {\n\t\t\treturn 39.3701;\n\t\t} else if (unit.matches(\"miles?\")) {\n\t\t\treturn 63360;\n\t\t} else if (unit.matches(\"yards?\")) {\n\t\t\treturn 36;\n\t\t} else if (unit.equals(\"feet\")) {\n\t\t\treturn 12;\n\t\t} else if (unit.equals(\"foot\")) {\n\t\t\treturn 12;\n\t\t} else if (unit.matches(\"inch(?:es)?\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.matches(\"mi\\\\.?\")) {\n\t\t\treturn 63360;\n\t\t} else if (unit.equals(\"km\")) {\n\t\t\treturn 39370.1;\n\t\t} else if (unit.equals(\"cm\")) {\n\t\t\treturn 0.393701;\n\t\t} else if (unit.equals(\"mm\")) {\n\t\t\treturn 0.0393701;\n\t\t} else if (unit.equals(\"m\")) {\n\t\t\treturn 39.3701;\n\t\t} else if (unit.matches(\"yd\\\\.?\")) {\n\t\t\treturn 36;\n\t\t} else if (unit.matches(\"ft\\\\.?\")) {\n\t\t\treturn 12;\n\t\t} else if (unit.matches(\"in\\\\.?\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.equals(\"\\\"\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.equals(\"\\'\")) {\n\t\t\treturn 12;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tpublic static double toYears(final String time) {\n\t\tfinal Matcher m = UnitConverter.TIME_NUMBER.matcher(time);\n\t\tif (!m.find()) throw new IllegalArgumentException();\n\t\tdouble value = 0;\n\t\tdo {\n\t\t\tvalue += Double.parseDouble(m.group(1)) * UnitConverter.yearsIn(m.group(2));\n\t\t} while (m.find());\n\t\treturn value;\n\t}\n\n\tpublic static double yearsIn(final String unit) {\n\t\tif (unit.matches(\"years?\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.matches(\"months?\")) {\n\t\t\treturn 0.0833334;\n\t\t} else if (unit.matches(\"weeks?\")) {\n\t\t\treturn 0.0191781;\n\t\t} else if (unit.matches(\"days?\")) {\n\t\t\treturn 0.00273973;\n\t\t} else if (unit.matches(\"hours?\")) {\n\t\t\treturn 0.000114155;\n\t\t} else if (unit.matches(\"y(?:rs?)?\\\\.?\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.matches(\"mos?\\\\.?\")) {\n\t\t\treturn 0.0833334;\n\t\t} else if (unit.matches(\"wks?\\\\.?\")) {\n\t\t\treturn 0.0191781;\n\t\t} else if (unit.matches(\"d\\\\.?\")) {\n\t\t\treturn 0.00273973;\n\t\t} else if (unit.matches(\"h(?:rs?)?\\\\.?\")) {\n\t\t\treturn 0.000114155;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tpublic static double toPounds(final String weight) {\n\t\tfinal Matcher m = UnitConverter.WEIGHT_NUMBER.matcher(weight);\n\t\tif (!m.find()) throw new IllegalArgumentException();\n\t\tdouble value = 0;\n\t\tdo {\n\t\t\tvalue += Double.parseDouble(m.group(1)) * UnitConverter.poundsIn(m.group(2));\n\t\t} while (m.find());\n\t\treturn value;\n\t}\n\n\tpublic static double poundsIn(final String unit) {\n\t\tif (unit.matches(\"(?:metric\\\\s)?ton(?:ne)?s?\")) {\n\t\t\treturn 2204.62;\n\t\t} else if (unit.matches(\"(?:imperial|long)\\\\stons?\")) {\n\t\t\treturn 2240;\n\t\t} else if (unit.matches(\"(?:(?:US|short)\\\\s)?tons?\")) {\n\t\t\treturn 2000;\n\t\t} else if (unit.matches(\"milligrams?\")) {\n\t\t\treturn 2.20146e-6;\n\t\t} else if (unit.matches(\"kilograms?\")) {\n\t\t\treturn 2.20462;\n\t\t} else if (unit.matches(\"grams?\")) {\n\t\t\treturn 0.00220462;\n\t\t} else if (unit.matches(\"stones?\")) {\n\t\t\treturn 14;\n\t\t} else if (unit.matches(\"pounds?\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.matches(\"ounces?\")) {\n\t\t\treturn 1. / 16;\n\t\t} else if (unit.matches(\"[mM]?[tT]\\\\.?\")) {\n\t\t\treturn 2204.62;\n\t\t} else if (unit.matches(\"st\\\\.?\")) {\n\t\t\treturn 14;\n\t\t} else if (unit.matches(\"mg\\\\.?\")) {\n\t\t\treturn 2.20146e-6;\n\t\t} else if (unit.matches(\"kg\\\\.?\")) {\n\t\t\treturn 2.20462;\n\t\t} else if (unit.matches(\"g\\\\.?\")) {\n\t\t\treturn 0.00220462;\n\t\t} else if (unit.matches(\"lbs?\\\\.?\")) {\n\t\t\treturn 1;\n\t\t} else if (unit.matches(\"oz\\\\.?\")) {\n\t\t\treturn 1. / 16;\n\t\t} else {\n\t\t\treturn 1;\n\t\t}\n\t}\n\n}\n", "t com.intellij.lang.ASTNode;\nimport com.intellij.lang.folding.FoldingBuilder;\nimport com.intellij.lang.folding.FoldingDescriptor;\nimport com.intellij.openapi.editor.Document;\nimport com.intellij.openapi.project.DumbAware;\nimport com.intellij.openapi.util.TextRange;\nimport org.jetbrains.annotations.NotNull;\nimport org.jetbrains.annotations.Nullable;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class AvroIdlFoldingBuilder implements FoldingBuilder, DumbAware {\n    @NotNull\n    @Override\n    public FoldingDescriptor[] buildFoldRegions(@NotNull ASTNode node, @NotNull Document document) {\n        final List<FoldingDescriptor> descriptors = new ArrayList<>();\n        collectDescriptorsRecursively(node, document, descriptors);\n        return descriptors.toArray(new FoldingDescriptor[descriptors.size()]);\n    }\n\n    private static void collectDescriptorsRecursively(@NotNull ASTNode node,\n                                                      @NotNull Document document,\n                                                      @NotNull List<FoldingDescriptor> descriptors) {\n        if (!spanMultipleLines(node, document)) return;\n\n        if (node.findChildByType(AvroIdlTypes.LEFT_BRACE) != null || node.getElementType() == AvroIdlTypes.BLOCK_COMMENT) {\n            descriptors.add(new FoldingDescriptor(node, getBracedRange(node)));\n        }\n\n        for (ASTNode child : node.getChildren(null)) {\n            collectDescriptorsRecursively(child, document, descriptors);\n        }\n    }\n\n    @Nullable\n    @Override\n    public String getPlaceholderText(@NotNull ASTNode node) {\n        if (node.getElementType() == AvroIdlTypes.BLOCK_COMMENT) {\n            return \"/*...*/\";\n        }\n        else {\n            return \"{...}\";\n        }\n    }\n\n    @Override\n    public boolean isCollapsedByDefault(@NotNull ASTNode node) {\n        return false;\n    }\n\n    private static boolean spanMultipleLines(@NotNull ASTNode node, @NotNull Document document) {\n        final TextRange range = node.getTextRange();\n        return document.getLineNumber(range.getStartOffset()) < document.getLineNumber(range.getEndOffset());\n    }\n\n    private static TextRange getBracedRange(@NotNull ASTNode node) {\n        ASTNode leftBrace = node.findChildByType(AvroIdlTypes.LEFT_BRACE);\n        ASTNode rightBrace = node.findChildByType(AvroIdlTypes.RIGHT_BRACE);\n\n        return new TextRange(leftBrace != null ? leftBrace.getStartOffset() : node.getStartOffset(),\n                             rightBrace != null ? rightBrace.getTextRange().getEndOffset() : node.getTextRange().getEndOffset());\n    }\n}\n", "sharpsoft.hexapod.util.Quaternion;\nimport ch.sharpsoft.hexapod.util.Vector3;\n\npublic class QuternionTest {\n\n\t@Test\n\tpublic void testVector1() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(0.0, 0.0, Math.PI / 2);\n\t\tVector3 v = new Vector3(0.0, 1.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(1.0, m.getX(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector2() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(0.0, 0.0, Math.PI / 2);\n\t\tVector3 v = new Vector3(1.0, 0.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(-1.0, m.getY(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector3() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(0.0, 0.0, Math.PI / 2);\n\t\tVector3 v = new Vector3(0.0, 0.0, 1.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(1.0, m.getZ(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector4() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(0.0, 0.0, -Math.PI / 2);\n\t\tVector3 v = new Vector3(1.0, 0.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(1.0, m.getY(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector5() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(0.0, Math.PI / 2, 0.0);\n\t\tVector3 v = new Vector3(1.0, 0.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(-1.0, m.getZ(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector6() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(Math.PI / 2, 0.0, 0.0);\n\t\tVector3 v = new Vector3(1.0, 0.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(1.0, m.getX(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector7() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(Math.PI / 2, 0.0, 0.0);\n\t\tVector3 v = new Vector3(0.0, 1.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(-1.0, m.getZ(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector8() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(-Math.PI / 2, 0.0, 0.0);\n\t\tVector3 v = new Vector3(0.0, 1.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(1.0, m.getZ(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testVector9() throws Exception {\n\t\tQuaternion quat = Quaternion.fromEuler(0.0, -Math.PI / 4, 0.0);\n\t\tVector3 v = new Vector3(5.0, 0.0, 0.0);\n\t\tVector3 m = quat.multiply(v);\n\t\tassertEquals(3.5355, m.getZ(), 0.01f);\n\t\tassertEquals(3.5355, m.getX(), 0.01f);\n\t}\n\n\t@Test\n\tpublic void testEulerRoll() throws Exception {\n\t\tfor (int i = -1000; i < 1000; i++) {\n\t\t\tif (i == 0 || i == 1 || i == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQuaternion quat = Quaternion.fromEuler(Math.PI / i, 0.0, 0.0);\n\t\t\tassertEquals(Math.PI / i, quat.toAngles()[0], 0.01f);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testEulerPitch() throws Exception {\n\t\tfor (int i = -1000; i < 1000; i++) {\n\t\t\tif (i == 0 || i == 1 || i == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQuaternion quat = Quaternion.fromEuler(0.0, Math.PI / i, 0.0);\n\t\t\tassertEquals(Math.PI / i, quat.toAngles()[1], 0.01f);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testEulerYaw() throws Exception {\n\t\tfor (int i = -1000; i < 1000; i++) {\n\t\t\tif (i == 0 || i == 1 || i == -1) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tQuaternion quat = Quaternion.fromEuler(0.0, 0.0, Math.PI / i);\n\t\t\tassertEquals(Math.PI / i, quat.toAngles()[2], 0.01f);\n\t\t}\n\t}\n\n\t@Test\n\tpublic void testDiffRoll() throws Exception {\n\t\tQuaternion quat1 = Quaternion.fromEuler(0.57, 0.0, 0.0);\n\t\tQuaternion quat2 = Quaternion.fromEuler(0.923, 0.0, 0.0);\n\t\tQuaternion diff = quat1.mulInverse(quat2);\n\t\tdouble diffAngle = diff.toAngles()[0];\n\t\tassertEquals((0.57) - (0.923), diffAngle, 0.01f);\n\t}\n\n\t@Test\n\tpublic void testDiffPitch() throws Exception {\n\t\tQuaternion quat1 = Quaternion.fromEuler(0.0, 0.57, 0.0);\n\t\tQuaternion quat2 = Quaternion.fromEuler(0.0, 0.923, 0.0);\n\t\tQuaternion diff = quat1.mulInverse(quat2);\n\t\tdouble diffAngle = diff.toAngles()[1];\n\t\tassertEquals((0.57) - (0.923), diffAngle, 0.01f);\n\t}\n\n\t@Test\n\tpublic void testDiffYaw() throws Exception {\n\t\tQuaternion quat1 = Quaternion.fromEuler(0.0, 0.0, 0.57);\n\t\tQuaternion quat2 = Quaternion.fromEuler(0.0, 0.0, 0.923);\n\t\tQuaternion diff = quat1.mulInverse(quat2);\n\t\tdouble diffAngle = diff.toAngles()[2];\n\t\tassertEquals((0.57) - (0.923), diffAngle, 0.01f);\n\t}\n\n\t@Test\n\tpublic void testMulInverse() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.1, 0.0, 0.0);\n\t\tQuaternion o2 = Quaternion.fromEuler(0.0, 0.2, 0.0);\n\t\tQuaternion o3 = Quaternion.fromEuler(0.0, 0.0, 0.3);\n\n\t\tassertEquals(0.1, o1.toAngles()[0], 0.001);\n\t\tassertEquals(0.2, o2.toAngles()[1], 0.001);\n\t\tassertEquals(0.3, o3.toAngles()[2], 0.001);\n\n\t\tQuaternion o12 = o1.multiply(o2);\n\t\tQuaternion o13 = o1.multiply(o3);\n\t\tQuaternion o23 = o2.multiply(o3);\n\t\tQuaternion o32 = o3.multiply(o2);\n\n\t\to1 = o12.mulInverse(o2);\n\t\to2 = o23.mulInverse(o3);\n\t\to3 = o32.mulInverse(o2);\n\n\t\tassertEquals(0.1, o1.toAngles()[0], 0.001);\n\t\tassertEquals(0.2, o2.toAngles()[1], 0.001);\n\t\tassertEquals(0.3, o3.toAngles()[2], 0.001);\n\t}\n\n\t@Test\n\tpublic void testMulInverse2() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.1, 0.0, 0.0);\n\t\tQuaternion o2 = Quaternion.fromEuler(0.0, 0.2, 0.0);\n\t\tQuaternion o3 = Quaternion.fromEuler(0.0, 0.0, 0.3);\n\t\tQuaternion o4 = Quaternion.fromEuler(0.0, 1.1, 0.0);\n\n\t\tQuaternion o12 = o1.multiply(o2);\n\t\tQuaternion o123 = o12.multiply(o3);\n\t\tQuaternion o1234 = o123.multiply(o4);\n\n\t\to123 = o1234.mulInverse(o4);\n\t\to12 = o123.mulInverse(o3);\n\t\to1 = o12.mulInverse(o2);\n\n\t\tassertEquals(0.1, o1.toAngles()[0], 0.001);\n\t}\n\n\t@Test\n\tpublic void testMulInverse3() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.1, 0.0, 0.0);\n\t\tQuaternion o2 = Quaternion.fromEuler(0.0, 0.2, 0.0);\n\t\tQuaternion o12 = o1.multiply(o2);\n\t\to2 = o12.mulInverse(o1);\n\t\tassertEquals(0.2, o2.toAngles()[1], 0.001);\n\t}\n\n\t@Test\n\tpublic void testMulInverse4() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.1, 0.0, 0.0);\n\t\tQuaternion o2 = Quaternion.fromEuler(0.0, 0.2, 0.0);\n\t\tQuaternion o3 = Quaternion.fromEuler(0.0, 0.0, 0.3);\n\n\t\tQuaternion o12 = o1.multiply(o2);\n\t\tQuaternion o123 = o12.multiply(o3);\n\n\t\to3 = o123.mulInverse(o12);\n\n\t\tassertEquals(0.3, o3.toAngles()[2], 0.01);\n\t}\n\n\t@Test\n\tpublic void testGetDirectionX1() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.0, 0.0, 0.0);\n\t\tVector3 result = o1.getDirectionX(10);\n\t\tassertEquals(10.0, result.getX(), 0.01);\n\t}\n\n\t@Test\n\tpublic void testGetDirectionX2() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.0, 0.0, Math.PI / 2);\n\t\tVector3 result = o1.getDirectionX(10);\n\t\tassertEquals(-10.0, result.getY(), 0.01);\n\t}\n\n\t@Test\n\tpublic void testGetDirectionX3() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.0, 0.0, -Math.PI / 2);\n\t\tVector3 result = o1.getDirectionX(10);\n\t\tassertEquals(10.0, result.getY(), 0.01);\n\t}\n\n\t@Test\n\tpublic void testGetDirectionX4() throws Exception {\n\t\tQuaternion o1 = Quaternion.fromEuler(0.0, Math.PI / 2, 0.0);\n\t\tVector3 result = o1.getDirectionX(10);\n\t\tassertEquals(-10.0, result.getZ(), 0.01);\n\t}\n}", "lled;\n\tpublic int championsKilled;\n\tpublic int combatPlayerScore;\n\tpublic int consumablesPurchased;\n\tpublic int damageDealtPlayer;\n\tpublic int doubleKills;\n\tpublic int firstBlood;\n\tpublic int gold;\n\tpublic int goldEarned;\n\tpublic int goldSpent;\n\tpublic int item0;\n\tpublic int item1;\n\tpublic int item2;\n\tpublic int item3;\n\tpublic int item4;\n\tpublic int item5;\n\tpublic int item6;\n\tpublic int itemsPurchased;\n\tpublic int killingSprees;\n\tpublic int largestCriticalStrike;\n\tpublic int largestKillingSpree;\n\tpublic int largestMultiKill;\n\tpublic int legendaryItemsCreated;\n\tpublic int level;\n\tpublic int magicDamageDealtPlayer;\n\tpublic int magicDamageDealtToChampions;\n\tpublic int magicDamageTaken;\n\tpublic int minionsDenied;\n\tpublic int minionsKilled;\n\tpublic int neutralMinionsKilled;\n\tpublic int neutralMinionsKilledEnemyJungle;\n\tpublic int neutralMinionsKilledYourJungle;\n\tpublic boolean nexusKilled;\n\tpublic int nodeCapture;\n\tpublic int nodeCaptureAssist;\n\tpublic int nodeNeutralize;\n\tpublic int nodeNeutralizeAssist;\n\tpublic int numDeaths;\n\tpublic int numItemsBought;\n\tpublic int objectivePlayerScore;\n\tpublic int pentaKills;\n\tpublic int physicalDamageDealtPlayer;\n\tpublic int physicalDamageDealtToChampions;\n\tpublic int physicalDamageTaken;\n\tpublic int quadraKills;\n\tpublic int sightWardsBought;\n\tpublic int spell1Cast;\n\tpublic int spell2Cast;\n\tpublic int spell3Cast;\n\tpublic int spell4Cast;\n\tpublic int summonSpell1Cast;\n\tpublic int summonSpell2Cast;\n\tpublic int superMonsterKilled;\n\tpublic int team;\n\tpublic int teamObjective;\n\tpublic int timePlayed;\n\tpublic int totalDamageDealt;\n\tpublic int totalDamageDealtToChampions;\n\tpublic int totalDamageTaken;\n\tpublic int totalHeal;\n\tpublic int totalPlayerScore;\n\tpublic int totalScoreRank;\n\tpublic int totalTimeCrowdControlDealt;\n\tpublic int totalUnitsHealed;\n\tpublic int tripleKills;\n\tpublic int trueDamageDealtPlayer;\n\tpublic int trueDamageDealtToChampions;\n\tpublic int trueDamageTaken;\n\tpublic int turretsKilled;\n\tpublic int unrealKills;\n\tpublic int victoryPointTotal;\n\tpublic int visionWardsBought;\n\tpublic int wardKilled;\n\tpublic int wardPlaced;\n\tpublic boolean win;\n}\n", " a single node in a tree or tree-like data structure.<br>\r\n * \r\n * @param <T> - actual node type\r\n * \r\n * @since Zjava 1.0\r\n * \r\n * @author Ivan Zaitsau\r\n */\r\npublic interface Node<T extends Node<T>> {\r\n\t\r\n\t/**\r\n\t * Returns list of node child-nodes<br>\r\n\t * \r\n\t * @return list of node children\r\n\t */\r\n\tList<T> getChildren();\r\n}\r\n", "t jkanvas.animation.AnimationTiming;\nimport jkanvas.painter.Renderpass;\n\n/**\n * A camera is way to control the viewport of a {@link jkanvas.Canvas}.\n * \n * @author Joschi <josua.krause@gmail.com>\n */\npublic interface Camera {\n\n  /**\n   * Scrolls to the specified viewport. The rectangle will be completely visible\n   * afterwards.\n   * \n   * @param rect The rectangle in canvas coordinates.\n   * @param timing The timing of the scrolling.\n   * @param onFinish The action that is executed after the animation has\n   *          finished.\n   * @param useMargin Whether to add the canvas margin.\n   */\n  void toView(Rectangle2D rect, AnimationTiming timing,\n      AnimationAction onFinish, boolean useMargin);\n\n  /**\n   * Moves the view by the given amount.\n   * \n   * @param dx The horizontal movement in component coordinates.\n   * @param dy The vertical movement in component coordinates.\n   */\n  void move(double dx, double dy);\n\n  /**\n   * Scrolls to the specified render pass. The bounding box of the render pass\n   * will be completely visible afterwards. If the render pass has no bounding\n   * box the finish action will be scheduled normally but otherwise nothing\n   * happens.\n   * \n   * @param pass The render pass.\n   * @param timing The timing of the scrolling.\n   * @param onFinish The action that is executed after the animation has\n   *          finished.\n   * @param useMargin Whether to add the canvas margin.\n   */\n  // TODO #43 -- Java 8 simplification\n  void toView(Renderpass pass, AnimationTiming timing,\n      AnimationAction onFinish, boolean useMargin);\n\n  /**\n   * Getter.\n   * \n   * @return The current view in canvas coordinates.\n   */\n  Rectangle2D getView();\n\n  /**\n   * Getter.\n   * \n   * @return The destination of the current scroll animation in canvas\n   *         coordinates. If no scroll animation is active the result is the\n   *         same as {@link #getView()}.\n   */\n  Rectangle2D getPredictView();\n\n  /**\n   * Getter.\n   * \n   * @return Whether the camera is in animation.\n   */\n  boolean inAnimation();\n\n}\n", "ose;\nimport com.google.gson.annotations.SerializedName;\n\n\npublic class Image {\n\n    @SerializedName(\"hostedSmallUrl\")\n    @Expose\n    private String hostedSmallUrl;\n    @SerializedName(\"hostedMediumUrl\")\n    @Expose\n    private String hostedMediumUrl;\n    @SerializedName(\"hostedLargeUrl\")\n    @Expose\n    private String hostedLargeUrl;\n    @SerializedName(\"imageUrlsBySize\")\n    @Expose\n    private ImageUrlsBySize imageUrlsBySize;\n\n    /**\n     *\n     * @return\n     *     The hostedSmallUrl\n     */\n    public String getHostedSmallUrl() {\n        return hostedSmallUrl;\n    }\n\n    /**\n     *\n     * @param hostedSmallUrl\n     *     The hostedSmallUrl\n     */\n    public void setHostedSmallUrl(String hostedSmallUrl) {\n        this.hostedSmallUrl = hostedSmallUrl;\n    }\n\n    /**\n     *\n     * @return\n     *     The hostedMediumUrl\n     */\n    public String getHostedMediumUrl() {\n        return hostedMediumUrl;\n    }\n\n    /**\n     *\n     * @param hostedMediumUrl\n     *     The hostedMediumUrl\n     */\n    public void setHostedMediumUrl(String hostedMediumUrl) {\n        this.hostedMediumUrl = hostedMediumUrl;\n    }\n\n    /**\n     *\n     * @return\n     *     The hostedLargeUrl\n     */\n    public String getHostedLargeUrl() {\n        return hostedLargeUrl;\n    }\n\n    /**\n     *\n     * @param hostedLargeUrl\n     *     The hostedLargeUrl\n     */\n    public void setHostedLargeUrl(String hostedLargeUrl) {\n        this.hostedLargeUrl = hostedLargeUrl;\n    }\n\n    /**\n     *\n     * @return\n     *     The imageUrlsBySize\n     */\n    public ImageUrlsBySize getImageUrlsBySize() {\n        return imageUrlsBySize;\n    }\n\n    /**\n     *\n     * @param imageUrlsBySize\n     *     The imageUrlsBySize\n     */\n    public void setImageUrlsBySize(ImageUrlsBySize imageUrlsBySize) {\n        this.imageUrlsBySize = imageUrlsBySize;\n    }\n\n}\n", ".analyzer.domain.MetricValueEntity;\nimport java.util.List;\nimport java.util.Map;\nimport org.springframework.data.neo4j.annotation.Query;\nimport org.springframework.data.neo4j.repository.Neo4jRepository;\nimport org.springframework.lang.NonNull;\nimport org.springframework.transaction.annotation.Transactional;\n\n@Transactional(readOnly = true)\npublic interface MetricRepository extends Neo4jRepository<MetricValueEntity, Long> {\n\n  /**\n   * NOTE: only used in tests. WILL cause an out of memory exception if used on a sufficiently large\n   * project.\n   *\n   * @param projectId The project id.\n   * @return All of the metric values in a project.\n   */\n  @Query(\"MATCH (p)-[:CONTAINS*]->()-[:MEASURED_BY]->(m) WHERE ID(p) = {0} RETURN m\")\n  List<MetricValueEntity> findByProjectId(long projectId);\n\n  /**\n   * Creates [:MEASURED_BY] relationships between metric values and files and [:VALID_FOR]\n   * relationships between metric values and commits.\n   *\n   * @param saveData A list of Objects, where each objects contains a list with the id of an\n   *     existing FileEntity and an existing CommitEntity, the name of the metric to save, its value\n   *     and its findings.\n   */\n  @Query(\n      \"MATCH (c) WHERE ID(c) = {0} WITH c UNWIND {1} as x \"\n          + \"MATCH (f) WHERE ID(f) = x[3] \"\n          + \"CREATE (f)-[:MEASURED_BY]->(m:MetricValueEntity {value: x[0], name: x[1], findings: x[2]})-[:VALID_FOR]->(c)\")\n  @Transactional\n  void saveMetrics(long commitId, @NonNull List<Object> saveData);\n\n  /**\n   * Uses APOC.\n   *\n   * @param projectId The project id.\n   * @param branchName The branch name.\n   * @return All files and their corresponding metrics for the head commit of the given branch\n   */\n  @Query(\n      \"MATCH (p)-[:HAS_BRANCH]->(b:BranchEntity)-[:POINTS_TO]->(c) WHERE ID(p) = {0} AND b.name = {1} WITH c LIMIT 1 \"\n          + \"CALL apoc.path.subgraphNodes(c, {relationshipFilter:'IS_CHILD_OF>'}) YIELD node WITH node as c ORDER BY c.timestamp DESC WITH collect(c) as commits \"\n          + \"CALL apoc.cypher.run('UNWIND commits as c OPTIONAL MATCH (f)<-[:RENAMED_FROM]-()-[:CHANGED_IN]->(c) RETURN collect(f) as renames', {commits: commits}) \"\n          + \"YIELD value WITH commits, value.renames as renames \"\n          + \"CALL apoc.cypher.run('UNWIND commits as c OPTIONAL MATCH (f)-[:DELETED_IN]->(c) \"\n          + \"RETURN collect(f) as deletes', {commits: commits}) YIELD value WITH commits, renames, value.deletes as deletes \"\n          + \"UNWIND commits as c \"\n          + \"MATCH (f)-[:MEASURED_BY]->(m)-[:VALID_FOR]->(c) WHERE \"\n          + \"NOT(f IN deletes OR f IN renames) AND m.value <> 0 WITH ID(f) as id, m.name as name, head(collect(m)) as metric \"\n          + \"RETURN  id, collect({name: metric.name, value: metric.value}) as metrics\")\n  List<Map<String, Object>> getLastMetricsForFiles(long projectId, @NonNull String branchName);\n\n  @Query(\"MATCH (c)<-[:VALID_FOR]-(m) WHERE ID(c) = {0} DETACH DELETE m\")\n  @Transactional\n  void deleteMetricsForCommit(long id);\n}\n", "soft Corporation.  All rights reserved.\npackage tla2sany.modanalyzer;\n\nimport java.util.Enumeration;\nimport java.util.Hashtable;\n\n/**\n * Each instance of this class basically is a map from ParseUnit objects to\n * ParseUnitRelatives objects.\n *\n * It is just a wrapper for a Hashtable, with the added benefit of type checking\n */\n\nclass ParseUnitsTable {\n\n  // Maps ParseUnit string names to their respective ParseUnit objects\n  Hashtable parseUnitTable = new Hashtable();\n\n  ParseUnit get(String parseUnitName) { \n    return (ParseUnit)parseUnitTable.get(parseUnitName); \n  }\n\n  void put (ParseUnit parseUnitName, ParseUnit parseUnit) {\n    parseUnitTable.put(parseUnitName, parseUnit);\n  }\n\n  Enumeration getKeys() { return parseUnitTable.keys(); }  \n\n  public String toString() {\n    String ret = \"\";\n\n    Enumeration e = parseUnitTable.keys();\n    while ( e.hasMoreElements()) {\n      ret += \"[ ParseUnit: \" + ((ParseUnit)e.nextElement()).getName() + \" ] \";\n    }\n    return ret;\n  }\n\n}\n", "il.Locale;\n\nclass DateConverter extends TimeConverter<Date> {\n    public DateConverter(Locale locale) {\n        super(locale, new Class[]{Date.class});\n    }\n}\n", "reements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\npackage org.apache.tomcat.websocket.pojo;\n\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.websocket.ContainerProvider;\nimport javax.websocket.OnClose;\nimport javax.websocket.OnMessage;\nimport javax.websocket.OnOpen;\nimport javax.websocket.Session;\nimport javax.websocket.WebSocketContainer;\nimport javax.websocket.server.PathParam;\nimport javax.websocket.server.ServerEndpoint;\n\nimport org.junit.Assert;\nimport org.junit.Test;\n\nimport org.apache.catalina.Context;\nimport org.apache.catalina.servlets.DefaultServlet;\nimport org.apache.catalina.startup.Tomcat;\nimport org.apache.catalina.startup.TomcatBaseTest;\nimport org.apache.tomcat.websocket.pojo.TesterUtil.ServerConfigListener;\nimport org.apache.tomcat.websocket.pojo.TesterUtil.SimpleClient;\nimport org.apache.tomcat.websocket.pojo.TesterUtil.SingletonConfigurator;\n\npublic class TestPojoMethodMapping extends TomcatBaseTest {\n\n    private static final String PARAM_ONE = \"abcde\";\n    private static final String PARAM_TWO = \"12345\";\n    private static final String PARAM_THREE = \"true\";\n\n    @Test\n    public void test() throws Exception {\n\n        // Set up utility classes\n        Server server = new Server();\n        SingletonConfigurator.setInstance(server);\n        ServerConfigListener.setPojoClazz(Server.class);\n\n        Tomcat tomcat = getTomcatInstance();\n        // Must have a real docBase - just use temp\n        Context ctx =\n            tomcat.addContext(\"\", System.getProperty(\"java.io.tmpdir\"));\n        ctx.addApplicationListener(ServerConfigListener.class.getName());\n        Tomcat.addServlet(ctx, \"default\", new DefaultServlet());\n        ctx.addServletMapping(\"/\", \"default\");\n\n        WebSocketContainer wsContainer =\n                ContainerProvider.getWebSocketContainer();\n\n\n        tomcat.start();\n\n        SimpleClient client = new SimpleClient();\n        URI uri = new URI(\"ws://localhost:\" + getPort() + \"/\" + PARAM_ONE +\n                \"/\" + PARAM_TWO + \"/\" + PARAM_THREE);\n\n        Session session = wsContainer.connectToServer(client, uri);\n        session.getBasicRemote().sendText(\"NO-OP\");\n        session.close();\n\n        // Give server 5s to close\n        int count = 0;\n        while (count < 50) {\n            if (server.isClosed()) {\n                break;\n            }\n            count++;\n            Thread.sleep(100);\n        }\n        if (count == 50) {\n            Assert.fail(\"Server did not process an onClose event within 5 \" +\n                    \"seconds of the client sending a close message\");\n        }\n\n        // Check no errors\n        List<String> errors = server.getErrors();\n        for (String error : errors) {\n            System.err.println(error);\n        }\n        Assert.assertEquals(\"Found errors\", 0, errors.size());\n    }\n\n\n    @ServerEndpoint(value=\"/{one}/{two}/{three}\",\n            configurator=SingletonConfigurator.class)\n    public static final class Server {\n\n        private final List<String> errors = new ArrayList<String>();\n        private volatile boolean closed;\n\n        @OnOpen\n        public void onOpen(@PathParam(\"one\") String p1, @PathParam(\"two\")int p2,\n                @PathParam(\"three\")boolean p3) {\n            checkParams(\"onOpen\", p1, p2, p3);\n        }\n\n        @OnMessage\n        public void onMessage(@SuppressWarnings(\"unused\") String msg,\n                @PathParam(\"one\") String p1, @PathParam(\"two\")int p2,\n                @PathParam(\"three\")boolean p3) {\n            checkParams(\"onMessage\", p1, p2, p3);\n        }\n\n        @OnClose\n        public void onClose(@PathParam(\"one\") String p1,\n                @PathParam(\"two\")int p2, @PathParam(\"three\")boolean p3) {\n            checkParams(\"onClose\", p1, p2, p3);\n            closed = true;\n        }\n\n        public List<String> getErrors() {\n            return errors;\n        }\n\n        public boolean isClosed() {\n            return closed;\n        }\n\n        private void checkParams(String method, String p1, int p2, boolean p3) {\n            checkParam(method, PARAM_ONE, p1);\n            checkParam(method, PARAM_TWO, Integer.toString(p2));\n            checkParam(method, PARAM_THREE, Boolean.toString(p3));\n        }\n\n        private void checkParam(String method, String expected, String actual) {\n            if (!expected.equals(actual)) {\n                errors.add(\"Method [\" + method + \"]. Expected [\" + expected +\n                        \"] was + [\" + actual + \"]\");\n            }\n        }\n    }\n}\n", "ngl.texture.source.decorator.BaseTextureSourceDecorator.TextureSourceDecoratorOptions;\n\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\n\npublic class RectangleTextureSourceDecoratorShape implements ITextureSourceDecoratorShape {\n\t// ===========================================================\n\t// Constants\n\t// ===========================================================\n\n\t// ===========================================================\n\t// Fields\n\t// ===========================================================\n\n\tprivate static RectangleTextureSourceDecoratorShape sDefaultInstance;\n\n\t// ===========================================================\n\t// Constructors\n\t// ===========================================================\n\n\tpublic RectangleTextureSourceDecoratorShape() {\n\n\t}\n\n\tpublic static RectangleTextureSourceDecoratorShape getDefaultInstance() {\n\t\tif(sDefaultInstance == null) {\n\t\t\tsDefaultInstance = new RectangleTextureSourceDecoratorShape();\n\t\t}\n\t\treturn sDefaultInstance;\n\t}\n\n\t// ===========================================================\n\t// Getter & Setter\n\t// ===========================================================\n\n\t// ===========================================================\n\t// Methods for/from SuperClass/Interfaces\n\t// ===========================================================\n\n\t@Override\n\tpublic void onDecorateBitmap(final Canvas pCanvas, final Paint pPaint, final TextureSourceDecoratorOptions pDecoratorOptions) {\n\t\tfinal float left = pDecoratorOptions.getInsetLeft();\n\t\tfinal float top = pDecoratorOptions.getInsetTop();\n\t\tfinal float right = pCanvas.getWidth() - pDecoratorOptions.getInsetRight();\n\t\tfinal float bottom = pCanvas.getHeight() - pDecoratorOptions.getInsetBottom();\n\t\t\n\t\tpCanvas.drawRect(left, top, right, bottom, pPaint);\n\t}\n\n\t// ===========================================================\n\t// Methods\n\t// ===========================================================\n\n\t// ===========================================================\n\t// Inner and Anonymous Classes\n\t// ===========================================================\n};", " android.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.Button;\n\n/**\n * Base Fragment class to handle state indication (progress and error)\n */\npublic abstract class BaseFragment extends Fragment {\n    protected static final int STATE_OK = 0;\n    protected static final int STATE_LOADING = 1;\n    protected static final int STATE_ERROR = 2;\n\n    private static final String TAG = \"BaseFragment\";\n    private static final String KEY_PROGRESS_STATE = \"progressState\";\n\n    private int mProgressState;\n    private View mProgressIndicator;\n    private View mErrorLayout;\n\n    /**\n     * Called to have the fragment instantiate its user interface view by\n     * BaseFragment's {@link #onCreateView} with the same parameters.\n     * <p>\n     * For state indication to function properly, returned View should contain\n     * Views with IDs <code>\"progress_indicator\"</code> and\n     * <code>\"error_layout\"</code> (latter containing Button with ID\n     * <code>\"try_again_button\"</code>).\n     *\n     * @param inflater           The LayoutInflater object to inflate views\n     * @param container          If non-null, this is the parent view\n     * @param savedInstanceState If non-null, this is the previous saved state\n     * @return Return the View for the fragment's UI. Should not be null.\n     */\n    @NonNull\n    protected abstract View createView(LayoutInflater inflater, @Nullable ViewGroup container,\n                                       @Nullable Bundle savedInstanceState);\n\n    /**\n     * Called by \"Try again\" button (visible in case of errors).\n     * Subclasses should provide specific implementation to reload their content.\n     * No need to call setupProgressState(STATE_LOADING), BaseFragment takes care of that.\n     */\n    protected abstract void tryAgain();\n\n    @Override\n    public void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        if (savedInstanceState != null) {\n            mProgressState = savedInstanceState.getInt(KEY_PROGRESS_STATE);\n        }\n    }\n\n    @NonNull\n    @Override\n    public final View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,\n                                   @Nullable Bundle savedInstanceState) {\n        View view = createView(inflater, container, savedInstanceState);\n\n        mProgressIndicator = view.findViewById(R.id.progress_indicator);\n        mErrorLayout = view.findViewById(R.id.error_layout);\n        Button tryAgainButton = view.findViewById(R.id.try_again_button);\n        if (tryAgainButton != null) {\n            tryAgainButton.setOnClickListener(v -> {\n                setupProgressState(STATE_LOADING);\n                tryAgain();\n            });\n        }\n        setupProgressState(mProgressState);\n\n        return view;\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        outState.putInt(KEY_PROGRESS_STATE, mProgressState);\n    }\n\n    /**\n     * Saves operation state in private variable (persisted via saved state Bundle)\n     * and displays it if possible (= if view is already created).\n     *\n     * @param state One of protected constants: <code>STATE_OK</code>,\n     *              <code>STATE_LOADING</code> or <code>STATE_ERROR</code>\n     */\n    protected void setupProgressState(int state) {\n        mProgressState = state;\n        if (mProgressIndicator != null) {\n            mProgressIndicator.setVisibility(state == STATE_LOADING ? View.VISIBLE : View.GONE);\n        }\n        if (mErrorLayout != null) {\n            mErrorLayout.setVisibility(state == STATE_ERROR ? View.VISIBLE : View.GONE);\n        }\n    }\n}\n", "=\r\n        [1/2]this.spouse |-> spouse &*& spouse == null ? [1/2]this.spouse |-> null : [1/2]spouse.spouse |-> this;\r\n    \r\n    protected lemma void spouse_symm_helper()\r\n        requires valid(?s) &*& [1/2]this.spouse |-> ?s0;\r\n        ensures valid(s) &*& [1/2]this.spouse |-> s0 &*& s == s0;\r\n    {\r\n        open valid(s);\r\n        close valid(s);\r\n    }\r\n    \r\n    @*/\r\n    \r\n    public /*lemma*/ void spouse_symm()\r\n        //@ requires valid(?s) &*& s.valid(?ss);\r\n        //@ ensures valid(s) &*& s.valid(ss) &*& ss == this;\r\n    {\r\n        //@ open valid(s);\r\n        //@ spouse.spouse_symm_helper();\r\n        //@ close valid(s);\r\n    }\r\n\r\n    public Person()\r\n        //@ requires true;\r\n        //@ ensures valid(null);\r\n    {\r\n        //@ close valid(null);\r\n    }\r\n    \r\n    public Person getSpouse()\r\n        //@ requires valid(?s);\r\n        //@ ensures valid(s) &*& result == s;\r\n    {\r\n        //@ open valid(s);\r\n        return spouse;\r\n        //@ close valid(s);\r\n    }\r\n    \r\n    protected void setSpouse(Person other)\r\n        //@ requires valid(null) &*& other.spouse |-> null;\r\n        //@ ensures valid(other) &*& [1/2]other.spouse |-> this &*& [1/2]spouse |-> other;\r\n    {\r\n        //@ open valid(null);\r\n        spouse = other;\r\n        other.spouse = this;\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    protected void clearSpouse()\r\n        //@ requires [1/2]spouse |-> ?s &*& valid(?ss) &*& [1/2]s.spouse |-> _;\r\n        //@ ensures valid(null) &*& s.spouse |-> null &*& ss == s;\r\n    {\r\n        //@ open valid(ss);\r\n        spouse.spouse = null;\r\n        spouse = null;\r\n        //@ close valid(null);\r\n    }\r\n    \r\n    void marry(Person other)\r\n        //@ requires valid(null) &*& other.valid(null);\r\n        //@ ensures valid(other) &*& other.valid(this);\r\n    {\r\n        //@ open valid(null);\r\n        other.setSpouse(this);\r\n        //@ close valid(other);\r\n    }\r\n    \r\n    void divorce()\r\n        //@ requires valid(?other) &*& other.valid(?ss);\r\n        //@ ensures valid(null) &*& other.valid(null) &*& ss == this;\r\n    {\r\n        //@ open valid(other);\r\n        spouse.clearSpouse();\r\n        //@ close valid(null);\r\n    }\r\n\r\n}\r\n\r\nclass Program {\r\n\r\n    public static void main(String[] args)\r\n        //@ requires true;\r\n        //@ ensures true;\r\n    {\r\n        Person a = new Person();\r\n        Person b = new Person();\r\n        a.marry(b);\r\n        b.divorce();\r\n    }\r\n\r\n}", "s.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n * of the Software, and to permit persons to whom the Software is furnished to do\n * so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\nimport fj.*;\nimport static org.codehaus.mojo.unix.maven.rpm.RpmMojoUtil.*;\nimport org.codehaus.mojo.unix.maven.rpm.*;\n\n/**\n * @author <a href=\"mailto:trygvis@inamo.no\">Trygve Laugst&oslash;l</a>\n * @goal package-rpm\n * @phase package\n * @requiresDependencyResolution runtime\n */\n@SuppressWarnings( \"UnusedDeclaration\" )\npublic class PackageRpmMojo\n    extends AbstractPackageMojo<RpmUnixPackage, RpmUnixPackage.RpmPreparedPackage>\n{\n    /**\n     * @parameter\n     */\n    protected RpmSpecificSettings rpm = new RpmSpecificSettings();\n\n    public PackageRpmMojo()\n    {\n        super( \"linux\", \"rpm\", \"rpm\" );\n    }\n\n    protected F<RpmUnixPackage, RpmUnixPackage> getValidateMojoSettingsAndApplyFormatSpecificSettingsToPackageF()\n    {\n        return new F<RpmUnixPackage, RpmUnixPackage>()\n        {\n            public RpmUnixPackage f( RpmUnixPackage unixPackage )\n            {\n                return validateMojoSettingsAndApplyFormatSpecificSettingsToPackage( rpm, unixPackage );\n            }\n        };\n    }\n}\n", "08, 2011 Eric Rizzo, IBM Corporation and others.\n * All rights reserved. This program and the accompanying materials\n * are made available under the terms of the Eclipse Public License v1.0\n * which accompanies this distribution, and is available at\n * http://www.eclipse.org/legal/epl-v10.html\n *\n * Contributors:\n *    Eric Rizzo - initial API and implementation (see Bug 210255)\n *******************************************************************************/\npackage org.eclipse.jdt.internal.ui.actions;\n\nimport org.eclipse.core.runtime.Assert;\n\nimport org.eclipse.jface.action.Action;\nimport org.eclipse.jface.viewers.TreeViewer;\n\nimport org.eclipse.ui.PlatformUI;\n\nimport org.eclipse.jdt.internal.ui.IJavaHelpContextIds;\nimport org.eclipse.jdt.internal.ui.JavaPluginImages;\n\n\n/**\n * An {@link Action} that will collapse all nodes in a given {@link TreeViewer}.\n *\n * @since 3.4\n */\npublic class CollapseAllAction extends Action {\n\n\tprivate final TreeViewer fViewer;\n\n\tpublic CollapseAllAction(TreeViewer viewer) {\n\t\tsuper(ActionMessages.CollapsAllAction_label, JavaPluginImages.DESC_ELCL_COLLAPSEALL);\n\t\tsetToolTipText(ActionMessages.CollapsAllAction_tooltip);\n\t\tsetDescription(ActionMessages.CollapsAllAction_description);\n\t\tPlatformUI.getWorkbench().getHelpSystem().setHelp(this, IJavaHelpContextIds.COLLAPSE_ALL_ACTION);\n\t\tAssert.isNotNull(viewer);\n\t\tfViewer= viewer;\n\t}\n\n\t@Override\n\tpublic void run() {\n\t\ttry {\n\t\t\tfViewer.getControl().setRedraw(false);\n\t\t\tfViewer.collapseAll();\n\t\t} finally {\n\t\t\tfViewer.getControl().setRedraw(true);\n\t\t}\n\t}\n\n}\n", "", "\nimport mod.steamnsteel.mcgui.client.gui.GuiRenderer;\nimport mod.steamnsteel.mcgui.client.gui.GuiTexture;\nimport mod.steamnsteel.mcgui.client.gui.IGuiTemplate;\nimport mod.steamnsteel.mcgui.client.gui.IModelView;\nimport mod.steamnsteel.mcgui.client.gui.controls.ButtonControl;\nimport net.minecraft.client.renderer.GlStateManager;\nimport net.minecraft.client.renderer.RenderHelper;\nimport net.minecraft.item.ItemStack;\nimport org.lwjgl.opengl.GL11;\nimport org.lwjgl.util.Rectangle;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ProjectTableRecipeControl extends ButtonControl implements IGuiTemplate<ProjectTableRecipeControl>, IModelView<ProjectTableRecipe>\n{\n    private final GuiTexture craftableTexture;\n    private final GuiTexture uncraftableTexture;\n    private ProjectTableRecipe recipe = null;\n\n    public ProjectTableRecipeControl(GuiRenderer guiRenderer, GuiTexture craftableTexture, GuiTexture uncraftableTexture)\n    {\n        super(guiRenderer, new Rectangle(0, 0, craftableTexture.getBounds().getWidth(), craftableTexture.getBounds().getHeight()));\n        this.craftableTexture = craftableTexture;\n        this.uncraftableTexture = uncraftableTexture;\n\n        setDefaultTexture(craftableTexture);\n        setDisabledTexture(uncraftableTexture);\n        setHoverTexture(craftableTexture);\n        setPressedTexture(uncraftableTexture);\n    }\n\n    @Override\n    public void draw() {\n        if (recipe == null) { return; }\n        super.draw();\n\n        GlStateManager.enableRescaleNormal();\n        final ImmutableList<ItemStack> output = recipe.getOutput();\n        final ItemStack outputItemStack = output.get(0);\n        if (output.size() == 1 && outputItemStack.getItem() != null)\n        {\n            RenderHelper.enableGUIStandardItemLighting();\n            getGuiRenderer().renderItem(this, outputItemStack, 2, 3);\n            RenderHelper.disableStandardItemLighting();\n\n            if (outputItemStack.stackSize > 1)\n            {\n                final String craftedItemCount = String.format(\"%d\", outputItemStack.stackSize);\n                final int textWidth = getGuiRenderer().getStringWidth(craftedItemCount);\n\n                GlStateManager.depthFunc(GL11.GL_ALWAYS);\n                getGuiRenderer().drawStringWithShadow(this, craftedItemCount, 16 - textWidth + 2, 12, 16777215);\n                GlStateManager.depthFunc(GL11.GL_LEQUAL);\n\n            }\n            getGuiRenderer().drawStringWithShadow(this, recipe.getDisplayName(), 2 + 20, 8, 16777215);\n        }\n\n        final int inputItemCount = recipe.getConsolidatedInput().size();\n\n        for (int j = 0; j < inputItemCount; ++j) {\n            final ItemStack inputItemStack = recipe.getConsolidatedInput().get(j);\n\n            final String requiredItemCount = String.format(\"%d\", inputItemStack.stackSize);\n            final int textWidth = getGuiRenderer().getStringWidth(requiredItemCount);\n\n            final int border = 1;\n            final int padding = 2;\n            final int itemSize = 16;\n\n            getGuiRenderer().renderItem(this, inputItemStack, getBounds().getWidth() - border - (itemSize + padding) * (j + border), padding + border);\n\n            GlStateManager.depthFunc(GL11.GL_ALWAYS);\n            getGuiRenderer().drawStringWithShadow(this, requiredItemCount, getBounds().getWidth() - border - (itemSize + padding) * j - textWidth - border , 12, 16777215);\n            GlStateManager.depthFunc(GL11.GL_LEQUAL);\n        }\n\n        GlStateManager.disableRescaleNormal();\n\n    }\n\n    public ProjectTableRecipe getRecipe()\n    {\n        return recipe;\n    }\n\n    public void setRecipe(ProjectTableRecipe recipe)\n    {\n        this.recipe = recipe;\n    }\n\n    @Override\n    public ProjectTableRecipeControl construct()\n    {\n        final ProjectTableRecipeControl concreteControl = new ProjectTableRecipeControl(getGuiRenderer(), craftableTexture, uncraftableTexture);\n\n        concreteControl.recipeCraftingEventListeners = recipeCraftingEventListeners;\n\n        return concreteControl;\n    }\n\n    @Override\n    public void setModel(ProjectTableRecipe recipe)\n    {\n        this.recipe = recipe;\n    }\n\n    @Override\n    protected void onButtonPressed() {\n        onRecipeCraftingInternal();\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // On Recipe Crafting Event Handling\n    /////////////////////////////////////////////////////////////////////////////\n\n    private void onRecipeCraftingInternal() {\n        onRecipeCrafting();\n\n        fireRecipeCraftingEvent();\n    }\n\n    protected void onRecipeCrafting() {\n    }\n\n    private void fireRecipeCraftingEvent()\n    {\n        for (final IRecipeCraftingEventListener eventListener : recipeCraftingEventListeners)\n        {\n            try {\n                eventListener.onRecipeCrafting(recipe);\n            } catch (final RuntimeException e) {\n                System.out.println(String.format(\"Exception in an IRecipeCraftingEventListener %s\", e));\n            }\n        }\n    }\n\n    private List<IRecipeCraftingEventListener> recipeCraftingEventListeners = new ArrayList<IRecipeCraftingEventListener>(1);\n\n    @SuppressWarnings(\"unused\")\n    public void addOnRecipeCraftingEventListener(IRecipeCraftingEventListener listener) {\n        recipeCraftingEventListeners.add(listener);\n    }\n    @SuppressWarnings(\"unused\")\n    public void removeOnRecipeCraftingEventListener(IRecipeCraftingEventListener listener) {\n        recipeCraftingEventListeners.remove(listener);\n    }\n}\n", "ng.*;\n\npublic class WeatherPanel extends Component implements Runnable{\n\tprotected int width, height;\n\tprotected boolean running;\n\n    protected Image BackImg;\n    protected Image OffScreenImage;\n    protected Graphics OffScreenGraphics;\n    protected Color RainColor;\n    protected int Season;\n    protected int LRdir;\n    protected int MaxCount;\n    protected int Radius;\n    protected int MaxSpeed;\n    protected int WndSpeed;\n    protected int Xpos[];\n    protected int Ypos[];\n    protected int Height[];\n    protected int Speed[];\n    protected boolean RndDirection;\n    protected boolean Accumulate;\n    protected boolean DevInfo;\n\n\tpublic WeatherPanel(int w, int h){\n\t\twidth = w;\n\t\theight = h;\n\n        RainColor = new Color(145, 164, 164);\n        Season = 1;\n        LRdir = 2;\n        MaxCount = 100;\n        Radius = 2;\n        MaxSpeed = 8;\n        WndSpeed = 0;\n        Xpos = new int[1024];\n        Ypos = new int[1024];\n        Height = new int[1024];\n        Speed = new int[1024];\n        RndDirection = true;\n        Accumulate = false;\n        DevInfo = false;\n\t}\n\n\tpublic Dimension getPreferredSize(){\n\t\treturn new Dimension(width, height);\n\t}\n\n\tpublic void start(){\n\t\trunning = true;\n\t\tThread thread = new Thread(this);\n\t\tthread.start();\n\t}\n\n\tpublic void stop(){\n\t\trunning = false;\n\t}\n\n\tpublic void run(){\n\t\twhile (running){\n\t\t\trepaint();\n\t\t\ttry{\n\t\t\t\tThread.sleep(100);\n\t\t\t}catch(Exception e){\n\t\t\t}\n\t\t}\n\t}\n\n\tpublic void paint(Graphics g){\n\t\tif (OffScreenImage == null){\n\t\t\tOffScreenImage = createImage(getWidth(), getHeight());\n\t\t\tOffScreenGraphics = OffScreenImage.getGraphics();\n\t\t\tfor (int I = 0; I < MaxCount; I++){\n\t\t\t\tSpeed[I] = (int)(Randomizer.getNextRandom() * MaxSpeed) + 3;\n\t\t\t\tXpos[I] = (int)(Randomizer.getNextRandom() * getWidth());\n\t\t\t\tYpos[I] = (int)(Randomizer.getNextRandom() * getHeight());\n\t\t\t}\n\n\t\t\tint height = getHeight();\n\t\t\tfor (int I = 0; I < 1024; I++){\n\t\t\t\tHeight[I] = height;\n\t\t\t}\n\t\t}\n\n\t\train(g);\n\t}\n\n    protected void rain(Graphics g){\n        int Stat = 0;\n        OffScreenGraphics.setColor(getBackground());\n        OffScreenGraphics.fillRect(0, 0, getWidth(), getHeight());\n        OffScreenGraphics.setColor(RainColor);\n        //OffScreenGraphics.drawImage(BackImg, 0, 0, getWidth(), getHeight(), this);\n        Stat = (int)(Randomizer.getNextRandom() * 100.0);\n        if (RndDirection){\n            if (Stat > 0 && Stat < 5){\n                LRdir = 1;\n                WndSpeed = (int)(Randomizer.getNextRandom() * -5.0);\n            }\n            else if (Stat > 55 && Stat < 60){\n                LRdir = 3;\n                WndSpeed = (int)(Randomizer.getNextRandom() * 5.0);\n            }else if (Stat > 98){\n                LRdir = 2;\n                WndSpeed = 0;\n            }\n        }\n\n\t\tfor (int I = 0; I < MaxCount; I++){\n            Ypos[I] += Speed[I];\n            if (LRdir == 1)\n                Xpos[I] += WndSpeed;\n            else if (LRdir == 3)\n                Xpos[I] += WndSpeed;\n            if (Xpos[I] < 0)\n                Xpos[I] = getWidth() - 1;\n            if (Xpos[I] > getWidth())\n                Xpos[I] = 1;\n            if (Ypos[I] > getHeight()){\n                Ypos[I] = 0;\n                Xpos[I] = (int)(Randomizer.getNextRandom() * getWidth());\n            }\n            OffScreenGraphics.drawLine(Xpos[I], Ypos[I], Xpos[I] + WndSpeed / 2, Ypos[I] + 2);\n            OffScreenGraphics.drawLine(Xpos[I], Ypos[I] + 1, Xpos[I] + WndSpeed / 2, Ypos[I] + 3);\n        }\n        g.drawImage(OffScreenImage, 0, 0, getWidth(), getHeight(), this);\n    }\n\n\tpublic static void main(String[] args){\n\t\tFrame frame = new Frame(\"Weather Panel\");\n\t\tWeatherPanel panWeather = new WeatherPanel(300, 300);\n\t\tframe.setLayout(new BorderLayout());\n\t\tframe.add(panWeather, BorderLayout.CENTER);\n\t\tframe.pack();\n\t\tframe.show();\n\t\tpanWeather.start();\n\t}\n}", "rsistence.ManyToOne;\nimport javax.persistence.OneToOne;\n\n@javax.persistence.Entity\npublic class Lance extends Entity{\n\n\tprivate double valor;\n\tprivate Calendar data;\n\t@OneToOne(fetch=FetchType.EAGER)\n\tprivate Usuario usuario;\n\t@ManyToOne\n\tprivate Leilao leilao;\n\n\tpublic double getValor() {\n\t\treturn valor;\n\t}\n\tpublic void setValor(double valor) {\n\t\tthis.valor = valor;\n\t}\n\tpublic Calendar getData() {\n\t\treturn data;\n\t}\n\tpublic void setData(Calendar data) {\n\t\tthis.data = data;\n\t}\n\tpublic Usuario getUsuario() {\n\t\treturn usuario;\n\t}\n\tpublic void setUsuario(Usuario usuario) {\n\t\tthis.usuario = usuario;\n\t}\n\tpublic Leilao getLeilao() {\n\t\treturn leilao;\n\t}\n\tpublic void setLeilao(Leilao leilao) {\n\t\tthis.leilao = leilao;\n\t}\n\t\n\t\n}\n", "AbstractUnitTest {\n    // TODO\n}\n", " ReactActivity {\n\n    /**\n     * Returns the name of the main component registered from JavaScript.\n     * This is used to schedule rendering of the component.\n     */\n    @Override\n    protected String getMainComponentName() {\n        return \"GrooveBass\";\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.tools.jconsole;\n\nimport java.awt.*;\nimport java.util.ArrayList;\n\nimport javax.swing.*;\nimport javax.swing.border.*;\n\n\n@SuppressWarnings(\"serial\")\nclass OverviewTab extends Tab {\n    JPanel gridPanel;\n    TimeComboBox timeComboBox;\n\n    public static String getTabName() {\n        return Messages.OVERVIEW;\n    }\n\n    public OverviewTab(VMPanel vmPanel) {\n        super(vmPanel, getTabName());\n\n        setBorder(new EmptyBorder(4, 4, 3, 4));\n        setLayout(new BorderLayout());\n\n        JPanel topPanel     = new JPanel(new BorderLayout());\n        add(topPanel, BorderLayout.NORTH);\n\n        JPanel controlPanel = new JPanel(new FlowLayout(FlowLayout.CENTER, 20, 5));\n        topPanel.add(controlPanel, BorderLayout.CENTER);\n\n        timeComboBox = new TimeComboBox();\n        LabeledComponent lc = new LabeledComponent(Messages.TIME_RANGE_COLON,\n                                                   Resources.getMnemonicInt(Messages.TIME_RANGE_COLON),\n                                                   timeComboBox);\n        controlPanel.add(lc);\n\n        gridPanel = new JPanel(new AutoGridLayout(10, 6));\n        gridPanel.setBorder(null);\n        JScrollPane sp = new JScrollPane(gridPanel);\n        sp.setBorder(null);\n        sp.setViewportBorder(null);\n        add(sp, BorderLayout.CENTER);\n\n        // Note that panels are added on first update\n    }\n\n\n    public SwingWorker<?, ?> newSwingWorker() {\n        return new SwingWorker<Object, Object>() {\n            public Object doInBackground() {\n                return null;\n            }\n\n            protected void done() {\n                if (gridPanel.getComponentCount() == 0) {\n                    final ArrayList<Plotter> plotters = new ArrayList<Plotter>();\n                    for (Tab tab : vmPanel.getTabs()) {\n                        OverviewPanel[] ops = tab.getOverviewPanels();\n                        if (ops != null) {\n                            for (OverviewPanel op : ops) {\n                                gridPanel.add(op);\n                                Plotter plotter = op.getPlotter();\n                                if (plotter != null) {\n                                    plotters.add(plotter);\n                                    timeComboBox.addPlotter(plotter);\n                                }\n                            }\n                        }\n                    }\n                    if (plotters.size() > 0) {\n                        workerAdd(new Runnable() {\n                            public void run() {\n                                ProxyClient proxyClient = vmPanel.getProxyClient();\n                                for (Plotter plotter : plotters) {\n                                    proxyClient.addWeakPropertyChangeListener(plotter);\n                                }\n                            }\n                        });\n                    }\n                    if (getParent() instanceof JTabbedPane) {\n                        Utilities.updateTransparency((JTabbedPane)getParent());\n                    }\n                }\n            }\n        };\n    }\n\n\n\n    private class AutoGridLayout extends GridLayout {\n        public AutoGridLayout(int hGap, int vGap) {\n            super(0, 1, hGap, vGap);\n        }\n\n        public Dimension preferredLayoutSize(Container parent) {\n            return minimumLayoutSize(parent);\n        }\n\n        public Dimension minimumLayoutSize(Container parent) {\n            updateColumns(parent);\n            return super.minimumLayoutSize(parent);\n        }\n\n        private void updateColumns(Container parent) {\n            // Use the outer panel width, not the scrolling gridPanel\n            int parentWidth = OverviewTab.this.getWidth();\n\n            int columnWidth = 1;\n\n            for (Component c : parent.getComponents()) {\n                columnWidth = Math.max(columnWidth, c.getPreferredSize().width);\n            }\n\n            int n = parent.getComponentCount();\n            int maxCols = Math.min(n, parentWidth / columnWidth);\n\n            for (int columns = maxCols; columns >= 1; columns--) {\n                if (columns == 1) {\n                    setColumns(maxCols);\n                } else if ((n % columns) == 0) {\n                    setColumns(columns);\n                    break;\n                }\n            }\n        }\n    }\n}\n", "\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.astir_trotter.atcustom.ui.iconics.pkg;\n\nimport android.content.Context;\nimport android.graphics.Typeface;\n\nimport com.astir_trotter.atcustom.ui.iconics.core.typeface.IIcon;\nimport com.astir_trotter.atcustom.ui.iconics.core.typeface.ITypeface;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.LinkedList;\n\npublic class FoundationIcons implements ITypeface {\n    private static final String TTF_FILE = \"foundation-icons-font-v3.0.0.1.ttf\";\n    private static Typeface typeface = null;\n    private static HashMap<String, Character> mChars;\n\n    @Override\n    public IIcon getIcon(String key) {\n        return Icon.valueOf(key);\n    }\n\n    @Override\n    public HashMap<String, Character> getCharacters() {\n        if (mChars == null) {\n            HashMap<String, Character> aChars = new HashMap<String, Character>();\n            for (Icon v : Icon.values()) {\n                aChars.put(v.name(), v.character);\n            }\n            mChars = aChars;\n        }\n        return mChars;\n    }\n\n    @Override\n    public String getMappingPrefix() {\n        return \"fou\";\n    }\n\n    @Override\n    public String getFontName() {\n        return \"Foundation Icons\";\n    }\n\n    @Override\n    public String getVersion() {\n        return \"3.0.0.1\";\n    }\n\n    @Override\n    public int getIconCount() {\n        return mChars.size();\n    }\n\n    @Override\n    public Collection<String> getIcons() {\n        Collection<String> icons = new LinkedList<String>();\n        for (Icon value : Icon.values()) {\n            icons.add(value.name());\n        }\n        return icons;\n    }\n\n    @Override\n    public String getAuthor() {\n        return \"ZURB Inc.\";\n    }\n\n    @Override\n    public String getUrl() {\n        return \"http://zurb.com/playground/foundation-icon-fonts-3\";\n    }\n\n    @Override\n    public String getDescription() {\n        return \"Customize your icons to be any size, color, style in CSS\";\n    }\n\n    @Override\n    public String getLicense() {\n        return \"MIT Open Source License\";\n    }\n\n    @Override\n    public String getLicenseUrl() {\n        return \"https://github.com/zurb/foundation-icons/blob/master/MIT-LICENSE.txt\";\n    }\n\n    @Override\n    public Typeface getTypeface(Context context) {\n        if (typeface == null) {\n            try {\n                typeface = Typeface.createFromAsset(context.getAssets(), \"fonts/\" + TTF_FILE);\n            } catch (Exception e) {\n                return null;\n            }\n        }\n        return typeface;\n    }\n\n    public enum Icon implements IIcon {\n        fou_address_book('\\uf100'),\n\t\tfou_alert('\\uf101'),\n\t\tfou_align_center('\\uf102'),\n\t\tfou_align_justify('\\uf103'),\n\t\tfou_align_left('\\uf104'),\n\t\tfou_align_right('\\uf105'),\n\t\tfou_anchor('\\uf106'),\n\t\tfou_annotate('\\uf107'),\n\t\tfou_archive('\\uf108'),\n\t\tfou_arrow_down('\\uf109'),\n\t\tfou_arrow_left('\\uf10a'),\n\t\tfou_arrow_right('\\uf10b'),\n\t\tfou_arrow_up('\\uf10c'),\n\t\tfou_arrows_compress('\\uf10d'),\n\t\tfou_arrows_expand('\\uf10e'),\n\t\tfou_arrows_in('\\uf10f'),\n\t\tfou_arrows_out('\\uf110'),\n\t\tfou_asl('\\uf111'),\n\t\tfou_asterisk('\\uf112'),\n\t\tfou_at_sign('\\uf113'),\n\t\tfou_background_color('\\uf114'),\n\t\tfou_battery_empty('\\uf115'),\n\t\tfou_battery_full('\\uf116'),\n\t\tfou_battery_half('\\uf117'),\n\t\tfou_bitcoin_circle('\\uf118'),\n\t\tfou_bitcoin('\\uf119'),\n\t\tfou_blind('\\uf11a'),\n\t\tfou_bluetooth('\\uf11b'),\n\t\tfou_bold('\\uf11c'),\n\t\tfou_book_bookmark('\\uf11d'),\n\t\tfou_book('\\uf11e'),\n\t\tfou_bookmark('\\uf11f'),\n\t\tfou_braille('\\uf120'),\n\t\tfou_burst_new('\\uf121'),\n\t\tfou_burst_sale('\\uf122'),\n\t\tfou_burst('\\uf123'),\n\t\tfou_calendar('\\uf124'),\n\t\tfou_camera('\\uf125'),\n\t\tfou_check('\\uf126'),\n\t\tfou_checkbox('\\uf127'),\n\t\tfou_clipboard_notes('\\uf128'),\n\t\tfou_clipboard_pencil('\\uf129'),\n\t\tfou_clipboard('\\uf12a'),\n\t\tfou_clock('\\uf12b'),\n\t\tfou_closed_caption('\\uf12c'),\n\t\tfou_cloud('\\uf12d'),\n\t\tfou_comment_minus('\\uf12e'),\n\t\tfou_comment_quotes('\\uf12f'),\n\t\tfou_comment_video('\\uf130'),\n\t\tfou_comment('\\uf131'),\n\t\tfou_comments('\\uf132'),\n\t\tfou_compass('\\uf133'),\n\t\tfou_contrast('\\uf134'),\n\t\tfou_credit_card('\\uf135'),\n\t\tfou_crop('\\uf136'),\n\t\tfou_crown('\\uf137'),\n\t\tfou_css3('\\uf138'),\n\t\tfou_database('\\uf139'),\n\t\tfou_die_five('\\uf13a'),\n\t\tfou_die_four('\\uf13b'),\n\t\tfou_die_one('\\uf13c'),\n\t\tfou_die_six('\\uf13d'),\n\t\tfou_die_three('\\uf13e'),\n\t\tfou_die_two('\\uf13f'),\n\t\tfou_dislike('\\uf140'),\n\t\tfou_dollar_bill('\\uf141'),\n\t\tfou_dollar('\\uf142'),\n\t\tfou_download('\\uf143'),\n\t\tfou_eject('\\uf144'),\n\t\tfou_elevator('\\uf145'),\n\t\tfou_euro('\\uf146'),\n\t\tfou_eye('\\uf147'),\n\t\tfou_fast_forward('\\uf148'),\n\t\tfou_female_symbol('\\uf149'),\n\t\tfou_female('\\uf14a'),\n\t\tfou_filter('\\uf14b'),\n\t\tfou_first_aid('\\uf14c'),\n\t\tfou_flag('\\uf14d'),\n\t\tfou_folder_add('\\uf14e'),\n\t\tfou_folder_lock('\\uf14f'),\n\t\tfou_folder('\\uf150'),\n\t\tfou_foot('\\uf151'),\n\t\tfou_foundation('\\uf152'),\n\t\tfou_graph_bar('\\uf153'),\n\t\tfou_graph_horizontal('\\uf154'),\n\t\tfou_graph_pie('\\uf155'),\n\t\tfou_graph_trend('\\uf156'),\n\t\tfou_guide_dog('\\uf157'),\n\t\tfou_hearing_aid('\\uf158'),\n\t\tfou_heart('\\uf159'),\n\t\tfou_home('\\uf15a'),\n\t\tfou_html5('\\uf15b'),\n\t\tfou_indent_less('\\uf15c'),\n\t\tfou_indent_more('\\uf15d'),\n\t\tfou_info('\\uf15e'),\n\t\tfou_italic('\\uf15f'),\n\t\tfou_key('\\uf160'),\n\t\tfou_laptop('\\uf161'),\n\t\tfou_layout('\\uf162'),\n\t\tfou_lightbulb('\\uf163'),\n\t\tfou_like('\\uf164'),\n\t\tfou_link('\\uf165'),\n\t\tfou_list_bullet('\\uf166'),\n\t\tfou_list_number('\\uf167'),\n\t\tfou_list_thumbnails('\\uf168'),\n\t\tfou_list('\\uf169'),\n\t\tfou_lock('\\uf16a'),\n\t\tfou_loop('\\uf16b'),\n\t\tfou_magnifying_glass('\\uf16c'),\n\t\tfou_mail('\\uf16d'),\n\t\tfou_male_female('\\uf16e'),\n\t\tfou_male_symbol('\\uf16f'),\n\t\tfou_male('\\uf170'),\n\t\tfou_map('\\uf171'),\n\t\tfou_marker('\\uf172'),\n\t\tfou_megaphone('\\uf173'),\n\t\tfou_microphone('\\uf174'),\n\t\tfou_minus_circle('\\uf175'),\n\t\tfou_minus('\\uf176'),\n\t\tfou_mobile_signal('\\uf177'),\n\t\tfou_mobile('\\uf178'),\n\t\tfou_monitor('\\uf179'),\n\t\tfou_mountains('\\uf17a'),\n\t\tfou_music('\\uf17b'),\n\t\tfou_next('\\uf17c'),\n\t\tfou_no_dogs('\\uf17d'),\n\t\tfou_no_smoking('\\uf17e'),\n\t\tfou_page_add('\\uf17f'),\n\t\tfou_page_copy('\\uf180'),\n\t\tfou_page_csv('\\uf181'),\n\t\tfou_page_delete('\\uf182'),\n\t\tfou_page_doc('\\uf183'),\n\t\tfou_page_edit('\\uf184'),\n\t\tfou_page_export_csv('\\uf185'),\n\t\tfou_page_export_doc('\\uf186'),\n\t\tfou_page_export_pdf('\\uf187'),\n\t\tfou_page_export('\\uf188'),\n\t\tfou_page_filled('\\uf189'),\n\t\tfou_page_multiple('\\uf18a'),\n\t\tfou_page_pdf('\\uf18b'),\n\t\tfou_page_remove('\\uf18c'),\n\t\tfou_page_search('\\uf18d'),\n\t\tfou_page('\\uf18e'),\n\t\tfou_paint_bucket('\\uf18f'),\n\t\tfou_paperclip('\\uf190'),\n\t\tfou_pause('\\uf191'),\n\t\tfou_paw('\\uf192'),\n\t\tfou_paypal('\\uf193'),\n\t\tfou_pencil('\\uf194'),\n\t\tfou_photo('\\uf195'),\n\t\tfou_play_circle('\\uf196'),\n\t\tfou_play_video('\\uf197'),\n\t\tfou_play('\\uf198'),\n\t\tfou_plus('\\uf199'),\n\t\tfou_pound('\\uf19a'),\n\t\tfou_power('\\uf19b'),\n\t\tfou_previous('\\uf19c'),\n\t\tfou_price_tag('\\uf19d'),\n\t\tfou_pricetag_multiple('\\uf19e'),\n\t\tfou_print('\\uf19f'),\n\t\tfou_prohibited('\\uf1a0'),\n\t\tfou_projection_screen('\\uf1a1'),\n\t\tfou_puzzle('\\uf1a2'),\n\t\tfou_quote('\\uf1a3'),\n\t\tfou_record('\\uf1a4'),\n\t\tfou_refresh('\\uf1a5'),\n\t\tfou_results_demographics('\\uf1a6'),\n\t\tfou_results('\\uf1a7'),\n\t\tfou_rewind_ten('\\uf1a8'),\n\t\tfou_rewind('\\uf1a9'),\n\t\tfou_rss('\\uf1aa'),\n\t\tfou_safety_cone('\\uf1ab'),\n\t\tfou_save('\\uf1ac'),\n\t\tfou_share('\\uf1ad'),\n\t\tfou_sheriff_badge('\\uf1ae'),\n\t\tfou_shield('\\uf1af'),\n\t\tfou_shopping_bag('\\uf1b0'),\n\t\tfou_shopping_cart('\\uf1b1'),\n\t\tfou_shuffle('\\uf1b2'),\n\t\tfou_skull('\\uf1b3'),\n\t\tfou_social_500px('\\uf1b4'),\n\t\tfou_social_adobe('\\uf1b5'),\n\t\tfou_social_amazon('\\uf1b6'),\n\t\tfou_social_android('\\uf1b7'),\n\t\tfou_social_apple('\\uf1b8'),\n\t\tfou_social_behance('\\uf1b9'),\n\t\tfou_social_bing('\\uf1ba'),\n\t\tfou_social_blogger('\\uf1bb'),\n\t\tfou_social_delicious('\\uf1bc'),\n\t\tfou_social_designer_news('\\uf1bd'),\n\t\tfou_social_deviant_art('\\uf1be'),\n\t\tfou_social_digg('\\uf1bf'),\n\t\tfou_social_dribbble('\\uf1c0'),\n\t\tfou_social_drive('\\uf1c1'),\n\t\tfou_social_dropbox('\\uf1c2'),\n\t\tfou_social_evernote('\\uf1c3'),\n\t\tfou_social_facebook('\\uf1c4'),\n\t\tfou_social_flickr('\\uf1c5'),\n\t\tfou_social_forrst('\\uf1c6'),\n\t\tfou_social_foursquare('\\uf1c7'),\n\t\tfou_social_game_center('\\uf1c8'),\n\t\tfou_social_github('\\uf1c9'),\n\t\tfou_social_google_plus('\\uf1ca'),\n\t\tfou_social_hacker_news('\\uf1cb'),\n\t\tfou_social_hi5('\\uf1cc'),\n\t\tfou_social_instagram('\\uf1cd'),\n\t\tfou_social_joomla('\\uf1ce'),\n\t\tfou_social_lastfm('\\uf1cf'),\n\t\tfou_social_linkedin('\\uf1d0'),\n\t\tfou_social_medium('\\uf1d1'),\n\t\tfou_social_myspace('\\uf1d2'),\n\t\tfou_social_orkut('\\uf1d3'),\n\t\tfou_social_path('\\uf1d4'),\n\t\tfou_social_picasa('\\uf1d5'),\n\t\tfou_social_pinterest('\\uf1d6'),\n\t\tfou_social_rdio('\\uf1d7'),\n\t\tfou_social_reddit('\\uf1d8'),\n\t\tfou_social_skillshare('\\uf1d9'),\n\t\tfou_social_skype('\\uf1da'),\n\t\tfou_social_smashing_mag('\\uf1db'),\n\t\tfou_social_snapchat('\\uf1dc'),\n\t\tfou_social_spotify('\\uf1dd'),\n\t\tfou_social_squidoo('\\uf1de'),\n\t\tfou_social_stack_overflow('\\uf1df'),\n\t\tfou_social_steam('\\uf1e0'),\n\t\tfou_social_stumbleupon('\\uf1e1'),\n\t\tfou_social_treehouse('\\uf1e2'),\n\t\tfou_social_tumblr('\\uf1e3'),\n\t\tfou_social_twitter('\\uf1e4'),\n\t\tfou_social_vimeo('\\uf1e5'),\n\t\tfou_social_windows('\\uf1e6'),\n\t\tfou_social_xbox('\\uf1e7'),\n\t\tfou_social_yahoo('\\uf1e8'),\n\t\tfou_social_yelp('\\uf1e9'),\n\t\tfou_social_youtube('\\uf1ea'),\n\t\tfou_social_zerply('\\uf1eb'),\n\t\tfou_social_zurb('\\uf1ec'),\n\t\tfou_sound('\\uf1ed'),\n\t\tfou_star('\\uf1ee'),\n\t\tfou_stop('\\uf1ef'),\n\t\tfou_strikethrough('\\uf1f0'),\n\t\tfou_subscript('\\uf1f1'),\n\t\tfou_superscript('\\uf1f2'),\n\t\tfou_tablet_landscape('\\uf1f3'),\n\t\tfou_tablet_portrait('\\uf1f4'),\n\t\tfou_target_two('\\uf1f5'),\n\t\tfou_target('\\uf1f6'),\n\t\tfou_telephone_accessible('\\uf1f7'),\n\t\tfou_telephone('\\uf1f8'),\n\t\tfou_text_color('\\uf1f9'),\n\t\tfou_thumbnails('\\uf1fa'),\n\t\tfou_ticket('\\uf1fb'),\n\t\tfou_torso_business('\\uf1fc'),\n\t\tfou_torso_female('\\uf1fd'),\n\t\tfou_torso('\\uf1fe'),\n\t\tfou_torsos_all_female('\\uf1ff'),\n\t\tfou_torsos_all('\\uf200'),\n\t\tfou_torsos_female_male('\\uf201'),\n\t\tfou_torsos_male_female('\\uf202'),\n\t\tfou_torsos('\\uf203'),\n\t\tfou_trash('\\uf204'),\n\t\tfou_trees('\\uf205'),\n\t\tfou_trophy('\\uf206'),\n\t\tfou_underline('\\uf207'),\n\t\tfou_universal_access('\\uf208'),\n\t\tfou_unlink('\\uf209'),\n\t\tfou_unlock('\\uf20a'),\n\t\tfou_upload_cloud('\\uf20b'),\n\t\tfou_upload('\\uf20c'),\n\t\tfou_usb('\\uf20d'),\n\t\tfou_video('\\uf20e'),\n\t\tfou_volume_none('\\uf20f'),\n\t\tfou_volume_strike('\\uf210'),\n\t\tfou_volume('\\uf211'),\n\t\tfou_web('\\uf212'),\n\t\tfou_wheelchair('\\uf213'),\n\t\tfou_widget('\\uf214'),\n\t\tfou_wrench('\\uf215'),\n\t\tfou_x_circle('\\uf216'),\n\t\tfou_x('\\uf217'),\n\t\tfou_yen('\\uf218'),\n\t\tfou_zoom_in('\\uf219'),\n\t\tfou_zoom_out('\\uf21a');\n\n        char character;\n\n        Icon(char character) {\n            this.character = character;\n        }\n\n        public String getFormattedName() {\n            return \"{\" + name() + \"}\";\n        }\n\n        public char getCharacter() {\n            return character;\n        }\n\n        public String getName() {\n            return name();\n        }\n\n        // remember the typeface so we can use it later\n        private static ITypeface typeface;\n\n        public ITypeface getTypeface() {\n            if (typeface == null) {\n                typeface = new FoundationIcons();\n            }\n            return typeface;\n        }\n    }\n}\n", "iesaer Str. 5, 01129 Dresden\n * All rights reserved.\n */\n\npackage service;\n\nimport java.io.IOException;\nimport java.util.Properties;\n\nimport javafx.concurrent.Service;\nimport javafx.concurrent.Task;\n\n/**\n * Service for updating word label.\n */\npublic class GameService extends Service<Boolean> {\n\n    /**\n     * Constant for property: display.time.in.ms\n     */\n    private static final String DISPLAY_TIME_IN_MS_PROPERTY = \"display.time.in.ms\";\n\n    /**\n     * Constant for property: words.to.show\n     */\n    private static final String WORDS_TO_SHOW_PROPERTY = \"words.to.show\";\n\n    /**\n     * Properties for running the game.\n     */\n    private Properties gameProperties;\n\n    /**\n     * Counter for numbers of execution.\n     */\n    private int numbersOfExecution = 0;\n\n    /**\n     * Maximum numbers of execution.\n     */\n    private int maxNumbersOfExecution;\n\n    public GameService() {\n        gameProperties = new Properties();\n        try {\n            gameProperties.load(getClass().getResourceAsStream(\"/default.properties\"));\n            maxNumbersOfExecution = Integer.parseInt(gameProperties.getProperty(WORDS_TO_SHOW_PROPERTY));\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n    @Override\n    protected Task<Boolean> createTask() {\n        return new GameTask(Long.parseLong(gameProperties.getProperty(DISPLAY_TIME_IN_MS_PROPERTY)), numbersOfExecution,\n                maxNumbersOfExecution);\n    }\n\n    public boolean showNextWord() {\n        if (numbersOfExecution < maxNumbersOfExecution) {\n            restart();\n            numbersOfExecution++;\n        } else {\n            cancelled();\n            return false;\n        }\n        return true;\n    }\n\n    /**\n     * Task.\n     */\n    private class GameTask extends Task<Boolean> {\n\n        private long timeToShowWord = 500;\n        private int currentExecution;\n        private int maxExecution;\n\n        private GameTask(long actualTimeToShowWord, int currentExecution, int maxExecution) {\n            this.timeToShowWord = actualTimeToShowWord;\n            this.currentExecution = currentExecution;\n            this.maxExecution = maxExecution;\n        }\n\n        @Override\n        protected Boolean call() throws Exception {\n            updateProgress(currentExecution, maxExecution);\n            updateMessage(\"Word 1\");\n            updateValue(false);\n            Thread.sleep(timeToShowWord);\n            updateMessage(\"\");\n            updateValue(true);\n            return true;\n        }\n    }\n}\n", " java.util.Set;\n\n/**\n * @author octopod\n */\npublic interface Element {\n\n\t/**\n\t * Returns true if:\n\t * <ul>\n\t *     <li>{@code getColor()} returns {@code TextColor.WHITE}</li>\n\t *     <li>{@code getStyles()} returns an empty set</li>\n\t *     <li>{@code getClickEvent()} returns {@code null}</li>\n\t *     <li>{@code getHoverEvent()} returns {@code null}</li>\n\t * </ul>\n\t * This means that this TextElement represents text that is not formatted at all.\n\t * @return\n\t */\n\tboolean isPlain();\n\n\t/**\n\t * Returns true if:\n\t * <ul>\n\t *     <li>{@code getText()} returns {@code \"\"}</li>\n\t *     <li>{@code isPlain()} returns {@code true}</li>\n\t * </ul>\n\t * This means the root ChatElement represents nothing.\n\t * @return\n\t */\n\tboolean isEmpty();\n\n\t/**\n\t * Returns true if:\n\t * <ul>\n\t *     <li>{@code getText()} returns {@code \"\"}</li>\n\t *     <li>{@code isPlain()} returns {@code false}</li>\n\t * </ul>\n\t * This means the root ChatElement represents an empty string\n\t * with formats placed on it.\n\t * @return\n\t */\n\tboolean isOnlyFormats();\n\n\tString getText();\n\n\tChatColor getColor();\n\n\tSet<ChatStyle> getStyles();\n\n\tTextMode getMode();\n\n\tClickEventEntry getClickEvent();\n\n\tHoverEventEntry getHoverEvent();\n\n\tList<Element> getChildren();\n\n\tString toString(int indent);\n\n\tElement text(String text);\n\n\tElement color(ChatColor color);\n\n\tElement style(ChatStyle... styles);\n\n\tElement style(Set<ChatStyle> styles);\n\n\tElement mode(TextMode mode);\n\n\tElement click(ClickEvent event, Element value);\n\n\tElement click(ClickEventEntry entry);\n\n\tElement hover(HoverEvent event, Element value);\n\n\tElement hover(HoverEventEntry entry);\n\n\tElement attachAndGet(Element element);\n\n\tElement attach(Element... elements);\n\n\tElement attach(List<Element> elements);\n\n\tElement detach(Element... elements);\n\n\tElement detach(List<Element> elements);\n\n\tElement detachAll();\n}\n", "e\n    public boolean isData() {\n        return true;\n    }\n    \n    @Override\n    public String disassemble(final Word word, final int n, final Machine machine) {\n        return \"\";\n    }\n    \n    @Override\n    public int execute(final Word word, final int n, final RegisterFile registerFile, final Memory memory, final Machine machine) throws IllegalMemAccessException, IllegalInstructionException {\n        throw new IllegalInstructionException(\"Cannot execute data\");\n    }\n}\n", "let.annotation.WebServlet;\nimport javax.servlet.http.HttpServlet;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\nimport model.ApplicationModel;\nimport model.ClientBean;\nimport model.ShoppingCartBean;\n\n/**\n * Servlet implementation class Checkout\n */\n@WebServlet(\"/Checkout\")\npublic class Checkout extends HttpServlet {\n\tprivate static final long serialVersionUID = 1L;\n       \n    /**\n     * @see HttpServlet#HttpServlet()\n     */\n    public Checkout() {\n        super();\n    }\n    @Override\n  \tpublic void init() throws ServletException {\n  \t\tsuper.init();\n  \t\ttry {\n  \t\t\tApplicationModel model = (ApplicationModel) this\n  \t\t\t\t\t.getServletContext().getAttribute(\"model\");\n  \t\t\tif (model == null) {\n  \t\t\t\tmodel = new ApplicationModel();\n  \t\t\t}\n  \t\t\tthis.getServletContext().setAttribute(\"model\", model);\n\n  \t\t} catch (ClassNotFoundException e) {\n  \t\t\tSystem.out.println(\"Class not loaded \" + e);\n  \t\t}\n\n  \t}\n\n\n\t/**\n\t * @see HttpServlet#doGet(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t// Setup the application root for static files\n\t\trequest.setAttribute(\"app_root\", request.getContextPath());\n\t\t\n\t\t//Only allow checkout if user is signed in\n\t\tClientBean client = (ClientBean) request.getSession().getAttribute(\"client\");\n\t\tif(client==null){\n\t\t\tresponse.sendRedirect(request.getContextPath()+\"/Authorization?action=login\");\n\t\t\treturn;\n\t\t} else {\n\t\t\tif(request.getParameter(\"action\") != null && request.getParameter(\"action\").equals(\"finalize\")){\n\t\t\t\t//Get the shopping cart\n\t\t\t\tShoppingCartBean sc  = (ShoppingCartBean) (request.getSession().getAttribute(\"shopping_cart\"));\n\t\t\t\t\n\t\t\t\tif(sc==null || sc.getItems().size()<1){\n\t\t\t\t\tresponse.sendRedirect(request.getContextPath() + \"/Catalog\");\n\t\t\t\t\treturn;\n\t\t\t\t} else {\n\t\t\t\t\t//Let's get the model\n\t\t\t\t\tApplicationModel m = (ApplicationModel) getServletContext().getAttribute(\"model\");\n\t\t\t\t\ttry {\n\t\t\t\t\t\tString filename = m.placeOrder(sc, client, this.getServletContext().getRealPath(\"purchaseOrders\"));\n\t\t\t\t\t\trequest.setAttribute(\"po_file\", filename);\n\t\t\t\t\t\trequest.getRequestDispatcher(\"OrderConfirmed.jspx\").forward(request, response);\n\t\t\t\t\t\trequest.getSession().setAttribute(\"shopping_cart\", null);\n\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else {\n\t\t\t\t//Otherwise just show the checkout page\n\t\t\t\trequest.getRequestDispatcher(\"Checkout.jspx\").forward(request, response);\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t\t\n\t}\n\n\t/**\n\t * @see HttpServlet#doPost(HttpServletRequest request, HttpServletResponse response)\n\t */\n\tprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {\n\t\t// TODO Auto-generated method stub\n\t}\n\n}\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.commons.lang3.mutable;\n\n/**\n * A mutable <code>int</code> wrapper.\n * \n * @see Integer\n * @since 2.1\n * @author Apache Software Foundation\n * @version $Id: MutableInt.java 916081 2010-02-25 01:28:13Z niallp $\n */\npublic class MutableInt extends Number implements Comparable<MutableInt>, Mutable<Number> {\n\n    /**\n     * Required for serialization support.\n     * \n     * @see java.io.Serializable\n     */\n    private static final long serialVersionUID = 512176391864L;\n\n    /** The mutable value. */\n    private int value;\n\n    /**\n     * Constructs a new MutableInt with the default value of zero.\n     */\n    public MutableInt() {\n        super();\n    }\n\n    /**\n     * Constructs a new MutableInt with the specified value.\n     * \n     * @param value  the initial value to store\n     */\n    public MutableInt(int value) {\n        super();\n        this.value = value;\n    }\n\n    /**\n     * Constructs a new MutableInt with the specified value.\n     * \n     * @param value  the initial value to store, not null\n     * @throws NullPointerException if the object is null\n     */\n    public MutableInt(Number value) {\n        super();\n        this.value = value.intValue();\n    }\n\n    /**\n     * Constructs a new MutableInt parsing the given string.\n     * \n     * @param value  the string to parse, not null\n     * @throws NumberFormatException if the string cannot be parsed into an int\n     * @since 2.5\n     */\n    public MutableInt(String value) throws NumberFormatException {\n        super();\n        this.value = Integer.parseInt(value);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the value as a Integer instance.\n     * \n     * @return the value as a Integer, never null\n     */\n    public Integer getValue() {\n        return new Integer(this.value);\n    }\n\n    /**\n     * Sets the value.\n     * \n     * @param value  the value to set\n     */\n    public void setValue(int value) {\n        this.value = value;\n    }\n\n    /**\n     * Sets the value from any Number instance.\n     * \n     * @param value  the value to set, not null\n     * @throws NullPointerException if the object is null\n     */\n    public void setValue(Number value) {\n        this.value = value.intValue();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Increments the value.\n     *\n     * @since Commons Lang 2.2\n     */\n    public void increment() {\n        value++;\n    }\n\n    /**\n     * Decrements the value.\n     *\n     * @since Commons Lang 2.2\n     */\n    public void decrement() {\n        value--;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds a value to the value of this instance.\n     * \n     * @param operand  the value to add, not null\n     * @since Commons Lang 2.2\n     */\n    public void add(int operand) {\n        this.value += operand;\n    }\n\n    /**\n     * Adds a value to the value of this instance.\n     * \n     * @param operand  the value to add, not null\n     * @throws NullPointerException if the object is null\n     * @since Commons Lang 2.2\n     */\n    public void add(Number operand) {\n        this.value += operand.intValue();\n    }\n\n    /**\n     * Subtracts a value from the value of this instance.\n     * \n     * @param operand  the value to subtract, not null\n     * @since Commons Lang 2.2\n     */\n    public void subtract(int operand) {\n        this.value -= operand;\n    }\n\n    /**\n     * Subtracts a value from the value of this instance.\n     * \n     * @param operand  the value to subtract, not null\n     * @throws NullPointerException if the object is null\n     * @since Commons Lang 2.2\n     */\n    public void subtract(Number operand) {\n        this.value -= operand.intValue();\n    }\n\n    //-----------------------------------------------------------------------\n    // shortValue and bytValue rely on Number implementation\n    /**\n     * Returns the value of this MutableInt as an int.\n     *\n     * @return the numeric value represented by this object after conversion to type int.\n     */\n    @Override\n    public int intValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this MutableInt as a long.\n     *\n     * @return the numeric value represented by this object after conversion to type long.\n     */\n    @Override\n    public long longValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this MutableInt as a float.\n     *\n     * @return the numeric value represented by this object after conversion to type float.\n     */\n    @Override\n    public float floatValue() {\n        return value;\n    }\n\n    /**\n     * Returns the value of this MutableInt as a double.\n     *\n     * @return the numeric value represented by this object after conversion to type double.\n     */\n    @Override\n    public double doubleValue() {\n        return value;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets this mutable as an instance of Integer.\n     *\n     * @return a Integer instance containing the value from this mutable, never null\n     */\n    public Integer toInteger() {\n        return Integer.valueOf(intValue());\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this object to the specified object. The result is <code>true</code> if and only if the argument is\n     * not <code>null</code> and is a <code>MutableInt</code> object that contains the same <code>int</code> value\n     * as this object.\n     * \n     * @param obj  the object to compare with, null returns false\n     * @return <code>true</code> if the objects are the same; <code>false</code> otherwise.\n     */\n    @Override\n    public boolean equals(Object obj) {\n        if (obj instanceof MutableInt) {\n            return value == ((MutableInt) obj).intValue();\n        }\n        return false;\n    }\n\n    /**\n     * Returns a suitable hash code for this mutable.\n     * \n     * @return a suitable hash code\n     */\n    @Override\n    public int hashCode() {\n        return value;\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Compares this mutable to another in ascending order.\n     * \n     * @param other  the other mutable to compare to, not null\n     * @return negative if this is less, zero if equal, positive if greater\n     */\n    public int compareTo(MutableInt other) {\n        int anotherVal = other.value;\n        return value < anotherVal ? -1 : (value == anotherVal ? 0 : 1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Returns the String value of this mutable.\n     * \n     * @return the mutable value as a string\n     */\n    @Override\n    public String toString() {\n        return String.valueOf(value);\n    }\n\n}\n", "ecture for XML Binding(JAXB) Reference Implementation, v2.2.6 \n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \n// Any modifications to this file will be lost upon recompilation of the source schema. \n// Generated on: 2013.09.14 at 08:04:17 AM CEST \n//\n\nimport javax.xml.bind.annotation.*;\nimport java.util.List;\n\n\n/**\n * <p>Java class for anonymous complex type.\n * \n * <p>The following schema fragment specifies the expected content contained within this class.\n * \n * <pre>\n * &lt;complexType>\n *   &lt;complexContent>\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\n *       &lt;sequence>\n *         &lt;element name=\"TeamLeagueStanding\">\n *           &lt;complexType>\n *             &lt;complexContent>\n *               &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\n *                 &lt;sequence>\n *                   &lt;element name=\"Team\" type=\"{http://www.w3.org/2001/XMLSchema}string\"/>\n *                   &lt;element name=\"Team_Id\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Played\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"PlayedAtHome\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"PlayedAway\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Won\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Draw\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Lost\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"NumberOfShots\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"YellowCards\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"RedCards\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Goals_For\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Goals_Against\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Goal_Difference\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                   &lt;element name=\"Points\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n *                 &lt;/sequence>\n *               &lt;/restriction>\n *             &lt;/complexContent>\n *           &lt;/complexType>\n *         &lt;/element>\n *         &lt;element name=\"AccountInformation\" type=\"{http://www.w3.org/2001/XMLSchema}string\"/>\n *       &lt;/sequence>\n *     &lt;/restriction>\n *   &lt;/complexContent>\n * &lt;/complexType>\n * </pre>\n * \n * \n */\n@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"\", propOrder = {\n    \"teamLeagueStanding\",\n    \"accountInformation\"\n})\n@XmlRootElement(name = \"XMLSOCCER.COM\")\npublic class GetLeagueStandingsBySeasonResultXML {\n\n    @XmlElement(name = \"TeamLeagueStanding\", required = true, namespace=\"http://xmlsoccer.com/LeagueStanding\")\n    protected List<TeamLeagueStanding> teamLeagueStanding;\n    @XmlElement(name = \"AccountInformation\", required = true)\n    protected String accountInformation;\n\n    /**\n     * Gets the value of the teamLeagueStanding property.\n     *\n     * @return\n     *     possible object is\n     *     {@link GetLeagueStandingsBySeasonResultXML.TeamLeagueStanding }\n     *\n     */\n    public List<TeamLeagueStanding> getTeamLeagueStanding() {\n        return teamLeagueStanding;\n    }\n\n    /**\n     * Sets the value of the teamLeagueStanding property.\n     *\n     * @param value\n     *     allowed object is\n     *     {@link GetLeagueStandingsBySeasonResultXML.TeamLeagueStanding }\n     *\n     */\n    public void setTeamLeagueStanding(List<TeamLeagueStanding> value) {\n        this.teamLeagueStanding = value;\n    }\n\n    /**\n     * Gets the value of the accountInformation property.\n     * \n     * @return\n     *     possible object is\n     *     {@link String }\n     *     \n     */\n    public String getAccountInformation() {\n        return accountInformation;\n    }\n\n    /**\n     * Sets the value of the accountInformation property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link String }\n     *     \n     */\n    public void setAccountInformation(String value) {\n        this.accountInformation = value;\n    }\n\n\n    /**\n     * <p>Java class for anonymous complex type.\n     * \n     * <p>The following schema fragment specifies the expected content contained within this class.\n     * \n     * <pre>\n     * &lt;complexType>\n     *   &lt;complexContent>\n     *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\n     *       &lt;sequence>\n     *         &lt;element name=\"Team\" type=\"{http://www.w3.org/2001/XMLSchema}string\"/>\n     *         &lt;element name=\"Team_Id\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Played\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"PlayedAtHome\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"PlayedAway\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Won\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Draw\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Lost\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"NumberOfShots\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"YellowCards\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"RedCards\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Goals_For\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Goals_Against\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Goal_Difference\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *         &lt;element name=\"Points\" type=\"{http://www.w3.org/2001/XMLSchema}int\"/>\n     *       &lt;/sequence>\n     *     &lt;/restriction>\n     *   &lt;/complexContent>\n     * &lt;/complexType>\n     * </pre>\n     * \n     * \n     */\n    @XmlAccessorType(XmlAccessType.FIELD)\n    @XmlType(name = \"\", propOrder = {\n        \"team\",\n        \"teamId\",\n        \"played\",\n        \"playedAtHome\",\n        \"playedAway\",\n        \"won\",\n        \"draw\",\n        \"lost\",\n        \"numberOfShots\",\n        \"yellowCards\",\n        \"redCards\",\n        \"goalsFor\",\n        \"goalsAgainst\",\n        \"goalDifference\",\n        \"points\"\n    })\n    public static class TeamLeagueStanding {\n\n        @XmlElement(name = \"Team\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected String team;\n        @XmlElement(name = \"Team_Id\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int teamId;\n        @XmlElement(name = \"Played\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int played;\n        @XmlElement(name = \"PlayedAtHome\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int playedAtHome;\n        @XmlElement(name = \"PlayedAway\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int playedAway;\n        @XmlElement(name = \"Won\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int won;\n        @XmlElement(name = \"Draw\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int draw;\n        @XmlElement(name = \"Lost\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int lost;\n        @XmlElement(name = \"NumberOfShots\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int numberOfShots;\n        @XmlElement(name = \"YellowCards\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int yellowCards;\n        @XmlElement(name = \"RedCards\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int redCards;\n        @XmlElement(name = \"Goals_For\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int goalsFor;\n        @XmlElement(name = \"Goals_Against\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int goalsAgainst;\n        @XmlElement(name = \"Goal_Difference\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int goalDifference;\n        @XmlElement(name = \"Points\", namespace=\"http://xmlsoccer.com/LeagueStanding\")\n        protected int points;\n        \n        /**\n         * Gets the value of the team property.\n         * \n         * @return\n         *     possible object is\n         *     {@link String }\n         *     \n         */\n        public String getTeam() {\n            return team;\n        }\n\n        /**\n         * Sets the value of the team property.\n         * \n         * @param value\n         *     allowed object is\n         *     {@link String }\n         *     \n         */\n        public void setTeam(String value) {\n            this.team = value;\n        }\n\n        /**\n         * Gets the value of the teamId property.\n         * \n         */\n        public int getTeamId() {\n            return teamId;\n        }\n\n        /**\n         * Sets the value of the teamId property.\n         * \n         */\n        public void setTeamId(int value) {\n            this.teamId = value;\n        }\n\n        /**\n         * Gets the value of the played property.\n         * \n         */\n        public int getPlayed() {\n            return played;\n        }\n\n        /**\n         * Sets the value of the played property.\n         * \n         */\n        public void setPlayed(int value) {\n            this.played = value;\n        }\n\n        /**\n         * Gets the value of the playedAtHome property.\n         * \n         */\n        public int getPlayedAtHome() {\n            return playedAtHome;\n        }\n\n        /**\n         * Sets the value of the playedAtHome property.\n         * \n         */\n        public void setPlayedAtHome(int value) {\n            this.playedAtHome = value;\n        }\n\n        /**\n         * Gets the value of the playedAway property.\n         * \n         */\n        public int getPlayedAway() {\n            return playedAway;\n        }\n\n        /**\n         * Sets the value of the playedAway property.\n         * \n         */\n        public void setPlayedAway(int value) {\n            this.playedAway = value;\n        }\n\n        /**\n         * Gets the value of the won property.\n         * \n         */\n        public int getWon() {\n            return won;\n        }\n\n        /**\n         * Sets the value of the won property.\n         * \n         */\n        public void setWon(int value) {\n            this.won = value;\n        }\n\n        /**\n         * Gets the value of the draw property.\n         * \n         */\n        public int getDraw() {\n            return draw;\n        }\n\n        /**\n         * Sets the value of the draw property.\n         * \n         */\n        public void setDraw(int value) {\n            this.draw = value;\n        }\n\n        /**\n         * Gets the value of the lost property.\n         * \n         */\n        public int getLost() {\n            return lost;\n        }\n\n        /**\n         * Sets the value of the lost property.\n         * \n         */\n        public void setLost(int value) {\n            this.lost = value;\n        }\n\n        /**\n         * Gets the value of the numberOfShots property.\n         * \n         */\n        public int getNumberOfShots() {\n            return numberOfShots;\n        }\n\n        /**\n         * Sets the value of the numberOfShots property.\n         * \n         */\n        public void setNumberOfShots(int value) {\n            this.numberOfShots = value;\n        }\n\n        /**\n         * Gets the value of the yellowCards property.\n         * \n         */\n        public int getYellowCards() {\n            return yellowCards;\n        }\n\n        /**\n         * Sets the value of the yellowCards property.\n         * \n         */\n        public void setYellowCards(int value) {\n            this.yellowCards = value;\n        }\n\n        /**\n         * Gets the value of the redCards property.\n         * \n         */\n        public int getRedCards() {\n            return redCards;\n        }\n\n        /**\n         * Sets the value of the redCards property.\n         * \n         */\n        public void setRedCards(int value) {\n            this.redCards = value;\n        }\n\n        /**\n         * Gets the value of the goalsFor property.\n         * \n         */\n        public int getGoalsFor() {\n            return goalsFor;\n        }\n\n        /**\n         * Sets the value of the goalsFor property.\n         * \n         */\n        public void setGoalsFor(int value) {\n            this.goalsFor = value;\n        }\n\n        /**\n         * Gets the value of the goalsAgainst property.\n         * \n         */\n        public int getGoalsAgainst() {\n            return goalsAgainst;\n        }\n\n        /**\n         * Sets the value of the goalsAgainst property.\n         * \n         */\n        public void setGoalsAgainst(int value) {\n            this.goalsAgainst = value;\n        }\n\n        /**\n         * Gets the value of the goalDifference property.\n         * \n         */\n        public int getGoalDifference() {\n            return goalDifference;\n        }\n\n        /**\n         * Sets the value of the goalDifference property.\n         * \n         */\n        public void setGoalDifference(int value) {\n            this.goalDifference = value;\n        }\n\n        /**\n         * Gets the value of the points property.\n         * \n         */\n        public int getPoints() {\n            return points;\n        }\n\n        /**\n         * Sets the value of the points property.\n         * \n         */\n        public void setPoints(int value) {\n            this.points = value;\n        }\n\n        @Override\n        public String toString() {\n            //return \"TeamLeagueStanding{\" + \"team=\" + team + \", teamId=\" + teamId + \", played=\" + played + \", playedAtHome=\" + playedAtHome + \", playedAway=\" + playedAway + \", won=\" + won + \", draw=\" + draw + \", lost=\" + lost + \", numberOfShots=\" + numberOfShots + \", yellowCards=\" + yellowCards + \", redCards=\" + redCards + \", goalsFor=\" + goalsFor + \", goalsAgainst=\" + goalsAgainst + \", goalDifference=\" + goalDifference + \", points=\" + points + \", leagueName=\" + leagueName + \", season=\" + season + \", id=\" + id + '}';\n            return \"LEAGUE STANDINGS: \" + \"  TEAM: \" + team + \"  PLAYED: \" + played + \"  PLAYED AT HOME: \" + playedAtHome + \"  PLAYED AWAY: \" + playedAway + \"  WON: \" + won + \"  DRAW: \" + draw + \"  LOST: \" + lost + \"  GOALS FOR: \" + goalsFor + \"  GOALS AGAINST: \" + goalsAgainst + \"  GOAL DIFFERENCE: \" + goalDifference + \"  POINTS: \" + points  ;\n        }\n\n    }\n\n}\n", "    \n}\n", "oreMatchers.notNullValue;\nimport static org.junit.Assert.assertThat;\n\nimport java.io.File;\nimport java.io.FileWriter;\nimport java.io.Writer;\n\nimport org.dom4j.Document;\nimport org.junit.Test;\nimport org.mule.api.MuleMessage;\nimport org.mule.module.client.MuleClient;\nimport org.mule.module.xml.util.XMLUtils;\nimport org.mule.tck.junit4.FunctionalTestCase;\n\npublic class ScriptingTestCase extends FunctionalTestCase\n{\n\n\tprivate static final String INPUT_DIRECTORY = \"./data\";\n\t\n\tprivate static final String INPUT_FILE = INPUT_DIRECTORY + \"/testFile\";\n\n    @Override\n    protected String getConfigResources()\n    {\n        return \"scripting.xml\";\n    }\n    \n    @Test\n    public void testScripting() throws Exception\n    {\n        MuleClient muleClient = new MuleClient(muleContext);\n\n        String lowercaseString = \"hello\";\n        MuleMessage result = muleClient.send(\"vm://groovy-uppercase.in\", lowercaseString, null);\n        assertThat(result, is(notNullValue()));\n        assertThat(result.getPayload(), is(notNullValue()));\n        assertThat(result.getPayloadAsString(), is(lowercaseString.toUpperCase()));\n    }\n    \n    @Test\n    public void testExternalScripting() throws Exception\n    {\n    \tcreateTempDirectory();\n    \tcreateAndPopulateTempFile();\n    \t\n    \tMuleClient muleClient = new MuleClient(muleContext);\n\n        MuleMessage result = muleClient.request(\"jms://orders\", 5000);\n        assertThat(result, is(notNullValue()));\n        assertThat(result.getPayload(), is(notNullValue()));\n\n        String resultString = result.getPayloadAsString();\n        Document resultDocument = XMLUtils.toDocument(resultString, muleContext);\n        assertThat(resultDocument, is(notNullValue()));\n    }\n    \n    private void createTempDirectory() throws Exception\n    {\n    \tFile tmpDir = new File(INPUT_DIRECTORY);\n        tmpDir.delete();\n        tmpDir.mkdir();\n    }\n\n    private void createAndPopulateTempFile() throws Exception\n    {\n        File target = new File(INPUT_FILE);\n\n        Writer out = new FileWriter(target);\n        out.write(\"409,1234,PENDING\\n410,1234,PENDING\\n411,1235,PENDING\");\n        out.flush();\n        out.close();\n\n        target.deleteOnExit();\n    }\n\n}\n", "ndencyEntity {\n    private String uuid;\n    private String jobKey;\n    private String upJobKey;\n    private String domainId;\n\n    public String getUuid() {\n        return uuid;\n    }\n\n    public void setUuid(String uuid) {\n        this.uuid = uuid;\n    }\n\n    public String getJobKey() {\n        return jobKey;\n    }\n\n    public void setJobKey(String jobKey) {\n        this.jobKey = jobKey;\n    }\n\n    public String getUpJobKey() {\n        return upJobKey;\n    }\n\n    public void setUpJobKey(String up_id) {\n        this.upJobKey = up_id;\n    }\n\n    public String getDomainId() {\n        return domainId;\n    }\n\n    public void setDomainId(String domain_id) {\n        this.domainId = domain_id;\n    }\n\n    @Override\n    public String toString() {\n        return \"TaskDependencyEntity{\" +\n                \"uuid='\" + uuid + '\\'' +\n                \", jobKey='\" + jobKey + '\\'' +\n                \", upJobKey='\" + upJobKey + '\\'' +\n                \", domain_id='\" + domainId + '\\'' +\n                '}';\n    }\n}\n", "er one\n\t   or more contributor license agreements.\tSee the NOTICE file\n\t   distributed with this work for additional information\n\t   regarding copyright ownership.  The ASF licenses this file\n\t   to you under the Apache License, Version 2.0 (the\n\t   \"License\"); you may not use this file except in compliance\n\t   with the License.  You may obtain a copy of the License at\n\t\t http://www.apache.org/licenses/LICENSE-2.0\n\t   Unless required by applicable law or agreed to in writing,\n\t   software distributed under the License is distributed on an\n\t   \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n\t   KIND, either express or implied.  See the License for the\n\t   specific language governing permissions and limitations\n\t   under the License.\n*/\nimport java.util.ArrayList;\nimport java.util.List;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport android.app.AlertDialog;\nimport android.content.DialogInterface;\nimport org.apache.cordova.CordovaPlugin;\nimport org.apache.cordova.CallbackContext;\nimport org.apache.cordova.CordovaInterface;\nimport org.apache.cordova.PluginResult;\nimport android.view.ContextThemeWrapper;\n/**\n * This class provides a service.\n */\npublic class ListViewAlert extends CordovaPlugin {\n\tstatic String TAG = \"ListViewAlert\";\n\t/**\n\t * Constructor.\n\t */\n\tpublic ListViewAlert() {\n\t}\n\t/**\n\t * Executes the request and returns PluginResult.\n\t *\n\t * @param action\t\tThe action to execute.\n\t * @param args\t\t\tJSONArry of arguments for the plugin.\n\t * @param callbackId\tThe callback id used when calling back into JavaScript.\n\t * @return\t\t\t\tA PluginResult object with a status and message.\n\t */\n\t@Override\n\tpublic boolean execute(String action, JSONArray args, CallbackContext callbackContext) throws JSONException {\n\t\t\n\t\t\tif (action.equals(\"ListViewAlert\")) {\n\t\t\t\tthis.loadList(args, callbackContext);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t// --------------------------------------------------------------------------\n\t// LOCAL METHODS\n\t// --------------------------------------------------------------------------\n\tpublic void loadList( final JSONArray thelist,\tfinal CallbackContext callbackContext) {\n\t\tfinal CordovaInterface cordova = this.cordova;\n\t\tRunnable runnable = new Runnable() {\n\t\t\tpublic void run() {\n\t\t\t\tList<String> list = new ArrayList<String>();\n\t\t\t\t// we start with index 1 because index 0 is the title\n\t\t\t\tfor( int x = 1; x < thelist.length(); x++) {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlist.add( thelist.getString(x) );\n\t\t\t\t\t} catch (JSONException e) {\n\t\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\t\te.printStackTrace();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tCharSequence[] items = list.toArray(new CharSequence[list.size()]);\n\t\t\t\tAlertDialog.Builder builder = new AlertDialog.Builder(new ContextThemeWrapper(\n    cordova.getActivity(),android.R.style.Theme_Holo_Dialog));\n\t\t\t\ttry {\n\t\t\t\t\tbuilder.setTitle( thelist.getString(0) );\n\t\t\t\t\t// builder.setMessage( \"This is a hardcoded message to try whether or not this is feasible!\");\n\t\t\t\t} catch (JSONException e) {\n\t\t\t\t\t// TODO Auto-generated catch block\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t} // index 0 contains the title\n\t\t\t\tbuilder.setItems(items, new DialogInterface.OnClickListener() {\n\t\t\t\t\tpublic void onClick(DialogInterface dialog, int item) {\n\t\t\t\t\t\tdialog.dismiss();\n\t\t\t\t\t\t// we +1 to item because item starts from 0, but from\n\t\t\t\t\t\t// thelist[0], that was the title...\n\t\t\t\t\t\tcallbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, item + 1));\n\t\t\t\t\t\t//callbackContext.sendPluginResult(pluginResult)\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tAlertDialog alert = builder.create();\n\t\t\t\talert.getWindow().getAttributes().windowAnimations = android.R.style.Animation_Dialog;\n\t\t\t\talert.show();\n\t\t\t}\n\t\t};\n\t\tthis.cordova.getActivity().runOnUiThread(runnable);\n\t}\n}\n\n", "Api;\nimport android.app.Notification;\nimport android.app.NotificationManager;\nimport android.app.PendingIntent;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.util.Log;\n\npublic class AlarmReciever extends BroadcastReceiver {\n    DatabaseHelper myDbHelper;\n\tNotificationManager nm;\n\tprivate long[] mVibratePattern = { 0, 200, 200, 300 };\n\t\n\t@TargetApi(Build.VERSION_CODES.JELLY_BEAN)\n\t@SuppressWarnings(\"deprecation\")\n\t@Override\n\tpublic void onReceive(Context context, Intent intent) {\n\t\t\n\t\t myDbHelper = new DatabaseHelper(context);\n\t\t \n\t\tString eventname = intent.getExtras().getString(\"event\");\n\t\t\n\t\t String eventvenue= myDbHelper.getVenueDisplay(eventname);\n\t\t Log.i(\"event_name\",eventname );\n\t\tint id =myDbHelper.getID(eventname);\n\t\tLog.i(\"id\",String.valueOf(id) );\n\t\tBitmap largeIcon = BitmapFactory.decodeResource(context.getResources(),\n\t\t\t\tR.drawable.thomsologosmallicon);\n\t\t\n\t\t\n\t\tNotification.Builder notificationBuilder = new Notification.Builder(\n\t\t\t\tcontext).setTicker(eventname)\n\t\t\t\t.setSmallIcon(R.drawable.ic_stat_toggle_star)\n\t\t\t\t.setLargeIcon(largeIcon)\n\t\t\t\t.setAutoCancel(true).setContentTitle(eventname)\n\t\t\t\t\n   \t\t\t\t.setContentText(eventvenue)\n\t\t\t\t.setVibrate(mVibratePattern);\n\t\t\t\n\n\t\t// Pass the Notification to the NotificationManager:\n\t\tNotificationManager mNotificationManager = (NotificationManager) context\n\t\t\t\t.getSystemService(Context.NOTIFICATION_SERVICE);\n\t\tmNotificationManager.notify(id,\n\t\t\t\tnotificationBuilder.build());\n\t\t\n\t\t\n\t\t\n\t\t\n\t\t\t\t\n\t\t\n\t\t\n\t\t\n\t}\n};", "sorResource;\nimport org.innovateuk.ifs.user.resource.BusinessType;\n\nimport java.util.List;\nimport java.util.function.BiConsumer;\n\nimport static java.util.Collections.emptyList;\n\npublic class AvailableAssessorResourceBuilder extends AssessorInviteResourceBuilder<AvailableAssessorResource, AvailableAssessorResourceBuilder> {\n\n    private AvailableAssessorResourceBuilder(List<BiConsumer<Integer, AvailableAssessorResource>> newMultiActions) {\n        super(newMultiActions);\n    }\n\n    @Override\n    protected AvailableAssessorResourceBuilder createNewBuilderWithActions(List<BiConsumer<Integer, AvailableAssessorResource>> actions) {\n        return new AvailableAssessorResourceBuilder(actions);\n    }\n\n    @Override\n    protected AvailableAssessorResource createInitial() {\n        return new AvailableAssessorResource();\n    }\n\n    public static AvailableAssessorResourceBuilder newAvailableAssessorResource() {\n        return new AvailableAssessorResourceBuilder(emptyList());\n    }\n\n    public AvailableAssessorResourceBuilder withId(Long... value) {\n        return withArraySetFieldByReflection(\"id\", value);\n    }\n\n    public AvailableAssessorResourceBuilder withEmail(String... value) {\n        return withArraySetFieldByReflection(\"email\", value);\n    }\n\n    public AvailableAssessorResourceBuilder withBusinessType(BusinessType... value) {\n        return withArraySetFieldByReflection(\"businessType\", value);\n    }\n}\n", "android.content.Context;\n\n/**\n * Created by Alberto Penas Amorberto Penas Amor on 28/05/2017.\n */\n\npublic class DatabaseSingleton {\n\n\n    private static AppDatabase appAppDatabase;\n\n\n    public static void init(Context context){\n        if (appAppDatabase == null) {\n            appAppDatabase = Room.databaseBuilder(context, AppDatabase.class, \"database\").build();\n        }\n    }\n\n\n    static AppDatabase instance(){\n        if (appAppDatabase == null){\n            throw new NullPointerException(\"Invoke first: init(Context context)\");\n        }\n        return appAppDatabase;\n    }\n}\n", "ect to license terms. See LICENSE.TXT\n */\npackage org.diirt.pods.web;\n\nimport javax.servlet.ServletContextEvent;\nimport javax.servlet.ServletContextListener;\nimport javax.servlet.annotation.WebListener;\nimport org.diirt.datasource.PVManager;\n\n/**\n *\n * @author carcassi\n */\n@WebListener\npublic class ShutdownCleanup implements ServletContextListener {\n\n    @Override\n    public void contextInitialized(ServletContextEvent sce) {\n    }\n\n    @Override\n    public void contextDestroyed(ServletContextEvent sce) {\n        PVManager.getReadScannerExecutorService().shutdownNow();\n        PVManager.getDefaultDataSource().close();\n    }\n\n}\n", "mport java.util.InputMismatchException;\nimport java.util.NoSuchElementException;\nimport java.util.Scanner;\n\n/**\n *\n * @author Kaz\u00f3 Csaba\n */\nenum Type {\n\tCHAR {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\tint value=scanner.nextInt();\n\t\t\t\tif (value<-Byte.MIN_VALUE || value>Byte.MAX_VALUE) throw new InputMismatchException(\"Char out of range\");\n\t\t\t\treturn value;\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as char\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.get();\n\t\t}\n\t},\n\tUCHAR {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\tint value=scanner.nextInt();\n\t\t\t\tif (value<0 || value>255) throw new InputMismatchException(\"Uchar out of range: \"+value);\n\t\t\t\treturn value;\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as uchar\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.get() & 0xFF;\n\t\t}\n\t},\n\tSHORT {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\tint value=scanner.nextInt();\n\t\t\t\tif (value<-Short.MIN_VALUE || value>Short.MAX_VALUE) throw new InputMismatchException(\"Short out of range\");\n\t\t\t\treturn value;\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as short\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.getShort();\n\t\t}\n\t},\n\tUSHORT {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\tint value=scanner.nextInt();\n\t\t\t\tif (value<0 || value>65535) throw new InputMismatchException(\"Ushort out of range\");\n\t\t\t\treturn value;\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as ushort\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.getShort() & 0xFFFF;\n\t\t}\n\t},\n\tINT {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\treturn scanner.nextInt();\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as int\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.getInt();\n\t\t}\n\t},\n\tUINT {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\tlong value=scanner.nextLong();\n\t\t\t\tif (value<0 || value>4294967295L) throw new InputMismatchException(\"Uint out of range\");\n\t\t\t\treturn value;\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as uint\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.getInt() & 0xFFFFFFFFL;\n\t\t}\n\t},\n\tFLOAT {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\treturn scanner.nextFloat();\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as float\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.getFloat();\n\t\t}\n\t},\n\tDOUBLE {\n\t\t@Override\n\t\tpublic Number parse(Scanner scanner) throws IOException {\n\t\t\ttry {\n\t\t\t\treturn scanner.nextDouble();\n\t\t\t} catch (InputMismatchException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Cannot parse '\"+scanner.next()+\"' as double\", e);\n\t\t\t} catch (NoSuchElementException e) {\n\t\t\t\tthrow new InvalidPlyFormatException(\"Unexpected end of file\", e);\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic Number read(ByteBuffer buffer) throws IOException {\n\t\t\treturn buffer.getDouble();\n\t\t}\n\n\t};\n\tpublic abstract Number parse(Scanner scanner) throws IOException;\n\tpublic abstract Number read(ByteBuffer buffer) throws IOException;\n}\n", "ernate.Hibernate;\nimport org.hibernate.Session;\nimport org.hibernate.criterion.Restrictions;\n\nimport com.visualpatterns.timex.model.Timesheet;\nimport com.visualpatterns.timex.util.DateUtil;\nimport com.visualpatterns.timex.util.HibernateUtil;\n\n/**\n * Manages database operations for Timesheet table.\n * @author anil\n */\npublic class TimesheetManagerExtras\n{\n    public List getTimesheets(String statusCode)\n    {\n        List timesheetList = null;\n\n        Session session = HibernateUtil.getSessionFactory()\n                .getCurrentSession();\n        session.beginTransaction();\n        timesheetList = session.createQuery(\n                \"from Timesheet\" + \" where statusCode = ?\").setString(0,\n                statusCode).list();\n        session.getTransaction().commit();\n\n        return timesheetList;\n    }\n    \n    /**\n     * Demonstrates use of Hibernate's Session.getNamedQuery method.\n     */\n    public List getTimesheetsUsingNamedQuery(\n            int employeeId,\n            Date periodEndingDate)\n    {\n        List timesheetList = null;\n\n        Session session = HibernateUtil.getSessionFactory()\n                .getCurrentSession();\n        session.beginTransaction();\n        System.err.println(\"periodEndingDate = \" + periodEndingDate);\n        timesheetList = session.getNamedQuery(\n                \"getTimesheetsByEmployeeIdAndPeriodEndingDate\").setInteger(\n                \"employeeId\", employeeId).setDate(\"periodEndingDate\",\n                periodEndingDate).list();\n        session.getTransaction().commit();\n\n        return timesheetList;\n    }\n\n    /** \n     * Demonstrates use of Hibernate's Session.createCriteria method.\n     */\n    public List getTimesheetsUsingCriteria(int employeeId)\n    {\n        List timesheetList = null;\n        Session session = HibernateUtil.getSessionFactory()\n                .getCurrentSession();\n        session.beginTransaction();\n        timesheetList = session.createCriteria(Timesheet.class).add(\n                Restrictions.eq(\"employeeId\", new Integer(employeeId)))\n                .list();\n        session.getTransaction().commit();\n\n        return timesheetList;\n    }\n\n    /** \n     * Saves a list of Timesheets \n     */\n    public int saveTimesheetsWithTransaction(List timesheets)\n    {\n        if (timesheets == null || timesheets.size() < 1) return 0;\n\n        Timesheet timesheet;\n        int saved = 0;\n        Session session = HibernateUtil.getSessionFactory()\n                .getCurrentSession();\n        try\n        {\n            session.beginTransaction();\n            for (int i = 0; i < timesheets.size(); i++)\n            {\n                timesheet = (Timesheet) timesheets.get(i);\n                session.saveOrUpdate(timesheet);\n                saved++;\n            }\n\n            session.getTransaction().commit();\n        } catch (Exception e)\n        {\n            session.getTransaction().rollback();\n        }\n\n        return saved;\n    }\n\n    /**\n     * Demonstrates use of Hibernate's Session.createSQLQuery method.\n     */\n    public int getDaysLeftTillPeriodEnd()\n    {\n        Session session = HibernateUtil.getSessionFactory()\n                .getCurrentSession();\n        int daysLeft = -1;\n        String sql = \"select datediff('dd', NOW, ?) AS daysleft\"\n                + \" from timesheet\";\n        Integer valueObject = (Integer) session.createSQLQuery(sql)\n                .addScalar(\"daysleft\", Hibernate.INTEGER).setDate(0,\n                        DateUtil.getCurrentPeriodEndingDate()).uniqueResult();\n        if (valueObject != null) daysLeft = valueObject.intValue();\n        return daysLeft;\n    }\n}\n", " \n * @author Jonas Andr\u00e9e\n *\n */\npublic class MainGame {\n\tpublic static void main(String[] args) {\n\t\tcreateAndShowGUI();\n\t}\n\n\tprivate static void createAndShowGUI() {\n\t\tJFrame f = new JFrame(\"drawString\");\n\t\tf.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tf.add(new GamePanel());\n\t\tf.pack();\n\t\tf.setVisible(true);\n\t}\n}\n", "ic class BasicTask extends Task implements Serializable {\n\n  private static final long serialVersionUID = 1L;\n\n  /**\n   * BasicTask constructor.\n   * \n   * @param name Task name.\n   * @param description Task description.\n   * @param father Father task.\n   * @param root Project tree root.\n   */\n  public BasicTask(String name, String description, Project father, ArrayList<Activity> root) {\n    super(name, description, father, root, \"BasicTask\");\n    assert ((name != null) && (description != null) && (father != null));\n  }\n\n  /**\n   * No arg constructor used to serialize.\n   * \n   */\n  public BasicTask() {\n\n  }\n\n  @Override\n  public Task getNextTask() {\n    return null;\n  }\n\n  @Override\n  public Date getTaskStartDate() {\n    return null;\n  }\n\n  @Override\n  public int getTimeLimit() {\n    return 0;\n  }\n\n  @Override\n  public Date getEndingDate() {\n    return null;\n  }\n\n\n}\n", "oid.graphics.Paint;\r\nimport android.graphics.Paint.Align;\r\nimport android.graphics.Paint.Style;\r\nimport android.util.Log;\r\nimport android.util.TypedValue;\r\nimport android.widget.Toast;\r\n\r\npublic class SimpleHeader implements Headable {\r\n    private float PI = (float) Math.PI;\r\n    private int mState = STATE_REST;\r\n    private int mPice = 6;\r\n    private Paint mPaint;\r\n    private int mHeight = 0;\r\n    private int mTime = 0;\r\n    private int mTextColor;\r\n    private int mPointColor;\r\n    private float mPointRadius = 0;\r\n    private float mCircleRadius = 0;\r\n    private float mFontOffset;\r\n    private String mMsg;\r\n    private boolean isClipCanvas = true;\r\n\r\n    public SimpleHeader(Context context) {\r\n        mPaint = new Paint();\r\n        mPaint.setAntiAlias(true);\r\n        mPaint.setStyle(Style.FILL);\r\n        int fontSize = (int) TypedValue\r\n                .applyDimension(TypedValue.COMPLEX_UNIT_SP, 20, context.getResources()\r\n                        .getDisplayMetrics());\r\n        mPaint.setTextSize(fontSize);\r\n        mPaint.setTextAlign(Align.CENTER);\r\n        mTextColor = 0xffffffff;\r\n        mPointColor = 0xffffffff;\r\n        mFontOffset = -(mPaint.getFontMetrics().top + mPaint.getFontMetrics().bottom) / 2;\r\n        mHeight = (int) TypedValue\r\n                .applyDimension(TypedValue.COMPLEX_UNIT_DIP, 45, context.getResources()\r\n                        .getDisplayMetrics());\r\n        mPointRadius =\r\n                TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2.5f, context.getResources()\r\n                        .getDisplayMetrics());\r\n        mCircleRadius = mPointRadius * 3.5f;\r\n    }\r\n\r\n    public void setTextColor(int color) {\r\n        mTextColor = color;\r\n    }\r\n\r\n    public void setCircleColor(int color) {\r\n        mPointColor = color;\r\n    }\r\n\r\n    public void setIsClipCanvas(boolean bool) {\r\n        isClipCanvas = bool;\r\n    }\r\n\r\n    @Override\r\n    public void stateChange(int state, String msg) {\r\n        if (mState != state) {\r\n            mTime = 0;\r\n        }\r\n        mState = state;\r\n        this.mMsg = msg;\r\n        Log.d(\"zzSTATE\", state+\"\");\r\n    }\r\n\r\n    @Override\r\n    public int getState() {\r\n        return mState;\r\n    }\r\n\r\n    @Override\r\n    public boolean draw(Canvas canvas, int left, int top, int right, int bottom) {\r\n        boolean more = false;\r\n        final int width = right - left;\r\n        final int height = mHeight;\r\n        final int offset = bottom - top;\r\n        canvas.save();\r\n        if (isClipCanvas) {\r\n            canvas.clipRect(left + 5, 1, right + 5, bottom - 1);\r\n        }\r\n        switch (mState) {\r\n        case STATE_REST:\r\n            break;\r\n        case STATE_PULL:\r\n        case STATE_RELEASE:\r\n            if (offset < 10) {\r\n                break;\r\n            }\r\n            mPaint.setColor(mPointColor);\r\n            for (int i = 0; i < mPice; i++) {\r\n                int angleParam;\r\n                if (offset < height * 3 / 4) {\r\n                    angleParam = offset * 16 / height - 3;// \u6bcf1%\u8f6c0.16\u5ea6;\r\n                } else {\r\n                    angleParam = offset * 300 / height - 217;// \u6bcf1%\u8f6c3\u5ea6;\r\n                }\r\n                float angle = -(i * (360 / mPice) - angleParam) * PI / 180;\r\n                float radiusParam;\r\n                if (offset <= height) {\r\n                    radiusParam = offset / (float) height;\r\n                    radiusParam = 1 - radiusParam;\r\n                    radiusParam *= radiusParam;\r\n                    radiusParam = 1 - radiusParam;\r\n                } else {\r\n                    radiusParam = 1;\r\n                }\r\n                float radius = width / 2 - radiusParam * (width / 2 - mCircleRadius);\r\n                float x = (float) (width / 2 + radius * Math.cos(angle));\r\n                float y = (float) (offset / 2 + radius * Math.sin(angle));\r\n                canvas.drawCircle(x, y + top, mPointRadius, mPaint);\r\n            }\r\n            break;\r\n        case STATE_LOADING:\r\n            more = true;\r\n            mPaint.setColor(mPointColor);\r\n            for (int i = 0; i < mPice; i++) {\r\n                int angleParam = mTime * 5;\r\n                float angle = -(i * (360 / mPice) - angleParam) * PI / 180;\r\n                float radius = mCircleRadius;\r\n                float x = (float) (width / 2 + radius * Math.cos(angle));\r\n                float y;\r\n                if (offset < height) {\r\n                    y = (float) (offset - height / 2 + radius * Math.sin(angle));\r\n                } else {\r\n                    y = (float) (offset / 2 + radius * Math.sin(angle));\r\n                }\r\n                canvas.drawCircle(x, y + top, mPointRadius, mPaint);\r\n            }\r\n            mTime++;\r\n            break;\r\n        case STATE_SUCCESS:\r\n        case STATE_FAIL:\r\n            more = true;\r\n            final int time = mTime;\r\n            if (time < 30) {\r\n                mPaint.setColor(mPointColor);\r\n                for (int i = 0; i < mPice; i++) {\r\n                    int angleParam = mTime * 10;\r\n                    float angle = -(i * (360 / mPice) - angleParam) * PI / 180;\r\n                    float radius = mCircleRadius + time * mCircleRadius;\r\n                    float x = (float) (width / 2 + radius * Math.cos(angle));\r\n                    float y;\r\n                    if (offset < height) {\r\n                        y = (float) (offset - height / 2 + radius * Math.sin(angle));\r\n                    } else {\r\n                        y = (float) (offset / 2 + radius * Math.sin(angle));\r\n                    }\r\n                    canvas.drawCircle(x, y + top, mPointRadius, mPaint);\r\n                }\r\n                mPaint.setColor(mTextColor);\r\n                mPaint.setAlpha(time * 255 / 30);\r\n                String text = mMsg != null ? mMsg : mState == STATE_SUCCESS ? \"\u52a0\u8f7d\u6210\u529f\" : \"\u52a0\u8f7d\u5931\u8d25\";\r\n                float y;\r\n                if (offset < height) {\r\n                    y = offset - height / 2;\r\n                } else {\r\n                    y = offset / 2;\r\n                }\r\n                canvas.drawText(text, width / 2, y + top + mFontOffset, mPaint);\r\n            } else {\r\n                mPaint.setColor(mTextColor);\r\n                String text = mMsg != null ? mMsg : mState == STATE_SUCCESS ? \"\u52a0\u8f7d\u6210\u529f\" : \"\u52a0\u8f7d\u5931\u8d25\";\r\n                float y;\r\n                if (offset < height) {\r\n                    y = offset - height / 2;\r\n                    mPaint.setAlpha(offset * 255 / height);\r\n                } else {\r\n                    y = offset / 2;\r\n                }\r\n                canvas.drawText(text, width / 2, y + top + mFontOffset, mPaint);\r\n            }\r\n            mTime++;\r\n            break;\r\n        }\r\n        canvas.restore();\r\n        return more;\r\n    }\r\n\r\n    @Override\r\n    public void toastResultInOtherWay(Context context, int state) {\r\n        if (state == Headable.STATE_SUCCESS) {\r\n        } else if (state == Headable.STATE_FAIL) {\r\n            Toast.makeText(context, mMsg != null ? mMsg : \"\u52a0\u8f7d\u5931\u8d25\", Toast.LENGTH_SHORT).show();\r\n        }\r\n    }\r\n\r\n    @Override\r\n    public int getHeight() {\r\n        return mHeight;\r\n    }\r\n}\r\n", "dt.core.Flags;\r\nimport org.eclipse.jdt.core.IMethod;\r\nimport org.eclipse.jdt.core.IType;\r\nimport org.eclipse.jdt.core.ITypeHierarchy;\r\nimport org.eclipse.jdt.core.JavaModelException;\r\n\r\npublic class OverridingFinder {\r\n\r\n\tpublic static List<IMethod> findOverridenMethods(IMethod method) {\r\n\t\t// String mname = GetNames.getShortMethodName(method);\r\n\t\tIType type = method.getDeclaringType();\r\n\t\tList<IMethod> list = new ArrayList<IMethod>();\r\n\t\ttry {\r\n\t\t\tITypeHierarchy hier = type.newSupertypeHierarchy(null);\r\n\t\t\tIType supType = hier.getSuperclass(type);\r\n\t\t\tString prefix=\"\";\r\n\t\t\tif(type.getFullyQualifiedName().contains(\".\"))\r\n\t\t\tprefix=type.getFullyQualifiedName().substring(0, type.getFullyQualifiedName().indexOf(\".\"));\r\n\t\t\twhile (supType != null) {\r\n\t\t\t\tif(!supType.getFullyQualifiedName().startsWith(prefix)){\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t}\r\n\t\t\t\tIMethod[] ms = supType.findMethods(method);\r\n\t\t\t\tif (ms != null) {\r\n\t\t\t\t\tfor (IMethod m : ms) {\r\n\t\t\t\t\t\tint flag = m.getFlags();\r\n\t\t\t\t\t\tif (!Flags.isAbstract(flag))//Bug fix: add the checking for abstract methods\r\n\t\t\t\t\t\t\tlist.add(m);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tsupType = hier.getSuperclass(supType);\r\n\t\t\t}\r\n\t\t} catch (JavaModelException e) {\r\n\t\t\t// TODO Auto-generated catch block\r\n\t\t\te.printStackTrace();\r\n\t\t}\r\n\r\n\t\treturn list;\r\n\t}\r\n}\r\n", "     throw new RuntimeException();\n    ListNode cur = head, last = null, next = head;\n    int ahead = 0;\n    while (ahead < k && next != null)\n    {\n      ++ahead;\n      next = next.next;\n    }\n    while (ahead == k)\n    {\n      ListNode prev = cur, nlast = cur;\n      cur = cur.next;\n      while (cur != next)\n      {\n        ListNode ncur = cur.next;\n        cur.next = prev;\n        prev = cur;\n        cur = ncur;\n      }\n      if (last != null)\n        last.next = prev;\n      else\n        head = prev;\n      last = nlast;\n      ahead = 0;\n      while (ahead < k && next != null)\n      {\n        ++ahead;\n        next = next.next;\n      }\n    }\n    if (last != null)\n      last.next = cur;\n    return head;\n  }\n}\n", "ntext;\nimport android.os.IBinder;\n\nimport com.nata.xdroid.notifier.CommonNotice;\nimport com.nata.xdroid.notifier.Notifier;\n\nimport de.robv.android.xposed.XC_MethodHook;\n\nimport static de.robv.android.xposed.XposedBridge.log;\nimport static de.robv.android.xposed.XposedHelpers.findAndHookMethod;\n\n/**\n * Created by Calvin on 2016/11/25.\n */\n\npublic class CrashHook implements Hook {\n    private Context context;\n\n    public CrashHook(Context context) {\n        this.context = context;\n    }\n\n\n    @Override\n    public void hook(final ClassLoader loader) {\n        // Handle Crash\n        findAndHookMethod(\"com.android.server.am.ActivityManagerService\", loader, \"handleApplicationCrash\", IBinder.class, ApplicationErrorReport.CrashInfo.class, new XC_MethodHook() {\n            @Override\n            protected void beforeHookedMethod(MethodHookParam param) throws Throwable {\n                ApplicationErrorReport.CrashInfo info = (ApplicationErrorReport.CrashInfo) param.args[1];\n                Notifier.notice(context, CommonNotice.CRASH + info.throwClassName + \"->\" + info.exceptionClassName + \" -> \" + info.exceptionMessage + \" -> \" + info.stackTrace);\n                log(CommonNotice.CRASH + info.throwClassName + \"->\" + info.exceptionClassName + \" -> \" + info.exceptionMessage + \" -> \" + info.stackTrace);\n            }\n        });\n    }\n}\n", "ass QMult extends Quantity {\n  public final Quantity quantity_1, quantity_2;\n  public QMult(Quantity p1, Quantity p2) { quantity_1 = p1; quantity_2 = p2; }\n\n  public <R,A> R accept(coop.rchain.syntax.rholang.Absyn.Quantity.Visitor<R,A> v, A arg) { return v.visit(this, arg); }\n\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o instanceof coop.rchain.syntax.rholang.Absyn.QMult) {\n      coop.rchain.syntax.rholang.Absyn.QMult x = (coop.rchain.syntax.rholang.Absyn.QMult)o;\n      return this.quantity_1.equals(x.quantity_1) && this.quantity_2.equals(x.quantity_2);\n    }\n    return false;\n  }\n\n  public int hashCode() {\n    return 37*(this.quantity_1.hashCode())+this.quantity_2.hashCode();\n  }\n\n\n}\n", "difier;\n\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Date: 27-Jun-2016\n *\n * @author T. Curran\n */\npublic class WildcardMatcherTest {\n\n\tprivate static final String SEARCH_STRING = \"The quick fox jumped over the lazy dog.\";\n\n\t/**\n\t * This method simply instantiates a private constructor to ensure code coverage for it so the\n\t * coverage reports aren't diminished\n\t */\n\t@Test\n\tpublic void testConstantsConstructorIsPrivate() throws Exception {\n\t\tConstructor<WildcardMatcher> constructor = WildcardMatcher.class.getDeclaredConstructor();\n\t\tassertTrue(Modifier.isPrivate(constructor.getModifiers()));\n\t\tconstructor.setAccessible(true);\n\t\tconstructor.newInstance();\n\t}\n\n\t@Test\n\tpublic void shouldBeAbleToMatchWildcard() {\n\t\tassertTrue(WildcardMatcher.matches(SEARCH_STRING, \"*lazy dog*\"));\n\t\tassertTrue(WildcardMatcher.matches(SEARCH_STRING, \"*lazy dog.\"));\n\t\tassertTrue(WildcardMatcher.matches(SEARCH_STRING, \"The quick ?ox jumped over ?he lazy dog.\"));\n\n\t\tassertFalse(WildcardMatcher.matches(SEARCH_STRING, \"*lazy do..\"));\n\t\tassertFalse(WildcardMatcher.matches(SEARCH_STRING, \"*lazy dog\"));\n\t\tassertFalse(WildcardMatcher.matches(SEARCH_STRING, \"The quick [a-z]ox jumped over [a-z]he lazy dog.\"));\n\t}\n}\n", "istence.*;\r\n\r\n/**\r\n * The persistent class for the personnes database table.\r\n * \r\n */\r\n@Entity\r\n@Table(name = \"personnes1\")\r\n@Inheritance(strategy = InheritanceType.SINGLE_TABLE)\r\n@DiscriminatorColumn(name = \"persontype\")\r\n@DiscriminatorValue(\"1\")\r\n@NamedQuery(name = \"Personne1.findAll\", query = \"SELECT p FROM Personne1 p\")\r\npublic class Personne1 implements Serializable {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@Id\r\n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\r\n\tprivate Integer id;\r\n\r\n\tprivate String codepostal;\r\n\r\n\tprivate String nom;\r\n\r\n\tprivate String prenom;\r\n\r\n\tprivate String rue;\r\n\r\n\tprivate String ville;\r\n\r\n\tpublic Personne1() {\r\n\t}\r\n\r\n\tpublic Integer getId() {\r\n\t\treturn this.id;\r\n\t}\r\n\r\n\tpublic void setId(Integer id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\tpublic String getCodepostal() {\r\n\t\treturn this.codepostal;\r\n\t}\r\n\r\n\tpublic void setCodepostal(String codepostal) {\r\n\t\tthis.codepostal = codepostal;\r\n\t}\r\n\r\n\tpublic String getNom() {\r\n\t\treturn this.nom;\r\n\t}\r\n\r\n\tpublic void setNom(String nom) {\r\n\t\tthis.nom = nom;\r\n\t}\r\n\r\n\tpublic String getPrenom() {\r\n\t\treturn this.prenom;\r\n\t}\r\n\r\n\tpublic void setPrenom(String prenom) {\r\n\t\tthis.prenom = prenom;\r\n\t}\r\n\r\n\tpublic String getRue() {\r\n\t\treturn this.rue;\r\n\t}\r\n\r\n\tpublic void setRue(String rue) {\r\n\t\tthis.rue = rue;\r\n\t}\r\n\r\n\tpublic String getVille() {\r\n\t\treturn this.ville;\r\n\t}\r\n\r\n\tpublic void setVille(String ville) {\r\n\t\tthis.ville = ville;\r\n\t}\r\n\r\n}", "/\npublic interface HttpRequest {\n\n    static final String HEADER_CONTENT_TYPE = \"Content-Type\";\n    static final String HEADER_CONTENT_LENGTH = \"Content-Length\";\n\n    String getUrl();\n\n    HttpParams getHeaders();\n\n    HttpBody getBody();\n\n    HttpVerb getVerb();\n\n    boolean followRedirects();\n\n    static final class Builder<T> implements GenericBuilder<HttpRequest> {\n\n        private final String url;\n        private final HttpVerb verb;\n        private final HttpParams headers = new HttpParams();\n        private final HttpParams query = new HttpParams();\n\n        private HttpBody body;\n        private boolean followRedirects = false;\n\n        Builder(String url, HttpVerb verb){\n            this.url = url;\n            this.verb = verb;\n        }\n\n        public Builder<T> query(String name, String value){\n            this.query.put(name, value);\n            return this;\n        }\n\n        public Builder<T> query(HttpParams query){\n            this.query.putAll(query);\n            return this;\n        }\n\n        public Builder<T> header(String name, String value){\n            this.headers.put(name, value);\n            return this;\n        }\n\n        public Builder<T> header(HttpParams headers){\n            this.headers.putAll(headers);\n            return this;\n        }\n\n        public Builder<T> body(String contentType, String body){\n            this.body(new HttpStringBody(contentType, body));\n            return this;\n        }\n\n        public Builder<T> body(HttpBody body){\n            this.body = body;\n            return this;\n        }\n\n        public Builder<T> body(GenericBuilder<? extends HttpBody> body){\n            this.body = body.build();\n            return this;\n        }\n\n        public Builder<T> followRedirects(boolean followRedirects){\n            this.followRedirects = followRedirects;\n            return this;\n        }\n\n        public HttpRequest build(){\n\n            if(verb == HttpVerb.GET){\n                this.headers.removeAll(HEADER_CONTENT_TYPE); //Quick-dirty fix to prevent content type on get request\n            }\n\n            if(body != null){\n                if(body.getContentType() != null && !body.getContentType().isEmpty() && !this.headers.containsKey(HEADER_CONTENT_TYPE)){\n                    this.headers.put(HEADER_CONTENT_TYPE, body.getContentType());\n                }\n                if(body.getContentLength() >= 0  && !this.headers.containsKey(HEADER_CONTENT_LENGTH)){\n                    this.headers.put(HEADER_CONTENT_LENGTH, body.getContentLength());\n                }\n            }\n\n            return new HttpRequest() {\n                @Override\n                public String getUrl() {\n                    StringBuilder urlFinal = new StringBuilder(url);\n                    if(!query.isEmpty()){\n                        if(url.contains(\"?\")){\n                            if(!url.endsWith(\"&\")){\n                                urlFinal.append(\"&\");\n                            }\n                        } else {\n                            urlFinal.append(\"?\");\n                        }\n                        String queryStr = query.toUrlEncodedString();\n                        urlFinal.append(queryStr);\n                    }\n                    return urlFinal.toString();\n                }\n\n                @Override\n                public HttpParams getHeaders() {\n                    return headers;\n                }\n\n                @Override\n                public HttpBody getBody(){\n                    return body;\n                }\n\n                @Override\n                public HttpVerb getVerb() {\n                    return verb;\n                }\n\n                @Override\n                public boolean followRedirects() {\n                    return followRedirects;\n                }\n            };\n        }\n\n    }\n}\n", "cmu.hcii.whyline.bytecode.*;\nimport edu.cmu.hcii.whyline.qa.InvocationBlock;\nimport edu.cmu.hcii.whyline.trace.Trace;\nimport edu.cmu.hcii.whyline.ui.UI;\nimport edu.cmu.hcii.whyline.ui.views.View;\nimport edu.cmu.hcii.whyline.util.Util;\n\n/**\n * @author Andrew J. Ko\n *\n */\npublic class InvocationBlockView extends EventBlockView<InvocationBlock> {\n\t\n\tpublic InvocationBlockView(Visualization visualization, InvocationBlock block) {\n\t\t\n\t\tsuper(visualization, block);\n\t\t\n\t}\n\n\tprotected boolean isFamiliarInitially() { \n\n\t\tMethodrefInfo methodref = ((Invoke)visualization.getTrace().getInstruction(getBlock().getEventID())).getMethodInvoked();\n\t\tTrace trace = visualization.getTrace();\n\t\t\n\t\tClassfile classfile = trace.getClassfileByName(methodref.getClassName());\n\t\tboolean methodSourceIsFamiliar = classfile != null && trace.hasUserSourceFileFor(classfile);\n\t\treturn methodSourceIsFamiliar;\n\t\t\n\t}\n\n\tpublic final static void paintParensAndBraces(EventBlockView<?> view, Visualization visualization, Graphics2D g) {\n\n\t\tint leftParenX = (int) (view.getLocalLeft() + UI.PADDING_WITHIN_EVENTS * 2 + view.widthOfLabel);\n\t\tint parenY = (int) (view.getLocalBottom() - (view.getLocalHeight() - (visualization.PAREN_ASCENT)) / 2 - visualization.PAREN_DESCENT);\n\t\t\n\t\tArgumentEventView lastVisibleArgument = null;\n\t\tfor(View child : view.getChildren())\n\t\t\tif(child instanceof ArgumentEventView && !((ArgumentEventView)child).isHidden()) {\n\t\t\t\tlastVisibleArgument = (ArgumentEventView)child;\n\t\t\t}\n\t\t\n\t\tint rightParenX = (lastVisibleArgument == null ? leftParenX  + (int)visualization.PAREN_WIDTH : (int) (view.getLocalLeft() + lastVisibleArgument.getLocalRight() + UI.PADDING_WITHIN_EVENTS));\n\t\t\n\t\tg.setFont(UI.getSmallFont());\n\t\tg.setColor(UI.getControlTextColor());\n\t\tg.drawGlyphVector(visualization.LEFT_PAREN, leftParenX, parenY);\n\t\tg.drawGlyphVector(visualization.RIGHT_PAREN, rightParenX, parenY);\n\t\tg.drawGlyphVector(visualization.CLOSING_BRACE, (float)view.getVisibleLocalRight() + UI.PADDING_WITHIN_EVENTS, parenY);\n\n\t}\n\t\n\tprotected double getPaddingAfterLabel() { \n\n\t\tboolean hasVisibleArgument = false;\n\t\tfor(View child : getChildren()) {\n\t\t\tif(child instanceof ArgumentEventView) {\n\t\t\t\tif(!((ArgumentEventView)child).isHidden()) {\n\t\t\t\t\thasVisibleArgument = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If we've reached a non argument, then there isn't one.\n\t\t\telse break;\n\t\t}\n\n\t\treturn hasVisibleArgument ? 0 : visualization.PAREN_WIDTH + visualization.PAREN_AND_BRACE_WIDTH;\n\t\n\t}\n\n\tprotected final void paintExpanded(Graphics2D g) {\n\n\t\tsuper.paintExpanded(g);\n\t\t\t\t\n\t\tpaintParensAndBraces(this, visualization, g);\n\t\t\n\t}\n\n\tpublic String determineFirstLine() { \n\t\n\t\tInvoke invoke = ((Invoke)visualization.getTrace().getInstruction(getEventID()));\n\t\tString methodName = invoke.getJavaMethodName();\n\t\tString full = methodName + (isCollapsed() ? \"()\" : \"\"); \n\t\treturn Util.elide(full, UI.MAX_EVENT_LENGTH);\n\t\t\n\t}\n\n\tpublic String determineSecondLine() { return null; }\n\n\tprotected Color determineBorderColor() { return getBlock().invocationWasInstrumented() ? UI.CONTROL_COLOR : UI.UNFAMILIAR_COLOR; }\n\t\t\n}\n", "\n\n    Graph(int V) {\n\n    }\n\n    public static void change1(int [] p){\n        System.out.println(p);\n        p = new int[]{2};\n        System.out.println(p);\n    }\n\n    public static void change2(int p){\n        System.out.println(p);\n        p = 3;\n        System.out.println(p);\n    }\n    public static void main(String [] args){\n        int [] a = {1};\n        int b = 2;\n        System.out.println(b);\n        change1(a);\n        change2(b);\n        StdRandom.uniform();\n    }\n\n}\n", "arge, to any person obtaining a copy\n    of this software and associated documentation files (the \"Software\"), to deal\n    in the Software without restriction, including without limitation the rights\n    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n    copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all\n    copies or substantial portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n    SOFTWARE.\n*/\n\npackage com.aquarianz.aqlib.serialization;\n\nimport com.aquarianz.aqlib.AqCalendar;\nimport com.aquarianz.aqlib.Day;\nimport com.aquarianz.aqlib.Util;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\n\nimport javax.xml.bind.DatatypeConverter;\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport java.io.ByteArrayInputStream;\nimport java.io.File;\nimport java.util.LinkedList;\nimport java.util.Map;\nimport java.util.TreeMap;\n\n/**\n * Reads data from XML.\n */\npublic class XmlReadArchive implements ReadArchive {\n\n    protected final ObjectFactory factory;\n    protected Element root;\n    private Map<String, Element> children = new TreeMap<>();\n    private final LinkedList<Map<String, Element>> stack = new LinkedList<>();\n\n    public XmlReadArchive(File file, ObjectFactory factory) {\n        this.factory = factory;\n\n        try {\n            DocumentBuilderFactory xmlFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = xmlFactory.newDocumentBuilder();\n            Document document = builder.parse(file);\n            setRoot(document.getDocumentElement());\n        } catch (Exception ex) {\n            throw new RuntimeException(ex.getMessage(), ex);\n        }\n\n        root.normalize();\n    }\n\n    public XmlReadArchive(String xml, ObjectFactory factory) {\n        this.factory = factory;\n\n        try {\n            DocumentBuilderFactory xmlFactory = DocumentBuilderFactory.newInstance();\n            DocumentBuilder builder = xmlFactory.newDocumentBuilder();\n            ByteArrayInputStream input =  new ByteArrayInputStream(xml.getBytes(\"UTF-8\"));\n            Document document = builder.parse(input);\n            setRoot(document.getDocumentElement());\n        } catch (Exception ex) {\n            throw new RuntimeException(ex.getMessage(), ex);\n        }\n\n        root.normalize();\n    }\n\n    private void setRoot(Element element) {\n        root = element;\n\n        NodeList list = root.getChildNodes();\n        int length = list.getLength();\n        for (int i = 0; i < length; i++) {\n            Node node = list.item(i);\n            if (node.getNodeType() != Node.ELEMENT_NODE) {\n                continue;\n            }\n\n            Element child = (Element) node;\n            children.put(child.getTagName(), child);\n        }\n    }\n\n    @Override\n    public void close() {\n\n    }\n\n    @Override\n    public boolean hasMoreData(String name) {\n        Element element = findElement(name);\n        return (element != null);\n    }\n\n    private Element findElement(String name) {\n        return children.get(name);\n    }\n\n    @Override\n    public byte readByte(String name) {\n        Element element = findElement(name);\n        return Byte.parseByte(element.getTextContent());\n    }\n\n    @Override\n    public int readInt(String name) {\n        Element element = findElement(name);\n        return Integer.parseInt(element.getTextContent());\n    }\n\n    @Override\n    public Long readLong(String name) {\n        Element element = findElement(name);\n        if (!Util.equals(element.getAttribute(\"null\"), \"true\")) {\n            return Long.parseLong(element.getTextContent());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public float readFloat(String name) {\n        Element element = findElement(name);\n        return Float.parseFloat(element.getTextContent());\n    }\n\n    @Override\n    public Double readDouble(String name) {\n        Element element = findElement(name);\n        if (!Util.equals(element.getAttribute(\"null\"), \"true\")) {\n            return Double.parseDouble(element.getTextContent());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public Boolean readBoolean(String name) {\n        Element element = findElement(name);\n        if (!Util.equals(element.getAttribute(\"null\"), \"true\")) {\n            return Boolean.parseBoolean(element.getTextContent());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public String readString(String name) {\n        Element element = findElement(name);\n        if (!Util.equals(element.getAttribute(\"null\"), \"true\")) {\n            return element.getTextContent();\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public AqCalendar readTimestamp(String name) {\n        String text = readString(name);\n        if (null != text) {\n            return AqCalendar.parseCalendar(text, AqCalendar.DEFAULT_FORMAT);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public Day readDay(String name) {\n        String text = readString(name);\n        if (null != text) {\n            return new Day(text);\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public byte[] readBytes(String name) {\n        Element element = findElement(name);\n        if (!Util.equals(element.getAttribute(\"null\"), \"true\")) {\n            return DatatypeConverter.parseBase64Binary(element.getTextContent());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public void beginTransaction(String name) {\n        Element element = findElement(name);\n        stack.add(children);\n        setRoot(element);\n    }\n\n    @Override\n    public void endTransaction() {\n        Element element = (Element) root.getParentNode();\n        root = element;\n        children = stack.removeLast();\n    }\n\n    @Override\n    public AqSerializable readObject(String name) {\n        // Prepare for loading object\n        beginTransaction(name);\n\n        AqSerializable instance = null;\n        if (!Util.equals(root.getAttribute(\"null\"), \"true\")) {\n            // Read type hierarchy\n            String[] types = root.getAttribute(\"type\").split(\",\");\n\n            // Create object instance\n            for (String type : types) {\n                instance = factory.createObject(type);\n                if (null != instance) {\n                    break;\n                }\n            }\n\n            if (null == instance) {\n                throw new RuntimeException(\"Unknown hierarchy: \" + types);\n            }\n\n            // Ask object to read it's data\n            instance.readFrom(this);\n        }\n\n        // Commit load\n        endTransaction();\n\n        return instance;\n    }\n}\n", "istry;\n\n\n/**\n * This object contains factory methods for each\n * Java content interface and Java element interface\n * generated in the br.com.swconsultoria.cte.schema_300.retdistdfeint package.\n * <p>An ObjectFactory allows you to programatically\n * construct new instances of the Java representation\n * for XML content. The Java representation of XML\n * content can consist of schema derived interfaces\n * and classes representing the binding of schema\n * type definitions, element declarations and model\n * groups.  Factory methods for each of these are\n * provided in this class.\n */\n@XmlRegistry\npublic class ObjectFactory {\n\n\n    /**\n     * Create a new ObjectFactory that can be used to create new instances of schema derived classes for package: br.com.swconsultoria.cte.schema_300.retdistdfeint\n     */\n    public ObjectFactory() {\n    }\n\n    /**\n     * Create an instance of {@link RetDistDFeInt }\n     */\n    public RetDistDFeInt createRetDistDFeInt() {\n        return new RetDistDFeInt();\n    }\n\n    /**\n     * Create an instance of {@link RetDistDFeInt.LoteDistDFeInt }\n     */\n    public RetDistDFeInt.LoteDistDFeInt createRetDistDFeIntLoteDistDFeInt() {\n        return new RetDistDFeInt.LoteDistDFeInt();\n    }\n\n    /**\n     * Create an instance of {@link RetDistDFeInt.LoteDistDFeInt.DocZip }\n     */\n    public RetDistDFeInt.LoteDistDFeInt.DocZip createRetDistDFeIntLoteDistDFeIntDocZip() {\n        return new RetDistDFeInt.LoteDistDFeInt.DocZip();\n    }\n\n}\n", "13, 2015 EclipseSource.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n ******************************************************************************/\npackage com.eclipsesource.json;\n\nimport static com.eclipsesource.json.TestUtil.assertException;\nimport static org.junit.Assert.*;\n\nimport java.io.IOException;\nimport java.io.StringReader;\n\nimport org.hamcrest.core.StringStartsWith;\nimport org.junit.Test;\n\n\npublic class JsonParser_Test {\n\n  @Test\n  public void parse_rejectsEmptyString() {\n    assertParseException(0, \"Unexpected end of input\", \"\");\n  }\n\n  @Test\n  public void parse_rejectsEmptyReader() {\n    ParseException exception = assertException(ParseException.class, new Runnable() {\n      public void run() {\n        try {\n          new JsonParser(new StringReader(\"\")).parse();\n        } catch (IOException exception) {\n          throw new RuntimeException(exception);\n        }\n      }\n    });\n\n    assertEquals(0, exception.getOffset());\n    assertThat(exception.getMessage(), StringStartsWith.startsWith(\"Unexpected end of input at\"));\n  }\n\n  @Test\n  public void parse_acceptsArrays() {\n    assertEquals(new JsonArray(), parse(\"[]\"));\n  }\n\n  @Test\n  public void parse_acceptsObjects() {\n    assertEquals(new JsonObject(), parse(\"{}\"));\n  }\n\n  @Test\n  public void parse_acceptsStrings() {\n    assertEquals(new JsonString(\"\"), parse(\"\\\"\\\"\"));\n  }\n\n  @Test\n  public void parse_acceptsLiterals() {\n    assertSame(Json.NULL, parse(\"null\"));\n  }\n\n  @Test\n  public void parse_stripsPadding() {\n    assertEquals(new JsonArray(), parse(\" [ ] \"));\n  }\n\n  @Test\n  public void parse_ignoresAllWhiteSpace() {\n    assertEquals(new JsonArray(), parse(\"\\t\\r\\n [\\t\\r\\n ]\\t\\r\\n \"));\n  }\n\n  @Test\n  public void parse_failsWithUnterminatedString() {\n    assertParseException(5, \"Unexpected end of input\", \"[\\\"foo\");\n  }\n\n  @Test\n  public void parse_handlesLineBreaksAndColumnsCorrectly() {\n    assertParseException(0, 1, 0, \"!\");\n    assertParseException(2, 2, 0, \"[\\n!\");\n    assertParseException(3, 2, 0, \"[\\r\\n!\");\n    assertParseException(6, 3, 1, \"[ \\n \\n !\");\n    assertParseException(7, 2, 3, \"[ \\r\\n \\r !\");\n  }\n\n  @Test\n  public void parse_handlesInputsThatExceedBufferSize() throws IOException {\n    String input = \"[ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47 ]\";\n\n    JsonValue value = new JsonParser(new StringReader(input), 3).parse();\n\n    assertEquals(\"[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47]\", value.toString());\n  }\n\n  @Test\n  public void parse_handlesStringsThatExceedBufferSize() throws IOException {\n    String input = \"[ \\\"lorem ipsum dolor sit amet\\\" ]\";\n\n    JsonValue value = new JsonParser(new StringReader(input), 3).parse();\n\n    assertEquals(\"[\\\"lorem ipsum dolor sit amet\\\"]\", value.toString());\n  }\n\n  @Test\n  public void parse_handlesNumbersThatExceedBufferSize() throws IOException {\n    String input = \"[ 3.141592653589 ]\";\n\n    JsonValue value = new JsonParser(new StringReader(input), 3).parse();\n\n    assertEquals(\"[3.141592653589]\", value.toString());\n  }\n\n  @Test\n  public void parse_handlesPositionsCorrectlyWhenInputExceedsBufferSize() {\n    final String input = \"{\\n  \\\"a\\\": 23,\\n  \\\"b\\\": 42,\\n}\";\n\n    ParseException exception = assertException(ParseException.class, new Runnable() {\n      public void run() {\n        try {\n          new JsonParser(new StringReader(input), 3).parse();\n        } catch (IOException e) {\n        }\n      }\n    });\n\n    assertEquals(4, exception.getLine());\n    assertEquals(0, exception.getColumn());\n    assertEquals(24, exception.getOffset());\n  }\n\n  @Test\n  public void arrays_empty() {\n    assertEquals(\"[]\", parse(\"[]\").toString());\n  }\n\n  @Test\n  public void arrays_singleValue() {\n    assertEquals(\"[23]\", parse(\"[23]\").toString());\n  }\n\n  @Test\n  public void arrays_multipleValues() {\n    assertEquals(\"[23,42]\", parse(\"[23,42]\").toString());\n  }\n\n  @Test\n  public void arrays_withWhitespaces() {\n    assertEquals(\"[23,42]\", parse(\"[ 23 , 42 ]\").toString());\n  }\n\n  @Test\n  public void arrays_nested() {\n    assertEquals(\"[[23],42]\", parse(\"[[23],42]\").toString());\n  }\n\n  @Test\n  public void arrays_illegalSyntax() {\n    assertParseException(1, \"Expected value\", \"[,]\");\n    assertParseException(4, \"Expected ',' or ']'\", \"[23 42]\");\n    assertParseException(4, \"Expected value\", \"[23,]\");\n  }\n\n  @Test\n  public void arrays_incomplete() {\n    assertParseException(1, \"Unexpected end of input\", \"[\");\n    assertParseException(2, \"Unexpected end of input\", \"[ \");\n    assertParseException(3, \"Unexpected end of input\", \"[23\");\n    assertParseException(4, \"Unexpected end of input\", \"[23 \");\n    assertParseException(4, \"Unexpected end of input\", \"[23,\");\n    assertParseException(5, \"Unexpected end of input\", \"[23, \");\n  }\n\n  @Test\n  public void objects_empty() {\n    assertEquals(\"{}\", parse(\"{}\").toString());\n  }\n\n  @Test\n  public void objects_singleValue() {\n    assertEquals(\"{\\\"foo\\\":23}\", parse(\"{\\\"foo\\\":23}\").toString());\n  }\n\n  @Test\n  public void objects_multipleValues() {\n    assertEquals(\"{\\\"foo\\\":23,\\\"bar\\\":42}\", parse(\"{\\\"foo\\\":23,\\\"bar\\\":42}\").toString());\n  }\n\n  @Test\n  public void objects_whitespace() {\n    assertEquals(\"{\\\"foo\\\":23,\\\"bar\\\":42}\", parse(\"{ \\\"foo\\\" : 23, \\\"bar\\\" : 42 }\").toString());\n  }\n\n  @Test\n  public void objects_nested() {\n    assertEquals(\"{\\\"foo\\\":{\\\"bar\\\":42}}\", parse(\"{\\\"foo\\\":{\\\"bar\\\":42}}\").toString());\n  }\n\n  @Test\n  public void objects_illegalSyntax() {\n    assertParseException(1, \"Expected name\", \"{,}\");\n    assertParseException(1, \"Expected name\", \"{:}\");\n    assertParseException(1, \"Expected name\", \"{23}\");\n    assertParseException(4, \"Expected ':'\", \"{\\\"a\\\"}\");\n    assertParseException(5, \"Expected ':'\", \"{\\\"a\\\" \\\"b\\\"}\");\n    assertParseException(5, \"Expected value\", \"{\\\"a\\\":}\");\n    assertParseException(8, \"Expected name\", \"{\\\"a\\\":23,}\");\n    assertParseException(8, \"Expected name\", \"{\\\"a\\\":23,42\");\n  }\n\n  @Test\n  public void objects_incomplete() {\n    assertParseException(1, \"Unexpected end of input\", \"{\");\n    assertParseException(2, \"Unexpected end of input\", \"{ \");\n    assertParseException(2, \"Unexpected end of input\", \"{\\\"\");\n    assertParseException(4, \"Unexpected end of input\", \"{\\\"a\\\"\");\n    assertParseException(5, \"Unexpected end of input\", \"{\\\"a\\\" \");\n    assertParseException(5, \"Unexpected end of input\", \"{\\\"a\\\":\");\n    assertParseException(6, \"Unexpected end of input\", \"{\\\"a\\\": \");\n    assertParseException(7, \"Unexpected end of input\", \"{\\\"a\\\":23\");\n    assertParseException(8, \"Unexpected end of input\", \"{\\\"a\\\":23 \");\n    assertParseException(8, \"Unexpected end of input\", \"{\\\"a\\\":23,\");\n    assertParseException(9, \"Unexpected end of input\", \"{\\\"a\\\":23, \");\n  }\n\n  @Test\n  public void strings_emptyString_isAccepted() {\n    assertEquals(\"\", parse(\"\\\"\\\"\").asString());\n  }\n\n  @Test\n  public void strings_asciiCharacters_areAccepted() {\n    assertEquals(\" \", parse(\"\\\" \\\"\").asString());\n    assertEquals(\"a\", parse(\"\\\"a\\\"\").asString());\n    assertEquals(\"foo\", parse(\"\\\"foo\\\"\").asString());\n    assertEquals(\"A2-D2\", parse(\"\\\"A2-D2\\\"\").asString());\n    assertEquals(\"\\u007f\", parse(\"\\\"\\u007f\\\"\").asString());\n  }\n\n  @Test\n  public void strings_nonAsciiCharacters_areAccepted() {\n    assertEquals(\"\u0420\u0443\u0441\u0441\u043a\u0438\u0439\", parse(\"\\\"\u0420\u0443\u0441\u0441\u043a\u0438\u0439\\\"\").asString());\n    assertEquals(\"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\", parse(\"\\\"\u0627\u0644\u0639\u0631\u0628\u064a\u0629\\\"\").asString());\n    assertEquals(\"\u65e5\u672c\u8a9e\", parse(\"\\\"\u65e5\u672c\u8a9e\\\"\").asString());\n  }\n\n  @Test\n  public void strings_controlCharacters_areRejected() {\n    // JSON string must not contain characters < 0x20\n    assertParseException(3, \"Expected valid string character\", \"\\\"--\\n--\\\"\");\n    assertParseException(3, \"Expected valid string character\", \"\\\"--\\r\\n--\\\"\");\n    assertParseException(3, \"Expected valid string character\", \"\\\"--\\t--\\\"\");\n    assertParseException(3, \"Expected valid string character\", \"\\\"--\\u0000--\\\"\");\n    assertParseException(3, \"Expected valid string character\", \"\\\"--\\u001f--\\\"\");\n  }\n\n  @Test\n  public void strings_validEscapes_areAccepted() {\n    // valid escapes are \\\" \\\\ \\/ \\b \\f \\n \\r \\t and unicode escapes\n    assertEquals(\" \\\" \", parse(\"\\\" \\\\\\\" \\\"\").asString());\n    assertEquals(\" \\\\ \", parse(\"\\\" \\\\\\\\ \\\"\").asString());\n    assertEquals(\" / \", parse(\"\\\" \\\\/ \\\"\").asString());\n    assertEquals(\" \\u0008 \", parse(\"\\\" \\\\b \\\"\").asString());\n    assertEquals(\" \\u000c \", parse(\"\\\" \\\\f \\\"\").asString());\n    assertEquals(\" \\r \", parse(\"\\\" \\\\r \\\"\").asString());\n    assertEquals(\" \\n \", parse(\"\\\" \\\\n \\\"\").asString());\n    assertEquals(\" \\t \", parse(\"\\\" \\\\t \\\"\").asString());\n  }\n\n  @Test\n  public void strings_escape_atStart() {\n    assertEquals(\"\\\\x\", parse(\"\\\"\\\\\\\\x\\\"\").asString());\n  }\n\n  @Test\n  public void strings_escape_atEnd() {\n    assertEquals(\"x\\\\\", parse(\"\\\"x\\\\\\\\\\\"\").asString());\n  }\n\n  @Test\n  public void strings_illegalEscapes_areRejected() {\n    assertParseException(2, \"Expected valid escape sequence\", \"\\\"\\\\a\\\"\");\n    assertParseException(2, \"Expected valid escape sequence\", \"\\\"\\\\x\\\"\");\n    assertParseException(2, \"Expected valid escape sequence\", \"\\\"\\\\000\\\"\");\n  }\n\n  @Test\n  public void strings_validUnicodeEscapes_areAccepted() {\n    assertEquals(\"\\u0021\", parse(\"\\\"\\\\u0021\\\"\").asString());\n    assertEquals(\"\\u4711\", parse(\"\\\"\\\\u4711\\\"\").asString());\n    assertEquals(\"\\uffff\", parse(\"\\\"\\\\uffff\\\"\").asString());\n    assertEquals(\"\\uabcdx\", parse(\"\\\"\\\\uabcdx\\\"\").asString());\n  }\n\n  @Test\n  public void strings_illegalUnicodeEscapes_areRejected() {\n    assertParseException(3, \"Expected hexadecimal digit\", \"\\\"\\\\u \\\"\");\n    assertParseException(3, \"Expected hexadecimal digit\", \"\\\"\\\\ux\\\"\");\n    assertParseException(5, \"Expected hexadecimal digit\", \"\\\"\\\\u20 \\\"\");\n    assertParseException(6, \"Expected hexadecimal digit\", \"\\\"\\\\u000x\\\"\");\n  }\n\n  @Test\n  public void strings_incompleteStrings_areRejected() {\n    assertParseException(1, \"Unexpected end of input\", \"\\\"\");\n    assertParseException(4, \"Unexpected end of input\", \"\\\"foo\");\n    assertParseException(5, \"Unexpected end of input\", \"\\\"foo\\\\\");\n    assertParseException(6, \"Unexpected end of input\", \"\\\"foo\\\\n\");\n    assertParseException(6, \"Unexpected end of input\", \"\\\"foo\\\\u\");\n    assertParseException(7, \"Unexpected end of input\", \"\\\"foo\\\\u0\");\n    assertParseException(9, \"Unexpected end of input\", \"\\\"foo\\\\u000\");\n    assertParseException(10, \"Unexpected end of input\", \"\\\"foo\\\\u0000\");\n  }\n\n  @Test\n  public void numbers_integer() {\n    assertEquals(new JsonNumber(\"0\"), parse(\"0\"));\n    assertEquals(new JsonNumber(\"-0\"), parse(\"-0\"));\n    assertEquals(new JsonNumber(\"1\"), parse(\"1\"));\n    assertEquals(new JsonNumber(\"-1\"), parse(\"-1\"));\n    assertEquals(new JsonNumber(\"23\"), parse(\"23\"));\n    assertEquals(new JsonNumber(\"-23\"), parse(\"-23\"));\n    assertEquals(new JsonNumber(\"1234567890\"), parse(\"1234567890\"));\n    assertEquals(new JsonNumber(\"123456789012345678901234567890\"),\n                 parse(\"123456789012345678901234567890\"));\n  }\n\n  @Test\n  public void numbers_minusZero() {\n    // allowed by JSON, allowed by Java\n    JsonValue value = parse(\"-0\");\n\n    assertEquals(0, value.asInt());\n    assertEquals(0l, value.asLong());\n    assertEquals(0f, value.asFloat(), 0);\n    assertEquals(0d, value.asDouble(), 0);\n  }\n\n  @Test\n  public void numbers_decimal() {\n    assertEquals(new JsonNumber(\"0.23\"), parse(\"0.23\"));\n    assertEquals(new JsonNumber(\"-0.23\"), parse(\"-0.23\"));\n    assertEquals(new JsonNumber(\"1234567890.12345678901234567890\"),\n                 parse(\"1234567890.12345678901234567890\"));\n  }\n\n  @Test\n  public void numbers_withExponent() {\n    assertEquals(new JsonNumber(\"0.1e9\"), parse(\"0.1e9\"));\n    assertEquals(new JsonNumber(\"0.1e9\"), parse(\"0.1e9\"));\n    assertEquals(new JsonNumber(\"0.1E9\"), parse(\"0.1E9\"));\n    assertEquals(new JsonNumber(\"-0.23e9\"), parse(\"-0.23e9\"));\n    assertEquals(new JsonNumber(\"0.23e9\"), parse(\"0.23e9\"));\n    assertEquals(new JsonNumber(\"0.23e+9\"), parse(\"0.23e+9\"));\n    assertEquals(new JsonNumber(\"0.23e-9\"), parse(\"0.23e-9\"));\n  }\n\n  @Test\n  public void numbers_withInvalidFormat() {\n    assertParseException(0, \"Expected value\", \"+1\");\n    assertParseException(0, \"Expected value\", \".1\");\n    assertParseException(1, \"Unexpected character\", \"02\");\n    assertParseException(2, \"Unexpected character\", \"-02\");\n    assertParseException(1, \"Expected digit\", \"-x\");\n    assertParseException(2, \"Expected digit\", \"1.x\");\n    assertParseException(2, \"Expected digit\", \"1ex\");\n    assertParseException(3, \"Unexpected character\", \"1e1x\");\n  }\n\n  @Test\n  public void numbers_incomplete() {\n    assertParseException(1, \"Unexpected end of input\", \"-\");\n    assertParseException(2, \"Unexpected end of input\", \"1.\");\n    assertParseException(4, \"Unexpected end of input\", \"1.0e\");\n    assertParseException(5, \"Unexpected end of input\", \"1.0e-\");\n  }\n\n  @Test\n  public void null_complete() {\n    assertEquals(Json.NULL, parse(\"null\"));\n  }\n\n  @Test\n  public void null_incomplete() {\n    assertParseException(1, \"Unexpected end of input\", \"n\");\n    assertParseException(2, \"Unexpected end of input\", \"nu\");\n    assertParseException(3, \"Unexpected end of input\", \"nul\");\n  }\n\n  @Test\n  public void null_withIllegalCharacter() {\n    assertParseException(1, \"Expected 'u'\", \"nx\");\n    assertParseException(2, \"Expected 'l'\", \"nux\");\n    assertParseException(3, \"Expected 'l'\", \"nulx\");\n    assertParseException(4, \"Unexpected character\", \"nullx\");\n  }\n\n  @Test\n  public void true_complete() {\n    assertSame(Json.TRUE, parse(\"true\"));\n  }\n\n  @Test\n  public void true_incomplete() {\n    assertParseException(1, \"Unexpected end of input\", \"t\");\n    assertParseException(2, \"Unexpected end of input\", \"tr\");\n    assertParseException(3, \"Unexpected end of input\", \"tru\");\n  }\n\n  @Test\n  public void true_withIllegalCharacter() {\n    assertParseException(1, \"Expected 'r'\", \"tx\");\n    assertParseException(2, \"Expected 'u'\", \"trx\");\n    assertParseException(3, \"Expected 'e'\", \"trux\");\n    assertParseException(4, \"Unexpected character\", \"truex\");\n  }\n\n  @Test\n  public void false_complete() {\n    assertSame(Json.FALSE, parse(\"false\"));\n  }\n\n  @Test\n  public void false_incomplete() {\n    assertParseException(1, \"Unexpected end of input\", \"f\");\n    assertParseException(2, \"Unexpected end of input\", \"fa\");\n    assertParseException(3, \"Unexpected end of input\", \"fal\");\n    assertParseException(4, \"Unexpected end of input\", \"fals\");\n  }\n\n  @Test\n  public void false_withIllegalCharacter() {\n    assertParseException(1, \"Expected 'a'\", \"fx\");\n    assertParseException(2, \"Expected 'l'\", \"fax\");\n    assertParseException(3, \"Expected 's'\", \"falx\");\n    assertParseException(4, \"Expected 'e'\", \"falsx\");\n    assertParseException(5, \"Unexpected character\", \"falsex\");\n  }\n\n  private static void assertParseException(int offset, String message, final String json) {\n    ParseException exception = assertException(ParseException.class, new Runnable() {\n      public void run() {\n        parse(json);\n      }\n    });\n    assertEquals(offset, exception.getOffset());\n    assertThat(exception.getMessage(), StringStartsWith.startsWith(message + \" at\"));\n  }\n\n  private static void assertParseException(int offset, int line, int column, final String json) {\n    ParseException exception = assertException(ParseException.class, new Runnable() {\n      public void run() {\n        parse(json);\n      }\n    });\n    assertEquals(\"offset\", offset, exception.getOffset());\n    assertEquals(\"line\", line, exception.getLine());\n    assertEquals(\"column\", column, exception.getColumn());\n  }\n\n  private static JsonValue parse(String json) {\n    try {\n      return new JsonParser(json).parse();\n    } catch (IOException exception) {\n      throw new RuntimeException(exception);\n    }\n  }\n\n}\n", "TURN_BACK\n}\n", "e incorrect behavior and will be lost if\r\n *     the code is regenerated.\r\n */\r\npackage com.mozu.api.contracts.core;\r\n\r\nimport java.io.Serializable;\r\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\r\nimport org.joda.time.DateTime;\r\n\r\n/**\r\n *\tIdentifier and datetime stamp information recorded when a user or application creates, updates, or deletes a resource entity. This value is system-supplied and read-only.\r\n */\r\n@JsonIgnoreProperties(ignoreUnknown = true)\r\npublic class AuditInfo implements Serializable\r\n{\r\n\t// Default Serial Version UID\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t/**\r\n\t * Unique identifier of the user created the resource entity. This value is system-supplied and read-only.\r\n\t */\r\n\tprotected String createBy;\n\r\n\tpublic String getCreateBy() {\n\t\treturn this.createBy;\n\t}\n\r\n\tpublic void setCreateBy(String createBy) {\n\t\tthis.createBy = createBy;\n\t}\r\n\r\n\t/**\r\n\t * Date and time when the entity was created, represented in UTC Date/Time.\r\n\t */\r\n\tprotected DateTime createDate;\n\r\n\tpublic DateTime getCreateDate() {\n\t\treturn this.createDate;\n\t}\n\r\n\tpublic void setCreateDate(DateTime createDate) {\n\t\tthis.createDate = createDate;\n\t}\r\n\r\n\t/**\r\n\t * Unique identifier of the user who last modified the item. This value is system-supplied and read-only.\r\n\t */\r\n\tprotected String updateBy;\n\r\n\tpublic String getUpdateBy() {\n\t\treturn this.updateBy;\n\t}\n\r\n\tpublic void setUpdateBy(String updateBy) {\n\t\tthis.updateBy = updateBy;\n\t}\r\n\r\n\t/**\r\n\t * Date and time when the entity was last updated, represented in UTC Date/Time.\r\n\t */\r\n\tprotected DateTime updateDate;\n\r\n\tpublic DateTime getUpdateDate() {\n\t\treturn this.updateDate;\n\t}\n\r\n\tpublic void setUpdateDate(DateTime updateDate) {\n\t\tthis.updateDate = updateDate;\n\t}\r\n\r\n}\r\n", "rt android.app.Dialog;\nimport android.app.DialogFragment;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.content.SharedPreferences;\nimport android.preference.PreferenceManager;\nimport android.os.Bundle;\nimport android.text.format.DateFormat;\nimport android.util.Log;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.TimePicker;\n\npublic class MyActivity extends Activity implements AdapterView.OnItemClickListener {\n    private static final String TAG = \"MyActivity\";\n    private String[] mListText = new String[3];\n    private ArrayAdapter<String> mAdapter;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        Log.i(TAG, \"onCreate\");\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_my);\n\n        initListView();\n    }\n\n    private boolean initListView() {\n        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(this);\n        boolean run_flag = pref.getBoolean(Const.RUN_FLAG, false);\n\n        mListText[0] = run_flag ? getString(R.string.list1_1) : getString(R.string.list1_0);\n        mListText[1] = getString(R.string.list2_0, pref.getInt(Const.ON_HOUR, 22), pref.getInt(Const.ON_MINUTE, 0));\n        mListText[2] = getString(R.string.list3_0, pref.getInt(Const.OFF_HOUR, 6), pref.getInt(Const.OFF_MINUTE, 0));\n\n        mAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, mListText);\n        ListView listView = (ListView) findViewById(R.id.listView);\n        TextView textView = new TextView(this);\n        textView.setText(R.string.list0_0);\n        listView.addHeaderView(textView, null, false);\n        listView.setAdapter(mAdapter);\n\n        listView.setOnItemClickListener(this);\n        return true;\n    }\n\n    @Override\n    public void onItemClick(AdapterView<?> adapterView, View view, int i, long l) {\n        final String DIALOG = \"dialog\";\n        switch (i) {\n            case 0:\n                break;\n            case 1:\n                doToggleService();\n                break;\n            case 2:\n                new SettingDialog1().show(getFragmentManager(), DIALOG);\n                break;\n            case 3:\n                new SettingDialog2().show(getFragmentManager(), DIALOG);\n                break;\n        }\n    }\n\n    private boolean doToggleService() {\n        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(this);\n        SharedPreferences.Editor edit = pref.edit();\n\n        boolean run_flag = !pref.getBoolean(Const.RUN_FLAG, false);\n        edit.putBoolean(Const.RUN_FLAG, run_flag);\n        edit.apply();\n        mListText[0] = run_flag ? getString(R.string.list1_1) : getString(R.string.list1_0);\n        mAdapter.notifyDataSetChanged();\n\n        Intent i = new Intent(this, MyService.class);\n        i.putExtra(Const.RUN_MODE, run_flag ? Const.MODE_START : Const.MODE_END);\n        startService(i);\n        return true;\n    }\n\n    public static class SettingDialog1 extends DialogFragment implements DialogInterface.OnClickListener {\n        private TimePicker mTimePicker;\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(getActivity());\n            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n            builder.setTitle(R.string.time_title);\n            mTimePicker = new TimePicker(getActivity());\n            if (savedInstanceState != null){\n                mTimePicker.setCurrentHour(savedInstanceState.getInt(Const.ON_HOUR));\n                mTimePicker.setCurrentMinute(savedInstanceState.getInt(Const.ON_MINUTE));\n            } else {\n                mTimePicker.setCurrentHour(pref.getInt(Const.ON_HOUR, 22));\n                mTimePicker.setCurrentMinute(pref.getInt(Const.ON_MINUTE, 0));\n            }\n            mTimePicker.setIs24HourView(DateFormat.is24HourFormat(getActivity()));\n            mTimePicker.setSaveFromParentEnabled(false);\n            mTimePicker.setSaveEnabled(true);\n            builder.setView(mTimePicker);\n            builder.setPositiveButton(R.string.time_done, this);\n            return builder.create();\n        }\n\n        @Override\n        public void onSaveInstanceState(Bundle outState) {\n            if (mTimePicker != null){\n                outState.putInt(Const.ON_HOUR, mTimePicker.getCurrentHour());\n                outState.putInt(Const.ON_MINUTE, mTimePicker.getCurrentMinute());\n            }\n            super.onSaveInstanceState(outState);\n        }\n\n        @Override\n        public void onClick(DialogInterface dialogInterface, int i) {\n            final SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(getActivity());\n            int hour = mTimePicker.getCurrentHour();\n            int minute = mTimePicker.getCurrentMinute();\n            SharedPreferences.Editor edit = pref.edit();\n            edit.putInt(Const.ON_HOUR, hour);\n            edit.putInt(Const.ON_MINUTE, minute);\n            edit.apply();\n\n            MyActivity my = (MyActivity)getActivity();\n            my.mListText[1] = getString(R.string.list2_0, hour, minute);\n            my.mAdapter.notifyDataSetChanged();\n            my.refreshSetting();\n        }\n    }\n\n    public static class SettingDialog2 extends DialogFragment implements DialogInterface.OnClickListener {\n        private TimePicker mTimePicker;\n\n        @Override\n        public Dialog onCreateDialog(Bundle savedInstanceState) {\n            final SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(getActivity());\n            AlertDialog.Builder builder = new AlertDialog.Builder(getActivity());\n            builder.setTitle(R.string.time_title);\n            mTimePicker = new TimePicker(getActivity());\n            if (savedInstanceState != null){\n                mTimePicker.setCurrentHour(savedInstanceState.getInt(Const.OFF_HOUR));\n                mTimePicker.setCurrentMinute(savedInstanceState.getInt(Const.OFF_MINUTE));\n            } else {\n                mTimePicker.setCurrentHour(pref.getInt(Const.OFF_HOUR, 6));\n                mTimePicker.setCurrentMinute(pref.getInt(Const.OFF_MINUTE, 0));\n            }\n            mTimePicker.setIs24HourView(DateFormat.is24HourFormat(getActivity()));\n            mTimePicker.setSaveFromParentEnabled(false);\n            mTimePicker.setSaveEnabled(true);\n            builder.setView(mTimePicker);\n            builder.setPositiveButton(R.string.time_done, this);\n            return builder.create();\n        }\n\n        @Override\n        public void onSaveInstanceState(Bundle outState) {\n            if (mTimePicker != null){\n                outState.putInt(Const.OFF_HOUR, mTimePicker.getCurrentHour());\n                outState.putInt(Const.OFF_MINUTE, mTimePicker.getCurrentMinute());\n            }\n            super.onSaveInstanceState(outState);\n        }\n\n        @Override\n        public void onClick(DialogInterface dialogInterface, int i) {\n            final SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(getActivity());\n            int hour = mTimePicker.getCurrentHour();\n            int minute = mTimePicker.getCurrentMinute();\n            SharedPreferences.Editor edit = pref.edit();\n            edit.putInt(Const.OFF_HOUR, hour);\n            edit.putInt(Const.OFF_MINUTE, minute);\n            edit.apply();\n\n            MyActivity my = (MyActivity)getActivity();\n            my.mListText[2] = getString(R.string.list3_0, hour, minute);\n            my.mAdapter.notifyDataSetChanged();\n            my.refreshSetting();\n        }\n    }\n\n    private boolean refreshSetting() {\n        SharedPreferences pref = PreferenceManager.getDefaultSharedPreferences(this);\n        boolean run_flag = pref.getBoolean(Const.RUN_FLAG, false);\n\n        if (run_flag) {\n            Intent i = new Intent(this, MyService.class);\n            i.putExtra(Const.RUN_MODE, Const.MODE_START);\n            startService(i);\n        }\n        return true;\n    }\n}\n", "s.Ship;\nimport static dcpu.DcpuConstants.*;\n\npublic class DemoSensor implements Equipment {\n\tprivate Ship ship;\n\tprivate char hwid;\n\n\tpublic DemoSensor(char hwid) {\n\t\tthis.hwid = hwid;\n\t}\n\n\tpublic void addedTo(Ship s) {\n\t\tthis.ship = s;\n\t\t\n\t\ts.addPluginHardware(hwid, new Hardware() {\n\t\t\t\n\t\t\tpublic void query(Dcpu parent) {\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t\tpublic void plugged_in(Dcpu parent, char id) {\n\t\t\t}\n\t\t\t\n\t\t\tpublic void interrupted(Dcpu parent) {\n\t\t\t\tparent.regs.gp[REG_C] = 0;\n\t\t\t\tif (Math.abs((int)ship.me.x)<0x7FFF) {\n\t\t\t\t\tparent.regs.gp[REG_A] = (char)((int)ship.me.x);\n\t\t\t\t} else {\n\t\t\t\t\tparent.regs.gp[REG_C] |= 1;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (Math.abs((int)ship.me.y)<0x7FFF) {\n\t\t\t\t\tparent.regs.gp[REG_B] = (char)((int)ship.me.y);\n\t\t\t\t} else {\n\t\t\t\t\tparent.regs.gp[REG_C] |= 2;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tint rotdeg = (((int)((ship.me.rot / Math.PI) * 180))%360);\n\t\t\t\twhile (rotdeg < 0) {\n\t\t\t\t\trotdeg += 360;\n\t\t\t\t}\t\t\t\t\n\t\t\t\tparent.regs.gp[REG_X] = (char)rotdeg;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\tint rotspeeddeg = (((int)((ship.me.rotspeed_calc() / Math.PI) * 180*33)));\n\t\t\t\tparent.regs.gp[REG_Y] = (char)rotspeeddeg;\n\t\t\t\t\n\t\t\t\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t});\n\t}\n\n\tpublic void reset() {\n\t\t\n\t}\n\n\tpublic void physicsTickPostForce() {\n\t\t\n\t}\n\n\tpublic void triggerSynchronizedEvent(char id, int cyclesAgo) {\n\t}\n\n\tpublic void physicsTickPreForce() {\n\t\t// TODO Auto-generated method stub\n\t\t\n\t}\n\n}\n", "om.plivo.api.models.base.Deleter;\nimport okhttp3.ResponseBody;\nimport retrofit2.Call;\n\npublic class AddressDeleter extends Deleter<Application> {\n\n  public AddressDeleter(String id) {\n    super(id);\n  }\n\n  @Override\n  protected Call<ResponseBody> obtainCall() {\n    return client().getApiService().addressDelete(client().getAuthId(), id);\n  }\n}\n\n", "ny Blue,achellies\n * <p/>\n * Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n * and associated documentation files (the \"Software\"), to deal in the Software\n * without restriction, including without limitation the rights to use, copy, modify,\n * merge, publish, distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * <p/>\n * The above copyright notice and this permission notice shall be included in all copies\n * or substantial portions of the Software.\n * <p/>\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,\n * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR\n * PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n * FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n * @author BunnyBlue\n **/\npackage com.openatlas.hack;\n\nimport com.openatlas.hack.Hack.HackDeclaration.HackAssertionException;\nimport com.openatlas.hack.Interception.InterceptionHandler;\nimport com.openatlas.runtime.DelegateClassLoader;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\n\npublic class Hack {\n    private static AssertionFailureHandler sFailureHandler;\n\n    public interface AssertionFailureHandler {\n        boolean onAssertionFailure(HackAssertionException hackAssertionException);\n    }\n\n    public static abstract class HackDeclaration {\n\n        public static class HackAssertionException extends Throwable {\n            private static final long serialVersionUID = 1;\n            private Class<?> mHackedClass;\n            private String mHackedFieldName;\n            private String mHackedMethodName;\n\n            public HackAssertionException(String cause) {\n                super(cause);\n            }\n\n            public HackAssertionException(Exception exception) {\n                super(exception);\n            }\n\n            @Override\n            public String toString() {\n                return getCause() != null ? getClass().getName() + \": \"\n                        + getCause() : super.toString();\n            }\n\n            public Class<?> getHackedClass() {\n                return this.mHackedClass;\n            }\n\n            public void setHackedClass(Class<?> cls) {\n                this.mHackedClass = cls;\n            }\n\n            public String getHackedMethodName() {\n                return this.mHackedMethodName;\n            }\n\n            public void setHackedMethodName(String name) {\n                this.mHackedMethodName = name;\n            }\n\n            public String getHackedFieldName() {\n                return this.mHackedFieldName;\n            }\n\n            public void setHackedFieldName(String name) {\n                this.mHackedFieldName = name;\n            }\n        }\n    }\n\n    public static class HackedClass<C> {\n        protected Class<C> mClass;\n\n        public HackedField<C, Object> staticField(String name)\n                throws HackAssertionException {\n            return new HackedField(this.mClass, name, Modifier.STATIC);\n        }\n\n        public HackedField<C, Object> field(String name)\n                throws HackAssertionException {\n            return new HackedField(this.mClass, name, 0);\n        }\n\n        public HackedMethod staticMethod(String name, Class<?>... parameterTypes)\n                throws HackAssertionException {\n            return new HackedMethod(this.mClass, name, parameterTypes, Modifier.STATIC);\n        }\n\n        public HackedMethod method(String name, Class<?>... parameterTypes)\n                throws HackAssertionException {\n            return new HackedMethod(this.mClass, name, parameterTypes, 0);\n        }\n\n        public HackedConstructor constructor(Class<?>... parameterTypes)\n                throws HackAssertionException {\n            return new HackedConstructor(this.mClass, parameterTypes);\n        }\n\n        public HackedClass(Class<C> cls) {\n            this.mClass = cls;\n        }\n\n        public Class<C> getmClass() {\n            return this.mClass;\n        }\n    }\n\n    public static class HackedConstructor {\n        protected Constructor<?> mConstructor;\n\n        HackedConstructor(Class<?> clazz, Class<?>[] parameterTypes) throws HackAssertionException {\n            if (clazz != null) {\n                try {\n                    this.mConstructor = clazz.getDeclaredConstructor(parameterTypes);\n                } catch (Exception e) {\n                    HackAssertionException hackAssertionException = new HackAssertionException(e);\n                    hackAssertionException.setHackedClass(clazz);\n                    Hack.fail(hackAssertionException);\n                }\n            }\n        }\n\n        public Object getInstance(Object... args) throws IllegalArgumentException {\n\n            this.mConstructor.setAccessible(true);\n            try {\n                return this.mConstructor.newInstance(args);\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n    }\n\n    public static class HackedField<C, T> {\n        private final Field mField;\n\n        public <T2> com.openatlas.hack.Hack.HackedField<C, T2> ofGenericType(Class<?> cls) throws HackAssertionException {\n            if (!(this.mField == null || cls.isAssignableFrom(this.mField.getType()))) {\n                Hack.fail(new HackAssertionException(new ClassCastException(\n                        this.mField + \" is not of type \" + cls)));\n            }\n            return (HackedField<C, T2>) this;\n        }\n\n        public <T2> com.openatlas.hack.Hack.HackedField<C, T2> ofType(\n                Class<T2> cls) throws HackAssertionException {\n            if (!(this.mField == null || cls.isAssignableFrom(this.mField\n                    .getType()))) {\n                Hack.fail(new HackAssertionException(new ClassCastException(\n                        this.mField + \" is not of type \" + cls)));\n            }\n            return (HackedField<C, T2>) this;\n        }\n\n        public com.openatlas.hack.Hack.HackedField<C, T> ofType(\n                String className) throws HackAssertionException {\n            com.openatlas.hack.Hack.HackedField<C, T> ofType = null;\n            try {\n                ofType = (HackedField<C, T>) ofType(Class.forName(className));\n            } catch (Exception e) {\n                Hack.fail(new HackAssertionException(e));\n            }\n            return ofType;\n        }\n\n        public T get(C object) {\n            try {\n                return (T) this.mField.get(object);\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n                return null;\n            }\n        }\n\n        public void set(C object, Object value) {\n            try {\n                this.mField.set(object, value);\n            } catch (Throwable e) {\n                e.printStackTrace();\n                if (value instanceof DelegateClassLoader) {\n                    throw new RuntimeException(\"set DelegateClassLoader fail\", e);\n                }\n            }\n        }\n\n        public void hijack(C c, InterceptionHandler<?> interceptionHandler) {\n            Object obj = get(c);\n            if (obj == null) {\n                throw new IllegalStateException(\"Cannot hijack null\");\n            }\n            set(c, Interception.proxy(obj,\n                    interceptionHandler, obj.getClass()\n                            .getInterfaces()));\n        }\n\n        HackedField(Class<C> cls, String name, int modifier) throws HackAssertionException {\n            Field field = null;\n            if (cls == null) {\n                this.mField = null;\n                return;\n            }\n            try {\n                field = cls.getDeclaredField(name);\n                if (modifier > 0 && (field.getModifiers() & modifier) != modifier) {\n                    Hack.fail(new HackAssertionException(field\n                            + \" does not match modifiers: \" + modifier));\n                }\n                field.setAccessible(true);\n            } catch (Exception e) {\n                HackAssertionException hackAssertionException = new HackAssertionException(e);\n                hackAssertionException.setHackedClass(cls);\n                hackAssertionException.setHackedFieldName(name);\n                Hack.fail(hackAssertionException);\n            } finally {\n                this.mField = field;\n            }\n        }\n\n        public Field getField() {\n            return this.mField;\n        }\n    }\n\n    public static class HackedMethod {\n        protected final Method mMethod;\n\n        /****\n         * @param receiver the object on which to call this method (or null for static methods)\n         * @param args     the arguments to the method\n         * @return the result\n         * @throws IllegalArgumentException\n         * @throws InvocationTargetException\n         */\n        public Object invoke(Object receiver, Object... args) throws IllegalArgumentException, InvocationTargetException {\n            try {\n                return this.mMethod.invoke(receiver, args);\n            } catch (IllegalAccessException e) {\n                e.printStackTrace();\n            }\n            return null;\n        }\n\n        /***\n         * @param name           the requested method's name.\n         * @param parameterTypes the parameter types of the requested method.\n         */\n        HackedMethod(Class<?> cls, String name, Class<?>[] parameterTypes, int modifier) throws HackAssertionException {\n            Method method = null;\n            if (cls == null) {\n                this.mMethod = null;\n                return;\n            }\n            try {\n                method = cls.getDeclaredMethod(name, parameterTypes);\n                if (modifier > 0 && (method.getModifiers() & modifier) != modifier) {\n                    Hack.fail(new HackAssertionException(method\n                            + \" does not match modifiers: \" + modifier));\n                }\n                method.setAccessible(true);\n            } catch (Exception e) {\n                HackAssertionException hackAssertionException = new HackAssertionException(e);\n                hackAssertionException.setHackedClass(cls);\n                hackAssertionException.setHackedMethodName(name);\n                Hack.fail(hackAssertionException);\n            } finally {\n                this.mMethod = method;\n            }\n        }\n\n        public Method getMethod() {\n            return this.mMethod;\n        }\n    }\n\n    public static <T> HackedClass<T> into(Class<T> cls) {\n        return new HackedClass(cls);\n    }\n\n    public static <T> HackedClass<T> into(String str)\n            throws HackAssertionException {\n        try {\n            return new HackedClass(Class.forName(str));\n        } catch (Exception e) {\n            fail(new HackAssertionException(e));\n            return new HackedClass(null);\n        }\n    }\n\n    private static void fail(HackAssertionException hackAssertionException)\n            throws HackAssertionException {\n        if (sFailureHandler == null\n                || !sFailureHandler.onAssertionFailure(hackAssertionException)) {\n            throw hackAssertionException;\n        }\n    }\n\n    public static void setAssertionFailureHandler(\n            AssertionFailureHandler assertionFailureHandler) {\n        sFailureHandler = assertionFailureHandler;\n    }\n\n    private Hack() {\n    }\n}\n", "ODE                \n//                       DO NOT MODIFY                     \n//                                                         \n// Generated on 11/15/2014 22:29:17\n// ******************************************************* \npackage com.blastedstudios.freeboot.ai.bt.actions;\n\n/** ModelAction class created from MMPM action Aim. */\npublic class Aim extends jbt.model.task.leaf.action.ModelAction {\n\t/**\n\t * Value of the parameter \"target\" in case its value is specified at\n\t * construction time. null otherwise.\n\t */\n\tprivate float[] target;\n\t/**\n\t * Location, in the context, of the parameter \"target\" in case its value is\n\t * not specified at construction time. null otherwise.\n\t */\n\tprivate java.lang.String targetLoc;\n\n\t/**\n\t * Constructor. Constructs an instance of Aim.\n\t * \n\t * @param target\n\t *            value of the parameter \"target\", or null in case it should be\n\t *            read from the context. If null, <code>targetLoc</code> cannot\n\t *            be null.\n\t * @param targetLoc\n\t *            in case <code>target</code> is null, this variable represents\n\t *            the place in the context where the parameter's value will be\n\t *            retrieved from.\n\t */\n\tpublic Aim(jbt.model.core.ModelTask guard, float[] target,\n\t\t\tjava.lang.String targetLoc) {\n\t\tsuper(guard);\n\t\tthis.target = target;\n\t\tthis.targetLoc = targetLoc;\n\t}\n\n\t/**\n\t * Returns a com.blastedstudios.freeboot.ai.bt.actions.execution.Aim task that\n\t * is able to run this task.\n\t */\n\tpublic jbt.execution.core.ExecutionTask createExecutor(\n\t\t\tjbt.execution.core.BTExecutor executor,\n\t\t\tjbt.execution.core.ExecutionTask parent) {\n\t\treturn new com.blastedstudios.freeboot.ai.bt.actions.execution.Aim(this,\n\t\t\t\texecutor, parent, this.target, this.targetLoc);\n\t}\n}", "rface Action extends GenericAction<WebElement> {\n}", "ineItemClickListener {\n    public void onItemClick(View v, int position);\n}\n", "ed by whoszus on 2017/4/10.\n *\n * @email whoszus@yahoo.com\n */\n@Entity\n@Table(name = \"ip_access_list\")\npublic class IpAccessListEntity {\n    private Integer id;\n    private String ipAddr;\n    private int handleStatus;\n    private Integer isAccessable;\n\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"ID\", nullable = false)\n    public Integer getId() {\n        return id;\n    }\n\n    public void setId(Integer id) {\n        this.id = id;\n    }\n\n    @Basic\n    @Column(name = \"IP_ADDR\", nullable = true, length = 30)\n    public String getIpAddr() {\n        return ipAddr;\n    }\n\n    public void setIpAddr(String ipAddr) {\n        this.ipAddr = ipAddr;\n    }\n\n    @Basic\n    @Column(name = \"HANDLE_STATUS\", nullable = false)\n    public int getHandleStatus() {\n        return handleStatus;\n    }\n\n    public void setHandleStatus(int handleStatus) {\n        this.handleStatus = handleStatus;\n    }\n\n    @Basic\n    @Column(name = \"IS_ACCESSABLE\", nullable = true)\n    public Integer getIsAccessable() {\n        return isAccessable;\n    }\n\n    public void setIsAccessable(Integer isAccessable) {\n        this.isAccessable = isAccessable;\n    }\n\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        IpAccessListEntity that = (IpAccessListEntity) o;\n\n        if (id != that.id) return false;\n        if (handleStatus != that.handleStatus) return false;\n        if (ipAddr != null ? !ipAddr.equals(that.ipAddr) : that.ipAddr != null) return false;\n        if (isAccessable != null ? !isAccessable.equals(that.isAccessable) : that.isAccessable != null) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = id;\n        result = 31 * result + (ipAddr != null ? ipAddr.hashCode() : 0);\n        result = 31 * result + handleStatus;\n        result = 31 * result + (isAccessable != null ? isAccessable.hashCode() : 0);\n        return result;\n    }\n}\n", "rDao;\nimport com.ss.server.dao.jpa.*;\nimport com.ss.server.domain.*;\nimport com.ss.server.domain.in.ChargeRequest;\nimport com.ss.server.domain.in.SentenceRequest;\nimport com.ss.server.domain.in.UserInfo;\nimport com.ss.server.entity.*;\nimport com.ss.server.utils.CommandExecutor;\nimport com.ss.server.utils.KeyGenerator;\nimport org.apache.commons.codec.binary.Base64;\nimport org.apache.commons.lang.RandomStringUtils;\nimport org.apache.commons.lang.StringUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Service;\n\nimport javax.transaction.Transactional;\nimport java.util.ArrayList;\nimport java.util.Date;\nimport java.util.List;\n\n/**\n * Created with IntelliJ IDEA.\n * User: liji\n * Date: 17/3/2\n * Time: \u4e0b\u53489:31\n * To change this template use File | Settings | File Templates.\n */\n@Service\npublic class SSManager {\n\n    /**\n     * The constant TRAFFIC_UNIT_G.\n     */\n    public final static float TRAFFIC_UNIT_G = 1024 * 1024 * 1024;\n    /**\n     * The constant DEFAULT_FLOW.\n     */\n    private static final Logger log = LoggerFactory.getLogger(SSManager.class);\n\n    @Autowired\n    private SSUserDao ssUserDao;\n\n    @Autowired\n    private SSKeyRepository ssKeyRepository;\n\n    @Autowired\n    private KcptunRepository kcptunRepository;\n\n    @Autowired\n    private UserConfigRepository userConfigRepository;\n    @Autowired\n    private GuideSentenceRepository guideSentenceRepository;\n\n\n    @Autowired\n    private HostRepository hostRepository;\n\n    /**\n     * Create user.\n     *\n     * @param user the user\n     * @param flow the flow\n     * @return the ss user\n     */\n    public SSUser createSSUser(User user, int flow) {\n        log.info(\"\u521b\u5efaSS\u7528\u6237\uff1a{}\", user.toString());\n        int port = this.getMaxPort();\n        String pass = RandomStringUtils.randomNumeric(6);\n        SSUser ss = new SSUser();\n        ss.setEmail(user.getEmail());\n        ss.setEnable(true);\n        ss.setPass(pass);\n        ss.setPassword(pass);\n        ss.setPort(port);\n        ss.setTransferEnable(flow * TRAFFIC_UNIT_G);\n        ss.setUsed(0);\n        ss.setUserName(user.getFirstName());\n        ssUserDao.save(ss);\n        return ss;\n    }\n\n    // \u4e0d\u5b89\u5168\uff0c\u6682\u65f6\u4f7f\u7528\n    // \u8fd9\u5757\u903b\u8f91\u53ef\u80fd\u6709\u95ee\u9898\uff0c\u51fa\u73b0port\u51b2\u7a81\u7684\u95ee\u9898 2016-01-10\n    private int getMaxPort() {\n        // \u6570\u636e\u91cf\u5927\u4ee5\u540e\u53ef\u80fd\u6709\u95ee\u9898\u3002\n        return ssUserDao.getMaxPort() + 1;\n        /*int port = INCREMENT_PORT.get();\n        if(port == 0){\n\t\t\tport = this.ssUserDao.getMaxPort();\n\t\t\t// \u5f53\u524d\u6700\u5927\u503c\n\t\t\t// \u89e3\u51b3\u7aef\u53e3\u91cd\u590d\n\t\t\tINCREMENT_PORT.set(port + 1);\n\t\t}\n\t\treturn INCREMENT_PORT.incrementAndGet();*/\n    }\n\n\n    /**\n     * Generate key string.\n     *\n     * @param keyLength the key length\n     * @param host      the host\n     * @param flow      the flow\n     * @param keyType   the key type\n     * @return the string\n     */\n    public SSKey generateKey(int keyLength, String host, int flow, String keyType) {\n        if (host.equals(\"\")) {\n            host = Constant.KCP_DEFAULT_HOST;\n        }\n        String key = KeyGenerator.make(keyLength);\n        SSKey ssKey = new SSKey();\n        ssKey.setKey(key);\n        ssKey.setKeyType(keyType);\n        // Base64\n        ssKey.setBase64Code(new String(Base64.encodeBase64(key.getBytes())));\n        ssKey.setFlow(flow);\n        ssKey.setKeyHost(host);\n        ssKey.setKeyLength(keyLength);\n        return this.ssKeyRepository.save(ssKey);\n    }\n\n\n    private SSKey validateKey(String code) {\n        String key = new String(Base64.decodeBase64(code));\n        SSKey ssKey = this.ssKeyRepository.findByKey(key);\n        if (ssKey != null && !ssKey.isUsed()) {\n            // \u9a8c\u8bc1\u5b8c\u6210\u5931\u6548\n            ssKey.setUpdateTime(new Date());\n            ssKey.setUsed(true);\n            this.ssKeyRepository.save(ssKey);\n            return ssKey;\n        } else {\n            return null;\n        }\n    }\n\n    /**\n     * Gets user config.\n     *\n     * @param userInfo the user info\n     * @return the user config\n     */\n    @Transactional\n    public UserConfigDto getUserConfig(UserInfo userInfo) {\n        UserConfigDto result = new UserConfigDto();\n        UserConfig userConfig = findConfigByMac(userInfo.getMac());\n        if (userInfo != null && !StringUtils.isEmpty(userInfo.getKey())) {\n            // \u9a8c\u8bc1\u79d8\u94a5\n            SSKey ssKey = validateKey(userInfo.getKey());\n            if (ssKey != null) { // \u9a8c\u8bc1\u79d8\u94a5\u6210\u529f\n                // \u5145\u503c\n                if (userConfig != null) { // \u5df2\u7ecf\u6709\u7ed1\u5b9a\u8fc7mac\u5730\u5740\uff0c\u518d\u6b21\u5145\u503c\u64cd\u4f5c\n                    if (ssKey.getKeyType().equals(SSKey.KEY_TYPE_CHARGE)) { // \u5145\u503c\u7c7b\u578b\u79d8\u94a5\n                        // \u589e\u52a0\u6d41\u91cf\u64cd\u4f5c\n                        ssUserDao.updateFlow(userInfo.getMac(), ssKey.getFlow() * Constant.PER_GB);\n                        BeanUtils.copyProperties(userConfig, result);\n                    }\n                } else { // \u9996\u6b21\u4f7f\u7528\uff0c\u6ce8\u518c\u7528\u6237\n                    BeanUtils.copyProperties(createAccount(userInfo, ssKey), result);\n                }\n            } else {\n                // \u5931\u8d25\n                log.info(\"\u5145\u503c\u5931\u8d25\uff1a{},{}\", userInfo.getKey(), userInfo.getMac());\n                throw new RuntimeException(\"\u79d8\u94a5\u9a8c\u8bc1\u5931\u8d25\");\n            }\n        } else { // \u83b7\u53d6\u7528\u6237\u914d\u7f6e\n            BeanUtils.copyProperties(userConfig, result);\n        }\n        return result;\n    }\n\n    private UserConfig createAccount(UserInfo userInfo, SSKey ssKey) {\n        User user = new User();\n        user.setEmail(userInfo.getIp());\n        user.setFirstName(userInfo.getMac());\n        SSUser ssUser = this.createSSUser(user, ssKey.getFlow());\n        Kcptun kcptun = this.createKcpUser(ssUser.getPort(), ssKey.getKeyHost());\n        this.executeProcess(kcptun);\n        UserConfig ssConfig = this.saveUserConfig(userInfo, kcptun, ssUser);\n        return ssConfig;\n    }\n\n    private Kcptun createKcpUser(int ssPort, String kcpHost) {\n        Kcptun kcptun = new Kcptun();\n        kcptun.setKcpPort(ssPort + Constant.KCPTUN_PORT_INCREASE);\n        kcptun.setSsHost(Constant.SS_HOST);\n        kcptun.setSsPort(ssPort);\n        kcptun.setKcpHost(kcpHost);\n        kcptun.setSsMode(Constant.SS_SEC_MODE_RC4_MD5);\n        kcptun.setKcpMode(Constant.KCP_MODE);\n        this.kcptunRepository.save(kcptun);\n        return kcptun;\n    }\n\n    private UserConfig findConfigByMac(String mac) {\n        return this.userConfigRepository.findByMac(mac);\n    }\n\n\n    private UserConfig saveUserConfig(UserInfo userInfo, Kcptun kcptun, SSUser ssUser) {\n        log.info(\"\u4fdd\u5b58\u7528\u6237\u914d\u7f6e\u4fe1\u606f\uff01\");\n        UserConfig userConfig = new UserConfig();\n        userConfig.setEmail(userInfo.getEmail());\n        userConfig.setKcpHost(kcptun.getKcpHost());\n        userConfig.setKcpMode(kcptun.getKcpMode());\n        userConfig.setKcpPort(kcptun.getKcpPort());\n        userConfig.setKey(userInfo.getKey());\n        userConfig.setMac(userInfo.getMac());\n        userConfig.setName(userInfo.getName());\n        userConfig.setPhone(userInfo.getPhone());\n        userConfig.setSsHost(kcptun.getSsHost());\n        userConfig.setSsPassword(ssUser.getPassword());\n        userConfig.setSsPort(ssUser.getPort());\n        userConfig.setSsSecMode(kcptun.getSsMode());\n        return this.userConfigRepository.save(userConfig);\n    }\n\n    /**\n     * ./server_linux_386 -t 127.0.0.1:10896 -l :1980 -mode fast2\n     *\n     * @param kcptun the kcptun\n     */\n    public void executeProcess(Kcptun kcptun) {\n        log.info(\"\u521b\u5efaKCP\u8fdb\u7a0b\");\n        String command = \"./server_linux_386 -t \" + kcptun.getKcpHost() + \":\" + kcptun.getSsPort() + \" -l :\" + kcptun.getKcpPort() + \" -mode fast2\";\n        CommandExecutor.executeCommand(command);\n    }\n\n\n    /**\n     * Gets over flow by mac.\n     *\n     * @param mac the mac\n     * @return the over flow by mac\n     */\n    public AccountInfo getOverFlowByMac(String mac) {\n        AccountInfo accountInfo = new AccountInfo();\n        accountInfo.setLastFlow(this.ssUserDao.getLastFlow(mac) / Constant.PER_GB);\n        return accountInfo;\n    }\n\n\n    /**\n     * Charge ss boolean.\n     *\n     * @param chargeRequest the charge request\n     * @return the boolean\n     */\n    public boolean chargeSS(ChargeRequest chargeRequest) {\n        UserConfig userConfig = findConfigByMac(chargeRequest.getMac());\n        if (userConfig != null) {\n            // \u9a8c\u8bc1\u79d8\u94a5\n            SSKey ssKey = validateKey(chargeRequest.getKey());\n            if (ssKey == null) {\n                throw new RuntimeException(\"\u79d8\u94a5\u9a8c\u8bc1\u5931\u8d25\");\n            } else {\n                // \u589e\u52a0\u6d41\u91cf\u64cd\u4f5c\n                ssUserDao.updateFlow(chargeRequest.getMac(), ssKey.getFlow() * Constant.PER_GB);\n            }\n            return true;\n        } else {\n            throw new RuntimeException(\"\u6ca1\u6709\u627e\u5230\u8fd9\u4e2amac\u5730\u5740\");\n            // \u9a8c\u8bc1\u79d8\u94a5\n        }\n    }\n\n\n    /**\n     * Find all kcptun iterable.\n     *\n     * @return the iterable\n     */\n    public Iterable<Kcptun> findAllKcptun() {\n        return kcptunRepository.findAll();\n    }\n\n\n    /**\n     * Gets guide sentence.\n     *\n     * @return the guide sentence\n     */\n    public SentenceDto getGuideSentence() {\n        SentenceDto dto = new SentenceDto();\n        BeanUtils.copyProperties(this.guideSentenceRepository.findTopByOrderByCreateTimeDesc(), dto);\n        return dto;\n    }\n\n    /**\n     * Save guide sentence.\n     *\n     * @param request the request\n     */\n    public void saveGuideSentence(SentenceRequest request) {\n        GuideSentence guideSentence = new GuideSentence();\n        BeanUtils.copyProperties(request, guideSentence);\n        this.guideSentenceRepository.save(guideSentence);\n    }\n\n\n    /**\n     * Create host.\n     *\n     * @param ip the ip\n     */\n    public void createHost(String ip) {\n        Host host = new Host();\n        host.setIp(ip);\n        host.setConnectedSum(0);\n        this.hostRepository.save(host);\n    }\n\n    /**\n     * Find all hosts list.\n     *\n     * @return the list\n     */\n    public List<HostDto> findAllHosts() {\n        List<HostDto> list = new ArrayList<>();\n        this.hostRepository.findAll().forEach(host -> {\n            HostDto hostDto = new HostDto();\n            BeanUtils.copyProperties(host, hostDto);\n            list.add(hostDto);\n        });\n        return list;\n    }\n\n    /**\n     * Add host connections.\n     *\n     * @param ip the ip\n     */\n    public void addHostConnections(String ip) {\n        Host host = this.hostRepository.findByIp(ip);\n        host.setConnectedSum(host.getConnectedSum() + 1);\n        this.hostRepository.save(host);\n    }\n}\n", "ted = false;\r\n\tpublic String name = null;\r\n\tpublic Collection<Node> neighbors;\r\n\t\r\n\tpublic Node() {}\r\n\t\r\n\tpublic Node(String n){\r\n\t\tname = n;\r\n\t}\r\n\t\r\n\tpublic Node(String n , Boolean v) {\r\n\t\tname = n;\r\n\t\tvisited = v;\r\n\t}\r\n}", "etRequest;\nimport javax.validation.Valid;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.ModelAttribute;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport de.gw.auto.domain.SonstigeAusgaben;\nimport de.gw.auto.service.RegisteredUser;\nimport de.gw.auto.service.implementation.SonstigeAusgabenService;\nimport de.gw.auto.view.ViewName;\nimport de.gw.auto.view.model.HeaderModel;\nimport de.gw.auto.view.model.NewSonstigeAusgaben;\nimport de.gw.auto.view.model.NewTanken;\nimport de.gw.auto.view.model.SonstigeAusgabenView;\nimport de.gw.auto.view.model.helper.SonstigeAusgabenModelHelper;\n\n@Controller\n@RequestMapping(\"user/sonstigeAusgaben\")\npublic class SonstigeAusgabenController extends ControllerHelper {\n\n\t@Autowired\n\tprivate SonstigeAusgabenModelHelper sonstigeAusgabenModelHelper;\n\n\t@Autowired\n\tprivate SonstigeAusgabenService sonstigeAusgabenService;\n\n\t@RequestMapping(value = \"/save\", method = RequestMethod.POST)\n\tpublic String save(@Valid NewSonstigeAusgaben newSonstigeAusgaben, BindingResult bindingResult, Model model,\n\t\t\tPrincipal principal, RedirectAttributes redirectAttributes) {\n\t\tRegisteredUser user = giveRegisteredUser(principal);\n\t\tif (bindingResult.hasErrors()) {\n\t\t\tsonstigeAusgabenModelHelper.prepare(newSonstigeAusgaben, user.getCurrentAuto());\n\t\t\tmodel.addAttribute(newSonstigeAusgaben);\n\t\t\treturn \"sonstigeAusgaben/new\";\n\t\t}\n\n\t\tSonstigeAusgaben sa = new SonstigeAusgaben(newSonstigeAusgaben.getDatum(), newSonstigeAusgaben.getKmStand(),\n\t\t\t\tnewSonstigeAusgaben.getKommentar(), newSonstigeAusgaben.getKosten(), user.getCurrentAuto());\n\n\t\tsonstigeAusgabenService.save(sa, user);\n\t\treturn ViewName.REDIRECT_ROOT_USER_SHOW;\n\t}\n\n\t@RequestMapping(value = \"/show\", method = RequestMethod.GET)\n\tpublic String show(@ModelAttribute(\"SonstigeAusgabenView\") SonstigeAusgabenView sonstigeAusgabenView,\n\t\t\tPrincipal principal, Model model, HttpServletRequest request,\n\t\t\t@RequestParam(value = \"page\", defaultValue = \"0\") int page) {\n\t\tRegisteredUser user = giveRegisteredUser(principal);\n\t\tif (user.getCurrentAuto() == null) {\n\t\t\treturn \"redirect:/user/auto/new\";\n\t\t}\n\t\tif (user.getCurrentAuto().getSonstigeAusgaben().isEmpty()) {\n\t\t\treturn \"redirect:/user/sonstigeAusgaben/new\";\n\t\t}\n\t\tHeaderModel headerModel = new HeaderModel(user);\n\t\tsonstigeAusgabenView = this.sonstigeAusgabenModelHelper.prepare(sonstigeAusgabenView, user, page);\n\n\t\tmodel.addAttribute(\"headerModel\", headerModel);\n\t\tmodel.addAttribute(\"sonstigeAusgabenView\", sonstigeAusgabenView);\n\t\tmodel.addAttribute(\"newTanken\", new NewTanken());\n\t\treturn \"userMainPage\";\n\t}\n\n\t@RequestMapping(value = \"/new\", method = RequestMethod.GET)\n\tpublic String prepareNew(NewSonstigeAusgaben newSonstigeAusgaben, BindingResult bindingResult, Model model,\n\t\t\tPrincipal principal) {\n\t\tRegisteredUser user = giveRegisteredUser(principal);\n\t\tsonstigeAusgabenModelHelper.prepare(newSonstigeAusgaben, user.getCurrentAuto());\n\t\tmodel.addAttribute(newSonstigeAusgaben);\n\t\treturn \"sonstigeAusgaben/new\";\n\t}\n\n}\n", "Android Wheel Control.\n * https://code.google.com/p/android-wheel/\n *\n * Copyright 2011 Yuri Kanivets\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage antistatic.spinnerwheel;\n\nimport android.content.Context;\nimport android.content.res.TypedArray;\nimport android.graphics.*;\nimport android.graphics.drawable.Drawable;\nimport android.util.AttributeSet;\nimport com.nineoldandroids.animation.Animator;\nimport com.nineoldandroids.animation.ObjectAnimator;\n\n\n/**\n * Abstract spinner spinnerwheel view.\n * This class should be subclassed.\n *\n * @author Yuri Kanivets\n * @author Dimitri Fedorov\n */\npublic abstract class AbstractWheelView extends AbstractWheel {\n\n    private static int itemID = -1;\n\n    @SuppressWarnings(\"unused\")\n    private final String LOG_TAG = AbstractWheelView.class.getName() + \" #\" + (++itemID);\n\n    //----------------------------------\n    //  Default properties values\n    //----------------------------------\n\n    protected static final int DEF_ITEMS_DIMMED_ALPHA = 50; // 60 in ICS\n\n    protected static final int DEF_SELECTION_DIVIDER_ACTIVE_ALPHA = 70;\n\n    protected static final int DEF_SELECTION_DIVIDER_DIMMED_ALPHA = 70;\n\n    protected static final int DEF_ITEM_OFFSET_PERCENT = 10;\n\n    protected static final int DEF_ITEM_PADDING = 10;\n    \n    protected static final int DEF_SELECTION_DIVIDER_SIZE = 2;\n\n    //----------------------------------\n    //  Class properties\n    //----------------------------------\n\n    // configurable properties\n\n    /** The alpha of the selector spinnerwheel when it is dimmed. */\n    protected int mItemsDimmedAlpha;\n\n    /** The alpha of separators spinnerwheel when they are shown. */\n    protected int mSelectionDividerActiveAlpha;\n\n    /** The alpha of separators when they are is dimmed. */\n    protected int mSelectionDividerDimmedAlpha;\n\n    /** Top and bottom items offset */\n    protected int mItemOffsetPercent;\n\n    /** Left and right padding value */\n    protected int mItemsPadding;\n\n    /** Divider for showing item to be selected while scrolling */\n    protected Drawable mSelectionDivider;\n\n    // the rest\n\n    /**\n     * The {@link android.graphics.Paint} for drawing the selector.\n     */\n    protected Paint mSelectorWheelPaint;\n\n    /**\n     * The {@link android.graphics.Paint} for drawing the separators.\n     */\n    protected Paint mSeparatorsPaint;\n\n    /**\n     * {@link com.nineoldandroids.animation.Animator} for dimming the selector spinnerwheel.\n     */\n    protected Animator mDimSelectorWheelAnimator;\n\n    /**\n     * {@link com.nineoldandroids.animation.Animator} for dimming the selector spinnerwheel.\n     */\n    protected Animator mDimSeparatorsAnimator;\n\n    /**\n     * The property for setting the selector paint.\n     */\n    protected static final String PROPERTY_SELECTOR_PAINT_COEFF = \"selectorPaintCoeff\";\n\n    /**\n     * The property for setting the separators paint.\n     */\n    protected static final String PROPERTY_SEPARATORS_PAINT_ALPHA = \"separatorsPaintAlpha\";\n\n\n    protected Bitmap mSpinBitmap;\n    protected Bitmap mSeparatorsBitmap;\n\n\n    //--------------------------------------------------------------------------\n    //\n    //  Constructor\n    //\n    //--------------------------------------------------------------------------\n\n    public AbstractWheelView(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs, defStyle);\n    }\n\n    //--------------------------------------------------------------------------\n    //\n    //  Initiating assets and setters for paints\n    //\n    //--------------------------------------------------------------------------\n\n    @Override\n    protected void initAttributes(AttributeSet attrs, int defStyle) {\n        super.initAttributes(attrs, defStyle);\n        \n        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.AbstractWheelView, defStyle, 0);\n        mItemsDimmedAlpha = a.getInt(R.styleable.AbstractWheelView_itemsDimmedAlpha, DEF_ITEMS_DIMMED_ALPHA);\n        mSelectionDividerActiveAlpha = a.getInt(R.styleable.AbstractWheelView_selectionDividerActiveAlpha, DEF_SELECTION_DIVIDER_ACTIVE_ALPHA);\n        mSelectionDividerDimmedAlpha = a.getInt(R.styleable.AbstractWheelView_selectionDividerDimmedAlpha, DEF_SELECTION_DIVIDER_DIMMED_ALPHA);\n        mItemOffsetPercent = a.getInt(R.styleable.AbstractWheelView_itemOffsetPercent, DEF_ITEM_OFFSET_PERCENT);\n        mItemsPadding = a.getDimensionPixelSize(R.styleable.AbstractWheelView_itemsPadding, DEF_ITEM_PADDING);\n        mSelectionDivider = a.getDrawable(R.styleable.AbstractWheelView_selectionDivider);\n        a.recycle();\n    }\n\n    @Override\n    protected void initData(Context context) {\n        super.initData(context);\n\n        // creating animators\n        mDimSelectorWheelAnimator = ObjectAnimator.ofFloat(this, PROPERTY_SELECTOR_PAINT_COEFF, 1, 0);\n\n        mDimSeparatorsAnimator = ObjectAnimator.ofInt(this, PROPERTY_SEPARATORS_PAINT_ALPHA,\n                mSelectionDividerActiveAlpha, mSelectionDividerDimmedAlpha\n        );\n\n        // creating paints\n        mSeparatorsPaint = new Paint();\n        mSeparatorsPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n        mSeparatorsPaint.setAlpha(mSelectionDividerDimmedAlpha);\n\n        mSelectorWheelPaint = new Paint();\n        mSelectorWheelPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.DST_IN));\n    }\n\n    /**\n     * Recreates assets (like bitmaps) when layout size has been changed\n     *\n     * @param width New spinnerwheel width\n     * @param height New spinnerwheel height\n     */\n    @Override\n    protected void recreateAssets(int width, int height) {\n        mSpinBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        mSeparatorsBitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);\n        setSelectorPaintCoeff(0);\n    }\n\n    /**\n     * Sets the <code>alpha</code> of the {@link Paint} for drawing separators\n     * spinnerwheel.\n     * @param alpha alpha value from 0 to 255\n     */\n    @SuppressWarnings(\"unused\")  // Called via reflection\n    public void setSeparatorsPaintAlpha(int alpha) {\n        mSeparatorsPaint.setAlpha(alpha);\n        invalidate();\n    }\n\n    /**\n     * Sets the <code>coeff</code> of the {@link Paint} for drawing\n     * the selector spinnerwheel.\n     *\n     * @param coeff Coefficient from 0 (selector is passive) to 1 (selector is active)\n     */\n    abstract public void setSelectorPaintCoeff(float coeff);\n\n    public void setSelectionDivider(Drawable selectionDivider) {\n        this.mSelectionDivider = selectionDivider;\n    }\n\n    //--------------------------------------------------------------------------\n    //\n    //  Processing scroller events\n    //\n    //--------------------------------------------------------------------------\n\n    @Override\n    protected void onScrollTouched() {\n        mDimSelectorWheelAnimator.cancel();\n        mDimSeparatorsAnimator.cancel();\n        setSelectorPaintCoeff(1);\n        setSeparatorsPaintAlpha(mSelectionDividerActiveAlpha);\n    }\n\n    @Override\n    protected void onScrollTouchedUp() {\n        super.onScrollTouchedUp();\n        fadeSelectorWheel(750);\n        lightSeparators(750);\n    }\n\n    @Override\n    protected void onScrollFinished() {\n        fadeSelectorWheel(500);\n        lightSeparators(500);\n    }\n\n    //----------------------------------\n    //  Animating components\n    //----------------------------------\n\n    /**\n     * Fade the selector spinnerwheel via an animation.\n     *\n     * @param animationDuration The duration of the animation.\n     */\n    private void fadeSelectorWheel(long animationDuration) {\n        mDimSelectorWheelAnimator.setDuration(animationDuration);\n        mDimSelectorWheelAnimator.start();\n    }\n\n    /**\n     * Fade the selector spinnerwheel via an animation.\n     *\n     * @param animationDuration The duration of the animation.\n     */\n    private void lightSeparators(long animationDuration) {\n        mDimSeparatorsAnimator.setDuration(animationDuration);\n        mDimSeparatorsAnimator.start();\n    }\n\n\n    //--------------------------------------------------------------------------\n    //\n    //  Layout measuring\n    //\n    //--------------------------------------------------------------------------\n\n    /**\n     * Perform layout measurements\n     */\n    abstract protected void measureLayout();\n\n\n    //--------------------------------------------------------------------------\n    //\n    //  Drawing stuff\n    //\n    //--------------------------------------------------------------------------\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n\n        if (mViewAdapter != null && mViewAdapter.getItemsCount() > 0) {\n            if (rebuildItems()) {\n                measureLayout();\n            }\n            doItemsLayout();\n            drawItems(canvas);\n        }\n    }\n\n    /**\n     * Draws items on specified canvas\n     *\n     * @param canvas the canvas for drawing\n     */\n    abstract protected void drawItems(Canvas canvas);\n}\n", "blic int maxMirror(int[] nums) {\r\n\t\tif (nums.length == 0) {\r\n\t\t\treturn 0;\r\n\t\t}\r\n\r\n\t\tfor (int i = nums.length; i > 1; i--) {\r\n\t\t\tint len = i;\r\n\r\n\t\t\tfor (int j = 0; j <= nums.length - len; j++) {\r\n\t\t\t\tint[] reverse = new int[len];\r\n\t\t\t\tint index = 0;\r\n\r\n\t\t\t\tfor (int k = j; index < len; k++) {\r\n\t\t\t\t\treverse[reverse.length - 1 - index] = nums[k];\r\n\t\t\t\t\tindex++;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tfor (int k = 0; k <= nums.length - len; k++) {\r\n\t\t\t\t\tint position = 0;\r\n\r\n\t\t\t\t\tfor (int m = k; position < len; m++) {\r\n\t\t\t\t\t\tif (reverse[position] != nums[m]) {\r\n\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tif (position == len - 1) {\r\n\t\t\t\t\t\t\treturn len;\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tposition++;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn 1;\r\n\t}\r\n}\r\n", "lic class MyWebViewClient extends WebViewClient {\n\t@Override\n\tpublic void onPageFinished (WebView view, String url) {\n\t\tsuper.onPageFinished(view, url);\n\t}\n}\n", "", "ement;\n\nimport database.DB;\n\n/**\n * Task that resets all scores.\n * @author charles\n *\n */\npublic class ResetScoresTask implements Runnable {\n\n\t@Override\n\tpublic void run() {\n\t\tString sqlProduct =\"UPDATE products SET reliability_score =1\";\n\t\tString sqlUser =\"UPDATE users SET trust_score =1\";\n\t\tString sqlReview =\"UPDATE reviews SET HONESTY_score =1\";\n\t\ttry {\n\t\tConnection c = DB.getConnection();\n\t\t\n\t\tStatement st = c.createStatement();\n\t\t\tst.executeUpdate(sqlReview);\n\t\t\tst.executeUpdate(sqlUser);\n\t\t\tst.executeUpdate(sqlProduct);\n\t\t\tst.close();\n\t\t\tSystem.out.println(\"Score resetted\");\n\t\t} catch (SQLException | ClassNotFoundException e) {\n\t\t\tSystem.out.println(\"Error in Reset Score Task\");\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\n\t}\n}\n", "cape.elysium.net.codec.decoder.message.*;\nimport org.moparscape.elysium.util.BufferUtil;\n\n/**\n * Created by daniel on 14/01/2015.\n */\npublic final class MiscMessageDecoders {\n\n    public static final class BotDetectionMessageDecoder extends AbstractMessageDecoder<BotDetectionMessage> {\n\n        public BotDetectionMessageDecoder() {\n            super(BotDetectionMessage.class, 69);\n        }\n\n        public BotDetectionMessage decode(ByteBuf buffer, int length) {\n            throw new UnsupportedOperationException(\"No packet with opcode 69 in client\");\n        }\n    }\n\n    public static final class CommandMessageDecoder extends AbstractMessageDecoder<CommandMessage> {\n\n        public CommandMessageDecoder() {\n            super(CommandMessage.class, 90);\n        }\n\n        public CommandMessage decode(ByteBuf buffer, int length) {\n            String input = BufferUtil.readString(buffer);\n            int firstSpace = input.indexOf(\" \");\n            String command = input;\n            String[] args = new String[0];\n\n            if (firstSpace != -1) {\n                command = input.substring(0, firstSpace).trim();\n                args = input.substring(firstSpace + 1).trim().split(\" \");\n            }\n\n            return new CommandMessage(command, args);\n        }\n    }\n\n    public static final class ExceptionMessageDecoder extends AbstractMessageDecoder<ExceptionMessage> {\n\n        public ExceptionMessageDecoder() {\n            super(ExceptionMessage.class, 156);\n        }\n\n        public ExceptionMessage decode(ByteBuf buffer, int length) {\n            byte[] exceptionBytes = new byte[length];\n            buffer.readBytes(exceptionBytes);\n\n            return new ExceptionMessage(exceptionBytes);\n        }\n    }\n\n    public static final class InvalidMessageDecoder implements MessageDecoder<InvalidMessage> {\n\n        public int getOpcode() {\n            throw new IllegalStateException(\"This message decoder should not be activated\");\n        }\n\n        public Class<InvalidMessage> getMessageType() {\n            return InvalidMessage.class;\n        }\n\n        public InvalidMessage decode(ByteBuf buffer, int length) {\n            byte[] payload = new byte[length];\n            buffer.readBytes(payload, 0, length);\n\n            return new InvalidMessage(payload);\n        }\n    }\n\n    public static final class PingMessageDecoder extends AbstractMessageDecoder<PingMessage> {\n\n        public PingMessageDecoder() {\n            super(PingMessage.class, 5);\n        }\n\n        public PingMessage decode(ByteBuf buffer, int length) {\n            return new PingMessage();\n        }\n    }\n\n    public static final class ReportMessageDecoder extends AbstractMessageDecoder<ReportMessage> {\n\n        public ReportMessageDecoder() {\n            super(ReportMessage.class, 7);\n        }\n\n        public ReportMessage decode(ByteBuf buffer, int length) {\n            long reportedHash = buffer.readLong();\n            byte reasonCode = buffer.readByte();\n            return new ReportMessage(reportedHash, reasonCode);\n        }\n    }\n\n    public static final class SleepwordMessageDecoder extends AbstractMessageDecoder<SleepwordMessage> {\n\n        public SleepwordMessageDecoder() {\n            super(SleepwordMessage.class, 200);\n        }\n\n        public SleepwordMessage decode(ByteBuf buffer, int length) {\n            throw new UnsupportedOperationException(\"No packet with opcode 200 in client\");\n        }\n    }\n\n    public static final class TrapMessageDecoder extends AbstractMessageDecoder<TrapMessage> {\n\n        public TrapMessageDecoder() {\n            super(TrapMessage.class, 3);\n        }\n\n        public TrapMessage decode(ByteBuf buffer, int length) {\n            throw new UnsupportedOperationException(\"No packet with opcode 3 in client\");\n        }\n    }\n}\n", "ager;\nimport org.apache.logging.log4j.Logger;\nimport ru.otus.kirillov.cacheengine.Cache;\n\nimport java.util.Comparator;\n\n/**\n * \u0420\u0435\u0430\u043b\u0438\u0437\u0430\u0446\u0438\u044f \u043f\u043e\u043b\u0438\u0442\u0438\u043a\u0438 LRU \u0434\u043b\u044f \u0432\u044b\u0442\u0435\u0441\u043d\u0435\u043d\u0438\u044f \u0434\u0430\u043d\u043d\u044b\u0445 \u0438\u0437 \u043a\u044d\u0448\u0430\n * <p>\n * Created by \u0410\u043b\u0435\u043a\u0441\u0430\u043d\u0434\u0440 on 07.02.2018.\n */\npublic class LruEvictionCommand extends MaxCacheSizeEvictionCommand {\n\n    private static final Logger LOGGER = LogManager.getLogger();\n\n    private double reductionFactor;\n\n    public LruEvictionCommand(Cache<?, ?> cache, int maxCacheSize, double reductionFactor) {\n        super(cache, maxCacheSize);\n        this.reductionFactor = reductionFactor;\n    }\n\n    @Override\n    public void execute() {\n        int currentCacheSize = getCache().size();\n        int maxCacheSize = getMaxCacheSize();\n\n        if (maxCacheSize > currentCacheSize) {\n            LOGGER.debug(\"New cache size {} must be less than current cache size {}\",\n                    maxCacheSize, currentCacheSize);\n            return;\n        }\n\n        int newCacheSize = (int) (currentCacheSize * reductionFactor);\n\n        if (newCacheSize < 0 || newCacheSize >= currentCacheSize) {\n            throw new IllegalStateException(\n                    String.format(\"Wrong new cache size = %d, old cache size = %d\", newCacheSize, currentCacheSize)\n            );\n        }\n\n        LOGGER.info(\"Start to eviction by LRU-policy. With params max cache size = {}, \" +\n                        \"current cache size = {}, reduction factor = {}, new cache size = {}\", maxCacheSize, currentCacheSize,\n                reductionFactor, newCacheSize);\n\n        getCache().entrySet().stream()\n                .sorted(Comparator.comparing(p -> p.getValue().getLastAccessTime()))\n                .limit(currentCacheSize - newCacheSize)\n                .forEach(p -> ((Cache) getCache()).remove(p.getKey()));\n        LOGGER.info(\"Eviction success!\");\n    }\n}\n", "import react.client.ExternalComponent;\nimport react.client.ReactClass;\n\nimport javax.inject.Inject;\nimport javax.inject.Singleton;\n\n@Singleton\npublic class ReactSelectAsync extends ExternalComponent<ReactSelectAsync.Props> {\n    @Inject\n    public ReactSelectAsync() {\n    }\n\n    @Override\n    protected native ReactClass getReactClass() /*-{\n        return $wnd.Camber.ReactSelectAsync;\n    }-*/;\n\n    @JsType(isNative = true)\n    public interface Props extends BaseProps {\n        // todo\n    }\n}\n", " beacon's characteristics (battery level, broadcasting power, advertising interval, software and hardware version)\n */\npublic class BeaconCharacteristics\n{\n\tprivate final String BeaconUUID;\n\tprivate final int BeaconMajor;\n\tprivate final int BeaconMinor;\n\tprivate final int BeaconPowerValue;\n\tprivate final int BeaconBroadcastInterval;\n\tprivate final String BeaconName;\n\tprivate final int BeaconMfgr;\n\tprivate final int BeaconTxPower;\n\tprivate final int BeaconState;\n\tprivate final int BeaconAudioState;\n\t\n\n\tpublic BeaconCharacteristics(JaaleeService JLService, BeaconNameService Name, BeaconTxPower txPower, BeaconStateService state, BeaconAudioService audio)\n\t{\n\t\tthis.BeaconUUID = JLService.getBeaconUUID().replaceAll(\" \", \"\");\n\t\tthis.BeaconMajor = JLService.getBeaconMajor();\n\t\tthis.BeaconMinor = JLService.getBeaconMinor();\n\t\tthis.BeaconPowerValue = JLService.getBeaconPower();\n\t\tthis.BeaconBroadcastInterval = JLService.getBeaconBroadcastInterval();\n\t\tthis.BeaconName = Name.getBeaconName().replaceAll(\" \", \"\");\n\t\tthis.BeaconMfgr = JLService.getBeaconMfgr();\n\t\tthis.BeaconTxPower = txPower.getBeaconTxPower();\n\t\tthis.BeaconState = state.getBeaconState();\n\t\tthis.BeaconAudioState = audio.getBeaconAudioState();\n\t}\n\t\n\tpublic int getBeaconTxPower()\n\t{\n\t\treturn this.BeaconTxPower;\n\t}\n\t\n\tpublic int getBeaconState()\n\t{\n\t\treturn this.BeaconState;\n\t}\n\t\n\tpublic int getBeaconAudioState()\n\t{\n\t\treturn this.BeaconAudioState;\n\t}\n\t\n\tpublic int getBeaconMfgr()\n\t{\n\t\treturn this.BeaconMfgr;\n\t}\n\n\tpublic String getBeaconUUID() {\n\t\treturn this.BeaconUUID;\n\t}\n\tpublic int getBroadcastingPower() {\n\t\treturn this.BeaconPowerValue;\n\t}\n\tpublic int getBroadcastRate() {\n\t\treturn this.BeaconBroadcastInterval;\n\t}\n\tpublic int getMajor() {\n\t\treturn this.BeaconMajor;\n\t}\n\tpublic int getMinor() {\n\t\treturn this.BeaconMinor;\n\t}\n\tpublic String getBeaconName()\n\t{\n\t\treturn this.BeaconName;\n\t}\n\n\tpublic String toString() {\n\t\treturn Objects.toStringHelper(this)\n\t\t\t\t.add(\"BeaconState\", this.BeaconState)\n\t\t\t\t.add(\"BeaconUUID\", this.BeaconUUID)\n\t\t\t\t.add(\"BeaconMajor\", this.BeaconMajor)\n\t\t\t\t.add(\"BeaconMinor\", this.BeaconMinor)\n\t\t\t\t.add(\"BeaconPowerValue\", this.BeaconPowerValue)\n\t\t\t\t.add(\"BeaconBroadcast\", this.BeaconBroadcastInterval)\n\t\t\t\t.add(\"BeaconMfgr\", this.BeaconMfgr)\n\t\t\t\t.add(\"BeaconTxPower\", this.BeaconTxPower)\n\t\t\t\t.add(\"BeaconAudioState\", this.BeaconAudioState)\n\t\t\t\t.add(\"BeaconName\", this.BeaconName).toString();\n\t}\n}\n", " template file, choose Tools | Templates\n * and open the template in the editor.\n */\n\npackage com.github.thorqin.webapi.smc;\n\nimport java.awt.Dialog;\nimport java.io.File;\nimport javax.swing.JFileChooser;\nimport javax.swing.JOptionPane;\n\n/**\n *\n * @author nuo.qin\n */\npublic class FirstDialog extends javax.swing.JDialog {\n\n\tprivate boolean isOK = false;\n\tprivate boolean isQuit = false;\n\tprivate String configFile = null;\n\t/**\n\t * Creates new form FirstDialog\n\t */\n\tpublic FirstDialog() {\n\t\tsuper((Dialog)null, true);\n\t\tinitComponents();\n\t}\n\t\n\tpublic boolean isOK() {\n\t\treturn isOK;\n\t}\n\t\n\tpublic boolean isQuit() {\n\t\treturn isQuit;\n\t}\n\t\n\tpublic String getConfigFile() {\n\t\treturn configFile;\n\t}\n\n\t/**\n\t * This method is called from within the constructor to initialize the form.\n\t * WARNING: Do NOT modify this code. The content of this method is always\n\t * regenerated by the Form Editor.\n\t */\n\t@SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        buttonNew = new javax.swing.JButton();\n        buttonOpen = new javax.swing.JButton();\n        jLabel1 = new javax.swing.JLabel();\n        jLabel2 = new javax.swing.JLabel();\n        buttonQuit = new javax.swing.JButton();\n        jLabel3 = new javax.swing.JLabel();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        setTitle(\"Web Configuration Editor\");\n        setModalityType(java.awt.Dialog.ModalityType.DOCUMENT_MODAL);\n        setResizable(false);\n\n        buttonNew.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/com/github/thorqin/webapi/smc/new.png\"))); // NOI18N\n        buttonNew.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));\n        buttonNew.setVerticalTextPosition(javax.swing.SwingConstants.BOTTOM);\n        buttonNew.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                buttonNewActionPerformed(evt);\n            }\n        });\n\n        buttonOpen.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/com/github/thorqin/webapi/smc/open.png\"))); // NOI18N\n        buttonOpen.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));\n        buttonOpen.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                buttonOpenActionPerformed(evt);\n            }\n        });\n\n        jLabel1.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n        jLabel1.setText(\"Create New Config\");\n\n        jLabel2.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n        jLabel2.setText(\"Open Exist Config\");\n\n        buttonQuit.setIcon(new javax.swing.ImageIcon(getClass().getResource(\"/com/github/thorqin/webapi/smc/quit.png\"))); // NOI18N\n        buttonQuit.setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));\n        buttonQuit.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                buttonQuitActionPerformed(evt);\n            }\n        });\n\n        jLabel3.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);\n        jLabel3.setText(\"Close This Tool\");\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(39, 39, 39)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(jLabel1, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(32, 32, 32)\n                        .addComponent(jLabel2, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(buttonNew, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)\n                        .addGap(32, 32, 32)\n                        .addComponent(buttonOpen, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)))\n                .addGap(33, 33, 33)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)\n                    .addComponent(buttonQuit, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(jLabel3, javax.swing.GroupLayout.PREFERRED_SIZE, 143, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addContainerGap(27, Short.MAX_VALUE))\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addGap(32, 32, 32)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(buttonNew, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(buttonOpen, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE)\n                    .addComponent(buttonQuit, javax.swing.GroupLayout.PREFERRED_SIZE, 126, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addComponent(jLabel2)\n                    .addComponent(jLabel1)\n                    .addComponent(jLabel3))\n                .addContainerGap(26, Short.MAX_VALUE))\n        );\n\n        pack();\n        setLocationRelativeTo(null);\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void buttonNewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonNewActionPerformed\n        isOK = true;\n\t\tconfigFile = null;\n\t\tthis.dispose();\n    }//GEN-LAST:event_buttonNewActionPerformed\n\n    private void buttonOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonOpenActionPerformed\n\t\tJFileChooser fileChooser = new JFileChooser();\n\t\tFileExtensionFilter filter = new FileExtensionFilter(\"Web Config\", \"config\");\n\t\tfileChooser.setFileFilter(filter);\n\t\tString path = EditorDialog.class.getProtectionDomain().getCodeSource().getLocation().getPath();\n\t\tFile dir = new File(path);\n\t\tfileChooser.setCurrentDirectory(dir);\n\t\tint result = fileChooser.showOpenDialog(null);\n\n\t\tif (result == JFileChooser.APPROVE_OPTION) {\n\t\t\tconfigFile = fileChooser.getSelectedFile().getAbsolutePath();\n\t\t\tif (fileChooser.getFileFilter().getDescription().equals(\"Web config\")) {\n\t\t\t\tif (!configFile.toLowerCase().endsWith(\".config\")) {\n\t\t\t\t\tconfigFile += \".config\";\n\t\t\t\t}\n\t\t\t}\n\t\t\tFile choosedFile = new File(configFile);\n\t\t\tif (!choosedFile.exists()) {\n\t\t\t\tJOptionPane.showMessageDialog(null, \"File not found!\", \"Error\", JOptionPane.ERROR_MESSAGE);\n\t\t\t\treturn;\n\t\t\t}\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t\tisOK = true;\n\t\tthis.dispose();\n    }//GEN-LAST:event_buttonOpenActionPerformed\n\n    private void buttonQuitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonQuitActionPerformed\n        isQuit = true;\n\t\tthis.dispose();\n    }//GEN-LAST:event_buttonQuitActionPerformed\n\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JButton buttonNew;\n    private javax.swing.JButton buttonOpen;\n    private javax.swing.JButton buttonQuit;\n    private javax.swing.JLabel jLabel1;\n    private javax.swing.JLabel jLabel2;\n    private javax.swing.JLabel jLabel3;\n    // End of variables declaration//GEN-END:variables\n}\n", "ense (see LICENSE.txt).\n */\npackage integrationTests;\n\nimport org.junit.*;\nimport org.junit.runners.*;\n\n@FixMethodOrder(MethodSorters.NAME_ASCENDING)\npublic final class UnreachableStatementsTest extends CoverageTest\n{\n   UnreachableStatements tested;\n\n   @Test\n   public void staticClassInitializerShouldHaveNoBranches()\n   {\n      assertLine(3, 1, 1, 5); // one execution for each test (the constructor), plus one for the static initializer\n   }\n\n   @Test\n   public void nonBranchingMethodWithUnreachableLines()\n   {\n      try { tested.nonBranchingMethodWithUnreachableLines(); } catch (AssertionError ignore) {}\n\n      assertLines(7, 10, 2);\n      assertLine(7, 1, 1, 1);\n      assertLine(8, 1, 1, 1);\n      assertLine(9, 1, 0, 0);\n      assertLine(10, 1, 0, 0);\n\n      findMethodData(7);\n      assertMethodLines(7, 10);\n      assertPaths(2, 1, 1); // one path for asserts on, another for asserts off\n      assertPath(4, 1);\n      assertPath(5, 0);\n   }\n\n   @Test\n   public void branchingMethodWithUnreachableLines_avoidAssertion()\n   {\n      tested.branchingMethodWithUnreachableLines(0);\n\n      assertLines(14, 20, 3);\n      assertLine(14, 1, 1, 1);\n      assertLine(15, 1, 0, 0);\n      assertLine(16, 1, 0, 0);\n      assertLine(19, 1, 1, 1);\n      assertLine(20, 1, 1, 1);\n\n      findMethodData(14);\n      assertPaths(3, 1, 1);\n   }\n\n   @Test\n   public void branchingMethodWithUnreachableLines_hitAndFailAssertion()\n   {\n      try { tested.branchingMethodWithUnreachableLines(1); } catch (AssertionError ignore) {}\n\n      // Accounts for executions from previous test.\n      assertLines(14, 20, 4);\n      assertLine(14, 1, 1, 2);\n      assertLine(15, 1, 1, 1);\n      assertLine(16, 1, 0, 0);\n\n      findMethodData(14);\n      assertPaths(3, 2, 2);\n  }\n}", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.redis.implementation;\n\nimport com.azure.core.annotation.BodyParam;\nimport com.azure.core.annotation.Delete;\nimport com.azure.core.annotation.ExpectedResponses;\nimport com.azure.core.annotation.Get;\nimport com.azure.core.annotation.HeaderParam;\nimport com.azure.core.annotation.Headers;\nimport com.azure.core.annotation.Host;\nimport com.azure.core.annotation.HostParam;\nimport com.azure.core.annotation.PathParam;\nimport com.azure.core.annotation.Put;\nimport com.azure.core.annotation.QueryParam;\nimport com.azure.core.annotation.ReturnType;\nimport com.azure.core.annotation.ServiceInterface;\nimport com.azure.core.annotation.ServiceMethod;\nimport com.azure.core.annotation.UnexpectedResponseExceptionType;\nimport com.azure.core.http.rest.PagedFlux;\nimport com.azure.core.http.rest.PagedIterable;\nimport com.azure.core.http.rest.PagedResponse;\nimport com.azure.core.http.rest.PagedResponseBase;\nimport com.azure.core.http.rest.Response;\nimport com.azure.core.http.rest.RestProxy;\nimport com.azure.core.management.exception.ManagementException;\nimport com.azure.core.util.Context;\nimport com.azure.core.util.FluxUtil;\nimport com.azure.resourcemanager.redis.fluent.PatchSchedulesClient;\nimport com.azure.resourcemanager.redis.fluent.models.RedisPatchScheduleInner;\nimport com.azure.resourcemanager.redis.models.DefaultName;\nimport com.azure.resourcemanager.redis.models.RedisPatchScheduleListResult;\nimport reactor.core.publisher.Mono;\n\n/** An instance of this class provides access to all the operations defined in PatchSchedulesClient. */\npublic final class PatchSchedulesClientImpl implements PatchSchedulesClient {\n    /** The proxy service used to perform REST calls. */\n    private final PatchSchedulesService service;\n\n    /** The service client containing this operation class. */\n    private final RedisManagementClientImpl client;\n\n    /**\n     * Initializes an instance of PatchSchedulesClientImpl.\n     *\n     * @param client the instance of the service client containing this operation class.\n     */\n    PatchSchedulesClientImpl(RedisManagementClientImpl client) {\n        this.service =\n            RestProxy.create(PatchSchedulesService.class, client.getHttpPipeline(), client.getSerializerAdapter());\n        this.client = client;\n    }\n\n    /**\n     * The interface defining all the services for RedisManagementClientPatchSchedules to be used by the proxy service\n     * to perform REST calls.\n     */\n    @Host(\"{$host}\")\n    @ServiceInterface(name = \"RedisManagementClien\")\n    private interface PatchSchedulesService {\n        @Headers({\"Content-Type: application/json\"})\n        @Get(\n            \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redis\"\n                + \"/{cacheName}/patchSchedules\")\n        @ExpectedResponses({200})\n        @UnexpectedResponseExceptionType(ManagementException.class)\n        Mono<Response<RedisPatchScheduleListResult>> listByRedisResource(\n            @HostParam(\"$host\") String endpoint,\n            @QueryParam(\"api-version\") String apiVersion,\n            @PathParam(\"subscriptionId\") String subscriptionId,\n            @PathParam(\"resourceGroupName\") String resourceGroupName,\n            @PathParam(\"cacheName\") String cacheName,\n            @HeaderParam(\"Accept\") String accept,\n            Context context);\n\n        @Headers({\"Content-Type: application/json\"})\n        @Put(\n            \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redis/{name}\"\n                + \"/patchSchedules/{default}\")\n        @ExpectedResponses({200, 201})\n        @UnexpectedResponseExceptionType(ManagementException.class)\n        Mono<Response<RedisPatchScheduleInner>> createOrUpdate(\n            @HostParam(\"$host\") String endpoint,\n            @PathParam(\"resourceGroupName\") String resourceGroupName,\n            @PathParam(\"name\") String name,\n            @PathParam(\"default\") DefaultName defaultParameter,\n            @QueryParam(\"api-version\") String apiVersion,\n            @PathParam(\"subscriptionId\") String subscriptionId,\n            @BodyParam(\"application/json\") RedisPatchScheduleInner parameters,\n            @HeaderParam(\"Accept\") String accept,\n            Context context);\n\n        @Headers({\"Content-Type: application/json\"})\n        @Delete(\n            \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redis/{name}\"\n                + \"/patchSchedules/{default}\")\n        @ExpectedResponses({200, 204})\n        @UnexpectedResponseExceptionType(ManagementException.class)\n        Mono<Response<Void>> delete(\n            @HostParam(\"$host\") String endpoint,\n            @PathParam(\"resourceGroupName\") String resourceGroupName,\n            @PathParam(\"name\") String name,\n            @PathParam(\"default\") DefaultName defaultParameter,\n            @QueryParam(\"api-version\") String apiVersion,\n            @PathParam(\"subscriptionId\") String subscriptionId,\n            @HeaderParam(\"Accept\") String accept,\n            Context context);\n\n        @Headers({\"Content-Type: application/json\"})\n        @Get(\n            \"/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Cache/redis/{name}\"\n                + \"/patchSchedules/{default}\")\n        @ExpectedResponses({200})\n        @UnexpectedResponseExceptionType(ManagementException.class)\n        Mono<Response<RedisPatchScheduleInner>> get(\n            @HostParam(\"$host\") String endpoint,\n            @PathParam(\"resourceGroupName\") String resourceGroupName,\n            @PathParam(\"name\") String name,\n            @PathParam(\"default\") DefaultName defaultParameter,\n            @QueryParam(\"api-version\") String apiVersion,\n            @PathParam(\"subscriptionId\") String subscriptionId,\n            @HeaderParam(\"Accept\") String accept,\n            Context context);\n\n        @Headers({\"Content-Type: application/json\"})\n        @Get(\"{nextLink}\")\n        @ExpectedResponses({200})\n        @UnexpectedResponseExceptionType(ManagementException.class)\n        Mono<Response<RedisPatchScheduleListResult>> listByRedisResourceNext(\n            @PathParam(value = \"nextLink\", encoded = true) String nextLink,\n            @HostParam(\"$host\") String endpoint,\n            @HeaderParam(\"Accept\") String accept,\n            Context context);\n    }\n\n    /**\n     * Gets all patch schedules in the specified redis cache (there is only one).\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param cacheName The name of the Redis cache.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return all patch schedules in the specified redis cache (there is only one) along with {@link PagedResponse} on\n     *     successful completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<PagedResponse<RedisPatchScheduleInner>> listByRedisResourceSinglePageAsync(\n        String resourceGroupName, String cacheName) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (cacheName == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter cacheName is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        return FluxUtil\n            .withContext(\n                context ->\n                    service\n                        .listByRedisResource(\n                            this.client.getEndpoint(),\n                            this.client.getApiVersion(),\n                            this.client.getSubscriptionId(),\n                            resourceGroupName,\n                            cacheName,\n                            accept,\n                            context))\n            .<PagedResponse<RedisPatchScheduleInner>>map(\n                res ->\n                    new PagedResponseBase<>(\n                        res.getRequest(),\n                        res.getStatusCode(),\n                        res.getHeaders(),\n                        res.getValue().value(),\n                        res.getValue().nextLink(),\n                        null))\n            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));\n    }\n\n    /**\n     * Gets all patch schedules in the specified redis cache (there is only one).\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param cacheName The name of the Redis cache.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return all patch schedules in the specified redis cache (there is only one) along with {@link PagedResponse} on\n     *     successful completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<PagedResponse<RedisPatchScheduleInner>> listByRedisResourceSinglePageAsync(\n        String resourceGroupName, String cacheName, Context context) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (cacheName == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter cacheName is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        context = this.client.mergeContext(context);\n        return service\n            .listByRedisResource(\n                this.client.getEndpoint(),\n                this.client.getApiVersion(),\n                this.client.getSubscriptionId(),\n                resourceGroupName,\n                cacheName,\n                accept,\n                context)\n            .map(\n                res ->\n                    new PagedResponseBase<>(\n                        res.getRequest(),\n                        res.getStatusCode(),\n                        res.getHeaders(),\n                        res.getValue().value(),\n                        res.getValue().nextLink(),\n                        null));\n    }\n\n    /**\n     * Gets all patch schedules in the specified redis cache (there is only one).\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param cacheName The name of the Redis cache.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return all patch schedules in the specified redis cache (there is only one) as paginated response with {@link\n     *     PagedFlux}.\n     */\n    @ServiceMethod(returns = ReturnType.COLLECTION)\n    public PagedFlux<RedisPatchScheduleInner> listByRedisResourceAsync(String resourceGroupName, String cacheName) {\n        return new PagedFlux<>(\n            () -> listByRedisResourceSinglePageAsync(resourceGroupName, cacheName),\n            nextLink -> listByRedisResourceNextSinglePageAsync(nextLink));\n    }\n\n    /**\n     * Gets all patch schedules in the specified redis cache (there is only one).\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param cacheName The name of the Redis cache.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return all patch schedules in the specified redis cache (there is only one) as paginated response with {@link\n     *     PagedFlux}.\n     */\n    @ServiceMethod(returns = ReturnType.COLLECTION)\n    private PagedFlux<RedisPatchScheduleInner> listByRedisResourceAsync(\n        String resourceGroupName, String cacheName, Context context) {\n        return new PagedFlux<>(\n            () -> listByRedisResourceSinglePageAsync(resourceGroupName, cacheName, context),\n            nextLink -> listByRedisResourceNextSinglePageAsync(nextLink, context));\n    }\n\n    /**\n     * Gets all patch schedules in the specified redis cache (there is only one).\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param cacheName The name of the Redis cache.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return all patch schedules in the specified redis cache (there is only one) as paginated response with {@link\n     *     PagedIterable}.\n     */\n    @ServiceMethod(returns = ReturnType.COLLECTION)\n    public PagedIterable<RedisPatchScheduleInner> listByRedisResource(String resourceGroupName, String cacheName) {\n        return new PagedIterable<>(listByRedisResourceAsync(resourceGroupName, cacheName));\n    }\n\n    /**\n     * Gets all patch schedules in the specified redis cache (there is only one).\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param cacheName The name of the Redis cache.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return all patch schedules in the specified redis cache (there is only one) as paginated response with {@link\n     *     PagedIterable}.\n     */\n    @ServiceMethod(returns = ReturnType.COLLECTION)\n    public PagedIterable<RedisPatchScheduleInner> listByRedisResource(\n        String resourceGroupName, String cacheName, Context context) {\n        return new PagedIterable<>(listByRedisResourceAsync(resourceGroupName, cacheName, context));\n    }\n\n    /**\n     * Create or replace the patching schedule for Redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the Redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param parameters Parameters to set the patching schedule for Redis cache.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return response to put/get patch schedules for Redis cache along with {@link Response} on successful completion\n     *     of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Mono<Response<RedisPatchScheduleInner>> createOrUpdateWithResponseAsync(\n        String resourceGroupName, String name, DefaultName defaultParameter, RedisPatchScheduleInner parameters) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (name == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter name is required and cannot be null.\"));\n        }\n        if (defaultParameter == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter defaultParameter is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        if (parameters == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter parameters is required and cannot be null.\"));\n        } else {\n            parameters.validate();\n        }\n        final String accept = \"application/json\";\n        return FluxUtil\n            .withContext(\n                context ->\n                    service\n                        .createOrUpdate(\n                            this.client.getEndpoint(),\n                            resourceGroupName,\n                            name,\n                            defaultParameter,\n                            this.client.getApiVersion(),\n                            this.client.getSubscriptionId(),\n                            parameters,\n                            accept,\n                            context))\n            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));\n    }\n\n    /**\n     * Create or replace the patching schedule for Redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the Redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param parameters Parameters to set the patching schedule for Redis cache.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return response to put/get patch schedules for Redis cache along with {@link Response} on successful completion\n     *     of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<Response<RedisPatchScheduleInner>> createOrUpdateWithResponseAsync(\n        String resourceGroupName,\n        String name,\n        DefaultName defaultParameter,\n        RedisPatchScheduleInner parameters,\n        Context context) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (name == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter name is required and cannot be null.\"));\n        }\n        if (defaultParameter == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter defaultParameter is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        if (parameters == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter parameters is required and cannot be null.\"));\n        } else {\n            parameters.validate();\n        }\n        final String accept = \"application/json\";\n        context = this.client.mergeContext(context);\n        return service\n            .createOrUpdate(\n                this.client.getEndpoint(),\n                resourceGroupName,\n                name,\n                defaultParameter,\n                this.client.getApiVersion(),\n                this.client.getSubscriptionId(),\n                parameters,\n                accept,\n                context);\n    }\n\n    /**\n     * Create or replace the patching schedule for Redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the Redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param parameters Parameters to set the patching schedule for Redis cache.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return response to put/get patch schedules for Redis cache on successful completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Mono<RedisPatchScheduleInner> createOrUpdateAsync(\n        String resourceGroupName, String name, DefaultName defaultParameter, RedisPatchScheduleInner parameters) {\n        return createOrUpdateWithResponseAsync(resourceGroupName, name, defaultParameter, parameters)\n            .flatMap(\n                (Response<RedisPatchScheduleInner> res) -> {\n                    if (res.getValue() != null) {\n                        return Mono.just(res.getValue());\n                    } else {\n                        return Mono.empty();\n                    }\n                });\n    }\n\n    /**\n     * Create or replace the patching schedule for Redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the Redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param parameters Parameters to set the patching schedule for Redis cache.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return response to put/get patch schedules for Redis cache.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public RedisPatchScheduleInner createOrUpdate(\n        String resourceGroupName, String name, DefaultName defaultParameter, RedisPatchScheduleInner parameters) {\n        return createOrUpdateAsync(resourceGroupName, name, defaultParameter, parameters).block();\n    }\n\n    /**\n     * Create or replace the patching schedule for Redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the Redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param parameters Parameters to set the patching schedule for Redis cache.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return response to put/get patch schedules for Redis cache along with {@link Response}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Response<RedisPatchScheduleInner> createOrUpdateWithResponse(\n        String resourceGroupName,\n        String name,\n        DefaultName defaultParameter,\n        RedisPatchScheduleInner parameters,\n        Context context) {\n        return createOrUpdateWithResponseAsync(resourceGroupName, name, defaultParameter, parameters, context).block();\n    }\n\n    /**\n     * Deletes the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the {@link Response} on successful completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Mono<Response<Void>> deleteWithResponseAsync(\n        String resourceGroupName, String name, DefaultName defaultParameter) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (name == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter name is required and cannot be null.\"));\n        }\n        if (defaultParameter == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter defaultParameter is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        return FluxUtil\n            .withContext(\n                context ->\n                    service\n                        .delete(\n                            this.client.getEndpoint(),\n                            resourceGroupName,\n                            name,\n                            defaultParameter,\n                            this.client.getApiVersion(),\n                            this.client.getSubscriptionId(),\n                            accept,\n                            context))\n            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));\n    }\n\n    /**\n     * Deletes the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the {@link Response} on successful completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<Response<Void>> deleteWithResponseAsync(\n        String resourceGroupName, String name, DefaultName defaultParameter, Context context) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (name == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter name is required and cannot be null.\"));\n        }\n        if (defaultParameter == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter defaultParameter is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        context = this.client.mergeContext(context);\n        return service\n            .delete(\n                this.client.getEndpoint(),\n                resourceGroupName,\n                name,\n                defaultParameter,\n                this.client.getApiVersion(),\n                this.client.getSubscriptionId(),\n                accept,\n                context);\n    }\n\n    /**\n     * Deletes the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return A {@link Mono} that completes when a successful response is received.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Mono<Void> deleteAsync(String resourceGroupName, String name, DefaultName defaultParameter) {\n        return deleteWithResponseAsync(resourceGroupName, name, defaultParameter)\n            .flatMap((Response<Void> res) -> Mono.empty());\n    }\n\n    /**\n     * Deletes the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public void delete(String resourceGroupName, String name, DefaultName defaultParameter) {\n        deleteAsync(resourceGroupName, name, defaultParameter).block();\n    }\n\n    /**\n     * Deletes the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the {@link Response}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Response<Void> deleteWithResponse(\n        String resourceGroupName, String name, DefaultName defaultParameter, Context context) {\n        return deleteWithResponseAsync(resourceGroupName, name, defaultParameter, context).block();\n    }\n\n    /**\n     * Gets the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the patching schedule of a redis cache along with {@link Response} on successful completion of {@link\n     *     Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Mono<Response<RedisPatchScheduleInner>> getWithResponseAsync(\n        String resourceGroupName, String name, DefaultName defaultParameter) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (name == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter name is required and cannot be null.\"));\n        }\n        if (defaultParameter == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter defaultParameter is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        return FluxUtil\n            .withContext(\n                context ->\n                    service\n                        .get(\n                            this.client.getEndpoint(),\n                            resourceGroupName,\n                            name,\n                            defaultParameter,\n                            this.client.getApiVersion(),\n                            this.client.getSubscriptionId(),\n                            accept,\n                            context))\n            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));\n    }\n\n    /**\n     * Gets the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the patching schedule of a redis cache along with {@link Response} on successful completion of {@link\n     *     Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<Response<RedisPatchScheduleInner>> getWithResponseAsync(\n        String resourceGroupName, String name, DefaultName defaultParameter, Context context) {\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        if (resourceGroupName == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\"));\n        }\n        if (name == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter name is required and cannot be null.\"));\n        }\n        if (defaultParameter == null) {\n            return Mono\n                .error(new IllegalArgumentException(\"Parameter defaultParameter is required and cannot be null.\"));\n        }\n        if (this.client.getSubscriptionId() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getSubscriptionId() is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        context = this.client.mergeContext(context);\n        return service\n            .get(\n                this.client.getEndpoint(),\n                resourceGroupName,\n                name,\n                defaultParameter,\n                this.client.getApiVersion(),\n                this.client.getSubscriptionId(),\n                accept,\n                context);\n    }\n\n    /**\n     * Gets the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the patching schedule of a redis cache on successful completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Mono<RedisPatchScheduleInner> getAsync(String resourceGroupName, String name, DefaultName defaultParameter) {\n        return getWithResponseAsync(resourceGroupName, name, defaultParameter)\n            .flatMap(\n                (Response<RedisPatchScheduleInner> res) -> {\n                    if (res.getValue() != null) {\n                        return Mono.just(res.getValue());\n                    } else {\n                        return Mono.empty();\n                    }\n                });\n    }\n\n    /**\n     * Gets the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the patching schedule of a redis cache.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public RedisPatchScheduleInner get(String resourceGroupName, String name, DefaultName defaultParameter) {\n        return getAsync(resourceGroupName, name, defaultParameter).block();\n    }\n\n    /**\n     * Gets the patching schedule of a redis cache.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param name The name of the redis cache.\n     * @param defaultParameter Default string modeled as parameter for auto generation to work correctly.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the patching schedule of a redis cache along with {@link Response}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    public Response<RedisPatchScheduleInner> getWithResponse(\n        String resourceGroupName, String name, DefaultName defaultParameter, Context context) {\n        return getWithResponseAsync(resourceGroupName, name, defaultParameter, context).block();\n    }\n\n    /**\n     * Get the next page of items.\n     *\n     * @param nextLink The nextLink parameter.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the response of list patch schedules Redis operation along with {@link PagedResponse} on successful\n     *     completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<PagedResponse<RedisPatchScheduleInner>> listByRedisResourceNextSinglePageAsync(String nextLink) {\n        if (nextLink == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter nextLink is required and cannot be null.\"));\n        }\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        return FluxUtil\n            .withContext(\n                context -> service.listByRedisResourceNext(nextLink, this.client.getEndpoint(), accept, context))\n            .<PagedResponse<RedisPatchScheduleInner>>map(\n                res ->\n                    new PagedResponseBase<>(\n                        res.getRequest(),\n                        res.getStatusCode(),\n                        res.getHeaders(),\n                        res.getValue().value(),\n                        res.getValue().nextLink(),\n                        null))\n            .contextWrite(context -> context.putAll(FluxUtil.toReactorContext(this.client.getContext()).readOnly()));\n    }\n\n    /**\n     * Get the next page of items.\n     *\n     * @param nextLink The nextLink parameter.\n     * @param context The context to associate with this operation.\n     * @throws IllegalArgumentException thrown if parameters fail the validation.\n     * @throws ManagementException thrown if the request is rejected by server.\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent.\n     * @return the response of list patch schedules Redis operation along with {@link PagedResponse} on successful\n     *     completion of {@link Mono}.\n     */\n    @ServiceMethod(returns = ReturnType.SINGLE)\n    private Mono<PagedResponse<RedisPatchScheduleInner>> listByRedisResourceNextSinglePageAsync(\n        String nextLink, Context context) {\n        if (nextLink == null) {\n            return Mono.error(new IllegalArgumentException(\"Parameter nextLink is required and cannot be null.\"));\n        }\n        if (this.client.getEndpoint() == null) {\n            return Mono\n                .error(\n                    new IllegalArgumentException(\n                        \"Parameter this.client.getEndpoint() is required and cannot be null.\"));\n        }\n        final String accept = \"application/json\";\n        context = this.client.mergeContext(context);\n        return service\n            .listByRedisResourceNext(nextLink, this.client.getEndpoint(), accept, context)\n            .map(\n                res ->\n                    new PagedResponseBase<>(\n                        res.getRequest(),\n                        res.getStatusCode(),\n                        res.getHeaders(),\n                        res.getValue().value(),\n                        res.getValue().nextLink(),\n                        null));\n    }\n}\n", "", " Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage nl.igorski.lib.ui.helpers;\n\nimport android.graphics.Point;\nimport nl.igorski.lib.ui.interfaces.ICacheableSprite;\n\n/**\n * Created with IntelliJ IDEA.\n * User: igorzinken\n * Date: 16-08-14\n * Time: 09:28\n * To change this template use File | Settings | File Templates.\n *\n * BitmapCacher can be used for AnimatedSprites whose draw method\n * uses custom graphics / Bitmap layering to render its contents.\n * Instead of redrawing the same value upon each render cycle, this\n * class can aid in creating a cached Bitmap during the first render\n * which can be used for subsequent renders to greatly free CPU resources\n */\npublic final class BitmapCacher\n{\n    /**\n     * prior to caching a Bitmap, the sprite must be prepared\n     * which basically restores its offset to a 0,0 coordinate\n     * allowing the temporary canvas to occupy less memory as\n     * a smaller area can be reserved\n     *\n     * @param {ICacheableSprite} sprite\n     * @return {Point} holding the original sprite coordinates\n     */\n    public static Point prepare( ICacheableSprite sprite )\n    {\n        final Point out = new Point( sprite.getXPos(), sprite.getYPos() );\n\n        sprite.setXPos( 0 );\n        sprite.setYPos( 0 );\n\n        return out;\n    }\n\n    /**\n     * after the caching operation completed, this method must\n     * be invoked to restore the given sprites original position\n     *\n     * @param {ICacheableSprite} sprite\n     * @param {Point} originalCoords cached by the prepare method\n     */\n    public static void restore( ICacheableSprite sprite, Point originalCoords )\n    {\n        sprite.setXPos( originalCoords.x );\n        sprite.setYPos( originalCoords.y );\n    }\n}\n", "/\npublic class HttpResponse extends HttpMessage {\n\n\n    private String statusCode;\n    private String reasonPhrase;\n\n\n    public HttpResponse(byte[] original, String httpVersion, List<HttpHeader> headers, String body, String statusCode, String reasonPhrase) {\n\n        super(original, httpVersion, headers, body);\n        this.statusCode = statusCode;\n        this.reasonPhrase = reasonPhrase;\n\n    }\n\n\n    public String getStatusCode() {\n\n        return statusCode;\n\n    }\n\n\n    public void setStatusCode(String statusCode) {\n\n        this.statusCode = statusCode;\n\n    }\n\n\n    public String getReasonPhrase() {\n\n        return reasonPhrase;\n\n    }\n\n\n    public void setReasonPhrase(String reasonPhrase) {\n\n        this.reasonPhrase = reasonPhrase;\n\n    }\n\n\n    @Override\n    public String toString() {\n\n        StringBuilder sb = new StringBuilder()\n                .append(httpVersion)\n                .append(\" \")\n                .append(statusCode)\n                .append(\" \")\n                .append(reasonPhrase)\n                .append(\"\\r\\n\");\n        for (HttpHeader header : headers)\n            sb.append(header.getKey())\n                    .append(\": \")\n                    .append(header.getValue())\n                    .append(\"\\r\\n\");\n        sb.append(\"\\r\\n\")\n                .append(body);\n\n        return sb.toString();\n\n    }\n\n\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.notificationhubs.models;\n\nimport com.azure.core.util.ExpandableStringEnum;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport java.util.Collection;\n\n/** Defines values for SkuName. */\npublic final class SkuName extends ExpandableStringEnum<SkuName> {\n    /** Static value Free for SkuName. */\n    public static final SkuName FREE = fromString(\"Free\");\n\n    /** Static value Basic for SkuName. */\n    public static final SkuName BASIC = fromString(\"Basic\");\n\n    /** Static value Standard for SkuName. */\n    public static final SkuName STANDARD = fromString(\"Standard\");\n\n    /**\n     * Creates or finds a SkuName from its string representation.\n     *\n     * @param name a name to look for.\n     * @return the corresponding SkuName.\n     */\n    @JsonCreator\n    public static SkuName fromString(String name) {\n        return fromString(name, SkuName.class);\n    }\n\n    /** @return known SkuName values. */\n    public static Collection<SkuName> values() {\n        return values(SkuName.class);\n    }\n}\n", "nstraints;\nimport java.awt.GridBagLayout;\nimport java.awt.GridLayout;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.KeyListener;\nimport java.sql.Connection;\nimport java.sql.DriverManager;\nimport java.sql.ResultSet;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.text.DecimalFormat;\n\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JOptionPane;\nimport javax.swing.JPanel;\nimport javax.swing.JScrollPane;\nimport javax.swing.JTable;\nimport javax.swing.JTextField;\nimport javax.swing.table.DefaultTableCellRenderer;\nimport javax.swing.table.DefaultTableModel;\nimport javax.swing.table.TableColumn;\n\npublic class Items {\n\t\n    static Connection conn = null;\n    static JLabel lItem, lPrice, lDisPercentage;\n    static JTextField tfItem, tfPrice, tfDisPercentage;\n    static JButton addItem, removeItem, refresh;\n    static Object[][] dataResult;\n    static Object[] columns = {\"\",\"Item\", \"Quantity\",\n        \"Price\", \"Total Price\", \"Discount\",\n        \"Price After Discount\", \"Total Price After Discount\"};\n    \n    static DefaultTableModel dTableModel = \n            new DefaultTableModel(dataResult, columns) {\n                \n        public Class getColumnClass(int column){\n            Class returnValue;            \n\t\n            if((column >= 0) && (column < getColumnCount())) \n                returnValue = getValueAt(0, column).getClass();\n            else \n                returnValue = Object.class;\n            return returnValue;\n        }\n\t\n        public boolean isCellEditable(int row, int column) {\n            if(column == 0 || column == 1 || \n                    column == 2 || column == 4 || \n                    column == 6 || column == 7)\n                return false;\n            return true;\n        }\n    };\n\n    public static JTable itemTable = new JTable(dTableModel);\n\n    public static JScrollPane itemPanel() {\n        \n        loadData();\t\n        \n        itemTable.setAutoCreateRowSorter(true);\n        itemTable.setRowHeight(itemTable.getRowHeight() + 16);\n        \n        JScrollPane itemTableSP = new JScrollPane(itemTable);        \n        TableColumn column = null;\n        \n        for(int i = 0; i < itemTable.getColumnCount(); i++) {\n            column = itemTable.getColumnModel().getColumn(i);\n            if(i == 0)\n                column.setPreferredWidth(56);\n            else\n                column.setPreferredWidth(150);\n        }\n        \n        addItem = new JButton(\"Add\");\n        removeItem = new JButton(\"Remove\");\n        refresh = new JButton(\"Refresh\");    \n        \n        addItem.setToolTipText(\"Add a new item\");\n        removeItem.setToolTipText(\"Remove selected item\");\n        refresh.setToolTipText(\"Refresh items database\");\n        \n        lItem = new JLabel(\"Item\");\n        lPrice = new JLabel(\"Price\");        \n        lDisPercentage = new JLabel(\"Discount\");              \n       \n        tfItem = new JTextField(19);\n        tfPrice = new JTextField(9);\n        tfDisPercentage = new JTextField(9);\n\t\n        JPanel mainPanel = new JPanel(new BorderLayout());\n        JPanel inputPanel = new JPanel(new GridLayout(0,1,2,2));\n        JPanel textPanel = new JPanel();\n        JPanel btmPanel1 = new JPanel();\n        JPanel btmPanel = new JPanel(new BorderLayout());\n        \n        textPanel.add(lItem);\n        textPanel.add(tfItem);\n        textPanel.add(lPrice);\n        textPanel.add(tfPrice);\n        textPanel.add(lDisPercentage);\n        textPanel.add(tfDisPercentage);\n        \n        btmPanel1.add(addItem);\n        btmPanel1.add(removeItem);\n        btmPanel1.add(refresh);\n        btmPanel.add(btmPanel1, BorderLayout.EAST);\n\t\n        inputPanel.add(textPanel);\n        inputPanel.add(btmPanel);\n        mainPanel.add(inputPanel, BorderLayout.NORTH);\n        mainPanel.add(itemTableSP, BorderLayout.CENTER);\n        JScrollPane mainPanelSP = new JScrollPane(mainPanel);\n        \n        addItem.addActionListener(new ActionListener() {\n            \n            @Override\n            public void actionPerformed(ActionEvent e) {\n                addAction();\t\n            }\n        });\n        \n        addItem.addKeyListener(new KeyListener() {\n\t\n            @Override\n            public void keyPressed(KeyEvent e) {  \n                \n                if(e.getKeyCode() == 10) {\n                    addAction();\n                }\n            }\n            \n            @Override\n            public void keyReleased(KeyEvent arg0) {\n            \n            }\n            \n            @Override\n            public void keyTyped(KeyEvent arg0) {\n            }\n        });\n        \n        removeItem.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                removeAction();\n            }\n        });\n\n        refresh.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                Main.infoPane.append(Main.tp, Color.BLACK,\n                        \"Loading data...\\n\");\n                double ts1 = System.currentTimeMillis();\n                dTableModel.setRowCount(1);\n                dTableModel.removeRow(0);\n                loadData();\n                double ts2 = System.currentTimeMillis();\n                double T = Double.parseDouble(\n                        new DecimalFormat(\".###\").\n                        format((ts2 - ts1) / 1000));\n                Main.infoPane.append(Main.tp,\n                        new Color(10, 100, 10),\n                        \"Data has been successfully loaded (\" \n                        + T + \" sec)\\n\");\n            }\n        });\n        \n        tfItem.addActionListener(new ActionListener() {\n            \n            @Override\n            public void actionPerformed(ActionEvent e) {\n                tfPrice.requestFocus();\n            }\n        });\n        tfPrice.addActionListener(new ActionListener() {\n\t\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                tfDisPercentage.requestFocus();\n            }\n        });\n\t\n        tfDisPercentage.addActionListener(new ActionListener() {\n\n            @Override\n            public void actionPerformed(ActionEvent e) {\n                addItem.requestFocus();\n            }\n        });\n        \n        itemTable.addKeyListener(new KeyListener() {\n            \n            @Override\n            public void keyPressed(KeyEvent e) {\n                \n                if(e.getKeyCode() == 10) {\n                    \n                    Object sItem = \n                            itemTable.getValueAt\n                            (itemTable.getSelectedRow(), 1);\n                    \n                    int sQuantity = \n                            (int) itemTable.getValueAt\n                            (itemTable.getSelectedRow(), 2);\n                    \n                    double sPrice = \n                            (double) itemTable.getValueAt\n                            (itemTable.getSelectedRow(), 3);\n                    \n                    double sTotalPrice = \n                            Double.parseDouble\n                            (new DecimalFormat(\".##\").\n                            format(sQuantity * sPrice));\n                    \n                    double sDisPercentage = \n                            (double) itemTable.getValueAt\n                            (itemTable.getSelectedRow(), 5);\n                   \n                    double sDisPrice = \n                            Double.parseDouble\n                            (new DecimalFormat(\".##\").\n                            format(sPrice * (1-sDisPercentage)));\n                   \n                    double stotalDisPrice = \n                            Double.parseDouble\n                            (new DecimalFormat(\".##\").\n                            format(sQuantity * sDisPrice));\n                    \n                    try{\n                        Class.forName(\"com.mysql.jdbc.Driver\");\n                        String username = LogIn.username;\n                        String password = LogIn.password;\n                        String url = \"jdbc:mysql://\" + LogIn.ip \n                                + \"/inventory\";\n                        \n                        conn = DriverManager.getConnection\n                                (url, username, password);\n                        \n                        Statement stmt = conn.createStatement();\n                        \n                        String updateItem = \"UPdATE items SET quantity = \" \n                                + sQuantity + \", price = \" \n                                + sPrice + \", totalPrice = \" \n                                + sTotalPrice + \", disPercentage = \" \n                                + sDisPercentage + \", disPrice = \" \n                                + sDisPrice + \", totalDisPrice = \"\n                                + stotalDisPrice + \" WHERE itemName = '\" \n                                + sItem + \"';\";\n                        \n                        stmt.executeUpdate(updateItem);\n                        Main.infoPane.append\n                                (Main.tp, new Color(10, 100, 10), \"new \" \n                                + sItem + \"'s valuse has been updated\\n\");\n                        \n                        conn.close();\n                        stmt.close();\n                        \n                        itemTable.setValueAt\n                                (sQuantity, itemTable.getSelectedRow(), 2);\n                        \n                        itemTable.setValueAt\n                                (sPrice, itemTable.getSelectedRow(), 3);\n                        \n                        itemTable.setValueAt\n                                (sTotalPrice, itemTable.getSelectedRow(), 4);\n                       \n                        itemTable.setValueAt\n                                (sDisPercentage, itemTable.getSelectedRow(), 5);\n                        \n                        itemTable.setValueAt\n                                (sDisPrice, itemTable.getSelectedRow(), 6);\n                       \n                        itemTable.setValueAt\n                                (stotalDisPrice, itemTable.getSelectedRow(), 7);\n                        \n                        updateSumTotalDisPrice();\n                    \n                    } catch(SQLException sqlex) {\n                        sqlex.printStackTrace();\n                    } catch(ClassNotFoundException cex) {\n                        cex.printStackTrace();\n                    }\n\t\t\n                } else if(e.getKeyCode() == 127) {\n                    removeAction();\n                }\n            }\n\n            @Override\n            public void keyReleased(KeyEvent arg0) {\n            }\n            \n            @Override\n            public void keyTyped(KeyEvent arg0) {\n            }\n        });\n        \n        return mainPanelSP;\n    }\n    \n    public static void loadData() {\n    \n        Statement stmt;\n\t\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            String username = LogIn.username;\n            String password = LogIn.password;\n            String url = \"jdbc:mysql://\" + LogIn.ip + \"/inventory\";\n            conn = DriverManager.getConnection(url, username, password);\n            stmt = conn.createStatement();\n            String selectStuff = \"Select * From items;\";\n            ResultSet rset = stmt.executeQuery(selectStuff);\n\t\n            Object[] tempRow;\n            int count = 0;\n            while(rset.next()) {                \n\t\t\n                int quantity = rset.getInt(2);\n                double price = rset.getDouble(3);\n                double totalPrice = rset.getDouble(4);\n                double disPercentage = rset.getDouble(5);\n                double disPrice = rset.getDouble(6);\n                double totalDisPrice = rset.getDouble(7);\n\t\t\n                price = Double.parseDouble(                        \n                        new DecimalFormat(\".##\").\n                        format(price));\n\t\t\t\n                totalPrice = Double.parseDouble(                \n                        new DecimalFormat(\".##\").                        \n                        format(totalPrice));\n\t\t\t\n                disPercentage = Double.parseDouble(\n                        new DecimalFormat(\".##\").\n                        format(disPercentage));\n\t\t\t\n                disPrice = Double.parseDouble(\n                        new DecimalFormat(\".##\").\n                        format(disPrice));\n                        \n                totalDisPrice = Double.parseDouble(\n                        new DecimalFormat(\".##\").\n                        format(totalDisPrice));                \n\t\t\n                tempRow = \n                        new Object[]{ ++count,\n                            rset.getString(1),\n                            quantity, price,\n                            totalPrice,\n                            disPercentage,\n                            disPrice,\n                            totalDisPrice};\n                            \t\t\n                dTableModel.addRow(tempRow);\n            }\n\t\n            rset.close();\n            conn.close();\n            \n            //Center the data in the table\n            DefaultTableCellRenderer centerRenderer = \n                    new DefaultTableCellRenderer();\n            \n            centerRenderer.setHorizontalAlignment( JLabel.CENTER );\n            \n            for(int i = 0; i < itemTable.getColumnCount(); i++)\n                itemTable.getColumnModel().getColumn(i).\n                        setCellRenderer( centerRenderer );            \n\t\n        } catch (SQLException | ClassNotFoundException e) {\n            e.printStackTrace();\n\t\n        }catch(NullPointerException e2) {\n        }\n    }\n        \n    public static void addAction() {\n   \n        try{\n        \n            double sDisPercentage = \n                    Double.parseDouble(tfDisPercentage.getText());\n            \n            String sItem = tfItem.getText();\n            \n            if(sDisPercentage > 1 || sDisPercentage < 0)\n                Main.infoPane.append(Main.tp, Color.RED,\n                        \"Discount value must be between 0 & 1\\n\");\n                else {\n                int sQuantity = 0;\n                double sPrice = Double.parseDouble(tfPrice.getText());\n                double sTotalPrice = sPrice * sQuantity;\n                double sDisPrice = sPrice * (1-sDisPercentage);\n                double sTotalDisPrice = sDisPrice * sQuantity;\n                \n                int num = 0;\n                try {\n                    num = (int) itemTable.getValueAt\n                            (itemTable.getRowCount()-1, 0)+1;\n                    \n                } catch(Exception ex) {\n                    num = 1;\n                }\n\n                Object[] tempRow = \n                        new Object[]{num, sItem,\n                            sQuantity, sPrice, sTotalPrice,                           \n                            sDisPercentage, sDisPrice, sTotalDisPrice};\n                try{\n                    Class.forName(\"com.mysql.jdbc.Driver\");\n                    String username = LogIn.username;\n                    String password = LogIn.password;                        \n                    String url = \"jdbc:mysql://\" + LogIn.ip + \"/inventory\";                        \n                    conn = DriverManager.getConnection(url,\n                            username, password);\n                    Statement stmt = conn.createStatement();\n                    String itemSearch = \"SELECT * from items where \"\n                            + \"itemName = '\" + sItem.trim() + \"';\";\n                    stmt = conn.createStatement();\n                    ResultSet rset = stmt.executeQuery(itemSearch);\n                    if(rset.next())\n                        Main.infoPane.append(Main.tp, Color.RED,\n                                \"Multiple item defined.\\n\");\n                    else {\n                        String sqlQuery = \"INSERT INTO items VALUES ('\" \n                                + sItem + \"', \" + sQuantity + \", \" \n                                + sPrice + \",\" + sTotalPrice + \",\" \n                                + sDisPercentage + \", \" \n                                + sDisPrice + \", \"+ sTotalDisPrice +\");\";\n                            \n                        stmt.execute(sqlQuery);\n                        Main.infoPane.append(Main.tp, new Color(10,100,10),\n                                \"new item added to the Database (\" \n                                + sItem + \")\\n\");\n                            \n                        dTableModel.addRow(tempRow);\n                        tfItem.requestFocus();\n                    }\n                    \n                    rset.close();\n                    conn.close();\n                    stmt.close();\n                    \n                    SInvoice_NewInvoice.loadItemData();\n                    PInvoice_NewInvoice.loadItemData();\n                    \n                } catch(SQLException ex) {\n                    ex.printStackTrace();\n                    Main.infoPane.append\n                            (Main.tp, Color.RED,\n                            \"can't connect to the Database\\n\");\n                    \n                } catch(ClassNotFoundException ex) {\n                    ex.printStackTrace();\n                    Main.infoPane.append\n                            (Main.tp, Color.RED,\n                            \"can't connect to the Database\\n\");\n                } \n            }\n        } catch(NumberFormatException ex) {\n            \n            Main.infoPane.append(Main.tp, Color.RED, \"Invalid data\\n\");\n            ex.printStackTrace();\n            \n        } catch (NullPointerException ex) {\n        }\n    }\n        \n    public static void removeAction() {\n    \n        try{\n            Object temp = itemTable.getValueAt(itemTable.getSelectedRow(), 1);\n            \n            int result = \n                    JOptionPane.showConfirmDialog\n                    (null, \"Are you sure you want to \"\n                    + \"permanently delete this item?\",\n                    \"Delete Item\",JOptionPane.YES_OPTION);\n            \n            switch (result) {\n                case JOptionPane.YES_OPTION :\n                    try {\n                        Class.forName(\"com.mysql.jdbc.Driver\");\n                        \n                        String username = LogIn.username;\n                        String password = LogIn.password;\n                        \n                        String url = \n                                \"jdbc:mysql://\" + LogIn.ip + \"/inventory\";\n                        \n                        conn = DriverManager.getConnection\n                                (url, username, password);\n                        \n                        Statement stmt = conn.createStatement();\n                        \n                        String newPres = \n                                \"DELETE FROM items WHERE itemName = '\" \n                                + temp + \"';\";\n                        \n                        stmt.executeUpdate(newPres);\n                        \n                        dTableModel.removeRow(itemTable.getSelectedRow());\n                        int count = 0;\n                        \n                        for(int i = 0; i < dTableModel.getRowCount(); i++)\n                            itemTable.setValueAt(++count, i, 0);\n                        \n                        Main.infoPane.append\n                                (Main.tp, new Color(10,100,10),\n                                \"item \\\"\" + temp + \"\\\" removed\\n\");\n                        \n                        stmt.close();\n                        conn.close();\n                                                \n                        SInvoice_NewInvoice.loadItemData();\n                        PInvoice_NewInvoice.loadItemData();\n                    \n                    } catch (SQLException e1) {\n                        \n                        Main.infoPane.append\n                                (Main.tp, Color.RED,\n                                \"can't connect to the Database\\n\");\n                        \n                        e1.printStackTrace();\n                        \n                    } catch (ClassNotFoundException e1) {\n                        \n                        Main.infoPane.append\n                                (Main.tp, Color.RED,\n                                \"can't connect to the Database\\n\");\n                        \n                        e1.printStackTrace();\n                    }\n                    break;\n                    \n                case JOptionPane.NO_OPTION :\n                    break;\n                }\n        } catch(IndexOutOfBoundsException ee) {\n            Main.infoPane.append(Main.tp, Color.RED, \"No item selected\\n\");\n        }\n    }\n    \n    public static void updateSumTotalDisPrice() {\n        double total = 0;\n        try {\n            Class.forName(\"com.mysql.jdbc.Driver\");\n            String username = LogIn.username;\n            String password = LogIn.password;\n            String url = \n                    \"jdbc:mysql://\" + LogIn.ip + \"/inventory\";\n            \n            conn = DriverManager.getConnection(url, username, password);\n            \n            String selectStuff =\n                    \"SELECT SUM(totalDisPrice) \"\n                    + \"AS sumTotalDisPrice FROM items;\";\n            \n            Statement stmt = conn.createStatement();\n            ResultSet rset = stmt.executeQuery(selectStuff);\n            \n            while(rset.next())\n                total = rset.getDouble(1);\n            \n        }catch (SQLException ex) {\n            ex.printStackTrace();\n        } catch (ClassNotFoundException ex) {\n            ex.printStackTrace();\n        }\n        total = Double.parseDouble( new DecimalFormat(\".##\").format(total));\n        Main.statusBar.setText(\"Database\", \"items\", \"\" + total);\n    }\n}\n", "l.List;\n\nimport at.ac.tuwien.big.xmlintelledit.intelledit.scope.helper.GetFunc;\nimport at.ac.tuwien.big.xmlintelledit.intelledit.transfer.ETransferrable;\nimport at.ac.tuwien.big.xmlintelledit.intelledit.transfer.EcoreTransferFunction;\n\npublic class DynamicEqualProbabilityScope<T> implements ValueScope<T,Boolean>{\n\t\n\tprivate GetFunc<? extends List<T>> t;\n\t\n\tprivate DynamicEqualProbabilityScope(GetFunc<? extends List<T>> t) {\n\t\tthis.t = t;\n\t}\n\t\n\tpublic static<T> DynamicEqualProbabilityScope<T> fromList(GetFunc<? extends List<T>> listf) {\n\t\treturn new DynamicEqualProbabilityScope<>(listf);\n\t}\n\t\n\tprivate List<T> t() {\n\t\treturn t.get();\n\t}\n\n\t@Override\n\tpublic boolean contains(T sol) {\n\t\treturn t().contains(sol);\n\t}\n\n\t@Override\n\tpublic Boolean getQuality(T sol) {\n\t\treturn t().contains(sol);\n\t}\n\n\t@Override\n\tpublic Iterator<T> iterator() {\n\t\treturn t().iterator();\n\t}\n\n\t@Override\n\tpublic boolean isFinite() {\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic Iterator<T> sample() {\n\t\treturn new EqualProbabilitySampler<T>(t());\n\t}\n\n\t@Override\n\tpublic void transfer(EcoreTransferFunction transferFunc) {\n\t\tt = (GetFunc<? extends List<T>>) ETransferrable.transfer(t, transferFunc);\n\t}\n\n\n\n}\n\n", "word based key for use with PBKDF1 as defined in PKCS#5.\n */\npublic class PBKDF1Key\n    implements PBKDFKey\n{\n    private final char[] password;\n    private final CharToByteConverter converter;\n\n    /**\n     * Basic constructor for a password based key with generation parameters for PBKDF1.\n     *\n     * @param password password to use.\n     * @param converter the converter to use to turn the char array into octets.\n     */\n    public PBKDF1Key(char[] password, CharToByteConverter converter)\n    {\n        this.password = new char[password.length];\n        this.converter = converter;\n\n        System.arraycopy(password, 0, this.password, 0, password.length);\n    }\n\n    /**\n     * Return a reference to the char[] array holding the password.\n     *\n     * @return a reference to the password array.\n     */\n    public char[] getPassword()\n    {\n        return password;\n    }\n\n    /**\n     * Return the password based key derivation function this key is for,\n     *\n     * @return the string \"PBKDF1\"\n     */\n    public String getAlgorithm()\n    {\n        return \"PBKDF1\";\n    }\n\n    /**\n     * Return the format encoding.\n     *\n     * @return the type name representing a char[] to byte[] conversion.\n     */\n    public String getFormat()\n    {\n        return converter.getType();\n    }\n\n    /**\n     * Return the password converted to bytes.\n     *\n     * @return the password converted to a byte array.\n     */\n    public byte[] getEncoded()\n    {\n        return converter.convert(password);\n    }\n}\n", "s.service.TwitterService;\n\n/**\n * Created by crpoon on 2017-03-19.\n */\npublic class InstagramServer {\n\n    private static final long THREAD_SLEEP_TIME = 15000;\n\n    private static InstagramServer instance;\n    private static InstagramService service;\n\n    private InstagramServer() {\n        service = InstagramService.getInstance();\n    }\n\n    public static InstagramServer getInstance() {\n        if (instance == null) {\n            instance = new InstagramServer();\n        }\n        return instance;\n    }\n\n    public void start() {\n        Thread selfiesThread = createThread(\"Selfies\");\n        Thread blessedThread = createThread(\"Blessed\");\n        Thread igersThread = createThread(\"Igers\");\n        Thread nofilterThread = createThread(\"No_Filter\");\n\n        selfiesThread.start();\n        blessedThread.start();\n        igersThread.start();\n        nofilterThread.start();\n    }\n\n    public Thread createThread(String name){\n        return new Thread(new Runnable() {\n            @Override\n            public void run() {\n                while (true) {\n                    try {\n                        service.calculateAndPersistStock(name);\n                        Thread.sleep(THREAD_SLEEP_TIME);\n                    } catch (InterruptedException e) {\n                        // TODO: Handle this better\n                        System.out.println(\"rip\");\n                    }\n                }\n            }\n        });\n    }\n}\n", "se;\nimport com.linecorp.armeria.server.Server;\nimport com.linecorp.armeria.server.brave.BraveService;\nimport com.linecorp.armeria.server.healthcheck.HealthCheckService;\nimport com.linecorp.armeria.server.logging.LoggingService;\nimport java.util.Date;\n\npublic final class Backend {\n\n  public static void main(String[] args) {\n    final HttpTracing httpTracing = HttpTracingFactory.create(\"backend\");\n\n    final Server server = Server.builder()\n        .http(9000)\n        .service(\"/health\", HealthCheckService.builder().build())\n        .service(\"/api\", (ctx, req) -> {\n          String response = new Date().toString();\n          String username = req.headers().get(\"user_name\");\n          if (username != null) response += \" \" + username;\n          return HttpResponse.of(response);\n        })\n        .decorator(BraveService.newDecorator(httpTracing))\n        .decorator(LoggingService.newDecorator())\n        .build();\n\n    server.start().join();\n  }\n}\n", "CE: ac70bu\n * MODEL: Archos 70 Carbon\n */\nfinal class ac70bu_archos207020carbon {\n    public static final String DATA = \"Archos|Bush MyTablet 7|\";\n}\n", "ee of charge, to any person obtaining\n a copy of this software and associated documentation files (the\n \"Software\"), to deal in the Software without restriction, including\n without limitation the rights to use, copy, modify, merge, publish,\n distribute, sublicense, and/or sell copies of the Software, and to\n permit persons to whom the Software is furnished to do so, subject to\n the following conditions:\n\n The above copyright notice and this permission notice shall be\n included in all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\npackage com.pholser.junit.quickcheck.generator.java.lang;\n\nimport static com.pholser.junit.quickcheck.Generating.verifyBytes;\nimport static java.util.Arrays.asList;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.when;\n\nimport com.pholser.junit.quickcheck.Generating;\nimport com.pholser.junit.quickcheck.generator.BasicGeneratorPropertyParameterTest;\nimport java.util.List;\n\npublic class WrapperBytePropertyParameterTest\n    extends BasicGeneratorPropertyParameterTest {\n\n    public static final Byte TYPE_BEARER = null;\n\n    @Override protected void primeSourceOfRandomness() {\n        when(Generating.bytes(randomForParameterGenerator))\n            .thenReturn((byte) -95)\n            .thenReturn((byte) -94)\n            .thenReturn((byte) -93)\n            .thenReturn((byte) -92);\n    }\n\n    @Override protected int trials() {\n        return 4;\n    }\n\n    @Override protected List<?> randomValues() {\n        byte b = (byte) 0xA1;\n        return asList(b++, b++, b++, b);\n    }\n\n    @Override public void verifyInteractionWithRandomness() {\n        verifyBytes(randomForParameterGenerator, times(4));\n    }\n}\n", "mport com.viesis.viescraft.network.packet.MessageBase;\n\nimport io.netty.buffer.ByteBuf;\nimport net.minecraft.entity.player.EntityPlayer;\n\npublic class MessageConfig extends MessageBase<MessageConfig> {\n\t\n\t@Override\n\tpublic void fromBytes(ByteBuf buf) \n\t{\n\t\tViesCraftConfig.v1AirshipSpeed = buf.readInt();\n\t\tViesCraftConfig.v2AirshipSpeed = buf.readInt();\n\t\tViesCraftConfig.v3AirshipSpeed = buf.readInt();\n\t\tViesCraftConfig.v4AirshipSpeed = buf.readInt();\n\t\t\n\t\tViesCraftConfig.recipeBookAddAll = buf.readBoolean();\n\t\t\n\t\tViesCraftConfig.viesolineBurnTime = buf.readInt();\n\t\tViesCraftConfig.vanillaFuel = buf.readBoolean();\n\t\tViesCraftConfig.outsideModFuel = buf.readBoolean();\n\t}\n\t\n\t@Override\n\tpublic void toBytes(ByteBuf buf) \n\t{\n\t\tbuf.writeInt(ViesCraftConfig.v1AirshipSpeed);\n\t\tbuf.writeInt(ViesCraftConfig.v2AirshipSpeed);\n\t\tbuf.writeInt(ViesCraftConfig.v3AirshipSpeed);\n\t\tbuf.writeInt(ViesCraftConfig.v4AirshipSpeed);\n\t\t\n\t\tbuf.writeBoolean(ViesCraftConfig.recipeBookAddAll);\n\t\t\n\t\tbuf.writeInt(ViesCraftConfig.viesolineBurnTime);\n\t\tbuf.writeBoolean(ViesCraftConfig.vanillaFuel);\n\t\tbuf.writeBoolean(ViesCraftConfig.outsideModFuel);\n\t}\n\t\n\t@Override\n\tpublic void handleClientSide(MessageConfig message, EntityPlayer player) \n\t{\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void handleServerSide(MessageConfig message, EntityPlayer player) \n\t{\n\t\t\n\t}\n}\n", "ee AUTHORS)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage org.ta4j.core.trading.rules;\n\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.ta4j.core.Rule;\n\nimport static org.junit.Assert.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class AndRuleTest {\n\n    private Rule satisfiedRule;\n    private Rule unsatisfiedRule;\n    \n    @Before\n    public void setUp() {\n        satisfiedRule = new BooleanRule(true);\n        unsatisfiedRule = new BooleanRule(false);\n    }\n    \n    @Test\n    public void isSatisfied() {\n        assertFalse(satisfiedRule.and(BooleanRule.FALSE).isSatisfied(0));\n        assertFalse(BooleanRule.FALSE.and(satisfiedRule).isSatisfied(0));\n        assertFalse(unsatisfiedRule.and(BooleanRule.FALSE).isSatisfied(0));\n        assertFalse(BooleanRule.FALSE.and(unsatisfiedRule).isSatisfied(0));\n        \n        assertTrue(satisfiedRule.and(BooleanRule.TRUE).isSatisfied(10));\n        assertTrue(BooleanRule.TRUE.and(satisfiedRule).isSatisfied(10));\n        assertFalse(unsatisfiedRule.and(BooleanRule.TRUE).isSatisfied(10));\n        assertFalse(BooleanRule.TRUE.and(unsatisfiedRule).isSatisfied(10));\n    }\n}\n        \n", "is template file, choose Tools | Templates\r\n * and open the template in the editor.\r\n */\r\npackage personalized.job.matcher;\r\n\r\nimport java.awt.*;\r\nimport javax.swing.*;\r\nimport java.awt.event.*;\r\n/**\r\n *\r\n * @author ckk5093\r\n */\r\npublic class JobFrame extends JFrame{\r\n    \r\n    public JobFrame()\r\n    {\r\n        \r\n    }\r\n}\r\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.net;\n\nimport java.net.InetAddress;\nimport java.io.FileDescriptor;\nimport java.io.IOException;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport sun.security.action.GetPropertyAction;\n\n/**\n * Defines static methods to be invoked prior to binding or connecting TCP sockets.\n */\n\npublic final class NetHooks {\n\n    /**\n     * A provider with hooks to allow sockets be converted prior to binding or\n     * connecting a TCP socket.\n     *\n     * <p> Concrete implementations of this class should define a zero-argument\n     * constructor and implement the abstract methods specified below.\n     */\n    public static abstract class Provider {\n        /**\n         * Initializes a new instance of this class.\n         */\n        protected Provider() {}\n\n        /**\n         * Invoked prior to binding a TCP socket.\n         */\n        public abstract void implBeforeTcpBind(FileDescriptor fdObj,\n                                               InetAddress address,\n                                               int port)\n            throws IOException;\n\n        /**\n         * Invoked prior to connecting an unbound TCP socket.\n         */\n        public abstract void implBeforeTcpConnect(FileDescriptor fdObj,\n                                                 InetAddress address,\n                                                 int port)\n            throws IOException;\n    }\n\n    /**\n     * For now, we load the SDP provider on Solaris. In the future this may\n     * be changed to use the ServiceLoader facility to allow the deployment of\n     * other providers.\n     */\n    private static final Provider provider = new sun.net.sdp.SdpProvider();\n\n    /**\n     * Invoke prior to binding a TCP socket.\n     */\n    public static void beforeTcpBind(FileDescriptor fdObj,\n                                     InetAddress address,\n                                     int port)\n        throws IOException\n    {\n        provider.implBeforeTcpBind(fdObj, address, port);\n    }\n\n    /**\n     * Invoke prior to connecting an unbound TCP socket.\n     */\n    public static void beforeTcpConnect(FileDescriptor fdObj,\n                                        InetAddress address,\n                                        int port)\n        throws IOException\n    {\n        provider.implBeforeTcpConnect(fdObj, address, port);\n    }\n}\n", "mport org.apache.commons.lang3.builder.ToStringStyle;\nimport org.springframework.data.jpa.domain.AbstractPersistable;\nimport org.springframework.security.core.CredentialsContainer;\nimport org.springframework.security.core.GrantedAuthority;\nimport org.springframework.security.core.authority.SimpleGrantedAuthority;\nimport org.springframework.security.core.userdetails.UserDetails;\n\nimport javax.persistence.CascadeType;\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.FetchType;\nimport javax.persistence.OneToMany;\nimport javax.validation.Valid;\nimport javax.validation.constraints.NotNull;\nimport javax.validation.constraints.Size;\nimport java.util.Collection;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Function;\nimport java.util.stream.Collectors;\n\n/**\n * User entity.\n */\n@Entity\npublic class User extends AbstractPersistable<Long> implements UserDetails, CredentialsContainer {\n\n    @NotNull\n    @Size(min = 3, max = 30)\n    @Column(unique = true, length = 30, nullable = false)\n    private String username;\n\n    @NotNull\n    @Size(min = 5, max = 100)\n    @Column(length = 100, nullable = false)\n    private String password;\n\n    @NotNull\n    @Size(min = 1, max = 50)\n    @Column(length = 50, nullable = false)\n    private String firstName;\n\n    @NotNull\n    @Size(min = 1, max = 50)\n    @Column(length = 50, nullable = false)\n    private String lastName;\n\n    @NotNull\n    @Column(nullable = false)\n    private boolean active = true;\n\n    @NotNull\n    @Valid\n    @OneToMany( fetch = FetchType.EAGER, cascade = CascadeType.REFRESH )\n    private Set<Role> roles = new HashSet<> ();\n\n    @SuppressWarnings ( \"unused\" )\n    public User () {\n    }\n\n    public User ( String username, String password, String firstName, String lastName, Set<Role> roles, boolean active ) {\n        this.username = username;\n        this.password = password;\n        this.firstName = firstName;\n        this.lastName = lastName;\n        this.roles = roles;\n        this.active = active;\n    }\n\n    @Override\n    public Collection<? extends GrantedAuthority> getAuthorities () {\n        return roles\n                .stream ()\n                .map ( (Function<Role, GrantedAuthority>) role -> new SimpleGrantedAuthority ( \"ROLE_\" + role.getName () ) )\n                .collect( Collectors.toSet());\n\n    }\n\n    @Override\n    public String getPassword () {\n        return password;\n    }\n\n    public String getUsername () {\n        return username;\n    }\n\n    @Override\n    public boolean isAccountNonExpired () {\n        return true;\n    }\n\n    @Override\n    public boolean isAccountNonLocked () {\n        return true;\n    }\n\n    @Override\n    public boolean isCredentialsNonExpired () {\n        return true;\n    }\n\n    @Override\n    public boolean isEnabled () {\n        return this.active;\n    }\n\n    @Override\n    public void eraseCredentials () {\n        this.password = null;\n    }\n\n    public String getFirstName () {\n        return firstName;\n    }\n\n    public String getLastName () {\n        return lastName;\n    }\n\n    public Set<Role> getRoles () {\n        return roles;\n    }\n\n    public void setUsername ( String username ) {\n        this.username = username;\n    }\n\n    public void setPassword ( String password ) {\n        this.password = password;\n    }\n\n    public void setFirstName ( String firstName ) {\n        this.firstName = firstName;\n    }\n\n    public void setLastName ( String lastName ) {\n        this.lastName = lastName;\n    }\n\n    public void setActive ( boolean active ) {\n        this.active = active;\n    }\n\n    public void setRoles ( Set<Role> roles ) {\n        this.roles = roles;\n    }\n\n    @Override\n    public String toString () {\n        return new ToStringBuilder ( this, ToStringStyle.SIMPLE_STYLE )\n                .appendSuper ( super.toString () )\n                .append ( \"username\", username )\n                .append ( \"firstName\", firstName )\n                .append ( \"lastName\", lastName )\n                .append ( \"roles\", roles )\n                .append ( \"active\", active )\n                .toString ();\n    }\n\n}\n", "der;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.giscafer.physicaltable.Constant.ConfigConstant;\nimport com.jfinal.aop.Interceptor;\nimport com.jfinal.aop.Invocation;\nimport com.jfinal.render.RedirectRender;\n\n/**\n * \u8ba4\u8bc1\u62e6\u622a\u5668\n * @author champ\n */\npublic class AuthInterceptor implements Interceptor {\n\tprivate static Logger authlogger=LoggerFactory.getLogger(AuthInterceptor.class);\n\t@Override\n\tpublic void intercept(Invocation inv) {\n\t\tauthlogger.info(\"Before method invoking\");\n\t\tObject login=inv.getController().getSession().getAttribute(ConfigConstant.ISLOGIN);\n\t\t/*if((null!=login && Boolean.parseBoolean(login.toString()))){//\u5df2\u7ecf\u767b\u9646\n\t\t\trender(\"login.html\");\n\t\t}*/\n\t\tauthlogger.info(\"invoking:\"+inv.getControllerKey()+\"--\"+inv.getMethodName()+\"--\"+inv.getViewPath()+\"--\"+ToStringBuilder.reflectionToString(inv.getArgs()));\n\t\t//\u672a\u767b\u5f55\u8df3\u8f6c\n\t\tif(inv.getMethodName().equals(\"login\")||inv.getMethodName().equals(\"captcha\")||inv.getControllerKey().contains(\"register\")\n\t\t\t\t||(null!=login&&Boolean.parseBoolean(login.toString()))){\n//\t\t\t//\u4f20\u9012\u672c\u6b21\u8c03\u7528\uff0c\u8c03\u7528\u5269\u4e0b\u7684\u62e6\u622a\u5668\u4e0e\u76ee\u6807\u65b9\u6cd5 \n\t\t\tinv.invoke();\n\t\t}else{\n\t\t\tinv.getController().renderJavascript(\"<script type='text/javascript'>alert('\u60a8\u8fd8\u672a\u767b\u5f55,\u4e0d\u80fd\u6267\u884c\u6b64\u64cd\u4f5c!');</script>\");\n\t\t}\n\t\tauthlogger.info(\"After method invoking\");\n\t}\n\n}\n", "erface ApplicationScoped {}", "\npublic enum PropertiesProviderFactories {\n    FROM_SETTERS(new AskUserPropertiesProvider(DialogFactories.FROM_METHODS.get())),\n    FROM_CONSTRUCTOR_ARGS(new UseConstructorArgsPropertiesProvider(new ConstructorPropertiesAnalyzer()));\n\n    private final PropertiesProvider propertiesStrategy;\n\n    public PropertiesProvider get(){\n        return this.propertiesStrategy;\n    }\n\n    private PropertiesProviderFactories(PropertiesProvider propertiesStrategy) {\n        this.propertiesStrategy = propertiesStrategy;\n    }\n}\n", "rt android.content.Intent;\nimport android.location.Address;\nimport android.location.Location;\nimport android.location.LocationManager;\nimport android.net.Uri;\nimport android.os.Bundle;\nimport android.support.v4.app.FragmentActivity;\nimport android.support.v4.app.Fragment;\n\nimport android.widget.ArrayAdapter;\nimport android.widget.Toast;\n\nimport com.google.android.gms.maps.CameraUpdateFactory;\nimport com.google.android.gms.maps.GoogleMap;\nimport com.google.android.gms.maps.MapFragment;\nimport com.google.android.gms.maps.OnMapReadyCallback;\nimport com.google.android.gms.maps.SupportMapFragment;\nimport com.google.android.gms.maps.UiSettings;\nimport com.google.android.gms.maps.model.BitmapDescriptorFactory;\nimport com.google.android.gms.maps.model.LatLng;\nimport com.google.android.gms.maps.model.Marker;\nimport com.google.android.gms.maps.model.MarkerOptions;\nimport android.location.Geocoder;\nimport android.widget.ListView;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class MapsActivity extends FragmentActivity\n        implements OnMapReadyCallback, GoogleMap.OnMapLoadedCallback{\n\n    private GoogleMap mMap = null; // Might be null if Google Play services APK is not available.\n    private Geocoder geocoder;\n    List<Address> addressList = null;\n    double lat, lng;\n    private LatLng latLng;\n\n    ArrayList<String> vals;\n    ArrayAdapter<String> adapter;\n\n    ArrayList<artist> artistList;\n    ArrayList<Integer> paramArray;\n    StringBuffer locationName = new StringBuffer();\n\n    @Override\n    public void onMapReady(GoogleMap map) { //mapisloadedbutnotlaidoutyet\n        map.setOnMapLoadedCallback(this);\n    }\n\n    @Override\n    public void onMapLoaded() {\n    }\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.mapartist);\n        MapFragment mf = (MapFragment) getFragmentManager().findFragmentById(R.id.map);\n        mf.getMapAsync(this);\n        geocoder = new Geocoder(this);\n        Intent myCallerIntentHandler = getIntent();\n        Bundle myBundle = myCallerIntentHandler.getExtras();\n\n        paramArray = myBundle.getIntegerArrayList(\"myIntArray1\");\n        artistList = (ArrayList<artist>) myBundle.getSerializable(\"artists\");\n\n        latlongCheck(paramArray,artistList);\n\n        retrieveCities(paramArray,artistList);\n    }\n\n    public void latlongCheck(ArrayList<Integer> selected, ArrayList<artist> arts) {\n\n        vals = new ArrayList<String>();\n\n        for (int i = 0; i < selected.size(); i++) {\n            String home = arts.get(selected.get(i)).getNationality();\n            String person = arts.get(selected.get(i)).getName();\n            locationName.replace(0, locationName.length(), home);\n\n            try {\n                addressList = geocoder.getFromLocationName(locationName.toString(), 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            if (addressList != null && addressList.size() > 0) {\n                lat = (double) (addressList.get(0).getLatitude());\n                lng = (double) (addressList.get(0).getLongitude());\n            }\n        }\n    }\n\n\n    private void retrieveCities(ArrayList<Integer> selected, ArrayList<artist> arts) {\n\n        for (int i = 0; i < selected.size(); i++) {\n            String home = arts.get(selected.get(i)).getNationality();\n            String person = arts.get(selected.get(i)).getName();\n            String title = arts.get(selected.get(i)).getTitle();\n            locationName.replace(0, locationName.length(), home);\n\n            try {\n                addressList = geocoder.getFromLocationName(locationName.toString(), 1);\n            } catch (IOException e) {\n                e.printStackTrace();\n            }\n\n            if (addressList != null && addressList.size() > 0) {\n                lat = (double) (addressList.get(0).getLatitude());\n                lng = (double) (addressList.get(0).getLongitude());\n            }\n            if (mMap == null) {\n                mMap = ((MapFragment) getFragmentManager().findFragmentById(\n                        R.id.map)).getMap();\n            }\n            latLng = new LatLng(lat, lng);\n            mMap.addMarker(new MarkerOptions().position(latLng).title(person).snippet(title));\n\n        }\n    }}\n\n", ".oreilly.entities.Cubs;\nimport com.oreilly.entities.RedSox;\nimport com.oreilly.entities.BaseballGame;\n/**\n * Runs the code for the baseball games without\n * using the Spring framework.\n * \n * <p>This code directly uses the classes that are\n *    used in the Spring framework to create the beans.</p>\n * \n *\n */\npublic class RunDemoWithoutSpring {\n\tpublic static void main(String[] args) {\n\t\tTeam redSox = new RedSox();\n\t\tTeam cubs = new Cubs();\n\t\tGame game = new BaseballGame(redSox, cubs);\n\t\tfor (int i = 0; i < 4; i++) {\n\t\t\tSystem.out.println(game.playGame());\n\t\t}\n\t}\n}\n", " com.intellij.openapi.project.DumbService;\nimport com.intellij.openapi.project.Project;\nimport de.espend.idea.php.toolbox.remote.util.PersistentStorageUtil;\nimport org.jetbrains.annotations.NotNull;\n\n/**\n * @author Daniel Espendiller <daniel@espendiller.net>\n */\npublic class PhpToolboxProjectComponent implements ProjectComponent {\n\n    private Project project;\n\n    public PhpToolboxProjectComponent(@NotNull Project project) {\n        this.project = project;\n    }\n\n    @Override\n    public void projectOpened() {\n        DumbService.getInstance(project).smartInvokeLater(() -> PersistentStorageUtil.load(project));\n    }\n\n    @Override\n    public void projectClosed() {\n        PersistentStorageUtil.write(project);\n    }\n\n    @NotNull\n    @Override\n    public String getComponentName() {\n        return \"Php-Toolbox\";\n    }\n}\n", "nds ReactActivity {\n\n    /**\n     * Returns the name of the main component registered from JavaScript.\n     * This is used to schedule rendering of the component.\n     */\n    @Override\n    protected String getMainComponentName() {\n        return \"youDrawIGuess\";\n    }\n}\n", "rt java.io.UnsupportedEncodingException;\nimport java.util.Date;\n\n/**\n * Logging class to provide logging facilities to other classes Logging provides\n * output to a file based on the name passed to the constructor as well as\n * standard out;\n *\n * @author chanman\n */\npublic class Log {\n\n    String id;\n    PrintWriter out;\n\n    /**\n     * Instantiate a Log for a given name;\n     *\n     * @param id name of log\n     */\n    public Log(String id) {\n        this.id = id;\n        try {\n            String filename = id + \".txt\";\n            out = new PrintWriter(filename, \"ASCII\");\n        } catch (FileNotFoundException | UnsupportedEncodingException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    /**\n     * Log an entry with the name and date\n     *\n     * @param content content to log\n     */\n    public void log(String content) {\n        Date date = new Date();\n        out.print(\"[\" + date.toString() + \" \" + id + \"] \" + content + \"\\n\");\n        out.flush();\n        System.out.println(\"[\" + date.toString() + \" \" + id + \"] \" + content);\n    }\n}\n", "d by James Hollowell on 4/7/2015.\n */\npublic class Link\n{\n    private String url;\n    private Element context;\n\n    public Link(String url, Element context)\n    {\n        this.url = url;\n        this.context = context;\n    }\n\n    public String getUrl()\n    {\n        return url;\n    }\n\n    public Element getContext()\n    {\n        return context;\n    }\n}\n", "til.Calendar;\nimport java.util.GregorianCalendar;\nimport java.util.List;\nimport java.util.TimeZone;\n\n/**\n * Unit Tests for WeeklySchedule.\n *\n * @author roger\n */\npublic class WeeklyScheduleTest {\n    @Test\n    public void testWeeklyEveryDay() {\n        WeeklySchedule schedule = new WeeklySchedule(TimeZone.getDefault());\n        Calendar first = Calendar.getInstance(TimeZone.getDefault());\n        Calendar start = Calendar.getInstance(TimeZone.getDefault());\n\n        first.clear();\n        first.set(2013, Calendar.JANUARY, 1);\n\n        start.clear();\n        start.set(2013, Calendar.JUNE, 28);\n\n        schedule.parseSchedule(\"1-Y,Y,Y,Y,Y,Y,Y-07/02/2013\");\n        List<Calendar> dates = schedule.getDates(first, start, Integer.MAX_VALUE);\n\n        Assert.assertNotNull(dates);\n        Assert.assertEquals(5, dates.size());\n\n        for (int i = 0, day = 28, month = Calendar.JUNE; i < dates.size(); i++, day++) {\n            if (day > 30) {\n                day -= 30;\n                month++;\n            }\n\n            Assert.assertEquals(2013, dates.get(i).get(Calendar.YEAR));\n            Assert.assertEquals(month, dates.get(i).get(Calendar.MONTH));\n            Assert.assertEquals(day, dates.get(i).get(Calendar.DATE));\n        }\n    }\n\n    @Test\n    public void testBiWeeklyEveryDay() {\n        WeeklySchedule schedule = new WeeklySchedule(TimeZone.getDefault());\n        Calendar first = Calendar.getInstance(TimeZone.getDefault());\n        Calendar start = Calendar.getInstance(TimeZone.getDefault());\n\n        first.clear();\n        first.set(2013, Calendar.JANUARY, 1);\n\n        start.clear();\n        start.set(2013, Calendar.JANUARY, 6);\n\n        schedule.parseSchedule(\"2-Y,Y,Y,Y,Y,Y,Y-01/16/2013\");\n        List<Calendar> dates = schedule.getDates(first, start, Integer.MAX_VALUE);\n\n        Assert.assertNotNull(dates);\n        Assert.assertEquals(4, dates.size());\n\n        for (int i = 0, day = 13; i < dates.size(); i++, day++) {\n            Assert.assertEquals(2013, dates.get(i).get(Calendar.YEAR));\n            Assert.assertEquals(Calendar.JANUARY, dates.get(i).get(Calendar.MONTH));\n            Assert.assertEquals(day, dates.get(i).get(Calendar.DATE));\n        }\n    }\n\n    @Test\n    public void testBiWeeklySomeDays() {\n        WeeklySchedule schedule = new WeeklySchedule(TimeZone.getDefault());\n        Calendar first = Calendar.getInstance(TimeZone.getDefault());\n        Calendar start = Calendar.getInstance(TimeZone.getDefault());\n\n        first.clear();\n        first.set(2013, Calendar.JANUARY, 1);\n\n        start.clear();\n        start.set(2013, Calendar.JANUARY, 6);\n\n        schedule.parseSchedule(\"2-N,Y,N,Y,N,Y,N-01/23/2013\");\n        List<Calendar> dates = schedule.getDates(first, start, Integer.MAX_VALUE);\n\n        Assert.assertNotNull(dates);\n        Calendar[] expectedDates = {\n                new GregorianCalendar(2013, Calendar.JANUARY, 15),\n                new GregorianCalendar(2013, Calendar.JANUARY, 17),\n                new GregorianCalendar(2013, Calendar.JANUARY, 19),\n        };\n\n        Assert.assertEquals(expectedDates.length, dates.size());\n\n        for (int i = 0; i < expectedDates.length; i++) {\n            Assert.assertEquals(expectedDates[i], dates.get(i));\n        }\n    }\n}\n", "048.Game2048Frame;\n \npublic class Game2048 implements Runnable {\n \n    @Override\n    public void run() {\n        new Game2048Frame(new Game2048Model());\n    }\n     \n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(new Game2048());\n    }\n \n}", "MIT License (MIT)\n// \n// Copyright (c) 2014-2015 Keld Oelykke\n// \n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n// \n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n// \n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n//\n/////////////////////////////////////////////////////////////////////////////////////////\n\npackage starkcoder.failfast.fails.objects.enums;\n\nimport starkcoder.failfast.checks.objects.enums.IObjectEnumNotEqualsCheck;\nimport starkcoder.failfast.fails.FailFastException;\nimport starkcoder.failfast.fails.IFail;\nimport starkcoder.failfast.fails.NFail;\n\n/**\n * Fail specification throwing an exception when a not-equals check asserts.\n * \n * @author Keld Oelykke\n */\npublic interface IObjectEnumNotEqualsFail extends IFail\n{\n  /**\n   * Fails specified Enums, since they passed a not-equals check.\n   * \n   * @param caller\n   *          object calling checker and then failer (if Enum check asserted)\n   * @param referenceAName\n   *          name of reference A to fail\n   * @param referenceBName\n   *          name of reference B to fail\n   * @throws IllegalArgumentException\n   *           if caller is null\n   */\n  @NFail(failerSpecificationAndMethodId = \n      \"IObjectEnumNotEqualsFail.failEnumNotEquals(\" \n          + \"Object caller, String referenceAName, String referenceBName)\", \n      checkerSpecificationType = IObjectEnumNotEqualsCheck.class, \n      failExceptionType = FailFastException.class, \n      failMessageFormat = \"%s: Enum '%s'(%s) is NOT equal to Enum '%s'(%s).\", \n      failMessageArguments = \"fu0, fu1, cu1, fu2, cu2\")\n  void failEnumNotEquals(Object caller, String referenceAName, String referenceBName);\n\n  /**\n   * Fails specified Enums, since they passed a not-equals check.\n   * \n   * @param caller\n   *          object calling checker and then failer (if Enum check asserted)\n   * @param referenceAName\n   *          name of reference A to fail\n   * @param referenceBName\n   *          name of reference B to fail\n   * @param message\n   *          additional information\n   * @throws IllegalArgumentException\n   *           if caller is null\n   */\n  @NFail(failerSpecificationAndMethodId = \n      \"IObjectEnumNotEqualsFail.failEnumNotEquals(\" \n          + \"Object caller, String referenceAName, String referenceBName, String message)\", \n      checkerSpecificationType = IObjectEnumNotEqualsCheck.class, \n      failExceptionType = FailFastException.class, \n      failMessageFormat = \"%s: Enum '%s'(%s) is NOT equal to Enum '%s'(%s). %s.\", \n      failMessageArguments = \"fu0, fu1, cu1, fu2, cu2, fu3\")\n  void failEnumNotEquals(\n      Object caller, String referenceAName, String referenceBName, String message);\n\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.network.v2018_08_01;\n\nimport java.util.Collection;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.microsoft.rest.ExpandableStringEnum;\n\n/**\n * Defines values for ApplicationGatewaySslPolicyType.\n */\npublic final class ApplicationGatewaySslPolicyType extends ExpandableStringEnum<ApplicationGatewaySslPolicyType> {\n    /** Static value Predefined for ApplicationGatewaySslPolicyType. */\n    public static final ApplicationGatewaySslPolicyType PREDEFINED = fromString(\"Predefined\");\n\n    /** Static value Custom for ApplicationGatewaySslPolicyType. */\n    public static final ApplicationGatewaySslPolicyType CUSTOM = fromString(\"Custom\");\n\n    /**\n     * Creates or finds a ApplicationGatewaySslPolicyType from its string representation.\n     * @param name a name to look for\n     * @return the corresponding ApplicationGatewaySslPolicyType\n     */\n    @JsonCreator\n    public static ApplicationGatewaySslPolicyType fromString(String name) {\n        return fromString(name, ApplicationGatewaySslPolicyType.class);\n    }\n\n    /**\n     * @return known ApplicationGatewaySslPolicyType values\n     */\n    public static Collection<ApplicationGatewaySslPolicyType> values() {\n        return values(ApplicationGatewaySslPolicyType.class);\n    }\n}\n", "d, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage tech.madube.genericdao;\n\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\n\npublic class HibernateUtil {\n\n\tprivate SessionFactory sessionFactory;\n\tprivate static HibernateUtil instance = null;\n\tprivate SessionType sessionType = SessionType.MULTITHREADED;\n\n\t/**\n\t * Singleton\n\t */\n\tprivate HibernateUtil(){\n\n\t}\n\n\tpublic static HibernateUtil getInstance() {\n\t\tif(instance == null) {\n\t\t\tinstance = new HibernateUtil();\n\t\t}\n\t\treturn instance;\n\t}\n\n\tpublic SessionFactory getSessionFactory(){\n\t\treturn this.sessionFactory;\n\t}\n\n\tpublic void setConfiguration(Configuration configuration) {\n\t\tServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder()\n\t\t\t\t.applySettings(configuration.getProperties()).build();\n\t\tthis.sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n\t}\n\n\tpublic SessionType getSessionType() {\n\t\treturn sessionType;\n\t}\n\n\tpublic void setSessionType(SessionType sessionType) {\n\t\tthis.sessionType = sessionType;\n\t}\n}\n", "blessing:\n *\n *    May you do good and not evil.\n *    May you find forgiveness for yourself and forgive others.\n *    May you share freely, never taking more than you give.\n *\n */\npackage org.hibernate.dialect;\n\nimport java.sql.Types;\n\nimport org.hibernate.dialect.function.AbstractAnsiTrimEmulationFunction;\nimport org.hibernate.dialect.function.NoArgSQLFunction;\nimport org.hibernate.dialect.function.SQLFunction;\nimport org.hibernate.dialect.function.SQLFunctionTemplate;\nimport org.hibernate.dialect.function.StandardSQLFunction;\nimport org.hibernate.dialect.function.VarArgsSQLFunction;\nimport org.hibernate.type.StandardBasicTypes;\n\npublic class SQLiteDialect extends Dialect {\n  public SQLiteDialect() {\n    registerColumnType(Types.BIT, \"boolean\");\n    registerColumnType(Types.TINYINT, \"tinyint\");\n    registerColumnType(Types.SMALLINT, \"smallint\");\n    registerColumnType(Types.INTEGER, \"integer\");\n    registerColumnType(Types.BIGINT, \"bigint\");\n    registerColumnType(Types.FLOAT, \"float\");\n    registerColumnType(Types.REAL, \"real\");\n    registerColumnType(Types.DOUBLE, \"double\");\n    registerColumnType(Types.NUMERIC, \"numeric($p, $s)\");\n    registerColumnType(Types.DECIMAL, \"decimal\");\n    registerColumnType(Types.CHAR, \"char\");\n    registerColumnType(Types.VARCHAR, \"varchar($l)\");\n    registerColumnType(Types.LONGVARCHAR, \"longvarchar\");\n    registerColumnType(Types.DATE, \"date\");\n    registerColumnType(Types.TIME, \"time\");\n    registerColumnType(Types.TIMESTAMP, \"datetime\");\n    registerColumnType(Types.BINARY, \"blob\");\n    registerColumnType(Types.VARBINARY, \"blob\");\n    registerColumnType(Types.LONGVARBINARY, \"blob\");\n    registerColumnType(Types.BLOB, \"blob\");\n    registerColumnType(Types.CLOB, \"clob\");\n    registerColumnType(Types.BOOLEAN, \"boolean\");\n\n    //registerFunction( \"abs\", new StandardSQLFunction(\"abs\") );\n    registerFunction( \"concat\", new VarArgsSQLFunction(StandardBasicTypes.STRING, \"\", \"||\", \"\") );\n    //registerFunction( \"length\", new StandardSQLFunction(\"length\", StandardBasicTypes.LONG) );\n    //registerFunction( \"lower\", new StandardSQLFunction(\"lower\") );\n    registerFunction( \"mod\", new SQLFunctionTemplate(StandardBasicTypes.INTEGER, \"?1 % ?2\" ) );\n    registerFunction( \"quote\", new StandardSQLFunction(\"quote\", StandardBasicTypes.STRING) );\n    registerFunction( \"random\", new NoArgSQLFunction(\"random\", StandardBasicTypes.INTEGER) );\n    registerFunction( \"round\", new StandardSQLFunction(\"round\") );\n    registerFunction( \"substr\", new StandardSQLFunction(\"substr\", StandardBasicTypes.STRING) );\n    registerFunction( \"substring\", new SQLFunctionTemplate( StandardBasicTypes.STRING, \"substr(?1, ?2, ?3)\" ) );\n    registerFunction( \"trim\", new AbstractAnsiTrimEmulationFunction() {\n        protected SQLFunction resolveBothSpaceTrimFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"trim(?1)\");\n        }\n\n        protected SQLFunction resolveBothSpaceTrimFromFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"trim(?2)\");\n        }\n\n        protected SQLFunction resolveLeadingSpaceTrimFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"ltrim(?1)\");\n        }\n\n        protected SQLFunction resolveTrailingSpaceTrimFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"rtrim(?1)\");\n        }\n\n        protected SQLFunction resolveBothTrimFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"trim(?1, ?2)\");\n        }\n\n        protected SQLFunction resolveLeadingTrimFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"ltrim(?1, ?2)\");\n        }\n\n        protected SQLFunction resolveTrailingTrimFunction() {\n          return new SQLFunctionTemplate(StandardBasicTypes.STRING, \"rtrim(?1, ?2)\");\n        }\n    } );\n    //registerFunction( \"upper\", new StandardSQLFunction(\"upper\") );\n  }\n\n  public boolean supportsIdentityColumns() {\n    return true;\n  }\n\n  /*\n  public boolean supportsInsertSelectIdentity() {\n    return true; // As specify in NHibernate dialect\n  }\n  */\n\n  public boolean hasDataTypeInIdentityColumn() {\n    return false; // As specify in NHibernate dialect\n  }\n\n  /*\n  public String appendIdentitySelectToInsert(String insertString) {\n    return new StringBuffer(insertString.length()+30). // As specify in NHibernate dialect\n      append(insertString).\n      append(\"; \").append(getIdentitySelectString()).\n      toString();\n  }\n  */\n\n  public String getIdentityColumnString() {\n    // return \"integer primary key autoincrement\";\n    return \"integer\";\n  }\n\n  public String getIdentitySelectString() {\n    return \"select last_insert_rowid()\";\n  }\n\n  public boolean supportsLimit() {\n    return true;\n  }\n\n  public boolean bindLimitParametersInReverseOrder() {\n    return true;\n  }\n\n  protected String getLimitString(String query, boolean hasOffset) {\n    return new StringBuffer(query.length()+20).\n      append(query).\n      append(hasOffset ? \" limit ? offset ?\" : \" limit ?\").\n      toString();\n  }\n\n  public boolean supportsTemporaryTables() {\n    return true;\n  }\n\n  public String getCreateTemporaryTableString() {\n    return \"create temporary table if not exists\";\n  }\n\n  public boolean dropTemporaryTableAfterUse() {\n    return true; // TODO Validate\n  }\n\n  public boolean supportsCurrentTimestampSelection() {\n    return true;\n  }\n\n  public boolean isCurrentTimestampSelectStringCallable() {\n    return false;\n  }\n\n  public String getCurrentTimestampSelectString() {\n    return \"select current_timestamp\";\n  }\n\n  public boolean supportsUnionAll() {\n    return true;\n  }\n\n  public boolean hasAlterTable() {\n    return false; // As specify in NHibernate dialect\n  }\n\n  public boolean dropConstraints() {\n    return false;\n  }\n\n  /*\n  public String getAddColumnString() {\n    return \"add column\";\n  }\n  */\n\n  public String getForUpdateString() {\n    return \"\";\n  }\n\n  public boolean supportsOuterJoinForUpdate() {\n    return false;\n  }\n\n  public String getDropForeignKeyString() {\n    throw new UnsupportedOperationException(\"No drop foreign key syntax supported by SQLiteDialect\");\n  }\n\n  public String getAddForeignKeyConstraintString(String constraintName,\n      String[] foreignKey, String referencedTable, String[] primaryKey,\n      boolean referencesPrimaryKey) {\n    throw new UnsupportedOperationException(\"No add foreign key syntax supported by SQLiteDialect\");\n  }\n\n  public String getAddPrimaryKeyConstraintString(String constraintName) {\n    throw new UnsupportedOperationException(\"No add primary key syntax supported by SQLiteDialect\");\n  }\n\n  public boolean supportsIfExistsBeforeTableName() {\n    return true;\n  }\n\n  public boolean supportsCascadeDelete() {\n    return true;\n  }\n\n  /* not case insensitive for unicode characters by default (ICU extension needed)\n  public boolean supportsCaseInsensitiveLike() {\n    return true;\n  }\n  */\n\n  public boolean supportsTupleDistinctCounts() {\n    return false;\n  }\n\n  public String getSelectGUIDString() {\n    return \"select hex(randomblob(16))\";\n  }\n}", "import javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlRootElement;\nimport javax.xml.bind.annotation.XmlType;\n\n\n/**\n * <p>Java class for anonymous complex type.\n * \n * <p>The following schema fragment specifies the expected content contained within this class.\n * \n * <pre>\n * &lt;complexType>\n *   &lt;complexContent>\n *     &lt;restriction base=\"{http://www.w3.org/2001/XMLSchema}anyType\">\n *       &lt;sequence>\n *       &lt;/sequence>\n *     &lt;/restriction>\n *   &lt;/complexContent>\n * &lt;/complexType>\n * </pre>\n * \n * \n */\n@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"\")\n@XmlRootElement(name = \"DeleteUserResponse\")\npublic class DeleteUserResponse {\n\n\n}\n", "14 ObsidianBox <http://obsidianbox.org/>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.obsidianbox.magma.lang;\n\npublic enum LanguageGroups {\n    ACHIEVEMENT(\"achievement\"),\n    ATTRIBUTE(\"attribute\"),\n    COMMAND(\"commands\"),\n    ENTITY(\"entity\"),\n    ITEM(\"item\"),\n    ITEM_GROUP(\"itemGroup\"),\n    GUI(\"gui\"),\n    OPTIONS(\"options\"),\n    TILE(\"tile\");\n    private final String value;\n\n    LanguageGroups(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Returns the associated string value\n     *\n     * @return The string value\n     */\n    public String value() {\n        return value;\n    }\n}\n", "kage com.azure.messaging.eventhubs;\n\nimport static com.azure.core.util.tracing.Tracer.AZ_TRACING_NAMESPACE_KEY;\nimport static com.azure.core.util.tracing.Tracer.DIAGNOSTIC_ID_KEY;\nimport static com.azure.core.util.tracing.Tracer.ENTITY_PATH_KEY;\nimport static com.azure.core.util.tracing.Tracer.HOST_NAME_KEY;\nimport static com.azure.core.util.tracing.Tracer.MESSAGE_ENQUEUED_TIME;\nimport static com.azure.core.util.tracing.Tracer.SCOPE_KEY;\nimport static com.azure.core.util.tracing.Tracer.SPAN_CONTEXT_KEY;\nimport static com.azure.messaging.eventhubs.implementation.ClientConstants.AZ_NAMESPACE_VALUE;\nimport static com.azure.messaging.eventhubs.implementation.ClientConstants.AZ_TRACING_SERVICE_NAME;\n\nimport com.azure.core.amqp.implementation.TracerProvider;\nimport com.azure.core.util.Context;\nimport com.azure.core.util.logging.ClientLogger;\nimport com.azure.core.util.logging.LogLevel;\nimport com.azure.core.util.tracing.ProcessKind;\nimport com.azure.messaging.eventhubs.implementation.PartitionProcessor;\nimport com.azure.messaging.eventhubs.implementation.PartitionProcessorException;\nimport com.azure.messaging.eventhubs.models.Checkpoint;\nimport com.azure.messaging.eventhubs.models.CloseContext;\nimport com.azure.messaging.eventhubs.models.CloseReason;\nimport com.azure.messaging.eventhubs.models.ErrorContext;\nimport com.azure.messaging.eventhubs.models.EventBatchContext;\nimport com.azure.messaging.eventhubs.models.EventContext;\nimport com.azure.messaging.eventhubs.models.EventPosition;\nimport com.azure.messaging.eventhubs.models.InitializationContext;\nimport com.azure.messaging.eventhubs.models.LastEnqueuedEventProperties;\nimport com.azure.messaging.eventhubs.models.PartitionContext;\nimport com.azure.messaging.eventhubs.models.PartitionEvent;\nimport com.azure.messaging.eventhubs.models.PartitionOwnership;\nimport com.azure.messaging.eventhubs.models.ReceiveOptions;\nimport java.io.Closeable;\nimport java.io.IOException;\nimport java.time.Duration;\nimport java.util.List;\nimport java.util.Locale;\nimport java.util.Map;\nimport java.util.Optional;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport reactor.core.publisher.Flux;\nimport reactor.core.publisher.Signal;\nimport reactor.core.scheduler.Schedulers;\n\n/**\n * The partition pump manager that keeps track of all the partition pumps started by this {@link EventProcessorClient}.\n * Each partition pump is an {@link EventHubConsumerClient} that is receiving events from partitions this {@link\n * EventProcessorClient} has claimed ownership of.\n *\n * <p>\n * New partition pumps are created when this {@link EventProcessorClient} claims ownership of a new partition. When the\n * {@link EventProcessorClient} is requested to stop, this class is responsible for stopping all event processing tasks\n * and closing all connections to the Event Hub.\n * </p>\n */\nclass PartitionPumpManager {\n\n    private final ClientLogger logger = new ClientLogger(PartitionPumpManager.class);\n    private final CheckpointStore checkpointStore;\n    private final Map<String, EventHubConsumerAsyncClient> partitionPumps = new ConcurrentHashMap<>();\n    private final Supplier<PartitionProcessor> partitionProcessorFactory;\n    private final EventHubClientBuilder eventHubClientBuilder;\n    private final TracerProvider tracerProvider;\n    private final boolean trackLastEnqueuedEventProperties;\n    private final Map<String, EventPosition> initialPartitionEventPosition;\n    private final Duration maxWaitTime;\n    private final int maxBatchSize;\n    private final boolean batchReceiveMode;\n\n    /**\n     * Creates an instance of partition pump manager.\n     *\n     * @param checkpointStore The partition manager that is used to store and update checkpoints.\n     * @param partitionProcessorFactory The partition processor factory that is used to create new instances of {@link\n     * PartitionProcessor} when new partition pumps are started.\n     * @param eventHubClientBuilder The client builder used to create new clients (and new connections) for each\n     * partition processed by this {@link EventProcessorClient}.\n     * @param trackLastEnqueuedEventProperties If set to {@code true}, all events received by this EventProcessorClient\n     * will also include the last enqueued event properties for it's respective partitions.\n     * @param tracerProvider The tracer implementation.\n     * @param initialPartitionEventPosition Map of initial event positions for partition ids.\n     * @param maxBatchSize The maximum batch size to receive per users' process handler invocation.\n     * @param maxWaitTime The maximum time to wait to receive a batch or a single event.\n     * @param batchReceiveMode The boolean value indicating if this processor is configured to receive in batches or\n     * single events.\n     */\n    PartitionPumpManager(CheckpointStore checkpointStore,\n        Supplier<PartitionProcessor> partitionProcessorFactory, EventHubClientBuilder eventHubClientBuilder,\n        boolean trackLastEnqueuedEventProperties, TracerProvider tracerProvider,\n        Map<String, EventPosition> initialPartitionEventPosition, int maxBatchSize, Duration maxWaitTime,\n        boolean batchReceiveMode) {\n        this.checkpointStore = checkpointStore;\n        this.partitionProcessorFactory = partitionProcessorFactory;\n        this.eventHubClientBuilder = eventHubClientBuilder;\n        this.trackLastEnqueuedEventProperties = trackLastEnqueuedEventProperties;\n        this.tracerProvider = tracerProvider;\n        this.initialPartitionEventPosition = initialPartitionEventPosition;\n        this.maxBatchSize = maxBatchSize;\n        this.maxWaitTime = maxWaitTime;\n        this.batchReceiveMode = batchReceiveMode;\n    }\n\n    /**\n     * Stops all partition pumps that are actively consuming events. This method is invoked when the {@link\n     * EventProcessorClient} is requested to stop.\n     */\n    void stopAllPartitionPumps() {\n        this.partitionPumps.forEach((partitionId, eventHubConsumer) -> {\n            try {\n                eventHubConsumer.close();\n            } catch (Exception ex) {\n                logger.warning(Messages.FAILED_CLOSE_CONSUMER_PARTITION, partitionId, ex);\n            } finally {\n                partitionPumps.remove(partitionId);\n            }\n        });\n    }\n\n    /**\n     * Checks the state of the connection for the given partition. If the connection is closed, then this method will\n     * remove the partition from the list of partition pumps.\n     *\n     * @param ownership The partition ownership information for which the connection state will be verified.\n     */\n    void verifyPartitionConnection(PartitionOwnership ownership) {\n        if (partitionPumps.containsKey(ownership.getPartitionId())) {\n            EventHubConsumerAsyncClient consumerClient = partitionPumps.get(ownership.getPartitionId());\n            if (consumerClient.isConnectionClosed()) {\n                logger.info(\"Connection closed for {}, partition {}. Removing the consumer.\",\n                    ownership.getEventHubName(), ownership.getPartitionId());\n                partitionPumps.remove(ownership.getPartitionId());\n            }\n        }\n    }\n\n    /**\n     * Starts a new partition pump for the newly claimed partition. If the partition already has an active partition\n     * pump, this will not create a new consumer.\n     *\n     * @param claimedOwnership The details of partition ownership for which new partition pump is requested to start.\n     */\n    void startPartitionPump(PartitionOwnership claimedOwnership, Checkpoint checkpoint) {\n        if (partitionPumps.containsKey(claimedOwnership.getPartitionId())) {\n            logger.verbose(\"Consumer is already running for this partition {}\", claimedOwnership.getPartitionId());\n            return;\n        }\n\n        try {\n            PartitionContext partitionContext = new PartitionContext(claimedOwnership.getFullyQualifiedNamespace(),\n                claimedOwnership.getEventHubName(), claimedOwnership.getConsumerGroup(),\n                claimedOwnership.getPartitionId());\n            PartitionProcessor partitionProcessor = this.partitionProcessorFactory.get();\n\n            InitializationContext initializationContext = new InitializationContext(partitionContext);\n            partitionProcessor.initialize(initializationContext);\n\n            EventPosition startFromEventPosition = null;\n            // A checkpoint indicates the last known successfully processed event.\n            // So, the event position to start a new partition processing should be exclusive of the\n            // offset/sequence number in the checkpoint. If no checkpoint is available, start from\n            // the position in set in the InitializationContext (either the earliest event in the partition or\n            // the user provided initial position)\n            if (checkpoint != null && checkpoint.getOffset() != null) {\n                startFromEventPosition = EventPosition.fromOffset(checkpoint.getOffset());\n            } else if (checkpoint != null && checkpoint.getSequenceNumber() != null) {\n                startFromEventPosition = EventPosition.fromSequenceNumber(checkpoint.getSequenceNumber());\n            } else if (initialPartitionEventPosition.containsKey(claimedOwnership.getPartitionId())) {\n                startFromEventPosition = initialPartitionEventPosition.get(claimedOwnership.getPartitionId());\n            } else {\n                startFromEventPosition = EventPosition.latest();\n            }\n            logger.info(\"Starting event processing from {} for partition {}\", startFromEventPosition,\n                claimedOwnership.getPartitionId());\n            ReceiveOptions receiveOptions = new ReceiveOptions().setOwnerLevel(0L)\n                .setTrackLastEnqueuedEventProperties(trackLastEnqueuedEventProperties);\n\n            EventHubConsumerAsyncClient eventHubConsumer = eventHubClientBuilder.buildAsyncClient()\n                .createConsumer(claimedOwnership.getConsumerGroup(), EventHubClientBuilder.DEFAULT_PREFETCH_COUNT);\n\n            partitionPumps.put(claimedOwnership.getPartitionId(), eventHubConsumer);\n            //@formatter:off\n            Flux<Flux<PartitionEvent>> partitionEventFlux;\n            Flux<PartitionEvent> receiver = eventHubConsumer\n                .receiveFromPartition(claimedOwnership.getPartitionId(), startFromEventPosition, receiveOptions)\n                .doOnNext(partitionEvent -> {\n                    if (logger.canLogAtLevel(LogLevel.VERBOSE)) {\n                        logger.verbose(\"On next {}, {}, {}\",\n                            partitionContext.getEventHubName(), partitionContext.getPartitionId(),\n                            partitionEvent.getData().getSequenceNumber());\n                    }\n                });\n\n            if (maxWaitTime != null) {\n                partitionEventFlux = receiver\n                    .windowTimeout(maxBatchSize, maxWaitTime);\n            } else {\n                partitionEventFlux = receiver\n                    .window(maxBatchSize);\n            }\n            partitionEventFlux\n                .concatMap(Flux::collectList)\n                .publishOn(Schedulers.boundedElastic())\n                .subscribe(partitionEventBatch -> {\n                    processEvents(partitionContext, partitionProcessor,\n                        eventHubConsumer, partitionEventBatch);\n                },\n                    /* EventHubConsumer receive() returned an error */\n                    ex -> handleError(claimedOwnership, eventHubConsumer, partitionProcessor, ex, partitionContext),\n                    () -> {\n                        partitionProcessor.close(new CloseContext(partitionContext,\n                            CloseReason.EVENT_PROCESSOR_SHUTDOWN));\n                        cleanup(claimedOwnership, eventHubConsumer);\n                    });\n            //@formatter:on\n        } catch (Exception ex) {\n            if (partitionPumps.containsKey(claimedOwnership.getPartitionId())) {\n                cleanup(claimedOwnership, partitionPumps.get(claimedOwnership.getPartitionId()));\n            }\n            throw logger.logExceptionAsError(\n                new PartitionProcessorException(\n                    \"Error occurred while starting partition pump for partition \" + claimedOwnership.getPartitionId(),\n                    ex));\n        }\n    }\n\n    private void processEvent(PartitionContext partitionContext, PartitionProcessor partitionProcessor,\n        EventHubConsumerAsyncClient eventHubConsumer, EventContext eventContext) {\n\n        Context processSpanContext = null;\n        EventData eventData = eventContext.getEventData();\n        if (eventData != null) {\n            processSpanContext = startProcessTracingSpan(eventData, eventHubConsumer.getEventHubName(),\n                eventHubConsumer.getFullyQualifiedNamespace());\n            if (processSpanContext.getData(SPAN_CONTEXT_KEY).isPresent()) {\n                eventData.addContext(SPAN_CONTEXT_KEY, processSpanContext);\n            }\n        }\n        try {\n            if (logger.canLogAtLevel(LogLevel.VERBOSE)) {\n                logger.verbose(\"Processing event {}, {}\", partitionContext.getEventHubName(),\n                    partitionContext.getPartitionId());\n            }\n            partitionProcessor.processEvent(new EventContext(partitionContext, eventData, checkpointStore,\n                eventContext.getLastEnqueuedEventProperties()));\n            if (logger.canLogAtLevel(LogLevel.VERBOSE)) {\n                logger.verbose(\"Completed processing event {}, {}\", partitionContext.getEventHubName(),\n                    partitionContext.getPartitionId());\n            }\n            endProcessTracingSpan(processSpanContext, Signal.complete());\n        } catch (Throwable throwable) {\n            /* user code for event processing threw an exception - log and bubble up */\n            endProcessTracingSpan(processSpanContext, Signal.error(throwable));\n            throw logger.logExceptionAsError(new PartitionProcessorException(\"Error in event processing callback\",\n                throwable));\n        }\n    }\n\n    private void processEvents(PartitionContext partitionContext, PartitionProcessor partitionProcessor,\n        EventHubConsumerAsyncClient eventHubConsumer, List<PartitionEvent> partitionEventBatch) {\n        try {\n            if (batchReceiveMode) {\n                LastEnqueuedEventProperties[] lastEnqueuedEventProperties = new LastEnqueuedEventProperties[1];\n                List<EventData> eventDataList = partitionEventBatch.stream()\n                    .map(partitionEvent -> {\n                        lastEnqueuedEventProperties[0] = partitionEvent.getLastEnqueuedEventProperties();\n                        return partitionEvent.getData();\n                    })\n                    .collect(Collectors.toList());\n                EventBatchContext eventBatchContext = new EventBatchContext(partitionContext, eventDataList,\n                    checkpointStore, lastEnqueuedEventProperties[0]);\n                if (logger.canLogAtLevel(LogLevel.VERBOSE)) {\n                    logger.verbose(\"Processing event batch {}, {}\", partitionContext.getEventHubName(),\n                        partitionContext.getPartitionId());\n                }\n                partitionProcessor.processEventBatch(eventBatchContext);\n                if (logger.canLogAtLevel(LogLevel.VERBOSE)) {\n                    logger.verbose(\"Completed processing event batch{}, {}\", partitionContext.getEventHubName(),\n                        partitionContext.getPartitionId());\n                }\n            } else {\n                EventData eventData = (partitionEventBatch.size() == 1\n                    ? partitionEventBatch.get(0).getData() : null);\n                LastEnqueuedEventProperties lastEnqueuedEventProperties = (partitionEventBatch.size() == 1\n                    ? partitionEventBatch.get(0).getLastEnqueuedEventProperties() : null);\n                EventContext eventContext = new EventContext(partitionContext, eventData, checkpointStore,\n                    lastEnqueuedEventProperties);\n                processEvent(partitionContext, partitionProcessor, eventHubConsumer, eventContext);\n            }\n        } catch (Throwable throwable) {\n            /* user code for event processing threw an exception - log and bubble up */\n            throw logger.logExceptionAsError(new PartitionProcessorException(\"Error in event processing callback\",\n                throwable));\n        }\n    }\n\n    Map<String, EventHubConsumerAsyncClient> getPartitionPumps() {\n        return this.partitionPumps;\n    }\n\n    private void handleError(PartitionOwnership claimedOwnership, EventHubConsumerAsyncClient eventHubConsumer,\n        PartitionProcessor partitionProcessor, Throwable throwable, PartitionContext partitionContext) {\n        boolean shouldRethrow = true;\n        if (!(throwable instanceof PartitionProcessorException)) {\n            shouldRethrow = false;\n            // If user code threw an exception in processEvent callback, bubble up the exception\n            logger.warning(\"Error receiving events from partition {}\", partitionContext.getPartitionId(), throwable);\n            partitionProcessor.processError(new ErrorContext(partitionContext, throwable));\n        }\n        // If there was an error on receive, it also marks the end of the event data stream\n        // Any exception while receiving events will result in the processor losing ownership\n        CloseReason closeReason = CloseReason.LOST_PARTITION_OWNERSHIP;\n        partitionProcessor.close(new CloseContext(partitionContext, closeReason));\n        cleanup(claimedOwnership, eventHubConsumer);\n        if (shouldRethrow) {\n            PartitionProcessorException exception = (PartitionProcessorException) throwable;\n            throw logger.logExceptionAsError(exception);\n        }\n    }\n\n    private void cleanup(PartitionOwnership claimedOwnership, EventHubConsumerAsyncClient eventHubConsumer) {\n        try {\n            // close the consumer\n            logger.info(\"Closing consumer for partition id {}\", claimedOwnership.getPartitionId());\n            eventHubConsumer.close();\n        } finally {\n            // finally, remove the partition from partitionPumps map\n            logger.info(\"Removing partition id {} from list of processing partitions\",\n                claimedOwnership.getPartitionId());\n            partitionPumps.remove(claimedOwnership.getPartitionId());\n        }\n    }\n\n    /*\n     * Starts a new process tracing span and attaches the returned context to the EventData object for users.\n     */\n    private Context startProcessTracingSpan(EventData eventData, String eventHubName, String fullyQualifiedNamespace) {\n        Object diagnosticId = eventData.getProperties().get(DIAGNOSTIC_ID_KEY);\n        if (diagnosticId == null || !tracerProvider.isEnabled()) {\n            return Context.NONE;\n        }\n\n        Context spanContext = tracerProvider.extractContext(diagnosticId.toString(), Context.NONE)\n            .addData(ENTITY_PATH_KEY, eventHubName)\n            .addData(HOST_NAME_KEY, fullyQualifiedNamespace)\n            .addData(AZ_TRACING_NAMESPACE_KEY, AZ_NAMESPACE_VALUE);\n        spanContext = eventData.getEnqueuedTime() == null\n            ? spanContext\n            : spanContext.addData(MESSAGE_ENQUEUED_TIME, eventData.getEnqueuedTime().getEpochSecond());\n        return tracerProvider.startSpan(AZ_TRACING_SERVICE_NAME, spanContext, ProcessKind.PROCESS);\n    }\n\n    /*\n     * Ends the process tracing span and the scope of that span.\n     */\n    private void endProcessTracingSpan(Context processSpanContext, Signal<Void> signal) {\n        if (processSpanContext == null) {\n            return;\n        }\n\n        Optional<Object> spanScope = processSpanContext.getData(SCOPE_KEY);\n        // Disposes of the scope when the trace span closes.\n        if (!spanScope.isPresent() || !tracerProvider.isEnabled()) {\n            return;\n        }\n        if (spanScope.get() instanceof Closeable) {\n            Closeable close = (Closeable) processSpanContext.getData(SCOPE_KEY).get();\n            try {\n                close.close();\n                tracerProvider.endSpan(processSpanContext, signal);\n            } catch (IOException ioException) {\n                logger.error(Messages.EVENT_PROCESSOR_RUN_END, ioException);\n            }\n\n        } else {\n            logger.warning(String.format(Locale.US,\n                Messages.PROCESS_SPAN_SCOPE_TYPE_ERROR,\n                spanScope.get() != null ? spanScope.getClass() : \"null\"));\n        }\n    }\n}\n", "rface DealListAdapterNotifier {\n    void notifyEmpty();\n    void notifyNotEmpty();\n    void adapterUpdate();\n}\n", "charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n * THE SOFTWARE.\r\n */\r\n\r\npackage Core;\r\nimport Monsters.Affixes.*;\r\n\r\n/**\r\n *\r\n * @author Alexis\r\n */\r\npublic class Monster {\r\n    protected String Name;\r\n    protected int Level;\r\n    protected long ExpToGive;\r\n    protected int Health;\r\n    protected Gold GoldToGive;\r\n    public boolean IsAlive;\r\n    protected Affixe availableAffixes[];\r\n    \r\n    public Monster() {}\r\n    public Monster(int lvl) {\r\n        this.Level = lvl;\r\n        this.GoldToGive = new Gold();\r\n        this.Health = 15;\r\n        this.IsAlive = true;\r\n        //this.ComputeHealth();\r\n        this.ComputeExpToGive();\r\n        this.ComputeGoldToGive();\r\n        this.setAffixe();\r\n    }\r\n    \r\n    public void setAffixe() {};\r\n    \r\n    public void getHit(int dmg) {\r\n        if(this.Health > dmg) {\r\n            this.Health -= dmg;\r\n        }\r\n        else {\r\n            this.die();\r\n        }\r\n    }\r\n    \r\n    public void die() {\r\n        this.Health = 0;\r\n        this.IsAlive = false;\r\n    }\r\n    \r\n    public void ComputeExpToGive() {\r\n        this.ExpToGive = this.Level * 2;\r\n    }\r\n    \r\n    public void ComputeHealth() {\r\n        this.Health = this.Level*5;\r\n    }\r\n    \r\n    public long GetExpToGive() {\r\n        return this.ExpToGive;\r\n    }\r\n    \r\n    public void ComputeGoldToGive() {\r\n        this.GoldToGive.setAmount(this.Level * 3);\r\n    }\r\n    \r\n    public int GetGoldToGive() {\r\n        return this.GoldToGive.getAmount();\r\n    }\r\n \r\n    public int GetHealth() {\r\n        return this.Health;\r\n    }\r\n    \r\n}\r\n", ".0\n * \n *\n * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage com.ixaris.ope.applications.client.model;\n\nimport java.util.Objects;\nimport com.google.gson.annotations.SerializedName;\nimport com.ixaris.ope.applications.client.model.CurrencyAmountMessage;\nimport com.ixaris.ope.applications.client.model.ScaledAmount;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * A definition of a Fee that can be used when performing a transaction to take a fee.\n */\n@ApiModel(description = \"A definition of a Fee that can be used when performing a transaction to take a fee.\")\n@javax.annotation.Generated(value = \"io.swagger.codegen.languages.JavaClientCodegen\", date = \"2017-08-30T15:46:40.836+02:00\")\npublic class FeeDefinition {\n  @SerializedName(\"key\")\n  private String key = null;\n\n  /**\n   * The type of fee that should be taken.\n   */\n  public enum FeeTypeEnum {\n    @SerializedName(\"MAX\")\n    MAX(\"MAX\"),\n    \n    @SerializedName(\"MIN\")\n    MIN(\"MIN\"),\n    \n    @SerializedName(\"PLUS\")\n    PLUS(\"PLUS\"),\n    \n    @SerializedName(\"FLAT\")\n    FLAT(\"FLAT\"),\n    \n    @SerializedName(\"PERCENTAGE\")\n    PERCENTAGE(\"PERCENTAGE\");\n\n    private String value;\n\n    FeeTypeEnum(String value) {\n      this.value = value;\n    }\n\n    @Override\n    public String toString() {\n      return String.valueOf(value);\n    }\n  }\n\n  @SerializedName(\"feeType\")\n  private FeeTypeEnum feeType = null;\n\n  @SerializedName(\"flatAmountFees\")\n  private List<CurrencyAmountMessage> flatAmountFees = new ArrayList<CurrencyAmountMessage>();\n\n  @SerializedName(\"percentage\")\n  private ScaledAmount percentage = null;\n\n  public FeeDefinition key(String key) {\n    this.key = key;\n    return this;\n  }\n\n   /**\n   * The key identifying the kind of fee that was taken. Any value can be specified here.\n   * @return key\n  **/\n  @ApiModelProperty(example = \"null\", required = true, value = \"The key identifying the kind of fee that was taken. Any value can be specified here.\")\n  public String getKey() {\n    return key;\n  }\n\n  public void setKey(String key) {\n    this.key = key;\n  }\n\n  public FeeDefinition feeType(FeeTypeEnum feeType) {\n    this.feeType = feeType;\n    return this;\n  }\n\n   /**\n   * The type of fee that should be taken.\n   * @return feeType\n  **/\n  @ApiModelProperty(example = \"null\", value = \"The type of fee that should be taken.\")\n  public FeeTypeEnum getFeeType() {\n    return feeType;\n  }\n\n  public void setFeeType(FeeTypeEnum feeType) {\n    this.feeType = feeType;\n  }\n\n  public FeeDefinition flatAmountFees(List<CurrencyAmountMessage> flatAmountFees) {\n    this.flatAmountFees = flatAmountFees;\n    return this;\n  }\n\n  public FeeDefinition addFlatAmountFeesItem(CurrencyAmountMessage flatAmountFeesItem) {\n    this.flatAmountFees.add(flatAmountFeesItem);\n    return this;\n  }\n\n   /**\n   * The flat fee amounts to be taken per currency. Required for FLAT, MAX, MIN and PLUS fee types.\n   * @return flatAmountFees\n  **/\n  @ApiModelProperty(example = \"null\", value = \"The flat fee amounts to be taken per currency. Required for FLAT, MAX, MIN and PLUS fee types.\")\n  public List<CurrencyAmountMessage> getFlatAmountFees() {\n    return flatAmountFees;\n  }\n\n  public void setFlatAmountFees(List<CurrencyAmountMessage> flatAmountFees) {\n    this.flatAmountFees = flatAmountFees;\n  }\n\n  public FeeDefinition percentage(ScaledAmount percentage) {\n    this.percentage = percentage;\n    return this;\n  }\n\n   /**\n   * The percentage amount to be taken as a fee. Required for PERCENTAGE, MAX, MIN and PLUS fee types.\n   * @return percentage\n  **/\n  @ApiModelProperty(example = \"null\", value = \"The percentage amount to be taken as a fee. Required for PERCENTAGE, MAX, MIN and PLUS fee types.\")\n  public ScaledAmount getPercentage() {\n    return percentage;\n  }\n\n  public void setPercentage(ScaledAmount percentage) {\n    this.percentage = percentage;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    FeeDefinition feeDefinition = (FeeDefinition) o;\n    return Objects.equals(this.key, feeDefinition.key) &&\n        Objects.equals(this.feeType, feeDefinition.feeType) &&\n        Objects.equals(this.flatAmountFees, feeDefinition.flatAmountFees) &&\n        Objects.equals(this.percentage, feeDefinition.percentage);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(key, feeType, flatAmountFees, percentage);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class FeeDefinition {\\n\");\n    \n    sb.append(\"    key: \").append(toIndentedString(key)).append(\"\\n\");\n    sb.append(\"    feeType: \").append(toIndentedString(feeType)).append(\"\\n\");\n    sb.append(\"    flatAmountFees: \").append(toIndentedString(flatAmountFees)).append(\"\\n\");\n    sb.append(\"    percentage: \").append(toIndentedString(percentage)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n  \n}\n\n", "Math;\n\npublic class Environment {\n\tprivate static final double COLLISION_DIST = 10;\n\tprivate static final double LINEAR_SPEED_MULT = 2;\n\tprivate static final double ANGULAR_SPEED_MULT = 0.08;\n\t\n\tprivate List<Vehicle> vehicles;\n\tprivate List<Checkpoint> checkpoints;\n\tprivate Object mutex_lock;\n\t\n\tpublic double time;\n\t\n\tpublic Environment(List<Vehicle> vehicles, List<Checkpoint> checkpoints, Object mutex_lock){\n\t\tthis.vehicles = vehicles;\n\t\tthis.checkpoints = checkpoints;\n\t\tthis.mutex_lock = mutex_lock;\n\t\ttime = 0;\n\t}\n\t\n\t// Move vehicles to start point, and reset the checkpoint index.\n\tpublic void moveVehiclesToStart(){\n\t\ttime = 0;\n\t\tListIterator<Vehicle> iter = vehicles.listIterator();\n\t\twhile (iter.hasNext()){\n\t\t\tVehicle v = iter.next();\n\t\t\tv.x = 100;\n\t\t\tv.y = 100;\n\t\t\tv.yaw = 0;\n\t\t\tv.next_checkpoint_index = 0;\n\t\t\tv.left_track_speed = 0;\n\t\t\tv.right_track_speed = 0;\n\t\t\tv.dist_to_checkpoint_x = 0;\n\t\t\tv.dist_to_checkpoint_y = 0;\n\t\t\tv.getGenome().setFitness(0);\n\t\t\tv.getGenome().setMaxFitness(0);\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t// Assuming all vehicle speeds have been updated, this moves them and detects if the checkpoint\n\t// has been reached.\n\tpublic void update(double time_increment){\n\t\ttime += time_increment;\n\t\tListIterator<Vehicle> iter = vehicles.listIterator();\n\t\twhile (iter.hasNext()){\n\t\t\tVehicle v = iter.next();\n\t\t\t// Move each vehicle.\n\t\t\tdouble speed_diff = v.left_track_speed - v.right_track_speed;\n\t\t\tdouble speed_avg = (v.left_track_speed + v.right_track_speed) / 2.0;\n\t\t\t//System.out.println(\"Speed avg: \" + speed_avg);\n\t\t\t//System.out.println(\"Move X: \" + speed_avg * time_increment * Math.cos(v.yaw));\n\t\t\tv.x += LINEAR_SPEED_MULT * speed_avg * time_increment * Math.cos(v.yaw);\n\t\t\tv.y += LINEAR_SPEED_MULT * speed_avg * time_increment * Math.sin(v.yaw);\n\t\t\tv.yaw += ANGULAR_SPEED_MULT * speed_diff; \n\t\t\t// Detect collisions with checkpoints.\n\t\t\tif (v.next_checkpoint_index < checkpoints.size()){\n\t\t\t\tCheckpoint cp = checkpoints.get(v.next_checkpoint_index);\n\t\t\t\tif (Math.abs(cp.x - v.x) <= COLLISION_DIST){\n\t\t\t\t\tif (Math.abs(cp.y - v.y) <= COLLISION_DIST){\n\t\t\t\t\t\tv.next_checkpoint_index ++;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Update distance to checkpoints.\n\t\t\tif (v.next_checkpoint_index >= checkpoints.size()){\n\t\t\t\tv.dist_to_checkpoint_x = 0;\n\t\t\t\tv.dist_to_checkpoint_y = 0;\n\t\t\t} else {\n\t\t\t\tCheckpoint cp = checkpoints.get(v.next_checkpoint_index);\n\t\t\t\tv.dist_to_checkpoint_x = cp.x - v.x;\n\t\t\t\tv.dist_to_checkpoint_y = cp.y - v.y;\n\t\t\t}\n\t\t\t// Update fitness.\n\t\t\tdouble dist = Math.sqrt(v.dist_to_checkpoint_x*v.dist_to_checkpoint_x +\n\t\t\t\t\t\t\tv.dist_to_checkpoint_y*v.dist_to_checkpoint_y);\n\t\t\tv.getGenome().setFitness(v.next_checkpoint_index * 2000 - Math.min(800, dist) - time/4.0);\n\t\t\t\n\t\t}\n\t}\n\t\n\tpublic int getNumVehicles(){\n\t\treturn vehicles.size();\n\t}\n\t\n\tpublic Vehicle getVehicle(int index){\n\t\treturn vehicles.get(index);\n\t}\t\n\t\n\tpublic int getNumCheckpoints(){\n\t\treturn checkpoints.size();\n\t}\n\tpublic Checkpoint getCheckpoint(int index){\n\t\treturn checkpoints.get(index);\n\t}\n\t\n\tpublic void setVehicles(List<Vehicle> vehicles){\n\t\tsynchronized(mutex_lock){\n\t\t\tthis.vehicles = vehicles;\n\t\t}\n\t}\n}", "on is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * <p/>\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * <p/>\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage fr.bouyguestelecom.tv.bboxiot.datamodel.enums;\n\n/**\n * Property Capability enum\n *\n * @author Bertrand Martel\n */\npublic enum Capability {\n\n    NONE(\"none\"),\n    PULL(\"pull\"),\n    PUSH(\"push\");\n\n    private String valueStr = \"\";\n\n    private Capability(String valueStr) {\n        this.valueStr = valueStr;\n    }\n\n    public static Capability getCapabilityStr(String value) {\n\n        for (Capability capability : Capability.values()) {\n            if (value.equals(capability.valueStr))\n                return capability;\n        }\n        return NONE;\n    }\n\n    public String getValueStr() {\n        return valueStr;\n    }\n}\n", "os.Bundle;\n\npublic class Splash extends AppCompatActivity {\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_splash);\n    }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.netapp.v2019_06_01;\n\nimport com.microsoft.azure.arm.collection.SupportsCreating;\nimport rx.Completable;\nimport rx.Observable;\nimport com.microsoft.azure.management.netapp.v2019_06_01.implementation.PoolsInner;\nimport com.microsoft.azure.arm.model.HasInner;\n\n/**\n * Type representing Pools.\n */\npublic interface Pools extends SupportsCreating<CapacityPool.DefinitionStages.Blank>, HasInner<PoolsInner> {\n    /**\n     * Describe a Capacity Pool.\n     * Get details of the specified capacity pool.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param accountName The name of the NetApp account\n     * @param poolName The name of the capacity pool\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable for the request\n     */\n    Observable<CapacityPool> getAsync(String resourceGroupName, String accountName, String poolName);\n\n    /**\n     * Describe all Capacity Pools.\n     * List all capacity pools in the NetApp Account.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param accountName The name of the NetApp account\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable for the request\n     */\n    Observable<CapacityPool> listAsync(String resourceGroupName, String accountName);\n\n    /**\n     * Delete a capacity pool.\n     * Delete the specified capacity pool.\n     *\n     * @param resourceGroupName The name of the resource group.\n     * @param accountName The name of the NetApp account\n     * @param poolName The name of the capacity pool\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable for the request\n     */\n    Completable deleteAsync(String resourceGroupName, String accountName, String poolName);\n\n}\n", "e incorrect behavior and will be lost if\r\n *     the code is regenerated.\r\n */\r\npackage com.mozu.api.contracts.customer;\r\n\r\nimport java.io.Serializable;\r\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\r\nimport org.joda.time.DateTime;\r\nimport java.io.IOException;\r\nimport java.lang.ClassNotFoundException;\r\nimport com.mozu.api.contracts.core.AuditInfo;\r\n\r\n/**\r\n *\tThe Customer Segment object includes properties of a defined customer segment used to group customer accounts.\r\n */\r\n@JsonIgnoreProperties(ignoreUnknown = true)\r\npublic class CustomerSegment implements Serializable\r\n{\r\n\t// Default Serial Version UID\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t/**\r\n\t * The user-defined code assigned for the customer segment.\r\n\t */\r\n\tprotected  String code;\n\r\n\tpublic String getCode() {\n\t\treturn this.code;\n\t}\n\r\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\r\n\r\n\t/**\r\n\t * The localized description in text for the object, displayed per the locale code. For example, descriptions are used for product descriptions, attributes, and pre-authorization transaction types.\r\n\t */\r\n\tprotected  String description;\n\r\n\tpublic String getDescription() {\n\t\treturn this.description;\n\t}\n\r\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\r\n\r\n\t/**\r\n\t * Unique identifier of the source property, such as a catalog, discount, order, or email template.For a product field it will be the name of the field.For a category ID, must be a positive integer not greater than 2000000. By default,  auto-generates a category ID when categories are created. If you want to specify an ID during creation (which preserves category link relationships when migrating tenant data from one sandbox to another), you must also include the  query string in the endpoint. For example, . Then, use the  property to specify the desired category ID.For a product attribute it will be the Attribute FQN.For a document, the ID must be specified as a 32 character, case-insensitive, alphanumeric string. You can specify the ID as 32 sequential characters or as groups separated by dashes in the format 8-4-4-4-12. For example, or.For email templates, the ID must be one of the following values:\t\t\t\r\n\t */\r\n\tprotected  Integer id;\n\r\n\tpublic Integer getId() {\n\t\treturn this.id;\n\t}\n\r\n\tpublic void setId(Integer id) {\n\t\tthis.id = id;\n\t}\r\n\r\n\t/**\r\n\t * The user supplied name that appears in . You can use this field for identification purposes.\r\n\t */\r\n\tprotected  String name;\n\r\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\r\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\r\n\r\n\tprotected  AuditInfo auditInfo;\n\r\n\tpublic AuditInfo getAuditInfo() {\n\t\treturn this.auditInfo;\n\t}\n\r\n\tpublic void setAuditInfo(AuditInfo auditInfo) {\n\t\tthis.auditInfo = auditInfo;\n\t}\r\n\r\n\r\n}\r\n", "* @author Thomas Rademaker\n * @version 4/20/2012\n */\npublic class ArrayDeque<T> implements DequeInterface<T>\n{\n\tprivate T[] deque;\n\tprivate int frontIndex;\n\tprivate int backIndex;\n\tprivate static final int DEFAULT_INITIAL_CAPACITY = 50;\n\t\n\t/**\n\t * ArrayDeque constructor that uses the DEFAULT_INITIAL_CAPACITY field\n\t */\n\tpublic ArrayDeque()\n\t{\n\t\tthis(DEFAULT_INITIAL_CAPACITY);\n\t}\n\t\n\t/**\n\t * ArrayDeque constructor that creates a deque with an array.\n\t * @param int initialCapacity. An integer that is used as the initial capacity for the deque.\n\t */\n\tpublic ArrayDeque(int initialCapacity)\n\t{\n\t\t@SuppressWarnings(\"unchecked\")\n\t\tT[] tempDeque = (T[]) new Object[initialCapacity + 1];\n\t\tdeque = tempDeque;\n\t\tfrontIndex = 0;\n\t\tbackIndex = initialCapacity;\n\t}\n\t\n\t/**\n\t * Adds an object to the front of the deque.\n\t * @param T newEntry. The new object to be added.\n\t */\n\tpublic void addToFront(T newEntry)\n\t{\n\t\tensureCapacity();\n\t\t\n\t\tif(frontIndex == 0)\n\t\t\tfrontIndex = deque.length - 1;\n\t\telse\n\t\t\tfrontIndex = frontIndex - 1;\n\t\t\n\t\tdeque[frontIndex] = newEntry;\n\t}\n\t\n\t/**\n\t * Adds an object to the back of the deque.\n\t * @param T newEntry. The new object to be added.\n\t */\n\tpublic void addToBack(T newEntry)\n\t{\n\t\tensureCapacity();\n\t\tbackIndex = (backIndex + 1) % deque.length;\n\t\tdeque[backIndex] = newEntry;\n\t}\n\t\n\t/**\n\t * Doubles the size of the array deque if it is full\n\t */\n\tprivate void ensureCapacity()\n\t{\n\t\tif(frontIndex == ((backIndex + 2) % deque.length)) {\n\t\t\tT[] oldDeque = deque;\n\t\t\tint oldSize = oldDeque.length;\n\t\t\t\n\t\t\t@SuppressWarnings(\"unchecked\")\n\t\t\tT[] tempDeque = (T[]) new Object[2 * oldSize];\n\t\t\tdeque = tempDeque;\n\t\t\t\n\t\t\tfor(int i = 0; i < oldSize - 1; i++) {\n\t\t\t\tdeque[i] = oldDeque[frontIndex];\n\t\t\t\tfrontIndex = (frontIndex + 1) % oldSize;\n\t\t\t}\n\t\t\t\n\t\t\tfrontIndex = 0;\n\t\t\tbackIndex = oldSize - 2;\n\t\t}\n\t}\n\t\n\t/**\n\t * Removes an object from the front of the deque.\n\t * @return T. The object that is removed.\n\t */\n\tpublic T removeFront()\n\t{\n\t\tT front = null;\n\t\t\n\t\tif(!isEmpty()){\n\t\t\tfront = deque[frontIndex];\n\t\t\tdeque[frontIndex] = null;\n\t\t\tfrontIndex = (frontIndex + 1) % deque.length;\n\t\t}\n\t\t\n\t\treturn front;\n\t}\n\t\n\t/**\n\t * Removes an object from the back of the deque.\n\t * @return T. The object that is removed.\n\t */\n\tpublic T removeBack()\n\t{\n\t\tT back = null;\n\t\t\n\t\tif(!isEmpty()) {\n\t\t\tback = deque[backIndex];\n\t\t\tdeque[backIndex] = null;\n\t\t\t\n\t\t\tif(backIndex == 0)\n\t\t\t\tbackIndex = deque.length - 1;\n\t\t\telse\n\t\t\t\tbackIndex = (backIndex - 1);\n\t\t}\n\t\t\n\t\treturn back;\n\t}\n\t\n\t/**\n\t * Returns the item at the front of the deque.\n\t * @return T. The item in the front.\n\t */\n\tpublic T getFront()\n\t{\n\t\tif(!isEmpty())\n\t\t\treturn deque[frontIndex];\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Returns the item at the back of the deque.\n\t * @return T. The item in the back.\n\t */\n\tpublic T getBack()\n\t{\n\t\tif(!isEmpty())\n\t\t\treturn deque[backIndex];\n\t\t\n\t\treturn null;\n\t}\n\t\n\t/**\n\t * Checks to see if the deque is empty.\n\t * @return boolean. True if the deque is empty and false otherwise. \n\t */\n\tpublic boolean isEmpty()\n\t{\n\t\treturn frontIndex == ((backIndex + 1) % deque.length);\n\t}\n\t\n\t/**\n\t * Removes all of the items from the deque.\n\t */\n\tpublic void clear()\n\t{\n\t\twhile(!isEmpty())\n\t\t\tremoveBack();\n\t}\n\n}\n", "port com.cjburkey.claimchunk.smartcommand.CCSubCommand;\n\nimport de.goldmensch.commanddispatcher.Executor;\n\nimport org.bukkit.command.CommandSender;\nimport org.bukkit.entity.Player;\nimport org.jetbrains.annotations.NotNull;\n\nimport java.util.Optional;\n\npublic class UnclaimCmd extends CCSubCommand {\n\n    public UnclaimCmd(ClaimChunk claimChunk) {\n        super(claimChunk, Executor.PLAYER, \"unclaim\", true);\n    }\n\n    @Override\n    public @NotNull Optional<String> getDescription() {\n        return Optional.ofNullable(claimChunk.getMessages().cmdUnclaim);\n    }\n\n    @Override\n    public CCArg[] getPermittedArguments() {\n        return new CCArg[0];\n    }\n\n    @Override\n    public int getRequiredArguments() {\n        return 0;\n    }\n\n    @Override\n    public boolean onCall(@NotNull String cmdUsed, @NotNull CommandSender executor, String[] args) {\n        claimChunk.getMainHandler().unclaimChunk(false, false, (Player) executor);\n        return true;\n    }\n}\n", "aParCisla;\r\nimport cz.pfreiberg.knparser.util.VfkUtil;\r\n\r\npublic class DotcenaParCislaParser {\r\n\r\n\tpublic static DotcenaParCisla parse(String[] tokens) {\r\n\t\tint i = 0;\r\n\r\n\t\tDotcenaParCisla dotcenaParCisla = new DotcenaParCisla();\r\n\t\tdotcenaParCisla.setKatuzeKod(VfkUtil.getInteger(tokens, i++));\r\n\t\tdotcenaParCisla.setKmenoveCisloPar(VfkUtil.getInteger(tokens, i++));\r\n\t\tdotcenaParCisla.setPoddeleniCislaPar(VfkUtil.getInteger(tokens, i++));\r\n\t\tdotcenaParCisla.setDruhCislovaniPar(VfkUtil.getInteger(tokens, i++));\r\n\r\n\t\treturn dotcenaParCisla;\r\n\t}\r\n\r\n}\r\n", "xception;\n\nimport static org.junit.Assert.assertEquals;\n\n\npublic class UrlDataToolsTests {\n    @Test\n    public void testDataRetrievalFromIex() throws IOException {\n        // Skipif\n        Assume.assumeTrue(System.getenv(\"TRAVIS_CI\") == null);\n\n        // Arrange\n        String url = \"https://api.iextrading.com/1.0/stock/market/batch?symbols=aapl&types=quote\";\n\n        // Act\n        String result = UrlDataTools.urlToString(url).substring(0, 33);\n\n        // Assert\n        String expected = \"{\\\"AAPL\\\":{\\\"quote\\\":{\\\"symbol\\\":\\\"AAPL\\\"\";\n        assertEquals(expected, result);\n    }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.recoveryservices.siterecovery.v2018_01_10;\n\nimport com.microsoft.azure.arm.model.HasInner;\nimport com.microsoft.azure.management.recoveryservices.siterecovery.v2018_01_10.implementation.RecoveryPointInner;\nimport com.microsoft.azure.arm.model.Indexable;\nimport com.microsoft.azure.arm.model.Refreshable;\nimport com.microsoft.azure.arm.resources.models.HasManager;\nimport com.microsoft.azure.management.recoveryservices.siterecovery.v2018_01_10.implementation.RecoveryServicesManager;\n\n/**\n * Type representing RecoveryPoint.\n */\npublic interface RecoveryPoint extends HasInner<RecoveryPointInner>, Indexable, Refreshable<RecoveryPoint>, HasManager<RecoveryServicesManager> {\n    /**\n     * @return the id value.\n     */\n    String id();\n\n    /**\n     * @return the location value.\n     */\n    String location();\n\n    /**\n     * @return the name value.\n     */\n    String name();\n\n    /**\n     * @return the properties value.\n     */\n    RecoveryPointProperties properties();\n\n    /**\n     * @return the type value.\n     */\n    String type();\n\n}\n", "Driver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MoveByOffSet {\n\tpublic static void main(String... args) {\n\t\tWebDriver driver = new FirefoxDriver();\n\t\tdriver.get(\"file://C:/Selectable.html\");\n\t\tWebElement three = driver.findElement(By.name(\"three\"));\n\t\tSystem.out.println(\"X coordinate: \" + three.getLocation().getX()\n\t\t\t\t+ \"  Y coordinate: \" + three.getLocation().getY());\n\t\tActions builder = new Actions(driver);\n\t\tbuilder.moveByOffset(three.getLocation().getX() + 1, three\n\t\t\t\t.getLocation().getY() + 1);\n\t\tbuilder.perform();\n\t}\n}\n", "kedList;\nimport java.util.Queue;\n\npublic class ListOfDepths {\n    private static int V;\n    private static LinkedList<Integer>[] adj;\n\n    public ListOfDepths(int v){\n        V=v;\n        adj = new LinkedList[v];\n        for(int i=0; i<v; i++)\n            adj[i] = new LinkedList();\n    }\n\n    public void addEdge(int v,int w){\n        adj[v].add(w);\n    }\n\n    public static ArrayList<LinkedList<Integer>> depthList(int u){\n        boolean[] visited = new boolean[V];\n        Queue<Integer> q = new LinkedList<Integer>();\n        ArrayList<LinkedList<Integer>> res = new ArrayList<>();\n        int depth = 0;\n        res.add(new LinkedList<>());\n        res.get(depth).add(u);\n        depth++;\n        res.add(new LinkedList<>());\n        visited[u]=true;\n        q.add(u);\n        while(!q.isEmpty()){\n            u = q.poll();\n            Iterator<Integer> li = adj[u].listIterator();\n            while(li.hasNext()){\n                int j = li.next();\n                if(!visited[j]){\n                    visited[j] = true;\n                    res.get(depth).add(j);\n                }\n            }\n            if(q.isEmpty() && !res.get(depth).isEmpty()) {\n                q.addAll(res.get(depth));\n                res.add(new LinkedList<>());\n                depth++;\n            }\n        }\n        return res;\n    }\n\n    public static void main(String[] args) {\n        ListOfDepths g = new ListOfDepths(4);\n        g.addEdge(0,1);\n        g.addEdge(0,2);\n        g.addEdge(1,2);\n        g.addEdge(2,0);\n        g.addEdge(2,3);\n        g.addEdge(3,3);\n        ArrayList<LinkedList<Integer>> res = depthList(2);\n        for(LinkedList<Integer> u : res){\n            Iterator<Integer> li = u.listIterator();\n            while(li.hasNext()){\n                System.out.print(li.next());\n            }\n            System.out.println();\n        }\n    }\n}\n", ".testng.TestNGCucumberRunner;\nimport cucumber.api.testng.CucumberFeatureWrapper;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\n/**\n * An example of using TestNG when the test class does not inherit from \n * AbstractTestNGCucumberTests but still executes each feature as a separate\n * TestNG test.\n */\n@CucumberOptions(format = \"json:target/cucumber-report-feature-composite.json\")\npublic class RunCukesByFeatureAndCompositionTest extends RunCukesByCompositionBase {\n    private TestNGCucumberRunner testNGCucumberRunner;\n\n    @BeforeClass(alwaysRun = true)\n    public void setUpClass() throws Exception {\n        testNGCucumberRunner = new TestNGCucumberRunner(this.getClass());\n    }\n\n    @Test(groups = \"cucumber\", description = \"Runs Cucumber Feature\", dataProvider = \"features\")\n    public void feature(CucumberFeatureWrapper cucumberFeature) {\n        testNGCucumberRunner.runCucumber(cucumberFeature.getCucumberFeature());\n    }\n\n    @DataProvider\n    public Object[][] features() {\n        return testNGCucumberRunner.provideFeatures();\n    }\n\n    @AfterClass(alwaysRun = true)\n    public void tearDownClass() throws Exception {\n        testNGCucumberRunner.finish();\n    }\n}\n", "n;\n\n\nimport android.content.Context;\nimport android.content.pm.ApplicationInfo;\nimport android.content.pm.PackageInfo;\nimport android.content.pm.PackageManager;\nimport android.content.pm.PackageManager.NameNotFoundException;\nimport android.net.ConnectivityManager;\nimport android.net.NetworkInfo;\nimport android.os.Bundle;\nimport android.os.Looper;\nimport android.telephony.TelephonyManager;\nimport android.util.Log;\nimport android.widget.Toast;\n\npublic class ExampleUtil\n{\n    public static final String PREFS_NAME = \"JPUSH_EXAMPLE\";\n    public static final String PREFS_DAYS = \"JPUSH_EXAMPLE_DAYS\";\n    public static final String PREFS_START_TIME = \"PREFS_START_TIME\";\n    public static final String PREFS_END_TIME = \"PREFS_END_TIME\";\n    public static final String KEY_APP_KEY = \"JPUSH_APPKEY\";\n\n    public static boolean isEmpty( String s )\n    {\n        if ( null == s )\n        {\n            return true;\n        }\n        if ( s.length() == 0 )\n        {\n            return true;\n        }\n        if ( s.trim().length() == 0 )\n        {\n            return true;\n        }\n        return false;\n    }\n\n    // \u6821\u9a8cTag Alias \u53ea\u80fd\u662f\u6570\u5b57,\u82f1\u6587\u5b57\u6bcd\u548c\u4e2d\u6587\n    public static boolean isValidTagAndAlias( String s )\n    {\n        Pattern p = Pattern.compile( \"^[\\u4E00-\\u9FA50-9a-zA-Z_-]{0,}$\" );\n        Matcher m = p.matcher( s );\n        return m.matches();\n    }\n\n    // \u53d6\u5f97AppKey\n    public static String getAppKey( Context context )\n    {\n        Bundle metaData = null;\n        String appKey = null;\n        try\n        {\n            ApplicationInfo ai = context.getPackageManager().getApplicationInfo( context.getPackageName(),PackageManager.GET_META_DATA );\n            if ( null != ai )\n            {\n                metaData = ai.metaData;\n            }\n            if ( null != metaData )\n            {\n                appKey = metaData.getString( KEY_APP_KEY );\n                if ( ( null == appKey ) || appKey.length() != 24 )\n                {\n                    appKey = null;\n                }\n            }\n        }\n        catch ( NameNotFoundException e )\n        {\n\n        }\n        return appKey;\n    }\n\n    // \u53d6\u5f97\u7248\u672c\u53f7\n    public static String GetVersion( Context context )\n    {\n        try\n        {\n            PackageInfo manager = context.getPackageManager().getPackageInfo( context.getPackageName(),0 );\n            return manager.versionName;\n        }\n        catch ( NameNotFoundException e )\n        {\n            return \"Unknown\";\n        }\n    }\n\n    public static void showToast( final String toast,final Context context )\n    {\n        new Thread( new Runnable()\n        {\n\n            @Override\n            public void run()\n            {\n                Looper.prepare();\n                Toast.makeText( context,toast,Toast.LENGTH_SHORT ).show();\n                Looper.loop();\n            }\n        } ).start();\n    }\n\n    public static boolean isConnected( Context context )\n    {\n        ConnectivityManager conn = ( ConnectivityManager ) context.getSystemService( Context.CONNECTIVITY_SERVICE );\n        NetworkInfo info = conn.getActiveNetworkInfo();\n        return ( info != null && info.isConnected() );\n    }\n\n    public static String getImei( Context context,String imei )\n    {\n        try\n        {\n            TelephonyManager telephonyManager = ( TelephonyManager ) context.getSystemService( Context.TELEPHONY_SERVICE );\n            imei = telephonyManager.getDeviceId();\n        }\n        catch ( Exception e )\n        {\n            Log.e( ExampleUtil.class.getSimpleName(),e.getMessage() );\n        }\n        return imei;\n    }\n}\n", "ss PlayersList extends TaggedCircleBuffer<PlayerDesc, String> {\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 3755895266829903162L;\n\n\tpublic PlayersList(Iterable<PlayerDesc> buffer, int indx_begin, String tag) {\n\t\tsuper(buffer, indx_begin, tag);\n\t}\n\n\tpublic PlayersList(Iterable<PlayerDesc> buffer, String tag) {\n\t\tsuper(buffer, tag);\n\t}\n\n\tpublic PlayersList() {\n\t\tsuper();\n\t}\n\t\n\tpublic PlayersList getLocalPlayers()\n\t{\n\t\tVector<TaggedValue<PlayerDesc, String>> buffer = getBuffer();\n\t\tPlayersList local = new PlayersList();\n\t\tfor (TaggedValue<PlayerDesc, String> player : buffer ) {\n\t\t\tif ( player.value.isLocal() ) {\n\t\t\t\tlocal.add( player.value, player.tag );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn local;\n\t}\n\n\tpublic PlayersList getRemotePlayers()\n\t{\n\t\tVector<TaggedValue<PlayerDesc, String>> buffer = getBuffer();\n\t\tPlayersList remote = new PlayersList();\n\t\tfor (TaggedValue<PlayerDesc, String> player : buffer ) {\n\t\t\tif ( ! player.value.isLocal() ) {\n\t\t\t\tremote.add( player.value, player.tag );\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn remote;\n\t}\n\t\n\tprivate void add(PlayerDesc value, String tag) {\n\t\tsuper.add( new TaggedValue<PlayerDesc, String>( value, tag) );\n\t}\n\n\tpublic PlayersList clone() throws CloneNotSupportedException\n\t{\n\t\treturn (PlayersList) super.clone();\n\t}\n}\n", "port xss.LinkContainer.XssStruct;\nimport xss.Tasks.XssPreparer;\n\nimport java.io.*;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipInputStream;\n\n/**\n * Created by popka on 26.04.15.\n */\npublic class Reporter {\n\n    private XssContainer xssContainer;\n\n    private final String URL = \"URL\";\n    private final String DATE = \"DATE\";\n    private final String DURATION = \"DURATION\";\n    private final String COUNT = \"COUNT\";\n\n    private final String TYPE = \"TYPE\";\n    private final String FORM_NUMBER = \"FORM_NUMBER\";\n    private final String XSS = \"XSS\";\n\n    private final String REPORT = \"reportStyle.zip\";\n\n    private String header = \"<!DOCTYPE html>\\n\" +\n            \"<html lang=\\\"en\\\" class=\\\"no-js\\\">\\n\" +\n            \"<head>\\n\" +\n            \"<meta charset=\\\"UTF-8\\\" />\\n\" +\n            \"<title>XSS-Scanner \u041e\u0442\u0447\u0435\u0442</title>\\n\" +\n            \"<link rel=\\\"shortcut icon\\\" href=\\\"../favicon.ico\\\">\\n\" +\n            \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"reportStyle/xssScanerReportStyle/css/demo.css\\\" />\\n\" +\n            \"<link rel=\\\"stylesheet\\\" type=\\\"text/css\\\" href=\\\"reportStyle/xssScanerReportStyle/css/component.css\\\" />\\n\" +\n            \"</head>\\n\" +\n            \"<body>\\n\" +\n            \"<div class=\\\"container\\\">\\n\" +\n            \"<header>\\n\" +\n            \"<h1> <em>XSS-Scanner</em>\\n\" +\n            \"</h1>\\n\" +\n            \"</header>\\n\" +\n            \"<div class=\\\"component\\\">\\n\" +\n            \"<div class=\\\"reportInfo\\\">\\n\" +\n            \"<h2>\u041e\u0442\u0447\u0435\u0442</h2>\\n\" +\n            \"<p>\u041f\u0440\u043e\u0432\u0435\u0440\u043a\u0430 url <a href=\\\"\"+URL+\"\\\">\"+URL+\"</a> \u043e\u0442 \" + DATE +\"</p>\\n\" +\n            \"<p>\u041f\u0440\u043e\u0434\u043e\u043b\u0436\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u044c \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \"+DURATION+\"</p>\\n\" +\n            \"<p>\u041e\u0431\u043d\u0430\u0440\u0443\u0436\u0435\u043d\u043e <B>\"+COUNT+\"</B> \u0443\u044f\u0437\u0432\u0438\u043c\u043e\u0441\u0442\u0435\u0439</p>\\n\" +\n            \"</div>\";\n\n    private String tableRowReflected =\n            \"<tr>\\n\" +\n            \"<td>\"+TYPE+\"</td>\\n\" +\n            \"<td><textarea style=\\\"margin: 2px; height: 52px; width: 726px;\\\">\"+XSS+\"</textarea></td>\\n\" +\n            \"</tr>\";\n\n    private String tableHeaderReflected =\n            \"<table>\\n\" +\n            \"<thead>\\n\" +\n            \"<tr>\\n\" +\n            \"<th>\u0422\u0438\u043f \u0443\u044f\u0437\u0432\u0438\u043c\u043e\u0441\u0442\u0438</th>\\n\" +\n            \"<th>Url</th>\\n\" +\n            \"</tr>\\n\" +\n            \"</thead>\\n\" +\n            \"<tbody>\";\n\n    private String tableHeaderStored =\n            \"<table>\\n\" +\n            \"<thead>\\n\" +\n            \"<tr>\\n\" +\n            \"<th>\u0422\u0438\u043f \u0443\u044f\u0437\u0432\u0438\u043c\u043e\u0441\u0442\u0438</th>\\n\" +\n            \"<th>Url</th>\\n\" +\n            \"<th>XSS</th>\\n\" +\n            \"<th>\u041d\u043e\u043c\u0435\u0440 \u0444\u043e\u0440\u043c\u044b</th>\\n\" +\n            \"</tr>\\n\" +\n            \"</thead>\\n\" +\n            \"<tbody>\";\n\n    private String tableRowStored =\n            \"<tr>\\n\" +\n            \"<td>\"+TYPE+\"</td>\\n\" +\n            \"<td>\"+URL+\"</td>\\n\" +\n            \"<td><textarea style=\\\"margin: 2px; height: 94px; width: 329px;\\\">\"+XSS+\"</textarea></td>\\n\" +\n            \"<td style=\\\"text-align:center;\\\">\"+FORM_NUMBER+\"</td>\\n\" +\n            \"</tr>\";\n\n    private String tableFooter =\n            \"</tbody>\\n\" +\n            \"</table>\";\n\n    private String footer =\n            \"</div>\\n\" +\n            \"<script src=\\\"http://ajax.googleapis.com/ajax/libs/jquery/1/jquery.min.js\\\"></script>\\n\" +\n            \"<script src=\\\"http://cdnjs.cloudflare.com/ajax/libs/jquery-throttle-debounce/1.1/jquery.ba-throttle-debounce.min.js\\\"></script>\\n\" +\n            \"<script src=\\\"reportStyle/xssScanerReportStyle/js/jquery.stickyheader.js\\\"></script>\\n\" +\n            \"</body>\\n\" +\n            \"</html>\";\n\n    public Reporter(XssContainer xssContainer) {\n        this.xssContainer = xssContainer;\n    }\n\n    public void generateReport(String url, File directory, String duration) {\n\n\n        String html = replaceHeader(url, duration);\n\n        boolean isFirst = true;\n        for (XssStruct xssStruct:xssContainer) {\n            if (XssStruct.REFLECTED==xssStruct.type) {\n                if (isFirst) {\n                    html += tableHeaderReflected;\n                    isFirst = false;\n                }\n                html += generateTableRow(xssStruct, XssStruct.REFLECTED);\n            }\n        }\n        if (!isFirst)\n            html += tableFooter;\n\n        isFirst = true;\n        for (XssStruct xssStruct:xssContainer) {\n            if (XssStruct.STORED==xssStruct.type) {\n                if (isFirst) {\n                    html += tableHeaderStored;\n                    isFirst = false;\n                }\n                html += generateTableRow(xssStruct, XssStruct.STORED);\n            }\n        }\n        if (!isFirst)\n            html += tableFooter;\n\n\n        html += footer;\n\n        copyJsCssToDirectory(directory);\n        saveFile(html, directory);\n\n    }\n\n    private String replaceHeader(String url, String duration) {\n        header = header.replaceAll(URL, url);\n\n\n        DateFormat dateFormat = new SimpleDateFormat(\"dd MMMM YYYY\", new RussianDateFormatSymbols() );\n        header = header.replace(DATE, dateFormat.format( new Date() ));\n\n        header = header.replace(DURATION, duration);\n        header = header.replace(COUNT, xssContainer.size() + \"\");\n        return header;\n    }\n\n    private String generateTableRow(XssStruct xssStruct, int type) {\n        String generatingTableRow;\n        if (type == XssStruct.REFLECTED) {\n            generatingTableRow = tableRowReflected;\n            generatingTableRow = generatingTableRow.replace(XSS, xssStruct.url.replace(XssPreparer.INPUT_VALUE, xssStruct.xss));\n            generatingTableRow = generatingTableRow.replace(TYPE, \"REFLECTED\");\n        }\n        else {\n            generatingTableRow = tableRowStored;\n            generatingTableRow = generatingTableRow.replace(XSS, xssStruct.xss);\n            generatingTableRow = generatingTableRow.replace(TYPE, \"STORED\");\n            generatingTableRow = generatingTableRow.replace(URL, xssStruct.url);\n            generatingTableRow = generatingTableRow.replace(FORM_NUMBER, xssStruct.form+\"\");\n        }\n\n\n        return generatingTableRow;\n    }\n\n\n\n    private void saveFile(String text, File directory) {\n        DateFormat dateFormat = new SimpleDateFormat(\"HH.mm dd MMMM YYYY\", new RussianDateFormatSymbols() );\n        String formattedDate = dateFormat.format( new Date() );\n\n        if (directory.isDirectory()) {\n            String filePath = directory.getAbsolutePath().toString() +File.separator+ formattedDate + \".html\";\n            File reportHTML = new File(filePath);\n\n            try {\n                PrintWriter writer = new PrintWriter(reportHTML, \"UTF-8\");\n                writer.println(text);\n                writer.close();\n            } catch (FileNotFoundException | UnsupportedEncodingException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    private void copyJsCssToDirectory(File directory) {\n        /*ClassLoader classLoader = getClass().getClassLoader();\n        File reportStyle = new File(classLoader.getResource(REPORT).getFile());\n\n\n\n        DirectoryCopier directoryCopier = new DirectoryCopier();\n\n        try{\n            directoryCopier.copyFolder(reportStyle, directory);\n        }\n        catch(IOException e){\n            e.printStackTrace();\n        }*/\n\n        InputStream is = getClass().getClassLoader().getResourceAsStream(REPORT);\n        ZipInputStream zis = new ZipInputStream(is);\n        ZipEntry entry;\n\n        try {\n            while ((entry = zis.getNextEntry()) != null) {\n\n                // Create a file on HDD in the destinationPath directory\n                // destinationPath is a \"root\" folder, where you want to extract your ZIP file\n                File entryFile = new File(directory, entry.getName());\n                if (entry.isDirectory()) {\n\n                    if (entryFile.exists()) {\n                        System.out.print(\"Directory Already Exist\");\n                    } else {\n                        entryFile.mkdirs();\n                    }\n\n                } else {\n\n                    // Make sure all folders exists (they should, but the safer, the better ;-))\n                    if (entryFile.getParentFile() != null && !entryFile.getParentFile().exists()) {\n                        entryFile.getParentFile().mkdirs();\n                    }\n\n                    // Create file on disk...\n                    if (!entryFile.exists()) {\n                        entryFile.createNewFile();\n                    }\n\n                    // and rewrite data from stream\n                    OutputStream os = null;\n                    try {\n                        os = new FileOutputStream(entryFile);\n                        IOUtils.copy(zis, os);\n                    } finally {\n                        IOUtils.closeQuietly(os);\n                    }\n                }\n            }\n        }\n        catch (IOException e) {\n\n        }\n        finally {\n            IOUtils.closeQuietly(zis);\n        }\n\n    }\n\n}\n\n", "ecraft.util.SoundEvent;\nimport net.minecraftforge.fml.common.registry.GameRegistry;\n\npublic final class BBTweaksSounds {\n\tpublic static void init() {\n\t\tString[] sounds = { \"bbtweaks:iwrench\" };\n\n\t\tfor (String s : sounds) {\n\t\t\tResourceLocation location = new ResourceLocation(s);\n\t\t\tGameRegistry.register(new SoundEvent(location), location);\n\t\t}\n\t}\n\n\tprivate BBTweaksSounds() {\n\t}\n}", "ring[] args) {\n\t\tSystem.out.println(countSegments(\"Hello, my name is John\"));\n\t\tSystem.out.println(countSegments(\"Hello\"));\n\t\tSystem.out.println(countSegments(\"love live! mu'sic forever\"));\n\t\tSystem.out.println(countSegments(\"\"));\n\t\tSystem.out.println(countSegments(\", , , ,        a, eaefa\"));\n\t}\n\n\tpublic static int countSegments(String s) {\n\t\ts = s.trim();\n\t\tString sArr[] = s.split(\" \");\n\t\tint count = 0;\n\t\tfor (int i = 0; i < sArr.length; i++) {\n\t\t\tif (sArr[i].trim().length() > 0)\n\t\t\t\tcount++;\n\t\t}\n\t\treturn count;\n\t}\n\n}\n", "adle plugin from the resource data it found. It\r\n * should not be modified by hand.\r\n */\r\npackage android.support.constraint;\r\n\r\npublic final class R {\r\n    public static final class attr {\r\n        public static final int constraintSet = 0x7f010000;\r\n        public static final int layout_constraintBaseline_creator = 0x7f010004;\r\n        public static final int layout_constraintBaseline_toBaselineOf = 0x7f010005;\r\n        public static final int layout_constraintBottom_creator = 0x7f010006;\r\n        public static final int layout_constraintBottom_toBottomOf = 0x7f010007;\r\n        public static final int layout_constraintBottom_toTopOf = 0x7f010008;\r\n        public static final int layout_constraintDimensionRatio = 0x7f010009;\r\n        public static final int layout_constraintEnd_toEndOf = 0x7f01000a;\r\n        public static final int layout_constraintEnd_toStartOf = 0x7f01000b;\r\n        public static final int layout_constraintGuide_begin = 0x7f01000c;\r\n        public static final int layout_constraintGuide_end = 0x7f01000d;\r\n        public static final int layout_constraintGuide_percent = 0x7f01000e;\r\n        public static final int layout_constraintHeight_default = 0x7f01000f;\r\n        public static final int layout_constraintHeight_max = 0x7f010010;\r\n        public static final int layout_constraintHeight_min = 0x7f010011;\r\n        public static final int layout_constraintHorizontal_bias = 0x7f010012;\r\n        public static final int layout_constraintHorizontal_chainStyle = 0x7f010013;\r\n        public static final int layout_constraintHorizontal_weight = 0x7f010014;\r\n        public static final int layout_constraintLeft_creator = 0x7f010015;\r\n        public static final int layout_constraintLeft_toLeftOf = 0x7f010016;\r\n        public static final int layout_constraintLeft_toRightOf = 0x7f010017;\r\n        public static final int layout_constraintRight_creator = 0x7f010018;\r\n        public static final int layout_constraintRight_toLeftOf = 0x7f010019;\r\n        public static final int layout_constraintRight_toRightOf = 0x7f01001a;\r\n        public static final int layout_constraintStart_toEndOf = 0x7f01001b;\r\n        public static final int layout_constraintStart_toStartOf = 0x7f01001c;\r\n        public static final int layout_constraintTop_creator = 0x7f01001d;\r\n        public static final int layout_constraintTop_toBottomOf = 0x7f01001e;\r\n        public static final int layout_constraintTop_toTopOf = 0x7f01001f;\r\n        public static final int layout_constraintVertical_bias = 0x7f010020;\r\n        public static final int layout_constraintVertical_chainStyle = 0x7f010021;\r\n        public static final int layout_constraintVertical_weight = 0x7f010022;\r\n        public static final int layout_constraintWidth_default = 0x7f010023;\r\n        public static final int layout_constraintWidth_max = 0x7f010024;\r\n        public static final int layout_constraintWidth_min = 0x7f010025;\r\n        public static final int layout_editor_absoluteX = 0x7f010026;\r\n        public static final int layout_editor_absoluteY = 0x7f010027;\r\n        public static final int layout_goneMarginBottom = 0x7f010028;\r\n        public static final int layout_goneMarginEnd = 0x7f010029;\r\n        public static final int layout_goneMarginLeft = 0x7f01002a;\r\n        public static final int layout_goneMarginRight = 0x7f01002b;\r\n        public static final int layout_goneMarginStart = 0x7f01002c;\r\n        public static final int layout_goneMarginTop = 0x7f01002d;\r\n        public static final int layout_optimizationLevel = 0x7f01002e;\r\n    }\r\n    public static final class id {\r\n        public static final int all = 0x7f0b000f;\r\n        public static final int basic = 0x7f0b0010;\r\n        public static final int chains = 0x7f0b0011;\r\n        public static final int none = 0x7f0b0012;\r\n        public static final int packed = 0x7f0b000d;\r\n        public static final int parent = 0x7f0b000a;\r\n        public static final int spread = 0x7f0b000b;\r\n        public static final int spread_inside = 0x7f0b000e;\r\n        public static final int wrap = 0x7f0b000c;\r\n    }\r\n    public static final class styleable {\r\n        public static final int[] ConstraintLayout_Layout = { 0x010100c4, 0x0101011f, 0x01010120, 0x0101013f, 0x01010140, 0x7f010000, 0x7f010004, 0x7f010005, 0x7f010006, 0x7f010007, 0x7f010008, 0x7f010009, 0x7f01000a, 0x7f01000b, 0x7f01000c, 0x7f01000d, 0x7f01000e, 0x7f01000f, 0x7f010010, 0x7f010011, 0x7f010012, 0x7f010013, 0x7f010014, 0x7f010015, 0x7f010016, 0x7f010017, 0x7f010018, 0x7f010019, 0x7f01001a, 0x7f01001b, 0x7f01001c, 0x7f01001d, 0x7f01001e, 0x7f01001f, 0x7f010020, 0x7f010021, 0x7f010022, 0x7f010023, 0x7f010024, 0x7f010025, 0x7f010026, 0x7f010027, 0x7f010028, 0x7f010029, 0x7f01002a, 0x7f01002b, 0x7f01002c, 0x7f01002d, 0x7f01002e };\r\n        public static final int ConstraintLayout_Layout_android_maxHeight = 2;\r\n        public static final int ConstraintLayout_Layout_android_maxWidth = 1;\r\n        public static final int ConstraintLayout_Layout_android_minHeight = 4;\r\n        public static final int ConstraintLayout_Layout_android_minWidth = 3;\r\n        public static final int ConstraintLayout_Layout_android_orientation = 0;\r\n        public static final int ConstraintLayout_Layout_constraintSet = 5;\r\n        public static final int ConstraintLayout_Layout_layout_constraintBaseline_creator = 6;\r\n        public static final int ConstraintLayout_Layout_layout_constraintBaseline_toBaselineOf = 7;\r\n        public static final int ConstraintLayout_Layout_layout_constraintBottom_creator = 8;\r\n        public static final int ConstraintLayout_Layout_layout_constraintBottom_toBottomOf = 9;\r\n        public static final int ConstraintLayout_Layout_layout_constraintBottom_toTopOf = 10;\r\n        public static final int ConstraintLayout_Layout_layout_constraintDimensionRatio = 11;\r\n        public static final int ConstraintLayout_Layout_layout_constraintEnd_toEndOf = 12;\r\n        public static final int ConstraintLayout_Layout_layout_constraintEnd_toStartOf = 13;\r\n        public static final int ConstraintLayout_Layout_layout_constraintGuide_begin = 14;\r\n        public static final int ConstraintLayout_Layout_layout_constraintGuide_end = 15;\r\n        public static final int ConstraintLayout_Layout_layout_constraintGuide_percent = 16;\r\n        public static final int ConstraintLayout_Layout_layout_constraintHeight_default = 17;\r\n        public static final int ConstraintLayout_Layout_layout_constraintHeight_max = 18;\r\n        public static final int ConstraintLayout_Layout_layout_constraintHeight_min = 19;\r\n        public static final int ConstraintLayout_Layout_layout_constraintHorizontal_bias = 20;\r\n        public static final int ConstraintLayout_Layout_layout_constraintHorizontal_chainStyle = 21;\r\n        public static final int ConstraintLayout_Layout_layout_constraintHorizontal_weight = 22;\r\n        public static final int ConstraintLayout_Layout_layout_constraintLeft_creator = 23;\r\n        public static final int ConstraintLayout_Layout_layout_constraintLeft_toLeftOf = 24;\r\n        public static final int ConstraintLayout_Layout_layout_constraintLeft_toRightOf = 25;\r\n        public static final int ConstraintLayout_Layout_layout_constraintRight_creator = 26;\r\n        public static final int ConstraintLayout_Layout_layout_constraintRight_toLeftOf = 27;\r\n        public static final int ConstraintLayout_Layout_layout_constraintRight_toRightOf = 28;\r\n        public static final int ConstraintLayout_Layout_layout_constraintStart_toEndOf = 29;\r\n        public static final int ConstraintLayout_Layout_layout_constraintStart_toStartOf = 30;\r\n        public static final int ConstraintLayout_Layout_layout_constraintTop_creator = 31;\r\n        public static final int ConstraintLayout_Layout_layout_constraintTop_toBottomOf = 32;\r\n        public static final int ConstraintLayout_Layout_layout_constraintTop_toTopOf = 33;\r\n        public static final int ConstraintLayout_Layout_layout_constraintVertical_bias = 34;\r\n        public static final int ConstraintLayout_Layout_layout_constraintVertical_chainStyle = 35;\r\n        public static final int ConstraintLayout_Layout_layout_constraintVertical_weight = 36;\r\n        public static final int ConstraintLayout_Layout_layout_constraintWidth_default = 37;\r\n        public static final int ConstraintLayout_Layout_layout_constraintWidth_max = 38;\r\n        public static final int ConstraintLayout_Layout_layout_constraintWidth_min = 39;\r\n        public static final int ConstraintLayout_Layout_layout_editor_absoluteX = 40;\r\n        public static final int ConstraintLayout_Layout_layout_editor_absoluteY = 41;\r\n        public static final int ConstraintLayout_Layout_layout_goneMarginBottom = 42;\r\n        public static final int ConstraintLayout_Layout_layout_goneMarginEnd = 43;\r\n        public static final int ConstraintLayout_Layout_layout_goneMarginLeft = 44;\r\n        public static final int ConstraintLayout_Layout_layout_goneMarginRight = 45;\r\n        public static final int ConstraintLayout_Layout_layout_goneMarginStart = 46;\r\n        public static final int ConstraintLayout_Layout_layout_goneMarginTop = 47;\r\n        public static final int ConstraintLayout_Layout_layout_optimizationLevel = 48;\r\n        public static final int[] ConstraintSet = { 0x010100c4, 0x010100d0, 0x010100dc, 0x010100f4, 0x010100f5, 0x010100f7, 0x010100f8, 0x010100f9, 0x010100fa, 0x0101031f, 0x01010320, 0x01010321, 0x01010322, 0x01010323, 0x01010324, 0x01010325, 0x01010327, 0x01010328, 0x010103b5, 0x010103b6, 0x010103fa, 0x01010440, 0x7f010004, 0x7f010005, 0x7f010006, 0x7f010007, 0x7f010008, 0x7f010009, 0x7f01000a, 0x7f01000b, 0x7f01000c, 0x7f01000d, 0x7f01000e, 0x7f01000f, 0x7f010010, 0x7f010011, 0x7f010012, 0x7f010013, 0x7f010014, 0x7f010015, 0x7f010016, 0x7f010017, 0x7f010018, 0x7f010019, 0x7f01001a, 0x7f01001b, 0x7f01001c, 0x7f01001d, 0x7f01001e, 0x7f01001f, 0x7f010020, 0x7f010021, 0x7f010022, 0x7f010023, 0x7f010024, 0x7f010025, 0x7f010026, 0x7f010027, 0x7f010028, 0x7f010029, 0x7f01002a, 0x7f01002b, 0x7f01002c, 0x7f01002d };\r\n        public static final int ConstraintSet_android_alpha = 9;\r\n        public static final int ConstraintSet_android_elevation = 21;\r\n        public static final int ConstraintSet_android_id = 1;\r\n        public static final int ConstraintSet_android_layout_height = 4;\r\n        public static final int ConstraintSet_android_layout_marginBottom = 8;\r\n        public static final int ConstraintSet_android_layout_marginEnd = 19;\r\n        public static final int ConstraintSet_android_layout_marginLeft = 5;\r\n        public static final int ConstraintSet_android_layout_marginRight = 7;\r\n        public static final int ConstraintSet_android_layout_marginStart = 18;\r\n        public static final int ConstraintSet_android_layout_marginTop = 6;\r\n        public static final int ConstraintSet_android_layout_width = 3;\r\n        public static final int ConstraintSet_android_orientation = 0;\r\n        public static final int ConstraintSet_android_rotationX = 16;\r\n        public static final int ConstraintSet_android_rotationY = 17;\r\n        public static final int ConstraintSet_android_scaleX = 14;\r\n        public static final int ConstraintSet_android_scaleY = 15;\r\n        public static final int ConstraintSet_android_transformPivotX = 10;\r\n        public static final int ConstraintSet_android_transformPivotY = 11;\r\n        public static final int ConstraintSet_android_translationX = 12;\r\n        public static final int ConstraintSet_android_translationY = 13;\r\n        public static final int ConstraintSet_android_translationZ = 20;\r\n        public static final int ConstraintSet_android_visibility = 2;\r\n        public static final int ConstraintSet_layout_constraintBaseline_creator = 22;\r\n        public static final int ConstraintSet_layout_constraintBaseline_toBaselineOf = 23;\r\n        public static final int ConstraintSet_layout_constraintBottom_creator = 24;\r\n        public static final int ConstraintSet_layout_constraintBottom_toBottomOf = 25;\r\n        public static final int ConstraintSet_layout_constraintBottom_toTopOf = 26;\r\n        public static final int ConstraintSet_layout_constraintDimensionRatio = 27;\r\n        public static final int ConstraintSet_layout_constraintEnd_toEndOf = 28;\r\n        public static final int ConstraintSet_layout_constraintEnd_toStartOf = 29;\r\n        public static final int ConstraintSet_layout_constraintGuide_begin = 30;\r\n        public static final int ConstraintSet_layout_constraintGuide_end = 31;\r\n        public static final int ConstraintSet_layout_constraintGuide_percent = 32;\r\n        public static final int ConstraintSet_layout_constraintHeight_default = 33;\r\n        public static final int ConstraintSet_layout_constraintHeight_max = 34;\r\n        public static final int ConstraintSet_layout_constraintHeight_min = 35;\r\n        public static final int ConstraintSet_layout_constraintHorizontal_bias = 36;\r\n        public static final int ConstraintSet_layout_constraintHorizontal_chainStyle = 37;\r\n        public static final int ConstraintSet_layout_constraintHorizontal_weight = 38;\r\n        public static final int ConstraintSet_layout_constraintLeft_creator = 39;\r\n        public static final int ConstraintSet_layout_constraintLeft_toLeftOf = 40;\r\n        public static final int ConstraintSet_layout_constraintLeft_toRightOf = 41;\r\n        public static final int ConstraintSet_layout_constraintRight_creator = 42;\r\n        public static final int ConstraintSet_layout_constraintRight_toLeftOf = 43;\r\n        public static final int ConstraintSet_layout_constraintRight_toRightOf = 44;\r\n        public static final int ConstraintSet_layout_constraintStart_toEndOf = 45;\r\n        public static final int ConstraintSet_layout_constraintStart_toStartOf = 46;\r\n        public static final int ConstraintSet_layout_constraintTop_creator = 47;\r\n        public static final int ConstraintSet_layout_constraintTop_toBottomOf = 48;\r\n        public static final int ConstraintSet_layout_constraintTop_toTopOf = 49;\r\n        public static final int ConstraintSet_layout_constraintVertical_bias = 50;\r\n        public static final int ConstraintSet_layout_constraintVertical_chainStyle = 51;\r\n        public static final int ConstraintSet_layout_constraintVertical_weight = 52;\r\n        public static final int ConstraintSet_layout_constraintWidth_default = 53;\r\n        public static final int ConstraintSet_layout_constraintWidth_max = 54;\r\n        public static final int ConstraintSet_layout_constraintWidth_min = 55;\r\n        public static final int ConstraintSet_layout_editor_absoluteX = 56;\r\n        public static final int ConstraintSet_layout_editor_absoluteY = 57;\r\n        public static final int ConstraintSet_layout_goneMarginBottom = 58;\r\n        public static final int ConstraintSet_layout_goneMarginEnd = 59;\r\n        public static final int ConstraintSet_layout_goneMarginLeft = 60;\r\n        public static final int ConstraintSet_layout_goneMarginRight = 61;\r\n        public static final int ConstraintSet_layout_goneMarginStart = 62;\r\n        public static final int ConstraintSet_layout_goneMarginTop = 63;\r\n        public static final int[] LinearConstraintLayout = { 0x010100c4 };\r\n        public static final int LinearConstraintLayout_android_orientation = 0;\r\n    }\r\n}\r\n", "blic class ProductInventoryLink {\n\t@JsonProperty(\"ID\")\n\tprivate String id=\"\";\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getProductId() {\n\t\treturn productId;\n\t}\n\tpublic void setProductId(String productId) {\n\t\tthis.productId = productId;\n\t}\n\tpublic String getCompanyId() {\n\t\treturn companyId;\n\t}\n\tpublic void setCompanyId(String companyId) {\n\t\tthis.companyId = companyId;\n\t}\n\tpublic String getUrl() {\n\t\treturn url;\n\t}\n\tpublic void setUrl(String url) {\n\t\tthis.url = url;\n\t}\n\t@JsonProperty(\"ProductId\")\n\tprivate String productId=\"0\";\n\t@JsonProperty(\"CompanyId\")\n\tprivate String companyId=\"\";\n\t@JsonProperty(\"Url\")\n\tprivate String url=\"\";\n\t\n}\n", "otation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n/**\n * If present, this annotation indicates that the class, method or field should\n * be undocumented. This generally indicates that the item is likely going to be\n * subject to incompatible changes or removal, or is otherwise unstable or untested.\n * Items generally should not be hidden if they were ever exposed, but instead should\n * be deprecated and still publicly exposed for one release cycle or more, then either\n * hidden or removed.\n */\n@Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE, ElementType.FIELD, ElementType.METHOD})\n@Retention(RetentionPolicy.RUNTIME)\npublic @interface hide {\n\t/**\n\t * The reason why this element is hidden. This is likely only meant as a type of comment on the element itself,\n\t * but could potentially show up in general documentation in some cases.\n\t * @return \n\t */\n\tString value();\n}\n", "ensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n */\n\n// NOTE: this file is auto-copied from https://github.com/facebook/css-layout\n// @generated SignedSource<<21dab9bd1acf5892ad09370b69b7dd71>>\n\npackage com.facebook.csslayout;\n\npublic enum CSSWrap {\n  NOWRAP,\n  WRAP,\n}\n", "s.Resources;\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapShader;\nimport android.graphics.Canvas;\nimport android.graphics.Paint;\nimport android.graphics.RectF;\n\nimport com.bumptech.glide.load.engine.bitmap_recycle.BitmapPool;\nimport com.bumptech.glide.load.resource.bitmap.BitmapTransformation;\n\n/**\n * Created by Samuel on 16/7/6 10:21\n * Email:xuzhou40@gmail.com\n * desc:\u4f7f\u7528glide\u52a0\u8f7d\u5706\u89d2\u77e9\u5f62\n */\npublic class GlideRoundTransform extends BitmapTransformation {\n\n    private static float radius = 0f;\n\n    public GlideRoundTransform(Context context) {\n        this(context, 4);\n    }\n\n    public GlideRoundTransform(Context context, int dp) {\n        super(context);\n        this.radius = Resources.getSystem().getDisplayMetrics().density * dp;\n    }\n\n    private static Bitmap roundCrop(BitmapPool pool, Bitmap source) {\n        if (source == null) return null;\n\n        Bitmap result = pool.get(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        if (result == null) {\n            result = Bitmap.createBitmap(source.getWidth(), source.getHeight(), Bitmap.Config.ARGB_8888);\n        }\n\n        Canvas canvas = new Canvas(result);\n        Paint paint = new Paint();\n        paint.setShader(new BitmapShader(source, BitmapShader.TileMode.CLAMP, BitmapShader.TileMode.CLAMP));\n        paint.setAntiAlias(true);\n        RectF rectF = new RectF(0f, 0f, source.getWidth(), source.getHeight());\n        canvas.drawRoundRect(rectF, radius, radius, paint);\n        return result;\n    }\n\n    @Override\n    protected Bitmap transform(BitmapPool pool, Bitmap toTransform, int outWidth, int outHeight) {\n        return roundCrop(pool, toTransform);\n    }\n\n    @Override\n    public String getId() {\n        return getClass().getName() + Math.round(radius);\n    }\n}\n", "il.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlElementWrapper;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n@XmlRootElement(name = \"payment_method\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class SpreedlyPaymentMethod {\n\n\tpublic String token;\n\t@XmlElement(name = \"created_at\") public Date createdOn;\n\t@XmlElement(name = \"updated_at\") public Date updatedOn;\n    public String email;\n    public String data;\n    @XmlElement(name = \"storage_state\") public SpreedlyStorageState storageState;\n    @XmlElement(name = \"third_party_token\") public String thirdPartyToken;\n    public boolean test;\n    @XmlElement(name = \"last_four_digits\") public String lastFourDigits;\n    @XmlElement(name = \"first_six_digits\") public String firstSixDigits;\n    @XmlElement(name = \"card_type\") public SpreedlyCardType cardType;\n    @XmlElement(name = \"first_name\") public String firstName;\n    @XmlElement(name = \"last_name\") public String lastName;\n    public Integer month;\n    public Integer year;\n    public String address1;\n    public String address2;\n    public String city;\n    public String state;\n    public String zip;\n    public String country;\n    @XmlElement(name = \"phone_number\") public String phoneNumber;\n    @XmlElement(name = \"shipping_address1\") public String shippingAddress1;\n    @XmlElement(name = \"shipping_address2\") public String shippingAddress2;\n    @XmlElement(name = \"shipping_city\") public String shippingCity;\n    @XmlElement(name = \"shipping_state\") public String shippingState;\n    @XmlElement(name = \"shipping_zip\") public String shippingZip;\n    @XmlElement(name = \"shipping_country\") public String shippingCountry;\n    @XmlElement(name = \"shipping_phone_number\") public String shippingPhoneNumber;\n    @XmlElement(name = \"full_name\") public String fullName;\n    @XmlElement(name = \"eligible_for_card_updater\") public boolean eligibleForCardUpdater;\n    @XmlElement(name = \"payment_method_type\") public SpreedlyPaymentMethodType paymentMethodType;\n    @XmlElement(name = \"verification_value\") public String verificationValue;\n\t@XmlElementWrapper(name = \"errors\")\n\t@XmlElement(name = \"error\")\n\tpublic List<String> errors = new ArrayList<String>();\n\t@XmlElement(name = \"api_urls\") public SpreedlyApiURLs apiUrls;\n    public String number;\n\tpublic String getToken() {\n\t\treturn token;\n\t}\n\tpublic void setToken(final String token) {\n\t\tthis.token = token;\n\t}\n\tpublic Date getCreatedOn() {\n\t\treturn createdOn;\n\t}\n\tpublic void setCreatedOn(final Date createdOn) {\n\t\tthis.createdOn = createdOn;\n\t}\n\tpublic Date getUpdatedOn() {\n\t\treturn updatedOn;\n\t}\n\tpublic void setUpdatedOn(final Date updatedOn) {\n\t\tthis.updatedOn = updatedOn;\n\t}\n\tpublic String getEmail() {\n\t\treturn email;\n\t}\n\tpublic void setEmail(final String email) {\n\t\tthis.email = email;\n\t}\n\tpublic String getData() {\n\t\treturn data;\n\t}\n\tpublic void setData(final String data) {\n\t\tthis.data = data;\n\t}\n\tpublic SpreedlyStorageState getStorageState() {\n\t\treturn storageState;\n\t}\n\tpublic void setStorageState(final SpreedlyStorageState storageState) {\n\t\tthis.storageState = storageState;\n\t}\n\tpublic String getThirdPartyToken() {\n\t\treturn thirdPartyToken;\n\t}\n\tpublic void setThirdPartyToken(final String thirdPartyToken) {\n\t\tthis.thirdPartyToken = thirdPartyToken;\n\t}\n\tpublic boolean isTest() {\n\t\treturn test;\n\t}\n\tpublic void setTest(final boolean test) {\n\t\tthis.test = test;\n\t}\n\tpublic String getLastFourDigits() {\n\t\treturn lastFourDigits;\n\t}\n\tpublic void setLastFourDigits(final String lastFourDigits) {\n\t\tthis.lastFourDigits = lastFourDigits;\n\t}\n\tpublic String getFirstSixDigits() {\n\t\treturn firstSixDigits;\n\t}\n\tpublic void setFirstSixDigits(final String firstSixDigits) {\n\t\tthis.firstSixDigits = firstSixDigits;\n\t}\n\tpublic SpreedlyCardType getCardType() {\n\t\treturn cardType;\n\t}\n\tpublic void setCardType(final SpreedlyCardType cardType) {\n\t\tthis.cardType = cardType;\n\t}\n\tpublic String getFirstName() {\n\t\treturn firstName;\n\t}\n\tpublic void setFirstName(final String firstName) {\n\t\tthis.firstName = firstName;\n\t}\n\tpublic String getLastName() {\n\t\treturn lastName;\n\t}\n\tpublic void setLastName(final String lastName) {\n\t\tthis.lastName = lastName;\n\t}\n\tpublic Integer getMonth() {\n\t\treturn month;\n\t}\n\tpublic void setMonth(final Integer month) {\n\t\tthis.month = month;\n\t}\n\tpublic Integer getYear() {\n\t\treturn year;\n\t}\n\tpublic void setYear(final Integer year) {\n\t\tthis.year = year;\n\t}\n\tpublic String getAddress1() {\n\t\treturn address1;\n\t}\n\tpublic void setAddress1(final String address1) {\n\t\tthis.address1 = address1;\n\t}\n\tpublic String getAddress2() {\n\t\treturn address2;\n\t}\n\tpublic void setAddress2(final String address2) {\n\t\tthis.address2 = address2;\n\t}\n\tpublic String getCity() {\n\t\treturn city;\n\t}\n\tpublic void setCity(final String city) {\n\t\tthis.city = city;\n\t}\n\tpublic String getState() {\n\t\treturn state;\n\t}\n\tpublic void setState(final String state) {\n\t\tthis.state = state;\n\t}\n\tpublic String getZip() {\n\t\treturn zip;\n\t}\n\tpublic void setZip(final String zip) {\n\t\tthis.zip = zip;\n\t}\n\tpublic String getCountry() {\n\t\treturn country;\n\t}\n\tpublic void setCountry(final String country) {\n\t\tthis.country = country;\n\t}\n\tpublic String getPhoneNumber() {\n\t\treturn phoneNumber;\n\t}\n\tpublic void setPhoneNumber(final String phoneNumber) {\n\t\tthis.phoneNumber = phoneNumber;\n\t}\n\tpublic String getShippingAddress1() {\n\t\treturn shippingAddress1;\n\t}\n\tpublic void setShippingAddress1(final String shippingAddress1) {\n\t\tthis.shippingAddress1 = shippingAddress1;\n\t}\n\tpublic String getShippingAddress2() {\n\t\treturn shippingAddress2;\n\t}\n\tpublic void setShippingAddress2(final String shippingAddress2) {\n\t\tthis.shippingAddress2 = shippingAddress2;\n\t}\n\tpublic String getShippingCity() {\n\t\treturn shippingCity;\n\t}\n\tpublic void setShippingCity(final String shippingCity) {\n\t\tthis.shippingCity = shippingCity;\n\t}\n\tpublic String getShippingState() {\n\t\treturn shippingState;\n\t}\n\tpublic void setShippingState(final String shippingState) {\n\t\tthis.shippingState = shippingState;\n\t}\n\tpublic String getShippingZip() {\n\t\treturn shippingZip;\n\t}\n\tpublic void setShippingZip(final String shippingZip) {\n\t\tthis.shippingZip = shippingZip;\n\t}\n\tpublic String getShippingCountry() {\n\t\treturn shippingCountry;\n\t}\n\tpublic void setShippingCountry(final String shippingCountry) {\n\t\tthis.shippingCountry = shippingCountry;\n\t}\n\tpublic String getShippingPhoneNumber() {\n\t\treturn shippingPhoneNumber;\n\t}\n\tpublic void setShippingPhoneNumber(final String shippingPhoneNumber) {\n\t\tthis.shippingPhoneNumber = shippingPhoneNumber;\n\t}\n\tpublic String getFullName() {\n\t\treturn fullName;\n\t}\n\tpublic void setFullName(final String fullName) {\n\t\tthis.fullName = fullName;\n\t}\n\tpublic boolean isEligibleForCardUpdater() {\n\t\treturn eligibleForCardUpdater;\n\t}\n\tpublic void setEligibleForCardUpdater(final boolean eligibleForCardUpdater) {\n\t\tthis.eligibleForCardUpdater = eligibleForCardUpdater;\n\t}\n\tpublic SpreedlyPaymentMethodType getPaymentMethodType() {\n\t\treturn paymentMethodType;\n\t}\n\tpublic void setPaymentMethodType(final SpreedlyPaymentMethodType paymentMethodType) {\n\t\tthis.paymentMethodType = paymentMethodType;\n\t}\n\tpublic String getVerificationValue() {\n\t\treturn verificationValue;\n\t}\n\tpublic void setVerificationValue(final String verificationValue) {\n\t\tthis.verificationValue = verificationValue;\n\t}\n\tpublic List<String> getErrors() {\n\t\treturn errors;\n\t}\n\tpublic void setErrors(final List<String> errors) {\n\t\tthis.errors = errors;\n\t}\n\tpublic SpreedlyApiURLs getApiUrls() {\n\t\treturn apiUrls;\n\t}\n\tpublic void setApiUrls(final SpreedlyApiURLs apiUrls) {\n\t\tthis.apiUrls = apiUrls;\n\t}\n\tpublic String getNumber() {\n\t\treturn number;\n\t}\n\tpublic void setNumber(final String number) {\n\t\tthis.number = number;\n\t}\n\n\n}", "any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage okra.base;\n\nimport java.util.Map;\nimport java.util.Optional;\n\npublic interface Okra<T extends OkraItem> {\n\n    /**\n     * Retrieves a scheduled item from the backend\n     *\n     * @return An optional containing the item if found, otherwise an empty optional\n     */\n    Optional<T> poll();\n\n    /**\n     * Reschedule an item that was previously retrieved from the scheduled items pool\n     *\n     * @param item The item that will be rescheduled\n     * @return The rescheduled item if success, otherwise an empty optional\n     */\n    Optional<T> reschedule(T item);\n\n    /**\n     * Heartbeat an item to prevent that other scheduled item consumers acquire this same item\n     *\n     * @param item The item to heartbeat\n     * @return The updated item if success, otherwise an empty optional\n     */\n    Optional<T> heartbeat(T item);\n\n    /**\n     * Heartbeat an item to prevent that other scheduled item consumers acquire this same item\n     * This operation also updates custom attributes\n     *\n     * @param item The item to heartbeat\n     * @return The updated item if success, otherwise an empty optional\n     */\n    Optional<T> heartbeatAndUpdateCustomAttrs(T item, Map<String, Object> attrs);\n\n    /**\n     * Delete a scheduled item\n     *\n     * @param item The item to be deleted\n     */\n    void delete(T item);\n\n    /**\n     * Schedule an item\n     *\n     * @param item The item to schedule\n     */\n    void schedule(T item);\n\n}\n", "E140\n */\nfinal class k4_e140 {\n    public static final String DATA = \"Acer||\";\n}\n", "NSE.\n */\npackage com.codeup.movies.setup;\n\nimport com.codeup.db.Database;\n\nimport java.io.IOException;\nimport java.sql.Connection;\nimport java.sql.SQLException;\n\nclass MoviesDatabase {\n    private final Connection connection;\n\n    MoviesDatabase(Connection connection) {\n        this.connection = connection;\n    }\n\n    void create(String name) throws SQLException, IOException {\n        Database database = new Database(connection);\n        database.drop(name);\n        database.create(name);\n        database.use(name);\n    }\n}\n", "Iterator;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\nimport play.Logger;\n\nimport com.fasterxml.jackson.core.JsonProcessingException;\nimport com.fasterxml.jackson.databind.JsonNode;\nimport com.fasterxml.jackson.databind.ObjectMapper;\n\n/**\n * Allows one to obtain JSON schema details from an input JSON string.\n */\npublic class JsonSchemaBuilder {\n\n  private JsonSchema _schema = null;\n  private static final Logger.ALogger logger = Logger.of(JsonSchemaBuilder.class);\n\n  public JsonSchemaBuilder(String jsonInput) throws JsonProcessingException, IOException, JsonSchemaTypeException {\n    logger.debug(String.format(\"Attempting to parse schema from incoming JSON:\\n%s\", jsonInput));\n    buildSchema(jsonInput);\n  }\n\n  public JsonSchema getSchema() {\n    return _schema;\n  }\n\n  private void buildSchema(String jsonInput) throws JsonProcessingException, IOException, JsonSchemaTypeException {\n    JsonNode root = new ObjectMapper().readTree(jsonInput);\n    _schema = buildSchema(root);\n  }\n\n  private JsonSchema buildSchema(JsonNode input) throws JsonSchemaTypeException {\n    JsonSchema schema;\n    JsonSchemaType schemaType = null;\n    if (input.hasNonNull(\"type\"))\n      schemaType = lookupType(input.get(\"type\").asText());\n    else\n      throw new JsonSchemaTypeException(\"Missing JSON schema _type\");\n\n    logger.debug(String.format(\"Attempting to build schema for object of _type %s\", schemaType));\n\n    switch (schemaType) {\n      case ARRAY:\n        schema = buildArraySchema(input, new JsonSchemaArray());\n        break;\n      case NUMBER:\n        schema = buildNumberSchema(input, new JsonSchemaNumber());\n        break;\n      case INTEGER:\n        schema = buildIntegerSchema(input, new JsonSchemaInteger());\n        break;\n      case OBJECT:\n        schema = buildObjectSchema(input, new JsonSchemaObject());\n        break;\n      case STRING:\n        schema = buildStringSchema(input, new JsonSchemaString());\n        break;\n      case BOOLEAN:\n        schema = buildBooleanSchema(input, new JsonSchemaBoolean());\n        break;\n      default:\n        throw new JsonSchemaTypeException(\"Cannot establish JSON schema _type for object\");\n    }\n    // add the common attributes\n    return buildCommonSchema(input, schema);\n  }\n\n  private JsonSchema buildCommonSchema(JsonNode input, JsonSchema schema) throws JsonSchemaTypeException {\n    logger.debug(\"Adding common schema attributes\");\n    if (input.hasNonNull(\"title\"))\n      schema.title = input.get(\"title\").asText();\n    if (input.hasNonNull(\"description\"))\n      schema.description = input.get(\"description\").asText();\n    if (input.hasNonNull(\"type\"))\n      schema._type = lookupType(input.get(\"type\").asText());\n\n    // set the required fields\n    if (schema instanceof JsonSchemaObject) {\n      JsonSchemaObject obj = (JsonSchemaObject)schema;\n      if (obj.required != null) {\n        for (String requiredField: obj.required) {\n          if (obj.properties.containsKey(requiredField)) {\n            obj.properties.get(requiredField).required = true;\n          }\n        }\n      }\n    }\n\n    return schema;\n  }\n\n  private JsonSchemaArray buildArraySchema(JsonNode input, JsonSchemaArray schema) throws JsonSchemaTypeException {\n    logger.debug(String.format(\"Building array schema for node: %s\", input.toString()));\n    if (input.hasNonNull(\"maxItems\"))\n      schema.maxItems = input.get(\"maxItems\").asInt();\n    if (input.hasNonNull(\"minItems\"))\n      schema.minItems = input.get(\"minItems\").asInt();\n    if (input.hasNonNull(\"uniqueItems\"))\n      schema.uniqueItems = input.get(\"uniqueItems\").asBoolean();\n    if (input.hasNonNull(\"default\")) {\n      if (!input.get(\"default\").isArray())\n        throw new JsonSchemaTypeException(\"Was expecting array for default value for node\");\n      schema._default = new ArrayList<Object>();\n      JsonNode el;\n      Iterator<JsonNode> it = input.get(\"default\").elements();\n      while (it.hasNext()) {\n        el = it.next();\n        if (el.isInt() || el.isBigInteger())\n          schema._default.add(el.asInt());\n        else if (el.isDouble() || el.isFloat() || el.isFloatingPointNumber() || el.isNumber() || el.isBigDecimal())\n          schema._default.add(el.asDouble());\n        else if (el.isBoolean())\n          schema._default.add(el.asBoolean());\n        else if (el.isTextual())\n          schema._default.add(el.asText());\n      }\n    }\n    if (input.hasNonNull(\"items\")) {\n      if (input.get(\"items\").hasNonNull(\"$ref\")) {\n        schema.itemSchema = input.get(\"items\").get(\"$ref\").asText();\n        // strip off any preceding # characters\n        if (schema.itemSchema.startsWith(\"#\") && schema.itemSchema.length() > 1)\n          schema.itemSchema = schema.itemSchema.substring(1);\n      }\n    }\n    return schema;\n  }\n\n  private JsonSchemaBoolean buildBooleanSchema(JsonNode input, JsonSchemaBoolean schema) {\n    logger.debug(String.format(\"Building boolean schema for node: %s\", input.toString()));\n    if (input.hasNonNull(\"default\"))\n      schema._default = input.get(\"default\").asBoolean();\n    return schema;\n  }\n\n  private JsonSchemaInteger buildIntegerSchema(JsonNode input, JsonSchemaInteger schema) {\n    logger.debug(String.format(\"Building object schema for node: %s\", input.toString()));\n    if (input.hasNonNull(\"multipleOf\"))\n      schema.multipleOf = input.get(\"multipleOf\").asInt();\n    if (input.hasNonNull(\"maximum\"))\n      schema.maximum = input.get(\"maximum\").asInt();\n    if (input.hasNonNull(\"minimum\"))\n      schema.minimum = input.get(\"minimum\").asInt();\n    if (input.hasNonNull(\"default\"))\n      schema._default = input.get(\"default\").asInt();\n    return schema;\n  }\n\n  private JsonSchemaNumber buildNumberSchema(JsonNode input, JsonSchemaNumber schema) {\n    logger.debug(String.format(\"Building number schema for node: %s\", input.toString()));\n    if (input.hasNonNull(\"multipleOf\"))\n      schema.multipleOf = input.get(\"multipleOf\").asDouble();\n    if (input.hasNonNull(\"maximum\"))\n      schema.maximum = input.get(\"maximum\").asDouble();\n    if (input.hasNonNull(\"minimum\"))\n      schema.minimum = input.get(\"minimum\").asDouble();\n    if (input.hasNonNull(\"default\"))\n      schema._default = input.get(\"default\").asDouble();\n    return schema;\n  }\n\n  private JsonSchemaObject buildObjectSchema(JsonNode input, JsonSchemaObject schema) throws JsonSchemaTypeException {\n    JsonNode el;\n\n    logger.debug(String.format(\"Building object schema for node: %s\", input.toString()));\n\n    // if this schema refers to another schema\n    if (input.hasNonNull(\"$ref\")) {\n      schema.ref = input.get(\"$ref\").asText();\n      if (schema.ref.startsWith(\"#\"))\n        schema.ref = schema.ref.substring(1);\n    } else {\n      if (input.hasNonNull(\"required\")) {\n        schema.required = new ArrayList<String>();\n        if (!input.get(\"required\").isArray())\n          throw new JsonSchemaTypeException(\"Expecting array for required property\");\n        logger.debug(String.format(\"Adding required fields: %s\", input.get(\"required\")));\n        Iterator<JsonNode> it = input.get(\"required\").elements();\n        while (it.hasNext()) {\n          el = it.next();\n          logger.debug(String.format(\"Adding required field: %s\", el.asText()));\n          schema.required.add(el.asText());\n        }\n      }\n      if (input.hasNonNull(\"properties\") && input.get(\"properties\").isObject()) {\n        logger.debug(\"Getting properties for object\");\n        schema.properties = new LinkedHashMap<String, JsonSchema>();\n        el = input.get(\"properties\");\n        Iterator<Map.Entry<String, JsonNode>> it = el.fields();\n        while (it.hasNext()) {\n          Map.Entry<String, JsonNode> e = it.next();\n          logger.debug(String.format(\"Adding property %s: %s\", e.getKey(), e.getValue()));\n          schema.properties.put(e.getKey(), buildSchema(e.getValue()));\n        }\n      } else\n        throw new JsonSchemaTypeException(\"Expecting properties for object\");\n      if (input.hasNonNull(\"maxProperties\"))\n        schema.maxProperties = input.get(\"maxProperties\").asInt();\n      if (input.hasNonNull(\"minProperties\"))\n        schema.minProperties = input.get(\"minProperties\").asInt();\n    }\n    return schema;\n  }\n\n  private JsonSchemaString buildStringSchema(JsonNode input, JsonSchemaString schema) {\n    logger.debug(String.format(\"Building string schema for node: %s\", input.toString()));\n    if (input.hasNonNull(\"maxLength\"))\n      schema.maxLength = input.get(\"maxLength\").asInt();\n    if (input.hasNonNull(\"minLength\"))\n      schema.minLength = input.get(\"minLength\").asInt();\n    if (input.hasNonNull(\"pattern\"))\n      schema.pattern = input.get(\"pattern\").asText();\n    if (input.hasNonNull(\"default\"))\n      schema._default = input.get(\"default\").asText();\n    return schema;\n  }\n\n\n  private JsonSchemaType lookupType(String type) throws JsonSchemaTypeException {\n    switch (type.toLowerCase()) {\n      case \"array\": return JsonSchemaType.ARRAY;\n      case \"number\": return JsonSchemaType.NUMBER;\n      case \"null\": return JsonSchemaType.NULL;\n      case \"integer\": return JsonSchemaType.INTEGER;\n      case \"object\": return JsonSchemaType.OBJECT;\n      case \"string\": return JsonSchemaType.STRING;\n      case \"boolean\": return JsonSchemaType.BOOLEAN;\n      default: throw new JsonSchemaTypeException(String.format(\"Invalid JSON schema _type: %s\", type));\n    }\n  }\n\n}\n", "Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.transaction.TransactionConfiguration;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.xander.HWTO.model.entity.Persistent;\nimport org.xander.HWTO.model.entity.User;\nimport org.xander.HWTO.service.UserService;\nimport org.xander.HWTO.validation.annotations.Unique;\n\nimport javax.validation.ConstraintValidator;\nimport javax.validation.ConstraintValidatorContext;\n\n/**\n * Validator fo {@link Unique}. Checks the user uniqueness.\n *\n * @see Unique\n */\n@ContextConfiguration(locations = {\"classpath:/org/xander/HWTO/service/applicationContext-service.xml\", \"classpath:/org/xander/HWTO/model/applicationContext-dao.xml\"})\n@TransactionConfiguration(transactionManager = \"transactionManager\", defaultRollback = true)\n@Transactional\npublic class UserUniqueValidator implements ConstraintValidator<Unique, String> {\n\n    @Autowired\n    public UserUniqueValidator(UserService userService) {\n        this.userService = userService;\n    }\n\n    UserService userService;\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public void initialize(Unique annotation) {\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public boolean isValid(String value, ConstraintValidatorContext context) {\n        return userService.uniquenessNameCheck(value);\n\n    }\n}\n", "class Pair<FIRST, SECOND> {\n\n    public FIRST first;\n    public SECOND second;\n\n    public Pair(FIRST first, SECOND second) {\n        this.first = first;\n        this.second = second;\n    }\n\n    @Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((first == null) ? 0 : first.hashCode());\n\t\tresult = prime * result + ((second == null) ? 0 : second.hashCode());\n\t\treturn result;\n\t}\n\n    @Override\n    public boolean equals(Object object) {\n        if (object instanceof Pair) {\n            Pair<?, ?> pair = (Pair<?, ?>) object;\n            return this.first.equals(pair.first) &&\n                    this.second.equals(pair.second);\n        } else {\n            return false;\n        }\n    }\n}\n", "assword credentials.\n */\npublic class WrongPasswordException extends ServiceException {\n\n    private static final String USER_WRONG_PASSWORD_ERROR_MESSAGE = \"user.wrong.password.error.message\";\n\n    public WrongPasswordException() {\n        super(USER_WRONG_PASSWORD_ERROR_MESSAGE);\n    }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.batchai.v2018_03_01;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Represents a resource ID. For example, for a subnet, it is the resource URL\n * for the subnet.\n */\npublic class ResourceId {\n    /**\n     * The ID of the resource.\n     */\n    @JsonProperty(value = \"id\", required = true)\n    private String id;\n\n    /**\n     * Get the id value.\n     *\n     * @return the id value\n     */\n    public String id() {\n        return this.id;\n    }\n\n    /**\n     * Set the id value.\n     *\n     * @param id the id value to set\n     * @return the ResourceId object itself.\n     */\n    public ResourceId withId(String id) {\n        this.id = id;\n        return this;\n    }\n\n}\n", "ent.res.Resources;\nimport android.graphics.Color;\nimport android.graphics.Paint;\n\npublic class DisplayConfiguration {\n\n    public final int mTextColor = Color.WHITE;\n    public final int mLineColor = Color.WHITE;\n    public final int mPointerColor = Color.parseColor(\"#ffcc33\");\n\n    public final Paint mLinePaint;\n    public final Paint mPointerPaint;\n    public final float mCautionStripeThickness;\n    public final float mThinLineThickness;\n    public final float mThickLineThickness;\n    public final float mVeryThickLineThickness;\n    public final float mPointerShapeSize;\n    public final float mPointerToScaleOffset;\n    public final String mTextTypeface = \"fonts/LiberationSans-Regular.ttf\";\n    public final Resources mResources;\n    public final AssetManager mAssets;\n\n    public DisplayConfiguration(float w, float h, Resources resources, AssetManager assets) {\n        mResources = resources;\n        mAssets = assets;\n        mCautionStripeThickness = (float) Math.floor(w / 100);\n        mThinLineThickness = (float) Math.floor(w / 300);\n        mThickLineThickness = (float) Math.floor(1.75f * mThinLineThickness);\n        mVeryThickLineThickness = (float) Math.floor(2.5f * mThinLineThickness);\n        mPointerShapeSize = (float) Math.floor(w / 30);\n        mPointerToScaleOffset = (float) Math.floor(mPointerShapeSize / 3);\n\n        mLinePaint = new Paint();\n        mLinePaint.setColor(mLineColor);\n        mLinePaint.setAntiAlias(true);\n\n        mPointerPaint = new Paint();\n        mPointerPaint.setColor(mPointerColor);\n        mPointerPaint.setAntiAlias(true);\n    }\n}\n", "\n\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\n\npublic class IteratorIterator<T> implements Iterator<T> {\n\n    final Iterator<Iterator<T>> inputs;\n    Iterator<T> currentIterator;\n\n    public IteratorIterator(final Iterator<Iterator<T>> inputs) {\n        this.inputs = inputs;\n        this.currentIterator = new Iterator<T>() {\n            @Override public boolean hasNext() { return false; }\n            @Override public T next() { throw new NoSuchElementException(); }\n        };\n    }\n\n    public IteratorIterator(final List<Iterator<T>> inputs) {\n        this(inputs.iterator());\n    }\n\n    /**\n     * Ensure that currentIterator points to the next element if one exists.\n     */\n    private void updateCurrentIterator() {\n        while (! currentIterator.hasNext() && inputs.hasNext()) {\n            currentIterator = inputs.next();\n        }\n    }\n\n    @Override public boolean hasNext() {\n        updateCurrentIterator();\n\n        return currentIterator.hasNext();\n    }\n\n    @Override public T next() {\n        updateCurrentIterator();\n\n        return currentIterator.next();\n    }\n}\n", ";\nimport android.app.FragmentTransaction;\nimport android.app.ProgressDialog;\nimport android.os.AsyncTask;\nimport android.os.Bundle;\nimport android.preference.CheckBoxPreference;\nimport android.preference.EditTextPreference;\nimport android.preference.Preference;\nimport android.preference.PreferenceFragment;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.Toolbar;\nimport android.view.View;\nimport android.widget.Toast;\n\nimport org.json.JSONException;\nimport org.json.JSONObject;\nimport org.simpledrive.R;\nimport org.simpledrive.helper.Connection;\nimport org.simpledrive.helper.Preferences;\nimport org.simpledrive.helper.Util;\n\nimport java.lang.ref.WeakReference;\n\npublic class UserDetails extends AppCompatActivity {\n    // General\n    public static PrefsFragment prefsFragment;\n\n    public static String username;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        Bundle extras = getIntent().getExtras();\n        username = extras.getString(\"username\");\n\n        int theme = (Preferences.getInstance(this).read(Preferences.TAG_COLOR_THEME, \"light\").equals(\"light\")) ? R.style.MainTheme_Light : R.style.MainTheme_Dark;\n        setTheme(theme);\n\n        prefsFragment = new PrefsFragment();\n        FragmentManager fragmentManager = getFragmentManager();\n        FragmentTransaction fragmentTransaction = fragmentManager.beginTransaction();\n        fragmentTransaction.replace(R.id.content, prefsFragment).commit();\n\n        setContentView(R.layout.activity_settings);\n\n        initToolbar();\n        setToolbarTitle(username);\n        new GetStatus(username).execute();\n    }\n\n    private void initToolbar() {\n        Toolbar toolbar = (Toolbar) findViewById(R.id.toolbar);\n        if(toolbar != null) {\n            setSupportActionBar(toolbar);\n            toolbar.setNavigationIcon(R.drawable.ic_arrow);\n            toolbar.setNavigationOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    finish();\n                }\n            });\n        }\n    }\n\n    public static class PrefsFragment extends PreferenceFragment {\n        private UserDetails ctx;\n\n        @Override\n        public void onAttach(Activity act) {\n            super.onAttach(act);\n            ctx = (UserDetails) act;\n        }\n        private EditTextPreference quotaMax;\n        private CheckBoxPreference admin;\n\n        @Override\n        public void onCreate(Bundle savedInstanceState) {\n            super.onCreate(savedInstanceState);\n\n            // Load the preferences from an XML resource\n            addPreferencesFromResource(R.xml.settings_userdetails);\n\n            admin = (CheckBoxPreference) findPreference(\"user_admin\");\n            admin.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {\n                @Override\n                public boolean onPreferenceChange(Preference preference, Object o) {\n                    String admin = (o.toString().equals(\"true\")) ? \"1\" : \"0\";\n                    new SetAdmin(ctx, username, admin);\n                    return false;\n                }\n            });\n\n            quotaMax = (EditTextPreference) findPreference(\"user_quota_max\");\n            quotaMax.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {\n                @Override\n                public boolean onPreferenceChange(Preference preference, Object o) {\n                    String value = Long.toString(Util.stringToByte(o.toString()));\n                    new SetQuota(ctx, username, value).execute();\n                    return false;\n                }\n            });\n\n            setSummary(\"username\", username);\n        }\n\n        public void setSummary(String key, String value) {\n            Preference pref = findPreference(key);\n            if (pref != null) {\n                pref.setSummary(value);\n            }\n        }\n\n        public void setChecked(String key, boolean check) {\n            CheckBoxPreference pref = (CheckBoxPreference) findPreference(key);\n            if (pref != null) {\n                pref.setChecked(check);\n            }\n        }\n    }\n\n    private static class GetStatus extends AsyncTask<Void, Void, Connection.Response> {\n        private String username;\n\n        GetStatus(String username) {\n            this.username = username;\n        }\n\n        @Override\n        protected Connection.Response doInBackground(Void... pos) {\n            Connection multipart = new Connection(\"user\", \"get\");\n            multipart.addFormField(\"user\", username);\n\n            return multipart.finish();\n        }\n        @Override\n        protected void onPostExecute(Connection.Response res) {\n            if (res.successful()) {\n                try {\n                    JSONObject job = new JSONObject(res.getMessage());\n                    String admin = job.getString(\"admin\");\n\n                    prefsFragment.setChecked(\"user_admin\", admin.equals(\"1\"));\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            }\n\n            new GetQuota(username).execute();\n        }\n    }\n\n    private static class GetQuota extends AsyncTask<Void, Void, Connection.Response> {\n        private String username;\n\n        GetQuota(String username) {\n            this.username = username;\n        }\n\n        @Override\n        protected Connection.Response doInBackground(Void... pos) {\n            Connection multipart = new Connection(\"user\", \"quota\");\n            multipart.addFormField(\"user\", username);\n\n            return multipart.finish();\n        }\n\n        @Override\n        protected void onPostExecute(Connection.Response res) {\n            if (res.successful()) {\n                try {\n                    JSONObject job = new JSONObject(res.getMessage());\n                    String used = job.getString(\"used\");\n                    String max = job.getString(\"max\");\n\n                    prefsFragment.setSummary(\"user_quota_max\", Util.convertSize(max));\n                    prefsFragment.setSummary(\"user_quota_used\", Util.convertSize(used));\n                } catch (JSONException e1) {\n                    e1.printStackTrace();\n                }\n            }\n        }\n    }\n\n    private static class SetAdmin extends AsyncTask<Void, Void, Connection.Response> {\n        private WeakReference<UserDetails> ref;\n        private String username;\n        private String enable;\n        private ProgressDialog pDialog;\n\n        SetAdmin(UserDetails ctx, String username, String enable) {\n            this.ref = new WeakReference<>(ctx);\n            this.username = username;\n            this.enable = enable;\n        }\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n\n            if (ref.get() != null) {\n                final UserDetails act = ref.get();\n                pDialog = new ProgressDialog(act);\n                pDialog.setMessage(\"Updating...\");\n                pDialog.setIndeterminate(false);\n                pDialog.setCancelable(true);\n                pDialog.show();\n            }\n        }\n\n        @Override\n        protected Connection.Response doInBackground(Void... pos) {\n            Connection multipart = new Connection(\"user\", \"setadmin\");\n            multipart.addFormField(\"user\", username);\n            multipart.addFormField(\"enable\", enable);\n\n            return multipart.finish();\n        }\n\n        @Override\n        protected void onPostExecute(Connection.Response res) {\n            if (ref.get() == null) {\n                return;\n            }\n\n            final UserDetails act = ref.get();\n            pDialog.dismiss();\n            if (res.successful()) {\n                new GetStatus(username).execute();\n            }\n            else {\n                Toast.makeText(act, res.getMessage(), Toast.LENGTH_SHORT).show();\n            }\n        }\n    }\n\n    private static class SetQuota extends AsyncTask<Void, Void, Connection.Response> {\n        private WeakReference<UserDetails> ref;\n        private String username;\n        private String value;\n        private ProgressDialog pDialog;\n\n        SetQuota(UserDetails ctx, String username, String value) {\n            this.ref = new WeakReference<>(ctx);\n            this.username = username;\n            this.value = value;\n        }\n\n        @Override\n        protected void onPreExecute() {\n            super.onPreExecute();\n\n            if (ref.get() != null) {\n                final UserDetails act = ref.get();\n                pDialog = new ProgressDialog(act);\n                pDialog.setMessage(\"Updating...\");\n                pDialog.setIndeterminate(false);\n                pDialog.setCancelable(true);\n                pDialog.show();\n            }\n        }\n\n        @Override\n        protected Connection.Response doInBackground(Void... pos) {\n            Connection multipart = new Connection(\"user\", \"setquota\");\n            multipart.addFormField(\"user\", username);\n            multipart.addFormField(\"value\", value);\n\n            return multipart.finish();\n        }\n\n        @Override\n        protected void onPostExecute(Connection.Response res) {\n            if (ref.get() == null) {\n                return;\n            }\n\n            final UserDetails act = ref.get();\n            pDialog.dismiss();\n            if (res.successful()) {\n                new GetStatus(username).execute();\n            }\n            else {\n                Toast.makeText(act, res.getMessage(), Toast.LENGTH_SHORT).show();\n            }\n        }\n    }\n\n    private void setToolbarTitle(final String title) {\n        if (getSupportActionBar() != null) {\n            getSupportActionBar().setTitle(title);\n        }\n    }\n}", " Register Centre (VRK)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage ee.ria.xroad.common;\n\n/**\n * This interface contains global constants, such as port numbers\n * and configuration locations.\n */\npublic final class PortNumbers {\n    /** Client proxy listens for HTTP queries. */\n    public static final int CLIENT_HTTP_PORT = 80;\n\n    /** Client proxy listens for HTTPS queries. */\n    public static final int CLIENT_HTTPS_PORT = 443;\n\n    /** Port for connection between client and server proxy. */\n    public static final int PROXY_PORT = 5500;\n\n    /** Server proxy listens for OCSP requests. */\n    public static final int PROXY_OCSP_PORT = 5577;\n\n    /** Admin port for proxy. */\n    public static final int ADMIN_PORT = 5566;\n\n    /** Signer listens for HTTP queries. */\n    public static final int SIGNER_PORT = 5558;\n\n    /** Signer Admin port. */\n    public static final int SIGNER_ADMIN_PORT = 5559;\n\n    /** Center-Service HTTP port. */\n    public static final int CENTER_SERVICE_HTTP_PORT = 3333;\n\n    /** Center-Service HTTPS port. */\n    public static final int CENTER_SERVICE_HTTPS_PORT = 3443;\n\n    /** Port for Distributed Files Client. */\n    public static final int CONFIGURATION_CLIENT_PORT = 5665;\n\n    /** Port for Configuration Admin Port. */\n    public static final int CONFIGURATION_CLIENT_ADMIN_PORT = 5675;\n\n    /** Admin port for monitor agents. */\n    public static final int MONITOR_AGENT_ADMIN_PORT = 5588;\n\n    /** Port of the operational monitoring daemon. */\n    public static final int OP_MONITOR_DAEMON_PORT = 2080;\n\n    /** Proxy actorsystem port */\n    public static final int PROXY_ACTORSYSTEM_PORT = 5567;\n\n    private PortNumbers() {\n    }\n}\n", "and the API calls are still\n * rate limited.\n */\npublic class RateLimitException extends Exception {\n\n  private final Request request;\n  private final int retryCount;\n\n  /**\n   * Construct a new exception.\n   *\n   * @param request the originating request object.\n   * @param retryCount the number of times a retry was attempted.\n   */\n  public RateLimitException(Request request, int retryCount) {\n    this.request = request;\n    this.retryCount = retryCount;\n  }\n\n  /**\n   * Get the originating request object.\n   *\n   * @return the request object.\n   */\n  public Request getRequest() {\n    return this.request;\n  }\n\n  /**\n   * Get the number of times the action was attempted.\n   *\n   * @return the retry count.\n   */\n  public int getRetryCount() {\n    return this.retryCount;\n  }\n}\n", "mport javafx.event.EventHandler;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.media.MediaPlayer;\nimport javafx.util.Duration;\n\npublic class EventRowClicked implements EventHandler<MouseEvent> {\n\n    @Override\n    public void handle(MouseEvent e) {\n        if (e.getButton() == MouseButton.PRIMARY) {\n            if (e.getClickCount() >= 2 && MediaManager.instance.getLibraryView().getSelectionModel().getSelectedItem() != null) {\n\n                MediaManager.errorHandler.logDebug(\"LibraryRowFactory.mouseClicked dblClick detected\");\n\n                if (MediaManager.instance.getLibraryView().getSelectionModel().getSelectedIndex() == MediaManager.instance.getMediaId().get()) {\n                    MediaManager.instance.getPlayer().seek(new Duration(0));\n                    return;\n                }\n                if (MediaManager.instance.getPlayer() != null && MediaManager.instance.getPlayer().getStatus() == MediaPlayer.Status.PLAYING) {\n                    MediaManager.instance.onSongStopped();\n                }\n\n                // Sidebar Playing Playlist Highlighting\n                MediaManager.instance.refreshCurrentPlayingListSidebar();\n                MediaManager.instance.onSongPlay(MediaManager.instance.getLibraryView().getSelectionModel().getSelectedItem());\n            }\n        }\n    }\n\n}\n", "aterial;\nimport org.bukkit.entity.Player;\nimport org.bukkit.inventory.ItemStack;\nimport org.bukkit.inventory.PlayerInventory;\n\nimport me.egg82.hme.lists.GlowMaterialSet;\nimport me.egg82.hme.lists.GlowSet;\nimport me.egg82.hme.reflection.light.ILightHelper;\nimport ninja.egg82.bukkit.handlers.TickHandler;\nimport ninja.egg82.bukkit.utils.CommandUtil;\nimport ninja.egg82.concurrent.IConcurrentSet;\nimport ninja.egg82.patterns.ServiceLocator;\n\npublic class GlowTickCommand extends TickHandler {\n\t//vars\n\tprivate IConcurrentSet<UUID> glowSet = ServiceLocator.getService(GlowSet.class);\n\tprivate IConcurrentSet<Material> glowMaterialSet = ServiceLocator.getService(GlowMaterialSet.class);\n\tprivate ILightHelper lightHelper = ServiceLocator.getService(ILightHelper.class);\n\t\n\t//constructor\n\tpublic GlowTickCommand() {\n\t\tsuper(0L, 5L);\n\t}\n\t\n\t//public\n\t\n\t//private\n\tprotected void onExecute(long elapsedMilliseconds) {\n\t\tfor (UUID key : glowSet) {\n\t\t\te(key, CommandUtil.getPlayerByUuid(key));\n\t\t}\n\t}\n\tprivate void e(UUID uuid, Player player) {\n\t\tif (player == null) {\n\t\t\treturn;\n\t\t}\n\t\t\n\t\tPlayerInventory inv = player.getInventory();\n\t\tItemStack helmet = inv.getHelmet();\n\t\t\n\t\tif (helmet == null || !glowMaterialSet.contains(helmet.getType())) {\n\t\t\tLocation loc = player.getLocation().clone();\n\t\t\tloc.setX(loc.getBlockX() + 0.5d);\n\t\t\tloc.setY(loc.getBlockY() + 1.0d);\n\t\t\tloc.setZ(loc.getBlockZ() + 0.5d);\n\t\t\tlightHelper.removeLight(loc, false);\n\t\t\t\n\t\t\tglowSet.remove(uuid);\n\t\t}\n\t}\n}\n", "bservable;\n\nimport command.display.Display;\nimport command.display.DisplayCommands;\nimport javafx.scene.paint.Color;\nimport model.data.ActiveTurtles;\nimport model.data.TurtleData;\nimport model.turtleinfo.Pen;\n\n/**\n *\n * @author Sally Al\n *\n */\npublic class TurtleDisplayObserver extends DisplayCommandObserver {\n\n\tprivate static final long serialVersionUID = -350004370138167591L;\n\tTurtleData data;\n\n\tpublic TurtleDisplayObserver(TurtleData turtleData) {\n\t\tsuper(turtleData);\n\t\tthis.data = turtleData;\n\t}\n\n\t@Override\n\tpublic void update(Observable o, Object arg) {\n\n\t\tDisplayCommands observedClass = (DisplayCommands) o;\n\t\tMap<Display, List<Double>> map=observedClass.getMap();\n\n\t\tif(map.get(Display.SETPC)!=null){\n\t\t\tfor(int i = 0; i<getCurrent().size();i++){\n\t\t\t\tint turt = getCurrent().activeTurtleListValue(i);\n\t\t\t\tgetPen(turt).setColor(Color.web(myColors.get(map.get(Display.SETPC).get(0).intValue())));\n\t\t\t}\n\t\t}\n\t\tif(map.get(Display.SETPS)!=null){\n\t\t\tfor(int i = 0; i<getCurrent().size();i++){\n\t\t\t\tint turt = getCurrent().activeTurtleListValue(i);\n\t\t\t\tgetPen(turt).setThickness(map.get(Display.SETPS).get(0).intValue());\n\t\t\t}\n\t\t}\n\t\tif(map.get(Display.SETSH)!=null){\n\t\t\tfor(int i = 0; i<getCurrent().size();i++){\n\t\t\t\tint turt = getCurrent().activeTurtleListValue(i);\n\t\t\t\tgetPen(turt).setDashes(map.get(Display.SETPS).get(0));\n\t\t\t}\n\t\t}\n\n\n\n\t}\n\n\tprivate ActiveTurtles getCurrent() {\n\t\treturn data.prepareActiveTurtles();\n\t}\n\n\tprivate Pen getPen(int turt) {\n\t\treturn data.myTurtles().getAllTurtles().get(turt).getPen();\n\t}\n\n}\n", ";\n\nimport org.apache.maven.plugin.AbstractMojo;\nimport org.apache.maven.plugin.MojoExecutionException;\n\n/**\n * \n * @author stephane.manciot@ebiznext.com\n * @goal time\n */\npublic class TimeMojo extends AbstractMojo\n{\n    /**\n     * Date format to use\n     * \n     * @parameter expression=\"${display.timeFormat}\" default-value=\"dd/MM/yyyy HH:mm:ss\"\n     * @required\n     */\n    protected String timeFormat;\n\n    public void execute() throws MojoExecutionException\n    {\n        super.getLog().info(new SimpleDateFormat(timeFormat).format(new Date()));\n    }\n\n}\n", "xtends Repository<User> {\n    User create(User user);\n\n    User update(User user);\n\n    void remove(int id);\n\n    int getNumberOfUsers();\n}\n", "ays;\nimport java.util.Collection;\n\nimport org.junit.Test;\nimport org.junit.runners.Parameterized;\n\nimport com.microsoft.bingads.internal.functionalinterfaces.BiConsumer;\nimport com.microsoft.bingads.v12.api.test.entities.ad_extension.review.BulkReviewAdExtensionTest;\nimport com.microsoft.bingads.v12.bulk.entities.BulkReviewAdExtension;\n\npublic class BulkReviewAdExtensionWriteToRowValuesTextTest extends BulkReviewAdExtensionTest {\n\n    @Parameterized.Parameter(value = 1)\n    public String expectedResult;\n\n    @Parameterized.Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(new Object[][]{\n                {\"Display Text string\", \"Display Text string\"},\n                {null, null}\n        });\n    }\n\n    @Test\n    public void testWrite() {\n        this.testWriteProperty(\"Text\", this.datum, this.expectedResult, new BiConsumer<BulkReviewAdExtension, String>() {\n            @Override\n            public void accept(BulkReviewAdExtension c, String v) {\n                c.getReviewAdExtension().setText(v);\n            }\n        });\n    }\n}\n", "rt java.awt.Graphics2D;\nimport java.awt.image.BufferedImage;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.vitrivr.cineast.art.modules.abstracts.AbstractVisualizationModule;\nimport org.vitrivr.cineast.art.modules.visualization.VisualizationResult;\nimport org.vitrivr.cineast.art.modules.visualization.VisualizationType;\nimport org.vitrivr.cineast.core.data.providers.primitive.PrimitiveTypeProvider;\nimport org.vitrivr.cineast.core.db.DBSelector;\nimport org.vitrivr.cineast.core.util.web.ImageParser;\n\n/**\n * Created by sein on 02.09.16.\n */\npublic class VisualizationDominantEdgeGrid16 extends AbstractVisualizationModule {\n  public VisualizationDominantEdgeGrid16() {\n    super();\n    tableNames.put(\"DominantEdgeGrid16\", \"features_DominantEdgeGrid16\");\n  }\n\n  private static final Logger LOGGER = LogManager.getLogger();\n\n  @Override\n  public String getDisplayName() {\n    return \"VisualizationDominantEdgeGrid16\";\n  }\n\n  @Override\n  public String visualizeSegment(String segmentId) {\n    DBSelector selector = selectors.get(\"DominantEdgeGrid16\");\n    List<Map<String, PrimitiveTypeProvider>> result = selector.getRows(\"id\", segmentId);\n\n    BufferedImage image = new BufferedImage(512, 512, BufferedImage.TYPE_INT_RGB);\n    Graphics2D graph = image.createGraphics();\n    GradientPaint gradient;\n\n    for (Map<String, PrimitiveTypeProvider> row : result) {\n      float[] arr = row.get(\"feature\").getFloatArray();\n      for (int x = 0; x < 16; x++) {\n        for (int y = 0; y < 16; y++) {\n          switch ((int) arr[x * 16 + y]) {\n            case -10:\n              graph.setColor(Color.lightGray);\n              break;\n            case 2:\n              gradient = new GradientPaint(x * 32, y * 32 + 16, Color.white, x * 32 + 32, y * 32 + 16, Color.black);\n              graph.setPaint(gradient);\n              break;\n            case 3:\n              gradient = new GradientPaint(x * 32, y * 32, Color.white, x * 32 + 32, y * 32 + 32, Color.black);\n              graph.setPaint(gradient);\n              break;\n            case 0:\n              gradient = new GradientPaint(x * 32 + 16, y * 32, Color.white, x * 32 + 16, y * 32 + 32, Color.black);\n              graph.setPaint(gradient);\n              break;\n            case 1:\n              gradient = new GradientPaint(x * 32, y * 32 + 32, Color.white, x * 32 + 32, y * 32, Color.black);\n              graph.setPaint(gradient);\n              break;\n          }\n          graph.fillRect(x * 32, y * 32, 32, 32);\n        }\n      }\n    }\n    graph.dispose();\n\n    return ImageParser.BufferedImageToDataURL(image, \"png\");\n  }\n\n\n  @Override\n  public List<VisualizationType> getVisualizations() {\n    List<VisualizationType> types = new ArrayList<>();\n    types.add(VisualizationType.VISUALIZATION_SEGMENT);\n    return types;\n  }\n\n  @Override\n  public VisualizationResult getResultType() {\n    return VisualizationResult.IMAGE;\n  }\n}\n", "content.Context;\nimport android.database.Cursor;\nimport android.database.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\nimport org.greenrobot.eventbus.EventBus;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport testsample.altvr.com.testsample.events.SavedPhotosEvent;\nimport testsample.altvr.com.testsample.vo.PhotoVo;\n\n/**\n * Created by tejus on 4/14/2016.\n */\npublic class DatabaseUtil extends SQLiteOpenHelper {\n    private LogUtil log = new LogUtil(DatabaseUtil.class);\n\n    private static final int DATABASE_VERSION = 2;\n    //DB and tables\n    private static final String DATABASE_NAME = \"imagesearcher.db\";\n    private static final String TABLE_PHOTOS = \"photos\";\n\n    //Columns for Images table\n    private static final String KEY_PHOTO_ID = \"id\";\n    private static final String KEY_PHOTO = \"photo\";\n    private static final String KEY_TAGS = \"tags\";\n    private static final String KEY_LIKES = \"likes\";\n    private static final String KEY_VIEWS = \"views\";\n    private static final String KEY_USER_PHOTO = \"userphoto\";\n    private static final String KEY_USER_NAME = \"username\";\n    private static final String KEY_COMMENTS = \"comments\";\n\n    SQLiteDatabase mDb;\n\n    public DatabaseUtil(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase db) {\n        String IMAGES_TABLE = \"CREATE TABLE \" + TABLE_PHOTOS + \"(\"\n                            + KEY_PHOTO_ID + \" INTEGER PRIMARY KEY,\"\n                            + KEY_PHOTO + \" TEXT,\"\n                            + KEY_TAGS + \" TEXT,\"\n                            + KEY_LIKES + \" TEXT,\"\n                            + KEY_VIEWS + \" TEXT,\"\n                            + KEY_USER_PHOTO + \" TEXT,\"\n                            + KEY_USER_NAME + \" TEXT,\"\n                            + KEY_COMMENTS + \" TEXT\" +\")\";\n        db.execSQL(IMAGES_TABLE);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {\n        db.execSQL(\"DROP TABLE IF EXISTS \" + TABLE_PHOTOS);\n        onCreate(db);\n    }\n\n    /**\n     * YOUR CODE HERE\n     *\n     * For part 1b, you should fill in the various CRUD operations below to manipulate the db\n     * returned by getWritableDatabase() to store/load photos.\n     */\n    public boolean create(PhotoVo photoVo) {\n\n        log.d(\"creating data for \" + photoVo.id);\n\n        ContentValues values = new ContentValues();\n\n        values.put(KEY_PHOTO_ID, photoVo.id);\n        values.put(KEY_PHOTO, photoVo.webformatURL);\n        values.put(KEY_TAGS, photoVo.tags);\n        values.put(KEY_LIKES, photoVo.likes);\n        values.put(KEY_VIEWS, photoVo.views);\n        values.put(KEY_USER_PHOTO, photoVo.userImageURL);\n        values.put(KEY_USER_NAME, photoVo.user);\n        values.put(KEY_COMMENTS, photoVo.comments);\n\n        mDb = getWritableDatabase();\n        long id = mDb.insert(TABLE_PHOTOS, null, values);\n        mDb.close();\n\n        return id>0;\n    }\n\n    public boolean checkRecordExists(String photoId) {\n\n        log.d(\"check if photo id \" + photoId + \" exists\");\n\n        String sql =\"SELECT \"+KEY_PHOTO_ID+\" FROM \"+TABLE_PHOTOS+\" WHERE \"+KEY_PHOTO_ID+\"=\"+photoId;\n\n        mDb = getWritableDatabase();\n        Cursor cursor = mDb.rawQuery(sql, null);\n        boolean exists = cursor.getCount()>0;\n        cursor.close();\n        mDb.close();\n        return exists;\n    }\n\n    public boolean delete(PhotoVo photoVo) {\n\n        boolean deleteSuccessful = false;\n\n        mDb = getWritableDatabase();\n        deleteSuccessful = mDb.delete(TABLE_PHOTOS, KEY_PHOTO_ID+\" ='\" + photoVo.id + \"'\", null) > 0;\n        mDb.close();\n\n        return deleteSuccessful;\n    }\n\n    public boolean update(PhotoVo photoVo) {\n\n        ContentValues values = new ContentValues();\n\n        values.put(KEY_PHOTO_ID, photoVo.id);\n        values.put(KEY_PHOTO, photoVo.webformatURL);\n        values.put(KEY_TAGS, photoVo.tags);\n        values.put(KEY_LIKES, photoVo.likes);\n        values.put(KEY_VIEWS, photoVo.views);\n        values.put(KEY_USER_PHOTO, photoVo.userImageURL);\n        values.put(KEY_USER_NAME, photoVo.user);\n        values.put(KEY_COMMENTS, photoVo.comments);\n\n        String where = KEY_PHOTO_ID+\" = ?\";\n\n        String[] whereArgs = { photoVo.id };\n\n        mDb = getWritableDatabase();\n\n        boolean updateSuccessful = mDb.update(TABLE_PHOTOS, values, where, whereArgs) > 0;\n        mDb.close();\n\n        return updateSuccessful;\n    }\n\n    public List<PhotoVo> readAll() {\n\n        log.d(\"Read all data from db \");\n\n        List<PhotoVo> recordsList = new ArrayList<>();\n\n        String sql = \"SELECT * FROM \"+TABLE_PHOTOS+\" ORDER BY \"+KEY_PHOTO_ID+\" DESC\";\n\n        mDb = getWritableDatabase();\n        Cursor cursor = mDb.rawQuery(sql, null);\n\n        if (cursor.moveToFirst()) {\n            do {\n                int id = cursor.getInt(cursor.getColumnIndex(KEY_PHOTO_ID));\n                String photo = cursor.getString(cursor.getColumnIndex(KEY_PHOTO));\n                String tags = cursor.getString(cursor.getColumnIndex(KEY_TAGS));\n                String likes = cursor.getString(cursor.getColumnIndex(KEY_LIKES));\n                String views = cursor.getString(cursor.getColumnIndex(KEY_VIEWS));\n                String user_photo = cursor.getString(cursor.getColumnIndex(KEY_USER_PHOTO));\n                String user_name = cursor.getString(cursor.getColumnIndex(KEY_USER_NAME));\n                String comments_count = cursor.getString(cursor.getColumnIndex(KEY_COMMENTS));\n\n                PhotoVo photoVo = new PhotoVo();\n                photoVo.id = Integer.toString(id);\n                photoVo.webformatURL = photo;\n                photoVo.tags = tags;\n                photoVo.likes = likes!=null&&likes!=\"\"?Integer.parseInt(likes):0;\n                photoVo.views = views!=null&&views!=\"\"?Integer.parseInt(views):0;\n                photoVo.userImageURL = user_photo;\n                photoVo.user = user_name;\n                photoVo.comments = comments_count!=null&&comments_count!=\"\"?Integer.parseInt(comments_count):0;\n\n                recordsList.add(photoVo);\n\n            } while (cursor.moveToNext());\n        }\n\n        cursor.close();\n        mDb.close();\n\n        SavedPhotosEvent savedPhotosEvent = new SavedPhotosEvent(recordsList);\n        EventBus.getDefault().post(savedPhotosEvent);\n\n        return recordsList;\n    }\n\n    public int getCount() {\n\n        mDb = getWritableDatabase();\n\n        String sql = \"SELECT * FROM \"+TABLE_PHOTOS;\n        int recordCount = mDb.rawQuery(sql, null).getCount();\n        mDb.close();\n\n        return recordCount;\n    }\n}\n", "to license terms.\n *\n * This file is available and licensed under the following license:\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n *\n *  - Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in\n *    the documentation and/or other materials provided with the distribution.\n *  - Neither the name of Oracle Corporation nor the names of its\n *    contributors may be used to endorse or promote products derived\n *    from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\npackage ensemble.samples.controls.text;\n\nimport ensemble.Sample;\nimport javafx.scene.control.TextField;\n\n/**\n * Demonstrates a TextField control that allows you to enter text.\n *\n * @see javafx.scene.control.TextField\n */\npublic class TextFieldSample extends Sample {\n    public TextFieldSample() {\n        TextField text = new TextField(\"Text\");\n        text.setMaxSize(140, 20);\n        getChildren().add(text);\n    }\n}", "xception;\nimport xyz.jacobclark.exceptions.NotPlayersTurnException;\nimport xyz.jacobclark.exceptions.PositionOccupiedException;\nimport xyz.jacobclark.exceptions.PositionOutOfBoundsException;\nimport xyz.jacobclark.models.PebbleType;\nimport xyz.jacobclark.models.Piece;\nimport xyz.jacobclark.rules.Rules;\nimport xyz.jacobclark.rules.impl.GomokuRules;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static junit.framework.TestCase.assertFalse;\nimport static org.junit.Assert.assertTrue;\n\npublic class GomokuRulesTest {\n    Rules gomokuRules = new GomokuRules();\n\n    @Test\n    public void canExecuteAValidMove() throws PositionOutOfBoundsException, PositionOccupiedException, NotPlayersTurnException {\n        boolean result = gomokuRules.validateThatMoveIsLegal(new ArrayList<>(), new Piece(PebbleType.BLACK, 15, 15));\n        assertTrue(result);\n    }\n\n    @Test(expected = PositionOccupiedException.class)\n    public void canNotPlaceAStoneAtGivenPositionOnBoard_WhenAStoneIsAlreadyPlacedThere() throws PositionOccupiedException, PositionOutOfBoundsException, NotPlayersTurnException {\n        List<Piece> pieces = new ArrayList<>();\n        pieces.add(new Piece(PebbleType.BLACK, 0, 0));\n\n        gomokuRules.validateThatMoveIsLegal(pieces, new Piece(PebbleType.BLACK, 0, 0));\n    }\n\n    @Test(expected = PositionOutOfBoundsException.class)\n    public void canNotPlaceAStoneAtGivenPositionOnBoard_WhenItIsInAnNonExistentUpperBoundColumn() throws PositionOutOfBoundsException, PositionOccupiedException, NotPlayersTurnException {\n        gomokuRules.validateThatMoveIsLegal(new ArrayList<>(), new Piece(PebbleType.BLACK, 16, 15));\n    }\n\n    @Test(expected = PositionOutOfBoundsException.class)\n    public void canNotPlaceAStoneAtGivenPositionOnBoard_WhenItIsInAnNonExistentUpperBoundRow() throws PositionOutOfBoundsException, PositionOccupiedException, NotPlayersTurnException {\n        gomokuRules.validateThatMoveIsLegal(new ArrayList<>(), new Piece(PebbleType.BLACK, 15, 16));\n    }\n\n    @Test(expected = PositionOutOfBoundsException.class)\n    public void canNotPlaceAStoneAtGivenPositionOnBoard_WhenItIsInAnNonExistentLowerBoundColumn() throws PositionOutOfBoundsException, PositionOccupiedException, NotPlayersTurnException {\n        gomokuRules.validateThatMoveIsLegal(new ArrayList<>(), new Piece(PebbleType.BLACK, -16, 15));\n\n    }\n\n    @Test(expected = PositionOutOfBoundsException.class)\n    public void canNotPlaceAStoneAtGivenPositionOnBoard_WhenItIsInAnNonExistentLowerBoundRow() throws PositionOutOfBoundsException, PositionOccupiedException, NotPlayersTurnException {\n        gomokuRules.validateThatMoveIsLegal(new ArrayList<>(), new Piece(PebbleType.BLACK, 15, -16));\n    }\n\n    @Test(expected = NotPlayersTurnException.class)\n    public void canNotPlaceSameColouredStoneTwiceInARow() throws Exception, PositionOccupiedException, NotPlayersTurnException {\n        ArrayList<Piece> pieces = new ArrayList<>();\n        pieces.add(new Piece(PebbleType.BLACK, 0, 0));\n        pieces.add(new Piece(PebbleType.WHITE, 0, 1));\n        pieces.add(new Piece(PebbleType.BLACK, 0, 2));\n\n        gomokuRules.validateThatMoveIsLegal(pieces, new Piece(PebbleType.BLACK, 0, 3));\n    }\n\n    @Test(expected = NotPlayersTurnException.class)\n    public void canNotPlaceBlackStone_WhenBlackHasJustBeenPlaced() throws Exception, PositionOccupiedException, NotPlayersTurnException {\n        ArrayList<Piece> pieces = new ArrayList<>();\n        pieces.add(new Piece(PebbleType.BLACK, 0, 0));\n\n        gomokuRules.validateThatMoveIsLegal(pieces, new Piece(PebbleType.BLACK, 0, 1));\n    }\n\n    @Test(expected = NotPlayersTurnException.class)\n    public void canNotPlaceWhiteStone_WhenWhiteHasJustBeenPlaced_AfterSeveralMoves() throws Exception, PositionOccupiedException, NotPlayersTurnException {\n        ArrayList<Piece> pieces = new ArrayList<>();\n        pieces.add(new Piece(PebbleType.WHITE, 0, 0));\n        pieces.add(new Piece(PebbleType.BLACK, 0, 1));\n        pieces.add(new Piece(PebbleType.WHITE, 0, 2));\n\n        gomokuRules.validateThatMoveIsLegal(pieces, new Piece(PebbleType.WHITE, 0, 3));\n    }\n\n    @Test(expected = NotPlayersTurnException.class)\n    public void canNotPlaceAWhiteStoneFirst() throws Exception, PositionOccupiedException, NotPlayersTurnException {\n        ArrayList<Piece> pieces = new ArrayList<>();\n\n        gomokuRules.validateThatMoveIsLegal(pieces, new Piece(PebbleType.WHITE, 0, 0));\n    }\n\n    @Test(expected = GameWonException.class)\n    public void throwsGameWonException_WhenGameIsWonHorizontally() throws Exception {\n        ArrayList<Piece> pieces = new ArrayList<>();\n        pieces.add(new Piece(PebbleType.WHITE, 0, 0));\n        pieces.add(new Piece(PebbleType.WHITE, 1, 0));\n        pieces.add(new Piece(PebbleType.WHITE, 2, 0));\n        pieces.add(new Piece(PebbleType.WHITE, 3, 0));\n        pieces.add(new Piece(PebbleType.WHITE, 4, 0));\n\n        gomokuRules.validateThatGameIsWin(pieces);\n    }\n\n    @Test\n    public void returnsFalse_WhenGameIsNotWonYet() throws Exception {\n        ArrayList<Piece> pieces = new ArrayList<>();\n        pieces.add(new Piece(PebbleType.WHITE, 0, 0));\n\n        assertFalse(gomokuRules.validateThatGameIsWin(pieces));\n    }\n}\n", " java.io.InputStreamReader;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Type;\n\nimport javax.ws.rs.Consumes;\nimport javax.ws.rs.ProcessingException;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.WebApplicationException;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.MultivaluedMap;\nimport javax.ws.rs.ext.MessageBodyReader;\nimport javax.ws.rs.ext.MessageBodyWriter;\nimport javax.ws.rs.ext.Provider;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.protobuf.Message;\nimport com.google.protobuf.util.JsonFormat;\n\n@Provider\n@Produces(ProtobufBinaryProvider.TYPE_APPLICATION_X_PROTOBUF)\npublic class ProtobufBinaryProvider implements MessageBodyWriter<Message> {\n\tpublic static final String TYPE_APPLICATION_X_PROTOBUF = \"application/x-protobuf\";\n    JsonFormat.Printer printer = JsonFormat.printer().omittingInsignificantWhitespace();\n    JsonFormat.Parser parser = JsonFormat.parser();\n    Logger log = LoggerFactory.getLogger(getClass());\n\n    public ProtobufBinaryProvider() {\n        super();\n        log.info(\"Registered\");\n    }\n\n    @Override\n    public boolean isWriteable(Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType) {\n        return (Message.class.isAssignableFrom(type) || Message.Builder.class.isAssignableFrom(type));\n    }\n\n    @Override\n    public long getSize(Message myBean, Class<?> type, Type genericType, Annotation[] annotations,\n            MediaType mediaType) {\n        return 0;\n    }\n\n    @Override\n    public void writeTo(Message myBean, Class<?> type, Type genericType, Annotation[] annotations, MediaType mediaType,\n            MultivaluedMap<String, Object> httpHeaders, OutputStream entityStream)\n            throws IOException, WebApplicationException {\n        try {\n        \tmyBean.writeTo(entityStream);\n        } catch (final Exception e) {\n            log.error(\"Could not write?\", e);\n            throw new ProcessingException(\"Error serializing proto\");\n        }\n    }\n    //Note to support readFrom, you need to know the class of the proto, probably from a header\n\n}", "\u00b0\u00a4Fcatch \u00a8S\u00a6\u00b3\u00b1\u00b5\u00a8\u00ec\u00aa\u00baex\u00a7@\u00aa\u00ba\r\n * @author 1310081\r\n *\r\n */\r\npublic class MyApplication extends Application {\r\n\t\r\n\tstatic public String TAG = \"MyApplication\" ;\r\n\t\r\n\tpublic void onCreate() {\r\n\t\t\r\n\t\tLog.i(TAG ,\"\u00a6\u00b3\u00b1\u00d2\u00b0\u00ca\u00a6\u00db\u00adqapplication @@\") ;\r\n\t\t// Setup handler for uncaught exceptions.\r\n\t\tThread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() {\r\n\t\t\t@Override\r\n\t\t\tpublic void uncaughtException(Thread thread, Throwable e) {\r\n\t\t\t\thandleUncaughtException(thread, e);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\tpublic void handleUncaughtException(Thread thread, Throwable e) {\r\n\t\te.printStackTrace(); \r\n\t\t\r\n\t\tLog.i(\"MyApplication\", \"Handle uncatch exception: \" + e.getMessage());\r\n\t\tString stacktrace = \"\" ;\r\n\t\tfor ( StackTraceElement st: e.getStackTrace())\r\n\t\t{\r\n\t\t\tstacktrace += st.toString() + \"\\n\" ;\r\n\t\t}\r\n\t\t\r\n\t\tString output = \"uncatch exception:\" + e.getMessage() + \"\\nStackTrace:\" + stacktrace  ;\r\n\r\n\t\tCommon.showAlert(\"\u00b5o\u00a5\u00cd\u00c4Y\u00ad\u00ab\u00bf\u00f9\u00bb~\", output) ;\r\n\t\t\r\n\t\tif ( Common.spp != null )\r\n\t\t{\r\n\t\t\tCommon.spp.disconnect() ;\r\n\t\t}\r\n\t\tSystem.exit(1); // kill off the crashed app\r\n\t}\r\n\r\n}", "iew.View;\nimport android.widget.Button;\nimport android.widget.CheckBox;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\n/**\n * Created by Stoyan Gaydarov on 8/2/13.\n */\npublic class InsertScoresActivity extends Activity {\n\n    private int arrowIndex;\n    private TextView[] arrowViews;\n    private Score[] scores;\n    private TextView finalScore;\n    private Button submitBtn;\n    private Practice practice;\n    private CheckBox continueInsert;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        setContentView(R.layout.activity_insert);\n\n        long practiceId = getIntent().getLongExtra(\"practice_id\", -1L);\n        if (practiceId > 0) {\n            practice = MemoryStorage.getInstance().getPracticeRound(practiceId);\n        }\n\n        if (practice == null) {\n            practice = MemoryStorage.getInstance().startNewPracticeRound();\n        }\n\n        arrowIndex = 0;\n        int[] arrowRes = new int[]{R.id.arrow1, R.id.arrow2, R.id.arrow3, R.id.arrow4, R.id.arrow5, R.id.arrow6 };\n        arrowViews = new TextView[arrowRes.length];\n\n        scores = new Score[arrowRes.length];\n        for (int i = 0; i < arrowRes.length; i++) {\n            arrowViews[i] = (TextView) findViewById(arrowRes[i]);\n        }\n\n        continueInsert = (CheckBox) findViewById(R.id.continueInsert);\n        finalScore = (TextView) findViewById(R.id.finalScore);\n        submitBtn = (Button) findViewById(R.id.submit);\n\n        submitBtn.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                // Check all the scores\n                for (int i = 0; i < scores.length; i++) {\n                    if (scores[i] == null) {\n                        return;\n                    }\n                }\n\n                if(MemoryStorage.getInstance().appendScores(practice, scores)) {\n                    if (!continueInsert.isChecked()) {\n                        // If we are done inserting then finish\n                        finish();\n                    } else {\n                        // Otherwise reset the values\n                        scores = new Score[arrowViews.length];\n                        finalScore.setText(\"---\");\n                        arrowIndex = 0;\n\n                        for (TextView view : arrowViews) {\n                            view.setText(\"---\");\n                        }\n                    }\n                } else {\n                    Toast.makeText(InsertScoresActivity.this, \"Error Saving\", Toast.LENGTH_LONG).show();\n                }\n            }\n        });\n\n        setupButton(R.id.scoreX, Score.X);\n        setupButton(R.id.score10, Score.Ten);\n        setupButton(R.id.score9, Score.Nine);\n        setupButton(R.id.score8, Score.Eight);\n        setupButton(R.id.score7, Score.Seven);\n        setupButton(R.id.score6, Score.Six);\n        setupButton(R.id.score5, Score.Five);\n        setupButton(R.id.score4, Score.Four);\n        setupButton(R.id.score3, Score.Three);\n        setupButton(R.id.score2, Score.Two);\n        setupButton(R.id.score1, Score.One);\n        setupButton(R.id.scoreM, Score.Miss);\n    }\n\n    public void setupButton(int res, final Score buttonScore) {\n        Button button = (Button) findViewById(res);\n        button.setOnClickListener(new View.OnClickListener() {\n            @Override\n            public void onClick(View v) {\n                onClickScore(buttonScore);\n            }\n        });\n    }\n\n    public void onClickScore(Score score) {\n        arrowIndex = arrowIndex % arrowViews.length;\n\n        TextView view = arrowViews[arrowIndex];\n        view.setText(score.display);\n        scores[arrowIndex] = score;\n\n        arrowIndex++;\n\n        int value = 0;\n        for (int i = 0; i < scores.length; i++) {\n            if (scores[i] != null) {\n                value += scores[i].points;\n            }\n        }\n\n        finalScore.setText(String.valueOf(value));\n    }\n}\n", " {\n    public static boolean isAlmostPalindrome(String s) {\n        final StringBuilder sb = new StringBuilder();\n        for (int k = 0, len = s.length(), n = len / 2; k < n; k++) {\n            sb.setLength(0);\n            sb.append(s);\n            sb.setCharAt(len - 1 - k, s.charAt(k));\n            if (isPalindrome(sb)) {\n                return true;\n            }\n        }\n        return s.length() <= 1;\n    }\n\n    private static boolean isPalindrome(StringBuilder s) {\n        for (int k = 0, len = s.length(), n = len / 2; k < n; k++) {\n            if (s.charAt(k) != s.charAt(len - 1 - k)) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        final String[] tests = {\n            \"\",\n            \"1\",\n            \"asdf\",\n            \"abba\",\n            \"aka\",\n            \"1234554321\",\n            \"abccbx\",\n            \"123455x321\",\n            \"1a34554321\",\n            \"1a34543n1\",\n            \"1a3454an1\",\n        };\n        for (String s : tests) {\n            System.out.printf(\"String \\\"%s\\\": palindrom? %s; almost palindrome? %s%n\",\n                s, isPalindrome(new StringBuilder(s)), isAlmostPalindrome(s));\n        }\n    }\n}\n", "16 Business Factory, s.r.o.\n * <p>\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\npackage bf.io.openshop.ux;\n\nimport android.animation.Animator;\nimport android.app.Activity;\nimport android.app.ProgressDialog;\nimport android.content.Intent;\nimport android.net.Uri;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.support.annotation.NonNull;\nimport android.support.v7.app.AppCompatActivity;\nimport android.view.View;\nimport android.view.ViewAnimationUtils;\nimport android.view.animation.AccelerateDecelerateInterpolator;\nimport android.widget.AdapterView;\nimport android.widget.Button;\nimport android.widget.Spinner;\n\nimport com.android.volley.Request;\nimport com.android.volley.Response;\nimport com.android.volley.VolleyError;\nimport com.facebook.appevents.AppEventsLogger;\nimport com.facebook.applinks.AppLinkData;\n\nimport java.util.List;\nimport java.util.Locale;\n\nimport bf.io.openshop.CONST;\nimport bf.io.openshop.MyApplication;\nimport bf.io.openshop.R;\nimport bf.io.openshop.SettingsMy;\nimport bf.io.openshop.api.EndPoints;\nimport bf.io.openshop.api.GsonRequest;\nimport bf.io.openshop.entities.Shop;\nimport bf.io.openshop.entities.ShopResponse;\nimport bf.io.openshop.testing.EspressoIdlingResource;\nimport bf.io.openshop.utils.Analytics;\nimport bf.io.openshop.utils.MsgUtils;\nimport bf.io.openshop.utils.Utils;\nimport bf.io.openshop.ux.adapters.ShopSpinnerAdapter;\nimport bf.io.openshop.ux.dialogs.LoginDialogFragment;\nimport timber.log.Timber;\n\n/**\n * Initial activity. Handle install referrers, notifications and shop selection;\n * <p>\n * Created by Petr Melicherik.\n */\npublic class SplashActivity extends AppCompatActivity {\n    public static final String REFERRER = \"referrer\";\n    private static final String TAG = SplashActivity.class.getSimpleName();\n\n    private Activity activity;\n    private ProgressDialog progressDialog;\n\n    /**\n     * Indicates if layout has been already created.\n     */\n    private boolean layoutCreated = false;\n\n    /**\n     * Spinner offering all available shops.\n     */\n    private Spinner shopSelectionSpinner;\n\n    /**\n     * Button allowing selection of shop during fresh start.\n     */\n    private Button continueToShopBtn;\n\n    /**\n     * Indicates that window has been already detached.\n     */\n    private boolean windowDetached = false;\n\n    // Possible layouts\n    private View layoutIntroScreen;\n    private View layoutContent;\n    private View layoutContentNoConnection;\n    private View layoutContentSelectShop;\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        Timber.tag(TAG);\n        activity = this;\n\n        // init loading dialog\n        progressDialog = Utils.generateProgressDialog(this, false);\n\n        init();\n    }\n\n    /**\n     * Prepares activity view and handles incoming intent(Notification, utm data).\n     */\n\n    private void init() {\n        // Check if data connected.\n        if (!MyApplication.getInstance().isDataConnected()) {\n            progressDialog.hide();\n            Timber.d(\"No network connection.\");\n\n            initSplashLayout();\n\n            // Skip intro screen.\n            layoutContent.setVisibility(View.VISIBLE);\n            layoutIntroScreen.setVisibility(View.GONE);\n\n            // Show retry button.\n            layoutContentNoConnection.setVisibility(View.VISIBLE);\n            layoutContentSelectShop.setVisibility(View.GONE);\n        } else {\n            progressDialog.hide();\n\n            // Google Install referrer is handled by CampaignTrackingService and CampaignTrackingReceiver defined in Manifest.\n            // Referrer is sent with first event.\n\n            // Search for analytics data. General GA Campaign, and Facebook app links (if app links implemented on server side too).\n            Intent intent = this.getIntent();\n            if (intent != null) {\n                Uri uri = intent.getData();\n                if (uri != null && uri.isHierarchical() && (uri.getQueryParameter(\"utm_source\") != null || uri.getQueryParameter(REFERRER) != null)) {\n                    // GA General Campaign & Traffic Source Attribution. Save camping data.\n                    // https://developers.google.com/analytics/devguides/collection/android/v3/campaigns\n                    Timber.d(\"UTM source detected. - General Campaign & Traffic Source Attribution.\");\n                    if (uri.getQueryParameter(\"utm_source\") != null) {\n                        Analytics.setCampaignUriString(uri.toString());\n                    } else if (uri.getQueryParameter(REFERRER) != null) {\n                        Analytics.setCampaignUriString(uri.getQueryParameter(REFERRER));\n                    }\n                } else if (intent.getExtras() != null) {\n                    // FB app link. For function needs server side implementation also. https://developers.facebook.com/docs/applinks\n                    Timber.d(\"Extra bundle detected.\");\n                    try {\n                        Bundle bundleApplinkData = getIntent().getExtras();\n                        if (bundleApplinkData != null) {\n                            Bundle applinkData = bundleApplinkData.getBundle(\"al_applink_data\");\n                            if (applinkData != null) {\n                                String targetUrl = applinkData.getString(\"target_url\");\n                                if (targetUrl != null && !targetUrl.isEmpty()) {\n                                    Timber.d(\"TargetUrl: %s\", targetUrl);\n                                    Analytics.setCampaignUriString(targetUrl);\n                                }\n                            }\n                        }\n                    } catch (Exception e) {\n                        Timber.e(e, \"Parsing FB deepLink exception\");\n                    }\n                } else {\n                    // FB deferred app link. For function needs server side implementation also. https://developers.facebook.com/docs/applinks\n                    try {\n                        AppLinkData.fetchDeferredAppLinkData(this, new AppLinkData.CompletionHandler() {\n                            @Override\n                            public void onDeferredAppLinkDataFetched(AppLinkData appLinkData) {\n                                try {\n                                    if (appLinkData != null) {\n                                        String targetUrl = appLinkData.getTargetUri().toString();\n                                        if (targetUrl != null && !targetUrl.isEmpty()) {\n                                            Timber.e(\"TargetUrl: %s\", targetUrl);\n                                            Analytics.setCampaignUriString(targetUrl);\n                                        }\n                                    }\n                                } catch (Exception e) {\n                                    Timber.e(e, \"AppLinkData exception\");\n                                }\n                            }\n                        });\n                    } catch (Exception e) {\n                        Timber.e(e, \"Fetch deferredAppLinkData  exception\");\n                    }\n                }\n            }\n\n            // If opened by notification. Try load shop defined by notification data. If error, just start shop with last used shop.\n            if (this.getIntent() != null && this.getIntent().getExtras() != null && this.getIntent().getExtras().getString(EndPoints.NOTIFICATION_LINK) != null) {\n                Timber.d(\"Run by notification.\");\n                String type = this.getIntent().getExtras().getString(EndPoints.NOTIFICATION_LINK, \"\");\n                final String title = this.getIntent().getExtras().getString(EndPoints.NOTIFICATION_TITLE, \"\");\n                try {\n                    String[] linkParams = type.split(\":\");\n                    if (linkParams.length != 3) {\n                        Timber.e(\"Bad notification format. NotifyType: %s\", type);\n                        throw new Exception(\"Bad notification format. NotifyType:\" + type);\n                    } else {\n                        final String target = linkParams[1] + \":\" + linkParams[2];\n                        int shopId = Integer.parseInt(linkParams[0]);\n                        String url = String.format(EndPoints.SHOPS_SINGLE, shopId);\n                        Analytics.setCampaignUriString(this.getIntent().getExtras().getString(EndPoints.NOTIFICATION_UTM, \"\"));\n\n                        progressDialog.show();\n                        GsonRequest<Shop> req = new GsonRequest<>(Request.Method.GET, url, null, Shop.class, new Response.Listener<Shop>() {\n                            @Override\n                            public void onResponse(Shop shop) {\n                                progressDialog.cancel();\n                                Bundle bundle = new Bundle();\n                                bundle.putString(CONST.BUNDLE_PASS_TARGET, target);\n                                bundle.putString(CONST.BUNDLE_PASS_TITLE, title);\n\n                                // Logout user if shop changed\n                                Shop actualShop = SettingsMy.getActualShop();\n                                if (actualShop != null && shop.getId() != actualShop.getId())\n                                    LoginDialogFragment.logoutUser();\n\n                                setShopInformationAndStartMainActivity(shop, bundle);\n                            }\n                        }, new Response.ErrorListener() {\n                            @Override\n                            public void onErrorResponse(VolleyError error) {\n                                progressDialog.cancel();\n                                MsgUtils.logErrorMessage(error);\n                                startMainActivity(null);\n                            }\n                        });\n                        req.setRetryPolicy(MyApplication.getDefaultRetryPolice());\n                        req.setShouldCache(false);\n                        MyApplication.getInstance().addToRequestQueue(req, CONST.SPLASH_REQUESTS_TAG);\n                    }\n                } catch (Exception e) {\n                    Timber.e(e, \"Skip Splash activity after notification error.\");\n                    startMainActivity(null);\n                }\n            } else {\n                // Nothing special. try continue to MainActivity.\n                Timber.d(\"Nothing special.\");\n                startMainActivity(null);\n            }\n        }\n    }\n\n    /**\n     * Save selected/received shop, and try continue to MainActivity.\n     *\n     * @param shop   selected shop for persist.\n     * @param bundle notification specific data.\n     */\n    private void setShopInformationAndStartMainActivity(Shop shop, Bundle bundle) {\n        // Save selected shop\n        SettingsMy.setActualShop(shop);\n        startMainActivity(bundle);\n    }\n\n    /**\n     * SetContentView to activity and prepare layout views.\n     */\n    private void initSplashLayout() {\n        if (!layoutCreated) {\n            setContentView(R.layout.activity_splash);\n\n            layoutContent = findViewById(R.id.splash_content);\n            layoutIntroScreen = findViewById(R.id.splash_intro_screen);\n            layoutContentNoConnection = findViewById(R.id.splash_content_no_connection);\n            layoutContentSelectShop = findViewById(R.id.splash_content_select_shop);\n\n            shopSelectionSpinner = (Spinner) findViewById(R.id.splash_shop_selection_spinner);\n            continueToShopBtn = (Button) findViewById(R.id.splash_continue_to_shop_btn);\n            continueToShopBtn.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View v) {\n                    Shop selectedShop = (Shop) shopSelectionSpinner.getSelectedItem();\n                    if (selectedShop != null && selectedShop.getId() != CONST.DEFAULT_EMPTY_ID)\n                        setShopInformationAndStartMainActivity(selectedShop, null);\n                    else\n                        Timber.e(\"Cannot continue. Shop is not selected or is null.\");\n                }\n            });\n            Button reRunButton = (Button) findViewById(R.id.splash_re_run_btn);\n            if (reRunButton != null) {\n                reRunButton.setOnClickListener(new View.OnClickListener() {\n                    @Override\n                    public void onClick(View v) {\n                        progressDialog.show();\n                        (new Handler()).postDelayed(new Runnable() {\n                            @Override\n                            public void run() {\n                                init();\n                            }\n                        }, 600);\n                    }\n                });\n            } else {\n                Timber.e(new RuntimeException(), \"ReRunButton didn't found\");\n            }\n            layoutCreated = true;\n        } else {\n            Timber.d(\"%s screen is already created.\", this.getClass().getSimpleName());\n        }\n    }\n\n    /**\n     * Check if shop is selected. If so then start {@link MainActivity}. If no then show form with selection.\n     *\n     * @param bundle notification specific data.\n     */\n    private void startMainActivity(Bundle bundle) {\n        if (SettingsMy.getActualShop() == null) {\n            // First run, allow user choose desired shop.\n            Timber.d(\"Missing active shop. Show shop selection.\");\n            initSplashLayout();\n            layoutContentNoConnection.setVisibility(View.GONE);\n            layoutContentSelectShop.setVisibility(View.VISIBLE);\n            requestShops();\n        } else {\n            Intent mainIntent = new Intent(SplashActivity.this, MainActivity.class);\n            if (bundle != null) {\n                Timber.d(\"Pass bundle to main activity\");\n                mainIntent.putExtras(bundle);\n            }\n            startActivity(mainIntent);\n            finish();\n        }\n    }\n\n    /**\n     * Load available shops from server.\n     */\n    private void requestShops() {\n        if (layoutIntroScreen.getVisibility() != View.VISIBLE)\n            progressDialog.show();\n        GsonRequest<ShopResponse> getShopsRequest = new GsonRequest<>(Request.Method.GET, EndPoints.SHOPS, null, ShopResponse.class,\n                new Response.Listener<ShopResponse>() {\n                    @Override\n                    public void onResponse(@NonNull ShopResponse response) {\n                        Timber.d(\"Get shops response: %s\", response.toString());\n                        setSpinShops(response.getShopList());\n                        if (progressDialog != null) progressDialog.cancel();\n                        animateContentVisible();\n                    }\n                }, new Response.ErrorListener() {\n            @Override\n            public void onErrorResponse(VolleyError error) {\n                if (progressDialog != null) progressDialog.cancel();\n                MsgUtils.logAndShowErrorMessage(activity, error);\n                finish();\n            }\n        });\n        getShopsRequest.setRetryPolicy(MyApplication.getDefaultRetryPolice());\n        getShopsRequest.setShouldCache(false);\n        MyApplication.getInstance().addToRequestQueue(getShopsRequest, CONST.SPLASH_REQUESTS_TAG);\n    }\n\n    /**\n     * Prepare spinner with shops and pre-select the most appropriate.\n     *\n     * @param shopList list of shops received from server.\n     */\n    private void setSpinShops(List<Shop> shopList) {\n        if (shopList != null && !shopList.isEmpty()) {\n            // preset shop selection title.\n            Shop defaultEmptyValue = new Shop();\n            defaultEmptyValue.setId(CONST.DEFAULT_EMPTY_ID);\n            defaultEmptyValue.setName(getString(R.string.Select_shop));\n            shopList.add(0, defaultEmptyValue);\n\n            ShopSpinnerAdapter shopSpinnerAdapter = new ShopSpinnerAdapter(this, shopList, true);\n            shopSelectionSpinner.setAdapter(shopSpinnerAdapter);\n            shopSelectionSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {\n                @Override\n                public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {\n                    Shop item = (Shop) parent.getItemAtPosition(position);\n                    if (item.getId() == CONST.DEFAULT_EMPTY_ID)\n                        continueToShopBtn.setVisibility(View.INVISIBLE);\n                    else {\n                        continueToShopBtn.setVisibility(View.VISIBLE);\n                    }\n                }\n\n                @Override\n                public void onNothingSelected(AdapterView<?> parent) {\n                    Timber.d(\"No shop selected.\");\n                }\n            });\n\n            // pre-select shop if only 1 exist\n            if (shopList.size() == 2) {\n                shopSelectionSpinner.setSelection(1);\n                Timber.d(\"Only one shop exist.\");\n            } else {\n                // pre-select shop based on language\n                String defaultLanguage = Locale.getDefault().getLanguage();\n                Timber.d(\"Default language: %s\", defaultLanguage);\n                long tempShopId = 0; // DEFAULT no language\n\n                // Find corresponding shop and language\n                for (int i = 0; i < shopList.size(); i++) {\n                    if (shopList.get(i).getLanguage() != null && shopList.get(i).getLanguage().equalsIgnoreCase(defaultLanguage)) {\n                        tempShopId = shopList.get(i).getId();\n                        break;\n                    }\n                }\n\n                // Select founded shop\n                for (int i = 0; i < shopList.size(); i++) {\n                    if (shopList.get(i).getId() == tempShopId) {\n                        Timber.d(\"Preselect language position: %s\", i);\n                        shopSelectionSpinner.setSelection(i);\n                        break;\n                    }\n                }\n            }\n        } else {\n            Timber.e(new RuntimeException(), \"Trying to set empty shops array.\");\n        }\n    }\n\n    /**\n     * Hide intro screen and display content layout with animation.\n     */\n    private void animateContentVisible() {\n        if (layoutIntroScreen != null && layoutContent != null && layoutIntroScreen.getVisibility() == View.VISIBLE) {\n            EspressoIdlingResource.increment();\n            runOnUiThread(new Runnable() {\n                @Override\n                public void run() {\n                    new Handler().postDelayed(new Runnable() {\n                        @Override\n                        public void run() {\n                            if (windowDetached) {\n                                if (layoutContent != null) layoutContent.setVisibility(View.VISIBLE);\n                            } else {\n//                            // If lollipop use reveal animation. On older phones use fade animation.\n                                if (android.os.Build.VERSION.SDK_INT > Build.VERSION_CODES.LOLLIPOP) {\n                                    Timber.d(\"Circular animation.\");\n                                    // get the center for the animation circle\n                                    final int cx = (layoutContent.getLeft() + layoutContent.getRight()) / 2;\n                                    final int cy = (layoutContent.getTop() + layoutContent.getBottom()) / 2;\n\n                                    // get the final radius for the animation circle\n                                    int dx = Math.max(cx, layoutContent.getWidth() - cx);\n                                    int dy = Math.max(cy, layoutContent.getHeight() - cy);\n                                    float finalRadius = (float) Math.hypot(dx, dy);\n\n                                    Animator animator = ViewAnimationUtils.createCircularReveal(layoutContent, cx, cy, 0, finalRadius);\n                                    animator.setInterpolator(new AccelerateDecelerateInterpolator());\n                                    animator.setDuration(1250);\n                                    layoutContent.setVisibility(View.VISIBLE);\n                                    animator.start();\n                                } else {\n                                    Timber.d(\"Alpha animation.\");\n                                    layoutContent.setAlpha(0f);\n                                    layoutContent.setVisibility(View.VISIBLE);\n                                    layoutContent.animate()\n                                            .alpha(1f)\n                                            .setDuration(1000)\n                                            .setListener(null);\n                                }\n                            }\n                            EspressoIdlingResource.decrement();\n                        }\n                    }, 330);\n                }\n            });\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n\n        // Logs 'install' and 'app activate' App Events.\n        AppEventsLogger.activateApp(this);\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n\n        // Logs 'app deactivate' App Event.\n        AppEventsLogger.deactivateApp(this);\n    }\n\n    @Override\n    protected void onStop() {\n        if (progressDialog != null) progressDialog.cancel();\n        if (layoutIntroScreen != null) layoutIntroScreen.setVisibility(View.GONE);\n        if (layoutContent != null) layoutContent.setVisibility(View.VISIBLE);\n        MyApplication.getInstance().cancelPendingRequests(CONST.SPLASH_REQUESTS_TAG);\n        super.onStop();\n    }\n\n    @Override\n    public void onAttachedToWindow() {\n        windowDetached = false;\n        super.onAttachedToWindow();\n    }\n\n    @Override\n    public void onDetachedFromWindow() {\n        windowDetached = true;\n        super.onDetachedFromWindow();\n    }\n}\n", "fit.http.POST;\nimport retrofit.http.Query;\n\nimport com.josenaves.boogle.model.Document;\nimport com.josenaves.boogle.model.Matches;\n\npublic interface BoogleApi {\n\t@POST(\"/index\")\n\tString indexDocument(@Body Document document);\n\t\n\t@GET(\"/search\")\n\tMatches search(@Query(\"q\") String searchTerms);\n}\n", "Concatenate() {\n MyUnit myUnit = new MyUnit();\nString result = myUnit.concatenate(\"one\", \"two\");\nassertEquals(\"onetwo\", result); } }", "package erp.server;\n\nimport java.rmi.Remote;\nimport java.rmi.RemoteException;\n\n/**\n *\n * @author Sergio Flores\n */\npublic interface SServerRemote extends Remote {\n\n    public SLoginResponse login(SLoginRequest request) throws RemoteException;\n    public void logout(int sessionId) throws RemoteException;\n}\n", "blic MyComparableFour(T item1, T item2, T item3, T item4)\n\t{\n\t\tthis.item1 = item1;\n\t\tthis.item2 = item2;\n\t\tthis.item3 = item3;\n\t\tthis.item4 = item4;\n\t}\n\n\tpublic boolean allEqual()\n\t{\n\t\treturn item1.equals(item2) && item2.equals(item3) && item3.equals(item4);\n\t}\n\n\tpublic void shiftLeft()\n\t{\n\t\tT temp = item4;\n\t\titem4 = item3;\n\t\titem3 = item2;\n\t\titem2 = item1;\n\t\titem1 = temp;\n\t}\n\n\tpublic String toString()\n\t{\n\t\treturn String.format(\"(%s, %s, %s, %s)\",\n\t\t\titem1.toString(),\n\t\t\titem2.toString(),\n\t\t\titem3.toString(),\n\t\t\titem4.toString());\n\t}\n\n\tpublic T max()\n\t{\n\t\tT max = (item1.compareTo(item2) >= 0) ? item1: item2;\n\t\tmax = (max.compareTo(item3) >= 0) ? max : item3;\n\t\tmax = (max.compareTo(item4) >= 0) ? max : item4;\n\t\treturn max;\n\t}\n\n\tpublic static void main(String[] args)\n\t{\n\t\tMyComparableFour<String> myStringFour = new MyComparableFour<String>(\"obey\", \"obey\", \"obey\", \"obey\");\n\t\tSystem.out.println(myStringFour);\n\t\tSystem.out.println(myStringFour.allEqual());\n\n\t\tMyComparableFour<Integer> myIntFour = new MyComparableFour<Integer>(2, 3, 23, 5);\n\t\tSystem.out.println(myIntFour);\n\t\tSystem.out.println(myIntFour.allEqual());\t\n\t\tmyIntFour.shiftLeft();\n\t\tSystem.out.println(myIntFour);\n\t\tSystem.out.println(\"Max: \" + myIntFour.max());\n\n\t\tMyComparableFour<Employee> myEmployeeFour = new MyComparableFour<Employee>(\n\t\t\tnew Employee(2),\n\t\t\tnew Employee(3),\n\t\t\tnew Employee(23),\n\t\t\tnew Employee(5));\n\t\tSystem.out.println(myEmployeeFour);\n\t\tSystem.out.println(\"Max: \" + myEmployeeFour.max());\n\t}\n}", "lem in polynomial time. Link: http://en.wikipedia.org/wiki/Hungarian_algorithm\n * Originally Coded by Amir El Bawab, modified by Ethan J. Eldridge for double matrix \n * Date: 4 May 2014, Updated Aug 13 2014\n * License: MIT License ~ Please read License.txt for more information about the usage of this software\n * */\npublic class HungarianDouble {\n\tprivate double[][] originalValues; // Given values\n\tprivate double[][] values; // Cloned given values to be processed\n\tprivate int[][] lines; // Line drawn\n\tprivate int numLines; // Number of line drawn\n\t\n\tint rows[]; // Index of the column selected by every row (The final result)\n\tint occupiedCols[]; // Verify that all column are occupied, used in the optimization step\n\t\n\tpublic HungarianDouble(double[][] matrix) {\n\t\t// Initialization\n\t\toriginalValues = matrix; // Given matrix\n\t\tvalues = cloneMatrix(matrix); // Cloned matrix to be processed\n\t\trows = new int[values.length];\n\t\toccupiedCols = new int[values.length];\n\t\t\n\t\t//Algorithm\n\t\tsubtractRowMinimal(); \t\t\t\t// Step 1\n\t\tsubtractColMinimal();\t\t\t\t// Step 2\n\t\tcoverZeros();\t\t\t\t\t\t// Step 3\n\t\twhile(numLines < values.length){\n\t\t\tcreateAdditionalZeros();\t\t// Step 4 (Condition)\n\t\t\tcoverZeros();\t\t\t\t\t// Step 3 Again (Condition)\n\t\t}\n\t\toptimization();\t\t\t\t\t\t// Optimization\n\t}\n\t\n\t/**\n\t * Step 1\n\t * Subtract from every element the minimum value from its row\n\t * */\n\tpublic void subtractRowMinimal(){\n\t\tdouble rowMinValue[] = new double[values.length];\n\t\t//get the minimum for each row and store in rowMinValue[]\n\t\tfor(int row=0; row<values.length;row++){\n\t\t\trowMinValue[row] = values[row][0];\n\t\t\tfor(int col=1; col<values.length;col++){\n\t\t\t\tif(values[row][col] < rowMinValue[row])\n\t\t\t\t\trowMinValue[row] = values[row][col];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//subtract minimum from each row using rowMinValue[]\n\t\tfor(int row=0; row<values.length;row++){\n\t\t\tfor(int col=0; col<values.length;col++){\n\t\t\t\tvalues[row][col] -= rowMinValue[row];\n\t\t\t}\n\t\t}\n\t} //End Step 1\n\t\n\t/**\n\t * Step 2\n\t * Subtract from every element the minimum value from its column\n\t * */\n\tpublic void subtractColMinimal(){\n\t\tdouble colMinValue[] = new double[values.length];\n\t\t//get the minimum for each column and store them in colMinValue[]\n\t\tfor(int col=0; col<values.length;col++){\n\t\t\tcolMinValue[col] = values[0][col];\n\t\t\tfor(int row=1; row<values.length;row++){\n\t\t\t\tif(values[row][col] < colMinValue[col])\n\t\t\t\t\tcolMinValue[col] = values[row][col];\n\t\t\t}\n\t\t}\n\t\t\n\t\t//subtract minimum from each column using colMinValue[]\n\t\tfor(int col=0; col<values.length;col++){\n\t\t\tfor(int row=0; row<values.length;row++){\n\t\t\t\tvalues[row][col] -= colMinValue[col];\n\t\t\t}\n\t\t}\n\t} //End Step 2\n\t\n\t/**\n\t * Step 3.1\n\t * Loop through all elements, and run colorNeighbors when the element visited is equal to zero\n\t * */\n\tpublic void coverZeros(){\n\t\tnumLines = 0;\n\t\tlines = new int[values.length][values.length];\n\t\t\n\t\tfor(int row=0; row<values.length;row++){\n\t\t\tfor(int col=0; col<values.length;col++){\n\t\t\t\tif(values[row][col] == 0)\n\t\t\t\t\tcolorNeighbors(row, col, maxVH(row, col));\n\t\t\t}\n\t\t}\n\t}\n\t\n\t/**\n\t * Step 3.2\n\t * Checks which direction (vertical,horizontal) contains more zeros, every time a zero is found vertically, we increment the result\n\t * and every time a zero is found horizontally, we decrement the result. At the end, result will be negative, zero or positive\n\t * @param row Row index for the target cell\n\t * @param col Column index for the target cell\n\t * @return Positive integer means that the line passing by indexes [row][col] should be vertical, Zero or Negative means that the line passing by indexes [row][col] should be horizontal\n\t * */\n\tprivate int maxVH(int row, int col){\n\t\tint result = 0;\n\t\tfor(int i=0; i<values.length;i++){\n\t\t\tif(values[i][col] == 0)\n\t\t\t\tresult++;\n\t\t\tif(values[row][i] == 0)\n\t\t\t\tresult--;\n\t\t}\n\t\treturn result;\n\t}\n\t\n\t/**\n\t * Step 3.3\n\t * Color the neighbors of the cell at index [row][col]. To know which direction to draw the lines, we pass maxVH value.\n\t * @param row Row index for the target cell\n\t * @param col Column index for the target cell\n\t * @param maxVH Value return by the maxVH method, positive means the line to draw passing by indexes [row][col] is vertical, negative or zero means the line to draw passing by indexes [row][col] is horizontal\n\t * */\n\tprivate void colorNeighbors(int row, int col, int maxVH){\n\t\tif(lines[row][col] == 2) // if cell is colored twice before (intersection cell), don't color it again\n\t\t\treturn;\n\t\t\n\t\tif(maxVH > 0 && lines[row][col] == 1) // if cell colored vertically and needs to be recolored vertically, don't color it again (Allowing this step, will color the same line (result won't change), but the num of line will be incremented (wrong value for the num of line drawn))\n\t\t\treturn;\n\t\t\t\n\t\tif(maxVH <= 0 && lines[row][col] == -1) // if cell colored horizontally and needs to be recolored horizontally, don't color it again (Allowing this step, will color the same line (result won't change), but the num of line will be incremented (wrong value for the num of line drawn))\n\t\t\treturn;\n\t\t\n\t\tfor(int i=0; i<values.length;i++){ // Loop on cell at indexes [row][col] and its neighbors\n\t\t\tif(maxVH > 0)\t// if value of maxVH is positive, color vertically\n\t\t\t\tlines[i][col] = lines[i][col] == -1 || lines[i][col] == 2 ? 2 : 1; // if cell was colored before as horizontal (-1), and now needs to be colored vertical (1), so this cell is an intersection (2). Else if this value was not colored before, color it vertically\n\t\t\telse\t\t\t// if value of maxVH is zero or negative color horizontally\n\t\t\t\tlines[row][i] = lines[row][i] == 1 || lines[row][i] == 2 ? 2 : -1; // if cell was colored before as vertical (1), and now needs to be colored horizontal (-1), so this cell is an intersection (2). Else if this value was not colored before, color it horizontally\n\t\t}\n\t\t\n\t\t// increment line number\n\t\tnumLines++;\n//\t\tprintMatrix(lines); // Monitor the line draw steps\n\t}//End step 3\n\t\n\t/**\n\t * Step 4\n\t * This step is not always executed. (Check the algorithm in the constructor)\n\t * Create additional zeros, by coloring the minimum value of uncovered cells (cells not colored by any line)\n\t * */\n\tpublic void createAdditionalZeros(){\n\t\tdouble minUncoveredValue = 0; // We don't know the value of the first uncovered cell, so we put a joker value 0 (0 is safe, because before this step, all zeros were covered)\n\t\t\n\t\t// Find the min in the uncovered numbers\n\t\tfor(int row=0; row<values.length;row++){\n\t\t\tfor(int col=0; col<values.length;col++){\n\t\t\t\tif(lines[row][col] == 0 && (values[row][col] < minUncoveredValue || minUncoveredValue == 0))\n\t\t\t\t\tminUncoveredValue = values[row][col];\n\t\t\t}\n\t\t}\n\t\t\n\t\t// Subtract min form all uncovered elements, and add it to all elements covered twice\n\t\tfor(int row=0; row<values.length;row++){\n\t\t\tfor(int col=0; col<values.length;col++){\n\t\t\t\tif(lines[row][col] == 0) // If uncovered, subtract\n\t\t\t\t\tvalues[row][col] -= minUncoveredValue;\n\t\t\t\t\n\t\t\t\telse if(lines[row][col] == 2) // If covered twice, add\n\t\t\t\t\tvalues[row][col] += minUncoveredValue;\n\t\t\t}\n\t\t}\n\t} // End step 4\n\t\n\t/**\n\t * Optimization, assign every row a cell in a unique column. Since a row can contain more than one zero,\n\t * we need to make sure that all rows are assigned one cell from one unique column. To do this, use brute force\n\t * @param row\n\t * @param boolean If all rows were assigned a cell from a unique column, return true (at the end, guarantee true)\n\t * @return true\n\t * */\n\tprivate boolean optimization(int row){\n\t\tif(row == rows.length) // If all rows were assigned a cell\n\t\t\treturn true;\n\t\t\n\t\tfor(int col=0; col<values.length;col++){ // Try all columns\n\t\t\tif(values[row][col] == 0 && occupiedCols[col] == 0){ // If the current cell at column `col` has a value of zero, and the column is not reserved by a previous row\n\t\t\t\trows[row] = col; // Assign the current row the current column cell\n\t\t\t\toccupiedCols[col] = 1; // Mark the column as reserved\n\t\t\t\tif(optimization(row+1)) // If the next rows were assigned successfully a cell from a unique column, return true\n\t\t\t\t\treturn true;\n\t\t\t\toccupiedCols[col] = 0; // If the next rows were not able to get a cell, go back and try for the previous rows another cell from another column\n\t\t\t}\n\t\t}\n\t\treturn false; // If no cell were assigned for the current row, return false to go back one row to try to assign to it another cell from another column\n\t}\n\t\n\t/**\n\t * Overload optimization(int row) method\n\t * @return true\n\t * */\n\tpublic boolean optimization(){\n\t\treturn optimization(0);\n\t} //End optimization\n\t\n\t/**\n\t * Get the result by returning an array containing the cell assigned for each row\n\t * @return Array of rows where each array index represent the row number, and the value at each index is the column assigned to the corresponding row\n\t * */\n\tpublic int[] getResult(){\n\t\treturn rows;\n\t}\n\t\n\t/**\n\t * Get the sum of the value of the assigned cells for all rows using the original passed matrix, and using the rows array to know the index of the column for each row.\n\t * @return Total values\n\t * */\n\tpublic double getTotal(){\n\t\tdouble total = 0;\n\t\tfor(int row = 0; row < values.length; row++)\n\t\t\ttotal += originalValues[row][rows[row]];\n\t\treturn total;\n\t}\n\n\t/**\n\t * Clone the 2D array\n\t * @return A copy of the 2D array\n\t * */\n\tpublic double[][] cloneMatrix(double[][] matrix){\n\t\tdouble[][] tmp = new double[matrix.length][matrix.length];\n\t\tfor(int row = 0; row < matrix.length; row++){\n\t\t\ttmp[row] = matrix[row].clone();\n\t\t}\n\t\treturn tmp;\n\t}\n\t\n\t/**\n\t * Print a 2D array\n\t * @param matrix The target 2D array\n\t * */\n\tpublic void printMatrix(double[][] matrix){\n\t\tfor(int row=0; row<matrix.length;row++){\n\t\t\tfor(int col=0; col<matrix.length;col++){\n\t\t\t\tSystem.out.print(matrix[row][col]+\"\\t\");\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t\tSystem.out.println();\n\t}\n}\n", "n);\n    \n    public static void main(String[] args){\n        maxmin();\n    }\n    \n    private static void maxmin(){\n        int N = getIntFromStdin();\n        int K = getIntFromStdin();\n        List<Integer> inputsList = getInputs(N);\n        \n        int minimumFairness = calculateFairnessFromKSizeSublist(inputsList, K);\n        System.out.println(minimumFairness);\n    }\n    \n    private static int getIntFromStdin(){\n        return stdin.nextInt();\n    }\n    \n    private static List<Integer> getInputs(int size){\n        List<Integer> inputsList = new ArrayList<Integer>();\n        for(int i = 0; i < size; ++i)\n            inputsList.add(stdin.nextInt());\n        return inputsList;\n    }\n\n    private static int calculateFairnessFromKSizeSublist(List<Integer> inputsList, int K){\n        Collections.sort(inputsList);\n        int minimumFairness = calculateFairnessFromList(inputsList.subList(0, K));\n        for(int i = 1; i < inputsList.size()-K; ++i){\n            int currentFairness = calculateFairnessFromList(inputsList.subList(i, i+K));\n            if(currentFairness < minimumFairness)\n                minimumFairness = currentFairness;\n        }\n        return minimumFairness;\n    }\n    \n    private static int calculateFairnessFromList(List<Integer> list){\n        return maxValueInList(list) - minValueInList(list);\n    }\n                                              \n    private static int maxValueInList(List<Integer> list){\n        return Collections.max(list);\n    }\n    \n    private static int minValueInList(List<Integer> list){\n        return Collections.min(list);\n    }\n}\n", " implements Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = -4996369755998025141L;\r\n\tprivate String puInfo;\r\n\tprivate String duInfo;\r\n\r\n\tpublic String getPuInfo() {\r\n\t\treturn puInfo;\r\n\t}\r\n\r\n\tpublic void setPuInfo(String puInfo) {\r\n\t\tthis.puInfo = puInfo;\r\n\t}\r\n\r\n\tpublic String getDuInfo() {\r\n\t\treturn duInfo;\r\n\t}\r\n\r\n\tpublic void setDuInfo(String duInfo) {\r\n\t\tthis.duInfo = duInfo;\r\n\t}\r\n\r\n}\r\n", "ava.util.Iterator;\nimport java.util.List;\n\nimport static org.junit.Assert.*;\n\n/**\n * Unit test for class {@link CardPile}.\n */\npublic class CardPileTest {\n\n  /**\n   * Reference to the {@link CardPile} object under test.\n   */\n  CardPile cardPile;\n\n  /**\n   * Instantiates a new object before each test.\n   */\n  @Before\n  public void setUp() {\n    cardPile = new CardPile();\n  }\n\n  /**\n   * Tests one parameter constructor and getter / setter for <code>type</code>\n   * field.\n   */\n  @Test\n  public void testOneParameterConstructorAndGetterSetterForType() {\n    CardPile cardPile1 = new CardPile(CardPile.Type.Klondike);\n    assertEquals(CardPile.Type.Klondike, cardPile1.getType());\n    cardPile1.setType(CardPile.Type.Waste);\n    assertEquals(CardPile.Type.Waste, cardPile1.getType());\n  }\n\n  /**\n   * Tests two parameter constructor and getter / setter for <code>id</code>\n   * field.\n   */\n  @Test\n  public void testTwoParameterConstructorAndGetterSetterForId() {\n    CardPile cardPile1 = new CardPile(CardPile.Type.Klondike, \"TEST ID\");\n    assertEquals(\"TEST ID\", cardPile1.getId());\n    cardPile1.setId(\"CHANGED TEST ID\");\n    assertEquals(\"CHANGED TEST ID\", cardPile1.getId());\n  }\n\n  /**\n   * Tests <code>addCard()</code> and <code>numOfCards()</code> methods.\n   */\n  @Test\n  public void testAddCardAndNumOfCards() {\n    Card card = new FrenchCard(false, FrenchSuit.Spades, FrenchRank.Four);\n    cardPile.addCard(card);\n    assertEquals(1, cardPile.numOfCards());\n  }\n\n  /**\n   * Tests <code>isEmpty()</code> method.\n   */\n  @Test\n  public void testIsEmpty() {\n    assertTrue(cardPile.isEmpty());\n  }\n\n  /**\n   * Tests <code>getTopCard()</code> method.\n   */\n  @Test\n  public void testGetTopCard() {\n    Card card1 = new FrenchCard(false, FrenchSuit.Spades, FrenchRank.Four);\n    Card card2 = new FrenchCard(false, FrenchSuit.Diamonds, FrenchRank.Three);\n    cardPile.addCard(card1);\n    cardPile.addCard(card2);\n    assertSame(card2, cardPile.getTopCard());\n  }\n\n  /**\n   * Tests <code>cardsAbove()</code>, <code>moveCardsToPile()</code> and\n   * <code>moveCardToPile()</code> methods.\n   */\n  @Test\n  public void testCardsAboveAndMoveCardsToPile() {\n    Card card1 = new FrenchCard(false, FrenchSuit.Spades, FrenchRank.Five);\n    Card card2 = new FrenchCard(false, FrenchSuit.Diamonds, FrenchRank.Four);\n    Card card3 = new FrenchCard(false, FrenchSuit.Clubs, FrenchRank.Three);\n    Card card4 = new FrenchCard(false, FrenchSuit.Hearts, FrenchRank.Two);\n\n    cardPile.addCard(card1);\n    cardPile.addCard(card2);\n    cardPile.addCard(card3);\n    cardPile.addCard(card4);\n\n    List<Card> cardsAbove = cardPile.cardsAbove(card2);\n\n    assertSame(card2, cardsAbove.get(0));\n    assertSame(card3, cardsAbove.get(1));\n    assertSame(card4, cardsAbove.get(2));\n\n    CardPile cardPile1 = new CardPile();\n\n    cardPile.moveCardsToPile(cardsAbove, cardPile1);\n\n    assertEquals(1, cardPile.numOfCards());\n    assertEquals(3, cardPile1.numOfCards());\n    assertTrue(cardsAbove.isEmpty());\n\n    cardPile.moveCardToPile(cardPile.getTopCard(), cardPile1);\n    assertEquals(0, cardPile.numOfCards());\n    assertEquals(4, cardPile1.numOfCards());\n  }\n\n  /**\n   * Tests <code>iterator()</code> and <code>forEach()</code> methods.\n   */\n  @Test\n  public void testIteratorAndForEach() {\n    Card card1 = new FrenchCard(false, FrenchSuit.Spades, FrenchRank.Five);\n    Card card2 = new FrenchCard(false, FrenchSuit.Diamonds, FrenchRank.Four);\n    Card card3 = new FrenchCard(false, FrenchSuit.Clubs, FrenchRank.Three);\n    Card card4 = new FrenchCard(false, FrenchSuit.Hearts, FrenchRank.Two);\n\n    cardPile.addCard(card1);\n    cardPile.addCard(card2);\n    cardPile.addCard(card3);\n    cardPile.addCard(card4);\n\n    Iterator<Card> testIterator1 = cardPile.iterator();\n    assertSame(testIterator1.next(), cardPile.getCards().get(0));\n    assertSame(testIterator1.next(), cardPile.getCards().get(1));\n    assertSame(testIterator1.next(), cardPile.getCards().get(2));\n\n    Iterator<Card> testIterator2 = cardPile.iterator();\n    cardPile.forEach(card -> assertSame(card, testIterator2.next()));\n  }\n\n}\n", "hine;\nimport org.cf.smalivm.context.ExecutionNode;\nimport org.cf.smalivm.context.HeapItem;\nimport org.cf.smalivm.context.MethodState;\nimport org.cf.smalivm.exception.UnknownAncestors;\nimport org.cf.util.Utils;\nimport org.jf.dexlib2.iface.instruction.Instruction;\nimport org.jf.dexlib2.iface.instruction.formats.Instruction22c;\nimport org.jf.dexlib2.iface.reference.TypeReference;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class InstanceOfOp extends MethodStateOp {\n\n    private static final Logger log = LoggerFactory.getLogger(InstanceOfOp.class.getSimpleName());\n\n    static InstanceOfOp create(Instruction instruction, int address, VirtualMachine vm) {\n        String opName = instruction.getOpcode().name;\n        int childAddress = address + instruction.getCodeUnits();\n\n        Instruction22c instr = (Instruction22c) instruction;\n        int destRegister = instr.getRegisterA();\n        int arg1Register = instr.getRegisterB();\n        TypeReference typeRef = (TypeReference) instr.getReference();\n        String className = typeRef.getType();\n\n        return new InstanceOfOp(address, opName, childAddress, destRegister, arg1Register, className, vm);\n    }\n\n    private final String className;\n    private final int destRegister;\n    private final int arg1Register;\n    private final VirtualMachine vm;\n\n    InstanceOfOp(int address, String opName, int childAddress, int destRegister, int arg1Register, String className,\n                    VirtualMachine vm) {\n        super(address, opName, childAddress);\n\n        this.destRegister = destRegister;\n        this.arg1Register = arg1Register;\n        this.className = className;\n        this.vm = vm;\n    }\n\n    @Override\n    public void execute(ExecutionNode node, MethodState mState) {\n        HeapItem item = mState.readRegister(arg1Register);\n        boolean isInstance = false;\n        try {\n            ClassManager classManager = vm.getClassManager();\n            for (String type : Utils.getTypes(item)) {\n                isInstance = classManager.isInstance(type, className);\n                if (isInstance) {\n                    break;\n                }\n            }\n        } catch (UnknownAncestors e) {\n            if (log.isErrorEnabled()) {\n                log.error(\"Unable to determine ancestory for {}\\n{}\", className, e);\n            }\n        }\n\n        if (!isInstance && item.isUnknown()) {\n            // Don't have all of the type information, only declared type.\n            // Object obj = method.reflect() for example may return a String\n            // but the declared type is Object.\n            mState.assignRegister(destRegister, HeapItem.newUnknown(\"Z\"));\n        } else {\n            mState.assignRegister(destRegister, new HeapItem(isInstance, \"Z\"));\n        }\n    }\n\n    @Override\n    public String toString() {\n        StringBuilder sb = new StringBuilder(getName());\n        sb.append(\" r\").append(destRegister).append(\", \").append(arg1Register).append(\", \").append(className);\n\n        return sb.toString();\n    }\n\n}\n", " net.minecraft.client.renderer.entity.RenderCreeper;\nimport net.minecraft.client.renderer.entity.RenderManager;\nimport net.minecraft.entity.monster.EntityCreeper;\nimport net.minecraft.util.ResourceLocation;\nimport net.minecraftforge.fml.client.registry.IRenderFactory;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\nimport sblectric.lightningcraft.entities.EntityUnderworldCreeper;\nimport sblectric.lightningcraft.ref.RefStrings;\n\n/** Underworld Creeper renderer */\n@SideOnly(Side.CLIENT)\npublic class RenderUnderworldCreeper extends RenderCreeper {\n\t\n\tpublic static final IRenderFactory<EntityUnderworldCreeper> FACTORY = new Factory();\n\tprivate static final ResourceLocation TEXTURE = new ResourceLocation(RefStrings.MODID, \"textures/entities/underworld_creeper.png\");\n\t\n\tpublic RenderUnderworldCreeper(RenderManager rm) {\n\t\tsuper(rm);\n\t}\n\n    @Override\n    protected ResourceLocation getEntityTexture(EntityCreeper e) {\n        return TEXTURE;\n    }\n    \n    /** Its factory for registration */\n    private static class Factory implements IRenderFactory<EntityUnderworldCreeper> {\n\n\t\t@Override\n\t\tpublic Render<? super EntityUnderworldCreeper> createRenderFor(RenderManager manager) {\n\t\t\treturn new RenderUnderworldCreeper(manager);\n\t\t}\n    \t\n    }\n\n}\n", ";\n\tprivate User toUser;\n\tprivate Date date;\n\tRequestStatus status;\n\t\n\tpublic AddRequest(User from, User to, Date date) {\n\t\tfromUser = from;\n\t\ttoUser = to;\n\t\tthis.date = date;\n\t\tstatus = RequestStatus.Unread;\n\t}\n\t\n\tpublic RequestStatus getStatus() {\n\t\treturn status;\n\t}\n\t\n\tpublic User getFromUser() {\n\t\treturn fromUser;\n\t}\n\t\n\tpublic User getToUser() {\n\t\treturn toUser;\n\t}\n\t\n\tpublic Date getDate() {\n\t\treturn date;\n\t}\n}\n", "t android.media.AudioPlaybackCaptureConfiguration;\nimport android.media.AudioRecord;\nimport android.media.MediaRecorder;\nimport android.media.audiofx.AcousticEchoCanceler;\nimport android.media.audiofx.AudioEffect;\nimport android.os.Build;\nimport android.os.Process;\nimport android.util.Log;\n\nimport org.deviceconnect.android.libmedia.BuildConfig;\nimport org.deviceconnect.android.libmedia.streaming.MediaEncoderException;\nimport org.deviceconnect.android.libmedia.streaming.audio.filter.Filter;\nimport org.deviceconnect.android.libmedia.streaming.util.QueueThread;\n\nimport java.nio.ByteBuffer;\n\n/**\n * \u30de\u30a4\u30af\u304b\u3089\u97f3\u58f0\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u3066\u3001\u30a8\u30f3\u30b3\u30fc\u30c9\u3059\u308b\u30af\u30e9\u30b9.\n */\npublic class MicAACLATMEncoder extends AudioEncoder {\n    private static final boolean DEBUG = BuildConfig.DEBUG;\n    private static final String TAG = \"MIC-AAC-ENCODER\";\n\n    /**\n     * \u97f3\u58f0\u306e\u30a8\u30f3\u30b3\u30fc\u30c9\u8a2d\u5b9a.\n     */\n    private final MicAudioQuality mAudioQuality = new MicAudioQuality(\"audio/mp4a-latm\");\n\n    /**\n     * \u30de\u30a4\u30af\u304b\u3089\u97f3\u58f0\u3092\u30ec\u30b3\u30fc\u30c9\u3059\u308b\u30af\u30e9\u30b9.\n     */\n    private AudioRecord mAudioRecord;\n\n    /**\n     * \u30a8\u30b3\u30fc\u30ad\u30e3\u30f3\u30bb\u30e9\u30fc.\n     */\n    private AcousticEchoCanceler mEchoCanceler;\n\n    /**\n     * AudioRecord \u3067\u4f7f\u7528\u3059\u308b\u30d0\u30c3\u30d5\u30a1\u30b5\u30a4\u30ba.\n     */\n    private int mBufferSize;\n\n    /**\n     * \u9332\u97f3\u3092\u884c\u3046\u30b9\u30ec\u30c3\u30c9.\n     */\n    private AudioRecordThread mAudioThread;\n\n    /**\n     * \u30df\u30e5\u30fc\u30c8\u7528\u306e\u97f3\u58f0\u30c7\u30fc\u30bf\u3092\u78ba\u4fdd\u3059\u308b\u30d0\u30c3\u30d5\u30a1.\n     */\n    private byte[] mMuteBuffer;\n\n    @Override\n    public AudioQuality getAudioQuality() {\n        return mAudioQuality;\n    }\n\n    @Override\n    protected synchronized void startRecording() {\n        super.startRecording();\n\n        try {\n            startAudioRecord();\n        } catch (Exception e) {\n            // AudioRecord \u306e\u521d\u671f\u5316\u4e2d\u306b\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u305f\u5834\u5408\u306f\u3068\u308a\u3042\u3048\u305a\u505c\u6b62\u3057\u3066\u304a\u304f\n            stopAudioRecord();\n        }\n    }\n\n    @Override\n    protected synchronized void stopRecording() {\n        stopAudioRecord();\n        super.stopRecording();\n    }\n\n    @Override\n    protected void onInputData(ByteBuffer inputData, int index) {\n        inputData.clear();\n\n        if (mAudioRecord == null || mAudioThread == null || mMuteBuffer == null) {\n            mMediaCodec.queueInputBuffer(index, 0, 0, getPTSUs(), 0);\n        } else if (isMute()) {\n            // \u30df\u30e5\u30fc\u30c8\u8a2d\u5b9a\u306e\u5834\u5408\u306b\u306f\u3001AudioRecord \u304b\u3089\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3057\u306a\u3044\n            int length = mMuteBuffer.length;\n            if (inputData.remaining() < length) {\n                length = inputData.remaining();\n            }\n            inputData.put(mMuteBuffer, 0, length);\n            mMediaCodec.queueInputBuffer(index, 0, length, getPTSUs(), 0);\n        } else {\n            mAudioThread.add(() -> {\n                int len = mAudioRecord.read(inputData, mBufferSize);\n                if (DEBUG && len < 0) {\n                    Log.e(TAG, \"An error occurred with the AudioRecord API ! len=\" + len);\n                }\n                Filter filter = mAudioQuality.getFilter();\n                if (filter != null && len > 0) {\n                    filter.onProcessing(inputData, len);\n                }\n                mMediaCodec.queueInputBuffer(index, 0, len, getPTSUs(), 0);\n            });\n        }\n    }\n\n    /**\n     * \u97f3\u58f0\u3092\u9332\u97f3\u3059\u308b\u305f\u3081\u306e\u30b9\u30ec\u30c3\u30c9.\n     */\n    private static class AudioRecordThread extends QueueThread<Runnable> {\n        /**\n         * \u30b9\u30ec\u30c3\u30c9\u3092\u7d42\u4e86\u3057\u307e\u3059.\n         */\n        void terminate() {\n            interrupt();\n\n            try {\n                join(200);\n            } catch (InterruptedException e) {\n                // ignore.\n            }\n        }\n\n        @Override\n        public void run() {\n            Process.setThreadPriority(Process.THREAD_PRIORITY_URGENT_AUDIO);\n\n            try {\n                while (!isInterrupted()) {\n                    get().run();\n                }\n            } catch (InterruptedException e) {\n                // ignore.\n            } catch (Exception e) {\n                if (DEBUG) {\n                    Log.w(TAG, \"\", e);\n                }\n            }\n        }\n    }\n\n    /**\n     * \u97f3\u58f0\u30bd\u30fc\u30b9\u3092\u53d6\u5f97\u3057\u307e\u3059.\n     *\n     * @return \u97f3\u58f0\u30bd\u30fc\u30b9\n     */\n    private int getAudioSource() {\n        switch (mAudioQuality.getSource()) {\n            case DEFAULT:\n                return MediaRecorder.AudioSource.DEFAULT;\n            case MIC:\n                return MediaRecorder.AudioSource.MIC;\n            case APP:\n            default:\n                throw new RuntimeException(\"Audio source is not supported.\");\n        }\n    }\n\n    public static final int SAMPLES_PER_FRAME = 1024;\n    public static final int FRAMES_PER_BUFFER = 25;\n\n    /**\n     * AudioRecord \u3092\u958b\u59cb\u3057\u307e\u3059.\n     */\n    private void startAudioRecord() {\n        int minBufferSize = AudioRecord.getMinBufferSize(mAudioQuality.getSamplingRate(),\n                mAudioQuality.getChannel(), mAudioQuality.getFormat()) * 2;\n\n        mBufferSize = SAMPLES_PER_FRAME * FRAMES_PER_BUFFER;\n        if (mBufferSize < minBufferSize) {\n            mBufferSize = ((minBufferSize / SAMPLES_PER_FRAME) + 1) * SAMPLES_PER_FRAME * 2;\n        }\n\n        if (DEBUG) {\n            Log.d(TAG, \"AudioQuality: \" + mAudioQuality);\n            Log.d(TAG, \"  bufferSize: \" + mBufferSize);\n        }\n\n        mMuteBuffer = new byte[mBufferSize];\n\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            AudioRecord.Builder builder = new AudioRecord.Builder()\n                    .setAudioFormat(new AudioFormat.Builder()\n                            .setEncoding(mAudioQuality.getFormat())\n                            .setSampleRate(mAudioQuality.getSamplingRate())\n                            .setChannelMask(mAudioQuality.getChannel())\n                            .build())\n                    .setBufferSizeInBytes(mBufferSize);\n\n            switch (mAudioQuality.getSource()) {\n                case DEFAULT:\n                case MIC:\n                    builder.setAudioSource(getAudioSource());\n                    break;\n                case APP:\n                    AudioPlaybackCaptureConfiguration config = mAudioQuality.getCaptureConfig();\n                    if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q && config != null) {\n                        builder.setAudioPlaybackCaptureConfig(config);\n                    } else {\n                        throw new RuntimeException(\"Audio capture settings is invalid.\");\n                    }\n                    break;\n            }\n            mAudioRecord = builder.build();\n        } else {\n            mAudioRecord = new AudioRecord(getAudioSource(),\n                    mAudioQuality.getSamplingRate(),\n                    mAudioQuality.getChannel(),\n                    mAudioQuality.getFormat(),\n                    mBufferSize);\n        }\n\n        if (mAudioRecord.getState() != AudioRecord.STATE_INITIALIZED) {\n            postOnError(new MediaEncoderException(\"AudioRecord is already initialized.\"));\n            return;\n        }\n\n        if (mAudioQuality.isUseAEC() && AcousticEchoCanceler.isAvailable()) {\n            // \u30ce\u30a4\u30ba\u30ad\u30e3\u30f3\u30bb\u30e9\u30fc\n            mEchoCanceler = AcousticEchoCanceler.create(mAudioRecord.getAudioSessionId());\n            if (mEchoCanceler != null) {\n                int ret = mEchoCanceler.setEnabled(true);\n                if (ret != AudioEffect.SUCCESS) {\n                    if (DEBUG) {\n                        Log.w(TAG, \"AcousticEchoCanceler is not supported.\");\n                    }\n                }\n            }\n        }\n\n        mAudioRecord.startRecording();\n\n        mAudioThread = new AudioRecordThread();\n        mAudioThread.setName(\"MicAACLATMEncoder\");\n        mAudioThread.start();\n    }\n\n    /**\n     * AudioRecord \u3092\u505c\u6b62\u3057\u307e\u3059.\n     */\n    private void stopAudioRecord() {\n        if (mAudioThread != null) {\n            mAudioThread.terminate();\n            mAudioThread = null;\n        }\n\n        if (mAudioRecord != null) {\n            try {\n                mAudioRecord.stop();\n            } catch (Exception e) {\n                // ignore.\n            }\n            try {\n                mAudioRecord.release();\n            } catch (Exception e) {\n                // ignore.\n            }\n            mAudioRecord = null;\n        }\n\n        Filter filter = mAudioQuality.getFilter();\n        if (filter != null) {\n            filter.onRelease();\n        }\n\n        if (mEchoCanceler != null) {\n            mEchoCanceler.release();\n            mEchoCanceler = null;\n        }\n    }\n}\n", " granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage org.cactoos.scalar;\n\nimport java.security.SecureRandom;\nimport java.time.Duration;\nimport java.time.Instant;\nimport java.time.temporal.ChronoUnit;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport org.hamcrest.Matchers;\nimport org.junit.jupiter.api.Test;\nimport org.llorllale.cactoos.matchers.Assertion;\nimport org.llorllale.cactoos.matchers.HasValue;\n\n/**\n * Test case for {@link Retry}.\n *\n * @since 0.9\n * @checkstyle JavadocMethodCheck (500 lines)\n */\nfinal class RetryTest {\n\n    @Test\n    void runsScalarMultipleTimes() throws Exception {\n        new Assertion<>(\n            \"must retry in case of failure\",\n            new Retry<>(\n                () -> {\n                    // @checkstyle MagicNumberCheck (1 line)\n                    if (new SecureRandom().nextDouble() > 0.3d) {\n                        throw new IllegalArgumentException(\"May happen\");\n                    }\n                    return 0;\n                },\n                Integer.MAX_VALUE\n            ),\n            new HasValue<>(0)\n        ).affirm();\n    }\n\n    @Test\n    void runsScalarTwiceWithDefaults() throws Exception {\n        // @checkstyle MagicNumberCheck (1 line)\n        final AtomicInteger tries = new AtomicInteger(0);\n        new Assertion<>(\n            \"Should run twice with defaults\",\n            new Retry<>(\n                () -> {\n                    // @checkstyle MagicNumberCheck (1 line)\n                    if (tries.getAndIncrement() <= 1) {\n                        throw new IllegalArgumentException(\"Not enough tries\");\n                    }\n                    return 0;\n                }\n            ),\n           new HasValue<>(0)\n        ).affirm();\n    }\n\n    @Test\n    void runsScalarMultipleTimesIgnoringNegativeDuration()\n        throws Exception {\n        // @checkstyle MagicNumberCheck (2 line)\n        final int times = 2;\n        final AtomicInteger tries = new AtomicInteger(0);\n        new Assertion<>(\n            \"Should ignore negative duration\",\n            new Retry<>(\n                () -> {\n                    if (tries.getAndIncrement() < times) {\n                        throw new IllegalArgumentException(\"Not yet\");\n                    }\n                    return 0;\n                },\n                Integer.MAX_VALUE,\n                // @checkstyle MagicNumberCheck (1 line)\n                Duration.of(-5, ChronoUnit.DAYS)\n            ),\n            new HasValue<>(0)\n        ).affirm();\n    }\n\n    @Test\n    @SuppressWarnings(\"PMD.AvoidInstantiatingObjectsInLoops\")\n    void runsScalarMultipleTimesWithWait() throws Exception {\n        // @checkstyle MagicNumberCheck (3 line)\n        final int times = 3;\n        final long wait = 500;\n        final AtomicInteger tries = new AtomicInteger(0);\n        final List<Instant> executions = new ArrayList<>(times);\n        new Retry<>(\n            () -> {\n                if (tries.getAndIncrement() < times) {\n                    executions.add(Instant.now());\n                    throw new IllegalArgumentException(\"Not done yet\");\n                }\n                return 0;\n            },\n            Integer.MAX_VALUE,\n            Duration.ofMillis(wait)\n        ).value();\n        for (int position = 0; position < executions.size() - 1; position =\n            position + 1) {\n            final int actual = position;\n            new Assertion<>(\n                \"Should wait the given time between attempts\",\n                executions.get(actual).plusMillis(wait),\n                Matchers.lessThanOrEqualTo(executions.get(actual + 1))\n            ).affirm();\n        }\n    }\n}\n", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.compute.fluent.models;\n\nimport com.azure.core.annotation.Fluent;\nimport com.azure.core.util.logging.ClientLogger;\nimport com.azure.resourcemanager.compute.models.GalleryApplicationVersionPropertiesProvisioningState;\nimport com.azure.resourcemanager.compute.models.GalleryApplicationVersionPublishingProfile;\nimport com.azure.resourcemanager.compute.models.ReplicationStatus;\nimport com.fasterxml.jackson.annotation.JsonIgnore;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/** Describes the properties of a gallery Image Version. */\n@Fluent\npublic final class GalleryApplicationVersionProperties {\n    @JsonIgnore private final ClientLogger logger = new ClientLogger(GalleryApplicationVersionProperties.class);\n\n    /*\n     * The publishing profile of a gallery image version.\n     */\n    @JsonProperty(value = \"publishingProfile\", required = true)\n    private GalleryApplicationVersionPublishingProfile publishingProfile;\n\n    /*\n     * The current state of the gallery Application Version. The provisioning\n     * state, which only appears in the response.\n     */\n    @JsonProperty(value = \"provisioningState\", access = JsonProperty.Access.WRITE_ONLY)\n    private GalleryApplicationVersionPropertiesProvisioningState provisioningState;\n\n    /*\n     * This is the replication status of the gallery Image Version.\n     */\n    @JsonProperty(value = \"replicationStatus\", access = JsonProperty.Access.WRITE_ONLY)\n    private ReplicationStatus replicationStatus;\n\n    /**\n     * Get the publishingProfile property: The publishing profile of a gallery image version.\n     *\n     * @return the publishingProfile value.\n     */\n    public GalleryApplicationVersionPublishingProfile publishingProfile() {\n        return this.publishingProfile;\n    }\n\n    /**\n     * Set the publishingProfile property: The publishing profile of a gallery image version.\n     *\n     * @param publishingProfile the publishingProfile value to set.\n     * @return the GalleryApplicationVersionProperties object itself.\n     */\n    public GalleryApplicationVersionProperties withPublishingProfile(\n        GalleryApplicationVersionPublishingProfile publishingProfile) {\n        this.publishingProfile = publishingProfile;\n        return this;\n    }\n\n    /**\n     * Get the provisioningState property: The current state of the gallery Application Version. The provisioning state,\n     * which only appears in the response.\n     *\n     * @return the provisioningState value.\n     */\n    public GalleryApplicationVersionPropertiesProvisioningState provisioningState() {\n        return this.provisioningState;\n    }\n\n    /**\n     * Get the replicationStatus property: This is the replication status of the gallery Image Version.\n     *\n     * @return the replicationStatus value.\n     */\n    public ReplicationStatus replicationStatus() {\n        return this.replicationStatus;\n    }\n\n    /**\n     * Validates the instance.\n     *\n     * @throws IllegalArgumentException thrown if the instance is not valid.\n     */\n    public void validate() {\n        if (publishingProfile() == null) {\n            throw logger\n                .logExceptionAsError(\n                    new IllegalArgumentException(\n                        \"Missing required property publishingProfile in model GalleryApplicationVersionProperties\"));\n        } else {\n            publishingProfile().validate();\n        }\n        if (replicationStatus() != null) {\n            replicationStatus().validate();\n        }\n    }\n}\n", "ldterns.vilebot.util.BaseNick;\nimport com.oldterns.vilebot.util.Ignore;\nimport org.pircbotx.hooks.ListenerAdapter;\nimport org.pircbotx.hooks.events.JoinEvent;\nimport org.pircbotx.hooks.types.GenericMessageEvent;\nimport org.pircbotx.output.OutputIRC;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.TimeZone;\nimport java.util.concurrent.TimeUnit;\n\npublic class LastSeen\n    extends ListenerAdapter\n{\n\n    private static TimeZone timeZone = TimeZone.getTimeZone( \"America/Toronto\" );\n\n    private static DateFormat dateFormat = makeDateFormat();\n\n    @Override\n    public void onGenericMessage( final GenericMessageEvent event )\n    {\n        String userNick = BaseNick.toBaseNick( event.getUser().getNick() );\n        String botNick = event.getBot().getNick();\n\n        if ( !botNick.equals( userNick ) )\n        {\n            LastSeenDB.updateLastSeenTime( userNick );\n        }\n\n        if ( event instanceof JoinEvent && !botNick.equals( userNick ) && !Ignore.getOnJoin().contains( userNick ) )\n        {\n            longTimeNoSee( (JoinEvent) event, userNick );\n        }\n    }\n\n    private void longTimeNoSee( JoinEvent event, String joiner )\n    {\n        OutputIRC outputQ = event.getBot().send();\n        String replyTarget = event.getChannel().getName();\n\n        long lastSeen = LastSeenDB.getLastSeenTime( joiner );\n        long now = System.currentTimeMillis();\n        long timeAgo = now - lastSeen;\n\n        long daysAgo = TimeUnit.MILLISECONDS.toDays( timeAgo );\n\n        if ( daysAgo > 30 )\n        {\n\n            String str = \"Hi \" + joiner + \"! I last saw you \" + daysAgo + \" days ago at \"\n                + dateFormat.format( new Date( lastSeen ) ) + \". Long time, no see.\";\n            outputQ.message( replyTarget, str );\n        }\n\n        LastSeenDB.updateLastSeenTime( joiner );\n    }\n\n    private static DateFormat makeDateFormat()\n    {\n        SimpleDateFormat df = new SimpleDateFormat( \"yyyy-MM-dd'T'HH:mmX\" );\n        df.setTimeZone( timeZone );\n        return df;\n    }\n}\n", "uted under the terms of the MIT License\n */\npackage com.github.tonivade.claudb;\n\nimport org.openjdk.jmh.annotations.Benchmark;\nimport org.openjdk.jmh.annotations.BenchmarkMode;\nimport org.openjdk.jmh.annotations.Mode;\nimport org.openjdk.jmh.annotations.Scope;\nimport org.openjdk.jmh.annotations.State;\n\nimport redis.clients.jedis.Jedis;\nimport redis.clients.jedis.Pipeline;\n\n@State(Scope.Thread)\n@BenchmarkMode(Mode.AverageTime)\npublic class ClauDBBenchmark {\n  \n  private Jedis jedis = new Jedis(\"localhost\", 7081);\n  \n  @Benchmark\n  public void testCommands() {\n    jedis.set(\"a\", \"b\");\n    jedis.set(\"a\", \"b\");\n    jedis.set(\"a\", \"b\");\n    jedis.set(\"a\", \"b\");\n  }\n\n  @Benchmark\n  public void testPipeline() {\n    Pipeline pipeline = jedis.pipelined();\n    pipeline.set(\"a\", \"b\");\n    pipeline.set(\"a\", \"b\");\n    pipeline.set(\"a\", \"b\");\n    pipeline.set(\"a\", \"b\");\n    pipeline.sync();\n  }\n}\n", " (https://github.com/endosnipe)\r\n * \r\n * The MIT License (MIT)\r\n * \r\n * Copyright (c) 2012 Acroquest Technology Co.,Ltd.\r\n * \r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n ******************************************************************************/\r\npackage jp.co.acroquest.endosnipe.javelin.record;\r\n\r\nimport jp.co.acroquest.endosnipe.javelin.CallTreeNode;\r\nimport jp.co.acroquest.endosnipe.javelin.S2MaxAccumulatedTimeUpdateRecordStrategy;\r\nimport jp.co.acroquest.endosnipe.javelin.bean.Invocation;\r\nimport jp.co.acroquest.endosnipe.javelin.log.JavelinLogCallback;\r\n\r\n/**\r\n * seasar\u306eMaxAccumulatedTimeUpdateRecordStrategy\u306b\u3001\r\n * Javelin\u30ed\u30b0\u901a\u77e5\u96fb\u6587\u306e\u9001\u4fe1\u51e6\u7406\u3092\u8ffd\u52a0\u3057\u305f\u30b9\u30c8\u30e9\u30c6\u30b8\u30fc\u3002\r\n * \r\n * @author eriguchi\r\n */\r\npublic class MaxAccumulatedTimeUpdateRecordStrategy extends\r\n        S2MaxAccumulatedTimeUpdateRecordStrategy\r\n{\r\n    /** \u30e1\u30ac\u3092\u8868\u3059\u6570\u5b57 */\r\n    private static final int MEGA = 1000000;\r\n    \r\n    /**\r\n     * \u30a2\u30e9\u30fc\u30e0\u3092\u767a\u751f\u3055\u305b\u308b\u304b\u3069\u3046\u304b\u3092\u5224\u5b9a\u3057\u307e\u3059\u3002<br />\r\n     * \r\n     * @param node {@link CallTreeNode}\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\r\n     * @return \u30a2\u30e9\u30fc\u30e0\u3092\u767a\u751f\u3055\u305b\u308b\u5834\u5408\u3001<code>true</code>\r\n     */\r\n    public boolean judgeSendExceedThresholdAlarm(final CallTreeNode node)\r\n    {\r\n        boolean result = false;\r\n\r\n        Invocation invocation = node.getInvocation();\r\n        if (invocation.getCountFromStartup() > getIgnoreUpdateCount())\r\n        {\r\n            if (node.getAccumulatedTime() > invocation.getAlarmThreshold())\r\n            {\r\n                invocation.setAlarmThreshold(node.getAccumulatedTime());\r\n                result = true;\r\n            }\r\n            \r\n            long cpuTime = node.getCpuTime() / MEGA;\r\n            if (cpuTime > invocation.getAlarmCpuThreshold())\r\n            {\r\n                invocation.setAlarmCpuThreshold(cpuTime);\r\n                result = true;\r\n            }\r\n        }\r\n\r\n        return result;\r\n    }\r\n    \r\n    /**\r\n     * Javelin\u30ed\u30b0\u901a\u77e5\u96fb\u6587\u3092\u9001\u4fe1\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u3002\r\n     * \r\n     * @param node CallTreeNode\r\n     * @return Javelin\u30ed\u30b0\u901a\u77e5\u96fb\u6587\u3092\u9001\u4fe1\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\r\n     */\r\n    @Override\r\n    public JavelinLogCallback createCallback(final CallTreeNode node)\r\n    {\r\n        // \u30a2\u30e9\u30fc\u30e0\u95be\u5024\u3092\u8d85\u3048\u3066\u3044\u305f\u5834\u5408\u306e\u307fJavelin\u30ed\u30b0\u901a\u77e5\u96fb\u6587\u3092\u9001\u4fe1\u3059\u308b\u3002\r\n        if (this.judgeSendExceedThresholdAlarm(node) == false)\r\n        {\r\n            return null;\r\n        }\r\n\r\n        return createCallback();\r\n    }\r\n\r\n    /**\r\n     * Javelin\u30ed\u30b0\u901a\u77e5\u96fb\u6587\u3092\u9001\u4fe1\u3059\u308b\u30b3\u30fc\u30eb\u30d0\u30c3\u30af\u30aa\u30d6\u30b8\u30a7\u30af\u30c8\u3092\u4f5c\u6210\u3059\u308b\u3002\r\n     * \r\n     * @return \u30b3\u30fc\u30eb\u30d0\u30c3\u30af\r\n     */\r\n    @Override\r\n    public JavelinLogCallback createCallback()\r\n    {\r\n        return new JvnFileNotifyCallback();\r\n    }\r\n}\r\n", "d main(String [] args){\n\tScanner sc = new Scanner (System.in);\n\tint [] array = new int [5];\n\tint sum = 0;\n\tint product =1;\n\n\tfor(int i=0; i<array.length; i++){\n\t\tarray[i] = sc.nextInt();\n\t}\n\t\tsc.close();\n\n\tfor(int i=0; i<=array.length; i++){\n\t\ttry {\n\t\t\tproduct = product*array[i];\n\t\t\tsum = sum+array[i];\n\t\t}\n\t\tcatch (ArrayIndexOutOfBoundsException e) {\n\t\t\tSystem.out.println(\"An error has occurred.\");\n\t\t}\n\t}\n\n\t\tSystem.out.println(\"product: \" + product);\n\t\tSystem.out.println(\"sum: \" + sum);\n\n\t}\n}", "", "ent;\nimport com.haku.lecs.entity.Entity;\nimport com.haku.lecs.entity.EntityManager;\nimport org.junit.Test;\n\nimport java.util.BitSet;\n\nimport static org.junit.Assert.*;\n\npublic class ComponentsTest {\n    private final LECSContext context = new LECSContext();\n    private final EntityManager manager = context.entities;\n\n    @Test\n    public void testEmpty() {\n        Entity e = this.manager.create();\n        assertEquals(0, e.components.size());\n    }\n\n    @Test\n    public void testAdd() {\n        Entity e = this.manager.create();\n        assertEquals(0, e.components.size());\n        e.components.add(new Comp1());\n        assertEquals(1, e.components.size());\n        e.components.add(new Comp2());\n        e.components.add(new Comp3());\n        assertEquals(3, e.components.size());\n    }\n\n    @Test\n    public void testRemove() {\n        Entity e = this.manager.create();\n        e.components.add(new Comp1());\n        e.components.add(new Comp2());\n        e.components.add(new Comp3());\n        assertEquals(3, e.components.size());\n        e.components.remove(Comp1.class);\n        assertEquals(2, e.components.size());\n        e.components.remove(Component.getIndex(Comp2.class));\n    }\n\n    @Test\n    public void testContains() {\n        Entity e = this.manager.create();\n        e.components.add(new Comp1());\n        assertTrue(e.components.contains(Comp1.class));\n        e.components.remove(Comp1.class);\n        assertFalse(e.components.contains(Component.getIndex(Comp2.class)));\n    }\n\n    @Test\n    public void testGet() {\n        Entity e = this.manager.create();\n        Comp1 c1 = new Comp1();\n        Comp2 c2 = new Comp2();\n        e.components.add(c1);\n        e.components.add(c2);\n        assertEquals(c1, e.components.get(Comp1.class));\n        e.components.remove(Comp1.class);\n        assertEquals(c2, e.components.get(Component.getIndex(Comp2.class)));\n    }\n\n    @Test\n    public void testClear() {\n        Entity e = this.manager.create();\n        e.components.add(new Comp1());\n        e.components.add(new Comp2());\n        e.components.add(new Comp3());\n        assertEquals(3, e.components.size());\n        e.components.clear();\n        assertEquals(0, e.components.size());\n    }\n\n    @Test\n    public void testGetMask() {\n        Entity e = this.manager.create();\n        e.components.add(new Comp1());\n        e.components.add(new Comp3());\n        BitSet bs = e.components.getMask();\n        assertTrue(bs.get(Component.getIndex(Comp1.class)));\n        assertFalse(bs.get(Component.getIndex(Comp2.class)));\n        assertTrue(bs.get(Component.getIndex(Comp3.class)));\n    }\n\n    public final class Comp1 extends Component {\n\n    }\n\n    public final class Comp2 extends Component {\n\n    }\n\n    public final class Comp3 extends Component {\n\n    }\n}\n", ".config.EmailConfig;\r\nimport monitor.filter.FilterFactory;\r\nimport monitor.filter.LogFilter;\r\nimport monitor.listener.LogListener;\r\nimport monitor.listener.RollingLogListener;\r\nimport monitor.monitoring.LogMonitorFactory;\r\nimport monitor.monitoring.Monitor;\r\nimport monitor.process.LogMonitorManagedProcess;\r\nimport monitor.process.ManagedProcess;\r\nimport monitor.util.PropertiesLoader;\r\nimport org.slf4j.Logger;\r\nimport org.slf4j.LoggerFactory;\r\n\r\nimport java.io.File;\r\nimport java.util.ArrayList;\r\nimport java.util.List;\r\nimport java.util.Properties;\r\n\r\n/**\r\n * Created by Basem\r\n */\r\npublic class Main {\r\n\r\n    public static final String FILTER_PROPERTIESS_NAME = \"filter.properties\";\r\n    public static final String MAILPROPERTIESS_NAME = \"mail.properties\";\r\n    public static final String MONITOREDLOGS_PROPERTIESS_NAME = \"monitoredlogs.properties\";\r\n\r\n\r\n    public static void main(String[] args) {\r\n\r\n        ManagedProcess monitoringProcess;\r\n        List<Monitor> monitors;\r\n        FilterFactory filterFactory = new FilterFactory();\r\n        LogMonitorFactory logMonitorFactory = new LogMonitorFactory();\r\n        PropertiesLoader loader = new PropertiesLoader();\r\n        Properties filterProperties = loader.load(FILTER_PROPERTIESS_NAME);\r\n        EmailConfig mailProperties = new EmailConfig(loader.load(MAILPROPERTIESS_NAME));\r\n        Properties monitoredLogsProperties = loader.load(MONITOREDLOGS_PROPERTIESS_NAME);\r\n        Action mailAction = new MailAction(mailProperties);\r\n        LogListener listener = new RollingLogListener();\r\n\r\n\r\n        listener.addObserver(mailAction);\r\n        listener.addFilters(filterFactory.create(filterProperties));\r\n\r\n\r\n        monitors = logMonitorFactory.createTailerMonitors(monitoredLogsProperties, listener);\r\n\r\n        monitoringProcess = new LogMonitorManagedProcess(monitors);\r\n\r\n        Runtime.getRuntime().addShutdownHook(new Thread(monitoringProcess));\r\n\r\n        monitoringProcess.start();\r\n    }\r\n\r\n}\r\n", "tingStrategy.TimeWaitingStrategy;\nimport org.decaywood.utils.URLMapper;\nimport org.jsoup.Jsoup;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\nimport java.net.URL;\nimport java.rmi.RemoteException;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author: decaywood\n * @date: 2015/11/23 10:50\n */\n\n/**\n * \u677f\u5757\u6536\u96c6\u5668\uff0c\u6536\u96c6\u8bc1\u76d1\u4f1a\u6240\u6709\u677f\u5757\u7c7b\u578b\u7f16\u53f7\u4ee5\u53ca\u540d\u79f0\n */\npublic class CommissionIndustryCollector extends AbstractCollector<List<Industry>> {\n\n    public CommissionIndustryCollector() throws RemoteException {\n        this(null);\n    }\n\n    /**\n     *@param strategy \u8d85\u65f6\u7b49\u5f85\u7b56\u7565\uff08null\u5219\u8bbe\u7f6e\u4e3a\u9ed8\u8ba4\u7b49\u5f85\u7b56\u7565\uff09\n     */\n    public CommissionIndustryCollector(TimeWaitingStrategy strategy) throws RemoteException {\n        super(strategy);\n    }\n\n    @Override\n    public List<Industry> collectLogic() throws Exception {\n\n        List<Industry> res = new ArrayList<>();\n\n        String target = URLMapper.COMPREHENSIVE_PAGE.toString();\n\n        String content = request(new URL(target));\n        Document doc = Jsoup.parse(content);\n        Elements element = doc.getElementsByClass(\"second-nav\")\n                .get(1).children()\n                .get(3).children()\n                .get(3).children()\n                .select(\"a\");\n        StringBuilder builder = new StringBuilder();\n        for (Element ele : element) {\n            if (!ele.hasAttr(\"title\") || !ele.hasAttr(\"href\")) continue;\n            builder.append(ele.attr(\"href\"));\n            res.add(new Industry(ele.attr(\"title\"), builder.toString()));\n            builder.delete(0, builder.length());\n        }\n\n        return res;\n    }\n\n\n\n}\n", ".awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\n\npublic class SmartAddRows extends JDialog\n        implements ActionListener {\n    public class SmartAddRowsWinListener extends WindowAdapter {\n\n        public void windowClosing(WindowEvent windowevent) {\n            dispose();\n        }\n\n        public SmartAddRowsWinListener() {\n        }\n    }\n\n\n    public SmartAddRows(adminApp admnaap) {\n        super(admnaap, \" Add Rows\", false);\n        parent = admnaap;\n        getContentPane().setLayout(new BorderLayout());\n        numrows = new JTextField(\"10\");\n        JLabel numrowsLabel = new JLabel(\"  Add \");\n        JLabel therowsLabel = new JLabel(\"  Rows \");\n\n        JPanel inputpan = new JPanel(new GridLayout(0, 3));\n        inputpan.add(numrowsLabel);\n        inputpan.add(numrows);\n        inputpan.add(therowsLabel);\n\n        okido = new JButton(\"Add\");\n        okido.setBackground(new Color(225, 180, 180));\n        okido.setForeground(new Color(0, 0, 180));\n\n        nogo = new JButton(\"Cancel\");\n        nogo.setBackground(new Color(225, 180, 180));\n        nogo.setForeground(new Color(0, 0, 180));\n\n\n        JPanel btnpan = new JPanel(new GridLayout(0, 2));\n        btnpan.add(okido);\n        btnpan.add(nogo);\n\n        JPanel mainpanel = new JPanel(new BorderLayout());\n        mainpanel.add(\"Center\", inputpan);\n        mainpanel.add(\"South\", btnpan);\n\n        getContentPane().add(mainpanel, \"Center\");\n        addWindowListener(new SmartAddRowsWinListener());\n        okido.addActionListener(this);\n        nogo.addActionListener(this);\n        numrows.addActionListener(this);\n        pack();\n\n\n        setResizable(false);\n        setForeground(new Color(0, 0, 120));\n        setLocation(220, 220);\n        show();\n        // setred();\n    }\n\n    public static void main(String args[]) {\n    }\n\n    public void actionPerformed(ActionEvent actionevent) {\n        Object obj = actionevent.getSource();\n        if (obj == okido) {\n            pumprowstoP();\n        }\n        if (obj == nogo) {\n            dispose();\n        }\n        if (obj == numrows) {\n            pumprowstoP();\n        }\n    }\n\n    public void pumprowstoP() {\n        int ii = 0;\n        try {\n            ii = Integer.parseInt(numrows.getText());\n        } catch (Exception e) {\n            parent.setQstatus(e.toString(), false);\n            return;\n        }\n        setVisible(false);\n        parent.addSmartRows(ii);\n    }\n\n    JButton okido;\n    JButton nogo;\n    adminApp parent;\n    JTextField numrows;\n}\n", "tabase.sqlite.SQLiteDatabase;\nimport android.database.sqlite.SQLiteOpenHelper;\n\nimport static com.example.ahmed.popularmovies.provider.MovieContract.MovieEntry;\nimport static com.example.ahmed.popularmovies.provider.MovieContract.ReviewEntry;\nimport static com.example.ahmed.popularmovies.provider.MovieContract.TrailerEntry;\n\n/**\n * Created by ahmed on 12/9/15.\n */\nclass MovieDBHelper extends SQLiteOpenHelper {\n\n    // If you change the database schema, you must increment the database version.\n    private static final int DATABASE_VERSION = 3;\n\n    private static final String DATABASE_NAME = \"movie.db\";\n\n    public MovieDBHelper(Context context) {\n        super(context, DATABASE_NAME, null, DATABASE_VERSION);\n    }\n\n    @Override\n    public void onCreate(SQLiteDatabase sqLiteDatabase) {\n        final String SQL_CREATE_REVIEW_TABLE = \"CREATE TABLE \" + ReviewEntry.TABLE_NAME + \" (\" +\n                                               ReviewEntry._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \" +\n                                               ReviewEntry.COLUMN_MOVIE_ID + \" INTEGER, \" +\n                                               ReviewEntry.COLUMN_AUTHOR + \" TEXT UNIQUE, \" +\n                                               ReviewEntry.COLUMN_CONTENT + \" TEXT UNIQUE, \" +\n                                               \" FOREIGN KEY (\" + ReviewEntry.COLUMN_MOVIE_ID + \") REFERENCES \" +\n                                               MovieEntry.TABLE_NAME + \" (\" + MovieEntry.COLUMN_MOVIE_ID + \"));\";\n        final String SQL_CREATE_TRAILER_TABLE = \"CREATE TABLE \" + TrailerEntry.TABLE_NAME + \" (\" +\n                                                TrailerEntry._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT, \" +\n                                                TrailerEntry.COLUMN_MOVIE_ID + \" INTEGER, \" +\n                                                TrailerEntry.COLUMN_TRAILER_NAME + \" TEXT UNIQUE, \" +\n                                                TrailerEntry.COLUMN_URL + \" TEXT UNIQUE, \" +\n                                                \" FOREIGN KEY (\" + TrailerEntry.COLUMN_MOVIE_ID + \") REFERENCES \" +\n                                                MovieEntry.TABLE_NAME + \" (\" + MovieEntry.COLUMN_MOVIE_ID + \"));\";\n        final String SQL_CREATE_MOVIE_TABLE = \"CREATE TABLE \" + MovieEntry.TABLE_NAME + \" (\" +\n                                              MovieEntry._ID + \" INTEGER PRIMARY KEY AUTOINCREMENT,\" +\n                                              MovieEntry.COLUMN_MOVIE_ID + \" INTEGER UNIQUE NOT NULL, \" +\n                                              MovieEntry.COLUMN_TITLE + \" TEXT UNIQUE NOT NULL, \" +\n                                              MovieEntry.COLUMN_POSTER + \" TEXT  NOT NULL, \" +\n                                              MovieEntry.COLUMN_PLOT + \" TEXT  NOT NULL, \" +\n                                              MovieEntry.COLUMN_RELEASE_DATE + \" TEXT NOT NULL, \" +\n                                              MovieEntry.COLUMN_POPULARITY + \" REAL NOT NULL, \" +\n                                              MovieEntry.COLUMN_RATING + \" REAL NOT NULL, \" +\n                                              MovieEntry.COLUMN_SORT_BY_RATING + \" REAL NOT NULL, \" +\n                                              MovieEntry.COLUMN_IS_FAVORITE + \" INTEGER NOT NULL );\";\n//                                                // Set up the location column as a foreign key to location table.\n//                                                \" FOREIGN KEY (\" + MovieContract.MovieEntry.COLUMN_MOVIE_ID + \") REFERENCES \" +\n//                                                MovieContract.ReviewEntry.TABLE_NAME + \" (\" + MovieContract.ReviewEntry._ID + \"), \" +\n        // To assure the application have just one weather entry per day\n        // per location, it's created a UNIQUE constraint with REPLACE strategy\n//                                                \" UNIQUE (\" + MovieContract.MovieEntry.COLUMN_MOVIE_ID + \") ON CONFLICT REPLACE);\";\n        sqLiteDatabase.execSQL(SQL_CREATE_MOVIE_TABLE);\n        sqLiteDatabase.execSQL(SQL_CREATE_TRAILER_TABLE);\n        sqLiteDatabase.execSQL(SQL_CREATE_REVIEW_TABLE);\n    }\n\n    @Override\n    public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) {\n        // This database is only a cache for online data, so its upgrade policy is\n        // to simply to discard the data and start over\n        // Note that this only fires if you change the version number for your database.\n        // It does NOT depend on the version number for your application.\n        // If you want to update the schema without wiping data, commenting out the next 2 lines\n        // should be your top priority before modifying this method.\n        sqLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + MovieEntry.TABLE_NAME);\n        sqLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + TrailerEntry.TABLE_NAME);\n        sqLiteDatabase.execSQL(\"DROP TABLE IF EXISTS \" + ReviewEntry.TABLE_NAME);\n        onCreate(sqLiteDatabase);\n    }\n}\n\n", "tStream;\nimport java.net.URISyntaxException;\nimport java.net.URL;\nimport java.net.URLConnection;\nimport java.util.LinkedHashMap;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\n\nimport org.apache.http.HttpResponse;\nimport org.apache.http.HttpStatus;\nimport org.apache.http.StatusLine;\nimport org.apache.http.client.methods.HttpGet;\nimport org.apache.http.impl.client.DefaultHttpClient;\nimport org.ksoap2.SoapEnvelope;\nimport org.ksoap2.SoapFault;\nimport org.ksoap2.serialization.SoapObject;\nimport org.ksoap2.serialization.SoapSerializationEnvelope;\nimport org.ksoap2.transport.HttpTransportSE;\nimport org.w3c.dom.Document;\n\nimport android.graphics.Bitmap;\nimport android.graphics.BitmapFactory;\nimport android.util.Log;\n\nimport com.pmu.android.api.transport.ITransportApi;\nimport com.pmu.android.util.SoapParser;\nimport com.pmu.android.util.Util;\n\npublic class TransportApi implements ITransportApi {\n\n\tpublic byte[] get(String url) {\n\t\ttry {\n\t\t\tbyte[] result = null;\n\t\t\tURL aURL = new URL(url);\n\t\t\tURLConnection conn = aURL.openConnection();\n\t\t\tconn.connect();\n\t\t\tInputStream is = conn.getInputStream();\n\t\t\tBufferedInputStream bis = new BufferedInputStream(is);\n\t\t\tbyte[] buffer = new byte[1024];\n\t\t\twhile (bis.read(buffer) != -1) {\n\t\t\t\tif (result != null) {\n\t\t\t\t\tresult = Util.combine(result, buffer);\n\t\t\t\t} else {\n\t\t\t\t\tresult = buffer;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbis.close();\n\t\t\tis.close();\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic Document getXML(URL url) {\n\t\tDocument doc = null;\n\t\tHttpGet uri = null;\n\t\ttry {\n\t\t\turi = new HttpGet(url.toURI());\n\t\t} catch (URISyntaxException e1) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te1.printStackTrace();\n\t\t}\n\n\t\tDefaultHttpClient client = new DefaultHttpClient();\n\t\tHttpResponse resp = null;\n\t\ttry {\n\t\t\tresp = client.execute(uri);\n\t\t} catch (Exception e) {\n\t\t\t// TODO Auto-generated catch block\n\t\t\te.printStackTrace();\n\t\t}\n\t\tStatusLine status = resp.getStatusLine();\n\t\tif (status.getStatusCode() == HttpStatus.SC_OK) {\n\t\t\ttry {\n\t\t\t\tDocumentBuilderFactory factory = DocumentBuilderFactory\n\t\t\t\t\t\t.newInstance();\n\t\t\t\tDocumentBuilder builder;\n\t\t\t\tbuilder = factory.newDocumentBuilder();\n\t\t\t\tdoc = builder.parse(resp.getEntity().getContent());\n\n\t\t\t} catch (Exception e) {\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn doc;\n\t}\n\n\tpublic Bitmap getImage(String url) {\n\t\ttry {\n\t\t\tBitmap result = null;\n\t\t\tURL aURL = new URL(url);\n\t\t\tURLConnection conn = aURL.openConnection();\n\t\t\ttry {\n\t\t\t\tconn.connect();\n\t\t\t} catch (Exception e) {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\tInputStream is = conn.getInputStream();\n\t\t\tif (is != null) {\n\t\t\t\ttry {\n\t\t\t\t\tBufferedInputStream bis = new BufferedInputStream(is);\n\t\t\t\t\tif (bis != null) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tresult = BitmapFactory.decodeStream(is);\n\t\t\t\t\t\t} catch (Exception e) {\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tbis.close();\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t}\n\t\t\t\tis.close();\n\t\t\t}\n\t\t\treturn result;\n\t\t} catch (Exception e) {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\tpublic SoapObject callMethod(String url, String action, String methodName,\n\t\t\tString nameSpace, LinkedHashMap<String, String> paramters) {\n\t\ttry {\n\t\t\tLog.i(\"URL\", url);\n\t\t\tLog.i(\"action\", action);\n\t\t\tLog.i(\"methodName\", methodName);\n\t\t\tLog.i(\"nameSpace\", nameSpace);\n\t\t} catch (Exception e) {\n\t\t}\n\t\tSoapObject result = null;\n\t\tSoapObject request = new SoapObject(nameSpace, methodName);\n\t\tif (paramters != null) {\n\t\t\tfor (String k : paramters.keySet()) {\n\t\t\t\ttry {\n\t\t\t\t\tLog.i(k, paramters.get(k));\n\t\t\t\t} catch (Exception e) {\n\n\t\t\t\t}\n\t\t\t\trequest.addProperty(k, paramters.get(k));\n\t\t\t}\n\t\t}\n\t\tSoapSerializationEnvelope envelope = new SoapSerializationEnvelope(\n\t\t\t\tSoapEnvelope.VER11);\n\n\t\tenvelope.setOutputSoapObject(request);\n\t\tHttpTransportSE androidHttpTransport = new HttpTransportSE(url);\n\n\t\ttry {\n\t\t\tandroidHttpTransport.call(action, envelope);\n\t\t\tresult = (SoapObject) envelope.bodyIn;\n\t\t\ttry {\n\t\t\t\tLog.i(\"body\", SoapParser.getContent(result));\n\t\t\t} catch (Exception e) {\n\t\t\t}\n\t\t} catch (Exception e) {\n\t\t\ttry {\n\t\t\t\tSoapFault sf = (SoapFault) envelope.bodyIn;\n\t\t\t\tresult = new SoapObject(\"Fault\", sf.getMessage());\n\t\t\t\tLog.d(\"************\", sf.getLocalizedMessage());\n\t\t\t\tString fault = sf.getMessage();\n\t\t\t\tLog.d(\"************\", fault);\n\t\t\t\te.printStackTrace();\n\t\t\t} catch (Exception ee) {\n\t\t\t\tee.printStackTrace();\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n}\n", ";\nimport android.graphics.Typeface;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.ArrayAdapter;\nimport android.widget.ImageView;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\nimport com.example.spelldisaster.R;\n\n/**\n * @author horodysk\n */\npublic class InventoryListViewAdapter extends ArrayAdapter<InventoryItem> {\n\n    private int _resource;\n\n    /***/\n    public InventoryListViewAdapter(Context context, int resource, List<InventoryItem> items) {\n        super(context, resource, items);\n        _resource = resource;\n    }\n\n    /***/\n    public InventoryItem getEvent(int position) {\n        return getItem(position);\n    }\n\n    @Override\n    public View getView(int position, View convertView, @SuppressWarnings(\"unused\") ViewGroup parent) {\n        LinearLayout inventoryItemView = inflateTheView(convertView);\n        initializeVIewItems(position, inventoryItemView);\n\n        return inventoryItemView;\n    }\n\n    private LinearLayout inflateTheView(View convertView) {\n        LinearLayout inventoryItemView;\n        if (convertView == null) {\n            inventoryItemView = new LinearLayout(getContext());\n            String inflater = Context.LAYOUT_INFLATER_SERVICE;\n            LayoutInflater vi;\n            vi = (LayoutInflater) getContext().getSystemService(inflater);\n            vi.inflate(_resource, inventoryItemView, true);\n        }\n        else {\n            inventoryItemView = (LinearLayout) convertView;\n        }\n        return inventoryItemView;\n    }\n\n    private void initializeVIewItems(int position, LinearLayout inventoryItemView) {\n        InventoryItem item = getItem(position);\n\n        ImageView icon = (ImageView) inventoryItemView.findViewById(R.id.inventory_item_icon);\n        TextView name = (TextView) inventoryItemView.findViewById(R.id.inventory_item_name);\n        TextView weight = (TextView) inventoryItemView.findViewById(R.id.inventory_item_weight);\n\n        icon.setImageResource(item.getIcon());\n        name.setText(item.getName());\n        weight.setText(Double.toString(item.getWeight()));\n\n        Typeface font = Typeface.createFromAsset(getContext().getAssets(), \"fonts/LibbyHand.ttf\");\n        name.setTypeface(font);\n        weight.setTypeface(font);\n\n    }\n\n}", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage sun.rmi.rmic.newrmic.jrmp;\n\n/**\n * Constants specific to the JRMP rmic generator.\n *\n * WARNING: The contents of this source file are not part of any\n * supported API.  Code that depends on them does so at its own risk:\n * they are subject to change or removal without notice.\n *\n * @author Peter Jones\n **/\nfinal class Constants {\n\n    private Constants() { throw new AssertionError(); }\n\n    /*\n     * fully-qualified names of types used by rmic\n     */\n    static final String REMOTE_OBJECT = \"java.rmi.server.RemoteObject\";\n    static final String REMOTE_STUB = \"java.rmi.server.RemoteStub\";\n    static final String REMOTE_REF = \"java.rmi.server.RemoteRef\";\n    static final String OPERATION = \"java.rmi.server.Operation\";\n    static final String SKELETON = \"java.rmi.server.Skeleton\";\n    static final String SKELETON_MISMATCH_EXCEPTION =\n        \"java.rmi.server.SkeletonMismatchException\";\n    static final String REMOTE_CALL = \"java.rmi.server.RemoteCall\";\n    static final String MARSHAL_EXCEPTION = \"java.rmi.MarshalException\";\n    static final String UNMARSHAL_EXCEPTION = \"java.rmi.UnmarshalException\";\n    static final String UNEXPECTED_EXCEPTION = \"java.rmi.UnexpectedException\";\n\n    /*\n     * stub protocol versions\n     */\n    enum StubVersion { V1_1, VCOMPAT, V1_2 };\n\n    /*\n     * serialVersionUID for all stubs that can use 1.2 protocol\n     */\n    static final long STUB_SERIAL_VERSION_UID = 2;\n\n    /*\n     * version number used to seed interface hash computation\n     */\n    static final int INTERFACE_HASH_STUB_VERSION = 1;\n}\n", " granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage org.magicdgs.readtools.tools.conversion;\n\nimport org.magicdgs.readtools.RTCommandLineProgramTest;\nimport org.magicdgs.readtools.TestResourcesUtils;\n\nimport org.broadinstitute.hellbender.utils.test.ArgumentsBuilder;\nimport org.broadinstitute.hellbender.utils.test.IntegrationTestSpec;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport java.io.File;\n\n/**\n * @author Daniel Gomez-Sanchez (magicDGS)\n */\npublic class StandardizeReadsIntegrationTest extends RTCommandLineProgramTest {\n\n    private final static File TEST_TEMP_DIR =\n            createTempDir(StandardizeReadsIntegrationTest.class.getSimpleName());\n\n    // test files already in standard formatting\n    private final static File STANDARD_SINGLE_INDEX_SE = TestResourcesUtils.getWalkthroughDataFile(\"standard.single_index.SE.sam\");\n    private final static File STANDARD_DUAL_INDEX_SE = TestResourcesUtils.getWalkthroughDataFile(\"standard.dual_index.SE.sam\");\n    private final static File STANDARD_SINGLE_INDEX_PAIRED = TestResourcesUtils.getWalkthroughDataFile(\"standard.single_index.paired.sam\");\n    private final static File STANDARD_DUAL_INDEX_PAIRED = TestResourcesUtils.getWalkthroughDataFile(\"standard.dual_index.paired.sam\");\n\n    // for CRAM\n    // TODO: uncomment when CRAM tests are enabled\n    // private final static File REFERENCE_FOR_CRAM_TESTS = TestResourcesUtils.getWalkthroughDataFile(\"2L.fragment.fa\");\n\n    // TODO: it will be nice to split the data provider in different kind of inputs to\n    // TODO: have a good way of check what is failing (CRAM? BAM? SAM? FASTQ? DUAL_INDEX? SINGLE_INDEX? PAIRED? UNPAIRED? SPLIT_FILES?)\n    // TODO: this will be useful also for enabling reference tests\n    @DataProvider(name = \"toStandardize\")\n    public Object[][] tesStandardizeReadsData() {\n        return new Object[][] {\n                // standardize already standard files provides the same result\n                // SAM files\n                {\"standard.single_index.SE\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", STANDARD_SINGLE_INDEX_SE),\n                        STANDARD_SINGLE_INDEX_SE},\n                {\"standard.dual_index.SE\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", STANDARD_DUAL_INDEX_SE),\n                        STANDARD_DUAL_INDEX_SE},\n                {\"standard.single_index.paired\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", STANDARD_SINGLE_INDEX_PAIRED),\n                        STANDARD_SINGLE_INDEX_PAIRED},\n                {\"standard.dual_index.paired\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", STANDARD_DUAL_INDEX_PAIRED),\n                        STANDARD_DUAL_INDEX_PAIRED},\n                // BAM files\n                {\"standard.single_index.SE.bam\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"standard.single_index.SE.bam\")),\n                        STANDARD_SINGLE_INDEX_SE},\n                {\"standard.dual_index.SE.bam\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"standard.dual_index.SE.bam\")),\n                        STANDARD_DUAL_INDEX_SE},\n                {\"standard.single_index.paired.bam\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"standard.single_index.paired.bam\")),\n                        STANDARD_SINGLE_INDEX_PAIRED},\n                {\"standard.dual_index.paired.bam\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"standard.dual_index.paired.bam\")),\n                        STANDARD_DUAL_INDEX_PAIRED},\n                // CRAM files - requires reference\n                // TODO: to enable CRAM file testing, we should ignore the @SQ header lines\n                // TODO: because they aren't in the expected output (https://github.com/magicDGS/ReadTools/issues/305)\n//                {\"standard.single_index.SE.cram\",\n//                        new ArgumentsBuilder()\n//                                .addReference(REFERENCE_FOR_CRAM_TESTS)\n//                                .addFileArgument(\"input\", )(TestResourcesUtils.getWalkthroughDataFile(\"standard.single_index.SE.cram\")),\n//                        STANDARD_SINGLE_INDEX_SE},\n//                {\"standard.dual_index.SE.cram\",\n//                        new ArgumentsBuilder()\n//                                .addReference(REFERENCE_FOR_CRAM_TESTS)\n//                                .addFileArgument(\"input\", )(TestResourcesUtils.getWalkthroughDataFile(\"standard.dual_index.SE.cram\")),\n//                        STANDARD_DUAL_INDEX_SE},\n//                {\"standard.single_index.paired.cram\",\n//                        new ArgumentsBuilder()\n//                                .addReference(REFERENCE_FOR_CRAM_TESTS)\n//                                .addBooleanArgument(\"interleaved\", true)\n//                                .addFileArgument(\"input\", )(TestResourcesUtils.getWalkthroughDataFile(\"standard.single_index.paired.cram\")),\n//                        STANDARD_SINGLE_INDEX_PAIRED},\n//                {\"standard.dual_index.paired.cram\",\n//                        new ArgumentsBuilder()\n//                                .addReference(REFERENCE_FOR_CRAM_TESTS)\n//                                .addBooleanArgument(\"interleaved\", true)\n//                                .addFileArgument(\"input\", )(TestResourcesUtils.getWalkthroughDataFile(\"standard.dual_index.paired.cram\")),\n//                        STANDARD_DUAL_INDEX_PAIRED},\n\n                // standardize a SAM file with misencoded qualities (Illumina)\n                {\"misencoded.single_index.SE\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"misencoded.single_index.SE.sam\")),\n                        STANDARD_SINGLE_INDEX_SE},\n\n\n                // standardize a SAM with barcode in the read name\n                {\"bc_in_read_name.single_index.SE\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"barcodeInReadName\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"bc_in_read_name.single_index.SE.sam\")),\n                        STANDARD_SINGLE_INDEX_SE},\n                {\"bc_in_read_name.dual_index.SE\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"barcodeInReadName\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"bc_in_read_name.dual_index.SE.sam\")),\n                        STANDARD_DUAL_INDEX_SE},\n                {\"bc_in_read_name.single_index.paired\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"barcodeInReadName\", true)\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"bc_in_read_name.single_index.paired.sam\")),\n                        STANDARD_SINGLE_INDEX_PAIRED},\n                {\"bc_in_read_name.dual_index.paired\",\n                        new ArgumentsBuilder()\n                                .addBooleanArgument(\"barcodeInReadName\", true)\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"bc_in_read_name.dual_index.paired.sam\")),\n                        STANDARD_DUAL_INDEX_PAIRED},\n\n                // standardize a SAM file with dual index stored in BC/B2 tags (e.g., illumina2bam)\n                {\"bc_in_two_tags.dual_index.SE\",\n                        new ArgumentsBuilder()\n                                .addArgument(\"rawBarcodeSequenceTags\", \"BC\")\n                                .addArgument(\"rawBarcodeSequenceTags\", \"B2\")\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"bc_in_two_tags.dual_index.SE.sam\")),\n                        STANDARD_DUAL_INDEX_SE},\n                {\"bc_in_two_tags.dual_index.paired\",\n                        new ArgumentsBuilder()\n                                .addArgument(\"rawBarcodeSequenceTags\", \"BC\")\n                                .addArgument(\"rawBarcodeSequenceTags\", \"B2\")\n                                .addBooleanArgument(\"interleaved\", true)\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"bc_in_two_tags.dual_index.paired.sam\")),\n                        STANDARD_DUAL_INDEX_PAIRED},\n\n                // standardize FASTQ files\n                // with Casava read names\n                {\"casava.single_index.paired\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"casava.single_index.paired_1.fq\"))\n                                .addFileArgument(\"input2\", TestResourcesUtils.getWalkthroughDataFile(\"casava.single_index.paired_2.fq\")),\n                        STANDARD_SINGLE_INDEX_PAIRED},\n                // TODO: with Casava format, single-end data is marked as first of pair\n                // TODO: and we should force somehow single-end processing to set the unpaired flag\n                // TODO: thus, this isn't in the expected output (should be marked as single-end)\n                // TODO: see https://github.com/magicDGS/ReadTools/issues/306 for possible solutions\n                // TODO: we should enable this test once it is solved\n//                {\"casava.single_index.SE\",\n//                        new ArgumentsBuilder()\n//                                .addFileArgument(\"input\", )(TestResourcesUtils.getWalkthroughDataFile(\"casava.single_index.SE.fq\")),\n//                        STANDARD_SINGLE_INDEX_SE},\n                // with Illumina-legacy read names\n                // misencoded qualities (Illumina)\n                {\"legacy.single_index.illumina_quality.SE\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.illumina_quality.SE.fq\")),\n                        STANDARD_SINGLE_INDEX_SE},\n                // misencoded qualities (Illumina)\n                {\"legacy.single_index.illumina_quality.paired\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.illumina_quality_1.fq\"))\n                                .addFileArgument(\"input2\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.illumina_quality_2.fq\")),\n                        STANDARD_SINGLE_INDEX_PAIRED},\n                 // interleaved FASTQ\n                {\"legacy.dual_index.interleaved\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.dual_index.interleaved.fq\"))\n                                .addBooleanArgument(\"interleaved\", true),\n                        STANDARD_DUAL_INDEX_PAIRED\n                },\n                // several standard FASTQ files\n                {\"legacy.dual_index.paired\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.dual_index.paired_1.fq\"))\n                                .addFileArgument(\"input2\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.dual_index.paired_2.fq\")),\n                        STANDARD_DUAL_INDEX_PAIRED},\n                {\"legacy.dual_index.SE\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.dual_index.SE.fq\")),\n                        STANDARD_DUAL_INDEX_SE},\n                {\"legacy.single_index.interleaved.fq\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.interleaved.fq\"))\n                                .addBooleanArgument(\"interleaved\", true),\n                        STANDARD_SINGLE_INDEX_PAIRED},\n                {\"legacy.single_index.paired\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.paired_1.fq\"))\n                                .addFileArgument(\"input2\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.paired_2.fq\")),\n                        STANDARD_SINGLE_INDEX_PAIRED\n                },\n                {\"legacy.single_index.SE\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", TestResourcesUtils.getWalkthroughDataFile(\"legacy.single_index.SE.fq\")),\n                        STANDARD_SINGLE_INDEX_SE},\n\n                // test for barcode quality tags option (not in the Walkthrough data)\n                {\"StandardizeReads_single_SAM_quals\",\n                        new ArgumentsBuilder()\n                                .addFileArgument(\"input\", getTestFile(\"small.single.quals.sam\"))\n                                .addArgument(\"rawBarcodeSequenceTags\", \"BC\")\n                                .addArgument(\"rawBarcodeSequenceTags\", \"B2\")\n                                .addArgument(\"rawBarcodeQualityTag\", \"QT\")\n                                .addArgument(\"rawBarcodeQualityTag\", \"Q2\"),\n                        getTestFile(\"expected_single_standard_quals.sam\")}\n        };\n    }\n\n    // expected output should be SAM\n    @Test(dataProvider = \"toStandardize\")\n    public void tesStandardizeReads(final String name, final ArgumentsBuilder args,\n            final File expectedOutput)\n            throws Exception {\n        // output is always in\n        final File output = new File(TEST_TEMP_DIR, name + \".sam\");\n        // add output and remove from tests the program record\n        args.addFileArgument(\"output\", output)\n                .addBooleanArgument(\"addOutputSAMProgramRecord\", false);\n        runCommandLine(args);\n\n        // using text file concordance\n        // TODO: maybe we should find a different method\n        IntegrationTestSpec.assertEqualTextFiles(output, expectedOutput);\n    }\n\n}", "c ConfigDao configDao;\n\n\tpublic static ConfigDao instance() {\n\t\tif (configDao == null)\n\t\t\tconfigDao = new ConfigDao();\n\t\treturn configDao;\n\t}\n\n\tpublic ConfigDao() {\n\t\tconfig = new Config(\"\u00c1\u00bf\u00b7\u00b7\u00ca\u00bdKTV\", 10, 3, 3);\n\t}\n\n\tpublic Config getConfig() {\n\t\treturn config;\n\t}\n\n\tpublic void setConfig(Config config) {\n\t\tthis.config = config;\n\t}\n}\n", "anted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage com.heartbuffer.pipette.output;\n\nimport java.util.List;\nimport java.util.Map;\n\n/**\n *\n * @author Thomas Cashman\n */\npublic class ElasticsearchHttpOutput extends Output {\n    public static final String TYPE = \"elasticsearch_http\";\n    \n    private int currentNode;\n    \n    public ElasticsearchHttpOutput(List<String> nodeUrls) {\n        this(nodeUrls, DEFAULT_BUFFER_SIZE);\n    }\n\n    public ElasticsearchHttpOutput(List<String> nodeUrls, int bufferSize) {\n        super(bufferSize);\n    }\n\n    @Override\n    public void flush(List<Map<String, Object>> output) {\n        \n    }\n\n    @Override\n    public void preDestroy() {\n    }\n\n    @Override\n    public String getType() {\n        return TYPE;\n    }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.kusto.v2019_09_07;\n\nimport com.microsoft.azure.arm.model.HasInner;\nimport com.microsoft.azure.management.kusto.v2019_09_07.implementation.AzureResourceSkuInner;\nimport com.microsoft.azure.arm.resources.models.HasManager;\nimport com.microsoft.azure.management.kusto.v2019_09_07.implementation.KustoManager;\n\n/**\n * Type representing AzureResourceSku.\n */\npublic interface AzureResourceSku extends HasInner<AzureResourceSkuInner>, HasManager<KustoManager> {\n    /**\n     * @return the capacity value.\n     */\n    AzureCapacity capacity();\n\n    /**\n     * @return the resourceType value.\n     */\n    String resourceType();\n\n    /**\n     * @return the sku value.\n     */\n    AzureSku sku();\n\n}\n", "port org.cthul.monad.Unsafe;\nimport org.cthul.monad.function.CheckedFunction;\nimport org.cthul.monad.function.ExceptionWrapper;\nimport org.cthul.monad.function.RuntimeExceptionWrapper;\nimport org.cthul.monad.result.NoResult;\nimport org.cthul.monad.result.NoValue;\nimport org.cthul.monad.result.ValueResult;\nimport org.cthul.monad.switches.BasicSwitch;\nimport org.cthul.monad.switches.SwitchFunctionBuilder;\n\npublic class UnsafeStatusAdapter {\n    \n    private final Function<Exception, NoValue<?>> parentWrapper;\n    private final CheckedFunction<Unsafe<?, ?>, Status, ?> statusMapper;\n\n    public UnsafeStatusAdapter(Function<Exception, NoValue<?>> parentWrapper) {\n        this.parentWrapper = parentWrapper;\n        this.statusMapper = Unsafe::getStatus;\n    }\n\n    public UnsafeStatusAdapter(UnsafeStatusAdapter parent, CheckedFunction<Unsafe<?, ?>, Status, ?> statusMapper) {\n        this.parentWrapper = parent::apply;\n        this.statusMapper = statusMapper;\n    }\n    \n    private NoValue<?> parentWrap(Exception exception) {\n        return parentWrapper.apply(exception);\n    }\n    \n    protected NoValue<?> apply(Exception exception) {\n        return apply(parentWrap(exception));\n    }\n\n    @SuppressWarnings(\"UseSpecificCatch\")\n    protected <T, X extends Exception> Unsafe<T, X> apply(Unsafe<T, X> unsafe) {\n        if (unsafe.isPresent()) return unsafe;\n        return apply((NoValue<X>) unsafe).asUnsafe();\n    }\n    \n    @SuppressWarnings(\"UseSpecificCatch\")\n    protected <X extends Exception> NoValue<X> apply(NoValue<X> unsafe) {\n        Status newStatus;\n        try {\n            newStatus = statusMapper.apply(unsafe);\n        } catch (Exception ex) {\n            return unsafe.getScope().internal((X) ex);\n        }\n        if (unsafe.getStatus() == newStatus) return unsafe;\n        return unsafe.getScope().noValue(newStatus, unsafe.getException());\n    }\n    \n    public static class Checked<X extends Exception> extends UnsafeStatusAdapter implements ExceptionWrapper<X> {\n\n        private final ExceptionWrapper<X> wrapper;\n\n        public Checked(ExceptionWrapper<X> wrapper) {\n            super(wrapper::failed);\n            this.wrapper = wrapper;\n        }\n\n        protected Checked(Checked parent, CheckedFunction<Unsafe<?, ?>, Status, ?> statusMapper) {\n            super(parent, statusMapper);\n            this.wrapper = parent.wrapper;\n        }\n\n        public Checked<X> withStatusMapper(CheckedFunction<Unsafe<?, ?>, Status, ?> statusMapper) {\n            return new Checked<>(this, statusMapper);\n        }\n\n        @Override\n        public NoValue<X> failed(Exception exception) {\n            return (NoValue) apply(exception);\n        }\n\n        @Override\n        public <T> ValueResult<T> value(T value) {\n            return wrapper.value(value);\n        }\n\n        @Override\n        public NoResult okNoValue() {\n            return wrapper.okNoValue();\n        }\n\n        @Override\n        public BasicSwitch<Unsafe<?, ?>, Unsafe<?, ?>, Status, ? extends ExceptionWrapper<X>> withStatus() {\n            return SwitchFunctionBuilder.functionBuilder(this::withStatusMapper).asBasicSwitch();\n        }\n    }\n    \n    public static class Unchecked<X extends RuntimeException> extends UnsafeStatusAdapter implements RuntimeExceptionWrapper<X> {\n\n        private final RuntimeExceptionWrapper<X> wrapper;\n\n        public Unchecked(RuntimeExceptionWrapper<X> wrapper) {\n            super(wrapper::failed);\n            this.wrapper = wrapper;\n        }\n\n        protected Unchecked(Unchecked parent, CheckedFunction<Unsafe<?, ?>, Status, ?> statusMapper) {\n            super(parent, statusMapper);\n            this.wrapper = parent.wrapper;\n        }\n\n        public Unchecked<X> withStatusMapper(CheckedFunction<Unsafe<?, ?>, Status, ?> statusMapper) {\n            return new Unchecked<>(this, statusMapper);\n        }\n\n        @Override\n        public NoResult failed(Exception exception) {\n            return apply(exception).unchecked().noValue();\n        }\n\n        @Override\n        public <T> ValueResult<T> value(T value) {\n            return wrapper.value(value);\n        }\n\n        @Override\n        public NoResult okNoValue() {\n            return wrapper.okNoValue();\n        }\n\n        @Override\n        public BasicSwitch<Unsafe<?, ?>, Unsafe<?, ?>, Status, ? extends RuntimeExceptionWrapper<X>> withStatus() {\n            return SwitchFunctionBuilder.functionBuilder(this::withStatusMapper).asBasicSwitch();\n        }\n    }\n}\n", "aergoth.coreapi.rule.RuleDTO;\nimport net.daergoth.serviceapi.actors.ActorConvertException;\nimport net.daergoth.serviceapi.rule.RuleVO;\nimport net.daergoth.serviceapi.sensors.SensorConvertException;\n\n/**\n * Converter between {@code RuleDTO} and {@code RuleVO}.\n * Methods of this class should only be used in Service layer.\n *\n * @see net.daergoth.coreapi.rule.RuleDTO\n * @see net.daergoth.serviceapi.rule.RuleVO\n */\npublic class RuleConverter {\n\t\n\t/**\n\t * Converts a {@code RuleDTO} to VO.\n\t * @param dto  the DTO to convert\n\t * @return {@code RuleVO} equivalent to the DTO\n\t * @throws SensorConvertException if a {@code Sensor} related to this {@code Rule} has invalid type\n\t * @throws ActorConvertException if an {@code Actor} related to this {@code Rule} has invalid type\n\t */\n\tpublic static RuleVO toVO(RuleDTO dto) throws SensorConvertException, ActorConvertException {\n\t\tRuleVO vo = new RuleVO();\n\t\tvo.setId(dto.getId());\n\t\tvo.setName(dto.getName());\n\t\tvo.setEnabled(dto.isEnabled());\n\t\tvo.setConditions(ConditionConverter.toVOs(dto.getConditions()));\n\t\tvo.setActions(ActionConverter.toVOs(dto.getActions()));\n\t\treturn vo;\n\t}\n\t\n\t/**\n\t * Converts a list of {@code RuleDTO}s to VOs.\n\t * @param dtoList  the list of DTOs to convert\n\t * @return list of {@code RuleVO}s equivalent to the DTOs\n\t * @throws SensorConvertException if a {@code Sensor} related to one of the {@code Rule}s has invalid type\n\t * @throws ActorConvertException if an {@code Actor} related to one of the {@code Rule}s has invalid type\n\t */\n\tpublic static List<RuleVO> toVOs(List<RuleDTO> dtoList) throws SensorConvertException, ActorConvertException {\n\t\tList<RuleVO> vos = new ArrayList<>();\n\t\tfor (RuleDTO d : dtoList) {\n\t\t\tvos.add(RuleConverter.toVO(d));\n\t\t}\n\t\treturn vos;\n\t}\n\t\n\t/**\n\t * Converts a {@code RuleVO} to DTO.\n\t * @param vo  the VO to convert\n\t * @return {@code RuleDTO} equivalent to the VO\n\t */\n\tpublic static RuleDTO toDTO(RuleVO vo) {\n\t\tRuleDTO dto = new RuleDTO();\n\t\tdto.setId(vo.getId());\n\t\tdto.setName(vo.getName());\n\t\tdto.setEnabled(vo.isEnabled());\n\t\tdto.setConditions(ConditionConverter.toDTOs(vo.getConditions()));\n\t\tdto.setActions(ActionConverter.toDTOs(vo.getActions()));\n\t\treturn dto;\n\t}\n\t\n\t/**\n\t * Converts a list of {@code RuleVO}s to DTOs.\n\t * @param voList  the list of VOs to convert\n\t * @return list of {@code RuleDTO}s equivalent to the VOs\n\t */\n\tpublic static List<RuleDTO> toDTOs(List<RuleVO> voList) {\n\t\tList<RuleDTO> dtos = new ArrayList<>();\n\t\tfor (RuleVO v : voList) {\n\t\t\tdtos.add(RuleConverter.toDTO(v));\n\t\t}\n\t\treturn dtos;\n\t}\n}\n", "va.nio.file.Path;\nimport java.util.Date;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.amazonaws.AmazonClientException;\nimport com.amazonaws.event.ProgressListener;\nimport com.amazonaws.services.s3.model.GetObjectRequest;\nimport com.amazonaws.services.s3.model.PutObjectRequest;\nimport com.amazonaws.services.s3.transfer.TransferManager;\nimport com.amazonaws.services.s3.transfer.Upload;\nimport com.hood.transcoder.domain.movie.Movie;\nimport com.hood.transcoder.domain.movie.MovieId;\nimport com.hood.transcoder.domain.movie.MovieNotStoredException;\nimport com.hood.transcoder.domain.movie.MovieRepository;\n\npublic class S3MovieRepository implements MovieRepository\n{\n    private static final Logger logger = LoggerFactory.getLogger( S3MovieRepository.class );\n    private static final String S3_BUCKET_HOOD_ETS_SOURCE = \"hood-ets-source\";\n\n    private final TransferManager transferManager;\n\n    public S3MovieRepository( final TransferManager transferManager )\n    {\n        this.transferManager = transferManager;\n    }\n\n    @Override\n    public Movie get( final MovieId movieId )\n    {\n        final String key = movieId.getMovieId();\n        logger.debug( \"Downloading {} from S3\", key );\n        final GetObjectRequest getObjectRequest = new GetObjectRequest( S3_BUCKET_HOOD_ETS_SOURCE, key );\n        try\n        {\n            final Path outputPath = Files.createTempFile( \"movie\", key );\n            final File outputFile = outputPath.toFile();\n            this.transferManager.getAmazonS3Client().getObject( getObjectRequest, outputFile );\n            return new Movie( new MovieId( outputFile.getAbsolutePath() ), outputPath );\n        }\n        catch ( final Exception e )\n        {\n            logger.error( \"Exception while downloading\", e );\n        }\n        return null;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.hood.transcoder.MovieRepository#store(com.hood.transcoder.Movie)\n     */\n    @Override\n    public void store( final Movie movie ) throws MovieNotStoredException\n    {\n        final String key = movie.getMovieId().getMovieId();\n        logger.info( \"Uploading {} to S3 key {}\", movie, key );\n        final File movieFile = movie.getPath().toFile();\n        final PutObjectRequest putObjectRequest = new PutObjectRequest( S3_BUCKET_HOOD_ETS_SOURCE, key, movieFile );\n        final ProgressListener progressListener = new S3ProgressListener( key, movieFile.length() );\n        try\n        {\n            final Upload upload = this.transferManager.upload( putObjectRequest );\n            upload.addProgressListener( progressListener );\n            upload.waitForCompletion();\n        }\n        catch ( AmazonClientException | InterruptedException e )\n        {\n            this.transferManager.abortMultipartUploads( S3_BUCKET_HOOD_ETS_SOURCE, new Date() );\n            throw new MovieNotStoredException( movie, e );\n        }\n        logger.info( \"Upload complete.\" );\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.hood.transcoder.MovieRepository#remove(com.hood.transcoder.Movie)\n     */\n    @Override\n    public void remove( final Movie movie )\n    {\n        final String key = movie.getMovieId().getMovieId();\n        logger.info( \"Deleting file: {}\", key );\n        this.transferManager.getAmazonS3Client().deleteObject( S3_BUCKET_HOOD_ETS_SOURCE, key );\n    }\n}\n", "Activity;\nimport android.os.Bundle;\nimport android.webkit.WebView;\n\npublic class NewsReader extends AppCompatActivity {\n    WebView newsReader;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_newsreader);\n\n        Intent i = getIntent();\n        newsReader = (WebView) findViewById(R.id.newsReader);\n        newsReader.loadUrl(i.getStringExtra(\"newsreader\"));\n    }\n}\n", " main(String[] args) {\n\t\tString str = \"bbbab\";\n\t\tLongestPalindromeSubStringSubSequence longestPalindromeSubString = new LongestPalindromeSubStringSubSequence();\n\t\tSystem.out.println(longestPalindromeSubString.longestPalindromeSubString(str));\n\n\t}\n\n\tpublic String longestPalindromeSubString(String str) {\n\t\tBoolean dp[][] = new Boolean[str.length()][str.length()];\n\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tfor (int j = 0; j < str.length(); j++) {\n\t\t\t\tdp[i][j] = false;\n\t\t\t}\n\t\t}\n\n\t\tint maxLength = 1;\n\t\tint startIndex = 0;\n\n\t\t// All single characters are palindrome\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tdp[i][i] = true;\n\t\t}\n\n\t\t// All length 2 substrings\n\t\tfor (int i = 0; i < str.length() - 1; i++) {\n\t\t\tif (str.charAt(i) == str.charAt(i + 1)) {\n\t\t\t\tdp[i][i + 1] = true;\n\t\t\t\tstartIndex = i;\n\t\t\t\tmaxLength = 2;\n\t\t\t}\n\t\t}\n\n\t\tfor (int len = 3; len <= str.length(); len++) { // len: length of substring\n\t\t\tfor (int start = 0; start < str.length() - len + 1; start++) {\n\t\t\t\tint end = start + len - 1; // j:end index\n\t\t\t\tif (dp[start + 1][end - 1] && str.charAt(start) == str.charAt(end)) {\n\t\t\t\t\tdp[start][end] = true;\n\t\t\t\t\tif (len > maxLength) {\n\t\t\t\t\t\tstartIndex = start;\n\t\t\t\t\t\tmaxLength = len;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn str.substring(startIndex, startIndex + maxLength);\n\t}\n\n\tpublic int longestPalindromeSubSequence(String str) {\n\t\tint dp[][] = new int[str.length()][str.length()];\n\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tfor (int j = 0; j < str.length(); j++) {\n\t\t\t\tdp[i][j] = 0;\n\t\t\t}\n\t\t}\n\n\t\t// All single characters are palindrome\n\t\tfor (int i = 0; i < str.length(); i++) {\n\t\t\tdp[i][i] = 1;\n\t\t}\n\n\t\tfor (int len = 2; len <= str.length(); len++) { // len: length of substring\n\t\t\tfor (int start = 0; start < str.length() - len + 1; start++) {\n\t\t\t\tint end = start + len - 1;\n\t\t\t\tif (str.charAt(start) == str.charAt(end) && len == 2)\n\t\t\t\t\tdp[start][end] = 2;\n\t\t\t\telse if (str.charAt(start) == str.charAt(end))\n\t\t\t\t\tdp[start][end] = dp[start + 1][end - 1] + 2;\n\t\t\t\telse\n\t\t\t\t\tdp[start][end] = Math.max(dp[start + 1][end], dp[start][end - 1]);\n\t\t\t}\n\t\t}\n\t\treturn dp[0][str.length() - 1];\n\t}\n}\n", "LTI=true,NODE_USES_PARSER=false,VISITOR=true,TRACK_TOKENS=false,NODE_PREFIX=,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */\npackage stage2;\n\npublic\nclass whileStat_AST extends SimpleNode {\n  binaryExpression_AST condition;\n  SimpleNode body;\n  public whileStat_AST(int id) {\n    super(id);\n  }\n\n  public whileStat_AST(Decaf p, int id) {\n    super(p, id);\n  }\n\n\n  /** Accept the visitor. **/\n  public Object jjtAccept(DecafVisitor visitor, ScopeElement data) {\n    return visitor.visitWhileStat(this, data);\n  }\n\npublic void cAccept(CodeGenerator codeGenerator, ScopeElement data,\n\t\tString brkLbl, String contLbl, String nextLbl) {\n\tcodeGenerator.visitWhileStat(this, data, brkLbl, contLbl, nextLbl);\n}\n}\n/* JavaCC - OriginalChecksum=bde3061e834ce3f3b7adacd770a6fce8 (do not edit this line) */\n", "tility functions\n * @author NilsCoding\n */\npublic class ScopeUtils {\n\n    private ScopeUtils() { }\n    \n    /**\n     * Resolves the scope by name, returns default scope if invalid\n     * @param scopeName scope name\n     * @param defaultScope  default scope to return if invalid\n     * @return  scope or default scope\n     */\n    public static int resolveScopeByName(String scopeName, int defaultScope) {\n        if (scopeName == null) {\n            return defaultScope;\n        }\n        scopeName = scopeName.trim().toLowerCase();\n        if (scopeName.length() == 0) {\n            return defaultScope;\n        }\n        switch (scopeName) {\n            case \"application\": return PageContext.APPLICATION_SCOPE;\n            case \"page\": return PageContext.PAGE_SCOPE;\n            case \"request\": return PageContext.REQUEST_SCOPE;\n            case \"session\": return PageContext.SESSION_SCOPE;\n        }\n        return defaultScope;\n    }\n    \n}\n", "= new Zoo(\"Berlin\");\n\tWolf lupo1 = new Wolf(\"Lupo1\", 80.0, true, z1);\n\tWolf lupo2 = new Wolf(\"Lupo2\", 65.5, true, z1);\n\tHase bunny = new Hase(\"Bunny\", 7.8, true, \"Karotten\", 5.2, z2);\n\tHase hasi  = new Hase(\"Hasi\", 5.0, false, \"Salat\", 4.1, z1);\n\tReh bambi  = new Reh(\"Bambi\",25.0, true, \"Gras\", true, z1);\n\tHyaene shenzi = new Hyaene(\"Shenzi\", 50, true, z1);\n\n\tSystem.out.println (z2.toString());\n\tSystem.out.println (z1.toString());\n\tlupo1.friss(lupo1);\n\tlupo1.erlege(bambi);\n\tSystem.out.println (z1.toString());\n\tlupo1.friss(bambi);\n\tSystem.out.println (z1.toString());\n\tSystem.out.println (\"Der Mageninhalt von \"\n\t\t\t    + lupo1.name\n\t\t\t    + \" ist: \"\n\t\t\t    + lupo1.magenInhalt());\n\tlupo1.erlege(hasi);\n\tlupo1.friss(hasi);\n\tlupo1.erlege(lupo2);\n\tlupo1.friss(lupo2);\n\tSystem.out.println (\"Jetzt ist der Mageninhalt von \"\n\t\t\t    + lupo1.name\n\t\t\t    + \": \"\n\t\t\t    + lupo1.magenInhalt());\n\tlupo2.friss(bunny);\n\tlupo1.erlege(lupo1);\n\tSystem.out.println (z1.toString());\n    }\n}\n", ".accounts.AccountManager;\nimport android.app.Dialog;\nimport android.app.ProgressDialog;\nimport android.content.DialogInterface;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.text.Editable;\nimport android.text.Html;\nimport android.text.TextWatcher;\nimport android.text.method.LinkMovementMethod;\nimport android.view.KeyEvent;\nimport android.view.View;\nimport android.view.View.OnKeyListener;\nimport android.widget.ArrayAdapter;\nimport android.widget.AutoCompleteTextView;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\nimport android.widget.TextView.OnEditorActionListener;\n\nimport com.lnidigitalmarketing.aacc.BootstrapApplication;\nimport com.lnidigitalmarketing.aacc.R;\nimport com.lnidigitalmarketing.aacc.R.id;\nimport com.lnidigitalmarketing.aacc.R.layout;\nimport com.lnidigitalmarketing.aacc.R.string;\nimport com.lnidigitalmarketing.aacc.core.BootstrapService;\nimport com.lnidigitalmarketing.aacc.core.Constants;\nimport com.lnidigitalmarketing.aacc.core.User;\nimport com.lnidigitalmarketing.aacc.events.UnAuthorizedErrorEvent;\nimport com.lnidigitalmarketing.aacc.ui.TextWatcherAdapter;\nimport com.lnidigitalmarketing.aacc.util.SafeAsyncTask;\nimport com.lnidigitalmarketing.aacc.util.Toaster;\nimport com.squareup.otto.Bus;\nimport com.squareup.otto.Subscribe;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport javax.inject.Inject;\n\nimport butterknife.Bind;\nimport butterknife.ButterKnife;\n\nimport retrofit.RetrofitError;\nimport timber.log.Timber;\n\nimport static android.R.layout.simple_dropdown_item_1line;\nimport static android.accounts.AccountManager.KEY_ACCOUNT_NAME;\nimport static android.accounts.AccountManager.KEY_ACCOUNT_TYPE;\nimport static android.accounts.AccountManager.KEY_AUTHTOKEN;\nimport static android.accounts.AccountManager.KEY_BOOLEAN_RESULT;\nimport static android.view.KeyEvent.ACTION_DOWN;\nimport static android.view.KeyEvent.KEYCODE_ENTER;\nimport static android.view.inputmethod.EditorInfo.IME_ACTION_DONE;\n\n/**\n * Activity to authenticate the user against an API (example API on Parse.com)\n */\npublic class BootstrapAuthenticatorActivity extends ActionBarAccountAuthenticatorActivity {\n\n    /**\n     * PARAM_CONFIRM_CREDENTIALS\n     */\n    public static final String PARAM_CONFIRM_CREDENTIALS = \"confirmCredentials\";\n\n    /**\n     * PARAM_PASSWORD\n     */\n    public static final String PARAM_PASSWORD = \"password\";\n\n    /**\n     * PARAM_USERNAME\n     */\n    public static final String PARAM_USERNAME = \"username\";\n\n    /**\n     * PARAM_AUTHTOKEN_TYPE\n     */\n    public static final String PARAM_AUTHTOKEN_TYPE = \"authtokenType\";\n\n\n    private AccountManager accountManager;\n\n    @Inject BootstrapService bootstrapService;\n    @Inject Bus bus;\n\n    @Bind(id.et_email) protected AutoCompleteTextView emailText;\n    @Bind(id.et_password) protected EditText passwordText;\n    @Bind(id.b_signin) protected Button signInButton;\n\n    private final TextWatcher watcher = validationTextWatcher();\n\n    private SafeAsyncTask<Boolean> authenticationTask;\n    private String authToken;\n    private String authTokenType;\n\n    /**\n     * If set we are just checking that the user knows their credentials; this\n     * doesn't cause the user's password to be changed on the device.\n     */\n    private Boolean confirmCredentials = false;\n\n    private String email;\n\n    private String password;\n\n\n    /**\n     * In this instance the token is simply the sessionId returned from Parse.com. This could be a\n     * oauth token or some other type of timed token that expires/etc. We're just using the parse.com\n     * sessionId to prove the example of how to utilize a token.\n     */\n    private String token;\n\n    /**\n     * Was the original caller asking for an entirely new account?\n     */\n    protected boolean requestNewAccount = false;\n\n    @Override\n    public void onCreate(Bundle bundle) {\n        super.onCreate(bundle);\n\n        BootstrapApplication.component().inject(this);\n\n        accountManager = AccountManager.get(this);\n\n        final Intent intent = getIntent();\n        email = intent.getStringExtra(PARAM_USERNAME);\n        authTokenType = intent.getStringExtra(PARAM_AUTHTOKEN_TYPE);\n        confirmCredentials = intent.getBooleanExtra(PARAM_CONFIRM_CREDENTIALS, false);\n\n        requestNewAccount = email == null;\n\n        setContentView(layout.login_activity);\n\n        ButterKnife.bind(this);\n\n        emailText.setAdapter(new ArrayAdapter<String>(this,\n                simple_dropdown_item_1line, userEmailAccounts()));\n\n        passwordText.setOnKeyListener(new OnKeyListener() {\n\n            public boolean onKey(final View v, final int keyCode, final KeyEvent event) {\n                if (event != null && ACTION_DOWN == event.getAction()\n                        && keyCode == KEYCODE_ENTER && signInButton.isEnabled()) {\n                    handleLogin(signInButton);\n                    return true;\n                }\n                return false;\n            }\n        });\n\n        passwordText.setOnEditorActionListener(new OnEditorActionListener() {\n\n            public boolean onEditorAction(final TextView v, final int actionId,\n                                          final KeyEvent event) {\n                if (actionId == IME_ACTION_DONE && signInButton.isEnabled()) {\n                    handleLogin(signInButton);\n                    return true;\n                }\n                return false;\n            }\n        });\n\n        emailText.addTextChangedListener(watcher);\n        passwordText.addTextChangedListener(watcher);\n\n        final TextView signUpText = (TextView) findViewById(id.tv_signup);\n        signUpText.setMovementMethod(LinkMovementMethod.getInstance());\n        signUpText.setText(Html.fromHtml(getString(string.signup_link)));\n    }\n\n    private List<String> userEmailAccounts() {\n        final Account[] accounts = accountManager.getAccountsByType(\"com.google\");\n        final List<String> emailAddresses = new ArrayList<String>(accounts.length);\n        for (final Account account : accounts) {\n            emailAddresses.add(account.name);\n        }\n        return emailAddresses;\n    }\n\n    private TextWatcher validationTextWatcher() {\n        return new TextWatcherAdapter() {\n            public void afterTextChanged(final Editable gitDirEditText) {\n                updateUIWithValidation();\n            }\n\n        };\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        bus.register(this);\n        updateUIWithValidation();\n    }\n\n    @Override\n    protected void onPause() {\n        super.onPause();\n        bus.unregister(this);\n    }\n\n    private void updateUIWithValidation() {\n        final boolean populated = populated(emailText) && populated(passwordText);\n        signInButton.setEnabled(populated);\n    }\n\n    private boolean populated(final EditText editText) {\n        return editText.length() > 0;\n    }\n\n    @Override\n    protected Dialog onCreateDialog(int id) {\n        final ProgressDialog dialog = new ProgressDialog(this);\n        dialog.setMessage(getText(string.message_signing_in));\n        dialog.setIndeterminate(true);\n        dialog.setCancelable(true);\n        dialog.setOnCancelListener(new DialogInterface.OnCancelListener() {\n            public void onCancel(final DialogInterface dialog) {\n                if (authenticationTask != null) {\n                    authenticationTask.cancel(true);\n                }\n            }\n        });\n        return dialog;\n    }\n\n    @Subscribe\n    public void onUnAuthorizedErrorEvent(UnAuthorizedErrorEvent unAuthorizedErrorEvent) {\n        // Could not authorize for some reason.\n        Toaster.showLong(BootstrapAuthenticatorActivity.this, R.string.message_bad_credentials);\n    }\n\n    /**\n     * Handles onClick event on the Submit button. Sends username/password to\n     * the server for authentication.\n     * <p/>\n     * Specified by android:onClick=\"handleLogin\" in the layout xml\n     *\n     * @param view\n     */\n    public void handleLogin(final View view) {\n        if (authenticationTask != null) {\n            return;\n        }\n\n        if (requestNewAccount) {\n            email = emailText.getText().toString();\n        }\n\n        password = passwordText.getText().toString();\n        showProgress();\n\n        authenticationTask = new SafeAsyncTask<Boolean>() {\n            public Boolean call() throws Exception {\n\n                final String query = String.format(\"%s=%s&%s=%s\",\n                        PARAM_USERNAME, email, PARAM_PASSWORD, password);\n\n                User loginResponse = bootstrapService.authenticate(email, password);\n                token = loginResponse.getSessionToken();\n\n                return true;\n            }\n\n            @Override\n            protected void onException(final Exception e) throws RuntimeException {\n                // Retrofit Errors are handled inside of the {\n                if(!(e instanceof RetrofitError)) {\n                    final Throwable cause = e.getCause() != null ? e.getCause() : e;\n                    if(cause != null) {\n                        Toaster.showLong(BootstrapAuthenticatorActivity.this, cause.getMessage());\n                    }\n                }\n            }\n\n            @Override\n            public void onSuccess(final Boolean authSuccess) {\n                onAuthenticationResult(authSuccess);\n            }\n\n            @Override\n            protected void onFinally() throws RuntimeException {\n                hideProgress();\n                authenticationTask = null;\n            }\n        };\n        authenticationTask.execute();\n    }\n\n    /**\n     * Called when response is received from the server for confirm credentials\n     * request. See onAuthenticationResult(). Sets the\n     * AccountAuthenticatorResult which is sent back to the caller.\n     *\n     * @param result\n     */\n    protected void finishConfirmCredentials(final boolean result) {\n        final Account account = new Account(email, Constants.Auth.BOOTSTRAP_ACCOUNT_TYPE);\n        accountManager.setPassword(account, password);\n\n        final Intent intent = new Intent();\n        intent.putExtra(KEY_BOOLEAN_RESULT, result);\n        setAccountAuthenticatorResult(intent.getExtras());\n        setResult(RESULT_OK, intent);\n        finish();\n    }\n\n    /**\n     * Called when response is received from the server for authentication\n     * request. See onAuthenticationResult(). Sets the\n     * AccountAuthenticatorResult which is sent back to the caller. Also sets\n     * the authToken in AccountManager for this account.\n     */\n\n    protected void finishLogin() {\n        final Account account = new Account(email, Constants.Auth.BOOTSTRAP_ACCOUNT_TYPE);\n\n        authToken = token;\n\n        if (requestNewAccount) {\n            accountManager.addAccountExplicitly(account, password, null);\n            accountManager.setAuthToken(account, Constants.Auth.BOOTSTRAP_ACCOUNT_TYPE, authToken);\n        } else {\n            accountManager.setPassword(account, password);\n        }\n\n        final Intent intent = new Intent();\n        intent.putExtra(KEY_ACCOUNT_NAME, email);\n        intent.putExtra(KEY_ACCOUNT_TYPE, Constants.Auth.BOOTSTRAP_ACCOUNT_TYPE);\n\n        if (authTokenType != null\n                && authTokenType.equals(Constants.Auth.AUTHTOKEN_TYPE)) {\n            intent.putExtra(KEY_AUTHTOKEN, authToken);\n        }\n\n        setAccountAuthenticatorResult(intent.getExtras());\n        setResult(RESULT_OK, intent);\n        finish();\n    }\n\n    /**\n     * Hide progress dialog\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected void hideProgress() {\n        dismissDialog(0);\n    }\n\n    /**\n     * Show progress dialog\n     */\n    @SuppressWarnings(\"deprecation\")\n    protected void showProgress() {\n        showDialog(0);\n    }\n\n    /**\n     * Called when the authentication process completes (see attemptLogin()).\n     *\n     * @param result\n     */\n    public void onAuthenticationResult(final boolean result) {\n        if (result) {\n            if (!confirmCredentials) {\n                finishLogin();\n            } else {\n                finishConfirmCredentials(true);\n            }\n        } else {\n            Timber.d(\"onAuthenticationResult: failed to authenticate\");\n            if (requestNewAccount) {\n                Toaster.showLong(BootstrapAuthenticatorActivity.this,\n                        string.message_auth_failed_new_account);\n            } else {\n                Toaster.showLong(BootstrapAuthenticatorActivity.this,\n                        string.message_auth_failed);\n            }\n        }\n    }\n}\n", "ova.CordovaInterface;\nimport org.apache.cordova.CordovaPlugin;\nimport org.apache.cordova.PluginResult;\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport android.app.AlertDialog;\nimport android.app.ProgressDialog;\nimport android.content.DialogInterface;\nimport android.text.InputType;\nimport android.text.method.PasswordTransformationMethod;\nimport android.widget.EditText;\n\n\npublic class PinDialog extends CordovaPlugin {\n\n    public ProgressDialog spinnerDialog = null;\n\n    public PinDialog() {\n    }\n\n    public boolean execute(String action, JSONArray args, final CallbackContext callbackContext) throws JSONException {\n        if (action.equals(\"prompt\")) {\n        \t\n        \tfinal String message = args.getString(0);\n        \tfinal String title = args.getString(1);\n        \tfinal JSONArray buttonLabels = args.getJSONArray(2);\n        \t\n        \tfinal CordovaInterface cordova = this.cordova;\n            final EditText promptInput =  new EditText(cordova.getActivity());\n            promptInput.setInputType(InputType.TYPE_CLASS_NUMBER);\n            promptInput.setTransformationMethod(PasswordTransformationMethod.getInstance());\n           \n            Runnable runnable = new Runnable() {\n                public void run() {\n                    AlertDialog.Builder dlg = new AlertDialog.Builder(cordova.getActivity());\n                    dlg.setMessage(message);\n                    dlg.setTitle(title);\n                    dlg.setCancelable(true);\n                    \n                    dlg.setView(promptInput);\n                    \n                    final JSONObject result = new JSONObject();\n                    \n                    // First button\n                    if (buttonLabels.length() > 0) {\n                        try {\n                            dlg.setNegativeButton(buttonLabels.getString(0),\n                                new AlertDialog.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        dialog.dismiss();\n                                        try {\n                                            result.put(\"buttonIndex\",1);\n                                            result.put(\"input1\", promptInput.getText().toString().trim().length()==0 ? \"\" : promptInput.getText());                                                                                        \n                                        } catch (JSONException e) { e.printStackTrace(); }\n                                        callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, result));\n                                    }\n                                });\n                        } catch (JSONException e) { }\n                    }\n\n                    // Second button\n                    if (buttonLabels.length() > 1) {\n                        try {\n                            dlg.setNeutralButton(buttonLabels.getString(1),\n                                new AlertDialog.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        dialog.dismiss();\n                                        try {\n                                            result.put(\"buttonIndex\",2);\n                                            result.put(\"input1\", promptInput.getText().toString().trim().length()==0 ? \"\" : promptInput.getText());\n                                        } catch (JSONException e) { e.printStackTrace(); }\n                                        callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, result));\n                                    }\n                                });\n                        } catch (JSONException e) { }\n                    }\n\n                    // Third button\n                    if (buttonLabels.length() > 2) {\n                        try {\n                            dlg.setPositiveButton(buttonLabels.getString(2),\n                                new AlertDialog.OnClickListener() {\n                                    public void onClick(DialogInterface dialog, int which) {\n                                        dialog.dismiss();\n                                        try {\n                                            result.put(\"buttonIndex\",3);\n                                            result.put(\"input1\", promptInput.getText().toString().trim().length()==0 ? \"\" : promptInput.getText());\n                                        } catch (JSONException e) { e.printStackTrace(); }\n                                        callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, result));\n                                    }\n                                });\n                        } catch (JSONException e) { }\n                    }\n                    \n                    dlg.setOnCancelListener(new AlertDialog.OnCancelListener() {\n                        public void onCancel(DialogInterface dialog){\n                            dialog.dismiss();\n                            try {\n                                result.put(\"buttonIndex\",0);\n                                result.put(\"input1\", promptInput.getText().toString().trim().length()==0 ? \"\" : promptInput.getText());\n                            } catch (JSONException e) { e.printStackTrace(); }\n                            callbackContext.sendPluginResult(new PluginResult(PluginResult.Status.OK, result));\n                        }\n                    });\n\n                    dlg.create();\n                    dlg.show();\n\n                };\n            };\n            this.cordova.getActivity().runOnUiThread(runnable);\n        \t\n        \t\n        }\n\n        return true;\n    }\n\n}", "e \"License\"); you may not use this file except in compliance with the License.\n */\n\npackage com.hp.autonomy.frontend.find.core.test;\n\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.http.converter.json.Jackson2ObjectMapperBuilder;\n\n@Configuration\n@ConditionalOnProperty(value = \"mock.configuration\", matchIfMissing = true)\npublic class TestConfiguration {\n    @ConditionalOnMissingBean\n    @Bean\n    public Jackson2ObjectMapperBuilder jackson2ObjectMapperBuilder() {\n        return new Jackson2ObjectMapperBuilder();\n    }\n}\n", "pe;\r\n   private int iq, strength;\r\n   public Warrior(String name, char type)\r\n   {\r\n      this.name = name;\r\n      this.type = type;\r\n      generateStats();\r\n   }\r\n   public int getiq()\r\n   {\r\n      return iq;\r\n   }\r\n   public String getName()\r\n   {\r\n      return name;\r\n   }\r\n   public int getStrength()\r\n   {\r\n      return strength;\r\n   }\r\n   public char getType()\r\n   {\r\n      return type;\r\n   }\r\n   public void setiq(int other)\r\n   {\r\n      iq = other;\r\n   }\r\n   public void setStrength(int strength2)\r\n   {\r\n      strength = strength2;\r\n   }\r\n   public abstract void generateStats();\r\n \r\n   public boolean equals(Warrior other)\r\n   {\r\n      if(getName().equals(other.getName()))\r\n      {\r\n         if(getType() == other.getType())\r\n         {\r\n            if(getiq() == other.getiq())\r\n            {\r\n               if(getStrength() == other.getStrength())\r\n               {\r\n                  return true;\r\n               }\r\n            }\r\n         }\r\n      }\r\n      return false; \r\n   }\r\n  \r\n   public String toString()\r\n   {\r\n      return \"Name: \" + getName() + \" Clique: \" + getType() + \" IQ: \" + getiq() + \" Strength: \" + getStrength();\r\n   }\r\n   \r\n   public Warrior fight(Warrior other)\r\n   {\r\n      if(getiq() - other.getiq() >= 20)\r\n      {\r\n         return this;\r\n      }\r\n      else if(other.getiq() - getiq() >= 20)\r\n      {\r\n         return other;\r\n      }\r\n      else if(getStrength() > other.getStrength())\r\n      {\r\n         return this;\r\n      }\r\n      else\r\n         return other;\r\n   }\r\n}", "rays;\nimport java.util.Collections;\nimport java.util.List;\n\n/**\n * Created by sbwdlihao on 07/01/2017.\n */\npublic class StackTest {\n\n    @Test\n    public void testStackOps() {\n        List<VMCase> cases = new ArrayList<>(Arrays.asList(\n                new VMCase(OP.OP_TOALTSTACK,\n                        new VirtualMachine(50000, new ArrayList<>(Collections.singleton(new byte[]{1}))),\n                        new VirtualMachine(49998, new ArrayList<>(), new ArrayList<>(Collections.singleton(new byte[]{1})))\n                ),\n                new VMCase(OP.OP_FROMALTSTACK,\n                        new VirtualMachine(50000, new ArrayList<>(), new ArrayList<>(Collections.singleton(new byte[]{1}))),\n                        new VirtualMachine(49998, new ArrayList<>(Collections.singleton(new byte[]{1})), new ArrayList<>())\n                ),\n                new VMCase(OP.OP_FROMALTSTACK,\n                        new VirtualMachine(50000, new ArrayList<>(), new ArrayList<>()),\n                        Errors.ErrDataStackUnderflow\n                ),\n                new VMCase(OP.OP_2DROP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}, new byte[]{1}))),\n                        new VirtualMachine(50016, new ArrayList<>())\n                ),\n                new VMCase(OP.OP_2DUP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49980, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}, new byte[]{2}, new byte[]{1})))\n                ),\n                new VMCase(OP.OP_3DUP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49970, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{3}, new byte[]{2}, new byte[]{1})))\n                ),\n                new VMCase(OP.OP_2OVER,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{4}, new byte[]{3}, new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49980, new ArrayList<>(Arrays.asList(\n                                new byte[]{4}, new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{4}, new byte[]{3})))\n                ),\n                new VMCase(OP.OP_2OVER,\n                        new VirtualMachine(2, new ArrayList<>(Arrays.asList(\n                                new byte[]{4}, new byte[]{3}, new byte[]{2}, new byte[]{1}))),\n                        Errors.ErrRunLimitExceeded\n                ),\n                new VMCase(OP.OP_2ROT,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{6}, new byte[]{5}, new byte[]{4}, new byte[]{3}, new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49998, new ArrayList<>(Arrays.asList(\n                                new byte[]{4}, new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{6}, new byte[]{5})))\n                ),\n                new VMCase(OP.OP_2SWAP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{4}, new byte[]{3}, new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49998, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}, new byte[]{4}, new byte[]{3})))\n                ),\n                new VMCase(OP.OP_IFDUP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        new VirtualMachine(49990, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}, new byte[]{1})))\n                ),\n                new VMCase(OP.OP_IFDUP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{}))),\n                        new VirtualMachine(49999, new ArrayList<>(Arrays.asList(\n                                new byte[]{})))\n                ),\n                new VMCase(OP.OP_IFDUP,\n                        new VirtualMachine(1, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        Errors.ErrRunLimitExceeded\n                ),\n                new VMCase(OP.OP_DEPTH,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        new VirtualMachine(49990, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}, new byte[]{1})))\n                ),\n                new VMCase(OP.OP_DEPTH,\n                        new VirtualMachine(1, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        Errors.ErrRunLimitExceeded\n                ),\n                new VMCase(OP.OP_DROP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        new VirtualMachine(50008, new ArrayList<>())\n                ),\n                new VMCase(OP.OP_DUP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        new VirtualMachine(49990, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}, new byte[]{1})))\n                ),\n                new VMCase(OP.OP_DUP,\n                        new VirtualMachine(1, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        Errors.ErrRunLimitExceeded\n                ),\n                new VMCase(OP.OP_NIP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(50008, new ArrayList<>(Arrays.asList(\n                                new byte[]{1})))\n                ),\n                new VMCase(OP.OP_NIP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}))),\n                        Errors.ErrDataStackUnderflow\n                ),\n                new VMCase(OP.OP_OVER,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49990, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}, new byte[]{2})))\n                ),\n                new VMCase(OP.OP_OVER,\n                        new VirtualMachine(1, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        Errors.ErrRunLimitExceeded\n                ),\n                new VMCase(OP.OP_PICK,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{2}))),\n                        new VirtualMachine(49998, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{3})))\n                ),\n                new VMCase(OP.OP_PICK,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{3}))),\n                        Errors.ErrDataStackUnderflow\n                ),\n                new VMCase(OP.OP_PICK,\n                        new VirtualMachine(2, new ArrayList<>(Arrays.asList(\n                                new byte[]{(byte)0xff, (byte)0xff}, new byte[]{2}, new byte[]{1}, new byte[]{2}))),\n                        Errors.ErrRunLimitExceeded\n                ),\n                new VMCase(OP.OP_ROLL,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{2}))),\n                        new VirtualMachine(50007, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}, new byte[]{3})))\n                ),\n                new VMCase(OP.OP_ROLL,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}, new byte[]{3}))),\n                        Errors.ErrDataStackUnderflow\n                ),\n                new VMCase(OP.OP_ROT,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{3}, new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49998, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}, new byte[]{3})))\n                ),\n                new VMCase(OP.OP_SWAP,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49999, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}, new byte[]{2})))\n                ),\n                new VMCase(OP.OP_TUCK,\n                        new VirtualMachine(50000, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        new VirtualMachine(49990, new ArrayList<>(Arrays.asList(\n                                new byte[]{1}, new byte[]{2}, new byte[]{1})))\n                ),\n                new VMCase(OP.OP_TUCK,\n                        new VirtualMachine(1, new ArrayList<>(Arrays.asList(\n                                new byte[]{2}, new byte[]{1}))),\n                        Errors.ErrRunLimitExceeded\n                )\n        ));\n\n        byte[] stackOps = new byte[]{\n                OP.OP_DEPTH, OP.OP_FROMALTSTACK, OP.OP_TOALTSTACK, OP.OP_2DROP, OP.OP_2DUP, OP.OP_3DUP,\n                OP.OP_2OVER, OP.OP_2ROT, OP.OP_2SWAP, OP.OP_IFDUP, OP.OP_DROP, OP.OP_DUP, OP.OP_NIP,\n                OP.OP_OVER, OP.OP_PICK, OP.OP_ROLL, OP.OP_ROT, OP.OP_SWAP, OP.OP_TUCK\n        };\n\n        for (byte stackOp : stackOps) {\n            cases.add(new VMCase(stackOp, new VirtualMachine(0), Errors.ErrRunLimitExceeded));\n        }\n        for (int i = 2; i < stackOps.length; i++) {\n            cases.add(new VMCase(stackOps[i], new VirtualMachine(50000, new ArrayList<>()), Errors.ErrDataStackUnderflow));\n        }\n\n        VMCase.runCase(cases);\n    }\n}\n", "nnotation.ColType;\nimport org.nutz.dao.entity.annotation.Column;\nimport org.nutz.dao.entity.annotation.Name;\nimport org.nutz.dao.entity.annotation.Table;\n\n@Table(\"org_departments\")\npublic class Department {\n\t@Name @Column(\"d_id\") @ColDefine(notNull=true, width=64, update=false)\n\tprivate String id;\n\t@Column(\"d_code\") @ColDefine(notNull=true, width=10, update=false)\n\tprivate String code;\n\t@Column(\"d_path\") @ColDefine(notNull=true, width=200, update=false)\n\tprivate String path;\n\t@Column(\"display_name\") @ColDefine(notNull=true, width=200)\n\tprivate String name;\n\t@Column(\"alternate_name\") @ColDefine(notNull=true, width=200)\n\tprivate String altName;\n\t@Column(\"d_description\") @ColDefine(type=ColType.TEXT)\n\tprivate String description;\n\t@Column(\"display_order\") @ColDefine(notNull=true)\n\tprivate Integer displayOrder;\n\t@Column(\"create_time\") @ColDefine(notNull=true)\n\tprivate Long createTime;\n\t@Column(\"updateTime\")\n\tprivate Long updateTime;\n\n\tpublic String getId() {\n\t\treturn id;\n\t}\n\n\tpublic void setId(String id) {\n\t\tthis.id = id;\n\t}\n\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\n\tpublic String getPath() {\n\t\treturn path;\n\t}\n\n\tpublic void setPath(String path) {\n\t\tthis.path = path;\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic String getAltName() {\n\t\treturn altName;\n\t}\n\n\tpublic void setAltName(String altName) {\n\t\tthis.altName = altName;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic Integer getDisplayOrder() {\n\t\treturn displayOrder;\n\t}\n\n\tpublic void setDisplayOrder(Integer displayOrder) {\n\t\tthis.displayOrder = displayOrder;\n\t}\n\n\tpublic Long getCreateTime() {\n\t\treturn createTime;\n\t}\n\n\tpublic void setCreateTime(Long createTime) {\n\t\tthis.createTime = createTime;\n\t}\n\n\tpublic Long getUpdateTime() {\n\t\treturn updateTime;\n\t}\n\n\tpublic void setUpdateTime(Long updateTime) {\n\t\tthis.updateTime = updateTime;\n\t}\n}\n", "rt com.adobe.fre.FREContext;\nimport com.adobe.fre.FREFunction;\n\n/**\n * Android Support v4 ANE for Adobe AIR\n * @author Neil Rackett\n */\npublic class AndroidSupportV4Context extends FREContext\n{\n\tpublic AndroidSupportV4Context() {}\n\t\n\t@Override\n\tpublic Map<String, FREFunction> getFunctions()\n\t{\n\t\treturn new HashMap<String, FREFunction>();\n\t}\n\t\n\t@Override\n\tpublic void dispose() {};\n}\n", "Axis 1.4 Apr 22, 2006 (06:55:48 PDT) WSDL2Java emitter.\n */\n\npackage com.microsoft.bingads.v9.campaignmanagement;\n\npublic class EditorialReasonCollection  implements java.io.Serializable {\n    private java.lang.Long adOrKeywordId;\n\n    private com.microsoft.bingads.v9.campaignmanagement.AppealStatus appealStatus;\n\n    private com.microsoft.bingads.v9.campaignmanagement.EditorialReason[] reasons;\n\n    public EditorialReasonCollection() {\n    }\n\n    public EditorialReasonCollection(\n           java.lang.Long adOrKeywordId,\n           com.microsoft.bingads.v9.campaignmanagement.AppealStatus appealStatus,\n           com.microsoft.bingads.v9.campaignmanagement.EditorialReason[] reasons) {\n           this.adOrKeywordId = adOrKeywordId;\n           this.appealStatus = appealStatus;\n           this.reasons = reasons;\n    }\n\n\n    /**\n     * Gets the adOrKeywordId value for this EditorialReasonCollection.\n     * \n     * @return adOrKeywordId\n     */\n    public java.lang.Long getAdOrKeywordId() {\n        return adOrKeywordId;\n    }\n\n\n    /**\n     * Sets the adOrKeywordId value for this EditorialReasonCollection.\n     * \n     * @param adOrKeywordId\n     */\n    public void setAdOrKeywordId(java.lang.Long adOrKeywordId) {\n        this.adOrKeywordId = adOrKeywordId;\n    }\n\n\n    /**\n     * Gets the appealStatus value for this EditorialReasonCollection.\n     * \n     * @return appealStatus\n     */\n    public com.microsoft.bingads.v9.campaignmanagement.AppealStatus getAppealStatus() {\n        return appealStatus;\n    }\n\n\n    /**\n     * Sets the appealStatus value for this EditorialReasonCollection.\n     * \n     * @param appealStatus\n     */\n    public void setAppealStatus(com.microsoft.bingads.v9.campaignmanagement.AppealStatus appealStatus) {\n        this.appealStatus = appealStatus;\n    }\n\n\n    /**\n     * Gets the reasons value for this EditorialReasonCollection.\n     * \n     * @return reasons\n     */\n    public com.microsoft.bingads.v9.campaignmanagement.EditorialReason[] getReasons() {\n        return reasons;\n    }\n\n\n    /**\n     * Sets the reasons value for this EditorialReasonCollection.\n     * \n     * @param reasons\n     */\n    public void setReasons(com.microsoft.bingads.v9.campaignmanagement.EditorialReason[] reasons) {\n        this.reasons = reasons;\n    }\n\n    private java.lang.Object __equalsCalc = null;\n    public synchronized boolean equals(java.lang.Object obj) {\n        if (!(obj instanceof EditorialReasonCollection)) return false;\n        EditorialReasonCollection other = (EditorialReasonCollection) obj;\n        if (obj == null) return false;\n        if (this == obj) return true;\n        if (__equalsCalc != null) {\n            return (__equalsCalc == obj);\n        }\n        __equalsCalc = obj;\n        boolean _equals;\n        _equals = true && \n            ((this.adOrKeywordId==null && other.getAdOrKeywordId()==null) || \n             (this.adOrKeywordId!=null &&\n              this.adOrKeywordId.equals(other.getAdOrKeywordId()))) &&\n            ((this.appealStatus==null && other.getAppealStatus()==null) || \n             (this.appealStatus!=null &&\n              this.appealStatus.equals(other.getAppealStatus()))) &&\n            ((this.reasons==null && other.getReasons()==null) || \n             (this.reasons!=null &&\n              java.util.Arrays.equals(this.reasons, other.getReasons())));\n        __equalsCalc = null;\n        return _equals;\n    }\n\n    private boolean __hashCodeCalc = false;\n    public synchronized int hashCode() {\n        if (__hashCodeCalc) {\n            return 0;\n        }\n        __hashCodeCalc = true;\n        int _hashCode = 1;\n        if (getAdOrKeywordId() != null) {\n            _hashCode += getAdOrKeywordId().hashCode();\n        }\n        if (getAppealStatus() != null) {\n            _hashCode += getAppealStatus().hashCode();\n        }\n        if (getReasons() != null) {\n            for (int i=0;\n                 i<java.lang.reflect.Array.getLength(getReasons());\n                 i++) {\n                java.lang.Object obj = java.lang.reflect.Array.get(getReasons(), i);\n                if (obj != null &&\n                    !obj.getClass().isArray()) {\n                    _hashCode += obj.hashCode();\n                }\n            }\n        }\n        __hashCodeCalc = false;\n        return _hashCode;\n    }\n\n    // Type metadata\n    private static org.apache.axis.description.TypeDesc typeDesc =\n        new org.apache.axis.description.TypeDesc(EditorialReasonCollection.class, true);\n\n    static {\n        typeDesc.setXmlType(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"EditorialReasonCollection\"));\n        org.apache.axis.description.ElementDesc elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"adOrKeywordId\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"AdOrKeywordId\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"http://www.w3.org/2001/XMLSchema\", \"long\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"appealStatus\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"AppealStatus\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"AppealStatus\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(false);\n        typeDesc.addFieldDesc(elemField);\n        elemField = new org.apache.axis.description.ElementDesc();\n        elemField.setFieldName(\"reasons\");\n        elemField.setXmlName(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"Reasons\"));\n        elemField.setXmlType(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"EditorialReason\"));\n        elemField.setMinOccurs(0);\n        elemField.setNillable(true);\n        elemField.setItemQName(new javax.xml.namespace.QName(\"https://bingads.microsoft.com/CampaignManagement/v9\", \"EditorialReason\"));\n        typeDesc.addFieldDesc(elemField);\n    }\n\n    /**\n     * Return type metadata object\n     */\n    public static org.apache.axis.description.TypeDesc getTypeDesc() {\n        return typeDesc;\n    }\n\n    /**\n     * Get Custom Serializer\n     */\n    public static org.apache.axis.encoding.Serializer getSerializer(\n           java.lang.String mechType, \n           java.lang.Class _javaType,  \n           javax.xml.namespace.QName _xmlType) {\n        return \n          new  org.apache.axis.encoding.ser.BeanSerializer(\n            _javaType, _xmlType, typeDesc);\n    }\n\n    /**\n     * Get Custom Deserializer\n     */\n    public static org.apache.axis.encoding.Deserializer getDeserializer(\n           java.lang.String mechType, \n           java.lang.Class _javaType,  \n           javax.xml.namespace.QName _xmlType) {\n        return \n          new  org.apache.axis.encoding.ser.BeanDeserializer(\n            _javaType, _xmlType, typeDesc);\n    }\n\n}\n", " 2:05 PM\n * To change this template use File | Settings | File Templates.\n */\npublic class Resource {\n    private String id;\n    private String name;\n    private String displayName;\n    private String description;\n    private String icon;\n    private int quantity;\n\n    public void setID(String id) {this.id = id;}\n\n    public void setName(String newName){name=newName;}\n\n    public void setDisplayName(String newDisplayName){displayName=newDisplayName;}\n\n    public void setDescription(String newDescription){description=newDescription;}\n\n    public void setIcon(String newIcon){icon=newIcon;}\n\n    public void setQuantity(int quantity1){quantity=quantity1;}\n\n    public String getID() {return id;}\n\n    public String getName(){ return name;}\n\n    public String getDisplayName(){ return displayName;}\n\n    public String getDescription(){ return description;}\n\n    public String getIcon(){ return icon;}\n\n    public int getQuantity() {return quantity;}\n\n\n\n\n}\n", "dels.ColorScheme;\r\nimport com.puzzletimer.models.PuzzleInfo;\r\n\r\npublic interface Puzzle {\r\n    PuzzleInfo getPuzzleInfo();\r\n    Mesh getScrambledPuzzleMesh(ColorScheme colorScheme, String[] sequence);\r\n}\r\n", "w to manage the exchange parameters between all the rules in the engine\n * \n * @author Rigre Gregorio Garciandia Sonora\n */\npublic interface ExchangeManager {\n\n    /**\n     * Allow to resolve a exchange from a type\n     * \n     * @param <ResultType>\n     *            Allow the client to define the overall result type of the rule\n     *            execution. There is two ways to define the rule result, using\n     *            the exchange manager injected in the rule or using the return\n     *            value of the {@link Then} Annotate method\n     * @return ResultType Type of the result that will be returned\n     */\n    <ResultType> ResultType resolveResult();\n\n    /**\n     * Allow to add a new exchange\n     * \n     * @param <ResultType>\n     *            Allow the client to define the overall result type of the rule\n     *            execution. There is two ways to define the rule result, using\n     *            the exchange manager injected in the rule or using the return\n     *            value of the {@link Then} Annotate method\n     * @param result\n     *            Register a result of the overall rule execution\n     */\n    <ResultType> void registerResult(ResultType result);\n\n    /**\n     * Allow to resolve a exchange from a type\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param exchangeClass\n     *            Class of the exchange that will be resolved\n     * @return ExchangeType Type of the exchange\n     */\n    <ExchangeType> ExchangeType resolveExchangeByClass(Class<ExchangeType> exchangeClass);\n\n    /**\n     * Allow to resolve a exchange from a name\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param name\n     *            Name of the exchange that will be resolved\n     * @return ExchangeType Type of the exchange\n     */\n    <ExchangeType> ExchangeType resolveExchangeByName(Object name);\n\n    /**\n     * Allow to add a new exchange\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param exchange\n     *            Exchange to be added\n     */\n    <ExchangeType> void registerExchange(ExchangeType exchange);\n\n    /**\n     * Allow to add a new exchange\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param name\n     *            Name of the Exchange. This is use to inject named exchanges or\n     *            to resolve collection types like Maps, List\n     * @param exchange\n     *            Exchange to be added\n     */\n    <ExchangeType> void registerExchange(Object name, ExchangeType exchange);\n\n    /**\n     * Allow to replace one exchange\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param oldExchange\n     *            Existent Exchange\n     * @param newExchange\n     *            Exchange to replace the existent exchange\n     */\n    <ExchangeType> void replaceExchange(ExchangeType oldExchange, ExchangeType newExchange);\n\n    /**\n     * Allow to replace one exchange\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param name\n     *            Name of the Exchange. This is use to inject named exchanges or\n     *            to resolve collection types like Maps, List\n     * @param oldExchange\n     *            Existent Exchange\n     * @param newExchange\n     *            Exchange to replace the existent exchange\n     */\n    <ExchangeType> void replaceExchange(Object name, ExchangeType oldExchange, ExchangeType newExchange);\n\n    /**\n     * Allow top remove a exchange\n     * \n     * @param <ExchangeType>\n     *            Type of the exchange to be resolved\n     * @param exchange\n     *            Exchange to be removed\n     */\n    <ExchangeType> void removeExchangeByValue(ExchangeType exchange);\n\n    /**\n     * Allow top remove a exchange\n     * \n     * @param name\n     *            Exchange name to be removed\n     */\n    void removeExchangeByName(Object name);\n}\n", "l of the other GovTrack beans\n *\n */\npublic class Record {\n    private Id id;\n    private Name name;\n    private List<OtherName> listGovTrackOtherNames;\n    private Bio bio;\n    private List<Term> terms;\n    private List<LeadershipRole> leadership_roles;\n    private List<FamilyMember> family;\n    private List<OtherName> other_names;\n    public Id getId() {\n        return id;\n    }\n    public void setId(Id id) {\n        this.id = id;\n    }\n    public Name getName() {\n        return name;\n    }\n    public void setName(Name name) {\n        this.name = name;\n    }\n    public List<OtherName> getListGovTrackOtherNames() {\n        return listGovTrackOtherNames;\n    }\n    public void setListGovTrackOtherNames(List<OtherName> listGovTrackOtherNames) {\n        this.listGovTrackOtherNames = listGovTrackOtherNames;\n    }\n    public Bio getBio() {\n        return bio;\n    }\n    public void setBio(Bio bio) {\n        this.bio = bio;\n    }\n    public List<Term> getTerms() {\n        return terms;\n    }\n    public void setTerms(List<Term> terms) {\n        this.terms = terms;\n    }\n    public List<OtherName> getOther_names() {\n        return other_names;\n    }\n    public void setOther_names(List<OtherName> other_names) {\n        this.other_names = other_names;\n    }\n    public List<LeadershipRole> getLeadership_roles() {\n        return leadership_roles;\n    }\n    public void setLeadership_roles(List<LeadershipRole> leadership_roles) {\n        this.leadership_roles = leadership_roles;\n    }\n    public List<FamilyMember> getFamily() {\n        return family;\n    }\n    public void setFamily(List<FamilyMember> family) {\n        this.family = family;\n    }\n}\n", "less.exceptions.BackendlessFault;\nimport com.backendless.rt.messaging.MessagingSubscription;\nimport weborb.types.IAdaptingType;\n\nimport java.util.concurrent.CopyOnWriteArrayList;\n\npublic abstract class ConnectListener<T extends RTSubscription>\n{\n  private final CopyOnWriteArrayList<AsyncCallback<Void>> connectedCallbacks = new CopyOnWriteArrayList<>();\n  private final RTClient rtClient = RTClientFactory.get();\n  private volatile boolean connected;\n  private final T connectSubscription;\n\n  public ConnectListener( String subject  )\n  {\n    this.connectSubscription = createConnectSubscription( subject  );\n  }\n\n  public void connect( )\n  {\n    rtClient.subscribe( connectSubscription );\n  }\n\n  private T createConnectSubscription( String subject )\n  {\n    return createSubscription( new RTCallback()\n    {\n      @Override\n      public AsyncCallback usersCallback()\n      {\n        return null;\n      }\n\n      @Override\n      public void handleResponse( IAdaptingType response )\n      {\n        connected = true;\n        for( AsyncCallback<Void> connectedCallback : connectedCallbacks )\n        {\n          connectedCallback.handleResponse( null );\n        }\n\n        connected();\n      }\n\n      @Override\n      public void handleFault( BackendlessFault fault )\n      {\n        connected = false;\n        for( AsyncCallback<Void> connectedCallback : connectedCallbacks )\n        {\n          connectedCallback.handleFault( fault );\n        }\n      }\n    } );\n  }\n\n  public void disconnect()\n  {\n    rtClient.unsubscribe( connectSubscription.getId() );\n    connected = false;\n  }\n\n  public boolean isConnected()\n  {\n    return connected;\n  }\n\n  public void addConnectListener( AsyncCallback<Void> callback )\n  {\n    if( connected )\n      callback.handleResponse( null );\n\n    connectedCallbacks.add( callback );\n  }\n\n  public void removeConnectListener( AsyncCallback<Void> callback )\n  {\n    connectedCallbacks.remove( callback );\n  }\n\n  public void removeConnectListeners(  )\n  {\n    connectedCallbacks.clear();\n  }\n\n  public abstract void connected();\n  public abstract T createSubscription( RTCallback callback );\n}\n", " third-party contributors as\n * indicated by the @author tags or express copyright attribution\n * statements applied by the authors.  All third-party contributions are\n * distributed under license by Red Hat Inc.\n *\n * This copyrighted material is made available to anyone wishing to use, modify,\n * copy, or redistribute it subject to the terms and conditions of the GNU\n * Lesser General Public License, as published by the Free Software Foundation.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY\n * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License\n * for more details.\n *\n * You should have received a copy of the GNU Lesser General Public License\n * along with this distribution; if not, write to:\n * Free Software Foundation, Inc.\n * 51 Franklin Street, Fifth Floor\n * Boston, MA  02110-1301  USA\n */\npackage org.hibernate.type.descriptor.sql;\nimport java.sql.Types;\n\n/**\n * Descriptor for {@link Types#FLOAT FLOAT} handling.\n *\n * @author Steve Ebersole\n */\npublic class FloatTypeDescriptor extends RealTypeDescriptor {\n\tpublic static final FloatTypeDescriptor INSTANCE = new FloatTypeDescriptor();\n\n\tpublic int getSqlType() {\n\t\treturn Types.FLOAT;\n\t}\n}\n", "le;\n\npublic class Main {\t\n\t\n\tpublic static void main(String[] args){\n\t\tRectangle rectangle = new Rectangle(10,10,50,50);\n\t\tLine line = new Line(100,100, 500, 500);\n\t\tOval oval = new Oval(200, 200, 250, 250);\n\t\tPainter.addObjectInList(rectangle);\n\t\tPainter.addObjectInList(line);\n\t\tPainter.addObjectInList(oval);\n\t\tPainter.drawObjects();\n\t}\n}\n", "iTainter;\n\nimport static edu.columbia.cs.psl.test.phosphor.BaseMultiTaintClass.assertNonNullTaint;\nimport static edu.columbia.cs.psl.test.phosphor.BaseMultiTaintClass.assertNullOrEmpty;\n\n@SuppressWarnings(\"unused\")\npublic class MethodHolder {\n\n    public static final int RET_VALUE = 2;\n\n    // Whether methods' arguments are expected to be tainted\n    private final boolean checkArgsTainted;\n\n    MethodHolder(boolean checkArgsTainted) {\n        this.checkArgsTainted = checkArgsTainted;\n    }\n\n    public int example(boolean taintedBool) {\n        if(checkArgsTainted) {\n            assertNonNullTaint(MultiTainter.getTaint(taintedBool));\n        } else {\n            assertNullOrEmpty(MultiTainter.getTaint(taintedBool));\n        }\n        return RET_VALUE;\n    }\n\n    public int example(boolean[] b) {\n        if(checkArgsTainted) {\n            assertNonNullTaint(MultiTainter.getTaint(b[0]));\n        } else {\n            assertNullOrEmpty(MultiTainter.getTaint(b[0]));\n        }\n        return RET_VALUE;\n    }\n}\n", ".math.BigDecimal;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.mockito.Mockito.*;\n\npublic class CasinoTest {\n\n    private Roulette mockRoulette;\n    private Casino cut;\n\n    @Before\n    public void setUp() throws Exception {\n        mockRoulette = mock(Roulette.class);\n        cut = new Casino(mockRoulette);\n    }\n\n    @Test\n    public void callRouletteTableBetMethod() throws Exception {\n        cut.playRoulette(BigDecimal.ONE, 5);\n        verify(mockRoulette).bet(BigDecimal.ONE, 5);\n    }\n\n    @Test\n    public void playRouletteReturnsTheSameAmountAsBet() throws Exception {\n        when(mockRoulette.bet(BigDecimal.ONE, 5)).thenReturn(BigDecimal.TEN);\n        BigDecimal result = cut.playRoulette(BigDecimal.ONE, 5);\n        assertThat(result, is(equalTo(BigDecimal.TEN)));\n    }\n\n\n}", "r.beitz.buildchaindemo.domain.PersistentToken;\nimport fr.beitz.buildchaindemo.domain.User;\nimport fr.beitz.buildchaindemo.repository.PersistentTokenRepository;\nimport fr.beitz.buildchaindemo.repository.UserRepository;\nimport java.time.ZonedDateTime;\nimport fr.beitz.buildchaindemo.service.util.RandomUtil;\nimport java.time.LocalDate;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.transaction.annotation.Transactional;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport javax.inject.Inject;\nimport java.util.Optional;\nimport java.util.List;\n\nimport static org.assertj.core.api.Assertions.*;\n\n/**\n * Test class for the UserResource REST controller.\n *\n * @see UserService\n */\n@RunWith(SpringRunner.class)\n@SpringBootTest(classes = BuildchaindemoApp.class)\n@Transactional\npublic class UserServiceIntTest {\n\n    @Inject\n    private PersistentTokenRepository persistentTokenRepository;\n\n    @Inject\n    private UserRepository userRepository;\n\n    @Inject\n    private UserService userService;\n\n    @Test\n    public void testRemoveOldPersistentTokens() {\n        User admin = userRepository.findOneByLogin(\"admin\").get();\n        int existingCount = persistentTokenRepository.findByUser(admin).size();\n        generateUserToken(admin, \"1111-1111\", LocalDate.now());\n        LocalDate now = LocalDate.now();\n        generateUserToken(admin, \"2222-2222\", now.minusDays(32));\n        assertThat(persistentTokenRepository.findByUser(admin)).hasSize(existingCount + 2);\n        userService.removeOldPersistentTokens();\n        assertThat(persistentTokenRepository.findByUser(admin)).hasSize(existingCount + 1);\n    }\n\n    @Test\n    public void assertThatUserMustExistToResetPassword() {\n        Optional<User> maybeUser = userService.requestPasswordReset(\"john.doe@localhost\");\n        assertThat(maybeUser.isPresent()).isFalse();\n\n        maybeUser = userService.requestPasswordReset(\"admin@localhost\");\n        assertThat(maybeUser.isPresent()).isTrue();\n\n        assertThat(maybeUser.get().getEmail()).isEqualTo(\"admin@localhost\");\n        assertThat(maybeUser.get().getResetDate()).isNotNull();\n        assertThat(maybeUser.get().getResetKey()).isNotNull();\n    }\n\n    @Test\n    public void assertThatOnlyActivatedUserCanRequestPasswordReset() {\n        User user = userService.createUser(\"johndoe\", \"johndoe\", \"John\", \"Doe\", \"john.doe@localhost\", \"en-US\");\n        Optional<User> maybeUser = userService.requestPasswordReset(\"john.doe@localhost\");\n        assertThat(maybeUser.isPresent()).isFalse();\n        userRepository.delete(user);\n    }\n\n    @Test\n    public void assertThatResetKeyMustNotBeOlderThan24Hours() {\n        User user = userService.createUser(\"johndoe\", \"johndoe\", \"John\", \"Doe\", \"john.doe@localhost\", \"en-US\");\n\n        ZonedDateTime daysAgo = ZonedDateTime.now().minusHours(25);\n        String resetKey = RandomUtil.generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n\n        userRepository.save(user);\n\n        Optional<User> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey());\n\n        assertThat(maybeUser.isPresent()).isFalse();\n\n        userRepository.delete(user);\n    }\n\n    @Test\n    public void assertThatResetKeyMustBeValid() {\n        User user = userService.createUser(\"johndoe\", \"johndoe\", \"John\", \"Doe\", \"john.doe@localhost\", \"en-US\");\n\n        ZonedDateTime daysAgo = ZonedDateTime.now().minusHours(25);\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(\"1234\");\n        userRepository.save(user);\n        Optional<User> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey());\n        assertThat(maybeUser.isPresent()).isFalse();\n        userRepository.delete(user);\n    }\n\n    @Test\n    public void assertThatUserCanResetPassword() {\n        User user = userService.createUser(\"johndoe\", \"johndoe\", \"John\", \"Doe\", \"john.doe@localhost\", \"en-US\");\n        String oldPassword = user.getPassword();\n        ZonedDateTime daysAgo = ZonedDateTime.now().minusHours(2);\n        String resetKey = RandomUtil.generateResetKey();\n        user.setActivated(true);\n        user.setResetDate(daysAgo);\n        user.setResetKey(resetKey);\n        userRepository.save(user);\n        Optional<User> maybeUser = userService.completePasswordReset(\"johndoe2\", user.getResetKey());\n        assertThat(maybeUser.isPresent()).isTrue();\n        assertThat(maybeUser.get().getResetDate()).isNull();\n        assertThat(maybeUser.get().getResetKey()).isNull();\n        assertThat(maybeUser.get().getPassword()).isNotEqualTo(oldPassword);\n\n        userRepository.delete(user);\n    }\n\n    @Test\n    public void testFindNotActivatedUsersByCreationDateBefore() {\n        userService.removeNotActivatedUsers();\n        ZonedDateTime now = ZonedDateTime.now();\n        List<User> users = userRepository.findAllByActivatedIsFalseAndCreatedDateBefore(now.minusDays(3));\n        assertThat(users).isEmpty();\n    }\n\n    private void generateUserToken(User user, String tokenSeries, LocalDate localDate) {\n        PersistentToken token = new PersistentToken();\n        token.setSeries(tokenSeries);\n        token.setUser(user);\n        token.setTokenValue(tokenSeries + \"-data\");\n        token.setTokenDate(localDate);\n        token.setIpAddress(\"127.0.0.1\");\n        token.setUserAgent(\"Test agent\");\n        persistentTokenRepository.saveAndFlush(token);\n    }\n}\n", "va.util.Map;\n\nimport javax.annotation.Nonnull;\nimport javax.annotation.Nullable;\n\nimport org.bukkit.OfflinePlayer;\nimport org.bukkit.World;\nimport org.bukkit.block.Block;\nimport org.bukkit.entity.Entity;\nimport org.bukkit.entity.Player;\n\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.Maps;\n\nimport tc.oc.tracker.base.AbstractTracker;\nimport tc.oc.tracker.trackers.DispenserTracker;\n\npublic class SimpleDispenserTracker extends AbstractTracker implements DispenserTracker {\n    private final HashMap<Block, OfflinePlayer> placedDispensers = Maps.newHashMap();\n    private final HashMap<Entity, OfflinePlayer> ownedEntitys = Maps.newHashMap();\n\n    public boolean hasOwner(@Nonnull Entity entity) {\n        Preconditions.checkNotNull(entity, \"entity\");\n\n        return this.ownedEntitys.containsKey(entity);\n    }\n\n    public @Nullable OfflinePlayer getOwner(@Nonnull Entity entity) {\n        Preconditions.checkNotNull(entity, \"entity\");\n\n        return this.ownedEntitys.get(entity);\n    }\n\n    public @Nullable OfflinePlayer setOwner(@Nonnull Entity entity, @Nullable Player player) {\n        Preconditions.checkNotNull(entity, \"tnt entity\");\n\n        if(player != null) {\n            return this.ownedEntitys.put(entity, player);\n        } else {\n            return this.ownedEntitys.remove(entity);\n        }\n    }\n\n    public boolean hasPlacer(@Nonnull Block block) {\n        Preconditions.checkNotNull(block, \"block\");\n\n        return this.placedDispensers.containsKey(block);\n    }\n\n    public @Nullable OfflinePlayer getPlacer(@Nonnull Block block) {\n        Preconditions.checkNotNull(block, \"block\");\n\n        return this.placedDispensers.get(block);\n    }\n\n    public @Nullable OfflinePlayer setPlacer(@Nonnull Block block, @Nonnull Player player) {\n        Preconditions.checkNotNull(block, \"block\");\n        Preconditions.checkNotNull(player, \"player\");\n\n        return this.placedDispensers.put(block, player.getPlayer());\n    }\n\n    public @Nonnull OfflinePlayer clearPlacer(@Nonnull Block block) {\n        Preconditions.checkNotNull(block, \"block\");\n\n        return this.placedDispensers.remove(block);\n    }\n\n    public void clear(@Nonnull World world) {\n        // clear information about blocks in that world\n        Iterator<Map.Entry<Block, OfflinePlayer>> blockIt = this.placedDispensers.entrySet().iterator();\n        while(blockIt.hasNext()) {\n            Block block = blockIt.next().getKey();\n            if(block.getWorld().equals(world)) {\n                blockIt.remove();\n            }\n        }\n\n        // clear information about entitys in that world\n        Iterator<Map.Entry<Entity, OfflinePlayer>> entityIt = this.ownedEntitys.entrySet().iterator();\n        while(entityIt.hasNext()) {\n            Entity tnt = entityIt.next().getKey();\n            if(tnt.getWorld().equals(world)) {\n                entityIt.remove();\n            }\n        }\n    }\n}\n", "model.ModelSupport;\nimport org.springframework.beans.factory.config.BeanDefinition;\nimport org.springframework.context.annotation.Scope;\nimport org.springframework.stereotype.Component;\n\nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.Table;\n\nimport java.sql.Timestamp;\n\n/**\n * @author lpw\n */\n@Component(AddressModel.NAME + \".model\")\n@Scope(BeanDefinition.SCOPE_PROTOTYPE)\n@Entity(name = AddressModel.NAME)\n@Table(name = \"t_address\")\npublic class AddressModel extends ModelSupport {\n    static final String NAME = \"ranch.address\";\n\n    private String user; // \u7528\u6237ID\n    private String region; // \u884c\u653f\u533a\u5b57\u5178ID\n    private String detail; // \u8be6\u7ec6\u5730\u5740\n    private String postcode; // \u90ae\u653f\u7f16\u7801\n    private String name; // \u8054\u7cfb\u4eba\n    private String phone; // \u7535\u8bdd\u53f7\u7801\n    private String latitude; // GPS\u7eac\u5ea6\n    private String longitude; // GPS\u7ecf\u5ea6\n    private String label; // \u6807\u7b7e\n    private int major; // \u9ed8\u8ba4\u5730\u5740\uff1a0-\u5426\uff1b1-\u662f\n    private Timestamp time; // \u65f6\u95f4\n\n    @Jsonable\n    @Column(name = \"c_user\")\n    public String getUser() {\n        return user;\n    }\n\n    public void setUser(String user) {\n        this.user = user;\n    }\n\n    @Jsonable\n    @Column(name = \"c_region\")\n    public String getRegion() {\n        return region;\n    }\n\n    public void setRegion(String region) {\n        this.region = region;\n    }\n\n    @Jsonable\n    @Column(name = \"c_detail\")\n    public String getDetail() {\n        return detail;\n    }\n\n    public void setDetail(String detail) {\n        this.detail = detail;\n    }\n\n    @Jsonable\n    @Column(name = \"c_postcode\")\n    public String getPostcode() {\n        return postcode;\n    }\n\n    public void setPostcode(String postcode) {\n        this.postcode = postcode;\n    }\n\n    @Jsonable\n    @Column(name = \"c_name\")\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    @Jsonable\n    @Column(name = \"c_phone\")\n    public String getPhone() {\n        return phone;\n    }\n\n    public void setPhone(String phone) {\n        this.phone = phone;\n    }\n\n    @Jsonable\n    @Column(name = \"c_latitude\")\n    public String getLatitude() {\n        return latitude;\n    }\n\n    public void setLatitude(String latitude) {\n        this.latitude = latitude;\n    }\n\n    @Jsonable\n    @Column(name = \"c_longitude\")\n    public String getLongitude() {\n        return longitude;\n    }\n\n    public void setLongitude(String longitude) {\n        this.longitude = longitude;\n    }\n\n    @Jsonable\n    @Column(name = \"c_label\")\n    public String getLabel() {\n        return label;\n    }\n\n    public void setLabel(String label) {\n        this.label = label;\n    }\n\n    @Jsonable\n    @Column(name = \"c_major\")\n    public int getMajor() {\n        return major;\n    }\n\n    public void setMajor(int major) {\n        this.major = major;\n    }\n\n    @Jsonable\n    @Column(name = \"c_time\")\n    public Timestamp getTime() {\n        return time;\n    }\n\n    public void setTime(Timestamp time) {\n        this.time = time;\n    }\n}\n", "ated By \u4e0b\u5348 11:12 2017/6/3 0003\n * @Modified By\n */\npublic class SerializeUtils {\n    /**\n     * \u53cd\u5e8f\u5217\u5316\n     *\n     * @param bytes\n     * @return\n     */\n    public static Object deserialize(byte[] bytes) {\n\n        Object result = null;\n\n        if (isEmpty(bytes)) {\n            return null;\n        }\n\n        try {\n            ByteArrayInputStream byteStream = new ByteArrayInputStream(bytes);\n            try {\n                ObjectInputStream objectInputStream = new ObjectInputStream(byteStream);\n                try {\n                    result = objectInputStream.readObject();\n                } catch (ClassNotFoundException ex) {\n                    throw new Exception(\"Failed to deserialize object type\", ex);\n                }\n            } catch (Throwable ex) {\n                throw new Exception(\"Failed to deserialize\", ex);\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n        return result;\n    }\n\n    public static boolean isEmpty(byte[] data) {\n        return (data == null || data.length == 0);\n    }\n\n    /**\n     * \u5e8f\u5217\u5316\n     *\n     * @param object\n     * @return\n     */\n    public static byte[] serialize(Object object) {\n\n        byte[] result = null;\n\n        if (object == null) {\n            return new byte[0];\n        }\n        try {\n            ByteArrayOutputStream byteStream = new ByteArrayOutputStream(128);\n            try {\n                if (!(object instanceof Serializable)) {\n                    throw new IllegalArgumentException(SerializeUtils.class.getSimpleName() + \" requires a Serializable payload \" +\n                            \"but received an object of type [\" + object.getClass().getName() + \"]\");\n                }\n                ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteStream);\n                objectOutputStream.writeObject(object);\n                objectOutputStream.flush();\n                result = byteStream.toByteArray();\n            } catch (Throwable ex) {\n                throw new Exception(\"Failed to serialize\", ex);\n            }\n        } catch (Exception ex) {\n            ex.printStackTrace();\n        }\n        return result;\n    }\n}\n", "ath.BigDecimal;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.xeiam.xchange.Exchange;\nimport com.xeiam.xchange.ExchangeFactory;\nimport com.xeiam.xchange.coinsetter.CoinsetterException;\nimport com.xeiam.xchange.coinsetter.CoinsetterExchange;\nimport com.xeiam.xchange.coinsetter.dto.marketdata.CoinsetterLast;\nimport com.xeiam.xchange.coinsetter.dto.marketdata.CoinsetterListDepth;\nimport com.xeiam.xchange.coinsetter.dto.marketdata.CoinsetterPairedDepth;\nimport com.xeiam.xchange.coinsetter.dto.marketdata.CoinsetterQuote;\nimport com.xeiam.xchange.coinsetter.dto.marketdata.CoinsetterTicker;\nimport com.xeiam.xchange.coinsetter.service.polling.CoinsetterMarketDataServiceRaw;\nimport com.xeiam.xchange.currency.CurrencyPair;\nimport com.xeiam.xchange.dto.marketdata.OrderBook;\nimport com.xeiam.xchange.dto.marketdata.Ticker;\nimport com.xeiam.xchange.exceptions.ExchangeException;\nimport com.xeiam.xchange.exceptions.NotAvailableFromExchangeException;\nimport com.xeiam.xchange.exceptions.NotYetImplementedForExchangeException;\nimport com.xeiam.xchange.service.polling.marketdata.PollingMarketDataService;\n\npublic class CoinsetterMarketDataDemo {\n\n  private static final Logger log = LoggerFactory.getLogger(CoinsetterMarketDataDemo.class);\n\n  public static void main(String[] args) throws ExchangeException, NotAvailableFromExchangeException, NotYetImplementedForExchangeException, IOException {\n\n    Exchange coinsetter = ExchangeFactory.INSTANCE.createExchange(CoinsetterExchange.class.getName());\n    generic(coinsetter);\n    raw(coinsetter);\n  }\n\n  private static void generic(Exchange exchange) throws ExchangeException, NotAvailableFromExchangeException, NotYetImplementedForExchangeException, IOException {\n\n    PollingMarketDataService marketDataService = exchange.getPollingMarketDataService();\n\n    Ticker ticker = marketDataService.getTicker(CurrencyPair.BTC_USD);\n    log.info(\"Ticker: {}\", ticker);\n\n    OrderBook orderBook = marketDataService.getOrderBook(CurrencyPair.BTC_USD);\n    log.info(\"OrderBook: {}\", orderBook);\n\n    orderBook = marketDataService.getOrderBook(CurrencyPair.BTC_AUD, \"COINSETTER\");\n    log.info(\"OrderBook(COINSETTER): {}\", orderBook);\n\n    orderBook = marketDataService.getOrderBook(CurrencyPair.BTC_AUD, \"COINSETTER\", 5);\n    log.info(\"OrderBook(COINSETTER, 5): {}\", orderBook);\n\n    orderBook = marketDataService.getOrderBook(CurrencyPair.BTC_AUD, null, 5);\n    log.info(\"OrderBook(null, 5): {}\", orderBook);\n\n    orderBook = marketDataService.getOrderBook(CurrencyPair.BTC_AUD, null, null);\n    log.info(\"OrderBook(null, null): {}\", orderBook);\n  }\n\n  private static void raw(Exchange exchange) throws IOException {\n\n    CoinsetterMarketDataServiceRaw marketDataService = (CoinsetterMarketDataServiceRaw) exchange.getPollingMarketDataService();\n\n    CoinsetterLast last = marketDataService.getCoinsetterLast();\n    log.info(\"Coinsetter last: {}\", last);\n\n    last = marketDataService.getCoinsetterLast(5);\n    log.info(\"Coinsetter last 5: {}\", last);\n\n    CoinsetterTicker ticker = marketDataService.getCoinsetterTicker();\n    log.info(\"Coinsetter ticker: {}\", ticker);\n\n    CoinsetterPairedDepth pairedDepth = marketDataService.getCoinsetterPairedDepth(10, \"SMART\");\n    log.info(\"Coinsetter paired depth: {}\", pairedDepth);\n\n    CoinsetterListDepth fullDepth = marketDataService.getCoinsetterFullDepth(\"SMART\");\n    log.info(\"Coinsetter full depth: {}\", fullDepth);\n\n    CoinsetterQuote quoteBid = marketDataService.getCoinsetterQuote(new BigDecimal(\"5\"), \"BTCUSD\");\n    log.info(\"Coinsetter quote bid: {}\", quoteBid);\n\n    CoinsetterQuote quoteAsk = marketDataService.getCoinsetterQuote(new BigDecimal(\"-5\"), \"BTCUSD\");\n    log.info(\"Coinsetter quote ask: {}\", quoteAsk);\n\n    try {\n      // Invalid quoting quantity.\n      marketDataService.getCoinsetterQuote(new BigDecimal(\"1\"), \"BTCUSD\");\n    } catch (CoinsetterException e) {\n      log.info(\"Message: {}\", e.getMessage());\n    }\n\n  }\n\n}\n", "*******************\n  -----------------------------------------------------------------------------\n  XML2J XSD to Java code generator\n  -----------------------------------------------------------------------------\n  \n  This code was generated using XML2J code generator.\n  \n  Version: 2.4.2 \n  Project home: XML2J https://sourceforge.net/projects/xml2j/ \n\n  Module: MASTERS_RD \n  Generation date: Tue Apr 17 20:26:13 CEST 2018 \n  Author: XML2J-Generator\n\n******************************************************************************/\n\n/* SAX 2.0 dependencies */\nimport org.xml.sax.SAXException;\nimport org.xml.sax.XMLReader;\n\n/* Framework dependencies */\nimport com.xml2j.xml.core.DataSetter;\nimport com.xml2j.xml.core.XMLFragmentHandler;\nimport com.xml2j.xml.parser.ParserTask;\n\n\n/**\n * VideoType_d0e47_a61 handler class.\n *\n * @see VideoType_d0e47_a61\n */\npublic class VideoType_d0e47_a61Handler extends XMLFragmentHandler<VideoType_d0e47_a61> {\n\t/**\n\t * Proxy for VideoType_d0e47_a61Handler.\n\t */\n\tstatic class Proxy extends HandlerProxy<VideoType_d0e47_a61> {\n\t\t/**\n\t\t * Allocator for VideoType_d0e47_a61Handler.\n\t\t */\n\t\tprivate static class Allocator \n\t\t\t\textends HandlerProxy.Allocator<VideoType_d0e47_a61> {\t\t\t\n\t\t\tpublic XMLFragmentHandler<VideoType_d0e47_a61> create(\n\t\t\t\t\tParserTask task\n\t\t\t\t\t, XMLReader reader\n\t\t\t\t\t, XMLFragmentHandler<?> handler\n\t\t\t\t\t, String elementName\n\t\t\t\t\t, DataSetter setter\n\t\t\t\t\t, boolean doProcess) {\n\t\t\t\treturn new VideoType_d0e47_a61Handler(\n\t\t\t\t\ttask\n\t\t\t\t\t, reader\n\t\t\t\t\t, handler\n\t\t\t\t\t, elementName\n\t\t\t\t\t, VideoType_d0e47_a61.getAllocator()\n\t\t\t\t\t, setter\n\t\t\t\t\t, doProcess);\n\t\t\t}\n\t\t}\n\t\t\n\t\t/**\n\t\t * Constructor for Proxy.\n\t\t *\n\t\t * @param task the XML parser task\n\t\t * @param reader the XML reader\n\t\t * @param parentH the parent XML handler class\n\t\t * @param elementName the name of the XML Element (tag).\n\t\t * @param pSetter the setter for the parent data\n\t\t * @param doProcess indicates whether processing is active for this handler instance\n\t\t */\n\t\tpublic Proxy(ParserTask task, XMLReader reader, XMLFragmentHandler<?> parentH, String elementName,\n\t\t\t\tDataSetter pSetter, boolean doProcess) {\n\t\t\tsuper(task, reader, parentH, elementName, pSetter, new Allocator(), doProcess);\n\t\t}\n\t}\n\n\n\n\t/**\n\t * Constructor for handler class.\n\t *\n\t * @param reader the XML reader\n\t * @param parentH the parent XML handler class\n\t * @param elementName the name of the XML Element (tag)\n\t * @param allocator the allocator for the data type\n\t * @param pSetter the setter for the parent data\n\t * @param doProcess indicates whether processing is active for this handler instance\n\t */\n\tpublic VideoType_d0e47_a61Handler(\n\t\t\tParserTask application\n\t\t\t, XMLReader reader\n\t\t\t, XMLFragmentHandler<?> parentH\n\t\t\t, String elementName\n\t\t\t, VideoType_d0e47_a61.Allocator allocator\n\t\t\t, DataSetter pSetter\n\t\t\t, boolean doProcess) {\n\t\tsuper(application, reader, parentH, elementName, allocator, pSetter, doProcess);\n\t}\n\n\n\t/**\n\t * This method overrides the getData() of the super type, returning the more\n\t * specific type.\n\t * \n\t */\n\t@Override \n\tpublic VideoType_d0e47_a61 getData() {\n\t\treturn (VideoType_d0e47_a61)super.getData();\n\t}\n\n\n\n\n\t/**\n\t * This method is called by the XML parser on an end of element event.\n\t *\n\t * If the localName == 'the name of the element that this handler handles' control is\n\t * passed back to the parent handler (future events go there) and the data of\n\t * the children of this handler is attached to the data associated to this handler.\t\n\t * \n\t * The data that is collected is connected to the parent data only if a parentDataSetter\n\t * if found (getParentDataSetter()).\n\t *\n\t * If processing is enabled for a handler, the processor is called.\n\t */\n\t@Override\n\tpublic void endElement(String uri, String localName, String name)\n\t\tthrows SAXException {\n\t\t\n\t\t// collect data from children..\n\t\tif (localName.equals(\"description\")) {\n\t\t\tgetData().setDescription(getValue());\n\t\t\tgetContents().reset();\n\t\t} else if (localName.equals(\"title\")) {\n\t\t\tgetData().setTitle(getValue());\n\t\t\tgetContents().reset();\n\t\t} else if (localName.equals(getXMLElementName())) {\n\t\t\thandleElement();\n\t\t}\n\t\t\n\t}\t\n}\n", "pache License,\n * version 2.0 (the \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at:\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n * License for the specific language governing permissions and limitations\n * under the License.\n */\npackage com.github.sheigutn.pushbullet.stream;\n\nimport com.github.sheigutn.pushbullet.Pushbullet;\nimport com.github.sheigutn.pushbullet.stream.message.StreamMessage;\nimport lombok.Getter;\nimport lombok.SneakyThrows;\n\nimport javax.websocket.*;\nimport java.io.IOException;\nimport java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collection;\n\n@Getter\npublic final class PushbulletWebsocketClient {\n\n    private final static String BASE_URL = \"wss://stream.pushbullet.com:443/websocket/\";\n\n    private final Pushbullet pushbullet;\n\n    protected final Collection<PushbulletWebsocketListener> websocketListeners = new ArrayList<>();\n\n    private ClientEndpointConfig config = ClientEndpointConfig.Builder.create().build();\n\n    private WebSocketContainer webSocketContainer = ContainerProvider.getWebSocketContainer();\n\n    private Session websocketSession;\n\n    public PushbulletWebsocketClient(Pushbullet pushbullet) {\n        this.pushbullet = pushbullet;\n    }\n\n    /**\n     * Unregister a listener that listens to this websocket stream\n     * @param listener The listener to unregister\n     */\n    public void registerListener(PushbulletWebsocketListener listener) {\n        if(!websocketListeners.contains(listener)) {\n            websocketListeners.add(listener);\n        }\n    }\n\n    /**\n     * Register a new listener that listens to this websocket stream\n     * @param listener The listener to register\n     */\n    public void unregisterListener(PushbulletWebsocketListener listener) {\n        if(websocketListeners.contains(listener)) {\n            websocketListeners.remove(listener);\n        }\n    }\n\n    /**\n     * @return Whether the client is connected to the server\n     */\n    public synchronized boolean isConnected() {\n        return websocketSession != null && websocketSession.isOpen();\n    }\n\n    /**\n     * Connects the client to the server\n     */\n    @SneakyThrows\n    public synchronized void connect() {\n        if(websocketSession != null) return;\n        websocketSession = webSocketContainer.connectToServer(new Endpoint() {\n            @Override\n            public void onOpen(Session session, EndpointConfig config) {\n                //noinspection Convert2Lambda\n                session.addMessageHandler(new MessageHandler.Whole<String>() {\n                    @Override\n                    public void onMessage(String message) {\n                        websocketListeners.forEach(websocketListener -> websocketListener.handle(pushbullet, pushbullet.getGson().fromJson(message, StreamMessage.class)));\n                    }\n                });\n            }\n        }, config, new URI(BASE_URL + pushbullet.getAccessToken()));\n    }\n\n    /**\n     * Disconnects the client from the server\n     */\n    public synchronized void disconnect() {\n        if(websocketSession == null) return;\n        try {\n            websocketSession.close();\n        } catch (IOException e) {\n\n        }\n        finally {\n            websocketSession = null;\n        }\n    }\n}", "gistros.bloco1.Registro1925;\nimport br.com.swconsultoria.efd.icms.util.Util;\n\n/**\n * @author Yuri Lemes\n *\n */\npublic class GerarRegistro1925 {\n\n    public static StringBuilder gerar(Registro1925 registro1925, StringBuilder sb) {\n\n        sb.append(\"|\").append(Util.preencheRegistro(registro1925.getReg()));\n        sb.append(\"|\").append(Util.preencheRegistro(registro1925.getCod_inf_adic()));\n        sb.append(\"|\").append(Util.preencheRegistro(registro1925.getVl_inf_adic()));\n        sb.append(\"|\").append(Util.preencheRegistro(registro1925.getDescr_compl_aj()));\n        sb.append(\"|\").append('\\n');\n\n        return sb;\n    }\n}\n", " org.springframework.context.annotation.Configuration;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;\nimport org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;\nimport org.springframework.security.core.userdetails.UserDetailsService;\n\n@Configuration\n@EnableWebSecurity\npublic class SecurityConfiguration extends WebSecurityConfigurerAdapter {\n\n    private final UserDetailsService userDetailsService;\n\n    @Autowired\n    public SecurityConfiguration(UserDetailsService userDetailsService) {\n        this.userDetailsService = userDetailsService;\n    }\n\n    @Override\n    protected void configure(HttpSecurity http) throws Exception {\n        http.authorizeRequests().anyRequest().authenticated()   // All requests must be authenticated\n                .and()\n                .x509()                                         // Configure X.509 based pre authentication.\n                .subjectPrincipalRegex(\"serialNumber=([0-9]+)\") // Regex to extract the ID from the certificate\n                .userDetailsService(userDetailsService);        // Look into the package \"service\"\n    }\n}\n", "va.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface CreatedAt {\n}\n", "/**\n * Example local unit test, which will execute on the development machine (host).\n *\n * @see <a href=\"http://d.android.com/tools/testing\">Testing documentation</a>\n */\npublic class ExampleUnitTest {\n    @Test\n    public void addition_isCorrect() throws Exception {\n        assertEquals(4, 2 + 2);\n    }\n}", "\npublic class MessageMatcher {\n\n    private final Matcher matcher;\n\n    public MessageMatcher(Pattern pattern, String input) {\n        this.matcher = pattern.matcher(input);\n    }\n\n    public boolean matches() {\n        return matcher.matches();\n    }\n\n    public int getInt(String group) {\n        try {\n            return Integer.parseInt(this.getString(group));\n        } catch (NumberFormatException e) {\n            throw new IllegalArgumentException(\"Group \" + group + \" is not of type int.\");\n        }\n    }\n\n    public String getString(String group) {\n        return matcher.group(group);\n    }\n\n}\n", "ardFilter;\nimport cn.garymb.ygomobile.ygo.YGOCardSelectionBuilder;\n\nimport android.content.Context;\nimport android.content.SharedPreferences;\nimport android.util.AttributeSet;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\n\npublic class CardFilterRangeItem extends LinearLayout implements ICardFilter {\n\n\tprivate static final String TAG = \"CardFilterDialogItem\";\n\n\tprivate static final String PREF_KEY_LAST_MAX = \"max\";\n\n\tprivate static final String PREF_KEY_LAST_MIN = \"min\";\n\n\tprivate int mMax = -1;\n\n\tprivate int mMin = -1;\n\n\tprivate ICardFilter mCardFilterDelegate;\n\n\tprivate OnCardFilterChangeListener mListener;\n\n\tprivate TextView mDes;\n\n\tpublic CardFilterRangeItem(Context context) {\n\t\tthis(context, null);\n\t}\n\n\tpublic CardFilterRangeItem(Context context, AttributeSet attrs) {\n\t\tsuper(context, attrs);\n\t}\n\n\t@Override\n\tprotected void onFinishInflate() {\n\t\tsuper.onFinishInflate();\n\t\tmDes = (TextView) findViewById(R.id.des);\n\t}\n\t\n\t@Override\n\tpublic void setId(int id) {\n\t\tsuper.setId(id);\n\t\tloadLastRange();\n\t\tif (mDes != null) {\n\t\t\tfillDesText();\n\t\t}\n\t}\n\n\tprivate void fillDesText() {\n\t\tif (mMax != -1 && mMin != -1) {\n\t\t\tif (mMax != -1 || mMin != -1) {\n\t\t\t\tmDes.setText(\"...\");\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic int getMax() {\n\t\treturn mMax;\n\t}\n\t\n\tpublic int getMin() {\n\t\treturn mMin;\n\t}\n\n\t@Override\n\tpublic void onFilter(int type, int arg1, int arg2, Object obj) {\n\t\tif (mCardFilterDelegate != null) {\n\t\t\tmCardFilterDelegate.onFilter(type, arg1, arg2, obj);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void resetFilter() {\n\t\tmMax = mMin = 0;\n\t\tsaveLastRange();\n\t\tmListener = null;\n\t\tif (mCardFilterDelegate != null) {\n\t\t\tmCardFilterDelegate.resetFilter();\n\t\t}\n\t}\n\n\tprivate void saveLastRange() {\n\t\tSharedPreferences.Editor editor = getContext().getSharedPreferences(\n\t\t\t\tTAG + getId(), Context.MODE_PRIVATE).edit();\n\t\teditor.putInt(PREF_KEY_LAST_MAX, mMax);\n\t\teditor.putInt(PREF_KEY_LAST_MIN, mMin);\n\t\teditor.commit();\n\t}\n\n\tprivate void loadLastRange() {\n\t\tSharedPreferences sp = getContext().getSharedPreferences(TAG + getId(),\n\t\t\t\tContext.MODE_PRIVATE);\n\t\tmMax = sp.getInt(PREF_KEY_LAST_MAX, -1);\n\t\tmMin = sp.getInt(PREF_KEY_LAST_MIN, -1);\n\t}\n\n\tpublic void setRange(int type, int from, int to) {\n\t\tif (mMax != to || mMin != from) {\n\t\t\tmMax = to;\n\t\t\tmMin = from;\n\t\t\tsaveLastRange();\n\t\t\tfillDesText();\n\t\t\tonFilter(type, from, to, null);\n\t\t\tmListener.onChange(YGOCardSelectionBuilder.SELECTION_SEGMENT_TOTAL, buildSelection());\n\t\t}\n\t}\n\n\t@Override\n\tpublic String buildSelection() {\n\t\tif (mCardFilterDelegate != null) {\n\t\t\treturn mCardFilterDelegate.buildSelection();\n\t\t}\n\t\treturn null;\n\t}\n\n\tpublic void setCardFilterChangeListener(OnCardFilterChangeListener listener) {\n\t\tmListener = listener;\n\t}\n\n\tpublic void setCardFilterDelegate(ICardFilter filter) {\n\t\tmCardFilterDelegate = filter;\n\t}\n\n}\n", "layer;\nimport blackJack.server.Table;\n\npublic class Player extends Person implements RMIPlayer {\n\tprivate static long nextID = 0;\n\tprivate static final long serialVersionUID = 1L;\n\n\tprivate final long id;\n\tString name;\n\tTable table;\n\tboolean didHit = false;\n\tboolean didStand = false;\n\tboolean shouldUpdate = false;\n\n\tpublic Player(String name) {\n\t\tid = ++nextID;\n\t\tthis.name = name;\n\t}\n\n\tpublic void setShouldUpdate(boolean shouldUpdate) {\n\t\tthis.shouldUpdate = shouldUpdate;\n\t}\n\n\t/**\n\t * The value will be reset to false after calling\n\t * this method.\n\t * \n\t * @return if the player should update the screen.\n\t */\n\tpublic boolean shouldUpdate() throws RemoteException {\n\t\tboolean returnValue = shouldUpdate;\n\t\tshouldUpdate = false;\n\t\treturn returnValue;\n\t}\n\n\tpublic boolean hasMoved() {\n\t\treturn didHit || didStand;\n\t}\n\n\t/**\n\t * The value will be reset to false after calling\n\t * this method.\n\t * \n\t * @return if the player wants a card.\n\t */\n\tpublic boolean didHit() {\n\t\tboolean returnValue = didHit;\n\t\tdidHit = false;\n\t\treturn returnValue;\n\t}\n\n\tpublic boolean didStand() {\n\t\treturn didStand;\n\t}\n\n\t@Override\n\tpublic long getID() throws RemoteException {\n\t\treturn id;\n\t}\n\n\tpublic void setTable(Table table) {\n\t\tthis.table = table;\n\t}\n\n\tpublic void resetDecision() {\n\t\tdidHit = false;\n\t}\n\n\tpublic void resetToStartNextRound() {\n\t\tsuper.resetToStartNextRound();\n\t\tdidHit = didStand = false;\n\t}\n\n\t@Override\n\tpublic void doHit() throws RemoteException {\n\t\tif (!isMyTurn()) {\n\t\t\treturn;\n\t\t}\n\t\tdidHit = true;\n\t}\n\n\t@Override\n\tpublic void doStand() throws RemoteException {\n\t\tif (!isMyTurn()) {\n\t\t\treturn;\n\t\t}\n\t\tdidStand = true;\n\t}\n\n\t@Override\n\tpublic boolean doDoubleDown() throws RemoteException {\n\t\tif (!isMyTurn()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean doSplit() throws RemoteException {\n\t\tif (!isMyTurn()) {\n\t\t\treturn false;\n\t\t}\n\t\treturn false;\n\t}\n\n\t@Override\n\tpublic boolean isMyTurn() throws RemoteException {\n\t\treturn table.getCurrentPlayer() == this;\n\t}\n\n\t@Override\n\tpublic String getNameOfCurrentPlayer() throws RemoteException {\n\t\treturn table.getCurrentPlayer().getName();\n\t}\n\n\t@Override\n\tpublic boolean isAllowedToTakeACard() {\n\t\treturn getCardCount() < 21 && !didStand;\n\t}\n\n\t@Override\n\tpublic String show() {\n\t\tString turn = table.getCurrentPlayer() == this ? \">\" : \" \";\n\t\treturn String.format(\"(%3d) %s %15s: %s -> %d\", score, turn, name, cards.toString(), getCardCount());\n\t}\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"<Player '\" + name + \"'>\";\n\t}\n}\n", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.mixin.api.minecraft.world.entity.item;\n\nimport net.minecraft.world.entity.item.FallingBlockEntity;\nimport org.spongepowered.api.data.Keys;\nimport org.spongepowered.api.data.value.Value;\nimport org.spongepowered.api.entity.FallingBlock;\nimport org.spongepowered.asm.mixin.Mixin;\nimport org.spongepowered.common.mixin.api.minecraft.world.entity.EntityMixin_API;\n\nimport java.util.Set;\n\n@Mixin(FallingBlockEntity.class)\npublic abstract class FallingBlockEntityMixin_API extends EntityMixin_API implements FallingBlock {\n\n    @Override\n    protected Set<Value.Immutable<?>> api$getVanillaValues() {\n        final Set<Value.Immutable<?>> values = super.api$getVanillaValues();\n\n        values.add(this.requireValue(Keys.BLOCK_STATE).asImmutable());\n        values.add(this.requireValue(Keys.CAN_DROP_AS_ITEM).asImmutable());\n        values.add(this.requireValue(Keys.CAN_HURT_ENTITIES).asImmutable());\n        values.add(this.requireValue(Keys.CAN_PLACE_AS_BLOCK).asImmutable());\n        values.add(this.requireValue(Keys.DAMAGE_PER_BLOCK).asImmutable());\n        values.add(this.requireValue(Keys.FALL_TIME).asImmutable());\n        values.add(this.requireValue(Keys.MAX_FALL_DAMAGE).asImmutable());\n\n        return values;\n    }\n\n}\n", "nt;\nimport fi.imberg.juhani.ernu.interpreter.interfaces.Node;\n\n/**\n * A node that represents a boolean.\n */\npublic class BooleanNode implements Node {\n\n    /**\n     * Is this BooleanNode true?\n     */\n    private final boolean truth;\n\n    /**\n     * @param truth Is this BooleanNode true?\n     */\n    public BooleanNode(boolean truth) {\n        this.truth = truth;\n    }\n\n    public boolean isTrue() {\n        return truth;\n    }\n\n    @Override\n    public Node getValue(Environment environment) throws RuntimeException {\n        return this;\n    }\n\n    @Override\n    public String toString() {\n        return \"\" + this.truth;\n    }\n}\n", "kage com.azure.core.annotation;\n\nimport java.lang.annotation.Repeatable;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.Target;\n\nimport static java.lang.annotation.ElementType.METHOD;\nimport static java.lang.annotation.RetentionPolicy.RUNTIME;\n\n/**\n * The {@link Repeatable} container annotation for {@link UnexpectedResponseExceptionType}. This allows methods to have\n * different exceptions to be thrown or returned based on the response status codes returned from a REST API.\n */\n@Retention(RUNTIME)\n@Target(METHOD)\npublic @interface UnexpectedResponseExceptionTypes {\n    /**\n     * @return array of {@link UnexpectedResponseExceptionType} that annotate a method.\n     */\n    UnexpectedResponseExceptionType[] value();\n}\n", "ot Really a named entity, but...\n\t\n\tprivate Type type;\n\tprivate String value;\n\t\n\tpublic Expression(String name) { // For Variables..\n\t\tsuper(name);\n\t\ttype = new Type(\"UNKNOWN\");\n\t}\n\t\n\tpublic Expression(Type t) {\n\t\tsuper(null);\n\t\tthis.type = t;\n\t}\n\t\n\tpublic Expression(Type t, String value) {\n\t\tsuper(null);\n\t\tthis.type = t;\n\t\tthis.value = value;\n\t}\n\t\n\tpublic Type getType() {\n\t\treturn type;\n\t}\n\t\n\tpublic void setType(Type type) {\n\t\tif (!getType().equals(new Type(\"UNKNOWN\")) && !type.equals(getType()))\n\t\t\tthrow new SemanticException(\"Illegal Type Assignment \" + type + \" and \" + getType());\n\t\tthis.type = type;\n\t}\n\t\n\tpublic String getValue() {\n\t\treturn value;\n\t}\n\t\n\tpublic String getAssemblyValue() {\n\t\treturn value == null ? \"R1\" : value;\n\t}\n\t\n\tpublic void setValue(Expression exp) {\n\t\tif (!exp.getType().equals(new Type(\"UNKNOWN\")))\n\t\t\tsetType(exp.getType());\n\t\tthis.value = exp.getValue();\n\t}\n\t\n\tpublic String toString() {\n//\t\treturn \"{ Expression: \" + getType() + \" \" + getValue() + \"  }\";\n\t\treturn getValue();\n\t}\n}\n", "import org.java_websocket.handshake.ClientHandshake;\nimport org.java_websocket.handshake.ClientHandshakeBuilder;\n\npublic class Draft_17 extends Draft_10\n{\n    @Override\n    public HandshakeState acceptHandshakeAsServer(ClientHandshake handshakedata) throws InvalidHandshakeException\n    {\n        int v = readVersion(handshakedata);\n        if (v == 13)\n        {\n            return HandshakeState.MATCHED;\n        }\n        return HandshakeState.NOT_MATCHED;\n    }\n\n    @Override\n    public Draft copyInstance()\n    {\n        return new Draft_17();\n    }\n\n    @Override\n    public ClientHandshakeBuilder postProcessHandshakeRequestAsClient(ClientHandshakeBuilder request)\n    {\n        super.postProcessHandshakeRequestAsClient(request);\n        request.put(\"Sec-WebSocket-Version\", \"13\");// overwriting the previous\n        request.put(\"Sec-WebSocket-Protocol\", \"sip\");\n        request.put(\"Origin\", \"http://www.sipinspector.com\");\n        return request;\n    }\n\n}\n", "ort javax.validation.constraints.NotNull;\r\nimport org.springframework.data.mongodb.core.mapping.DBRef;\r\n\r\npublic class Guardian extends AbstDoc {\r\n\r\n    @DBRef\r\n    @NotNull\r\n    private Profile profile;\r\n\r\n}\r\n", "on.test.RooIntegrationTest;\n\n@RooIntegrationTest(entity = Catalogue.class)\npublic class CatalogueIntegrationTest {\n\n    @Test\n    public void testMarkerMethod() {\n    }\n}\n", " android.app.Activity;\nimport android.app.AlertDialog;\nimport android.content.SharedPreferences;\nimport android.os.Bundle;\nimport android.preference.PreferenceManager;\nimport android.view.View;\nimport android.widget.Button;\nimport android.widget.EditText;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport com.aspose.cloud.appdemo.R;\nimport com.aspose.cloud.sdk.cells.Workbook;\nimport com.aspose.cloud.sdk.common.Product;\nimport com.aspose.cloud.sdk.common.AsposeApp;\n\npublic class CellsWorkbookSetModifyPassword extends Activity {\n\tprivate EditText constructor_arg1;\n\tprivate EditText function_arg1;\n\tprivate TextView result;\n\tprivate Button btnSubmit;\n\tprotected String password;\n\tprotected boolean response;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tBasicConfigurator.configure();\n\t\t// TODO Auto-generated method stub\n\t\tsuper.onCreate(savedInstanceState);\n\t\tsetContentView(R.layout.cells_workbook_setmodifypassword);\n\t\tinit();\n\t\tbtnSubmit.setOnClickListener(new View.OnClickListener() {\n\n\t\t\t@Override\n\t\t\tpublic void onClick(View arg0) {\n\t\t\t\t// TODO Auto-generated method stub\n\t\t\t\tif (function_arg1.getText().length() == 0\n\t\t\t\t\t\t|| constructor_arg1.getText().length() == 0) {\n\t\t\t\t\tAlertDialog.Builder dialog = new AlertDialog.Builder(\n\t\t\t\t\t\t\tCellsWorkbookSetModifyPassword.this);\n\t\t\t\t\tdialog.setTitle(\"Error\");\n\t\t\t\t\tdialog.setMessage(\"Please Enter Require Fields\");\n\t\t\t\t\tdialog.setNeutralButton(\"Ok\", null);\n\t\t\t\t\tdialog.show();\n\t\t\t\t} else {\n\t\t\t\t\tpassword = function_arg1.getText().toString();\n\t\t\t\t\tWorkbook obj = new Workbook(constructor_arg1.getText()\n\t\t\t\t\t\t\t.toString());\n\t\t\t\t\tresponse = obj.setModifyPassword(password);\n\t\t\t\t\tif (response) {\n\t\t\t\t\t\tresult.append(\"Modify Password is being set successfylly\");\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresult.append(\"Oops.. Something went wrong\");\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\tprivate void init() {\n\t\tconstructor_arg1 = (EditText) findViewById(R.id.cells_workbook_constructor_arg1);\n\t\tfunction_arg1 = (EditText) findViewById(R.id.cells_workbook_setmodifypassword_arg1);\n\t\tresult = (TextView) findViewById(R.id.txt_result);\n\t\tbtnSubmit = (Button) findViewById(R.id.btn_submit);\n\t\tSharedPreferences sp = PreferenceManager\n\t\t\t\t.getDefaultSharedPreferences(this);\n\t\tString app_sid = sp.getString(\"app_sid\", \"\");\n\t\tString app_key = sp.getString(\"app_key\", \"\");\n\t\tif (app_sid.equals(\"\") || app_key.equals(\"\")) {\n\t\t\tToast.makeText(this,\n\t\t\t\t\t\"No App Key or AppSid Define. Please Define Them First\",\n\t\t\t\t\tToast.LENGTH_LONG).show();\n\t\t\tthis.finish();\n\t\t} else {\n\t\t\tAsposeApp.setAppInfo(app_key, app_sid);\n\t\t\tProduct.setBaseProductUri(\"http://api.aspose.com/v1.1\");\n\t\t}\n\t}\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.appservice.v2018_02_01;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * An app cloneability criterion.\n */\npublic class SiteCloneabilityCriterion {\n    /**\n     * Name of criterion.\n     */\n    @JsonProperty(value = \"name\")\n    private String name;\n\n    /**\n     * Description of criterion.\n     */\n    @JsonProperty(value = \"description\")\n    private String description;\n\n    /**\n     * Get name of criterion.\n     *\n     * @return the name value\n     */\n    public String name() {\n        return this.name;\n    }\n\n    /**\n     * Set name of criterion.\n     *\n     * @param name the name value to set\n     * @return the SiteCloneabilityCriterion object itself.\n     */\n    public SiteCloneabilityCriterion withName(String name) {\n        this.name = name;\n        return this;\n    }\n\n    /**\n     * Get description of criterion.\n     *\n     * @return the description value\n     */\n    public String description() {\n        return this.description;\n    }\n\n    /**\n     * Set description of criterion.\n     *\n     * @param description the description value to set\n     * @return the SiteCloneabilityCriterion object itself.\n     */\n    public SiteCloneabilityCriterion withDescription(String description) {\n        this.description = description;\n        return this;\n    }\n\n}\n", ", to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.jruby.rack.ext;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.nio.ByteBuffer;\nimport java.nio.channels.Channel;\nimport java.nio.channels.Channels;\nimport java.nio.channels.FileChannel;\nimport java.nio.channels.ReadableByteChannel;\nimport java.nio.channels.WritableByteChannel;\nimport java.util.Map;\n\nimport org.jruby.Ruby;\nimport org.jruby.RubyArray;\nimport org.jruby.RubyBoolean;\nimport org.jruby.RubyClass;\nimport org.jruby.RubyHash;\nimport org.jruby.RubyIO;\nimport org.jruby.RubyNumeric;\nimport org.jruby.RubyObject;\nimport org.jruby.RubyString;\nimport org.jruby.RubyTime;\nimport org.jruby.anno.JRubyClass;\nimport org.jruby.anno.JRubyMethod;\nimport org.jruby.javasupport.JavaUtil;\nimport org.jruby.rack.RackException;\nimport org.jruby.rack.RackResponse;\nimport org.jruby.rack.RackResponseEnvironment;\nimport org.jruby.runtime.Arity;\nimport org.jruby.runtime.Block;\nimport org.jruby.runtime.BlockBody;\nimport org.jruby.runtime.Helpers;\nimport org.jruby.runtime.JavaInternalBlockBody;\nimport org.jruby.runtime.ObjectAllocator;\nimport org.jruby.runtime.Signature;\nimport org.jruby.runtime.ThreadContext;\nimport org.jruby.runtime.Visibility;\nimport org.jruby.runtime.builtin.IRubyObject;\nimport org.jruby.util.ByteList;\n\n/**\n * JRuby::Rack::Response - the bridge from a Rack response into a (Java)\n * (servlet) response environment, (re-)implemented mostly in Java ...\n *\n * @author kares\n */\n@JRubyClass(name=\"JRuby::Rack::Response\")\npublic class Response extends RubyObject implements RackResponse {\n\n    protected static Boolean swallowClientAbort = Boolean.TRUE;\n\n    /**\n     * # Whether we swallow client abort exceptions (EOF received on the socket).\n     * @param context\n     * @param self\n     * @return a ruby boolean\n     */\n    @JRubyMethod(name = \"swallow_client_abort?\", meta = true)\n    public static IRubyObject is_swallow_client_abort(final ThreadContext context, final IRubyObject self) {\n        if ( swallowClientAbort == null ) return context.runtime.getFalse();\n        return context.runtime.newBoolean(swallowClientAbort);\n    }\n\n    /**\n     * @see #is_swallow_client_abort(ThreadContext, IRubyObject)\n     */\n    @JRubyMethod(name = \"swallow_client_abort=\", meta = true, required = 1)\n    public static IRubyObject set_swallow_client_abort(final IRubyObject self, final IRubyObject value) {\n        if ( value instanceof RubyBoolean ) {\n            swallowClientAbort = ((RubyBoolean) value).isTrue();\n        }\n        else {\n            swallowClientAbort = ! value.isNil();\n        }\n        return value;\n    }\n\n    protected static Boolean dechunk; // null means not set\n\n    /**\n     * Whether responses should de-chunk data (when chunked response detected).\n     * @param context\n     * @param self\n     * @return a ruby boolean\n     */\n    @JRubyMethod(name = \"dechunk?\", meta = true)\n    public static IRubyObject is_dechunk(final ThreadContext context, final IRubyObject self) {\n        if ( dechunk == null ) return context.nil;\n        return context.runtime.newBoolean(dechunk);\n    }\n\n    /**\n     * @see #is_dechunk(ThreadContext, IRubyObject)\n     */\n    @JRubyMethod(name = \"dechunk=\", meta = true, required = 1)\n    public static IRubyObject set_dechunk(final IRubyObject self, final IRubyObject value) {\n        if ( value instanceof RubyBoolean ) {\n            dechunk = ((RubyBoolean) value).isTrue();\n        }\n        else {\n            dechunk = ! value.isNil();\n        }\n        return value;\n    }\n\n    private static Integer channelChunkSize = 32 * 1024 * 1024; // 32 MB\n\n    /**\n     * Returns the channel chunk size to be used e.g. when a (send) file\n     * response is detected. By setting this value to nil you force an \"explicit\"\n     * byte buffer to be used when copying between channels.\n     *\n     * @note High values won't hurt when sending small files since most Java\n     * (file) channel implementations handle this gracefully. However if you're\n     * on Windows it is  recommended to not set this higher than the \"magic\"\n     * number (64 * 1024 * 1024) - (32 * 1024) as there seems to be anecdotal\n     * evidence that attempts to transfer more than 64MB at a time on certain\n     * Windows versions results in a slow copy.\n     * @see #get_channel_buffer_size(ThreadContext, IRubyObject)\n     * @param context\n     * @param self\n     * @return a (ruby) integer value\n     */\n    @JRubyMethod(name = \"channel_chunk_size\", meta = true)\n    public static IRubyObject get_channel_chunk_size(final ThreadContext context, final IRubyObject self) {\n        if ( channelChunkSize == null ) return context.nil;\n        return context.runtime.newFixnum(channelChunkSize);\n    }\n\n    /**\n     * @see #get_channel_chunk_size(ThreadContext, IRubyObject)\n     */\n    @JRubyMethod(name = \"channel_chunk_size=\", meta = true, required = 1)\n    public static IRubyObject set_channel_chunk_size(final IRubyObject self, final IRubyObject value) {\n        if ( value.isNil() ) {\n            channelChunkSize = null;\n        }\n        else {\n            final long val = value.convertToInteger(\"to_i\").getLongValue();\n            channelChunkSize = Integer.valueOf((int) val);\n        }\n        return value;\n    }\n\n    protected static Integer channelBufferSize = 16 * 1024; // 16 kB\n\n    /**\n     * Returns a byte buffer size that will be allocated when copying between\n     * channels. This usually won't happen at all (unless you return an exotic\n     * channel backed object) as with file responses the response channel is\n     * always transferable and thus {#channel_chunk_size} will be used.\n     * @see #get_channel_chunk_size(ThreadContext, IRubyObject)\n     * @param context\n     * @param self\n     * @return a (ruby) integer value\n     */\n    @JRubyMethod(name = \"channel_buffer_size\", meta = true)\n    public static IRubyObject get_channel_buffer_size(final ThreadContext context, final IRubyObject self) {\n        return context.runtime.newFixnum(channelBufferSize);\n    }\n\n    /**\n     * @see #get_channel_buffer_size(ThreadContext, IRubyObject)\n     */\n    @JRubyMethod(name = \"channel_buffer_size=\", meta = true, required = 1)\n    public static IRubyObject set_channel_buffer_size(final IRubyObject self, final IRubyObject value) {\n        if ( value.isNil() ) {\n            channelBufferSize = 16 * 1024;\n        }\n        else {\n            final long val = value.convertToInteger(\"to_i\").getLongValue();\n            channelBufferSize = Integer.valueOf((int) val);\n        }\n        return value;\n    }\n\n    static final ObjectAllocator ALLOCATOR = new ObjectAllocator() {\n        public IRubyObject allocate(Ruby runtime, RubyClass klass) {\n            return new Response(runtime, klass);\n        }\n    };\n\n    protected Response(Ruby runtime, RubyClass metaClass) {\n        super(runtime, metaClass);\n    }\n\n    private int status;\n    private RubyHash headers;\n    private IRubyObject body;\n\n    /**\n     * Expects a Rack response.\n     * @param context\n     * @param arg [status, headers, body]\n     */\n    @JRubyMethod(required = 1)\n    public IRubyObject initialize(final ThreadContext context, final IRubyObject arg) {\n        if ( arg instanceof RubyArray ) {\n            final RubyArray arr = (RubyArray) arg;\n            if ( arr.size() < 3 ) {\n                throw context.runtime.newArgumentError(\"expected 3 array elements (rack-respose)\");\n            }\n            this.status = (int) arr.eltInternal(0).convertToInteger(\"to_i\").getLongValue();\n            this.headers = arr.eltInternal(1).convertToHash();\n            this.body = arr.eltInternal(2);\n        }\n        else {\n            this.status = (int) arg.callMethod(context, \"[]\", context.runtime.newFixnum(0)).\n                convertToInteger(\"to_i\").getLongValue();\n            this.headers = arg.callMethod(context, \"[]\", context.runtime.newFixnum(1)).convertToHash();\n            this.body = arg.callMethod(context, \"[]\", context.runtime.newFixnum(2));\n        }\n        // HACK: deal with objects that don't comply with Rack specification\n        if ( ! this.body.respondsTo(\"each_line\") && ! this.body.respondsTo(\"each\") ) {\n            this.body = this.body.asString(); // previously @body = [ @body.to_s ]\n        }\n        return this;\n    }\n\n    @JRubyMethod\n    public IRubyObject status(final ThreadContext context) {\n        return context.runtime.newFixnum(status);\n    }\n\n    @JRubyMethod\n    public IRubyObject body(final ThreadContext context) {\n        return this.body;\n    }\n\n    @JRubyMethod\n    public IRubyObject headers(final ThreadContext context) {\n        return this.headers;\n    }\n\n    // RackResponse\n\n    /**\n     * @return the response status\n     * @see RackResponse#getStatus()\n     */\n    public int getStatus() {\n        return this.status;\n    }\n\n    /**\n     * @return the headers hash\n     * @see RackResponse#getHeaders()\n     */\n    @SuppressWarnings(\"unchecked\")\n    public Map<String, ?> getHeaders() {\n        return this.headers;\n    }\n\n    /**\n     * @return the response body (build up as a string)\n     * @see RackResponse#getBody()\n     */\n    public String getBody() {\n        if ( this.body instanceof RubyString ) return this.body.asJavaString();\n        // body = \"\"; @body.each { |part| body << part }; body\n        final ThreadContext context = getRuntime().getCurrentContext();\n        try {\n            final StringBuilder bodyParts = new StringBuilder();\n            invoke(context, this.body, \"each\",\n                    new JavaInternalBlockBody(context.runtime, Signature.ONE_REQUIRED) {\n\n                    @Override\n                    public IRubyObject yield(ThreadContext context, IRubyObject[] args) {\n                        for (IRubyObject part : args) {\n                            bodyParts.append( part.asString().toString() );\n                        }\n                        return args[0];\n                    }\n                        \n                }\n                 \n            );\n            return bodyParts.toString();\n        }\n        finally {\n            if ( this.body.respondsTo(\"close\") ) {\n                this.body.callMethod(context, \"close\");\n            }\n        }\n    }\n\n    /**\n     * Respond this response with the given (servlet) response environment.\n     * @see RackResponse#respond(RackResponseEnvironment)\n     */\n    public void respond(final RackResponseEnvironment response) throws RackException {\n        if ( ! response.isCommitted() ) {\n            try { // NOTE: we're assuming possible overrides are out of our NS\n                if ( getMetaClass().getName().startsWith(\"JRuby::Rack\") ) {\n                    // do the Java 'optimized' version :\n                    writeStatus(response);\n                    writeHeaders(response);\n                    writeBody(response);\n                }\n                else { // plain-old Ruby version\n                    final ThreadContext context = currentContext();\n                    final IRubyObject rubyResponse = JavaUtil.convertJavaToRuby(context.runtime, response);\n                    callMethod(context, \"write_status\", rubyResponse);\n                    callMethod(context, \"write_headers\", rubyResponse);\n                    callMethod(context, \"write_body\", rubyResponse);\n                }\n            }\n            catch (IOException e) { throw new RackException(e); }\n        }\n    }\n\n    @JRubyMethod(name = \"write_status\")\n    public IRubyObject write_status(final ThreadContext context, final IRubyObject response) {\n        writeStatus( (RackResponseEnvironment) response.toJava(RackResponseEnvironment.class) );\n        return context.nil;\n    }\n\n    protected void writeStatus(final RackResponseEnvironment response) {\n        response.setStatus(this.status);\n    }\n\n    @JRubyMethod(name = \"write_headers\")\n    public IRubyObject write_headers(final ThreadContext context, final IRubyObject response)\n        throws IOException {\n        writeHeaders( (RackResponseEnvironment) response.toJava(RackResponseEnvironment.class) );\n        return context.nil;\n    }\n\n    private static final ByteList NEW_LINE = new ByteList(new byte[] { '\\n' }, false);\n\n    protected void writeHeaders(final RackResponseEnvironment response) throws IOException {\n        this.headers.visitAll(new RubyHash.Visitor() { // headers.each { |key, val| }\n            @Override\n            public void visit(final IRubyObject key, final IRubyObject val) {\n                final String name = key.toString();\n\n                if ( name.equalsIgnoreCase(\"Content-Type\") ) {\n                    response.setContentType( val.asJavaString() ); return;\n                }\n\n                if ( name.equalsIgnoreCase(\"Content-Length\") ) {\n                    if ( isChunked() ) return;\n                    final long length = val.convertToInteger(\"to_i\").getLongValue();\n                    if ( length < Integer.MAX_VALUE ) {\n                        response.setContentLength( (int) length ); return;\n                    } // else will do addHeader\n                }\n\n                if ( name.equals(\"Transfer-Encoding\") ) {\n                    if ( skipEncodingHeader(val) ) return;\n                }\n\n                // NOTE: effectively the same as `v.split(\"\\n\").each` which is what\n                // rack handler does to guard against response splitting attacks !\n                final boolean each_line = val.respondsTo(\"each_line\");\n                if ( each_line || val.respondsTo(\"each\") ) {\n                    final ThreadContext context = getRuntime().getCurrentContext();\n                    final RubyString newLine = RubyString.newString(context.runtime, NEW_LINE);\n                    // value.each_line { |val| response.addHeader(key.to_s, val.chomp(\"\\n\")) }\n                    invoke(context, val, each_line ? \"each_line\" : \"each\",\n                        new JavaInternalBlockBody(context.runtime, Signature.ONE_REQUIRED) {\n\n                            @Override\n                            public IRubyObject yield(ThreadContext context, IRubyObject[] args) {\n                                IRubyObject value = args[0];\n                                value.callMethod(context, \"chomp!\", newLine);\n                                response.addHeader(name, value.toString());\n                                return value;\n                            }\n                                                    \n                        }\n                    );\n                    return;\n                }\n\n                if ( val instanceof RubyNumeric ) {\n                    final long value = val.convertToInteger(\"to_i\").getLongValue();\n                    if ( value < Integer.MAX_VALUE ) {\n                        response.addIntHeader(name, (int) value); return;\n                    } // else will do addHeader\n                }\n                else if ( val instanceof RubyTime ) {\n                    final long millis = ((RubyTime) val).getDateTime().getMillis();\n                    response.addDateHeader(name, millis); return;\n                }\n\n                response.addHeader(name, val.toString());\n            }\n        });\n    }\n\n    @JRubyMethod(name = \"write_body\")\n    public IRubyObject write_body(final ThreadContext context, final IRubyObject response)\n        throws IOException {\n        writeBody( (RackResponseEnvironment) response.toJava(RackResponseEnvironment.class) );\n        return context.nil;\n    }\n\n    protected void writeBody(final RackResponseEnvironment response) throws IOException {\n        Channel bodyChannel = null; IRubyObject body = this.body;\n        try {\n            if ( body.respondsTo(\"call\") && ! body.respondsTo(\"each\") ) {\n                final ThreadContext context = currentContext();\n                final IRubyObject outputStream =\n                    JavaUtil.convertJavaToRuby(context.runtime, response.getOutputStream());\n                this.body.callMethod(context, \"call\", outputStream);\n                return;\n            }\n\n            if ( body.respondsTo(\"to_path\") ) { // send_file\n                final ThreadContext context = currentContext();\n                final IRubyObject path = body.callMethod(context, \"to_path\");\n                callMethod(\"send_file\", path, JavaUtil.convertJavaToRuby(context.runtime, response));\n                return;\n            }\n\n            if ( body.respondsTo(\"body_parts\") ) {\n                body = body.callMethod(currentContext(), \"body_parts\");\n            }\n\n            if ( body.respondsTo(\"to_channel\") ) { // (body or body.body_parts).to_channel\n                if ( body instanceof RubyIO ) {\n                    bodyChannel = ((RubyIO) body).getChannel();\n                }\n                else {\n                    final ThreadContext context = currentContext();\n                    final IRubyObject channel = body.callMethod(context, \"to_channel\");\n                    bodyChannel = (Channel) channel.toJava(Channel.class);\n                }\n                if ( bodyChannel instanceof FileChannel ) {\n                    transferChannel( (FileChannel) bodyChannel, response.getOutputStream() );\n                }\n                else {\n                    transferChannel( (ReadableByteChannel) bodyChannel, response.getOutputStream() );\n                }\n                return;\n            }\n            // NOTE: we no longer handle \"to_inputstream\" since in 1.7 \"to_channel\" covers those ...\n\n            final OutputStream output = response.getOutputStream();\n            final ThreadContext context = currentContext();\n            IOException error = null;\n            if ( doDechunk() ) {\n                final IRubyObject output_stream = JavaUtil.convertJavaToRuby(context.runtime, output);\n                callMethod(context, \"write_body_dechunked\", output_stream);\n            }\n            else {\n                final String method = body.respondsTo(\"each_line\") ? \"each_line\" : \"each\";\n                try {\n                    invoke(context, body, method,\n                        new JavaInternalBlockBody(context.runtime, Signature.ONE_REQUIRED) {\n\n                        @Override\n                        public IRubyObject yield(ThreadContext context, IRubyObject[] args) {\n                            IRubyObject line = args[0];\n                            final ByteList bytes = line.asString().getByteList();\n                            try {\n                                output.write( line.asString().getBytes() );\n                                //output.write(bytes.unsafeBytes(), bytes.getBegin(), bytes.getRealSize());\n                                if ( doFlush() ) output.flush();\n                            }\n                            catch (IOException e) { throw new WrappedException(e); }\n                            return context.nil;\n                        }                                               \n                        \n                    });\n                }\n                catch (WrappedException e) { throw e.getIOCause(); }\n            }\n        }\n        catch (IOException e) { if ( ! handledAsClientAbort(e) ) throw e; }\n        catch (RuntimeException e) { if ( ! handledAsClientAbort(e) ) throw e; }\n        finally {\n            if ( body.respondsTo(\"close\") ) {\n                body.callMethod(currentContext(), \"close\");\n            }\n            else if ( bodyChannel != null ) {\n                bodyChannel.close(); // closing the channel closes the stream\n            }\n        }\n    }\n\n    private static class WrappedException extends RuntimeException {\n\n        WrappedException(IOException cause) {\n            super(cause);\n        }\n\n        IOException getIOCause() { return (IOException) getCause(); }\n\n    }\n\n    /**\n     * Sends a file when a Rails/Rack file response (`body.to_path`) is detected.\n     * This allows for potential application server overrides when file streaming.\n     * By default JRuby-Rack will stream the file using a (native) file channel.\n     * @param context\n     * @param path the file path\n     * @param response the response environment\n     * @throws IOException\n     */\n    @JRubyMethod(name = \"send_file\")\n    public IRubyObject send_file(final ThreadContext context,\n        final IRubyObject path, final IRubyObject response) throws IOException {\n        // NOTE: That this is not related to `Rack::Sendfile` support, since if you\n        // have configured *sendfile.type* (e.g. to Apache's \"X-Sendfile\") this part\n        // would not have been executing at all.\n        final RackResponseEnvironment servletResponse =\n            (RackResponseEnvironment) response.toJava(Object.class);\n        final FileInputStream input = new FileInputStream( path.asString().toString() );\n        final FileChannel inputChannel = input.getChannel();\n        try {\n            transferChannel(inputChannel, servletResponse.getOutputStream());\n        }\n        finally {\n            inputChannel.close();\n            try { input.close(); } catch (IOException e) { /* ignored */ }\n        }\n        return context.nil;\n    }\n\n    @JRubyMethod(name = \"chunked?\")\n    public IRubyObject chunked_p(final ThreadContext context) {\n        return context.runtime.newBoolean( isChunked() );\n    }\n\n    private static final ByteList TRANSFER_ENCODING = new ByteList(\n        new byte[] { 'T','r','a','n','s','f','e','r','-','E','n','c','o','d','i','n','g' },\n    false);\n\n    private Boolean chunked;\n\n    /**\n     * @return whether a chunked encoding is detected\n     */\n    public boolean isChunked() {\n        if ( chunked != null ) return chunked;\n        if ( this.headers != null ) {\n            final RubyString key = RubyString.newString(getRuntime(), TRANSFER_ENCODING);\n            final IRubyObject value = this.headers.callMethod(\"[]\", key);\n            if ( value instanceof RubyString ) {\n                return chunked = ( (RubyString) value ).getByteList().equal(CHUNKED);\n            }\n        }\n        return chunked = Boolean.FALSE;\n    }\n\n    /**\n     * @return whether de-chunking (a chunked Rack response) should be performed\n     */\n    protected boolean doDechunk() {\n        return dechunk == Boolean.TRUE && isChunked();\n    }\n\n    @JRubyMethod(name = \"flush?\")\n    public IRubyObject flush_p(final ThreadContext context) {\n        return context.runtime.newBoolean( doFlush() );\n    }\n\n    private static final ByteList CONTENT_LENGTH = new ByteList(\n        new byte[] { 'C','o','n','t','e','n','t','-','L','e','n','g','t','h' },\n    false);\n\n    /**\n     * @return whether output (body) should be flushed after each written line\n     */\n    protected boolean doFlush() {\n        if ( isChunked() ) return true;\n        if ( this.headers != null ) {\n            final RubyString key = RubyString.newString(getRuntime(), CONTENT_LENGTH);\n            final IRubyObject value = this.headers.callMethod(\"[]\", key);\n            return value.isNil(); // does not have a Content-Length header\n        }\n        return false;\n    }\n\n    private boolean handledAsClientAbort(final Exception ioe) {\n        if ( swallowClientAbort == Boolean.TRUE ) {\n            return isClientAbortException(ioe);\n        }\n        return false;\n    }\n\n    // ioe.inspect =~ /(ClientAbortException|EofException|broken pipe)/i\n    protected boolean isClientAbortException(final Exception ioe) {\n        String error = ioe.toString();\n        if ( error.contains(\"ClientAbortException\") ) return true;\n        if ( error.contains(\"EofException\") ) return true;\n        while ( true ) {\n            if ( error.toLowerCase().contains(\"broken pipe\") ) return true;\n            if ( ioe.getCause() == null ) break;\n            error = ioe.getCause().getMessage();\n            if ( error == null ) break;\n        }\n        return false;\n    }\n\n    private static final ByteList CHUNKED = new ByteList(new byte[] { 'c','h','u','n','k','e','d' }, false);\n\n    private boolean skipEncodingHeader(final IRubyObject value) {\n        if ( dechunk == Boolean.FALSE ) return false;\n        if ( value instanceof RubyString ) {\n            return ( (RubyString) value ).getByteList().equal(CHUNKED);\n        }\n        return false;\n    }\n\n    public Integer getChannelChunkSize() {\n        return channelChunkSize;\n    }\n\n    private void transferChannel(final FileChannel channel, final OutputStream output)\n        throws IOException {\n        final Integer chunkSize = getChannelChunkSize();\n        if ( chunkSize != null && chunkSize > 0 ) {\n            final WritableByteChannel outputChannel = Channels.newChannel(output);\n            long pos = 0; final long size = channel.size();\n            while ( pos < size ) {\n                // for small sizes will (correctly) \"ignore\" the large chunk :\n                pos += channel.transferTo(pos, chunkSize, outputChannel);\n            }\n        }\n        else {\n            transferChannel( (ReadableByteChannel) channel, output);\n        }\n    }\n\n    public Integer getChannelBufferSize() {\n        return channelBufferSize;\n    }\n\n    private void transferChannel(final ReadableByteChannel channel, final OutputStream output)\n        throws IOException {\n        final WritableByteChannel outputChannel = Channels.newChannel(output);\n\n        final ByteBuffer buffer = ByteBuffer.allocate(getChannelBufferSize());\n\n        while ( channel.read(buffer) != -1 ) {\n            buffer.flip();\n            outputChannel.write(buffer);\n            buffer.compact();\n        }\n        buffer.flip();\n        while ( buffer.hasRemaining() ) {\n            outputChannel.write(buffer);\n        }\n    }\n\n    ThreadContext currentContext() { return getRuntime().getCurrentContext(); }\n\n    static IRubyObject invoke(\n        final ThreadContext context, final IRubyObject self,\n        final String method, final BlockBody body) {\n        Block block = new Block(body, context.currentBinding(self, Visibility.PUBLIC));\n        return Helpers.invoke(context, self, method, block);\n    }\n\n    @Override\n    public Object toJava(Class target) {\n        if ( target == null || target == RackResponse.class ) return this;\n        return super.toJava(target);\n    }\n\n}\n", "Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.model;\n\nimport hudson.Extension;\nimport hudson.Util;\nimport hudson.model.Descriptor.FormException;\nimport hudson.util.FormValidation;\nimport java.io.IOException;\nimport java.util.Collection;\nimport javax.servlet.ServletException;\n\nimport jenkins.model.Jenkins;\nimport org.jenkinsci.Symbol;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\nimport org.kohsuke.stapler.Stapler;\nimport org.kohsuke.stapler.StaplerFallback;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\nimport org.kohsuke.stapler.interceptor.RequirePOST;\n\n/**\n * A view that delegates to another.\n * \n * TODO: this does not respond to renaming or deleting the proxied view.\n * \n * @author Tom Huybrechts\n *\n */\npublic class ProxyView extends View implements StaplerFallback {\n\n    private String proxiedViewName;\n\n    @DataBoundConstructor\n    public ProxyView(String name) {\n        super(name);\n\n        if (Jenkins.getInstance().getView(name) != null) {\n            // if this is a valid global view name, let's assume the\n            // user wants to show it\n            proxiedViewName = name;\n        }\n    }\n\n    public View getProxiedView() {\n        if (proxiedViewName == null) {\n            // just so we avoid errors just after creation\n            return Jenkins.getInstance().getPrimaryView();\n        } else {\n            return Jenkins.getInstance().getView(proxiedViewName);\n        }\n    }\n\n    public String getProxiedViewName() {\n        return proxiedViewName;\n    }\n\n    public void setProxiedViewName(String proxiedViewName) {\n        this.proxiedViewName = proxiedViewName;\n    }\n\n    @Override\n    public Collection<TopLevelItem> getItems() {\n        return getProxiedView().getItems();\n    }\n\n    @Override\n    public boolean contains(TopLevelItem item) {\n        return getProxiedView().contains(item);\n    }\n\n    @Override\n    protected void submit(StaplerRequest req) throws IOException, ServletException, FormException {\n        String proxiedViewName = req.getSubmittedForm().getString(\"proxiedViewName\");\n        if (Jenkins.getInstance().getView(proxiedViewName) == null) {\n            throw new FormException(\"Not an existing global view\", \"proxiedViewName\");\n        }\n        this.proxiedViewName = proxiedViewName;\n    }\n\n    @RequirePOST\n    @Override\n    public Item doCreateItem(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        return getProxiedView().doCreateItem(req, rsp);\n    }\n\n    /**\n     * Fails if a global view with the given name does not exist.\n     */\n    public FormValidation doViewExistsCheck(@QueryParameter String value) {\n        checkPermission(View.CREATE);\n\n        String view = Util.fixEmpty(value);\n        if(view==null) return FormValidation.ok();\n\n        if(Jenkins.getInstance().getView(view)!=null)\n            return FormValidation.ok();\n        else\n            return FormValidation.error(Messages.ProxyView_NoSuchViewExists(value));\n    }\n\n    @Extension @Symbol(\"proxy\")\n    public static class DescriptorImpl extends ViewDescriptor {\n\n        @Override\n        public String getDisplayName() {\n            return Messages.ProxyView_DisplayName();\n        }\n        \n        @Override\n        public boolean isInstantiable() {\n        \t// doesn't make sense to add a ProxyView to the global views\n        \treturn !(Stapler.getCurrentRequest().findAncestorObject(ViewGroup.class) instanceof Jenkins);\n        }\n\n    }\n\n    public Object getStaplerFallback() {\n        return getProxiedView();\n    }\n\n}\n", " private Node next;\n     \n    public Node(int pageNumber) {\n        this.pageNumber = pageNumber;\n    }\n \n    public int getPageNumber() {\n        return pageNumber;\n    }\n \n    public void setPageNumber(int data) {\n        this.pageNumber = data;\n    }\n     \n    public Node getPrev() {\n        return prev;\n    }\n \n    public void setPrev(Node prev) {\n        this.prev = prev;\n    }\n \n    public Node getNext() {\n        return next;\n    }\n \n    public void setNext(Node next) {\n        this.next = next;\n    }\n     \n    public String toString() {\n        return pageNumber + \"  \";\n    }\n}\n", "BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.Loader;\nimport android.database.Cursor;\nimport android.os.Bundle;\nimport android.support.v4.widget.SwipeRefreshLayout;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.StaggeredGridLayoutManager;\nimport android.support.v7.widget.Toolbar;\nimport android.text.format.DateUtils;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.TextView;\n\nimport com.example.android.xyzreader.R;\nimport com.example.android.xyzreader.data.ArticleLoader;\nimport com.example.android.xyzreader.data.ItemsContract;\nimport com.example.android.xyzreader.data.UpdaterService;\n\n/**\n * An activity representing a list of Articles. This activity has different presentations for\n * handset and tablet-size devices. On handsets, the activity presents a list of items, which when\n * touched, lead to a {@link ArticleDetailActivity} representing item details. On tablets, the\n * activity presents a grid of items as cards.\n */\npublic class ArticleListActivity extends AppCompatActivity implements\n        LoaderManager.LoaderCallbacks<Cursor> {\n\n    private SwipeRefreshLayout mSwipeRefreshLayout;\n    private RecyclerView mRecyclerView;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_article_list);\n\n        Toolbar mToolbar = (Toolbar) findViewById(R.id.toolbar);\n        setSupportActionBar(mToolbar);\n\n        mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipe_refresh_layout);\n\n        mRecyclerView = (RecyclerView) findViewById(R.id.recycler_view);\n        getLoaderManager().initLoader(0, null, this);\n\n        if (savedInstanceState == null) {\n            refresh();\n        }\n    }\n\n    private void refresh() {\n        startService(new Intent(this, UpdaterService.class));\n    }\n\n    @Override\n    protected void onStart() {\n        super.onStart();\n        registerReceiver(mRefreshingReceiver,\n                new IntentFilter(UpdaterService.BROADCAST_ACTION_STATE_CHANGE));\n    }\n\n    @Override\n    protected void onStop() {\n        super.onStop();\n        unregisterReceiver(mRefreshingReceiver);\n    }\n\n    private boolean mIsRefreshing = false;\n\n    private BroadcastReceiver mRefreshingReceiver = new BroadcastReceiver() {\n        @Override\n        public void onReceive(Context context, Intent intent) {\n            if (UpdaterService.BROADCAST_ACTION_STATE_CHANGE.equals(intent.getAction())) {\n                mIsRefreshing = intent.getBooleanExtra(UpdaterService.EXTRA_REFRESHING, false);\n                updateRefreshingUI();\n            }\n        }\n    };\n\n    private void updateRefreshingUI() {\n        mSwipeRefreshLayout.setRefreshing(mIsRefreshing);\n    }\n\n    @Override\n    public Loader<Cursor> onCreateLoader(int i, Bundle bundle) {\n        return ArticleLoader.newAllArticlesInstance(this);\n    }\n\n    @Override\n    public void onLoadFinished(Loader<Cursor> cursorLoader, Cursor cursor) {\n        Adapter adapter = new Adapter(cursor);\n        adapter.setHasStableIds(true);\n        mRecyclerView.setAdapter(adapter);\n        int columnCount = getResources().getInteger(R.integer.list_column_count);\n        StaggeredGridLayoutManager sglm =\n                new StaggeredGridLayoutManager(columnCount, StaggeredGridLayoutManager.VERTICAL);\n        mRecyclerView.setLayoutManager(sglm);\n    }\n\n    @Override\n    public void onLoaderReset(Loader<Cursor> loader) {\n        mRecyclerView.setAdapter(null);\n    }\n\n    private class Adapter extends RecyclerView.Adapter<ViewHolder> {\n        private Cursor mCursor;\n\n        public Adapter(Cursor cursor) {\n            mCursor = cursor;\n        }\n\n        @Override\n        public long getItemId(int position) {\n            mCursor.moveToPosition(position);\n            return mCursor.getLong(ArticleLoader.Query._ID);\n        }\n\n        @Override\n        public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType) {\n            View view = getLayoutInflater().inflate(R.layout.list_item_article, parent, false);\n            final ViewHolder vh = new ViewHolder(view);\n            view.setOnClickListener(new View.OnClickListener() {\n                @Override\n                public void onClick(View view) {\n                    startActivity(new Intent(Intent.ACTION_VIEW,\n                            ItemsContract.Items.buildItemUri(getItemId(vh.getAdapterPosition()))));\n                }\n            });\n            return vh;\n        }\n\n        @Override\n        public void onBindViewHolder(ViewHolder holder, int position) {\n            mCursor.moveToPosition(position);\n            holder.titleView.setText(mCursor.getString(ArticleLoader.Query.TITLE));\n            holder.subtitleView.setText(\n                    DateUtils.getRelativeTimeSpanString(\n                            mCursor.getLong(ArticleLoader.Query.PUBLISHED_DATE),\n                            System.currentTimeMillis(), DateUtils.HOUR_IN_MILLIS,\n                            DateUtils.FORMAT_ABBREV_ALL).toString()\n                            + \" by \"\n                            + mCursor.getString(ArticleLoader.Query.AUTHOR));\n            holder.thumbnailView.setImageUrl(\n                    mCursor.getString(ArticleLoader.Query.THUMB_URL),\n                    ImageLoaderHelper.getInstance(ArticleListActivity.this).getImageLoader());\n            holder.thumbnailView.setAspectRatio(mCursor.getFloat(ArticleLoader.Query.ASPECT_RATIO));\n        }\n\n        @Override\n        public int getItemCount() {\n            return mCursor.getCount();\n        }\n    }\n\n    public static class ViewHolder extends RecyclerView.ViewHolder {\n        public DynamicHeightNetworkImageView thumbnailView;\n        public TextView titleView;\n        public TextView subtitleView;\n\n        public ViewHolder(View view) {\n            super(view);\n            thumbnailView = (DynamicHeightNetworkImageView) view.findViewById(R.id.thumbnail);\n            titleView = (TextView) view.findViewById(R.id.article_title);\n            subtitleView = (TextView) view.findViewById(R.id.article_subtitle);\n        }\n    }\n}", "- Property of IBM\n * \"Restricted Materials of IBM\"\n * \n * IBM SDK, Java(tm) Technology Edition, v8\n * (C) Copyright IBM Corp. 2000, 2012. All Rights Reserved\n *\n * US Government Users Restricted Rights - Use, duplication or disclosure\n * restricted by GSA ADP Schedule Contract with IBM Corp.\n *===========================================================================\n */\n/*\n * Copyright (c) 2000, 2012, Oracle and/or its affiliates. All rights reserved.\n * ORACLE PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n *\n */\npackage java.beans;\n\nimport com.sun.beans.decoder.DocumentHandler;\n\nimport java.io.Closeable;\nimport java.io.InputStream;\nimport java.io.IOException;\nimport java.security.AccessControlContext;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\n\nimport org.xml.sax.InputSource;\nimport org.xml.sax.helpers.DefaultHandler;\n\n/**\n * The <code>XMLDecoder</code> class is used to read XML documents\n * created using the <code>XMLEncoder</code> and is used just like\n * the <code>ObjectInputStream</code>. For example, one can use\n * the following fragment to read the first object defined\n * in an XML document written by the <code>XMLEncoder</code>\n * class:\n * <pre>\n *       XMLDecoder d = new XMLDecoder(\n *                          new BufferedInputStream(\n *                              new FileInputStream(\"Test.xml\")));\n *       Object result = d.readObject();\n *       d.close();\n * </pre>\n *\n *<p>\n * For more information you might also want to check out\n * <a\n href=\"http://java.sun.com/products/jfc/tsc/articles/persistence3\">Long Term Persistence of JavaBeans Components: XML Schema</a>,\n * an article in <em>The Swing Connection.</em>\n * @see XMLEncoder\n * @see java.io.ObjectInputStream\n *\n * @since 1.4\n *\n * @author Philip Milne\n */\npublic class XMLDecoder implements AutoCloseable {\n    private final AccessControlContext acc = AccessController.getContext();\n    private final DocumentHandler handler = new DocumentHandler();\n    private final InputSource input;\n    private Object owner;\n    private Object[] array;\n    private int index;\n\n    /**\n     * Creates a new input stream for reading archives\n     * created by the <code>XMLEncoder</code> class.\n     *\n     * @param in The underlying stream.\n     *\n     * @see XMLEncoder#XMLEncoder(java.io.OutputStream)\n     */\n    public XMLDecoder(InputStream in) {\n        this(in, null);\n    }\n\n    /**\n     * Creates a new input stream for reading archives\n     * created by the <code>XMLEncoder</code> class.\n     *\n     * @param in The underlying stream.\n     * @param owner The owner of this stream.\n     *\n     */\n    public XMLDecoder(InputStream in, Object owner) {\n        this(in, owner, null);\n    }\n\n    /**\n     * Creates a new input stream for reading archives\n     * created by the <code>XMLEncoder</code> class.\n     *\n     * @param in the underlying stream.\n     * @param owner the owner of this stream.\n     * @param exceptionListener the exception handler for the stream;\n     *        if <code>null</code> the default exception listener will be used.\n     */\n    public XMLDecoder(InputStream in, Object owner, ExceptionListener exceptionListener) {\n        this(in, owner, exceptionListener, null);\n    }\n\n    /**\n     * Creates a new input stream for reading archives\n     * created by the <code>XMLEncoder</code> class.\n     *\n     * @param in the underlying stream.  <code>null</code> may be passed without\n     *        error, though the resulting XMLDecoder will be useless\n     * @param owner the owner of this stream.  <code>null</code> is a legal\n     *        value\n     * @param exceptionListener the exception handler for the stream, or\n     *        <code>null</code> to use the default\n     * @param cl the class loader used for instantiating objects.\n     *        <code>null</code> indicates that the default class loader should\n     *        be used\n     * @since 1.5\n     */\n    public XMLDecoder(InputStream in, Object owner,\n                      ExceptionListener exceptionListener, ClassLoader cl) {\n        this(new InputSource(in), owner, exceptionListener, cl);\n    }\n\n\n    /**\n     * Creates a new decoder to parse XML archives\n     * created by the {@code XMLEncoder} class.\n     * If the input source {@code is} is {@code null},\n     * no exception is thrown and no parsing is performed.\n     * This behavior is similar to behavior of other constructors\n     * that use {@code InputStream} as a parameter.\n     *\n     * @param is  the input source to parse\n     *\n     * @since 1.7\n     */\n    public XMLDecoder(InputSource is) {\n        this(is, null, null, null);\n    }\n\n    /**\n     * Creates a new decoder to parse XML archives\n     * created by the {@code XMLEncoder} class.\n     *\n     * @param is     the input source to parse\n     * @param owner  the owner of this decoder\n     * @param el     the exception handler for the parser,\n     *               or {@code null} to use the default exception handler\n     * @param cl     the class loader used for instantiating objects,\n     *               or {@code null} to use the default class loader\n     *\n     * @since 1.7\n     */\n    private XMLDecoder(InputSource is, Object owner, ExceptionListener el, ClassLoader cl) {\n        this.input = is;\n        this.owner = owner;\n        setExceptionListener(el);\n        this.handler.setClassLoader(cl);\n        this.handler.setOwner(this);\n    }\n\n    /**\n     * This method closes the input stream associated\n     * with this stream.\n     */\n    public void close() {\n        if (parsingComplete()) {\n            close(this.input.getCharacterStream());\n            close(this.input.getByteStream());\n        }\n    }\n\n    private void close(Closeable in) {\n        if (in != null) {\n            try {\n                in.close();\n            }\n            catch (IOException e) {\n                getExceptionListener().exceptionThrown(e);\n            }\n        }\n    }\n\n    private boolean parsingComplete() {\n        if (this.input == null) {\n            return false;\n        }\n        if (this.array == null) {\n            if ((this.acc == null) && (null != System.getSecurityManager())) {\n                throw new SecurityException(\"AccessControlContext is not set\");\n            }\n            AccessController.doPrivileged(new PrivilegedAction<Void>() {\n                public Void run() {\n                    XMLDecoder.this.handler.parse(XMLDecoder.this.input);\n                    return null;\n                }\n            }, this.acc);\n            this.array = this.handler.getObjects();\n        }\n        return true;\n    }\n\n    /**\n     * Sets the exception handler for this stream to <code>exceptionListener</code>.\n     * The exception handler is notified when this stream catches recoverable\n     * exceptions.\n     *\n     * @param exceptionListener The exception handler for this stream;\n     * if <code>null</code> the default exception listener will be used.\n     *\n     * @see #getExceptionListener\n     */\n    public void setExceptionListener(ExceptionListener exceptionListener) {\n        if (exceptionListener == null) {\n            exceptionListener = Statement.defaultExceptionListener;\n        }\n        this.handler.setExceptionListener(exceptionListener);\n    }\n\n    /**\n     * Gets the exception handler for this stream.\n     *\n     * @return The exception handler for this stream.\n     *     Will return the default exception listener if this has not explicitly been set.\n     *\n     * @see #setExceptionListener\n     */\n    public ExceptionListener getExceptionListener() {\n        return this.handler.getExceptionListener();\n    }\n\n    /**\n     * Reads the next object from the underlying input stream.\n     *\n     * @return the next object read\n     *\n     * @throws ArrayIndexOutOfBoundsException if the stream contains no objects\n     *         (or no more objects)\n     *\n     * @see XMLEncoder#writeObject\n     */\n    public Object readObject() {\n        return (parsingComplete())\n                ? this.array[this.index++]\n                : null;\n    }\n\n    /**\n     * Sets the owner of this decoder to <code>owner</code>.\n     *\n     * @param owner The owner of this decoder.\n     *\n     * @see #getOwner\n     */\n    public void setOwner(Object owner) {\n        this.owner = owner;\n    }\n\n    /**\n     * Gets the owner of this decoder.\n     *\n     * @return The owner of this decoder.\n     *\n     * @see #setOwner\n     */\n    public Object getOwner() {\n        return owner;\n    }\n\n    /**\n     * Creates a new handler for SAX parser\n     * that can be used to parse embedded XML archives\n     * created by the {@code XMLEncoder} class.\n     *\n     * The {@code owner} should be used if parsed XML document contains\n     * the method call within context of the &lt;java&gt; element.\n     * The {@code null} value may cause illegal parsing in such case.\n     * The same problem may occur, if the {@code owner} class\n     * does not contain expected method to call. See details <a\n     * href=\"http://java.sun.com/products/jfc/tsc/articles/persistence3/\">here</a>.\n     *\n     * @param owner  the owner of the default handler\n     *               that can be used as a value of &lt;java&gt; element\n     * @param el     the exception handler for the parser,\n     *               or {@code null} to use the default exception handler\n     * @param cl     the class loader used for instantiating objects,\n     *               or {@code null} to use the default class loader\n     * @return an instance of {@code DefaultHandler} for SAX parser\n     *\n     * @since 1.7\n     */\n    public static DefaultHandler createHandler(Object owner, ExceptionListener el, ClassLoader cl) {\n        DocumentHandler handler = new DocumentHandler();\n        handler.setOwner(owner);\n        handler.setExceptionListener(el);\n        handler.setClassLoader(cl);\n        return handler;\n    }\n}\n", "util.Objects;\nimport java.util.Optional;\nimport java.util.stream.Stream;\nimport java.util.zip.ZipEntry;\nimport java.util.zip.ZipFile;\n\n\npublic class ZipFileResourceProvider implements Resource.Provider {\n\n    private final ZipFile zipFile;\n\n    public ZipFileResourceProvider(ZipFile zipFile) {\n        this.zipFile = zipFile;\n    }\n\n    @Override\n    public Optional<Resource.Readable> getResourceByName(String path) {\n        return Optional.of(path).filter(p -> p.startsWith(\"/\")).map(p -> p.substring(1)).flatMap(this::getEntryByName);\n    }\n\n    private Optional<Resource.Readable> getEntryByName(final String entryName) {\n        return entryStream().filter(e -> entryName.equals(e.getName())).map(this::getZipResource).findFirst();\n    }\n\n    @Override\n    public Stream<Resource.Readable> stream() {\n        return entryStream().map(this::getZipResource);\n    }\n\n    private Stream<? extends ZipEntry> entryStream() {\n        return zipFile.stream().filter(e -> !e.isDirectory());\n    }\n\n    private Resource.Readable getZipResource(ZipEntry zipEntry) {\n        return Kute.zipEntryResource(\"/\" + zipEntry.getName(), zipFile, zipEntry);\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof ZipFileResourceProvider)) return false;\n        ZipFileResourceProvider readables = (ZipFileResourceProvider) o;\n        return Objects.equals(zipFile, readables.zipFile);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(zipFile);\n    }\n\n    @Override\n    public String toString() {\n        return \"ZipFileResourceProvider{\" +\n                \"zipFile=\" + zipFile +\n                '}';\n    }\n}\n\n\n\n\n\n", "itmap;\nimport android.graphics.BitmapFactory;\nimport android.os.Bundle;\nimport android.os.Environment;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.AppCompatActivity;\nimport android.text.TextUtils;\nimport android.widget.ImageView;\nimport android.widget.Toast;\n\nimport com.android.volley.RequestQueue;\nimport com.android.volley.VolleyError;\nimport com.android.volley.toolbox.ImageRequest;\nimport com.android.volley.toolbox.Volley;\nimport com.andyiac.talkischeap.R;\nimport com.orhanobut.logger.Logger;\n\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\n\n/**\n * Created by andyiac on 5/21/16.\n * <p>\n * \u4f7f\u7528volley \u4e0b\u8f7d\u7f51\u4e0a\u7684\u56fe\u7247 \u6d4b\u8bd5\u751f\u6210bitmap \u5360\u7528\u5185\u5b58\u7684\u5927\u5c0f\n * <p>\n * \u540c\u65f6\u6d4b\u8bd5\u4fdd\u5b58bitmap\u5230\u6587\u4ef6\u7684\u65b9\u6cd5\n * <p>\n * \u5728XFZ app \u4e2d\u4fdd\u5b58bitmap\u5230\u6587\u4ef6\u65b9\u6cd5\u591a\u6b21\u5bfc\u81f4OOM\n */\npublic class ImageBitmapMemoryTestActivity extends AppCompatActivity {\n\n    private ImageView mImageView;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.image_bitmap_memory_test_activity);\n        initView();\n        initData();\n    }\n\n    private void initView() {\n        mImageView = (ImageView) findViewById(R.id.id_memory_test_img);\n    }\n\n\n    private void initData() {\n\n        mDataRootPath = getCacheDir().getPath();\n\n        String img_url = \"http://e.hiphotos.baidu.com/image/pic/item/dcc451da81cb39db02807657d2160924ab18306a.jpg\";\n        RequestQueue mQueue = Volley.newRequestQueue(this);\n        ImageRequest imageRequest = new ImageRequest(\n                img_url,\n                new com.android.volley.Response.Listener<Bitmap>() {\n                    @Override\n                    public void onResponse(final Bitmap bitmap_src) {\n\n                        Bitmap bitmap = Bitmap.createScaledBitmap(bitmap_src, 200, 300, true);\n\n                        int height = bitmap.getHeight();\n                        int width = bitmap.getWidth();\n                        int size = bitmap.getRowBytes() * height;\n\n                        Logger.e(\"height ==>>\" + height + \" \\n\" +\n                                \"width ===>>\" + width + \"\\n\" +\n                                \"size =====\" + size + \" \\n\" +\n                                \"getByteCount\" + bitmap.getByteCount() + \"\\n\" +\n                                \"get row bytes \" + bitmap.getRowBytes()\n                        );\n\n                        mImageView.setImageBitmap(bitmap);\n                        savaBitmap(\"jestfor.jpg\", bitmap);\n\n                    }\n                }, 0, 0, Bitmap.Config.ALPHA_8, new com.android.volley.Response.ErrorListener() {\n            @Override\n            public void onErrorResponse(VolleyError error) {\n            }\n        });\n        mQueue.add(imageRequest);\n    }\n\n\n    /**\n     * \u4fdd\u5b58Image\u7684\u65b9\u6cd5\uff0c\u6709sd\u5361\u5b58\u50a8\u5230sd\u5361\uff0c\u6ca1\u6709\u5c31\u5b58\u50a8\u5230\u624b\u673a\u76ee\u5f55\n     *\n     * @param fileName\n     * @param bitmap_src\n     */\n    public void savaBitmap(String fileName, Bitmap bitmap_src) {\n        if (bitmap_src == null) {\n            return;\n        }\n//        Bitmap bitmap = Bitmap.createScaledBitmap(bitmap_src,200,300,true);\n\n        String path = getStorageDirectory();\n        File folderFile = new File(path);\n        if (!folderFile.exists()) {\n            folderFile.mkdir();\n        }\n        File file = new File(path + File.separator + fileName);\n\n        String path2 = file.getAbsolutePath();\n        Logger.e(\"=======path ====>>\" + path2);\n\n        try {\n            file.createNewFile();\n            FileOutputStream fos = new FileOutputStream(file);\n            bitmap_src.compress(Bitmap.CompressFormat.JPEG, 99, fos);\n            fos.flush();\n            fos.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n    }\n\n\n    /**\n     * sd\u5361\u7684\u6839\u76ee\u5f55\n     */\n    private static String mSdRootPath = Environment.getExternalStorageDirectory().getPath();\n    /**\n     * \u624b\u673a\u7684\u7f13\u5b58\u6839\u76ee\u5f55\n     */\n    private static String mDataRootPath = null;\n    /**\n     * \u4fdd\u5b58Image\u7684\u76ee\u5f55\u540d\n     */\n    private final static String FOLDER_NAME = \"/AndroidImage\";\n\n\n    /**\n     * \u83b7\u53d6\u50a8\u5b58Image\u7684\u76ee\u5f55\n     *\n     * @return\n     */\n    public String getStorageDirectory() {\n        return Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED) ?\n                mSdRootPath + FOLDER_NAME : mDataRootPath + FOLDER_NAME;\n    }\n\n\n}\n", "*;\nimport edu.psu.compbio.seqcode.gse.utils.*;\nimport edu.psu.compbio.seqcode.gse.utils.database.DatabaseException;\n\nimport java.util.*;\nimport java.io.*;\nimport java.sql.*;\n\npublic class SQLMLE extends SQLGeneric implements ChipChipMLE {\n    private int lasttype;\n    private String dataminsql, maxsql,minsql, maxrngsql, minrngsql;\n    private ArrayList<Double> b_i, bindll, nullll, lograt, conf;\n\n    public SQLMLE (String analysis, String version, int genomeid)  \n        throws NotFoundException {\n        super(\"mleanalysis\",analysis,version,genomeid);\n        String exptidstring = \" analysis = ? \";\n        datasql = \"select position, b_i, bindll, nullll, lograt, conf \" +\n            \"from mleresults where \" + exptidstring + \" and chromosome = ?\" +\n            \" and position >= ? and position <= ? order by position\";\n        dataminsql = \"select position, b_i, bindll, nullll, lograt, conf \" +\n            \"from mleresults where \" + exptidstring + \" and chromosome = ?\" +\n            \" and position >= ? and position <= ? \" +\n            \" and b_i >= ? and conf <= ? order by position\";\n        maxsql = \"select max(b_i) from mleresults where \" + exptidstring;\n        minsql = \"select min(b_i) from mleresults where \" + exptidstring;\n        maxrngsql = \"select max(b_i) from mleresults where \" +\n            exptidstring + \" and chromosome = ? \" + \n            \" and position >= ? and position <= ? \";\n        minrngsql = \"select min(b_i) from mleresults where \" +\n        \texptidstring + \" and chromosome = ? \" + \n        \t\" and position >= ? and position <= ? \";\n    }\n    public int getReplicates(int i) {\n        return 1;\n    }\n    public double getMax() {\n        try {\n            PreparedStatement maxstmt = chipcxn.prepareStatement(maxsql);\n            maxstmt.setInt(1,exptid);\n            ResultSet rs = maxstmt.executeQuery();\n            if(rs.next()) {\n                double d = rs.getDouble(1);\n                rs.close();\n                maxstmt.close();\n                return d;\n            } else {\n                throw new DatabaseException(\"Can't get max for analysis \" + exptid);\n            }\n        }catch (SQLException ex) {\n            throw new DatabaseException(ex.toString(),ex);\n        }\n    }\n    /* start and stop are chromosomal positions */\n    public double getMax(String chrom, int start, int stop) throws NotFoundException {\n        try {\n            PreparedStatement maxrngstmt = chipcxn.prepareStatement(maxrngsql);\n            bindExptParams(maxrngstmt);\n            maxrngstmt.setInt(sqlparambase+0,exptid);\n            maxrngstmt.setInt(sqlparambase+1,getChromID(chrom));\n            maxrngstmt.setInt(sqlparambase+2,start);\n            maxrngstmt.setInt(sqlparambase+3,stop);\n            ResultSet rs = maxrngstmt.executeQuery();\n            rs.next();\n            double d = rs.getDouble(1);\n            rs.close();\n            maxrngstmt.close();\n            return d;\n        }catch (SQLException ex) {\n            throw new DatabaseException(ex.toString(),ex);\n        }\n    }\n    public double getMin() {\n        try {\n            PreparedStatement minstmt = chipcxn.prepareStatement(minsql);\n            minstmt.setInt(1,exptid);\n            ResultSet rs = minstmt.executeQuery();\n            if(rs.next()) {\n                double d = rs.getDouble(1);\n                rs.close();\n                minstmt.close();\n                return d;\n            } else {\n                throw new DatabaseException(\"Can't get min for analysis \" + exptid);\n            }\n        }catch (SQLException ex) {\n            throw new DatabaseException(ex.toString(),ex);\n        }\n    }\n    /* start and stop are chromosomal positions */\n    public double getMin(String chrom, int start, int stop) throws NotFoundException {\n        try {\n            PreparedStatement minrngstmt = chipcxn.prepareStatement(minrngsql);\n            bindExptParams(minrngstmt);\n            minrngstmt.setInt(sqlparambase+0,exptid);\n            minrngstmt.setInt(sqlparambase+1,getChromID(chrom));\n            minrngstmt.setInt(sqlparambase+2,start);\n            minrngstmt.setInt(sqlparambase+3,stop);\n            ResultSet rs = minrngstmt.executeQuery();\n            rs.next();\n            double d = rs.getDouble(1);\n            rs.close();\n            minrngstmt.close();\n            return d;\n        }catch (SQLException ex) {\n            throw new DatabaseException(ex.toString(),ex);\n        }\n    }\n    public void window(String chrom, int start, int stop, double minsize, double maxconf) \n    throws NotFoundException {\n        if (sameWindow(chrom,start,stop,2)) {return;}\n        try {\n            PreparedStatement datastmt = chipcxn.prepareStatement(dataminsql);     \n            datastmt.setFetchSize(100);\n            bindExptParams(datastmt);\n            datastmt.setInt(sqlparambase+0,getChromID(chrom));\n            datastmt.setInt(sqlparambase+1,start);\n            datastmt.setInt(sqlparambase+2,stop);\n            datastmt.setDouble(sqlparambase+3,minsize);\n            datastmt.setDouble(sqlparambase+4,maxconf);\n            parseWindow(datastmt.executeQuery());\n            datastmt.close();\n        } catch (SQLException ex) {\n            throw new DatabaseException(ex.toString(),ex);\n        }\n    }\n    \n    protected void parseWindow(ResultSet rs) throws SQLException {\n        ArrayList<Integer> poslist = new ArrayList<Integer>();\n        b_i = new ArrayList<Double>();\n        bindll = new ArrayList<Double>();\n        nullll = new ArrayList<Double>();\n        lograt = new ArrayList<Double>();\n        conf = new ArrayList<Double>();\n        int i = 0;\n        while (rs.next()) {\n            poslist.add(rs.getInt(1));\n            b_i.add(rs.getDouble(2));\n            bindll.add(rs.getDouble(3));\n            nullll.add(rs.getDouble(4));\n            lograt.add(rs.getDouble(5));\n            conf.add(rs.getDouble(6));\n            i++;\n        }\n        count = i;\n        int[] positions = new int[poslist.size()];\n        for (i = 0; i < poslist.size(); i++) {positions[i] = poslist.get(i);}\n        setPositions(positions);\n        rs.close();\n    }\n\n    public double getSize(int i) {\n        return b_i.get(i);\n    }\n    public double getValue(int i, int j) {\n        return getSize(i);\n    }\n    public double getBindLL(int i){\n        return bindll.get(i);\n    }\n    public double getNullLL(int i){\n        return nullll.get(i);\n    }\n    public double getLogRat(int i){\n        return lograt.get(i);\n    }\n    public double getConf(int i) {\n        return conf.get(i);\n    }\n    public void close() {\n        super.close();\n    }\n\n\n}\n", "ornerFacing implements IStringSerializable {\n    NORTH_WEST(0,\"northwest\"),\n    SOUTH_WEST(1,\"southwest\"),\n    NORTH_EAST(2,\"northeast\"),\n    SOUTH_EAST(3,\"southeast\");\n\n    private final int ID;\n    private final String name;\n    public static final CornerFacing[] VALUES;\n\n    CornerFacing(int id, String name){\n        this.ID = id;\n        this.name = name;\n    }\n\n    static{\n        CornerFacing[] vals = values();\n        VALUES = new CornerFacing[vals.length];\n        for(CornerFacing cf : vals){\n            VALUES[cf.getID()]=cf;\n        }\n    }\n\n    @Override\n    public String getName() {\n        return name;\n    }\n\n    public int getID() {\n        return ID;\n    }\n\n    @Override\n    public String toString() {\n        return getName();\n    }\n\n    public static CornerFacing getById(int metadata) {\n        return VALUES[metadata%VALUES.length];\n    }\n}\n", "uppressWarnings(\"unused\")\npublic class Location {\n\n    private Double lat;\n    private Double lng;\n\n    public Double getLat() {\n        return lat;\n    }\n\n    public Double getLng() {\n        return lng;\n    }\n}\n", "ort List\n * Medium\n * 255\n * 314\n * Favorite\n * Share\n * Sort a linked list using insertion sort.\n * <p>\n * <p>\n * A graphical example of insertion sort. The partial sorted list (black) initially contains only the first element in the list.\n * With each iteration one element (red) is removed from the input data and inserted in-place into the sorted list\n * <p>\n * <p>\n * Algorithm of Insertion Sort:\n * <p>\n * Insertion sort iterates, consuming one input element each repetition, and growing a sorted output list.\n * At each iteration, insertion sort removes one element from the input data, finds the location it belongs within the sorted list, and inserts it there.\n * It repeats until no input elements remain.\n * <p>\n * Example 1:\n * <p>\n * Input: 4->2->1->3\n * Output: 1->2->3->4\n * Example 2:\n * <p>\n * Input: -1->5->3->4->0\n * Output: -1->0->3->4->5\n */\npublic class Solution {\n    public ListNode insertionSortList(ListNode head) {\n        ListNode result = null;\n        ListNode next = head;\n        while (next != null) {\n            ListNode current = next;\n            next = next.next;\n            current.next = null;\n            result = insert(result, current);\n        }\n        return result;\n    }\n\n    private ListNode insert(ListNode result, ListNode next) {\n        ListNode head = result;\n        ListNode pre = null;\n        if (head == null) {\n            return next;\n        }\n        while (head != null) {\n\n            if (head.val < next.val) {\n                if (head.next == null) {\n                    head.next = next;\n                    break;\n                } else {\n                    pre = head;\n                    head = head.next;\n                }\n            } else {\n                if (pre != null) {\n                    pre.next = next;\n                    next.next = head;\n                    break;\n                } else {\n                    next.next = head;\n                    result = next;\n                    break;\n                }\n            }\n\n        }\n        return result;\n    }\n}\n", "kage com.azure.search.documents.implementation.converters;\n\nimport com.azure.search.documents.indexes.models.NGramTokenFilter;\n\n/**\n * The helper class to set the non-public properties of an {@link NGramTokenFilter} instance.\n */\npublic final class NGramTokenFilterHelper {\n    private static NGramTokenFilterAccessor accessor;\n\n    private NGramTokenFilterHelper() { }\n\n    /**\n     * Type defining the methods to set the non-public properties of an {@link NGramTokenFilter} instance.\n     */\n    public interface NGramTokenFilterAccessor {\n        void setODataType(NGramTokenFilter tokenFilter, String odataType);\n        String getODataType(NGramTokenFilter tokenFilter);\n    }\n\n    /**\n     * The method called from {@link NGramTokenFilter} to set it's accessor.\n     *\n     * @param tokenFilterAccessor The accessor.\n     */\n    public static void setAccessor(final NGramTokenFilterAccessor tokenFilterAccessor) {\n        accessor = tokenFilterAccessor;\n    }\n\n    static void setODataType(NGramTokenFilter tokenFilter, String odataType) {\n        accessor.setODataType(tokenFilter, odataType);\n    }\n\n    static String getODataType(NGramTokenFilter tokenFilter) {\n        return accessor.getODataType(tokenFilter);\n    }\n}\n", "Copyright (c) Of Fire Twins Wesp 2015.                      /\n//                          Alise Wesp & Yuuki Wesp                            /\n////////////////////////////////////////////////////////////////////////////////\n\npackage RC.Framework.Extension.System.Marshal;\n\nimport RC.Framework.Extension.System.Int16;\nimport RC.Framework.Extension.System.Int32;\nimport RC.Framework.Extension.System.Marshal.SystemType;\nimport RC.Framework.RException.NotSupportedException;\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\npublic class BitConverter\n{\n\tpublic static byte[] getBytes(Int16 value)\n\t{\n\t\treturn getBytes(value.value);\n\t}\n\tpublic static byte[] getBytes(Int32 value)\n\t{\n\t\treturn getBytes(value.value);\n\t}\n\tpublic static byte[] getBytes(short value)\n\t{\n\t\treturn ByteBuffer.allocate(Short.BYTES).order(ByteOrder.nativeOrder()).putShort(value).array();\n\t}\n\tpublic static byte[] getBytes(float value)\n\t{\n\t\treturn ByteBuffer.allocate(Float.BYTES).order(ByteOrder.nativeOrder()).putFloat(value).array();\n\t}\n\tpublic static byte[] getBytes(long value)\n\t{\n\t\treturn ByteBuffer.allocate(Long.BYTES).order(ByteOrder.nativeOrder()).putLong(value).array();\n\t}\n\tpublic static byte[] getBytes(int value)\n\t{\n\t\treturn ByteBuffer.allocate(Integer.BYTES).order(ByteOrder.nativeOrder()).putInt(value).array();\n\t}\n\tpublic static byte[] getBytes(boolean value)\n\t{\n\t\tbyte[] ar = new byte[0];\n\t\ttry\n\t\t{\n\t\t\tar = new byte[SystemType.SizeOf(boolean.class)];\n\t\t} catch (NotSupportedException ignored) {}\n\t\tif(value)\n\t\t\tar[0] = 1;\n\t\telse\n\t\t\tar[0] = 0;\n\t\treturn ar;\n\t}\n\tpublic static float toSingle(byte[] buffer)\n\t{\n\t\treturn ByteBuffer.wrap(buffer, 0, buffer.length).order(ByteOrder.nativeOrder()).getFloat();\n\t}\n\tpublic static int toInt32(byte[] buffer)\n\t{\n\t\treturn ByteBuffer.wrap(buffer, 0, buffer.length).order(ByteOrder.nativeOrder()).getInt();\n\t}\n\tpublic static long toInt64(byte[] buffer)\n\t{\n\t\treturn ByteBuffer.wrap(buffer, 0, buffer.length).order(ByteOrder.nativeOrder()).getLong();\n\t}\n\tpublic static short toInt16(byte[] buffer)\n\t{\n\t\treturn ByteBuffer.wrap(buffer, 0, buffer.length).order(ByteOrder.nativeOrder()).getShort();\n\t}\n\tpublic static boolean toBool(byte[] buffer)\n\t{\n\t\treturn buffer[0] == 1;\n\t}\n}\n", "ort java.awt.*;\r\n   import java.awt.event.*;\r\n   import javax.swing.*;\r\n   import java.io.*;\r\n\t\r\n\t/*\r\nCopyright (c) 2003-2008,  Pete Sanderson and Kenneth Vollmar\r\n\r\nDeveloped by Pete Sanderson (psanderson@otterbein.edu)\r\nand Kenneth Vollmar (kenvollmar@missouristate.edu)\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining \r\na copy of this software and associated documentation files (the \r\n\"Software\"), to deal in the Software without restriction, including \r\nwithout limitation the rights to use, copy, modify, merge, publish, \r\ndistribute, sublicense, and/or sell copies of the Software, and to \r\npermit persons to whom the Software is furnished to do so, subject \r\nto the following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be \r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF \r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. \r\nIN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR \r\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF \r\nCONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION \r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n\r\n(MIT license, http://www.opensource.org/licenses/mit-license.html)\r\n */\r\n\t\r\n   /**\r\n    * Action class for the Settings menu item to control whether or not\r\n\t * assembler warnings are considered errors.  If so, a program generating\r\n\t * warnings but not errors will not assemble.\r\n    */\r\n    public class SettingsWarningsAreErrorsAction extends GuiAction  {\r\n   \t\r\n   \r\n       public SettingsWarningsAreErrorsAction(String name, Icon icon, String descrip,\r\n                             Integer mnemonic, KeyStroke accel, VenusUI gui) {\r\n         super(name, icon, descrip, mnemonic, accel, gui);\r\n      }\r\n   \t\t \r\n       public void actionPerformed(ActionEvent e) {\r\n\t\t   Globals.getSettings().setWarningsAreErrors(((JCheckBoxMenuItem)e.getSource()).isSelected());\r\n      }\r\n   \t   \t\r\n   }", "er;\nimport org.opengroupware.pubexport.OGoPubPageComponent;\nimport org.opengroupware.pubexport.parsers.OGoPubHTMLParser;\n\n@SuppressWarnings(\"rawtypes\")\npublic class OGoPubHTMLDocument extends OGoPubComponentDocument {\n\n  /* keys */\n  \n  @Override\n  public String objType() {\n    return \"document\";\n  }\n  \n  @Override\n  public String mimeType() {\n    return \"text/html\";\n  }\n\n  /* component definition */\n  \n  public Class lookupComponentClass(String _name, WOResourceManager _rm) {\n    return OGoPubPageComponent.class;\n  }\n  \n  @Override\n  public Class parserClass() {\n    return OGoPubHTMLParser.class;\n  }\n  \n  /* renderer */\n}\n", "t.v4.view.ViewPager;\nimport android.util.AttributeSet;\nimport android.view.View;\n\npublic class CalendarCardPager extends ViewPager {\n\n    private CardPagerAdapter mCardPagerAdapter;\n    private OnCellItemClick mOnCellItemClick;\n\n    public CalendarCardPager(Context context, AttributeSet attrs, int defStyle) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public CalendarCardPager(Context context, AttributeSet attrs) {\n        super(context, attrs);\n        init(context);\n    }\n\n    public CalendarCardPager(Context context) {\n        super(context);\n        init(context);\n    }\n\n    private void init(Context context) {\n        mCardPagerAdapter = new CardPagerAdapter(context);\n        setAdapter(mCardPagerAdapter);\n    }\n\n    public CardPagerAdapter getCardPagerAdapter() {\n        return mCardPagerAdapter;\n    }\n\n    public OnCellItemClick getOnCellItemClick() {\n        return mOnCellItemClick;\n    }\n\n    public void setOnCellItemClick(OnCellItemClick mOnCellItemClick) {\n        this.mOnCellItemClick = mOnCellItemClick;\n        mCardPagerAdapter.setDefaultOnCellItemClick(this.mOnCellItemClick);\n        if (getChildCount() > 0) {\n            for (int i = 0; i < getChildCount(); i++) {\n                View v = getChildAt(i);\n                if (v instanceof CalendarCard) {\n                    ((CalendarCard) v).setOnCellItemClick(this.mOnCellItemClick);\n                }\n            }\n        }\n    }\n\n}\n", "le.common.collect.Maps;\nimport com.google.gson.Gson;\nimport top.cardone.ConsumerApplication;\nimport lombok.extern.log4j.Log4j2;\nimport lombok.val;\nimport org.apache.commons.io.FileUtils;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.core.io.Resource;\nimport org.springframework.http.HttpEntity;\nimport org.springframework.http.HttpHeaders;\nimport org.springframework.http.MediaType;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\nimport org.springframework.util.CollectionUtils;\nimport top.cardone.context.ApplicationContextHolder;\n\nimport java.util.Map;\n\n@Log4j2\n@RunWith(SpringJUnit4ClassRunner.class)\n@SpringBootTest(classes = ConsumerApplication.class, value = {\"spring.profiles.active=test\"}, webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)\npublic class R0004FuncTest {\n    @Value(\"http://localhost:${server.port:8765}${server.servlet.context-path:}/v1/log/operateLog/r0004.json\")\n    private String funcUrl;\n\n    @Value(\"file:src/test/resources/top/cardone/func/v1/log/operateLog/R0004FuncTest.func.input.json\")\n    private Resource funcInputResource;\n\n    @Value(\"file:src/test/resources/top/cardone/func/v1/log/operateLog/R0004FuncTest.func.output.json\")\n    private Resource funcOutputResource;\n\n    @Test\n    public void func() throws Exception {\n        if (!funcInputResource.exists()) {\n            FileUtils.write(funcInputResource.getFile(), \"{}\", Charsets.UTF_8);\n        }\n\n        val input = FileUtils.readFileToString(funcInputResource.getFile(), Charsets.UTF_8);\n\n        Map<String, Object> parametersMap = ApplicationContextHolder.getBean(Gson.class).fromJson(input, Map.class);\n\n        Assert.assertFalse(\"\u8f93\u5165\u672a\u914d\u7f6e\", CollectionUtils.isEmpty(parametersMap));\n\n        Map<String, Object> output = Maps.newLinkedHashMap();\n\n        for (val parametersEntry : parametersMap.entrySet()) {\n            val body = ApplicationContextHolder.getBean(Gson.class).toJson(parametersEntry.getValue());\n\n            val headers = new HttpHeaders();\n\n            headers.setContentType(MediaType.APPLICATION_JSON_UTF8);\n            headers.set(\"Accept\", MediaType.APPLICATION_JSON_UTF8_VALUE);\n            headers.set(\"collectionStationCodeForToken\", parametersEntry.getKey().split(\":\")[0]);\n            headers.set(\"token\", ApplicationContextHolder.getBean(org.apache.shiro.authc.credential.PasswordService.class).encryptPassword(headers.get(\"collectionStationCodeForToken\").get(0)));\n\n            val httpEntity = new HttpEntity<>(body, headers);\n\n            val json = new org.springframework.boot.test.web.client.TestRestTemplate().postForObject(funcUrl, httpEntity, String.class);\n\n            val value = ApplicationContextHolder.getBean(Gson.class).fromJson(json, Map.class);\n\n            output.put(parametersEntry.getKey(), value);\n        }\n\n        FileUtils.write(funcOutputResource.getFile(), ApplicationContextHolder.getBean(Gson.class).toJson(output), Charsets.UTF_8);\n    }\n}", "bute it and/or modify\n    it under the terms of the GNU General Public License as published by\n    the Free Software Foundation; either version 2 of the License, or\n    (at your option) any later version.\n\n    This program is distributed in the hope that it will be useful,\n    but WITHOUT ANY WARRANTY; without even the implied warranty of\n    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n    GNU General Public License for more details.\n\n    You should have received a copy of the GNU General Public License along\n    with this program; if not, write to the Free Software Foundation, Inc.,\n    51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n*/\npackage net.sf.jabref.logic;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Objects;\nimport java.util.Optional;\n\nimport net.sf.jabref.BibDatabaseContext;\nimport net.sf.jabref.model.EntryTypes;\nimport net.sf.jabref.model.FieldChange;\nimport net.sf.jabref.model.database.BibDatabase;\nimport net.sf.jabref.model.database.BibDatabaseMode;\nimport net.sf.jabref.model.entry.BibEntry;\nimport net.sf.jabref.model.entry.EntryType;\nimport net.sf.jabref.model.entry.EntryUtil;\nimport net.sf.jabref.model.entry.FieldName;\nimport net.sf.jabref.model.entry.FileField;\nimport net.sf.jabref.model.entry.ParsedFileField;\n\npublic class TypedBibEntry {\n\n    private final BibEntry entry;\n    private final Optional<BibDatabase> database;\n    private final BibDatabaseMode mode;\n\n    public TypedBibEntry(BibEntry entry, BibDatabaseMode mode) {\n        this(entry, Optional.empty(), mode);\n    }\n\n    private TypedBibEntry(BibEntry entry, Optional<BibDatabase> database, BibDatabaseMode mode) {\n        this.entry = Objects.requireNonNull(entry);\n        this.database = Objects.requireNonNull(database);\n        this.mode = mode;\n    }\n\n    public TypedBibEntry(BibEntry entry, BibDatabaseContext databaseContext) {\n        this(entry, Optional.of(databaseContext.getDatabase()), databaseContext.getMode());\n    }\n\n    /**\n     * Returns true if this entry contains the fields it needs to be\n     * complete.\n     */\n    public boolean hasAllRequiredFields() {\n        Optional<EntryType> type = EntryTypes.getType(entry.getType(), this.mode);\n        if(type.isPresent()) {\n            return entry.allFieldsPresent(type.get().getRequiredFields(), database.orElse(null));\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * Gets the display name for the type of the entry.\n     */\n    public String getTypeForDisplay() {\n        Optional<EntryType> entryType = EntryTypes.getType(entry.getType(), mode);\n        if (entryType.isPresent()) {\n            return entryType.get().getName();\n        } else {\n            return EntryUtil.capitalizeFirst(entry.getType());\n        }\n    }\n\n    /**\n     * Gets a list of linked files.\n     *\n     * @return the list of linked files, is never null but can be empty\n     */\n    public List<ParsedFileField> getFiles() {\n        //Extract the path\n        Optional<String> oldValue = entry.getFieldOptional(FieldName.FILE);\n        if (!oldValue.isPresent()) {\n            return new ArrayList<>();\n        }\n\n        return FileField.parse(oldValue.get());\n    }\n\n    public Optional<FieldChange> setFiles(List<ParsedFileField> files) {\n\n        Optional<String> oldValue = entry.getFieldOptional(FieldName.FILE);\n        String newValue = FileField.getStringRepresentation(files);\n\n        if(oldValue.isPresent() && oldValue.get().equals(newValue)) {\n            return Optional.empty();\n        }\n\n        entry.setField(FieldName.FILE, newValue);\n        return Optional.of(new FieldChange(entry, FieldName.FILE, oldValue.orElse(\"\"), newValue));\n    }\n}\n", "rsion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.gk969.gallery.gallery3d.data;\n\nimport java.util.ArrayList;\n\npublic class FilterEmptyPromptSet extends MediaSet implements ContentListener {\n    @SuppressWarnings(\"unused\")\n    private static final String TAG = \"FilterEmptyPromptSet\";\n\n    private ArrayList<MediaItem> mEmptyItem;\n    private MediaSet mBaseSet;\n\n    public FilterEmptyPromptSet(Path path, MediaSet baseSet, MediaItem emptyItem) {\n        super(path, INVALID_DATA_VERSION);\n        mEmptyItem = new ArrayList<MediaItem>(1);\n        mEmptyItem.add(emptyItem);\n        mBaseSet = baseSet;\n        mBaseSet.addContentListener(this);\n    }\n\n    @Override\n    public int getMediaItemCount() {\n        int itemCount = mBaseSet.getMediaItemCount();\n        if (itemCount > 0) {\n            return itemCount;\n        } else {\n            return 1;\n        }\n    }\n\n    @Override\n    public ArrayList<MediaItem> getMediaItem(int start, int count) {\n        int itemCount = mBaseSet.getMediaItemCount();\n        if (itemCount > 0) {\n            return mBaseSet.getMediaItem(start, count);\n        } else if (start == 0 && count == 1) {\n            return mEmptyItem;\n        } else {\n            throw new ArrayIndexOutOfBoundsException();\n        }\n    }\n\n    @Override\n    public void onContentDirty() {\n        notifyContentChanged();\n    }\n\n    @Override\n    public boolean isLeafAlbum() {\n        return true;\n    }\n\n    @Override\n    public boolean isCameraRoll() {\n        return mBaseSet.isCameraRoll();\n    }\n\n    @Override\n    public long reload() {\n        return mBaseSet.reload();\n    }\n\n    @Override\n    public String getName() {\n        return mBaseSet.getName();\n    }\n}\n", "ofit2.http.GET;\nimport rx.Observable;\n\npublic interface RouteService {\n    @GET(\"Routes?format=json\")\n    Observable<Route[]> routes();\n\n    interface Callback {\n        void receivedRoutes(Route[] routes);\n    }\n\n}\n", " wired into\n * to a variable name. This provides flexibility changing wiring, makes checking\n * the wiring easier and significantly reduces the number of magic numbers\n * floating around.\n */\npublic class RobotMap {\n    // For example to map the left and right motors, you could define the\n    // following variables to use with your drivetrain subsystem.\n    // public static int leftMotor = 1;\n    // public static int rightMotor = 2;\n    \n    // If you are using multiple modules, make sure to define both the port\n    // number and the module. For example you with a rangefinder:\n    // public static int rangefinderPort = 1;\n    // public static int rangefinderModule = 1;\n}\n", ";\nimport com.builtbroken.mc.api.grid.IGridNode;\nimport com.builtbroken.mc.api.tile.ConnectionType;\nimport com.builtbroken.mc.api.tile.ITileConnection;\nimport com.builtbroken.mc.core.network.IPacketReceiver;\nimport com.builtbroken.mc.core.network.packet.PacketTile;\nimport com.builtbroken.mc.core.network.packet.PacketType;\nimport com.builtbroken.mc.imp.transform.vector.Pos;\nimport com.builtbroken.mc.prefab.tile.Tile;\nimport cpw.mods.fml.common.network.ByteBufUtils;\nimport cpw.mods.fml.relauncher.Side;\nimport cpw.mods.fml.relauncher.SideOnly;\nimport io.netty.buffer.ByteBuf;\nimport net.minecraft.block.Block;\nimport net.minecraft.block.material.Material;\nimport net.minecraft.client.renderer.texture.IIconRegister;\nimport net.minecraft.entity.player.EntityPlayer;\nimport net.minecraft.tileentity.TileEntity;\nimport net.minecraft.util.IIcon;\nimport net.minecraftforge.common.util.ForgeDirection;\n\n/**\n * Really basic wires with no extra functionality beyond providing connections for networks\n *\n * @see <a href=\"https://github.com/BuiltBrokenModding/VoltzEngine/blob/development/license.md\">License</a> for what you can and can't do with the code.\n * Created by Dark(DarkGuardsman, Robert) on 2/1/2017.\n */\npublic class TileWire extends Tile implements IPacketReceiver, IGridNode<WireNetwork>, ITileConnection\n{\n    //TODO replace with casing object, allows for none-block materials\n    public Block casingMaterial;\n    public int casingMaterialMeta = 0;\n\n    public WireNetwork network;\n\n    /** Bitmask **/\n    private byte wireConnections = 0;\n\n    @SideOnly(Side.CLIENT)\n    private static IIcon wireTexture;\n\n    public TileWire()\n    {\n        super(\"wire\", Material.iron);\n        onAdded();\n    }\n\n    @Override\n    public Tile newTile()\n    {\n        return new TileWire();\n    }\n\n    @Override\n    public void onNeighborChanged(Pos pos)\n    {\n        //IF we do not have a grid, find or make one\n        if (getGrid() == null)\n        {\n            findOrMakeGrid();\n        }\n\n        //TODO unit test\n        final TileEntity tile = pos.getTileEntity(oldWorld());\n        final ForgeDirection dir = toPos().sub(pos).floor().toForgeDirection();\n        if (tile instanceof ITileConnection)\n        {\n            if (((ITileConnection) tile).canConnect(this, ConnectionType.UE_POWER, dir))\n            {\n                checkForConnection(dir, tile);\n            }\n            else if (hasWireConnection(dir))\n            {\n                refreshConnections();\n            }\n        }\n        else if (hasWireConnection(dir))\n        {\n            refreshConnections();\n        }\n    }\n\n    @Override\n    public boolean refreshConnections()\n    {\n        final Pos center = new Pos((TileEntity)this);\n\n        //IF we do not have a grid, find or make one\n        if (getGrid() == null)\n        {\n            findOrMakeGrid();\n        }\n\n        //Update connections\n        final byte prevConnections = wireConnections;\n        for (ForgeDirection direction : ForgeDirection.VALID_DIRECTIONS)\n        {\n            final Pos pos = center.add(direction);\n            final TileEntity tile = pos.getTileEntity(oldWorld());\n            checkForConnection(direction, tile);\n        }\n        if (prevConnections != wireConnections)\n        {\n            sendDescPacket();\n            return true;\n        }\n        return false;\n    }\n\n    private void findOrMakeGrid()\n    {\n        final Pos center = new Pos((TileEntity)this);\n        //Look for an existing network\n        for (ForgeDirection direction : ForgeDirection.VALID_DIRECTIONS)\n        {\n            Pos pos = center.add(direction);\n            TileEntity tile = pos.getTileEntity(oldWorld());\n            if (tile instanceof TileWire && ((TileWire) tile).getGrid() != null)\n            {\n                setGrid(((TileWire) tile).getGrid());\n                break;\n            }\n        }\n        if (getGrid() == null)\n        {\n            setGrid(WireNetwork.newGrid());\n        }\n    }\n\n    /**\n     * Checks if a connection should be made\n     *\n     * @param direction - direction from this tile\n     * @param tile      - tile to check for connection\n     * @return true if a connection was made\n     */\n    private boolean checkForConnection(ForgeDirection direction, TileEntity tile)\n    {\n        if (tile instanceof ITileConnection && ((ITileConnection) tile).canConnect(this, ConnectionType.UE_POWER, direction))\n        {\n            //If wire check for network merges\n            if (tile instanceof TileWire)\n            {\n                if (((TileWire) tile).getGrid() != getGrid())\n                {\n                    WireNetworkManager.merge(((TileWire) tile).getGrid(), getGrid());\n                }\n            }\n            setWireConnection(direction, true);\n            return true;\n        }\n        else\n        {\n            setWireConnection(direction, false);\n        }\n        return false;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public IIcon getIcon()\n    {\n        return wireTexture;\n    }\n\n    @SideOnly(Side.CLIENT)\n    public void registerIcons(IIconRegister iconRegister)\n    {\n        wireTexture = iconRegister.registerIcon(BasicIndustry.PREFIX + \"copperWire\");\n    }\n\n    public boolean hasWireConnection(ForgeDirection direction)\n    {\n        return (wireConnections & (1 << direction.ordinal())) != 0;\n    }\n\n    public void setWireConnection(ForgeDirection direction, boolean hadConnection)\n    {\n        if (hadConnection)\n        {\n            wireConnections = (byte) (wireConnections | (1 << direction.ordinal()));\n        }\n        else\n        {\n            wireConnections = (byte) (wireConnections & ~(1 << direction.ordinal()));\n\n        }\n\n        if (!this.worldObj.isRemote)\n        {\n            sendDescPacket();\n        }\n\n        markDirty();\n        markRender();\n    }\n\n    @Override\n    public void read(ByteBuf data, EntityPlayer player, PacketType packet)\n    {\n        if (isClient())\n        {\n            String blockName = ByteBufUtils.readUTF8String(data);\n            this.casingMaterial = blockName.isEmpty() ? null : (Block) Block.blockRegistry.getObject(blockName);\n            this.casingMaterialMeta = data.readInt();\n            this.wireConnections = data.readByte();\n            markRender();\n        }\n    }\n\n    @Override\n    public PacketTile getDescPacket()\n    {\n        String blockName = \"\";\n        if (casingMaterial != null)\n        {\n            blockName = Block.blockRegistry.getNameForObject(casingMaterialMeta);\n            if (blockName == null)\n            {\n                blockName = \"\";\n            }\n        }\n        return new PacketTile(this, blockName, this.casingMaterialMeta, this.wireConnections);\n    }\n\n    @Override\n    public void setGrid(WireNetwork grid)\n    {\n        if (network != null)\n        {\n            network.remove(this);\n        }\n        network = grid;\n        if (network != null)\n        {\n            grid.add(this);\n        }\n    }\n\n    @Override\n    public WireNetwork getGrid()\n    {\n        return network;\n    }\n\n    @Override\n    public boolean canConnect(TileEntity tile, ConnectionType type, ForgeDirection from)\n    {\n        if (tile instanceof TileWire)\n        {\n            return ((TileWire) tile).casingMaterial == casingMaterial && ((TileWire) tile).casingMaterialMeta == casingMaterialMeta;\n        }\n        return type == ConnectionType.UE_POWER;\n    }\n\n    @Override\n    public boolean hasConnection(ConnectionType type, ForgeDirection side)\n    {\n        return (type == null || type == ConnectionType.UE_POWER) && hasWireConnection(side);\n    }\n}\n", "ukkit.Material;\nimport org.bukkit.configuration.file.FileConfiguration;\n\nimport au.com.mineauz.minigames.menu.MenuItem;\nimport au.com.mineauz.minigames.minigame.Minigame;\nimport au.com.mineauz.minigames.minigame.Team;\nimport au.com.mineauz.minigames.minigame.TeamColor;\n\npublic class TeamFlag extends Flag<Team> {\n\n    private final Minigame mgm;\n\n    public TeamFlag(Team value, String name, Minigame mgm) {\n        setFlag(value);\n        setDefaultFlag(value);\n        setName(name);\n        this.mgm = mgm;\n    }\n\n    @Override\n    public void saveValue(String path, FileConfiguration config) {\n        config.set(path + \".\" + getName() + \".displayName\", getFlag().getDisplayName());\n        if (!getFlag().getStartLocations().isEmpty()) {\n            for (int i = 0; i < getFlag().getStartLocations().size(); i++) {\n                LocationFlag locf = new LocationFlag(null, \"startpos.\" + i);\n                locf.setFlag(getFlag().getStartLocations().get(i));\n                locf.saveValue(path + \".\" + getName(), config);\n            }\n        }\n\n        for (Flag<?> flag : getFlag().getFlags()) {\n            if (flag.getDefaultFlag() != flag.getFlag()) {\n                flag.saveValue(path + \".\" + getName(), config);\n            }\n        }\n    }\n\n    @Override\n    public void loadValue(String path, FileConfiguration config) {\n        Team t = new Team(TeamColor.valueOf(getName()), mgm);\n        t.setDisplayName(config.getString(path + \".\" + getName() + \".displayName\"));\n        if (config.contains(path + \".\" + getName() + \".startpos\")) {\n            Set<String> locations = config.getConfigurationSection(path + \".\" + getName() + \".startpos\").getKeys(false);\n            for (String loc : locations) {\n                LocationFlag locf = new LocationFlag(null, \"startpos.\" + loc);\n                locf.loadValue(path + \".\" + getName(), config);\n                t.addStartLocation(locf.getFlag());\n            }\n        }\n\n        for (Flag<?> flag : t.getFlags()) {\n            if (config.contains(path + \".\" + getName() + \".\" + flag.getName())) {\n                flag.loadValue(path + \".\" + getName(), config);\n            }\n        }\n\n        setFlag(t);\n    }\n\n    @Override\n    public MenuItem getMenuItem(String name, Material displayItem) {\n        return null; //TODO: Menu Item\n    }\n\n    @Override\n    public MenuItem getMenuItem(String name, Material displayItem,\n                                List<String> description) {\n        return null;\n    }\n\n}\n", "ion, v2.2.8-b130911.1802 \n// See <a href=\"http://java.sun.com/xml/jaxb\">http://java.sun.com/xml/jaxb</a> \n// Any modifications to this file will be lost upon recompilation of the source schema. \n// Generated on: 2015.07.16 at 03:24:22 PM EEST \n//\n\n\npackage org.ecloudmanager.tmrk.cloudapi.model;\n\nimport javax.xml.bind.annotation.*;\n\n\n/**\n * <p>Java class for RoleReferenceType complex type.\n * \n * <p>The following schema fragment specifies the expected content contained within this class.\n * \n * <pre>\n * &lt;complexType name=\"RoleReferenceType\">\n *   &lt;complexContent>\n *     &lt;extension base=\"{}ReferenceType\">\n *       &lt;sequence>\n *         &lt;element name=\"RoleType\" type=\"{}RoleTypeEnum\" minOccurs=\"0\"/>\n *         &lt;element name=\"Active\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" minOccurs=\"0\"/>\n *         &lt;element name=\"Category\" type=\"{}RoleCategory\" minOccurs=\"0\"/>\n *         &lt;element name=\"IsAdminRole\" type=\"{http://www.w3.org/2001/XMLSchema}boolean\" minOccurs=\"0\"/>\n *       &lt;/sequence>\n *     &lt;/extension>\n *   &lt;/complexContent>\n * &lt;/complexType>\n * </pre>\n * \n * \n */\n@XmlAccessorType(XmlAccessType.FIELD)\n@XmlType(name = \"RoleReferenceType\", propOrder = {\n    \"roleType\",\n    \"active\",\n    \"category\",\n    \"isAdminRole\"\n})\npublic class RoleReferenceType\n    extends ReferenceType\n{\n\n    /**\n     *\n     */\n    private static final long serialVersionUID = 8645090447178306309L;\n    @XmlElement(name = \"RoleType\")\n    @XmlSchemaType(name = \"string\")\n    protected RoleTypeEnum roleType;\n    @XmlElement(name = \"Active\")\n    protected Boolean active;\n    @XmlElement(name = \"Category\")\n    @XmlSchemaType(name = \"string\")\n    protected RoleCategory category;\n    @XmlElement(name = \"IsAdminRole\")\n    protected Boolean isAdminRole;\n\n    /**\n     * Gets the value of the roleType property.\n     * \n     * @return\n     *     possible object is\n     *     {@link RoleTypeEnum }\n     *     \n     */\n    public RoleTypeEnum getRoleType() {\n        return roleType;\n    }\n\n    /**\n     * Sets the value of the roleType property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link RoleTypeEnum }\n     *     \n     */\n    public void setRoleType(RoleTypeEnum value) {\n        this.roleType = value;\n    }\n\n    /**\n     * Gets the value of the active property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean isActive() {\n        return active;\n    }\n\n    /**\n     * Sets the value of the active property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setActive(Boolean value) {\n        this.active = value;\n    }\n\n    /**\n     * Gets the value of the category property.\n     * \n     * @return\n     *     possible object is\n     *     {@link RoleCategory }\n     *     \n     */\n    public RoleCategory getCategory() {\n        return category;\n    }\n\n    /**\n     * Sets the value of the category property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link RoleCategory }\n     *     \n     */\n    public void setCategory(RoleCategory value) {\n        this.category = value;\n    }\n\n    /**\n     * Gets the value of the isAdminRole property.\n     * \n     * @return\n     *     possible object is\n     *     {@link Boolean }\n     *     \n     */\n    public Boolean isIsAdminRole() {\n        return isAdminRole;\n    }\n\n    /**\n     * Sets the value of the isAdminRole property.\n     * \n     * @param value\n     *     allowed object is\n     *     {@link Boolean }\n     *     \n     */\n    public void setIsAdminRole(Boolean value) {\n        this.isAdminRole = value;\n    }\n\n}\n", "incipal;\n\npublic class DynamoSessionExtension implements Serializable {\n    private Principal principal;\n    private String    authType;\n    private long      creationTime;\n    private int       maxInactiveInterval;\n    private long      accessedTime;\n\n    public Principal getPrincipal() {\n        return principal;\n    }\n\n    public void setPrincipal(Principal principal) {\n        this.principal = principal;\n    }\n\n    public String getAuthType() {\n        return authType;\n    }\n\n    public void setAuthType(String authType) {\n        this.authType = authType;\n    }\n\n    public long getCreationTime() {\n        return creationTime;\n    }\n\n    public void setCreationTime(long creationTime) {\n        this.creationTime = creationTime;\n    }\n\n    public int getMaxInactiveInterval() {\n        return maxInactiveInterval;\n    }\n\n    public void setMaxInactiveInterval(int maxInactiveInterval) {\n        this.maxInactiveInterval = maxInactiveInterval;\n    }\n\n    public long getAccessedTime() {\n        return accessedTime;\n    }\n\n    public void setAccessedTime(long accessedTime) {\n        this.accessedTime = accessedTime;\n    }\n}\n", "on layer of the OSM viewer. \n * The class <code>MapViewPane</code> gets its data from an\n * <code>OsmMap</code> object and visualizes it on a canvas. It also\n * reacts on keyboard and mouse events and provides a popup menu.\n * By default, it uses a platform independent\n * <code>DefaultEntityRenderer</code> to draw entities\n * but other renderers can be used as well. The default renderer does not\n * decide itself, which icon to use for a certain entity, or which color.\n * Instead, it assumes, that all entities have been classified before and\n * provide an attached <code>DefaultEntityViewInfo</code> object. For this\n * purpose, the OSM map must be equipped with an entity classifier.\n * The <code>MapViewFrame</code> demonstrates, how the viewer can be\n * embedded within a graphical application frame.</p>\n */\npackage aimax.osm.gui.swing.viewer;", "springframework.beans.propertyeditors.CustomDateEditor;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestParam;\nimport org.springframework.web.bind.annotation.ResponseBody;\n\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\n/**\n * Created by A on 2017/3/22.\n */\n@Controller\npublic class TestController {\n\n    private Logger logger = LoggerFactory.getLogger(getClass());\n\n    @RequestMapping(\"/test\")\n    @ResponseBody\n    public String test(@RequestParam Long id) {\n        logger.info(id.toString());\n        return \"\";\n    }\n\n\n    @InitBinder\n    public void initBinder(WebDataBinder binder) throws Exception {\n        //\u6ce8\u518c\u81ea\u5b9a\u4e49\u7684\u5c5e\u6027\u7f16\u8f91\u5668\n        //1\u3001\u65e5\u671f\n        DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\");\n        CustomDateEditor dateEditor = new CustomDateEditor(df, true);\n        //\u8868\u793a\u5982\u679c\u547d\u4ee4\u5bf9\u8c61\u6709Date\u7c7b\u578b\u7684\u5c5e\u6027\uff0c\u5c06\u4f7f\u7528\u8be5\u5c5e\u6027\u7f16\u8f91\u5668\u8fdb\u884c\u7c7b\u578b\u8f6c\u6362\n        binder.registerCustomEditor(Date.class, dateEditor);\n    }\n\n    @RequestMapping(\"/testDate\")\n    @ResponseBody\n    public String testDate(@RequestParam Date id) {\n        logger.info(id.toString());\n        return \"\";\n    }\n\n\n}\n", "ashMap;\r\nimport java.util.Map;\r\n\r\nimport javax.xml.bind.annotation.XmlElement;\r\n\r\nimport org.apache.commons.lang.StringUtils;\r\nimport org.apache.log4j.Logger;\r\n\r\npublic class CreateProductVariationUrlBuilder {\r\n\r\n\tprivate static final Logger logger = Logger\r\n\t\t\t.getLogger(CreateProductVariationUrlBuilder.class);\r\n\r\n\tpublic static final String URL = \"https://china-merchant.wish.com/api/v2/variant/add\";\r\n\r\n\tprivate CreateProductVariationParam param;\r\n\r\n\tpublic CreateProductVariationUrlBuilder(CreateProductVariationParam p) {\r\n\t\tthis.param = p;\r\n\t}\r\n\r\n\tpublic String build() {\r\n\t\tStringBuffer b = new StringBuffer();\r\n\t\tint i = 0;\r\n\t\tfor (Field f : CreateProductVariationParam.class.getDeclaredFields()) {\r\n\t\t\tf.setAccessible(true);\r\n\r\n\t\t\tXmlElement xe = f.getAnnotation(XmlElement.class);\r\n\t\t\tString name = xe.name();\r\n\t\t\tif (\"##default\".equals(name)) {\r\n\t\t\t\tname = f.getName();\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tObject value = f.get(param);\r\n\t\t\t\tif (i++ == 0) {\r\n\t\t\t\t\tb.append('?');\r\n\t\t\t\t} else {\r\n\t\t\t\t\tb.append('&');\r\n\t\t\t\t}\r\n\t\t\t\tb.append(name).append('=').append(null == value ? \"\" : value);\r\n\t\t\t} catch (IllegalArgumentException e) {\r\n\t\t\t\tlogger.warn(e);\r\n\t\t\t} catch (IllegalAccessException e) {\r\n\t\t\t\tlogger.warn(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn b.toString();\r\n\t}\r\n\r\n\tpublic Map<String, String> buildMap() {\r\n\t\tMap<String, String> map = new LinkedHashMap<String, String>();\r\n\t\tfor (Field f : CreateProductVariationParam.class.getDeclaredFields()) {\r\n\t\t\tf.setAccessible(true);\r\n\t\t\tXmlElement xe = f.getAnnotation(XmlElement.class);\r\n\t\t\tString name = xe.name();\r\n\t\t\tif (\"##default\".equals(name)) {\r\n\t\t\t\tname = f.getName();\r\n\t\t\t}\r\n\t\t\ttry {\r\n\t\t\t\tObject value = f.get(param);\r\n\t\t\t\tif (null != value) {\r\n\t\t\t\t\tString tmp = value.toString();\r\n\t\t\t\t\tif (StringUtils.isNotBlank(tmp)) {\r\n\t\t\t\t\t\tmap.put(name, tmp);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t} catch (IllegalArgumentException e) {\r\n\t\t\t\tlogger.warn(e);\r\n\t\t\t} catch (IllegalAccessException e) {\r\n\t\t\t\tlogger.warn(e);\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn map;\r\n\t}\r\n\r\n}\r\n", "t java.util.ArrayList;\r\nimport java.util.List;\r\n\r\nimport pamasich.pamautils.collections.Pair;\r\nimport pamasich.strategy.objects.Player;\r\nimport pamasich.strategy.objects.environment.Environment;\r\nimport pamasich.strategy.objects.environment.Forest;\r\nimport pamasich.strategy.objects.environment.Mountain;\r\nimport pamasich.strategy.objects.ground.Grass;\r\nimport pamasich.strategy.objects.ground.Ground;\r\nimport pamasich.strategy.objects.ground.Water;\r\nimport pamasich.strategy.objects.resources.Gold;\r\nimport pamasich.strategy.objects.resources.Resource;\r\nimport pamasich.strategy.objects.units.Archer;\r\nimport pamasich.strategy.objects.units.Scout;\r\nimport pamasich.strategy.objects.units.Unit;\r\n\r\npublic class TestMapBattle extends Map {\r\n\t\r\n\tprivate static int rows = 40;\r\n\tprivate static int columns = 50;\r\n\t\r\n\tprivate static int river_start = 15;\r\n\tprivate static int river_end = 35;\r\n\t\r\n\tpublic TestMapBattle() {\r\n\t\tsuper(new Dimension(columns, rows), new Grass(), initGround(), initEnvironment(), initResources(), initUnits(), new ArrayList<>(), true, \r\n\t\t\t\tinitRandomChanceListEnvironment(), true, initRandomChanceListResources());\r\n\t}\r\n\t\r\n\tprivate static List<Pair<Ground, Point>> initGround() {\r\n\t\tList<Pair<Ground, Point>> ground = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int x = river_start; x < river_end; x++) {\r\n\t\t\tfor (int y = 0; y < rows; y++) {\r\n\t\t\t\tground.add(new Pair<>(new Water(), new Point(x,y)));\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn ground;\r\n\t}\r\n\t\r\n\tprivate static List<Pair<Environment, Integer>> initRandomChanceListEnvironment() {\r\n\t\tList<Pair<Environment, Integer>> random_chance = new ArrayList<>();\r\n\t\t\r\n\t\trandom_chance.add(new Pair<>(new Mountain(), new Integer(10)));\r\n\t\trandom_chance.add(new Pair<>(new Forest(), new Integer(60)));\r\n\t\t\r\n\t\treturn random_chance;\r\n\t}\r\n\t\r\n\tprivate static List<Pair<Resource, Integer>> initRandomChanceListResources() {\r\n\t\tList<Pair<Resource, Integer>> random_chance = new ArrayList<>();\r\n\t\t\r\n\t\trandom_chance.add(new Pair<>(new Gold(), new Integer(2)));\r\n\t\t\r\n\t\treturn random_chance;\r\n\t}\r\n\t\r\n\tprivate static List<Pair<Environment, Point>> initEnvironment() {\r\n\t\tList<Pair<Environment, Point>> env = new ArrayList<>();\r\n\t\t\r\n\t\tfor (int x = 0; x < columns; x++) {\r\n\t\t\tfor (int y = 0; y < rows; y++) {\r\n\t\t\t\tif (x == 0 || x == columns-1 || y == 0 || y == rows-1) {\r\n\t\t\t\t\tenv.add(new Pair<>(new Mountain(true), new Point(x,y)));\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\t\r\n\t\treturn env;\r\n\t}\r\n\t\r\n\tprivate static List<Pair<Resource, Point>> initResources() {\r\n\t\tList<Pair<Resource, Point>> res = new ArrayList<>();\r\n\t\t\r\n\t\tres.add(new Pair<>(new Gold(), new Point(5,5)));\r\n\t\tres.add(new Pair<>(new Gold(), new Point(columns-5,rows-5)));\r\n\t\t\r\n\t\treturn res;\r\n\t}\r\n\t\r\n\tprivate static List<Pair<Unit, Point>> initUnits() {\r\n\t\tList<Pair<Unit, Point>> units = new ArrayList<>();\r\n\r\n\t\tunits.add(new Pair<>(new Scout(Player.getPlayer(1)), new Point(1,4)));\r\n\t\tunits.add(new Pair<>(new Archer(Player.getPlayer(1)), new Point(1,1)));\r\n\t\tunits.add(new Pair<>(new Scout(Player.getPlayer(2)), new Point(3,3)));\r\n\t\t\r\n\t\treturn units;\r\n\t}\r\n\t\r\n}\r\n", "ideoScanType {\n    @JsonProperty(\"progressive\") PROGRESSIVE,\n    @JsonProperty(\"interlaced\") INTERLACED,\n    @JsonProperty(\"unknown\") UNKNOWN;\n}\n", "y granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * \r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * \r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n */\r\npackage com.github.jguaneri.notifications;\r\n\r\nimport java.io.Serializable;\r\nimport java.util.List;\r\n\r\nimport javax.persistence.Basic;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.FetchType;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.ManyToMany;\r\nimport javax.persistence.OneToMany;\r\nimport javax.persistence.Table;\r\n\r\nimport org.hibernate.annotations.GenericGenerator;\r\n\r\n/**\r\n * @author Joseph Guaneri\r\n * @version 1.0\r\n * @since 1.0\r\n */\r\n@Entity\r\n@Table(name = \"client\")\r\npublic class Client implements Serializable {\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tprivate static final long serialVersionUID = 1L;\r\n\r\n\t@Id\r\n\t@GeneratedValue(generator = \"uuid\")\r\n\t@GenericGenerator(name = \"uuid\", strategy = \"uuid2\")\r\n\t@Column(name = \"id\")\r\n\tprivate String id;\r\n\r\n\t@Basic(fetch = FetchType.LAZY)\r\n\t@Column(name=\"subscription_id\")\r\n\tprivate String subscriptionId;\r\n\r\n\t@Basic(fetch = FetchType.LAZY)\r\n\t@Column(name=\"custom_client_id\")\r\n\tprivate String customClientId;\r\n\t\r\n\t@ManyToMany(fetch = FetchType.LAZY, mappedBy=\"subscribers\")\r\n\tprivate List<Channel> channels;\r\n\r\n\t@OneToMany(fetch = FetchType.LAZY, orphanRemoval = true, mappedBy = \"client\")\r\n\tprivate List<UserAcknowledgement> acknowledgements;\r\n\r\n\t/**\r\n\t * \r\n\t */\r\n\tpublic Client() {\r\n\t}\r\n\r\n\t/**\r\n\t * @return the id\r\n\t */\r\n\tpublic String getId() {\r\n\t\treturn id;\r\n\t}\r\n\r\n\t/**\r\n\t * @param id the id to set\r\n\t */\r\n\tpublic void setId(String id) {\r\n\t\tthis.id = id;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the subscriptionId\r\n\t */\r\n\tpublic String getSubscriptionId() {\r\n\t\treturn subscriptionId;\r\n\t}\r\n\r\n\t/**\r\n\t * @param subscriptionId the subscriptionId to set\r\n\t */\r\n\tpublic void setSubscriptionId(String subscriptionId) {\r\n\t\tthis.subscriptionId = subscriptionId;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the customClientId\r\n\t */\r\n\tpublic String getCustomClientId() {\r\n\t\treturn customClientId;\r\n\t}\r\n\r\n\t/**\r\n\t * @param customClientId the customClientId to set\r\n\t */\r\n\tpublic void setCustomClientId(String customClientId) {\r\n\t\tthis.customClientId = customClientId;\r\n\t}\r\n\r\n\t/**\r\n\t * @return the channels\r\n\t */\r\n\tpublic List<Channel> getChannels() {\r\n\t\treturn channels;\r\n\t}\r\n\r\n\t/**\r\n\t * @param channels the channels to set\r\n\t */\r\n\tpublic void setChannels(List<Channel> channels) {\r\n\t\tthis.channels = channels;\r\n\t}\r\n\r\n}\r\n", "s.*;\n\nimport java.lang.reflect.Constructor;\nimport java.util.Arrays;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport net.caustic.http.JavaNetResponseHeaders;\nimport net.caustic.http.ResponseHeaders;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameters;\n\n@RunWith(Parameterized.class)\npublic class ResponseHeadersTest {\n\t\n\tprivate final Constructor<ResponseHeaders> constructor;\n\t\n\tpublic ResponseHeadersTest(Class<ResponseHeaders> klass)\n\t\t\tthrows Exception {\n\t\tthis.constructor = klass.getConstructor(Map.class);\n\t}\n\t\n\t@Parameters\n\tpublic static Collection<Class<?>[]> implementations() {\n\t\treturn Arrays.asList(new Class<?>[][] {\n\t\t\t\t{ JavaNetResponseHeaders.class  }\n\t\t});\n\t}\n\t\n\t@Test\n\tpublic void testGetHeaderNamesIsZeroLengthOnEmpty() throws Exception {\n\t\tResponseHeaders empty = constructor.newInstance(Collections.emptyMap());\n\t\tassertEquals(0, empty.getHeaderNames().length);\n\t}\n\n\t@Test\n\tpublic void testGetHeaderValuesForNonexistentHeaderIsNull() throws Exception {\n\t\tResponseHeaders empty = constructor.newInstance(Collections.emptyMap());\n\t\tassertNull(empty.getHeaderValues(randomString()));\n\t}\n\n\t@Test\n\tpublic void testHeaderNames() throws Exception {\n\t\tString headerName = randomString();\n\t\tString headerValue = randomString();\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tmap.put(headerName, Arrays.asList(headerValue));\n\t\t\n\t\tResponseHeaders headers = constructor.newInstance(map);\n\t\t\n\t\tassertEquals(1, headers.getHeaderNames().length);\n\t\tassertEquals(headerName, headers.getHeaderNames()[0]);\n\t}\n\t\n\t@Test\n\tpublic void testHeaderGet() throws Exception {\n\t\tString headerName = randomString();\n\t\tString headerValue = randomString();\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tmap.put(headerName, Arrays.asList(headerValue));\n\t\t\n\t\tResponseHeaders headers = constructor.newInstance(map);\n\t\t\n\t\tassertEquals(1, headers.getHeaderValues(headerName).length);\n\t\tassertEquals(headerValue, headers.getHeaderValues(headerName)[0]);\n\t}\n\t\n\n\t@Test\n\tpublic void testHeaderGetMultiple() throws Exception {\n\t\tString headerName = randomString();\n\t\tString headerValue = randomString();\n\t\tString headerValue2 = randomString();\n\t\tMap<String, List<String>> map = new HashMap<String, List<String>>();\n\t\tmap.put(headerName, Arrays.asList(headerValue, headerValue2));\n\t\t\n\t\tResponseHeaders headers = constructor.newInstance(map);\n\t\t\n\t\tassertEquals(2, headers.getHeaderValues(headerName).length);\n\t\tassertEquals(headerValue, headers.getHeaderValues(headerName)[0]);\n\t\tassertEquals(headerValue2, headers.getHeaderValues(headerName)[1]);\n\t}\n}\n", "ort net.sf.esfinge.gamification.achievement.Achievement;\n\npublic class GameMemoryStorage extends Game {\n\n\tprivate Map<Object, Map<String, Achievement>> achievments = new HashMap<>();\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * net.sf.esfinge.gamification.mechanics.Game#addAchievement(java.lang.Object,\n\t * net.sf.esfinge.gamification.achievement.Achievement)\n\t */\n\t@Override\n\tpublic void insertAchievement(Object user, Achievement a) {\n\t\tif (!achievments.containsKey(user)) {\n\t\t\tachievments.put(user, new HashMap<String, Achievement>());\n\t\t}\n\t\tMap<String, Achievement> userAchiev = achievments.get(user);\n\t\tuserAchiev.put(a.getName(), a);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * net.sf.esfinge.gamification.mechanics.Game#removeAchievement(java.lang.Object\n\t * , net.sf.esfinge.gamification.achievement.Achievement)\n\t */\n\t@Override\n\tpublic void deleteAchievement(Object user, Achievement a) {\n\n\t\tif (!achievments.containsKey(user)) {\n\t\t\tachievments.put(user, new HashMap<String, Achievement>());\n\t\t}\n\t\tMap<String, Achievement> userAchiev = achievments.get(user);\n\t\tif (userAchiev.containsKey(a.getName())) {\n\t\t\tuserAchiev.remove(a.getName());\n\t\t}\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * net.sf.esfinge.gamification.mechanics.Game#getAchievement(java.lang.Object,\n\t * java.lang.String)\n\t */\n\t@Override\n\tpublic Achievement getAchievement(Object user, String achievName) {\n\t\tif (!achievments.containsKey(user)) {\n\t\t\tachievments.put(user, new HashMap<String, Achievement>());\n\t\t}\n\t\treturn achievments.get(user).get(achievName);\n\t}\n\n\t/*\n\t * (non-Javadoc)\n\t * \n\t * @see\n\t * net.sf.esfinge.gamification.mechanics.Game#getAchievements(java.lang.Object)\n\t */\n\t@Override\n\tpublic Map<String, Achievement> getAchievements(Object user) {\n\t\treturn achievments.get(user);\n\t}\n\n\t@Override\n\tpublic void updateAchievement(Object user, Achievement a) {\n\t\tinsertAchievement(user, a);\n\n\t}\n\n\t@Override\n\tpublic Map<String, Achievement> getAllAchievements(Class<? extends Achievement> type) {\n\n\t\tMap<String, Achievement> map = new HashMap<>();\n\n\t\tfor (Map.Entry<Object, Map<String, Achievement>> keys : achievments.entrySet()) {\n\t\t\tString key = (String) keys.getKey();\n\t\t\tMap<String, Achievement> userAchievement = achievments.get(key);\n\t\t\tfor (Achievement achievement : userAchievement.values()) {\n\t\t\t\tif (type.getTypeName() == achievement.getClass().getTypeName())\n\t\t\t\t\tmap.put(key, achievement);\n\t\t\t}\n\t\t}\n\n\t\treturn map;\n\t}\n\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\npackage org.openjdk.tests.java.util.stream;\n\nimport org.testng.annotations.Test;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.List;\nimport java.util.Optional;\nimport java.util.Spliterator;\nimport java.util.Spliterators;\nimport java.util.concurrent.ThreadLocalRandom;\nimport java.util.stream.*;\n\nimport static java.util.stream.LambdaTestHelpers.*;\n\n/**\n * DistinctOpTest\n */\n@Test\npublic class DistinctOpTest extends OpTestCase {\n\n    public void testUniqOp() {\n        assertCountSum(repeat(0, 10).stream().distinct(), 1, 0);\n        assertCountSum(repeat(1, 10).stream().distinct(), 1, 1);\n        assertCountSum(countTo(0).stream().distinct(), 0, 0);\n        assertCountSum(countTo(10).stream().distinct(), 10, 55);\n        assertCountSum(countTo(10).stream().distinct(), 10, 55);\n    }\n\n    public void testWithUnorderedInfiniteStream() {\n        // These tests should short-circuit, otherwise will fail with a time-out\n        // or an OOME\n\n        // Note that since the streams are unordered and any element is requested\n        // (a non-deterministic process) the only assertion that can be made is\n        // that an element should be found\n\n        Optional<Integer> oi = Stream.iterate(1, i -> i + 1).unordered().parallel().distinct().findAny();\n        assertTrue(oi.isPresent());\n\n        oi = ThreadLocalRandom.current().ints().boxed().parallel().distinct().findAny();\n        assertTrue(oi.isPresent());\n    }\n\n    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n    public void testOp(String name, TestData.OfRef<Integer> data) {\n        Collection<Integer> result = exerciseOpsInt(data, Stream::distinct, IntStream::distinct, LongStream::distinct, DoubleStream::distinct);\n\n        assertUnique(result);\n        assertTrue((data.size() > 0) ? result.size() > 0 : result.size() == 0);\n        assertTrue(result.size() <= data.size());\n    }\n\n    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n    public void testOpWithNull(String name, TestData.OfRef<Integer> data) {\n        Collection<Integer> node = exerciseOps(data, Stream::distinct);\n        assertUnique(node);\n\n        node = withData(data).\n                stream(s -> s.unordered().distinct()).\n                exercise();\n        assertUnique(node);\n\n        node = exerciseOps(data, s -> s.distinct().distinct());\n        assertUnique(node);\n    }\n\n    @Test(dataProvider = \"withNull:StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n    public void testOpWithNullSorted(String name, TestData.OfRef<Integer> data) {\n        List<Integer> l = new ArrayList<>();\n        data.into(l).sort(cNullInteger);\n        // Need to inject SORTED into the sorted list source since\n        // sorted() with a comparator ironically clears SORTED\n        Collection<Integer> node = exerciseOps(new SortedTestData<>(l), Stream::distinct);\n        assertUnique(node);\n        assertSorted(node, cNullInteger);\n    }\n\n    @SuppressWarnings(\"serial\")\n    static class SortedTestData<T> extends TestData.AbstractTestData.RefTestData<T, List<T>> {\n        SortedTestData(List<T> coll) {\n            super(\"SortedTestData\", coll,\n                  c -> StreamSupport.stream(Spliterators.spliterator(c.toArray(), Spliterator.ORDERED | Spliterator.SORTED), false),\n                  c -> StreamSupport.stream(Spliterators.spliterator(c.toArray(), Spliterator.ORDERED | Spliterator.SORTED), true),\n                  c -> Spliterators.spliterator(c.toArray(), Spliterator.ORDERED | Spliterator.SORTED),\n                  List::size);\n        }\n    }\n\n    public static final Comparator<Integer> cNullInteger = (a, b) -> {\n        if (a == null && b == null) {\n            return 0;\n        }\n        else if (a == null) {\n            return -1;\n        }\n        else if (b == null) {\n            return 1;\n        }\n        else {\n            return Integer.compare(a, b);\n        }\n    };\n\n    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n    public void testDistinctDistinct(String name, TestData.OfRef<Integer> data) {\n        Collection<Integer> result = withData(data)\n                .stream(s -> s.distinct().distinct(), new CollectorOps.TestParallelSizedOp<>())\n                .exercise();\n        assertUnique(result);\n    }\n\n    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n    public void testDistinctSorted(String name, TestData.OfRef<Integer> data) {\n        Collection<Integer> result = withData(data)\n                .stream(s -> s.distinct().sorted(),\n                        new CollectorOps.TestParallelSizedOp<>())\n                .exercise();\n        assertUnique(result);\n        assertSorted(result);\n    }\n\n    @Test(dataProvider = \"StreamTestData<Integer>\", dataProviderClass = StreamTestDataProvider.class)\n    public void testSortedDistinct(String name, TestData.OfRef<Integer> data) {\n        Collection<Integer> result = withData(data)\n                .stream(s -> s.sorted().distinct(),\n                        new CollectorOps.TestParallelSizedOp<>())\n                .exercise();\n        assertUnique(result);\n        assertSorted(result);\n    }\n}\n", "roid.gms.common.ConnectionResult;\nimport com.google.android.gms.common.api.GoogleApiClient;\nimport com.google.android.gms.wearable.MessageEvent;\nimport com.google.android.gms.wearable.Wearable;\nimport com.google.android.gms.wearable.WearableListenerService;\nimport com.mauriciotogneri.common.api.tpg.GetLinesColors;\nimport com.mauriciotogneri.common.api.tpg.GetNextDepartures;\nimport com.mauriciotogneri.common.api.tpg.GetThermometer;\nimport com.mauriciotogneri.common.api.tpg.Stop;\nimport com.mauriciotogneri.common.api.message.Message;\nimport com.mauriciotogneri.common.api.message.MessageApi.Messages;\nimport com.mauriciotogneri.common.api.message.MessageApi.Paths;\nimport com.mauriciotogneri.common.utils.EncodingHelper;\nimport com.mauriciotogneri.tpgwear.utils.Preferences;\nimport com.mauriciotogneri.tpgwear.api.TpgApi;\nimport com.mauriciotogneri.tpgwear.api.TpgApi.OnRequestResult;\n\nimport java.util.List;\nimport java.util.concurrent.TimeUnit;\n\npublic class WearableService extends WearableListenerService\n{\n    private static final int TIMEOUT = 1000 * 10; // in milliseconds\n\n    @Override\n    public void onMessageReceived(MessageEvent messageEvent)\n    {\n        String nodeId = messageEvent.getSourceNodeId();\n        String path = messageEvent.getPath();\n        String payload = EncodingHelper.getBytesAsString(messageEvent.getData());\n\n        if (TextUtils.equals(path, Paths.GET_FAVORITE_STOPS))\n        {\n            getFavoriteStops(nodeId);\n        }\n        else if (TextUtils.equals(path, Paths.GET_DEPARTURES))\n        {\n            getDepartures(nodeId, payload);\n        }\n        else if (TextUtils.equals(path, Paths.GET_TRIP))\n        {\n            getTrip(nodeId, payload);\n        }\n        else if (TextUtils.equals(path, Paths.INCREASE_STOP_HIT_COUNT))\n        {\n            increaseStopHitCount(payload);\n        }\n    }\n\n    private void getFavoriteStops(String nodeId)\n    {\n        Preferences preferences = Preferences.getInstance(this);\n        List<Stop> stops = preferences.getFavoriteStops();\n\n        reply(Messages.resultFavoriteStops(nodeId, stops));\n    }\n\n    private void getDepartures(final String nodeId, final String stopCode)\n    {\n        final TpgApi tpgApi = TpgApi.getInstance(this);\n\n        tpgApi.getLinesColors(new OnRequestResult<GetLinesColors>()\n        {\n            @Override\n            public void onSuccess(final GetLinesColors linesColors)\n            {\n                tpgApi.getNextDepartures(stopCode, new OnRequestResult<GetNextDepartures>()\n                {\n                    @Override\n                    public void onSuccess(GetNextDepartures nextDepartures)\n                    {\n                        nextDepartures.setColors(linesColors);\n                        nextDepartures.removeInvalidDepartures();\n\n                        reply(Messages.resultDepartures(nodeId, nextDepartures.departures));\n                    }\n\n                    @Override\n                    public void onFailure()\n                    {\n                    }\n                });\n            }\n\n            @Override\n            public void onFailure()\n            {\n            }\n        });\n    }\n\n    private void getTrip(final String nodeId, final String departureCode)\n    {\n        final TpgApi tpgApi = TpgApi.getInstance(this);\n\n        tpgApi.getThermometer(Integer.parseInt(departureCode), new OnRequestResult<GetThermometer>()\n        {\n            @Override\n            public void onSuccess(GetThermometer trip)\n            {\n                reply(Messages.resultTrip(nodeId, trip.steps));\n            }\n\n            @Override\n            public void onFailure()\n            {\n            }\n        });\n    }\n\n    private void increaseStopHitCount(String stopCode)\n    {\n        Preferences preferences = Preferences.getInstance(this);\n        preferences.increaseHitCount(stopCode);\n    }\n\n    private void reply(final Message message)\n    {\n        new Thread(new Runnable()\n        {\n            @Override\n            public void run()\n            {\n                GoogleApiClient client = new GoogleApiClient.Builder(WearableService.this).addApi(Wearable.API).build();\n                ConnectionResult connectionResult = client.blockingConnect(TIMEOUT, TimeUnit.MILLISECONDS);\n\n                if (connectionResult.isSuccess())\n                {\n                    Wearable.MessageApi.sendMessage(client, message.getNodeId(), message.getPath(), message.getPayloadAsBytes());\n                }\n\n                client.disconnect();\n            }\n        }).start();\n    }\n}", "dList;\nimport java.util.Queue;\n\npublic class Pipe implements Connector {\n\n    private final Queue<byte[]> queue;\n    private boolean pipeMessagePrepared;\n    private boolean closed;\n\n    public Pipe() {\n        this.queue = new LinkedList<>();\n    }\n\n    public boolean isPipeMessagePrepared() {\n        return pipeMessagePrepared;\n    }\n\n    public void setPipeMessagePrepared(boolean pipeMessagePrepared) {\n        this.pipeMessagePrepared = pipeMessagePrepared;\n    }\n\n    @Override\n    public void sendMessage(byte[] message) {\n        if (message != null) {\n            queue.add(message);\n        }\n    }\n\n    @Override\n    public byte[] readMessage() {\n        if (!queue.isEmpty()) {\n            return queue.remove();\n        }\n        return new byte[0];\n    }\n\n    public Queue<byte[]> getQueue() {\n        return queue;\n    }\n\n    public boolean isClosed() {\n        return closed;\n    }\n\n    public void setClosed(boolean closed) {\n        this.closed = closed;\n    }\n}\n", "y root for license details.\n */\n\npackage com.brightsparklabs.asanti.model.schema.constraint;\n\nimport com.brightsparklabs.asanti.model.data.RawAsnData;\nimport com.brightsparklabs.asanti.reader.AsnBerDataReader;\nimport com.brightsparklabs.asanti.schema.AsnPrimitiveType;\nimport com.brightsparklabs.asanti.validator.FailureType;\nimport com.brightsparklabs.asanti.validator.failure.SchemaConstraintValidationFailure;\nimport com.google.common.collect.ImmutableList;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.io.ByteSource;\nimport java.io.IOException;\n\n/** @author brightSPARK Labs */\npublic class AsnSchemaContainingConstraint extends AbstractAsnSchemaConstraint {\n    // -------------------------------------------------------------------------\n    // CONSTANTS\n    // -------------------------------------------------------------------------\n\n    // -------------------------------------------------------------------------\n    // CLASS VARIABLES\n    // -------------------------------------------------------------------------\n\n    // -------------------------------------------------------------------------\n    // INSTANCE VARIABLES\n    // -------------------------------------------------------------------------\n\n    private final String module;\n    private final String type;\n\n    // -------------------------------------------------------------------------\n    // CONSTRUCTION\n    // -------------------------------------------------------------------------\n\n    /**\n     * Default Constructor.\n     *\n     * @param module the module that the type id defined\n     * @param type the type that this is aliasing\n     */\n    public AsnSchemaContainingConstraint(final String module, final String type) {\n        this.module = module;\n        this.type = type;\n    }\n\n    // -------------------------------------------------------------------------\n    // PUBLIC METHODS\n    // -------------------------------------------------------------------------\n\n    @Override\n    protected ImmutableSet<SchemaConstraintValidationFailure> applyToNonNullBytes(\n            final byte[] bytes, final AsnPrimitiveType type) {\n        // This CONTAINING constraint means that we should be able to parse the bytes\n        // as valid ber/der.  The decode will try to do that.  The decode part will deal\n        // with alignment to schema, but this constraint should verify that the bytes are\n        // valid ber/der.\n        // It does mean we'll be doing that during decode, and verify, but oh well...\n\n        ImmutableSet.Builder<SchemaConstraintValidationFailure> builder = ImmutableSet.builder();\n\n        final ByteSource byteSource = ByteSource.wrap(bytes);\n        try {\n            final ImmutableList<RawAsnData> read = AsnBerDataReader.read(byteSource);\n            if (read.isEmpty()) {\n                builder.add(\n                        new SchemaConstraintValidationFailure(\n                                FailureType.DataIncorrectlyFormatted,\n                                \"Got no PDUs from aliased type, got \" + read.size()));\n            }\n        } catch (final IOException e) {\n            builder.add(\n                    new SchemaConstraintValidationFailure(\n                            FailureType.DataIncorrectlyFormatted,\n                            \"Failed to parse bytes of aliased type\"));\n        }\n        return builder.build();\n    }\n\n    /**\n     * Returns the module associated with the type this is aliasing\n     *\n     * @return the module associated with the type this is aliasing\n     */\n    public String getModule() {\n        return module;\n    }\n\n    /**\n     * Return the type this is aliasing\n     *\n     * @return the type this is aliasing\n     */\n    public String getType() {\n        return type;\n    }\n}\n", "t.games.security.spring.redirects.MobileAppChecker;\nimport org.springframework.security.config.annotation.web.builders.HttpSecurity;\nimport org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;\nimport org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter;\nimport org.springframework.security.web.util.matcher.AntPathRequestMatcher;\nimport org.springframework.security.web.util.matcher.RequestMatcher;\n\n/**\n * Date: 8/29/2015 Time: 2:44 PM\n *\n * Cut-n-paste of spring security class of same name to provide for overriding behaviour in\n * AbstractAuthenticationFilterConfigurer\n */\n@SuppressWarnings({\"WeakerAccess\", \"UnusedReturnValue\"})\npublic class MobileAwareFormLoginConfigurer extends AbstractAuthenticationFilterConfigurer {\n\n  public MobileAwareFormLoginConfigurer(MobileAppChecker mobileAppChecker) {\n    super(new UsernamePasswordAuthenticationFilter(), null, mobileAppChecker);\n    usernameParameter(\"username\");\n    passwordParameter(\"password\");\n  }\n\n  public MobileAwareFormLoginConfigurer loginPage(String loginPage) {\n    return super.loginPage(loginPage);\n  }\n\n  public MobileAwareFormLoginConfigurer usernameParameter(String usernameParameter) {\n    getAuthenticationFilter().setUsernameParameter(usernameParameter);\n    return this;\n  }\n\n  public MobileAwareFormLoginConfigurer passwordParameter(String passwordParameter) {\n    getAuthenticationFilter().setPasswordParameter(passwordParameter);\n    return this;\n  }\n\n  @Override\n  public void init(HttpSecurity http) throws Exception {\n    super.init(http);\n    initDefaultLoginFilter(http);\n  }\n\n  @Override\n  protected RequestMatcher createLoginProcessingUrlMatcher(String loginProcessingUrl) {\n    return new AntPathRequestMatcher(loginProcessingUrl, \"POST\");\n  }\n\n  private String getUsernameParameter() {\n    return getAuthenticationFilter().getUsernameParameter();\n  }\n\n  private String getPasswordParameter() {\n    return getAuthenticationFilter().getPasswordParameter();\n  }\n\n  private void initDefaultLoginFilter(HttpSecurity http) {\n    DefaultLoginPageGeneratingFilter loginPageGeneratingFilter = http\n        .getSharedObject(DefaultLoginPageGeneratingFilter.class);\n    if (loginPageGeneratingFilter != null && !isCustomLoginPage()) {\n      loginPageGeneratingFilter.setFormLoginEnabled(true);\n      loginPageGeneratingFilter.setUsernameParameter(getUsernameParameter());\n      loginPageGeneratingFilter.setPasswordParameter(getPasswordParameter());\n      loginPageGeneratingFilter.setLoginPageUrl(getLoginPage());\n      loginPageGeneratingFilter.setFailureUrl(getFailureUrl());\n      loginPageGeneratingFilter.setAuthenticationUrl(getLoginProcessingUrl());\n    }\n\n  }\n\n}\n", "ification<T> implements Specification<T> {\n\t\n\tpublic abstract boolean isSatisfiedBy(T t);\n\t\n\tpublic AbstractSpecification<T> or(Specification<T> s) {\n\t\treturn new OrSpecification<T>(this,s);\n\t}\n\n\tpublic AbstractSpecification<T> and(Specification<T> s) {\n\t\treturn new AndSpecification<T>(this,s);\n\t}\n\n\tpublic AbstractSpecification<T> not() {\n\t\treturn new NotSpecification<T>(this);\n\t}\n\n}\n", "tton;\nimport org.kordamp.ikonli.javafx.FontIcon;\n\npublic class ButtonWithIcon extends Button {\n    public ButtonWithIcon(@NamedArg(\"icon\") String iconLiteral) {\n        this(iconLiteral, 24);\n    }\n\n    public ButtonWithIcon(String iconLiteral, int iconSize) {\n        super();\n        var icon = new FontIcon(iconLiteral);\n        setGraphic(icon);\n        icon.setIconSize(iconSize);\n        icon.setIconLiteral(iconLiteral);\n    }\n}\n", "", "ense\n http://opensource.org/licenses/mit-license.php\n */\npackage org.deviceconnect.server;\n\nimport org.deviceconnect.server.http.HttpRequest;\nimport org.deviceconnect.server.http.HttpResponse;\n\n/**\n * DConnectServer\u304b\u3089\u306e\u30a4\u30d9\u30f3\u30c8\u3092\u53d7\u3051\u53d6\u308b\u70ba\u306e\u30ea\u30b9\u30ca\u30fc\u30a4\u30f3\u30bf\u30fc\u30d5\u30a7\u30fc\u30b9.\n * \n * @author NTT DOCOMO, INC.\n */\npublic interface DConnectServerEventListener {\n\n    /**\n     * Http\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u53d7\u4fe1\u6642\u306b\u547c\u3073\u51fa\u3055\u308c\u307e\u3059. <br/>\n     * Device Connect \u306e\u30ea\u30af\u30a8\u30b9\u30c8\u3068\u3057\u3066\u6b63\u3057\u304f\u306a\u3044\u306a\u3069\u306e\u7406\u7531\u3067\u30ea\u30af\u30a8\u30b9\u30c8\u306e\u53d7\u7406\u3092\u7834\u68c4\u3059\u308b\n     * \u5834\u5408\u306f\u3001\u623b\u308a\u5024\u3068\u3057\u3066false\u3092\u8fd4\u3059\u3053\u3068\u3067\u30b5\u30fc\u30d0\u30fc\u306b\u901a\u5e38\u306eHTTP\u30ea\u30af\u30a8\u30b9\u30c8\u3068\u3057\u3066\u51e6\u7406\u3055\u305b\u307e\u3059\u3002\n     * \n     * @param req Http\u30ea\u30af\u30a8\u30b9\u30c8\n     * @param res Http\u30ec\u30b9\u30dd\u30f3\u30b9\n     * @return \u30ea\u30af\u30a8\u30b9\u30c8\u3092\u53d7\u7406\u3059\u308b\u5834\u5408\u306ftrue\u3001\u30ea\u30af\u30a8\u30b9\u30c8\u3092\u7121\u8996\u3059\u308b\u5834\u5408\u306ffalse\u3092\u8fd4\u3059\n     */\n    boolean onReceivedHttpRequest(HttpRequest req, HttpResponse res);\n\n    /**\n     * \u30b5\u30fc\u30d0\u30fc\u3067\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u305f\u5834\u5408\u306b\u547c\u3073\u51fa\u3055\u308c\u307e\u3059.\n     * \n     * @param errorCode \u30a8\u30e9\u30fc\u7a2e\u985e\n     */\n    void onError(DConnectServerError errorCode);\n\n    /**\n     * \u30b5\u30fc\u30d0\u30fc\u304c\u8d77\u52d5\u3057\u305f\u6642\u306b\u547c\u3073\u51fa\u3055\u308c\u307e\u3059.\n     */\n    void onServerLaunched();\n\n}\n", "e BlockType {\n\n\tpublic boolean canContainFields();\n\n\tpublic boolean canContainMethods();\n\n\tpublic boolean isEnum();\n\n\tpublic boolean isInterface();\n}\n", "\u7236\u7c7b\n *\n * @author frank\n * @date 2017/9/10\n */\npublic class Subject {\n\n    private List<Observer> observers = new ArrayList<>();\n\n    public void register(Observer observer){\n        observers.add(observer);\n    }\n\n    public void unsubscribe(Observer observer){\n        observers.remove(observer);\n    }\n\n    public void informAll(){\n        for (Observer ob : observers){\n            ob.update(this);\n        }\n    }\n}\n", "park.*;\nimport spark.template.freemarker.FreeMarkerEngine;\n\nimport static spark.Spark.*;\n\n/**\n * @author michael.snowden\n */\npublic class Main {\n\n    public static void main(String[] args) {\n\n        port(Integer.valueOf(System.getenv(\"PORT\")));\n        staticFileLocation(\"/public\");\n\n        options(\"/*\", (request, response) -> {\n\n            String accessControlRequestHeaders = request.headers(\"Access-Control-Request-Headers\");\n            if (accessControlRequestHeaders != null) {\n                response.header(\"Access-Control-Allow-Headers\", accessControlRequestHeaders);\n            }\n\n            String accessControlRequestMethod = request.headers(\"Access-Control-Request-Method\");\n            if (accessControlRequestMethod != null) {\n                response.header(\"Access-Control-Allow-Methods\", accessControlRequestMethod);\n            }\n\n            return \"OK\";\n        });\n\n\n        before(new Filter() {\n            @Override\n            public void handle(Request request, Response response) throws Exception {\n                response.header(\"Access-Control-Allow-Origin\", \"*\");\n            }\n        });\n\n        get(\"/\", new TemplateViewRoute() {\n            @Override\n            public ModelAndView handle(Request request, Response response) {\n                return new ModelAndView(null, \"index.ftl\");\n            }\n        }, new FreeMarkerEngine());\n\n        get(\"/solve\", new Route() {\n            @Override\n            public Object handle(Request request, Response response) throws Exception {\n                String equation = request.queryParams(\"equation\");\n                if (equation != null) {\n                    return new EquationFactory().getBalancedEquation(new StringInputStream(equation)).asPlainText();\n                }\n                return \"\";\n            }\n        });\n\n        get(\"/solve-json\", new Route() {\n            @Override\n            public Object handle(Request request, Response response) throws Exception {\n                String equation = request.queryParams(\"equation\");\n                if (equation != null) {\n                    return new EquationFactory().getBalancedEquation(new StringInputStream(equation)).asPlainText();\n                }\n                return \"\";\n            }\n        });\n    }\n}\n\n", "gle.gwt.uibinder.client.UiBinder;\nimport com.google.gwt.user.client.ui.Composite;\nimport com.google.gwt.user.client.ui.Widget;\n\npublic class MainPageForm extends Composite {\n\n\tinterface MyUiBinder extends UiBinder<Widget, MainPageForm> {\n\t}\n\n\tprivate static MyUiBinder uiBinder = GWT.create(MyUiBinder.class);\n\n\tpublic MainPageForm() {\n\t\tinitWidget(uiBinder.createAndBindUi(this));\n\t}\n}\n", "     new Nota(2, 8),\n            new Nota(20, 5),\n            new Nota(32, 6),\n            new Nota(40, 0),\n        };\n        for (int i = 0;  i < note.length;  i++) {\n            for (int j = 0;  j < note.length;  j++) {\n                System.out.println(note[i].razmak(note[j]));\n            }\n        }\n    }\n}\n", "", "rtyChangeListener;\n\nimport javax.swing.JOptionPane;\nimport javax.swing.ProgressMonitor;\nimport javax.swing.SwingWorker;\n\nimport ui.MainFrame.UI;\n\nimport config.ConfFile;\nimport config.ObjectFile;\n\npublic class UIStatic implements PropertyChangeListener {\n\t\n\t// Container Class for UI components to be used by simulator\n\t\n\tpublic static MainFrame userFrame;\n\tpublic static ProgressMonitor progressMonitor;\n\tpublic static ConfFile configFile;\n\tpublic static ObjectFile worldLineFile;\n\tpublic static SwingWorker<Void, Void> simulation;\n\t\n\t@Override\n\tpublic void propertyChange(PropertyChangeEvent evt) {\n\t\tif (\"progress\" == evt.getPropertyName() ) {\n            int progress = (Integer) evt.getNewValue();\n            progressMonitor.setProgress(progress);\n            String message =\n                String.format(\"Completed %d%%.\\n\", progress);\n            progressMonitor.setNote(message);\n            if (progressMonitor.isCanceled() || simulation.isDone()) {\n                Toolkit.getDefaultToolkit().beep();\n                if (progressMonitor.isCanceled() || simulation.isCancelled()) {\n                    simulation.cancel(true);\n                    progressMonitor.close();\n                    JOptionPane.showMessageDialog(userFrame, \"World Line Generation Canceled\");\n                } else {\n                    JOptionPane.showMessageDialog(userFrame, \"World Line Generation Complete! Saved to: \" + worldLineFile.getAbsolutePath());\n                    progressMonitor.close();\n                }\n                userFrame.ResetFiles();\n    \t\t\tuserFrame.ChangeUI(UI.kGenerate);\n            }\n        }\n\t}\n\n}\n", "mport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.view.View.OnClickListener;\r\nimport android.widget.Button;\r\n\r\npublic class MainActivity extends Activity {\r\n\r\n\t//\u00b6\u00a8\u00d2\u00e5Button\u00b0\u00b4\u00c5\u00a5\u00b6\u00d4\u00cf\u00f3\r\n\tprivate Button btn1,btn2;\r\n\t\r\n\t@Override\r\n\tprotected void onCreate(Bundle savedInstanceState) {\r\n\t\tsuper.onCreate(savedInstanceState);\r\n\t\tsetContentView(R.layout.activity_main);\r\n\t\t\r\n\t\tinitView();\r\n\t}\r\n\r\n\t/**\r\n\t * \u00b3\u00f5\u00ca\u00bc\u00bb\u00af\u00d7\u00e9\u00bc\u00fe\r\n\t */\r\n\tprivate void initView(){\r\n\t\t//\u00ca\u00b5\u00c0\u00fd\u00bb\u00af\u00b0\u00b4\u00c5\u00a5\u00b6\u00d4\u00cf\u00f3\r\n\t\tbtn1 = (Button)findViewById(R.id.button1);\r\n\t\tbtn2 = (Button)findViewById(R.id.button2);\r\n\r\n\t\t//\u00c9\u00e8\u00d6\u00c3\u00bc\u00e0\u00cc\u00fd\u00a3\u00ac\u00bd\u00f8\u00c8\u00ebCustomTab\u00bd\u00e7\u00c3\u00e6\r\n\t\tbtn1.setOnClickListener(new OnClickListener() {\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(MainActivity.this,CustomTabActivity1.class));\r\n\t\t\t}\r\n\t\t});\r\n\t\t\r\n\t\t//\u00c9\u00e8\u00d6\u00c3\u00bc\u00e0\u00cc\u00fd\u00a3\u00ac\u00bd\u00f8\u00c8\u00ebRadioGroup\u00bd\u00e7\u00c3\u00e6\r\n\t\tbtn2.setOnClickListener(new OnClickListener() {\t\t\t\r\n\t\t\t@Override\r\n\t\t\tpublic void onClick(View v) {\r\n\t\t\t\tstartActivity(new Intent(MainActivity.this,CustomTabActivity2.class));\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n}\r\n", "tion.khronos.opengles.GL10;\n\nimport android.opengl.GLSurfaceView;\nimport android.opengl.GLU;\nimport android.opengl.GLSurfaceView.Renderer;\nimport android.view.MotionEvent;\n\npublic class Render implements Renderer {\n\n\t/** Triangle instance /\n\tprivate Triangle triangle;\n\t/** Square instance /\n\tprivate Square square;\n\t\n\t/** Pyramid instance */\n\tprivate Techo techo;\n\t/** Cube instance */\n\tprivate Casa casa;\n\tprivate Puerta puerta;\n\t\n\tprivate Hojas hojas;\n\tprivate Tronco tronco;\n\t\n\t\n\t/** Angle For The Pyramid */\n\tprivate float rtri; \t\n\t/** Angle For The Cube */\n\tprivate float rquad; \n\t\n\t/**\n\t * Instance the Triangle and Square objects\n\t */\n\tpublic Render() {\n\t\ttecho = new Techo();\n\t\tcasa = new Casa();\n\t\thojas = new Hojas();\n\t\ttronco = new Tronco();\n\t\tpuerta = new Puerta();\n\t}\n\t\n\t/**\n\t * The Surface is created/init()\n\t */\n\tpublic void onSurfaceCreated(GL10 gl, EGLConfig config) {\t\t\n\t\tgl.glShadeModel(GL10.GL_SMOOTH); \t\t\t//Enable Smooth Shading\n\t\tgl.glClearColor(0.0f, 0.0f, 0.0f, 0.5f); \t//Black Background\n\t\tgl.glClearDepthf(1.0f); \t\t\t\t\t//Depth Buffer Setup\n\t\tgl.glEnable(GL10.GL_DEPTH_TEST); \t\t\t//Enables Depth Testing\n\t\tgl.glDepthFunc(GL10.GL_LEQUAL); \t\t\t//The Type Of Depth Testing To Do\n\t\t\n\t\t//Really Nice Perspective Calculations\n\t\tgl.glHint(GL10.GL_PERSPECTIVE_CORRECTION_HINT, GL10.GL_NICEST); \n\t}\n\t\n\t/**\n\t * Here we do our drawing\n\t */\n\tpublic void onDrawFrame(GL10 gl) {\n\t\t//Clear Screen And Depth Buffer\n\t\tgl.glClear(GL10.GL_COLOR_BUFFER_BIT | GL10.GL_DEPTH_BUFFER_BIT);\t\n\t\tgl.glLoadIdentity();\t\t\t\t\t//Reset The Current Modelview Matrix\n\t\t\n\t\t/*\n\t\t * Minor changes to the original tutorial\n\t\t * \n\t\t * Instead of drawing our objects here,\n\t\t * we fire their own drawing methods on\n\t\t * the current instance\n\t\t */\n\t\tgl.glTranslatef(-2.0f, -1.2f, -10.0f);\t//Move down 1.2 Unit And Into The Screen 6.0\n\t\t//gl.glScalef(0.8f,0.8f,0.8f);\n\t\tgl.glRotatef(rquad, 1.0f, 1.0f, 0.0f);\n\t\tcasa.draw(gl);\t\t\t\t\t\t//Draw the square\n\t\t\t\t\n\t\t//Reset Modelview\n\t\t//gl.glLoadIdentity();\n\t\t//gl.glTranslatef(0.0f, 0.0f, 0.0f);\n\t\tpuerta.draw(gl);\n\t\t\n\t\t//Techo\n\t\tgl.glTranslatef(0.0f, 2.0f, 0.0f);//-2.0f, 0.8f, -10.0f);\t\t\n\t\t//gl.glRotatef(rtri, 0.0f, 1.0f, 0.0f);\n\t\ttecho.draw(gl);\t\t\t\t\t\t//Draw the triangle\t\n\t\t\n\t\t//Reset\n\t\tgl.glLoadIdentity();\n\t\t\n\t\t//Tronco\n\t\tgl.glTranslatef(2.0f, -1.2f, -10.0f);\n\t\t//gl.glRotatef(rquad, 1.0f, 1.0f, 0.0f);\n\t\ttronco.draw(gl);\t\t\n\t\t\n\t\t//Hojas\n\t\tgl.glTranslatef(0.0f, 2.0f, 0.0f);\n\t\thojas.draw(gl);\n\t\t\n\t\t\n\t\t\n\t\t\n\t\trtri +=0.5f;\n\t\trquad += 0.5f;\n\t}\t\n\t\n\t/**\n\t * If the surface changes, reset the view\n\t */\n\tpublic void onSurfaceChanged(GL10 gl, int width, int height) {\n\t\tif(height == 0) { \t\t\t\t\t\t//Prevent A Divide By Zero By\n\t\t\theight = 1; \t\t\t\t\t\t//Making Height Equal One\n\t\t}\n\n\t\tgl.glViewport(0, 0, width, height); \t//Reset The Current Viewport\n\t\tgl.glMatrixMode(GL10.GL_PROJECTION); \t//Select The Projection Matrix\n\t\tgl.glLoadIdentity(); \t\t\t\t\t//Reset The Projection Matrix\n\n\t\t//Calculate The Aspect Ratio Of The Window\n\t\tGLU.gluPerspective(gl, 45.0f, (float)width / (float)height, 0.1f, 100.0f);\n\n\t\tgl.glMatrixMode(GL10.GL_MODELVIEW); \t//Select The Modelview Matrix\n\t\tgl.glLoadIdentity(); \t\t\t\t\t//Reset The Modelview Matrix\n\t}\n\t\n\t/* ***** Listener Events ***** */\t\n\t/**\n\t * Override the touch screen listener.\n\t * \n\t * React to moves and presses on the touchscreen.\n\t */\n\tpublic boolean onTouchEvent(MotionEvent event) {\n\t\t//\n\t\tfloat x = event.getX();\n        float y = event.getY();\n        \n        //A press on the screen\n        if(event.getAction() == MotionEvent.ACTION_UP) {\n        \t//gl.glRotatef(rtri, 0.0f, 1.0f, 0.0f);\n    \t\t//techo.draw(gl);\t\n        }\n        \n        //We handled the event\n\t\treturn true;\n\t}\n\t\n\t\n\n}\n", "lic class JsonParser {\n\t\n\tprivate StringBuilder builder;\n\tprivate int inputIndex;\n\tprivate int inputLength;\n\tprivate String inputString;\n\t\n\t\n\t\n\tprivate static JsonException createParseError (final String message) {\n\t\treturn new JsonException(\"Parse error: \" + message);\n\t}\n\t\n\t\n\tprivate void expectCharacter (final char c) throws JsonException {\n\t\tfinal char n = nextCharacter();\n\t\tif (n != c) {\n\t\t\tthrow createParseError(\"Unexpected character at index \" + (inputIndex - 1) + \", expected '\" + c + \"'.\");\n\t\t}\n\t}\n\t\n\t\n\tprivate JsonArray internalParseArray() throws JsonException {\n\t\tskipWhitespaces();\n\t\t\n\t\tfinal JsonArray array = new JsonArray();\n\t\tarrayLoop: for (char c = peekCharacter(); ; c = peekCharacter()) {\n\t\t\tswitch (c) {\n\t\t\tcase ']':\n\t\t\t\t++inputIndex;\n\t\t\t\tbreak arrayLoop;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t{\n\t\t\t\tfinal Object value = internalParseValue();\n\t\t\t\tskipWhitespaces();\n\t\t\t\t\n\t\t\t\tc = peekCharacter();\n\t\t\t\tswitch (c) {\n\t\t\t\tcase ',':\n\t\t\t\t\t++inputIndex;\n\t\t\t\t\tskipWhitespaces();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase ']':\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow createParseError(\"Unexpected character at index \" + (inputIndex - 1) + \", expected ']' or ','.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tarray.add(value);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn array;\n\t}\n\t\n\t\n\tprivate Object internalParseNumber() throws JsonException {\n\t\tfinal int    inputIndex  = this.inputIndex;\n\t\tfinal int    inputLength = this.inputLength;\n\t\tfinal String inputString = this.inputString;\n\t\t\n\t\tboolean mustParseFloatingPoint = false;\n\t\t\n\t\tint i = inputIndex;\n\t\tnumberLoop: for (; i < inputLength; ++i) {\n\t\t\tfinal char c = inputString.charAt(i);\n\t\t\tswitch (c) {\n\t\t\tcase '0':\n\t\t\tcase '1':\n\t\t\tcase '2':\n\t\t\tcase '3':\n\t\t\tcase '4':\n\t\t\tcase '5':\n\t\t\tcase '6':\n\t\t\tcase '7':\n\t\t\tcase '8':\n\t\t\tcase '9':\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tcase '.':\n\t\t\tcase '+':\n\t\t\tcase '-':\n\t\t\tcase 'e':\n\t\t\tcase 'E':\n\t\t\t\tmustParseFloatingPoint = true;\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tbreak numberLoop;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.inputIndex = i;\n\t\t\n\t\tfinal int beginIndex = inputIndex - 1;\n\t\t\n\t\ttry {\n\t\t\tfinal String subString = inputString.substring(beginIndex, i);\n\t\t\t\n\t\t\tif (!mustParseFloatingPoint) {\n\t\t\t\ttry {\n\t\t\t\t\tfinal long value = Long.parseLong(subString);\n\t\t\t\t\tif (value >= Integer.MIN_VALUE && value <= Integer.MAX_VALUE) {\n\t\t\t\t\t\treturn Integer.valueOf((int)value);\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\treturn Long.valueOf(value);\n\t\t\t\t}\n\t\t\t\tcatch (final NumberFormatException e) {\n\t\t\t\t\t// will try Double.parseDouble...\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn Double.valueOf(subString);\n\t\t}\n\t\tcatch (final NumberFormatException e) {\n\t\t\tthrow createParseError(\"Invalid number syntax at index \" + beginIndex + \".\");\n\t\t}\n\t}\n\t\n\t\n\tprivate JsonObject internalParseObject() throws JsonException {\n\t\tskipWhitespaces();\n\t\t\n\t\tfinal JsonObject object = new JsonObject();\n\t\tobjectLoop: for (char c = nextCharacter(); ; c = nextCharacter()) {\n\t\t\tswitch (c) {\n\t\t\tcase '}':\n\t\t\t\tbreak objectLoop;\n\t\t\t\t\n\t\t\tcase '\"':\n\t\t\t{\n\t\t\t\tfinal String key = internalParseString();\n\t\t\t\tskipWhitespaces();\n\t\t\t\texpectCharacter(':');\n\t\t\t\tfinal Object value = internalParseValue();\n\t\t\t\tskipWhitespaces();\n\t\t\t\t\n\t\t\t\tc = peekCharacter();\n\t\t\t\tswitch (c) {\n\t\t\t\tcase ',':\n\t\t\t\t\t++inputIndex;\n\t\t\t\t\tskipWhitespaces();\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase '}':\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow createParseError(\"Unexpected character at index \" + (inputIndex - 1) + \", expected '}' or ','.\");\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (value != null) {\n\t\t\t\t\tobject.put(key, value);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tdefault:\n\t\t\t\tthrow createParseError(\"Unexpected character at index \" + (inputIndex - 1) + \", expected '}' or '\\\"'.\");\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn object;\n\t}\n\t\n\t\n\tprivate String internalParseString() throws JsonException {\n\t\tfinal int    inputIndex  = this.inputIndex;\n\t\tfinal int    inputLength = this.inputLength;\n\t\tfinal String inputString = this.inputString;\n\t\t\n\t\tint rawStringLength = 0;\n\t\t\n\t\tboolean escapes = false;\n\t\t\n\t\tchar c = 0;\n\t\tpreparationLoop: for (int i = inputIndex; i < inputLength; ++i) {\n\t\t\t++rawStringLength;\n\t\t\t\n\t\t\tc = inputString.charAt(i);\n\t\t\tswitch (c) {\n\t\t\tcase '\"':\n\t\t\t\tbreak preparationLoop;\n\t\t\t\t\n\t\t\tcase '\\\\':\n\t\t\t\tescapes = true;\n\t\t\t\t\n\t\t\t\t++rawStringLength;\n\t\t\t\t++i;\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (c != '\"') {\n\t\t\tthrow createParseError(\"Unterminated string value.\");\n\t\t}\n\t\t\n\t\tthis.inputIndex += rawStringLength;\n\t\t\n\t\tif (rawStringLength == 1) {\n\t\t\treturn \"\";\n\t\t}\n\t\t\n\t\tif (!escapes) {\n\t\t\treturn inputString.substring(inputIndex, inputIndex + rawStringLength - 1);\n\t\t}\n\t\t\n\t\tStringBuilder builder = this.builder;\n\t\tif (builder != null) {\n\t\t\tbuilder.setLength(0);\n\t\t\tbuilder.ensureCapacity(rawStringLength - 1);\n\t\t}\n\t\telse {\n\t\t\tbuilder = new StringBuilder(Math.max(rawStringLength - 1, 1024));\n\t\t\tthis.builder = builder;\n\t\t}\n\t\t\n\t\tstringLoop: for (int i = inputIndex; i < inputLength; ++i) {\n\t\t\tc = inputString.charAt(i);\n\t\t\tswitch (c) {\n\t\t\tcase '\"':\n\t\t\t\tbreak stringLoop;\n\t\t\t\t\n\t\t\tcase '\\\\':\n\t\t\t\t++i;\n\t\t\t\tc = inputString.charAt(i);\n\t\t\t\t\n\t\t\t\tswitch (c) {\n\t\t\t\tcase '\"':\n\t\t\t\tcase '\\\\':\n\t\t\t\tcase '/':\n\t\t\t\t\tbuilder.append(c);\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'b':\n\t\t\t\t\tbuilder.append('\\b');\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'f':\n\t\t\t\t\tbuilder.append('\\f');\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'n':\n\t\t\t\t\tbuilder.append('\\n');\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'r':\n\t\t\t\t\tbuilder.append('\\r');\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 't':\n\t\t\t\t\tbuilder.append('\\t');\n\t\t\t\t\tbreak;\n\t\t\t\t\t\n\t\t\t\tcase 'u': {\n\t\t\t\t\tfinal int beginIndex = i + 1;\n\t\t\t\t\tfinal int endIndex   = beginIndex + 4;\n\t\t\t\t\t\n\t\t\t\t\tif (endIndex > inputLength) {\n\t\t\t\t\t\tthrow createParseError(\"Unexpected end of input string.\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tfinal int characterCode;\n\t\t\t\t\ttry {\n\t\t\t\t\t\tcharacterCode = Integer.parseInt(inputString.substring(beginIndex, endIndex), 16);\n\t\t\t\t\t}\n\t\t\t\t\tcatch (final NumberFormatException e) {\n\t\t\t\t\t\tthrow createParseError(\"Invalid unicode escape sequence at index \" + i + \".\");\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tc = (char)characterCode;\n\t\t\t\t\ti += 4;\n\t\t\t\t\t\n\t\t\t\t\tbuilder.append(c);\n\t\t\t\t\t\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tdefault:\n\t\t\t\t\tthrow createParseError(\"Unknown escape sequence character '\" + c + \"' at index \" + i);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tbuilder.append(c);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn builder.toString();\n\t}\n\t\n\t\n\tprivate Object internalParseValue() throws JsonException {\n\t\tskipWhitespaces();\n\t\t\n\t\tfinal char c = nextCharacter();\n\t\tswitch (c) {\n\t\tcase '\"':\n\t\t\treturn internalParseString();\n\t\t\t\n\t\tcase '-':\n\t\tcase '0':\n\t\tcase '1':\n\t\tcase '2':\n\t\tcase '3':\n\t\tcase '4':\n\t\tcase '5':\n\t\tcase '6':\n\t\tcase '7':\n\t\tcase '8':\n\t\tcase '9':\n\t\t\treturn internalParseNumber();\n\t\t\t\n\t\tcase '{':\n\t\t\treturn internalParseObject();\n\t\t\t\n\t\tcase '[':\n\t\t\treturn internalParseArray();\n\t\t\t\n\t\tcase 't':\n\t\t\texpectCharacter('r');\n\t\t\texpectCharacter('u');\n\t\t\texpectCharacter('e');\n\t\t\treturn Boolean.TRUE;\n\t\t\t\n\t\tcase 'f':\n\t\t\texpectCharacter('a');\n\t\t\texpectCharacter('l');\n\t\t\texpectCharacter('s');\n\t\t\texpectCharacter('e');\n\t\t\treturn Boolean.FALSE;\n\t\t\t\n\t\tcase 'n':\n\t\t\texpectCharacter('u');\n\t\t\texpectCharacter('l');\n\t\t\texpectCharacter('l');\n\t\t\treturn null;\n\t\t}\n\t\t\n\t\tthrow createParseError(\"Unexpected character at index \" + (inputIndex - 1) + \".\");\n\t}\n\t\n\t\n\tprivate char nextCharacter() throws JsonException {\n\t\tfinal int index = inputIndex;\n\t\tif (index >= inputLength) {\n\t\t\tthrow createParseError(\"Unexpected end of input string.\");\n\t\t}\n\t\t\n\t\t++inputIndex;\n\t\t\n\t\treturn inputString.charAt(index);\n\t}\n\t\n\t\n\tpublic Object parse (final String string) throws JsonException {\n\t\tif (string == null) {\n\t\t\tthrow new IllegalArgumentException(\"'string' must not be null.\");\n\t\t}\n\n\t\tinputIndex = 0;\n\t\tinputLength = string.length();\n\t\tinputString = string;\n\t\t\n\t\tfinal Object object = internalParseValue();\n\t\tskipWhitespaces();\n\t\t\n\t\tif (inputIndex < inputLength) {\n\t\t\tthrow createParseError(\"Unexpected data beyond value at index \" + inputIndex + \".\");\n\t\t}\n\n\t\tbuilder = null;\n\t\tinputIndex = 0;\n\t\tinputLength = 0;\n\t\tinputString = null;\n\t\t\n\t\treturn object;\n\t}\n\t\n\t\n\tpublic JsonArray parseArray (final String string) throws JsonException {\n\t\tfinal Object object = parse(string);\n\t\tif (!(object instanceof JsonArray)) {\n\t\t\tthrow createParseError(\"Expected an array as root element.\");\n\t\t}\n\t\t\n\t\treturn (JsonArray)object;\n\t}\n\t\n\t\n\tpublic JsonObject parseObject (final String string) throws JsonException {\n\t\tfinal Object object = parse(string);\n\t\tif (!(object instanceof JsonObject)) {\n\t\t\tthrow createParseError(\"Expected an object as root element.\");\n\t\t}\n\t\t\n\t\treturn (JsonObject)object;\n\t}\n\t\n\t\n\tprivate char peekCharacter() throws JsonException {\n\t\tfinal int index = inputIndex;\n\t\tif (index >= inputLength) {\n\t\t\tthrow createParseError(\"Unexpected end of input string.\");\n\t\t}\n\t\t\n\t\treturn inputString.charAt(index);\n\t}\n\t\n\t\n\tprivate void skipWhitespaces() {\n\t\tfinal int    inputIndex  = this.inputIndex;\n\t\tfinal int    inputLength = this.inputLength;\n\t\tfinal String inputString = this.inputString;\n\t\t\n\t\tint i = inputIndex;\n\t\tinputLoop: for (; i < inputLength; ++i) {\n\t\t\tfinal char c = inputString.charAt(i);\n\t\t\tswitch (c) {\n\t\t\tcase ' ':\n\t\t\tcase '\\n':\n\t\t\tcase '\\r':\n\t\t\tcase '\\t':\n\t\t\tcase '\\u00A0':\n\t\t\tcase '\\uFEFF':\n\t\t\t\tbreak;\n\t\t\t\t\n\t\t\tdefault:\n\t\t\t\tif (!Character.isSpaceChar(c)) {\n\t\t\t\t\tbreak inputLoop;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tthis.inputIndex = i;\n\t}\n}\n", "erator;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\nenum PrevDir{\n  vert,\n  hor,\n  none\n}\n/**\n * Created by sundas on 7/7/2018.\n */\nclass PH{\n  int i;\n  int j;\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) return true;\n    if (o == null || getClass() != o.getClass()) return false;\n\n    PH ph = (PH) o;\n\n    if (getI() != ph.getI()) return false;\n    return getJ() == ph.getJ();\n\n  }\n\n  @Override\n  public int hashCode() {\n    int result = getI();\n    result = 31 * result + getJ();\n    return result;\n  }\n\n  @Override\n\n  public String toString() {\n    return \"PH{\" +\n        \"i=\" + i +\n        \", j=\" + j +\n        '}';\n  }\n\n  public int getI() {\n    return i;\n  }\n\n  public void setI(int i) {\n    this.i = i;\n  }\n\n  public int getJ() {\n    return j;\n  }\n\n  public void setJ(int j) {\n    this.j = j;\n  }\n}\npublic class FindPathInAGrid {\n\n  /*\n  . means allow\n  x means not allow\n  we can reach any point (x,y) if there\n  is a straight line without any X.\n  Calculate minimum steps.\n  In the example minsteps = 3\n\n  char[][] grid = new char[][]{\n        {'.','X','.'},\n        {'.','X','.'},\n        {'.','.','.'},\n    };\n\n   */\n\n  private static Set<PH> consideredIndex = new HashSet<>();\n\n  private static Set<PH> path = new LinkedHashSet<>();\n  /**\n   *\n   * @param grid\n   * @param a\n   * @param b\n   * @param c\n   * @param d\n   * @param i\n   * @param j\n   * @return\n   */\n  public static int minSteps(char[][] grid,int a,int b,\n                             int c,int d,\n  int i,int j){\n    PH ph = new PH();\n    ph.i = i;\n    ph.j = j;\n    if(consideredIndex.contains(ph)){\n      return Integer.MAX_VALUE;\n    }\n    if(i == c && j == d){\n      path.add(ph);\n      return 1;\n    }\n    if(i >= grid.length || j >= grid.length\n        || i < 0 || j < 0){\n      return Integer.MAX_VALUE;\n    }\n    if(grid[i][j] == 'X'){\n      return Integer.MAX_VALUE;\n    }\n    consideredIndex.add(ph);\n    int minSteps = Integer.MAX_VALUE;\n    int minStepsR = minSteps(grid, a, b, c, d, i, j + 1);\n    int minStepsD = minSteps(grid, a, b, c, d, i + 1, j);\n    int minStepsU = minSteps(grid,a,b,c,d,i - 1,j);\n    int minStepsL = minSteps(grid,a,b,c,d,i,j - 1);\n    minSteps = Math.min(Math.min(Math.min(minStepsR,minStepsD),\n        minStepsU),minStepsL) + 1;\n    path.add(ph);\n    return minSteps;\n  }\n\n  /**\n   *\n   * @param grid\n   * @param path\n   * @return\n   */\n  public static int\n  normalizeMinSteps(char[][] grid,Set<PH> path){\n    int normalizedSteps = path.size();\n    Iterator<PH> iterator = path.iterator();\n    int prevI = -1;\n    int prevJ = -1;\n    PrevDir dir = PrevDir.none;\n    while(iterator.hasNext()){\n      PH ph = iterator.next();\n      if(prevI >= 0 && prevJ >= 0){\n        PrevDir temp =  dir;\n        if(ph.i == prevI){\n          dir = PrevDir.hor;\n        }\n        if(ph.j == prevJ){\n          dir = PrevDir.vert;\n        }\n        if(temp != PrevDir.none && !dir.equals(temp)){\n          prevI = ph.i;\n          prevJ = ph.j;\n          continue;\n        }\n        if(ph.i != prevI\n            && ph.j == prevJ){\n          normalizedSteps--;\n        }\n        else if(ph.i == prevI\n            && ph.j != prevJ){\n          normalizedSteps--;\n        }\n      }\n      prevI = ph.i;\n      prevJ = ph.j;\n    }\n    return normalizedSteps;\n  }\n\n  /**\n   *\n   * @param args\n   */\n  public static void main(String[] args) {\n    char[][] grid = new char[][]{\n        {'.','X','.'},\n        {'.','X','.'},\n        {'.','.','.'},\n    };\n    System.out.println(minSteps(grid,0,0,0,2,0,0));\n    System.out.println(path);\n    System.out.println(normalizeMinSteps(grid,path));\n  }\n\n}\n", "Test;\n\nimport static org.junit.Assert.*;\n\npublic class SpringFactoryTest {\n\n    @Test\n    public void shouldGiveUsNewStepInstancesForEachScenario() {\n        final ObjectFactory factory = new SpringFactory();\n        factory.addClass(BellyStepdefs.class);\n\n        // Scenario 1\n        factory.createInstances();\n        final BellyStepdefs o1 = factory.getInstance(BellyStepdefs.class);\n        factory.disposeInstances();\n\n        // Scenario 2\n        factory.createInstances();\n        final BellyStepdefs o2 = factory.getInstance(BellyStepdefs.class);\n        factory.disposeInstances();\n\n        assertNotNull(o1);\n        assertNotNull(o2);\n        assertNotSame(o1, o2);\n    }\n\n    @Test\n    public void shouldNeverCreateNewApplicationBeanInstances() {\n        // Feature 1\n        final ObjectFactory factory1 = new SpringFactory();\n        factory1.createInstances();\n        final DummyComponent o1 = factory1.getInstance(DummyComponent.class);\n        factory1.disposeInstances();\n\n        // Feature 2\n        final ObjectFactory factory2 = new SpringFactory();\n        factory2.createInstances();\n        final DummyComponent o2 = factory2.getInstance(DummyComponent.class);\n        factory2.disposeInstances();\n\n        assertNotNull(o1);\n        assertNotNull(o2);\n        assertSame(o1, o2);\n    }\n\n    @Test\n    public void shouldRespectCommonAnnotationsInStepDefs() {\n        final ObjectFactory factory = new SpringFactory();\n        factory.addClass(WithSpringAnnotations.class);\n        factory.createInstances();\n        WithSpringAnnotations stepdef = factory.getInstance(WithSpringAnnotations.class);\n        factory.disposeInstances();\n\n        assertNotNull(stepdef);\n        assertTrue(stepdef.isAutowired());\n        assertTrue(stepdef.isPostConstructCalled());\n        assertTrue(stepdef.isPreDestroyCalled());\n    }\n\n    @Test\n    public void shouldRespectCustomPropertyPlaceholderConfigurer() {\n        final ObjectFactory factory = new SpringFactory();\n        factory.addClass(WithSpringAnnotations.class);\n        factory.createInstances();\n        WithSpringAnnotations stepdef = factory.getInstance(WithSpringAnnotations.class);\n        factory.disposeInstances();\n\n        assertEquals(\"property value\", stepdef.getProperty());\n    }\n}\n", ".gradle.api.Project;\nimport org.gradle.testfixtures.ProjectBuilder;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport static org.assertj.core.api.Assertions.assertThat;\n\n/**\n * @author Lars Grefer\n */\npublic class JSassBasePluginTest {\n\n    private Project project;\n\n    @Before\n    public void setUp() {\n        project = ProjectBuilder.builder().build();\n    }\n\n    @Test\n    public void testPrecisionConvention() throws Exception {\n        JSassBasePlugin basePlugin = project.getPlugins().apply(JSassBasePlugin.class);\n        SassCompile testSass = project.getTasks().create(\"testSass\", SassCompile.class);\n\n        assertThat(testSass.getPrecision()).isEqualTo(basePlugin.getExtension().getPrecision());\n    }\n\n    @Test\n    public void testPrecisionConvention_custom() throws Exception {\n        JSassBasePlugin basePlugin = project.getPlugins().apply(JSassBasePlugin.class);\n        SassCompile testSass = project.getTasks().create(\"testSass\", SassCompile.class);\n\n        basePlugin.getExtension().setPrecision(42);\n        assertThat(testSass.getPrecision()).isEqualTo(42);\n\n        basePlugin.getExtension().setPrecision(55);\n        assertThat(testSass.getPrecision()).isEqualTo(55);\n    }\n\n}", "erson obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage com.nexmo.client.voice.ncco;\n\nimport com.nexmo.client.voice.MachineDetection;\nimport org.junit.Test;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotSame;\n\npublic class ConnectActionTest {\n    @Test\n    public void testBuilderMultipleInstances() {\n        ConnectAction.Builder builder = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build());\n        assertNotSame(builder.build(), builder.build());\n    }\n\n    @Test\n    public void testAllFieldsWithPhoneEndpoint() {\n        PhoneEndpoint endpoint = PhoneEndpoint.builder(\"15554441234\").build();\n        ConnectAction connect = ConnectAction.builder(endpoint)\n                .from(\"15554449876\")\n                .eventType(EventType.SYNCHRONOUS)\n                .timeOut(3)\n                .limit(2)\n                .machineDetection(MachineDetection.CONTINUE)\n                .eventUrl(\"https://example.com\")\n                .eventMethod(EventMethod.POST)\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"from\\\":\\\"15554449876\\\",\\\"eventType\\\":\\\"synchronous\\\",\\\"limit\\\":2,\\\"machineDetection\\\":\\\"continue\\\",\\\"eventUrl\\\":[\\\"https://example.com\\\"],\\\"eventMethod\\\":\\\"POST\\\",\\\"action\\\":\\\"connect\\\",\\\"timeout\\\":3}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testAllFieldsWithWebSocketEndpoint() {\n        WebSocketEndpoint endpoint = WebSocketEndpoint.builder(\"wss://example.com\", \"content-type\").build();\n        ConnectAction connect = ConnectAction.builder(endpoint)\n                .from(\"15554449876\")\n                .eventType(EventType.SYNCHRONOUS)\n                .timeOut(3)\n                .limit(2)\n                .machineDetection(MachineDetection.CONTINUE)\n                .eventUrl(\"https://example.com\")\n                .eventMethod(EventMethod.POST)\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"uri\\\":\\\"wss://example.com\\\",\\\"type\\\":\\\"websocket\\\",\\\"content-type\\\":\\\"content-type\\\"}],\\\"from\\\":\\\"15554449876\\\",\\\"eventType\\\":\\\"synchronous\\\",\\\"limit\\\":2,\\\"machineDetection\\\":\\\"continue\\\",\\\"eventUrl\\\":[\\\"https://example.com\\\"],\\\"eventMethod\\\":\\\"POST\\\",\\\"action\\\":\\\"connect\\\",\\\"timeout\\\":3}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testAllFieldsWithSipEndpoint() {\n        SipEndpoint endpoint = SipEndpoint.builder(\"sip:test@sip.example.com\").build();\n        ConnectAction connect = ConnectAction.builder(endpoint)\n                .from(\"15554449876\")\n                .eventType(EventType.SYNCHRONOUS)\n                .timeOut(3)\n                .limit(2)\n                .machineDetection(MachineDetection.CONTINUE)\n                .eventUrl(\"https://example.com\")\n                .eventMethod(EventMethod.POST)\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"uri\\\":\\\"sip:test@sip.example.com\\\",\\\"type\\\":\\\"sip\\\"}],\\\"from\\\":\\\"15554449876\\\",\\\"eventType\\\":\\\"synchronous\\\",\\\"limit\\\":2,\\\"machineDetection\\\":\\\"continue\\\",\\\"eventUrl\\\":[\\\"https://example.com\\\"],\\\"eventMethod\\\":\\\"POST\\\",\\\"action\\\":\\\"connect\\\",\\\"timeout\\\":3}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testGetAction() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build()).build();\n        assertEquals(\"connect\", connect.getAction());\n    }\n\n    @Test\n    public void testDefaultWithPhone() {\n        PhoneEndpoint endpoint = PhoneEndpoint.builder(\"15554441234\").build();\n        ConnectAction connect = ConnectAction.builder(endpoint).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testDefaultWithWebSocket() {\n        WebSocketEndpoint endpoint = WebSocketEndpoint.builder(\"wss://example.com\", \"content-type\").build();\n        ConnectAction connect = ConnectAction.builder(endpoint).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"uri\\\":\\\"wss://example.com\\\",\\\"type\\\":\\\"websocket\\\",\\\"content-type\\\":\\\"content-type\\\"}],\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testDefaultWithWebSip() {\n        SipEndpoint endpoint = SipEndpoint.builder(\"sip:test@sip.example.com\").build();\n        ConnectAction connect = ConnectAction.builder(endpoint).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"uri\\\":\\\"sip:test@sip.example.com\\\",\\\"type\\\":\\\"sip\\\"}],\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testEndpointField() {\n        SipEndpoint initialEndpoint = SipEndpoint.builder(\"sip:test@sip.example.com\").build();\n        PhoneEndpoint newEndpoint = PhoneEndpoint.builder(\"15554441234\").build();\n\n        ConnectAction connect = ConnectAction.builder(initialEndpoint).endpoint(newEndpoint).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testFrom() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build())\n                .from(\"15554449876\")\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"from\\\":\\\"15554449876\\\",\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testEventType() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build())\n                .eventType(EventType.SYNCHRONOUS)\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"eventType\\\":\\\"synchronous\\\",\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testTimeOut() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build()).timeOut(5).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"action\\\":\\\"connect\\\",\\\"timeout\\\":5}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testLimit() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build()).limit(5).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"limit\\\":5,\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testMachineDetection() {\n        ConnectAction.Builder builder = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build());\n        ConnectAction connectContinue = builder.machineDetection(MachineDetection.CONTINUE).build();\n        ConnectAction connectHangup = builder.machineDetection(MachineDetection.CONTINUE).build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"machineDetection\\\":\\\"continue\\\",\\\"action\\\":\\\"connect\\\"},{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"machineDetection\\\":\\\"continue\\\",\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connectContinue, connectHangup).toJson());\n    }\n\n    @Test\n    public void testEventUrl() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build())\n                .eventUrl(\"https://example.org\")\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"eventUrl\\\":[\\\"https://example.org\\\"],\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n\n    @Test\n    public void testEventMethod() {\n        ConnectAction connect = ConnectAction.builder(PhoneEndpoint.builder(\"15554441234\").build())\n                .eventMethod(EventMethod.POST)\n                .build();\n\n        String expectedJson = \"[{\\\"endpoint\\\":[{\\\"number\\\":\\\"15554441234\\\",\\\"type\\\":\\\"phone\\\"}],\\\"eventMethod\\\":\\\"POST\\\",\\\"action\\\":\\\"connect\\\"}]\";\n        assertEquals(expectedJson, new Ncco(connect).toJson());\n    }\n}\n", "ion is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage se.jesjens.jesdob;\n\n/**\n * A IDob is a dynamic object, containing various kinds of data.\n * <p>\n * It is possible to add attributes to a dob, and to assign values to these attributes.\n * It is possible to read back the values for a specific attrbitutes.\n * <p>\n * IDobs can be exported to text as json-format, xml-format or dob-format. They can\n * then be saved to files and read as dynamic objects when they are needed.\n *\n * @author jenss\n */\npublic interface IDob {\n\n  /**\n   * Returns the value of a specific attribute.\n   *\n   * @param attribute The specific attribute.\n   * @return The value of the attribute.\n   */\n  public String attr(final String attribute);\n\n  /**\n   * Sets a specific attribute to a specific String value.\n   *\n   * @param attribute The specific attribute.\n   * @param value The specific String value.\n   * @return The dob object, to enable method chaining.\n   */\n  public IDob attr(final String attribute, final String value);\n\n  /**\n   * Sets a specific attribute to a specific boolean value.\n   *\n   * @param attribute The specific attribute.\n   * @param value The specific boolean value.\n   * @return The dob object, to enable method chaining.\n   */\n  public IDob attr(final String attribute, final boolean value);\n\n  /**\n   * Sets a specific attribute to a specific int value.\n   *\n   * @param attribute The specific attribute.\n   * @param value The specific int value.\n   * @return The dob object, to enable method chaining.\n   */\n  public IDob attr(final String attribute, final int value);\n\n  /**\n   * Sets a specific attribute to a specific float value.\n   *\n   * @param attribute The specific attribute.\n   * @param value The specific float value.\n   * @return The dob object, to enable method chaining.\n   */\n  public IDob attr(final String attribute, final float value);\n\n  /**\n   * Checks if a specific boolean attribute is true of false.\n   *\n   * @param attribute The specific attribute.\n   * @return If the attribute is true or false.\n   */\n  public boolean is(final String attribute);\n\n  /**\n   * Checks if the Dob object contains a specific attribute or not.\n   *\n   * @param attribute The specific attribute\n   * @return True or false, depending on if the attribute exists or not.\n   */\n  public boolean hasAttr(final String attribute);\n\n  /**\n   * Removes a specific attribute from the Dob.\n   *\n   * @param attribute The specific attribute.\n   * @return The dob object, to enable method chaining.\n   */\n  public IDob removeAttr(final String attribute);\n\n  /**\n   * Exports the Dob object data in json-format.\n   *\n   * @return The Dob object data in json-format.\n   */\n  public String toJson();\n\n  /**\n   * Exports the Dob object data in xml-format.\n   *\n   * @return The Dob object data in xml-format.\n   */\n  public String toXml();\n\n  /**\n   * Exports the Dob object data in dob-format.\n   *\n   * @return The Dob object data in dob-format.\n   */\n  public String toDob();\n}\n", "id.support.annotation.Nullable;\nimport android.support.v4.app.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\n/**\n * Created by huy on 1/15/2017.\n */\npublic class CropImageFragment extends Fragment {\n    @Nullable\n    @Override\n    public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, @Nullable Bundle savedInstanceState) {\n        return super.onCreateView(inflater, container, savedInstanceState);\n    }\n}\n", ".io.ByteArrayOutputStream;\nimport java.io.InputStreamReader;\nimport java.util.zip.GZIPInputStream;\nimport java.util.zip.GZIPOutputStream;\n\npublic class Gzip {\n\tpublic static byte[] compress(String str) throws Exception {\n\t\tByteArrayOutputStream obj = new ByteArrayOutputStream();\n\t\tGZIPOutputStream gzip = new GZIPOutputStream(obj);\n\n\t\tgzip.write(str.getBytes(\"UTF-8\"));\n\t\tgzip.close();\n\n\t\treturn obj.toByteArray();\n\t}\n\n\tpublic static String decompress(byte[] bytes) throws Exception {\n\t\tGZIPInputStream gis = new GZIPInputStream(new ByteArrayInputStream(bytes));\n\t\tBufferedReader bf = new BufferedReader(new InputStreamReader(gis, \"UTF-8\"));\n\t\tString outStr = \"\";\n\t\tString line;\n\n\t\twhile ((line = bf.readLine()) != null) {\n\t\t\toutStr += line;\n\t\t}\n\n\t\treturn outStr;\n\t}\n}\n", "eapon(Weapon weapon) {\n\t\tthis.weapon = weapon;\n\t}\n\t\n\tpublic void attack() {\n\t\tif (weapon == null) {\n\t\t\tweapon = new NoWeapon();\n\t\t}\n\t\tweapon.attack();\n\t}\n}\n", "#####. ######  ############   ############\n * #############  #####( ######  #####. ######  #############  #############\n *        ######  #####( ######  #####. ######  #####  ######  #####  ######\n * ###### ######  #####( ######  #####. ######  #####  #####   #####  ######\n * ###### ######  #####( ######  #####. ######  #####          #####  ######\n * #############  #############  #############  #############  #####  ######\n *  ############   ############  #############   ############  #####  ######\n *                                      ######\n *                               #############\n *                               ############\n *\n * Adyen Java API Library\n *\n * Copyright (c) 2021 Adyen B.V.\n * This file is open source and available under the MIT license.\n * See the LICENSE file for more info.\n */\npackage com.adyen.service;\n\nimport com.adyen.BaseTest;\nimport com.adyen.Client;\nimport com.adyen.model.Address;\nimport com.adyen.model.Amount;\nimport com.adyen.model.checkout.CreatePaymentLinkRequest;\nimport com.adyen.model.checkout.PaymentLinkResource;\nimport com.adyen.model.checkout.UpdatePaymentLinkRequest;\nimport com.adyen.service.exception.ApiException;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.Collections;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.fail;\n\npublic class PaymentLinksTest extends BaseTest {\n\n    @Test\n    public void TestCreatePaymentLinksSuccess() throws Exception {\n        Client client = createMockClientFromFile(\"mocks/paymentlinks/create-payment-links-success.json\");\n        PaymentLinks paymentLinks = new PaymentLinks(client);\n        CreatePaymentLinkRequest createPaymentLinkRequest = createPaymentLinkRequest();\n        PaymentLinkResource paymentLink = paymentLinks.create(createPaymentLinkRequest);\n        assertPaymentLinkResource(paymentLink, PaymentLinkResource.StatusEnum.ACTIVE);\n    }\n\n    @Test\n    public void TestCreatePaymentLinksErrorMerchantMissing() throws IOException {\n        Client client = createMockClientForErrors(403, \"mocks/paymentlinks/create-payment-links-error-merchant.json\");\n        PaymentLinks paymentLinks = new PaymentLinks(client);\n        CreatePaymentLinkRequest createPaymentLinkRequest = createPaymentLinkRequest();\n        try {\n            paymentLinks.create(createPaymentLinkRequest);\n            fail(\"Exception expected\");\n        } catch (ApiException e) {\n            assertNotNull(e.getError());\n            assertEquals(\"901\", e.getError().getErrorCode());\n            assertEquals(403, e.getError().getStatus());\n        }\n    }\n\n    @Test\n    public void TestCreatePaymentLinksErrorAmountMissing() throws IOException {\n        Client client = createMockClientForErrors(422, \"mocks/paymentlinks/create-payment-links-error-amount.json\");\n        PaymentLinks paymentLinks = new PaymentLinks(client);\n        CreatePaymentLinkRequest createPaymentLinkRequest = createPaymentLinkRequest();\n        try {\n            paymentLinks.create(createPaymentLinkRequest);\n            fail(\"Exception expected\");\n        } catch (ApiException e) {\n            assertNotNull(e.getError());\n            assertEquals(\"100\", e.getError().getErrorCode());\n            assertEquals(422, e.getError().getStatus());\n        }\n    }\n\n    @Test\n    public void TestCreatePaymentLinksErrorReferenceMissing() throws IOException {\n        Client client = createMockClientForErrors(422, \"mocks/paymentlinks/create-payment-links-error-reference.json\");\n        PaymentLinks paymentLinks = new PaymentLinks(client);\n        CreatePaymentLinkRequest createPaymentLinkRequest = createPaymentLinkRequest();\n        try {\n            paymentLinks.create(createPaymentLinkRequest);\n            fail(\"Exception expected\");\n        } catch (ApiException e) {\n            assertNotNull(e.getError());\n            assertEquals(\"130\", e.getError().getErrorCode());\n            assertEquals(422, e.getError().getStatus());\n        }\n    }\n\n    @Test\n    public void TestGetPaymentLink() throws IOException, ApiException {\n        Client client = createMockClientFromFile(\"mocks/paymentlinks/get-payment-link-success.json\");\n        PaymentLinks paymentLinks = new PaymentLinks(client);\n        PaymentLinkResource paymentLink = paymentLinks.retrieve(\"id\");\n        assertPaymentLinkResource(paymentLink, PaymentLinkResource.StatusEnum.ACTIVE);\n    }\n\n    @Test\n    public void TestUpdatePaymentLink() throws IOException, ApiException {\n        Client client = createMockClientFromFile(\"mocks/paymentlinks/update-payment-link-success.json\");\n        PaymentLinks paymentLinks = new PaymentLinks(client);\n        UpdatePaymentLinkRequest updatePaymentLinkRequest = new UpdatePaymentLinkRequest();\n        updatePaymentLinkRequest.setStatus(UpdatePaymentLinkRequest.StatusEnum.EXPIRED);\n        PaymentLinkResource paymentLink = paymentLinks.update(\"id\", updatePaymentLinkRequest);\n        assertPaymentLinkResource(paymentLink, PaymentLinkResource.StatusEnum.EXPIRED);\n    }\n\n    private void assertPaymentLinkResource(PaymentLinkResource paymentLink, PaymentLinkResource.StatusEnum status) {\n        assertNotNull(paymentLink);\n        assertNotNull(paymentLink.getId());\n        assertNotNull(paymentLink.getAmount());\n        assertNotNull(paymentLink.getCountryCode());\n        assertNotNull(paymentLink.getExpiresAt());\n        assertNotNull(paymentLink.getMerchantAccount());\n        assertNotNull(paymentLink.getReference());\n        assertNotNull(paymentLink.getShopperLocale());\n        assertNotNull(paymentLink.getShopperReference());\n        assertNotNull(status.getValue(), paymentLink.getStatus());\n        assertNotNull(paymentLink.getUrl());\n    }\n\n    /**\n     * Returns a sample PaymentsRequest opbject with test data\n     */\n    private CreatePaymentLinkRequest createPaymentLinkRequest() {\n        CreatePaymentLinkRequest createPaymentLinkRequest = new CreatePaymentLinkRequest();\n\n        createPaymentLinkRequest.setReference(\"YOUR_ORDER_NUMBER\");\n        createPaymentLinkRequest.setAmount(createAmountObject(\"BRL\", 1000L));\n        createPaymentLinkRequest.setCountryCode(\"BR\");\n        createPaymentLinkRequest.setMerchantAccount(\"MagentoMerchantTest\");\n        createPaymentLinkRequest.setShopperReference(\"YOUR_UNIQUE_SHOPPER_ID\");\n        createPaymentLinkRequest.setShopperEmail(\"test@email.com\");\n        createPaymentLinkRequest.setShopperLocale(\"pt_BR\");\n        createPaymentLinkRequest.setExpiresAt(\"2019-12-17T10:05:29Z\");\n        createPaymentLinkRequest.setRequiredShopperFields(Collections.singletonList(CreatePaymentLinkRequest.RequiredShopperFieldsEnum.DELIVERYADDRESS));\n        Address address = new Address();\n        address.setStreet(\"Street\");\n        address.setPostalCode(\"59000060\");\n        address.setCity(\"City\");\n        address.setHouseNumberOrName(\"999\");\n        address.setCountry(\"BR\");\n        address.setStateOrProvince(\"SP\");\n        createPaymentLinkRequest.setBillingAddress(address);\n        createPaymentLinkRequest.setDeliveryAddress(address);\n        createPaymentLinkRequest.setStorePaymentMethodMode(CreatePaymentLinkRequest.StorePaymentMethodModeEnum.DISABLED);\n\n        return createPaymentLinkRequest;\n    }\n\n    /**\n     * Returns a sample Amount opbject with given currency and value\n     */\n    private Amount createAmountObject(String currency, Long value) {\n        Amount amount = new Amount();\n        amount.setCurrency(currency);\n        amount.setValue(value);\n        return amount;\n    }\n}\n", "ruco.nucleo.resultado.Resultado;\n\npublic class Rodada {\n\n\tprivate final EstadoCiclos estadoCiclos;\n\n\tpublic Rodada(EstadoCiclos estadoCiclos) {\n\t\tthis.estadoCiclos = estadoCiclos;\n\t}\n\n\tpublic Resultado calcularResultado() {\n\t\tif (estadoCiclos.getQuantidadeCiclos() >= 2) {\n\t\t\tResultado resultadoCiclo0 = estadoCiclos.calcularResultadoDoCiclo(0);\n\t\t\tResultado resultadoCiclo1 = estadoCiclos.calcularResultadoDoCiclo(1);\n\n\t\t\tif (resultadoCiclo0.temVencedor() && resultadoCiclo0.equals(resultadoCiclo1)) return resultadoCiclo0;\n\n\t\t\tif (estadoCiclos.getQuantidadeCiclos() == 3) return estadoCiclos.calcularResultadoDoCiclo(2);\n\t\t}\n\n\t\treturn emAndamento();\n\t}\n\n}\n", "Exception;\nimport java.net.ServerSocket;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\n\n/**\n * The implementation of a ServerSocket handler. This is used by the Wi-Fi P2P group owner.\n */\npublic class OwnerSocketHandler extends Thread {\n\n    private ServerSocket serverSocket = null;\n    private final int THREAD_COUNT = 10;\n    private Handler handler;\n    private static final String TAG = WifiDirectHandler.TAG + \"OwnerSocketHandler\";\n\n    public OwnerSocketHandler(Handler handler) throws IOException {\n        try {\n            serverSocket = new ServerSocket(WifiDirectHandler.SERVER_PORT);\n            this.handler = handler;\n            Log.i(TAG, \"Group owner server socket started\");\n        } catch (IOException e) {\n            Log.e(TAG, \"Error starting server socket\");\n            Log.e(TAG, e.getMessage());\n            pool.shutdownNow();\n            throw e;\n        }\n    }\n\n    /**\n     * A ThreadPool for client sockets.\n     */\n    private final ThreadPoolExecutor pool = new ThreadPoolExecutor(\n            THREAD_COUNT, THREAD_COUNT, 10, TimeUnit.SECONDS,\n            new LinkedBlockingQueue<Runnable>());\n\n    @Override\n    public void run() {\n        Log.i(TAG, \"Group owner server socket thread running\");\n        while (true) {\n            try {\n                // A blocking operation. Initiate a CommunicationManager instance when\n                // there is a new connection\n                pool.execute(new CommunicationManager(serverSocket.accept(), handler));\n                Log.i(TAG, \"Launching the I/O handler\");\n            } catch (IOException e) {\n                Log.e(TAG, \"Error launching the I/O handler\");\n                Log.e(TAG, e.getMessage());\n                try {\n                    if (serverSocket != null && !serverSocket.isClosed()) {\n                        serverSocket.close();\n                        Log.i(TAG, \"Server socket closed\");\n                    }\n                } catch (IOException ioe) {\n                    Log.e(TAG, \"Error closing socket\");\n                    Log.e(TAG, ioe.getMessage());\n                }\n                pool.shutdownNow();\n                break;\n            }\n        }\n    }\n}\n", "kage com.microsoft.azure.spring.integration.test.support.rx;\n\nimport com.microsoft.azure.spring.integration.core.api.CheckpointConfig;\nimport com.microsoft.azure.spring.integration.core.api.RxSendOperation;\nimport com.microsoft.azure.spring.integration.core.api.RxSubscribeByGroupOperation;\nimport org.springframework.messaging.Message;\nimport rx.Observable;\n\npublic abstract class RxSendSubscribeByGroupOperationTest<T extends RxSendOperation & RxSubscribeByGroupOperation>\n    extends RxSendSubscribeOperationTest<T> {\n    protected String consumerGroup = \"group1\";\n\n    @Override\n    protected Observable<Message<?>> subscribe(String destination, Class<?> payloadType) {\n        return sendSubscribeOperation.subscribe(destination, consumerGroup, payloadType);\n    }\n\n    @Override\n    protected void setCheckpointConfig(CheckpointConfig checkpointConfig) {\n        sendSubscribeOperation.setCheckpointConfig(checkpointConfig);\n    }\n}\n", "e of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to  deal in  the Software without  restriction, including\n * without limitation  the rights to  use, copy, modify,  merge, publish,\n * distribute,  sublicense, and/or sell  copies of  the Software,  and to\n * permit persons to whom the Software  is furnished to do so, subject to\n * the following conditions:\n *\n * The  above  copyright  notice  and  this permission  notice  shall  be\n * included in all copies or substantial portions of the Software.\n *\n * THE  SOFTWARE IS  PROVIDED  \"AS  IS\", WITHOUT  WARRANTY  OF ANY  KIND,\n * EXPRESS OR  IMPLIED, INCLUDING  BUT NOT LIMITED  TO THE  WARRANTIES OF\n * MERCHANTABILITY,    FITNESS    FOR    A   PARTICULAR    PURPOSE    AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE,  ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n *\n */\npackage org.slf4j.impl;\n\nimport com.stata.sfi.SFIToolkit;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.PrintWriter;\nimport java.io.StringWriter;\nimport java.security.AccessController;\nimport java.security.PrivilegedAction;\nimport java.text.DateFormat;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Properties;\nimport org.slf4j.Logger;\nimport org.slf4j.event.LoggingEvent;\nimport org.slf4j.helpers.FormattingTuple;\nimport org.slf4j.helpers.MarkerIgnoringBase;\nimport org.slf4j.helpers.MessageFormatter;\nimport org.slf4j.helpers.Util;\nimport org.slf4j.spi.LocationAwareLogger;\n\n/**\n * <p>Simple implementation of {@link Logger} that sends all enabled log messages,\n * for all defined loggers, to the Stata results window.\n * The following system properties are supported to configure the behavior of this logger:</p>\n *\n * <ul>\n * <li><code>org.slf4j.stataLogger.defaultLogLevel</code> - Default log level for all instances of StataLogger.\n * Must be one of (\"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\"). If not specified, defaults to \"info\". </li>\n *\n * <li><code>org.slf4j.stataLogger.log.<em>a.b.c</em></code> - Logging detail level for a StataLogger instance\n * named \"a.b.c\". Right-side value must be one of \"trace\", \"debug\", \"info\", \"warn\", \"error\" or \"off\". When a StataLogger\n * named \"a.b.c\" is initialized, its level is assigned from this property. If unspecified, the level of nearest parent\n * logger will be used, and if none is set, then the value specified by\n * <code>org.slf4j.stataLogger.defaultLogLevel</code> will be used.</li>\n *\n * <li><code>org.slf4j.stataLogger.showDateTime</code> - Set to <code>true</code> if you want the current date and\n * time to be included in output messages. Default is <code>false</code></li>\n *\n * <li><code>org.slf4j.stataLogger.dateTimeFormat</code> - The date and time format to be used in the output messages.\n * The pattern describing the date and time format is defined by\n * <a href=\"http://docs.oracle.com/javase/1.5.0/docs/api/java/text/SimpleDateFormat.html\"><code>SimpleDateFormat</code></a>.\n * If the format is not specified or is invalid, the number of milliseconds since start up will be output. </li>\n *\n * <li><code>org.slf4j.stataLogger.showThreadName</code> -Set to <code>true</code> if you want to output the current\n * thread name. Defaults to <code>false</code>.</li>\n *\n * <li><code>org.slf4j.stataLogger.showLogName</code> - Set to <code>true</code> if you want the Logger instance name\n * to be included in output messages. Defaults to <code>true</code>.</li>\n *\n * <li><code>org.slf4j.stataLogger.showShortLogName</code> - Set to <code>true</code> if you want the last component\n * of the name to be included in output messages. Defaults to <code>false</code>.</li>\n *\n * <li><code>org.slf4j.stataLogger.levelInBrackets</code> - Should the level string be output in brackets? Defaults\n * to <code>true</code>.</li>\n *\n * <li><code>org.slf4j.stataLogger.warnLevelString</code> - The string value output for the warn level. Defaults\n * to <code>WARN</code>.</li>\n\n * </ul>\n *\n * <p>In addition to looking for system properties with the names specified above, this implementation also checks for\n * a class loader resource named <code>\"statalogger.properties\"</code>, and includes any matching definitions\n * from this resource (if it exists).</p>\n *\n * <p>With no configuration, the default output includes the level, logger name, and the\n * message followed by the line separator for the host.  In log4j terms it amounts to the\n * \"[%level] %logger - %m%n\" pattern. </p>\n * <p>Sample output follows.</p>\n * <pre>\n * [INFO] examples.Sort - Populating an array of 2 elements in reverse order.\n * [INFO] examples.SortAlgo - Entered the sort method.\n * [INFO] examples.SortAlgo - Dump of integer array:\n * [INFO] examples.SortAlgo - Element [0] = 0\n * [INFO] examples.SortAlgo - Element [1] = 1\n * [INFO] examples.Sort - The next log statement should be an error message.\n * [ERROR] examples.SortAlgo - Tried to dump an uninitialized array.\n *   at org.log4j.examples.SortAlgo.dump(SortAlgo.java:58)\n *   at org.log4j.examples.Sort.main(Sort.java:64)\n * [INFO] examples.Sort - Exiting main method.\n * </pre>\n *\n * <p>This implementation is based on\n * <a href=\"https://www.slf4j.org/api/org/slf4j/impl/SimpleLogger.html\">SLF4J's SimpleLogger</a>,\n * which is itself heavily inspired by\n * <a href=\"http://commons.apache.org/logging/\">Apache Commons Logging</a>'s SimpleLog.</p>\n *\n * @author Ceki G&uuml;lc&uuml;\n * @author <a href=\"mailto:sanders@apache.org\">Scott Sanders</a>\n * @author Rod Waldhoff\n * @author Robert Burrell Donkin\n * @author C&eacute;drik LIME\n * @author Diogo Pereira\n */\npublic class StataLogger extends MarkerIgnoringBase {\n\n    private static final long serialVersionUID = -632788891211436180L;\n    private static final String CONFIGURATION_FILE = \"statalogger.properties\";\n\n    private static long START_TIME = System.currentTimeMillis();\n    private static final Properties STATA_LOGGER_PROPS = new Properties();\n\n    private static final int LOG_LEVEL_TRACE = LocationAwareLogger.TRACE_INT;\n    private static final int LOG_LEVEL_DEBUG = LocationAwareLogger.DEBUG_INT;\n    private static final int LOG_LEVEL_INFO = LocationAwareLogger.INFO_INT;\n    private static final int LOG_LEVEL_WARN = LocationAwareLogger.WARN_INT;\n    private static final int LOG_LEVEL_ERROR = LocationAwareLogger.ERROR_INT;\n    // The OFF level can only be used in configuration files to disable logging. It has\n    // no printing method associated with it in o.s.Logger interface.\n    private static final int LOG_LEVEL_OFF = LOG_LEVEL_ERROR + 10;\n\n    private static boolean INITIALIZED = false;\n\n    private static int DEFAULT_LOG_LEVEL = LOG_LEVEL_INFO;\n    private static boolean SHOW_DATE_TIME = false;\n    private static String DATE_TIME_FORMAT_STR = null;\n    private static DateFormat DATE_FORMATTER = null;\n    private static boolean SHOW_THREAD_NAME = false;\n    private static boolean SHOW_LOG_NAME = true;\n    private static boolean SHOW_SHORT_LOG_NAME = false;\n    private static boolean LEVEL_IN_BRACKETS = true;\n    private static String WARN_LEVEL_STRING = \"WARN\";\n\n    /** All system properties used by <code>StataLogger</code> start with this prefix */\n    public static final String SYSTEM_PREFIX = \"org.slf4j.stataLogger.\";\n\n    public static final String DEFAULT_LOG_LEVEL_KEY = SYSTEM_PREFIX + \"defaultLogLevel\";\n    public static final String SHOW_DATE_TIME_KEY = SYSTEM_PREFIX + \"showDateTime\";\n    public static final String DATE_TIME_FORMAT_KEY = SYSTEM_PREFIX + \"dateTimeFormat\";\n    public static final String SHOW_THREAD_NAME_KEY = SYSTEM_PREFIX + \"showThreadName\";\n    public static final String SHOW_LOG_NAME_KEY = SYSTEM_PREFIX + \"showLogName\";\n    public static final String SHOW_SHORT_LOG_NAME_KEY = SYSTEM_PREFIX + \"showShortLogName\";\n    public static final String LEVEL_IN_BRACKETS_KEY = SYSTEM_PREFIX + \"levelInBrackets\";\n    public static final String WARN_LEVEL_STRING_KEY = SYSTEM_PREFIX + \"warnLevelString\";\n\n    public static final String LOG_KEY_PREFIX = SYSTEM_PREFIX + \"log.\";\n\n    private static String getStringProperty(String name) {\n        String prop = null;\n        try {\n            prop = System.getProperty(name);\n        } catch (SecurityException e) {\n            ; // Ignore\n        }\n        return (prop == null) ? STATA_LOGGER_PROPS.getProperty(name) : prop;\n    }\n\n    private static String getStringProperty(String name, String defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : prop;\n    }\n\n    private static boolean getBooleanProperty(String name, boolean defaultValue) {\n        String prop = getStringProperty(name);\n        return (prop == null) ? defaultValue : \"true\".equalsIgnoreCase(prop);\n    }\n\n    static void lazyInit() {\n        if (INITIALIZED) {\n            return;\n        }\n        INITIALIZED = true;\n        init();\n    }\n\n    static void init() {\n        loadProperties();\n\n        String defaultLogLevelString = getStringProperty(DEFAULT_LOG_LEVEL_KEY, null);\n        if (defaultLogLevelString != null)\n            DEFAULT_LOG_LEVEL = stringToLevel(defaultLogLevelString);\n\n        SHOW_LOG_NAME = getBooleanProperty(SHOW_LOG_NAME_KEY, SHOW_LOG_NAME);\n        SHOW_SHORT_LOG_NAME = getBooleanProperty(SHOW_SHORT_LOG_NAME_KEY, SHOW_SHORT_LOG_NAME);\n        SHOW_DATE_TIME = getBooleanProperty(SHOW_DATE_TIME_KEY, SHOW_DATE_TIME);\n        SHOW_THREAD_NAME = getBooleanProperty(SHOW_THREAD_NAME_KEY, SHOW_THREAD_NAME);\n        DATE_TIME_FORMAT_STR = getStringProperty(DATE_TIME_FORMAT_KEY, DATE_TIME_FORMAT_STR);\n        LEVEL_IN_BRACKETS = getBooleanProperty(LEVEL_IN_BRACKETS_KEY, LEVEL_IN_BRACKETS);\n        WARN_LEVEL_STRING = getStringProperty(WARN_LEVEL_STRING_KEY, WARN_LEVEL_STRING);\n\n        if (DATE_TIME_FORMAT_STR != null) {\n            try {\n                DATE_FORMATTER = new SimpleDateFormat(DATE_TIME_FORMAT_STR);\n            } catch (IllegalArgumentException e) {\n                Util.report(\"Bad date format in \" + CONFIGURATION_FILE + \"; will output relative time\", e);\n            }\n        }\n    }\n\n    private static void loadProperties() {\n        // Add props from the resource statalogger.properties\n        InputStream in = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {\n            public InputStream run() {\n                ClassLoader threadCL = Thread.currentThread().getContextClassLoader();\n                if (threadCL != null) {\n                    return threadCL.getResourceAsStream(CONFIGURATION_FILE);\n                } else {\n                    return ClassLoader.getSystemResourceAsStream(CONFIGURATION_FILE);\n                }\n            }\n        });\n        if (null != in) {\n            try {\n                STATA_LOGGER_PROPS.load(in);\n            } catch (java.io.IOException e) {\n                // ignored\n            } finally {\n                try {\n                    in.close();\n                } catch (java.io.IOException e) {\n                    // ignored\n                }\n            }\n        }\n    }\n\n    /** The current log level */\n    protected int currentLogLevel = LOG_LEVEL_INFO;\n    /** The short name of this StataLogger instance */\n    private transient String shortLogName = null;\n\n    /**\n     * Package access allows only {@link StataLoggerFactory} to instantiate\n     * StataLogger instances.\n     */\n    StataLogger(String name) {\n        this.name = name;\n\n        String levelString = recursivelyComputeLevelString();\n        if (levelString != null) {\n            this.currentLogLevel = stringToLevel(levelString);\n        } else {\n            this.currentLogLevel = DEFAULT_LOG_LEVEL;\n        }\n    }\n\n    String recursivelyComputeLevelString() {\n        String tempName = name;\n        String levelString = null;\n        int indexOfLastDot = tempName.length();\n        while ((levelString == null) && (indexOfLastDot > -1)) {\n            tempName = tempName.substring(0, indexOfLastDot);\n            levelString = getStringProperty(LOG_KEY_PREFIX + tempName, null);\n            indexOfLastDot = String.valueOf(tempName).lastIndexOf(\".\");\n        }\n        return levelString;\n    }\n\n    private static int stringToLevel(String levelStr) {\n        if (\"trace\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_TRACE;\n        } else if (\"debug\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_DEBUG;\n        } else if (\"info\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_INFO;\n        } else if (\"warn\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_WARN;\n        } else if (\"error\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_ERROR;\n        } else if (\"off\".equalsIgnoreCase(levelStr)) {\n            return LOG_LEVEL_OFF;\n        }\n        // assume INFO by default\n        return LOG_LEVEL_INFO;\n    }\n\n    /**\n     * This is our internal implementation for logging regular (non-parameterized)\n     * log messages.\n     *\n     * @param level   One of the LOG_LEVEL_XXX constants defining the log level\n     * @param message The message itself\n     * @param t       The exception whose stack trace should be logged\n     */\n    private void log(int level, String message, Throwable t) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n\n        StringBuilder buf = new StringBuilder(32);\n\n        // Append date-time if so configured\n        if (SHOW_DATE_TIME) {\n            if (DATE_FORMATTER != null) {\n                buf.append(getFormattedDate());\n                buf.append(' ');\n            } else {\n                buf.append(System.currentTimeMillis() - START_TIME);\n                buf.append(' ');\n            }\n        }\n\n        // Append current thread name if so configured\n        if (SHOW_THREAD_NAME) {\n            buf.append('[');\n            buf.append(Thread.currentThread().getName());\n            buf.append(\"] \");\n        }\n\n        if (LEVEL_IN_BRACKETS)\n            buf.append('[');\n\n        // Append a readable representation of the log level\n        switch (level) {\n            case LOG_LEVEL_TRACE:\n                buf.append(\"TRACE\");\n                break;\n            case LOG_LEVEL_DEBUG:\n                buf.append(\"DEBUG\");\n                break;\n            case LOG_LEVEL_INFO:\n                buf.append(\"INFO\");\n                break;\n            case LOG_LEVEL_WARN:\n                buf.append(WARN_LEVEL_STRING);\n                break;\n            case LOG_LEVEL_ERROR:\n                buf.append(\"ERROR\");\n                break;\n        }\n        if (LEVEL_IN_BRACKETS)\n            buf.append(']');\n        buf.append(' ');\n\n        // Append the name of the log instance if so configured\n        if (SHOW_SHORT_LOG_NAME) {\n            if (shortLogName == null)\n                shortLogName = computeShortName();\n            buf.append(String.valueOf(shortLogName)).append(\" - \");\n        } else if (SHOW_LOG_NAME) {\n            buf.append(String.valueOf(name)).append(\" - \");\n        }\n\n        // Append the message\n        buf.append(message);\n\n        write(level, buf, t);\n    }\n\n    private void write(int level, StringBuilder buf, Throwable t) {\n        if(level == LOG_LEVEL_ERROR) {\n            SFIToolkit.error(buf.toString());\n        } else {\n            SFIToolkit.display(buf.toString());\n        }\n\n        if (t != null) {\n            SFIToolkit.errorDebug(stackTraceToString(t));\n        }\n    }\n\n    private static String stackTraceToString(Throwable t) {\n        try (StringWriter sw = new StringWriter();\n                PrintWriter pw = new PrintWriter(sw))\n        {\n            t.printStackTrace(pw);\n            return sw.toString();\n        }\n        catch (IOException e) {\n            return \"\";\n        }\n    }\n\n    private String getFormattedDate() {\n        Date now = new Date();\n        String dateText;\n        synchronized (DATE_FORMATTER) {\n            dateText = DATE_FORMATTER.format(now);\n        }\n        return dateText;\n    }\n\n    private String computeShortName() {\n        return name.substring(name.lastIndexOf(\".\") + 1);\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arg1\n     * @param arg2\n     */\n    private void formatAndLog(int level, String format, Object arg1, Object arg2) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.format(format, arg1, arg2);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * For formatted messages, first substitute arguments and then log.\n     *\n     * @param level\n     * @param format\n     * @param arguments a list of 3 ore more arguments\n     */\n    private void formatAndLog(int level, String format, Object... arguments) {\n        if (!isLevelEnabled(level)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(format, arguments);\n        log(level, tp.getMessage(), tp.getThrowable());\n    }\n\n    /**\n     * Is the given log level currently enabled?\n     *\n     * @param logLevel is this level enabled?\n     * @return true if logLevel is enabled\n     */\n    protected boolean isLevelEnabled(int logLevel) {\n        // log level are numerically ordered so can use simple numeric\n        // comparison\n        return (logLevel >= currentLogLevel);\n    }\n\n    /** Are {@code trace} messages currently enabled? */\n    public boolean isTraceEnabled() {\n        return isLevelEnabled(LOG_LEVEL_TRACE);\n    }\n\n    /**\n     * A simple implementation which logs messages of level TRACE according\n     * to the format outlined above.\n     */\n    public void trace(String msg) {\n        log(LOG_LEVEL_TRACE, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_TRACE, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * TRACE according to the format outlined above.\n     */\n    public void trace(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_TRACE, format, argArray);\n    }\n\n    /** Log a message of level TRACE, including an exception. */\n    public void trace(String msg, Throwable t) {\n        log(LOG_LEVEL_TRACE, msg, t);\n    }\n\n    /** Are {@code debug} messages currently enabled? */\n    public boolean isDebugEnabled() {\n        return isLevelEnabled(LOG_LEVEL_DEBUG);\n    }\n\n    /**\n     * A simple implementation which logs messages of level DEBUG according\n     * to the format outlined above.\n     */\n    public void debug(String msg) {\n        log(LOG_LEVEL_DEBUG, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object param1, Object param2) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, param1, param2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * DEBUG according to the format outlined above.\n     */\n    public void debug(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_DEBUG, format, argArray);\n    }\n\n    /** Log a message of level DEBUG, including an exception. */\n    public void debug(String msg, Throwable t) {\n        log(LOG_LEVEL_DEBUG, msg, t);\n    }\n\n    /** Are {@code info} messages currently enabled? */\n    public boolean isInfoEnabled() {\n        return isLevelEnabled(LOG_LEVEL_INFO);\n    }\n\n    /**\n     * A simple implementation which logs messages of level INFO according\n     * to the format outlined above.\n     */\n    public void info(String msg) {\n        log(LOG_LEVEL_INFO, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_INFO, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * INFO according to the format outlined above.\n     */\n    public void info(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_INFO, format, argArray);\n    }\n\n    /** Log a message of level INFO, including an exception. */\n    public void info(String msg, Throwable t) {\n        log(LOG_LEVEL_INFO, msg, t);\n    }\n\n    /** Are {@code warn} messages currently enabled? */\n    public boolean isWarnEnabled() {\n        return isLevelEnabled(LOG_LEVEL_WARN);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level WARN according\n     * to the format outlined above.\n     */\n    public void warn(String msg) {\n        log(LOG_LEVEL_WARN, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_WARN, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * WARN according to the format outlined above.\n     */\n    public void warn(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_WARN, format, argArray);\n    }\n\n    /** Log a message of level WARN, including an exception. */\n    public void warn(String msg, Throwable t) {\n        log(LOG_LEVEL_WARN, msg, t);\n    }\n\n    /** Are {@code error} messages currently enabled? */\n    public boolean isErrorEnabled() {\n        return isLevelEnabled(LOG_LEVEL_ERROR);\n    }\n\n    /**\n     * A simple implementation which always logs messages of level ERROR according\n     * to the format outlined above.\n     */\n    public void error(String msg) {\n        log(LOG_LEVEL_ERROR, msg, null);\n    }\n\n    /**\n     * Perform single parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg, null);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object arg1, Object arg2) {\n        formatAndLog(LOG_LEVEL_ERROR, format, arg1, arg2);\n    }\n\n    /**\n     * Perform double parameter substitution before logging the message of level\n     * ERROR according to the format outlined above.\n     */\n    public void error(String format, Object... argArray) {\n        formatAndLog(LOG_LEVEL_ERROR, format, argArray);\n    }\n\n    /** Log a message of level ERROR, including an exception. */\n    public void error(String msg, Throwable t) {\n        log(LOG_LEVEL_ERROR, msg, t);\n    }\n\n    public void log(LoggingEvent event) {\n        int levelInt = event.getLevel().toInt();\n\n        if (!isLevelEnabled(levelInt)) {\n            return;\n        }\n        FormattingTuple tp = MessageFormatter.arrayFormat(event.getMessage(), event.getArgumentArray(), event.getThrowable());\n        log(levelInt, tp.getMessage(), event.getThrowable());\n    }\n}\n", "oup;\nimport org.jsoup.safety.Whitelist;\n\n/**\n * HTML\u6e05\u7406\n */\npublic class HtmlCleanEditor extends PropertyEditorSupport {\n\n\t/** \u662f\u5426\u79fb\u9664\u4e24\u7aef\u7a7a\u767d */\n\tprivate boolean trim;\n\n\t/** \u662f\u5426\u5c06\u7a7a\u8f6c\u6362\u4e3anull */\n\tprivate boolean emptyAsNull;\n\n\t/** \u767d\u540d\u5355 */\n\tprivate Whitelist whitelist = Whitelist.none();\n\n\t/**\n\t * @param trim\n\t *            \u662f\u5426\u79fb\u9664\u4e24\u7aef\u7a7a\u767d\n\t * @param emptyAsNull\n\t *            \u662f\u5426\u5c06\u7a7a\u8f6c\u6362\u4e3anull\n\t */\n\tpublic HtmlCleanEditor(boolean trim, boolean emptyAsNull) {\n\t\tthis.trim = trim;\n\t\tthis.emptyAsNull = emptyAsNull;\n\t}\n\n\t/**\n\t * @param trim\n\t *            \u662f\u5426\u79fb\u9664\u4e24\u7aef\u7a7a\u767d\n\t * @param emptyAsNull\n\t *            \u662f\u5426\u5c06\u7a7a\u8f6c\u6362\u4e3anull\n\t * @param whitelist\n\t *            \u767d\u540d\u5355\n\t */\n\tpublic HtmlCleanEditor(boolean trim, boolean emptyAsNull, Whitelist whitelist) {\n\t\tthis.trim = trim;\n\t\tthis.emptyAsNull = emptyAsNull;\n\t\tthis.whitelist = whitelist;\n\t}\n\n\t/**\n\t * \u83b7\u53d6\u5185\u5bb9\n\t * \n\t * @return \u5185\u5bb9\n\t */\n\t@Override\n\tpublic String getAsText() {\n\t\tObject value = getValue();\n\t\treturn value != null ? value.toString() : \"\";\n\t}\n\n\t/**\n\t * \u8bbe\u7f6e\u5185\u5bb9\n\t * \n\t * @param text\n\t *            \u5185\u5bb9\n\t */\n\t@Override\n\tpublic void setAsText(String text) {\n\t\tif (text != null) {\n\t\t\tString value = trim ? text.trim() : text;\n\t\t\tvalue = Jsoup.clean(value, whitelist);\n\t\t\tif (emptyAsNull && \"\".equals(value)) {\n\t\t\t\tvalue = null;\n\t\t\t}\n\t\t\tsetValue(value);\n\t\t} else {\n\t\t\tsetValue(null);\n\t\t}\n\t}\n\n}", "n\u00e9\n *\n */\npublic enum ListItemTypes {\n\tREQUEST, TRANSACTION;\n}\n", "", ".interfaces.UnaryOp;\nimport wolf.interfaces.Visitor;\nimport wolf.interfaces.WolfFunction;\n\n/**\n * A native unary, or unary operations native to WOLF\n * @author Kevin Dittmar\n * @author William Ezekiel\n * @author Joseph Alacqua\n * @version Apr 3, 2016\n */\npublic class NativeListUnary extends WolfFunction {\n    NativeListUnaryOp list_unary_op;\n    ListArgument list_argument;\n    \n    public NativeListUnary(NativeListUnaryOp list_unary_op, \n            ListArgument list_argument) {\n        this.list_unary_op = list_unary_op;\n        this.list_argument = list_argument;\n    }\n    \n    /**\n     * Accepts a visitor\n     * @param v a visitor\n     * @return the type returned by this unary op.\n     */\n    @Override\n    public Object accept(Visitor v) {\n        return v.visit(this);\n    }\n    \n    /**\n     * @return string representation of a list unary op\n     */\n    @Override\n    public String toString() {\n        return list_unary_op.toString() + \"(\" + list_argument.toString() + \")\";\n    }\n}\n\n", ".vse.dtos.Country;\nimport edu.vse.models.CountryEntity;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cache.annotation.Cacheable;\nimport org.springframework.stereotype.Service;\n\nimport javax.persistence.EntityNotFoundException;\nimport java.util.List;\nimport java.util.Optional;\n\nimport static java.util.stream.Collectors.toList;\n\n@Service\npublic class CountryService {\n\n    private static final Logger log = LoggerFactory.getLogger(CountryService.class);\n\n    private final CountryDao countryDao;\n\n    @Autowired\n    public CountryService(CountryDao countryDao) {\n        this.countryDao = countryDao;\n    }\n\n    @Cacheable(value = \"/countries/\", key = \"#p0\")\n    public Optional<Country> get(int id) {\n        try {\n            return Optional.of(countryDao.getOne(id)).map(CountryEntity::toDto);\n        } catch (EntityNotFoundException e) {\n            log.info(\"action=country-not-found id={}\", id);\n            return Optional.empty();\n        }\n    }\n\n    @Cacheable(value = \"/countries/\")\n    public Countries listAll() {\n        List<Country> collect = countryDao.findAll().stream().map(CountryEntity::toDto).collect(toList());\n        return new Countries(collect);\n    }\n}\n", " * <p>\r\n * Copyright (c) 2016 bothwing (bothwind@gmail.com)\r\n * <p>\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n * <p>\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n * <p>\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *********************************************************************************/\r\npackage com.bothwing.studyproject;\r\n\r\nimport android.os.Bundle;\r\nimport android.support.v7.app.AppCompatActivity;\r\nimport android.support.v7.widget.LinearLayoutManager;\r\nimport android.support.v7.widget.RecyclerView;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class MainActivity extends AppCompatActivity {\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_main);\r\n\r\n        initView();\r\n    }\r\n\r\n    private void initView() {\r\n        RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recycler_view_main);\r\n        recyclerView.setHasFixedSize(true);\r\n\r\n        LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getApplicationContext());\r\n        recyclerView.setLayoutManager(linearLayoutManager);\r\n\r\n        ArrayList<MainAdapterData> dataSet = new ArrayList<>();\r\n        MainRecyclerViewAdpater recyclerViewAdpater = new MainRecyclerViewAdpater(dataSet);\r\n        recyclerView.setAdapter(recyclerViewAdpater);\r\n\r\n        initData(dataSet);\r\n    }\r\n\r\n    private void initData(ArrayList<MainAdapterData> dataSet) {\r\n        dataSet.add(new MainAdapterData(MainAdapterData.Menu.MENU_RECYCLER, getString(R.string.main_menu1_title), getString(R.string.main_menu1_content)));\r\n        dataSet.add(new MainAdapterData(MainAdapterData.Menu.MENU_TABLAYOUT, getString(R.string.main_menu2_title), getString(R.string.main_menu2_content)));\r\n    }\r\n}\r\n", "t org.junit.rules.TestRule;\nimport org.junit.runner.Description;\nimport org.junit.runners.model.Statement;\n\nimport javax.swing.*;\nimport java.util.concurrent.CountDownLatch;\n\n/**\n * A JUnit {@link Rule} for running tests on the JavaFX thread and performing\n * JavaFX initialisation.  To include in your test case, add the following code:\n *\n * <pre>\n * {@literal @}Rule\n * public JavaFXThreadingRule jfxRule = new JavaFXThreadingRule();\n * </pre>\n *\n * @author Andy Till\n *\n */\npublic class JavaFxThreadingRule implements TestRule\n{\n\n    /**\n     * Flag for setting up the JavaFX, we only need to do this once for all tests.\n     */\n    private static boolean jfxIsSetup;\n\n    @Override\n    public Statement apply(Statement statement, Description description) {\n\n        return new OnJFXThreadStatement(statement);\n    }\n\n    private static class OnJFXThreadStatement extends Statement {\n\n        private final Statement statement;\n\n        public OnJFXThreadStatement(Statement aStatement) {\n            statement = aStatement;\n        }\n\n        private Throwable rethrownException = null;\n\n        @Override\n        public void evaluate() throws Throwable {\n\n            if(!jfxIsSetup) {\n                setupJavaFX();\n\n                jfxIsSetup = true;\n            }\n\n            final CountDownLatch countDownLatch = new CountDownLatch(1);\n\n            Platform.runLater(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        statement.evaluate();\n                    } catch (Throwable e) {\n                        rethrownException = e;\n                    }\n                    countDownLatch.countDown();\n                }});\n\n            countDownLatch.await();\n\n            // if an exception was thrown by the statement during evaluation,\n            // then re-throw it to fail the test\n            if(rethrownException != null) {\n                throw rethrownException;\n            }\n        }\n\n        protected void setupJavaFX() throws InterruptedException {\n\n            long timeMillis = System.currentTimeMillis();\n\n            final CountDownLatch latch = new CountDownLatch(1);\n\n            SwingUtilities.invokeLater(new Runnable() {\n                public void run() {\n                    // initializes JavaFX environment\n                    new JFXPanel();\n\n                    latch.countDown();\n                }\n            });\n\n            System.out.println(\"javafx initialising...\");\n            latch.await();\n            System.out.println(\"javafx is initialised in \" + (System.currentTimeMillis() - timeMillis) + \"ms\");\n        }\n\n    }\n}\n", "SH;\nimport static java.util.ResourceBundle.getBundle;\n\nimport java.text.MessageFormat;\nimport java.util.Locale;\nimport java.util.ResourceBundle;\n\n/**\n * Utility class for working with the I18N resources.\n * <p>\n * Not sure if this shouldn't be called I18NUtil.\n */\npublic final class ResourceUtil\n{\n    // Class Properties\n\n    ///////////////////////////////////////////////////////////////\n    // Constants recording the keys in the I18N resource bundle. //\n    ///////////////////////////////////////////////////////////////\n\n    // - InfoBar help messages\n\n    // -- For the root MenuBar\n    public static final String INFO_MENU_ROOT = \"menu.root.info\";\n\n    // -- For the ChoiceBoxes\n    public static final String INFO_CHOICE_VIEWTYPE = \"choice.viewtype.info\";\n    public static final String INFO_CHOICE_FILTERTYPE = \"choice.filtertype.info\";\n    public static final String INFO_CHOICE_FILTERTARGET = \"choice.filtertarget.info\";\n    public static final String INFO_CHOICE_COMPARISONOPERATOR = \"choice.comparisonOperator.info\";\n\n    // -- For the Buttons\n    public static final String INFO_BUTTON_FREEZE_UNFROZEN = \"button.freeze.unfrozen.info\";\n    public static final String INFO_BUTTON_FREEZE_FROZEN = \"button.freeze.frozen.info\";\n    public static final String INFO_BUTTON_COMPARE = \"button.compare.info\";\n    public static final String INFO_BUTTON_FILTER = \"button.filter.info\";\n    public static final String INFO_BUTTON_EXPORT = \"button.flat.export.info\";\n    public static final String INFO_BUTTON_QUICKFILTER = \"button.quickFilter.info\";\n    public static final String INFO_BUTTON_EXPANDALL = \"button.expandAll.info\";\n    public static final String INFO_BUTTON_COLLAPSEALLALL = \"button.collapseAll.info\";\n    public static final String INFO_BUTTON_ADDFILTER = \"button.addFilter.info\";\n    public static final String INFO_BUTTON_REMOVEFILTER = \"button.removeFilter.info\";\n\n    // -- For text input fields\n    public static final String INFO_INPUT_QUICKFILTER = \"input.quickFilter.info\";\n    public static final String INFO_INPUT_FILTERVALUE = \"input.filterValue.info\";\n\n    // -- For Labels\n    public static final String INFO_LABEL_PROFILESAMPLECOUNT = \"label.profileSampleCount.info\";\n    public static final String INFO_LABEL_BASESOURCE = \"label.baseSource.info\";\n    public static final String INFO_LABEL_NEWSOURCE = \"label.newSource.info\";\n\n    public static final String INFO_LABEL_ANCESTORS = \"label.ancestors.info\";\n    public static final String INFO_LABEL_DESCENDANTS = \"label.descendants.info\";\n\n    // -- For CheckBoxes\n    public static final String INFO_CHECK_HIDEERRORTHREADS = \"check.hideErrorThreads.info\";\n\n    public static final String INFO_TABLE_FLAT = \"table.flat.info\";\n    public static final String INFO_TABLE_FLATDIFF = \"table.flatDiff.info\";\n    public static final String INFO_TABLE_TREE = \"table.tree.info\";\n    public static final String INFO_TABLE_TREEDIFF = \"table.treeDiff.info\";\n\n    // -- For ListViews\n    public static final String INFO_LIST_FILTERS = \"list.filters.info\";\n\n    // -- For Tabs\n    public static final String INFO_TAB_PROFILE = \"tab.profile.info\";\n    public static final String INFO_TAB_PROFILEDIFF = \"tab.profileDiff.info\";\n\n    // - Text Content\n\n    // -- For Labels\n    public static final String CONTENT_LABEL_PROFILESAMPLECOUNT = \"label.profileSampleCount.content\";\n    public static final String CONTENT_LABEL_EXCEPTION = \"label.exception.content\";\n\n    // -- For Tab headers\n    public static final String CONTENT_TAB_LOADING = \"tab.loading.content\";\n\n    // - Context Menu Item labels\n\n    // -- For TreeItems\n    public static final String CTXMENU_TREE_EXPANDFULLY = \"ctxmenu.tree.expandFully\";\n    public static final String CTXMENU_TREE_EXPANDFIRSTONLY = \"ctxmenu.tree.expandFirstOnly\";\n    public static final String CTXMENU_TREE_COLLAPSE = \"ctxmenu.tree.collapse\";\n    public static final String CTXMENU_TREE_EXPORTSUBTREE = \"ctxmenu.tree.exportSubtree\";\n\n    // - Tooltip messages\n\n    // -- For Buttons\n    public static final String TOOLTIP_BUTTON_FREEZE_UNFROZEN = \"button.freeze.unfrozen.tooltip\";\n    public static final String TOOLTIP_BUTTON_FREEZE_FROZEN = \"button.freeze.frozen.tooltip\";\n\n    // - Column Headers\n    public static final String COLUMN_METHOD = \"column.method\";\n    public static final String COLUMN_SELF_PCT_GRAPH = \"column.selfCntPctGraph\";\n    public static final String COLUMN_TOTAL_PCT_GRAPH = \"column.totalCntPctGraph\";\n\n    public static final String COLUMN_SELF_CNT = \"column.selfCnt\";\n    public static final String COLUMN_SELF_TIME = \"column.selfTime\";\n    public static final String COLUMN_SELF_CNT_DIFF = \"column.selfCntDiff\";\n    public static final String COLUMN_SELF_TIME_DIFF = \"column.selfTimeDiff\";\n    public static final String COLUMN_SELF_CNT_PCT = \"column.selfCntPct\";\n    public static final String COLUMN_SELF_TIME_PCT = \"column.selfTimePct\";\n    public static final String COLUMN_SELF_CNT_PCT_DIFF = \"column.selfCntPctDiff\";\n    public static final String COLUMN_SELF_TIME_PCT_DIFF = \"column.selfTimePctDiff\";\n\n    public static final String COLUMN_TOTAL_CNT = \"column.totalCnt\";\n    public static final String COLUMN_TOTAL_TIME = \"column.totalTime\";\n    public static final String COLUMN_TOTAL_CNT_DIFF = \"column.totalCntDiff\";\n    public static final String COLUMN_TOTAL_TIME_DIFF = \"column.totalTimeDiff\";\n    public static final String COLUMN_TOTAL_CNT_PCT = \"column.totalCntPct\";\n    public static final String COLUMN_TOTAL_TIME_PCT = \"column.totalTimePct\";\n    public static final String COLUMN_TOTAL_CNT_PCT_DIFF = \"column.totalCntPctDiff\";\n    public static final String COLUMN_TOTAL_TIME_PCT_DIFF = \"column.totalTimePctDiff\";\n\n    // - Dialog Titles\n\n    public static final String TITLE_DIALOG_OPENFILE = \"dialog.openFile.title\";\n    public static final String TITLE_DIALOG_SPECIFYFILTERS = \"dialog.specifyFilters.title\";\n    public static final String TITLE_DIALOG_SPECIFYFILTER = \"dialog.specifyFilter.title\";\n\n    public static final String TITLE_DIALOG_ERR_OPENPROFILE = \"dialog.err.openProfile.title\";\n    public static final String TITLE_DIALOG_ERR_EXPORTPROFILE = \"dialog.err.exportProfile.title\";\n    public static final String TITLE_DIALOG_ERR_ALREADYOPENPROFILE = \"dialog.err.alreadyOpen.title\";\n\n    // - Dialog Headers\n\n    public static final String HEADER_DIALOG_ERR_OPENPROFILE = \"dialog.err.openProfile.header\";\n    public static final String HEADER_DIALOG_ERR_EXPORTPROFILE = \"dialog.err.exportProfile.header\";\n    public static final String HEADER_DIALOG_ERR_ALREADYOPENPROFILE = \"dialog.err.alreadyOpen.header\";\n\n    // - Dialog Content\n\n    public static final String MESSAGE_DIALOG_ERR_OPENPROFILE = \"dialog.err.openProfile.message\";\n    public static final String MESSAGE_DIALOG_ERR_TASKCANCELED = \"dialog.err.taskCanceled.message\";\n    public static final String MESSAGE_DIALOG_ERR_EXPORTPROFILE = \"dialog.err.exportProfile.message\";\n    public static final String MESSAGE_DIALOG_ERR_ALREADYOPENPROFILE = \"dialog.err.alreadyOpen.message\";\n\n    // - File Types\n\n    public static final String TYPE_FILE_HP = \"type.file.hp\";\n    public static final String TYPE_FILE_ALL = \"type.file.all\";\n\n    // - Exception Messages\n\n    public static final String EXCEPTION_DIALOGCREATIONFAILED = \"exception.dialogCreationFailed.message\";\n\n    // - General Strings\n\n    public static final String GENERAL_UNKNOWN = \"general.unknown\";\n    public static final String GENERAL_THREAD = \"general.thread\";\n    public static final String GENERAL_DEPTH = \"general.depth\";\n    public static final String GENERAL_SAMPLECOUNT = \"general.sampleCount\";\n\n    ///////////////////////////////////////////\n    // Bundle- and Locale-related constants. //\n    ///////////////////////////////////////////\n\n    private static final Locale DEFAULT_LOCALE = ENGLISH;\n    private static final String BUNDLE_BASE = \"com.insightfullogic.honest_profiler.ports.javafx.i18n.HPUIBundle\";\n    private static final ResourceBundle DEFAULT_BUNDLE = getBundle(BUNDLE_BASE, DEFAULT_LOCALE);\n\n    /**\n     * Returns the default {@link Locale} for the application, which is set to {@link Locale#ENGLISH} since that's the\n     * only available {@link ResourceBundle} at time of writing.\n     * <p>\n     * @return the default {@link Locale}\n     */\n    public static final Locale getDefaultLocale()\n    {\n        return DEFAULT_LOCALE;\n    }\n\n    /**\n     * Returns the {@link ResourceBundle} for the default {@link Locale}.\n     * <p>\n     * @return the {@link ResourceBundle} for the default {@link Locale}\n     */\n    public static ResourceBundle getDefaultBundle()\n    {\n        return DEFAULT_BUNDLE;\n    }\n\n    /**\n     * Formats a message from the specified {@link ResourceBundle} using the specified arguments.\n     * <p>\n     * @param locale the {@link Locale} (see {@link MessageFormat#setLocale(Locale)})\n     * @param bundle the {@link ResourceBundle} containing the message pattern\n     * @param key the key of the message pattern in the {@link ResourceBundle}\n     * @param args the arguments needed for formatting the message\n     * @return the formatted message\n     */\n    public static String format(Locale locale, ResourceBundle bundle, String key, Object... args)\n    {\n        MessageFormat formatter = new MessageFormat(\"\");\n        formatter.setLocale(locale);\n        formatter.applyPattern(bundle.getString(key));\n        return formatter.format(args);\n    }\n\n    // Instance Constructors\n\n    /**\n     * Private constructor for Utility Class.\n     */\n    private ResourceUtil()\n    {\n        // Private constructor for Utility Class\n    }\n}\n", "til.ArrayList;\n\npublic class Project\n{\n    private int id;\n    private String name;\n    private String desc;\n    private int leaderID;\n    private ArrayList<Integer> users;\n    private int calendar;\n\n    public Project( int id, String name, String desc, int leaderID, ArrayList<Integer> users, int calendar)\n    {\n        this.id = id;\n        this.name = name;\n        this.desc = desc;\n        this.leaderID = leaderID;\n        this.users = users;\n        this.calendar = calendar;\n    }\n\n    public String getID()\n    {\n        return this.name;\n    }\n\n    public String getName()\n    {\n        return this.name;\n    }\n\n    public String getDesc()\n    {\n        return this.desc;\n    }\n\n    public ArrayList<Task> getTasks(){\n        return new ArrayList<Task>();\n    }\n\n    public ArrayList<User> getUsers()\n    {\n        return new ArrayList<User>();\n    }\n\n    public int getleaderID()\n    {\n        return this.leaderID;\n    }\n\n    public void setName( String name)\n    {\n        this.name = name;\n    }\n\n    public void setDesc( String desc)\n    {\n        this.desc = desc;\n    }\n\n    public void setLeader( int leaderID)\n    {\n        this.leaderID = leaderID;\n    }\n\n    public void addUser( int userID)\n    {\n        this.users.add( userID);\n    }\n\n    public void removeUser( int userID)\n    {\n        users.remove( userID);\n    }\n\n    public Calendar getCalendar()\n    {\n        return Calendar.getByID( calendar);\n\n    }\n\n    public ArrayList<Calendar> getUserCalendars()\n    {\n        ArrayList<Calendar> userCalendars = new ArrayList<Calendar>();\n\n        for (Integer userID : users)\n        {\n            User user = User.getByID( userID);\n\n            userCalendars.add( user.getCalendar());\n        }\n\n        return userCalendars;\n    }\n\n    public String generateReport()\n    {\n        // To Do\n        return \"\";\n    }\n\n    public static Project getByID( int id)\n    {\n        // To Do\n        // Connect DB and get project\n        return null;\n    }\n}\n", "\r\n * Copyright (c) 2017 Anthony Law\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in all\r\n * copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *******************************************************************************/\r\npackage com.github.mob41.osumer.updater;\r\n\r\nimport java.awt.Color;\r\nimport java.awt.Desktop;\r\nimport java.awt.Font;\r\nimport java.awt.Toolkit;\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.InetAddress;\r\nimport java.net.MalformedURLException;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.net.URI;\r\nimport java.net.URISyntaxException;\r\nimport java.net.URL;\r\nimport java.util.Calendar;\r\n\r\nimport javax.swing.GroupLayout;\r\nimport javax.swing.GroupLayout.Alignment;\r\nimport javax.swing.ImageIcon;\r\nimport javax.swing.JButton;\r\nimport javax.swing.JFrame;\r\nimport javax.swing.JLabel;\r\nimport javax.swing.JOptionPane;\r\nimport javax.swing.JPanel;\r\nimport javax.swing.JProgressBar;\r\nimport javax.swing.LayoutStyle.ComponentPlacement;\r\nimport javax.swing.SwingConstants;\r\nimport javax.swing.border.EmptyBorder;\r\n\r\nimport com.github.mob41.osumer.exceptions.DebugDump;\r\nimport com.github.mob41.osumer.exceptions.DebuggableException;\r\nimport com.github.mob41.osumer.exceptions.DumpManager;\r\nimport com.github.mob41.osumer.exceptions.NoBuildsForVersionException;\r\nimport com.github.mob41.osumer.exceptions.NoSuchBuildNumberException;\r\nimport com.github.mob41.osumer.exceptions.NoSuchVersionException;\r\nimport com.github.mob41.osumer.exceptions.ErrorDumpDialog;\r\n\r\nimport java.awt.event.ActionListener;\r\nimport java.awt.event.ActionEvent;\r\n\r\npublic class UIFrame extends JFrame {\r\n\r\n\tprivate JPanel contentPane;\r\n\tprivate Thread thread;\r\n\tprivate boolean checkingUpdate = false;\r\n\t\r\n\tprivate final Config config;\r\n\tprivate final Updater updater;\r\n\tprivate JLabel lblStatus;\r\n\tprivate JProgressBar pb;\r\n\tprivate JButton btnCancel;\r\n\t\r\n\tprivate final boolean forceInstall;\r\n\r\n\t/**\r\n\t * Create the frame.\r\n\t */\r\n\tpublic UIFrame(Config config, boolean forceInstall) {\r\n\t\tthis.config = config;\r\n\t\tthis.forceInstall = forceInstall;\r\n\t\t\r\n\t\tsetTitle(\"osumer-updater\");\r\n\t\tsetIconImage(Toolkit.getDefaultToolkit().getImage(UIFrame.class.getResource(\"/com/github/mob41/osumer/updater/osumerIcon_32px.png\")));\r\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\r\n\t\tsetBounds(100, 100, 393, 461);\r\n\t\tcontentPane = new JPanel();\r\n\t\tcontentPane.setBorder(new EmptyBorder(5, 5, 5, 5));\r\n\t\tsetContentPane(contentPane);\r\n\t\t\r\n\t\tJLabel lblImg = new JLabel(\"\");\r\n\t\tlblImg.setIcon(new ImageIcon(UIFrame.class.getResource(\"/com/github/mob41/osumer/updater/osumerIcon_256px.png\")));\r\n\t\tlblImg.setHorizontalAlignment(SwingConstants.CENTER);\r\n\t\t\r\n\t\tpb = new JProgressBar();\r\n\t\t\r\n\t\tlblStatus = new JLabel(\"Waiting...\");\r\n\t\tlblStatus.setFont(new Font(\"Tahoma\", Font.PLAIN, 18));\r\n\t\tlblStatus.setHorizontalAlignment(SwingConstants.CENTER);\r\n\t\t\r\n\t\tbtnCancel = new JButton(\"Cancel\");\r\n\t\tbtnCancel.addActionListener(new ActionListener() {\r\n\t\t\tpublic void actionPerformed(ActionEvent arg0) {\r\n\t\t\t\tif (JOptionPane.showOptionDialog(UIFrame.this, \"Are you sure?\", \"Leaving\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE, null, null, 0) == JOptionPane.YES_OPTION){\r\n\t\t\t\t\tSystem.exit(0);\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t\tGroupLayout gl_contentPane = new GroupLayout(contentPane);\r\n\t\tgl_contentPane.setHorizontalGroup(\r\n\t\t\tgl_contentPane.createParallelGroup(Alignment.LEADING)\r\n\t\t\t\t.addComponent(lblImg, GroupLayout.DEFAULT_SIZE, 376, Short.MAX_VALUE)\r\n\t\t\t\t.addComponent(pb, GroupLayout.DEFAULT_SIZE, 284, Short.MAX_VALUE)\r\n\t\t\t\t.addComponent(lblStatus, Alignment.TRAILING, GroupLayout.DEFAULT_SIZE, 284, Short.MAX_VALUE)\r\n\t\t\t\t.addComponent(btnCancel, GroupLayout.DEFAULT_SIZE, 284, Short.MAX_VALUE)\r\n\t\t);\r\n\t\tgl_contentPane.setVerticalGroup(\r\n\t\t\tgl_contentPane.createParallelGroup(Alignment.LEADING)\r\n\t\t\t\t.addGroup(gl_contentPane.createSequentialGroup()\r\n\t\t\t\t\t.addComponent(lblImg, GroupLayout.PREFERRED_SIZE, 294, GroupLayout.PREFERRED_SIZE)\r\n\t\t\t\t\t.addPreferredGap(ComponentPlacement.RELATED)\r\n\t\t\t\t\t.addComponent(lblStatus, GroupLayout.PREFERRED_SIZE, 32, GroupLayout.PREFERRED_SIZE)\r\n\t\t\t\t\t.addPreferredGap(ComponentPlacement.RELATED)\r\n\t\t\t\t\t.addComponent(pb, GroupLayout.PREFERRED_SIZE, 35, GroupLayout.PREFERRED_SIZE)\r\n\t\t\t\t\t.addPreferredGap(ComponentPlacement.RELATED)\r\n\t\t\t\t\t.addComponent(btnCancel, GroupLayout.DEFAULT_SIZE, 33, Short.MAX_VALUE))\r\n\t\t);\r\n\t\tcontentPane.setLayout(gl_contentPane);\r\n\t\t\r\n\t\tupdater = new Updater(config);\r\n\t\tcheckUpdate();\r\n\t}\r\n\t\r\n\tprivate void checkUpdate(){\r\n\t\tif (!checkingUpdate){\r\n\t\t\tcheckingUpdate = true;\r\n\t\t\tthread = new Thread(){\r\n\t\t\t\tpublic void run(){\r\n\t\t\t\t\tlblStatus.setForeground(Color.BLACK);\r\n\t\t\t\t\tlblStatus.setText(\"Checking update...\");\r\n\t\t\t\t\t\r\n\t\t\t\t\tVersionInfo thisVerInfo = Installer.getInstalledVersion();\r\n\t\t\t\t\t\r\n\t\t\t\t\tUpdateInfo verInfo = null;\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tverInfo = updater.getLatestVersion();\r\n\t\t\t\t\t} catch (DebuggableException e){\r\n\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\tlblStatus.setText(\"Failure\");\r\n\t\t\t\t\t\tcheckingUpdate = false;\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tboolean startOsumer = false;\r\n\t\t\t\t\tboolean closeUpdater = true;\r\n\t\t\t\t\tif (verInfo == null){\r\n\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\tlblStatus.setText(\"Could get update info!\");\r\n\t\t\t\t\t} else if (!verInfo.isThisVersion()){\r\n\t\t\t\t\t\tlblStatus.setForeground(new Color(0,153,0));\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tboolean installing = thisVerInfo == null;\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tString verStr = verInfo.getVersion() +\r\n\t\t\t\t\t\t\t\t\"-\" + Updater.getBranchStr(verInfo.getBranch()) +\r\n\t\t\t\t\t\t\t\t\"-b\" + verInfo.getBuildNum();\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (installing){\r\n\t\t\t\t\t\t\tlblStatus.setText(\"Installation of \" + verStr);\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tlblStatus.setText(\"Available update to \" + verStr);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tboolean startInstall = false;\r\n\t\t\t\t\t\tif (!forceInstall){\r\n\t\t\t\t\t\t\tint option = JOptionPane.showOptionDialog(UIFrame.this,\r\n\t\t\t\t\t\t\t\t\t\tinstalling ? \"Install \" + verStr + \" now?\" : \"Update available! New version:\\n\" + verStr + \"\\n\\nDo you want to update it now?\\n\\n\",\r\n\t\t\t\t\t\t\t\t\t\tinstalling ? \"Installation\" : \"Update available\", JOptionPane.YES_NO_OPTION, JOptionPane.INFORMATION_MESSAGE, null, null, JOptionPane.NO_OPTION);\r\n\t\t\t\t\t\t\tstartInstall = option == JOptionPane.YES_OPTION;\r\n\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\tstartInstall = true;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\r\n\t\t\t\t\t\tif (startInstall){\r\n\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\tlblStatus.setText(\"Downloading\");\r\n\t\t\t\t\t\t\t\tpb.setStringPainted(true);\r\n\t\t\t\t\t\t\t\tURL url = new URL(verInfo.getExeLink());\r\n\r\n\t\t\t\t\t\t\t\tString dwnFolder = System.getProperty(\"java.io.tmpdir\");\r\n\t\t\t\t\t\t\t\tString dwnFile = verStr + \"_\" + Calendar.getInstance().getTimeInMillis();\r\n\t\t\t\t\t\t\t\tDownloader dwn = new Downloader(dwnFolder, dwnFile + \".exe\", url);\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\twhile (dwn.getStatus() == Downloader.DOWNLOADING){\r\n\t\t\t\t\t\t\t\t\tif (thread.isInterrupted()){\r\n\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tint progress = (int) dwn.getProgress();\r\n\t\t\t\t\t\t\t\t\tpb.setValue(progress);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\tif (dwn.getStatus() == Downloader.COMPLETED){\r\n\t\t\t\t\t\t\t\t\tpb.setIndeterminate(true);\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tInstaller installer = new Installer();\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tboolean stillInstall = true;\r\n\t\t\t\t\t\t\t\t\tif (Installer.isInstalled()){\r\n\t\t\t\t\t\t\t\t\t    if (!testPortFree(46725)) {\r\n\t\t\t\t\t\t\t\t\t        lblStatus.setText(\"Stopping daemon\");\r\n\t\t\t\t\t\t\t\t\t        try {\r\n\t\t\t\t\t\t\t\t                Socket socket = new Socket(InetAddress.getLoopbackAddress().getHostName(), 46725);\r\n\t\t\t\t\t\t\t\t                socket.setSoTimeout(5000);\r\n\r\n\t\t\t\t\t\t\t\t                PrintWriter writer = new PrintWriter(socket.getOutputStream());\r\n\t\t\t\t\t\t\t\t                writer.println(\"STOP\");\r\n\t\t\t\t\t\t\t\t                writer.flush();\r\n\t\t\t\t\t\t\t\t                socket.close();\r\n\t\t\t\t\t\t\t\t                \r\n\t\t\t\t\t\t\t\t                long startTime = System.currentTimeMillis();\r\n\t\t\t\t\t\t\t\t                while ((System.currentTimeMillis() - startTime) <= 5000 && !testPortFree(46725)) {\r\n\t\t\t\t\t\t\t\t                    try {\r\n                                                        Thread.sleep(1000);\r\n                                                    } catch (InterruptedException e) {}\r\n\t\t\t\t\t\t\t\t                }\r\n\t\t\t\t\t\t\t\t                \r\n\t\t\t\t\t\t\t\t                while(!testPortFree(46725)) {\r\n\t\t\t\t\t\t\t\t                    JOptionPane.showMessageDialog(UIFrame.this, \"osumer-updater could not shutdown osumer2 daemon.\\nPlease manually close it via \\\"osumer2\\\" - > \\\"Exit\\\" -> \\\"Yes\\\"\\nAnd press OK to continue.\", \"Info\", JOptionPane.INFORMATION_MESSAGE);\r\n\t\t\t\t\t\t\t\t                }\r\n\t\t\t\t\t\t\t\t            } catch (IOException e) {\r\n\t\t\t\t\t\t\t\t                e.printStackTrace();\r\n\t\t\t\t\t\t\t\t                DebugDump dump = new DebugDump(null, null, \"Opening connection to BG osumer socket\", null,\r\n\t\t\t\t\t\t\t\t                        \"Could not open socket at 46725 for BG call. Not osumer running at that port?\", false, e);\r\n\t\t\t\t\t\t\t\t                DumpManager.getInstance().addDump(dump);\r\n\t\t\t\t\t\t\t\t                ErrorDumpDialog dialog = new ErrorDumpDialog(dump);\r\n\t\t\t\t\t\t\t\t                dialog.setModal(true);\r\n\t\t\t\t\t\t\t\t                dialog.setVisible(true);\r\n\t\t\t\t\t\t\t\t                System.exit(-1);\r\n\t\t\t\t\t\t\t\t                return;\r\n\t\t\t\t\t\t\t\t            }\r\n\t\t\t\t\t\t\t\t\t    }\r\n\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Uninstalling\");\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tif (Updater.compareVersion(thisVerInfo.getVersion(), \"1.0.1\") == -1){\r\n\t\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\t\tinstaller.uninstall();\r\n\t\t\t\t\t\t\t\t\t\t\t} catch (DebuggableException e) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tstillInstall = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Uninstall failed\");\r\n\t\t\t\t\t\t\t\t\t\t\t\tDebugDump.showDebugDialog(e.getDump());\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\tProcessBuilder pb = new ProcessBuilder(\"java.exe\", \"-jar\", \"\\\"C:\\\\Program Files\\\\osumer\\\\osumer.exe\\\"\", \"-uninstall\", \"-quiet\");\r\n\t\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\t\tProcess proc = pb.start();\r\n\t\t\t\t\t\t\t\t\t\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));\r\n\t\t\t\t\t\t\t\t\t\t\t\tString line;\r\n\t\t\t\t\t\t\t\t\t\t\t\tboolean success = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\tString errorText = \"\";\r\n\t\t\t\t\t\t\t\t\t\t\t\tboolean errorNext = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tboolean readNext = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\twhile ((line = reader.readLine()) != null){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (readNext){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line.equals(\"Info@D$\") || line.equals(\"Error@D$\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treadNext = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treadNext = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (errorNext){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\terrorText += line;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (line.startsWith(\"Uninstallation success\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (line.equals(\"Info@U$\") || line.equals(\"Error@U$\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treadNext = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line.equals(\"Error@U$\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\terrorNext = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\treader.close();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (!success){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tstillInstall = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Uninstall failed\");\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(UIFrame.this, \"Error reported from executable:\\n\" + errorText, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tstillInstall = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Uninstall failed\");\r\n\t\t\t\t\t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(UIFrame.this, \"Error: \" + e, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\tif (stillInstall){\r\n                                        try {\r\n                                            lblStatus.setText(\"Cooling down...\");\r\n                                            Thread.sleep(5000);\r\n                                        } catch (InterruptedException e) {\r\n                                        }\r\n\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Installing\");\r\n\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\tif (Updater.compareVersion(verInfo.getVersion(), \"1.0.1\") == -1){\r\n\t\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\t\tinstaller.install(verInfo.getVersion(), Updater.getBranchStr(verInfo.getBranch()), verInfo.getBuildNum(), dwnFolder +  dwnFile + \".exe\");\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (Installer.isInstalled()){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tstartOsumer = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.GREEN);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Success\");\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tpb.setIndeterminate(false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} catch (DebuggableException e){\r\n\t\t\t\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Install failed\");\r\n\t\t\t\t\t\t\t\t\t\t\t\tDebugDump.showDebugDialog(e.getDump());\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t    System.out.println(\"\\\"\" + dwnFolder + dwnFile + \".exe\\\"\");\r\n\t\t\t\t\t\t\t\t\t\t\tProcessBuilder procb = new ProcessBuilder(\"java.exe\", \"-jar\", \"\\\"\" + dwnFolder + dwnFile + \".exe\\\"\", \"-install\", \"-quiet\");\r\n\t\t\t\t\t\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\t\t\t\t\t\tProcess proc = procb.start();\r\n\t\t\t\t\t\t\t\t\t\t\t\tBufferedReader reader = new BufferedReader(new InputStreamReader(proc.getInputStream()));\r\n\t\t\t\t\t\t\t\t\t\t\t\tString line;\r\n\t\t\t\t\t\t\t\t\t\t\t\tboolean success = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\tString errorText = \"\";\r\n\t\t\t\t\t\t\t\t\t\t\t\tboolean errorNext = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\tboolean readNext = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\twhile ((line = reader.readLine()) != null){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (readNext){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line.equals(\"Info@D$\") || line.equals(\"Error@D$\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treadNext = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treadNext = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (errorNext){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\terrorText += line;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (line.startsWith(\"Installation success\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tsuccess = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t} else if (line.equals(\"Info@U$\") || line.equals(\"Error@U$\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treadNext = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif (line.equals(\"Error@U$\")){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\terrorNext = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\treader.close();\r\n\t\t\t\t\t\t\t\t\t\t\t\t\r\n\t\t\t\t\t\t\t\t\t\t\t\tif (!success){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Install failed\");\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(UIFrame.this, \"Error reported from executable:\\n\" + errorText, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n\t\t\t\t\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (Installer.isInstalled()){\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tstartOsumer = true;\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.GREEN);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Success\");\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tpb.setIndeterminate(false);\r\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Install failed\");\r\n\t\t\t\t\t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(UIFrame.this, \"Error: \" + e, \"Error\", JOptionPane.ERROR_MESSAGE);\r\n\t\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t\t} else {\r\n\t\t\t\t\t\t\t\t\tcloseUpdater = false;\r\n\t\t\t\t\t\t\t\t\tlblStatus.setForeground(Color.RED);\r\n\t\t\t\t\t\t\t\t\tlblStatus.setText(\"Download failed\");\r\n\t\t\t\t\t\t\t\t\tpb.setIndeterminate(true);\r\n\t\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\t} catch (MalformedURLException e) {\r\n\t\t\t\t\t\t\t\te.printStackTrace();\r\n\t\t\t\t\t\t\t\tJOptionPane.showMessageDialog(UIFrame.this, \"The .exe web link provided from the update info is invalid.\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tstartOsumer = true;\r\n\t\t\t\t\t\tlblStatus.setText(\"Already latest\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\ttry {\r\n\t\t\t\t\t\tsleep(1000);\r\n\t\t\t\t\t} catch (InterruptedException e) {\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (startOsumer){\r\n\t\t\t\t\t\ttry {\r\n\t\t\t\t\t\t\tRuntime.getRuntime().exec(\"cmd /C \\\"\" + Installer.winPath + \"\\\\\" + Installer.winFile + \"\\\"\");\r\n\t\t\t\t\t\t} catch (IOException e) {\r\n\t\t\t\t\t\t\tJOptionPane.showMessageDialog(UIFrame.this, \"Unable to startup osumer\", \"Error\", JOptionPane.ERROR_MESSAGE);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tif (closeUpdater){\r\n\t\t\t\t\t\tdispose();\r\n\t\t\t\t\t}\r\n\t\t\t\t\t\r\n\t\t\t\t\tcheckingUpdate = false;\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t\tthread.start();\r\n\t\t}\r\n\t}\r\n\r\n    public static boolean testPortFree(int port) {\r\n        try {\r\n            new ServerSocket(port).close();\r\n            return true;\r\n        } catch (IOException e) {\r\n            return false;\r\n        }\r\n    }\r\n}\r\n", "app.AppCompatActivity;\nimport android.os.Bundle;\nimport android.view.View;\nimport android.widget.EditText;\n\npublic class AddNewMovie extends AppCompatActivity {\n\n    private EditText title_et, year_et, rated_et, released_et, runtime_et, genre_et, actors_et, plot_et;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_add_new_movie);\n    }\n\n    public void returnMainActivity(View view) {\n\n        saveMovieDescription();\n\n        Intent intent = new Intent(this, MainActivity.class);\n        startActivity(intent);\n    }\n\n    /*\n     * \"saves\" the user's input as a movie description object and adds it to a movie library\n     */\n    private void saveMovieDescription() {\n        title_et = (EditText) findViewById(R.id.title_editText);\n        year_et = (EditText) findViewById(R.id.year_editText);\n        rated_et = (EditText) findViewById(R.id.rating_editText);\n        released_et = (EditText) findViewById(R.id.released_editText);\n        runtime_et = (EditText) findViewById(R.id.runtime_editText);\n        genre_et = (EditText) findViewById(R.id.genre_editText);\n        actors_et = (EditText) findViewById(R.id.actors_editText);\n        plot_et = (EditText) findViewById(R.id.plot_editText);\n\n        MovieDescription newMovie = new MovieDescription();\n        newMovie.title = title_et.getText().toString();\n        newMovie.year = year_et.getText().toString();\n        newMovie.rating = rated_et.getText().toString();\n        newMovie.releaseDate = released_et.getText().toString();\n        newMovie.runtime = runtime_et.getText().toString();\n        newMovie.genre = genre_et.getText().toString();\n        newMovie.actors = actors_et.getText().toString();\n        newMovie.plot = plot_et.getText().toString();\n\n        String movieJson = newMovie.toJSONString();\n        android.util.Log.w(this.getClass().getSimpleName(), movieJson);\n    }\n}\n", "\n\tprivate Location min;\n\tprivate Location max;\n\tprivate double width;\n\tprivate double height;\n\t\n\tprivate void updateSizing() {\n\t\tthis.width = max.getX() - min.getX();\n\t\tthis.height = max.getY() - min.getY();\n\t}\n\t\n\tpublic Rectangle(Location min, Location max) {\n\t\tthis.min = min;\n\t\tthis.max = max;\n\t\tupdateSizing();\n\t}\n\t\n\tpublic Rectangle(Location min, double width, double height) {\n\t\tthis(min, new Location(min.getX() + width, min.getY() + height));\n\t}\n\t\n\tpublic double getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic double getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic Location getTopLeft() {\n\t\treturn min;\n\t}\n\t\n\tpublic Location getTopRight() {\n\t\tLocation loc = min.clone();\n\t\tloc.setX(this.max.getX());\n\t\treturn loc;\n\t}\n\t\n\tpublic Location getBottomLeft() {\n\t\tLocation loc = max.clone();\n\t\tloc.setX(this.min.getX());\n\t\treturn loc;\n\t}\n\t\n\tpublic Location getBottomRight() {\n\t\treturn min;\n\t}\n\t\n\tpublic boolean contains(Location loc) {\n\t\treturn loc.getX() >= this.min.getX()\n\t\t\t&& loc.getX() <= this.max.getX()\n\t\t\t&& loc.getY() >= this.min.getY()\n\t\t\t&& loc.getY() <= this.max.getY();\n\t}\n\t\n\tpublic void expand(double a) {\n\t\tthis.min.setX(this.min.getX() - a);\n\t\tthis.min.setY(this.min.getY() - a);\n\t\tthis.max.setX(this.max.getX() + a);\n\t\tthis.max.setY(this.max.getY() + a);\n\t\tupdateSizing();\n\t}\n\t\n\tpublic void shrink(double a) {\n\t\tthis.min.setX(this.min.getX() + a);\n\t\tthis.min.setY(this.min.getY() + a);\n\t\tthis.max.setX(this.max.getX() - a);\n\t\tthis.max.setY(this.max.getY() - a);\n\t\tupdateSizing();\n\t}\n\t\n\tpublic void rotate() {\n\t\tdouble height = this.height;\n\t\tdouble width = this.width;\n\t\tthis.max.setX(this.min.getX() + height);\n\t\tthis.max.setY(this.min.getY() + width);\n\t\tupdateSizing();\n\t}\n\t\n\tpublic void drawFill(GraphicsContext gfx) {\n\t\tgfx.fillRect(this.min.getX(), this.min.getY(), this.width, this.height);\n\t}\n\t\n\tpublic void drawFill(GraphicsContext gfx, int curve) {\n\t\tgfx.fillRoundRect(this.min.getX(), this.min.getY(), this.width, this.height, curve, curve);\n\t}\n\t\n\tpublic void drawStroke(GraphicsContext gfx) {\n\t\tgfx.strokeRect(this.min.getX(), this.min.getY(), this.width, this.height);\n\t}\n\t\n\tpublic Location getLocationRelative(double xp, double yp) {\n\t\tif(xp < 0 || xp > 1 || yp < 0 || xp > 1) {\n\t\t\tthrow new IllegalArgumentException(\"the given arguments must be beteen 0.0 and 1.0\");\n\t\t}\n\t\treturn new Location(this.min.getX() + this.width * xp, this.min.getY() + this.height * yp);\n\t}\n\t\n\tpublic void moveWithTopLeft(Location newMin) {\n\t\tthis.min = newMin;\n\t\tthis.max.setX(newMin.getX() + width);\n\t\tthis.max.setY(newMin.getY() + height);\n\t}\n\t\n\tpublic boolean intersects(Rectangle o) {\n\t\tif(o.contains(this.getTopLeft())\n\t\t|| o.contains(this.getTopRight())\n\t\t|| o.contains(this.getBottomLeft())\n\t\t|| o.contains(this.getBottomRight())\n\t\t|| this.contains(o.getBottomRight())\n\t\t|| this.contains(o.getBottomRight())\n\t\t|| this.contains(o.getBottomRight())\n\t\t|| this.contains(o.getBottomRight())) {\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n}\n", "rrays;\nimport java.util.Collection;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameter;\nimport org.junit.runners.Parameterized.Parameters;\n\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport com.microsoft.bingads.v12.api.test.entities.criterions.adgroup.age.BulkAdGroupAgeCriterionTest;\nimport com.microsoft.bingads.v12.bulk.entities.BulkAdGroupAgeCriterion;\n\n@RunWith(Parameterized.class)\npublic class BulkAdGroupAgeCriterionReadIdTest extends BulkAdGroupAgeCriterionTest {\n\n    @Parameter(value = 1)\n    public Long expectedResult;\n\n    @Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(\n                new Object[][]{\n                        {\"123\", 123L},\n                        {\"9223372036854775807\", 9223372036854775807L},\n                        {\"\", null},\n                        {null, null}\n                }\n        );\n    }\n\n    @Test\n    public void testRead() {\n        testReadProperty(\n                \"Id\",\n                datum,\n                expectedResult,\n                new Function<BulkAdGroupAgeCriterion, Long>() {\n                    @Override\n                    public Long apply(BulkAdGroupAgeCriterion c) {\n                        return c.getBiddableAdGroupCriterion().getId();\n                    }\n                }\n        );\n    }\n}\n", "e;\n    b = c && true; // OK\n    b = 1 && true; // error\n  }\n}\n", "com.google.common.primitives.Ints;\nimport org.json.*;\n\nimport java.util.*;\n\npublic class Sudoku {\n\n    Set<Candidate> givens;\n    Set<Candidate> solution = null;\n    final int size, boxesPerRow, boxesPerColumn;\n\n    public Sudoku(Set<Candidate> givens) {\n        this.givens = givens;\n\n        this.size = getSize();\n        this.boxesPerColumn = (int) (Math.sqrt(this.size));\n        this.boxesPerRow = (int) (Math.sqrt(this.size));\n\n        if (this.boxesPerRow * this.boxesPerColumn != this.size) {\n            throw new IllegalArgumentException(\"boxesPerRow * boxesPerColumn must equal size\");\n        }\n    }\n\n    public Sudoku(Set<Candidate> givens, int boxesPerRow, int boxesPerColumn) {\n        this.givens = givens;\n\n        this.size = getSize();\n        this.boxesPerColumn = boxesPerColumn;\n        this.boxesPerRow = boxesPerRow;\n        if (this.boxesPerRow * this.boxesPerColumn != this.size) {\n            throw new IllegalArgumentException(\"boxesPerRow * boxesPerColumn must equal size\");\n        }\n    }\n\n    public static Sudoku read(String str) {\n        HashSet<Candidate> givens = new HashSet<>();\n\n        JSONObject json = new JSONObject(str);\n        int boxesPerColumn = json.optInt(\"boxesPerColumn\", 0),\n                boxesPerRow = json.optInt(\"boxesPerRow\", 0);\n        JSONArray puzzle = json.getJSONArray(\"puzzle\"), rowElements;\n\n        for (int row = 0; row < puzzle.length(); ++row) {\n            rowElements = puzzle.getJSONArray(row);\n\n            for (int column = 0; column <= rowElements.length(); ++column) {\n                if (!rowElements.isNull(column)) {\n                    givens.add(new Candidate(row + 1, column + 1, rowElements.getInt(column)));\n                }\n            }\n        }\n\n        if (boxesPerRow == 0 || boxesPerColumn == 0) {\n            return new Sudoku(givens);\n        }\n        else {\n            return new Sudoku(givens, boxesPerRow, boxesPerColumn);\n        }\n\n    }\n\n    public Set<Candidate> solve() {\n        if (solution != null) {\n            return solution;\n        }\n\n        return solution = new ExactCoverProblem<Candidate, Constraint>(makeCandidates(), makeConstraints()) {\n            @Override\n            public boolean relation(Constraint constraint, Candidate candidate) {\n                return constraint.isSatisfiedBy(candidate);\n            }\n        }.solve();\n    }\n\n    public void print() {\n        int cellSize = (int) Math.ceil(Math.log10(size));\n\n        int[][] matrix = new int[size][size];\n        for (int[] row : matrix) {\n            Arrays.fill(row, 0);\n        }\n\n        Set<Candidate> toPrint = solution == null ? givens : solution;\n        toPrint.forEach(candidate -> matrix[candidate.row - 1][candidate.column - 1] = candidate.digit);\n\n        StringBuilder sb = new StringBuilder(topOrBottomRow(cellSize)).append(\"\\n\");\n        for (int row = 0; row < size; ++row) {\n            sb.append(rowOfDigits(matrix[row], cellSize)).append(\"\\n\");\n            if (row % boxesPerColumn == boxesPerColumn - 1 && row + 1 != size) {\n                sb.append(separatorRow(cellSize)).append(\"\\n\");\n            }\n        }\n        sb.append(topOrBottomRow(cellSize));\n        System.out.println(sb.toString());\n    }\n\n    private Set<Constraint> makeConstraints() {\n        HashSet<Constraint> constraints = new HashSet<>();\n        for (int m = 1; m <= size; ++m) {\n            for (int n = 1; n <= size; ++n) {\n                constraints.add(new RowColumnConstraint(m, n));\n                constraints.add(new RowDigitConstraint(m, n));\n                constraints.add(new ColumnDigitConstraint(m, n));\n                constraints.add(new BoxDigitConstraint(m, n));\n            }\n        }\n        return constraints;\n    }\n\n    private Set<Candidate> makeCandidates() {\n        HashSet<Candidate> candidates = new HashSet<>();\n\n        for (int row = 1; row <= size; ++row) {\n            for (int column = 1; column <= size; ++column) {\n                if (isGiven(row, column)) {\n                    candidates.add(getGiven(row, column));\n                }\n                else {\n                    for (int digit = 1; digit <= size; ++digit) {\n                        if (givenDigitInRow(row, digit)) { continue; }\n                        if (givenDigitInColumn(column, digit)) { continue; }\n                        if (givenDigitInBox(getBox(row, column), digit)) { continue; }\n                        candidates.add(new Candidate(row, column, digit));\n                    }\n                }\n            }\n        }\n        return candidates;\n    }\n\n    public Set<Candidate> getGivens() {\n        return Collections.unmodifiableSet(givens);\n    }\n\n    public Set<Candidate> getSolution() {\n        if (isSolved()) {\n            return Collections.unmodifiableSet(solution);\n        }\n        else {\n            return null;\n        }\n    }\n\n    public boolean isSolved() {\n        return solution != null;\n    }\n\n    public boolean isGiven(int row, int column) {\n        return givens\n                .stream()\n                .filter(given -> given.row == row && given.column == column)\n                .findAny()\n                .isPresent();\n    }\n\n    public Candidate getGiven(int row, int column) {\n        Optional<Candidate> result = givens\n                .stream()\n                .filter(given -> given.row == row && given.column == column)\n                .findAny();\n        return result.isPresent() ? result.get() : null;\n    }\n\n    public boolean givenDigitInRow(int row, int digit) {\n        return givens.stream().anyMatch(given -> given.row == row && given.digit == digit);\n    }\n\n    public boolean givenDigitInColumn(int column, int digit) {\n        return givens.stream().anyMatch(given -> given.column == column && given.digit == digit);\n    }\n\n    public boolean givenDigitInBox(int box, int digit) {\n        return givens.stream().anyMatch(given -> getBox(given) == box && given.digit == digit);\n    }\n\n    protected int getBox(Candidate candidate) {\n        return getBox(candidate.row, candidate.column);\n    }\n\n    protected int getBox(int row, int column) {\n        return (ceilDiv(row, boxesPerColumn) - 1) * boxesPerColumn + ceilDiv(column, boxesPerRow);\n    }\n\n    private int getSize() {\n        return givens.stream().mapToInt(candidate -> {\n            int m = Math.max(candidate.row, candidate.column);\n            return Math.max(m, candidate.digit);\n        }).max().getAsInt();\n    }\n\n    private int ceilDiv(int x, int y) {\n        return (x + y - 1) / y;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Sudoku sudoku = (Sudoku) o;\n        return size == sudoku.size &&\n                Objects.equals(givens, sudoku.givens);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(givens, size);\n    }\n\n    /* ************************************************************************\n     *  printing utility methods\n     * ******************+*****************************************************/\n    private String rowOfDigits(int[] row, int cellWidth) {\n        StringBuilder sb = new StringBuilder(\"|\");\n        StringJoiner joiner;\n        List<List<Integer>> partitions = Lists.partition(Ints.asList(row), boxesPerRow);\n\n        for (List<Integer> sublist : partitions) {\n            joiner = new StringJoiner(\" \", \"\", \"|\");\n            for (Integer i : sublist) {\n                joiner.add(String.format(\"%\" + cellWidth + \"s\", i == 0 ? \"\\u00B7\" : i));\n            }\n            sb.append(joiner.toString());\n        }\n        return sb.toString();\n    }\n\n    private String separatorRow(int cellWidth) {\n        StringBuilder sb = new StringBuilder(\"|\");\n        for (int i = 0; i < boxesPerRow; ++i) {\n            sb.append(Strings.repeat(\"-\", (cellWidth + 1) * boxesPerColumn - 1)).append(\"+\");\n        }\n        return sb.replace(sb.length() - 1, sb.length(), \"|\").toString();\n    }\n\n    private String topOrBottomRow(int cellWidth) {\n        return Strings.repeat(\"-\", ((cellWidth + 1) * boxesPerColumn) * boxesPerRow + 1);\n    }\n\n    public static class Candidate {\n        public final int row, column, digit;\n\n        public Candidate(int row, int column, int digit) {\n            this.row = row;\n            this.column = column;\n            this.digit = digit;\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Candidate candidate = (Candidate) o;\n            return row == candidate.row &&\n                    column == candidate.column &&\n                    digit == candidate.digit;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(row, column, digit);\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"[%d,%d,%d]\", row, column, digit);\n        }\n    }\n\n    abstract class Constraint {\n        public abstract boolean isSatisfiedBy(Candidate candidate);\n    }\n\n    class RowColumnConstraint extends Constraint {\n        final int row, column;\n\n        RowColumnConstraint(int row, int column) {\n            this.row = row;\n            this.column = column;\n        }\n\n        @Override\n        public boolean isSatisfiedBy(Candidate candidate) {\n            return candidate.row == this.row && candidate.column == this.column;\n        }\n    }\n\n    class RowDigitConstraint extends Constraint {\n        final int row, digit;\n\n        public RowDigitConstraint(int row, int digit) {\n            this.row = row;\n            this.digit = digit;\n        }\n\n        @Override\n        public boolean isSatisfiedBy(Candidate candidate) {\n            return candidate.row == this.row && candidate.digit == this.digit;\n        }\n    }\n\n    class ColumnDigitConstraint extends Constraint {\n        final int column, digit;\n\n        public ColumnDigitConstraint(int column, int digit) {\n            this.column = column;\n            this.digit = digit;\n        }\n\n        @Override\n        public boolean isSatisfiedBy(Candidate candidate) {\n            return candidate.column == this.column && candidate.digit == this.digit;\n        }\n    }\n\n    class BoxDigitConstraint extends Constraint {\n        final int box, digit;\n\n        public BoxDigitConstraint(int box, int digit) {\n            this.box = box;\n            this.digit = digit;\n        }\n\n        @Override\n        public boolean isSatisfiedBy(Candidate candidate) {\n            return getBox(candidate.row, candidate.column) == this.box && candidate.digit == this.digit;\n        }\n    }\n}\n", "", "import java.util.function.Function;\n\nimport org.geotools.feature.simple.SimpleFeatureTypeBuilder;\nimport org.opengis.feature.simple.SimpleFeatureType;\nimport org.opengis.referencing.crs.CoordinateReferenceSystem;\n\nimport com.vividsolutions.jts.geom.Geometry;\nimport com.vividsolutions.jts.geom.GeometryCollection;\nimport com.vividsolutions.jts.geom.LineString;\nimport com.vividsolutions.jts.geom.MultiLineString;\nimport com.vividsolutions.jts.geom.MultiPoint;\nimport com.vividsolutions.jts.geom.MultiPolygon;\nimport com.vividsolutions.jts.geom.Point;\nimport com.vividsolutions.jts.geom.Polygon;\n\npublic class GeoJSONSchemaDetector {\n\n    public static SimpleFeatureType getSchema(Map<String, Object> json, CoordinateReferenceSystem crs) {\n        return getSchema(json, crs, false);\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static SimpleFeatureType getSchema(Map<String, Object> json, CoordinateReferenceSystem crs, boolean ignoreGeometryProperties) {\n        // FIXME: This creates a side-effect by modifying the input as well as returning the SimpleFeatureType.\n        // Might cause problems later on...\n\n        // Map feature.geometry fields to JTS Geometries\n        replaceGeometry(json, GeoJSONReader2::toGeometry);\n        replaceMapProperties(json, it -> {\n            // Map properties of type Map<String, Object> to JTS geometries if possible, otherwise leave as is\n            try {\n                Geometry g = GeoJSONReader2.toGeometry(it);\n                if (ignoreGeometryProperties) {\n                    // If we want to ignore them return null to remove them from the properties map\n                    return null;\n                }\n                return g;\n            } catch (Exception e) {\n                return it;\n            }\n        });\n\n        Map<String, Class<?>> bindings = new HashMap<>();\n        String type = GeoJSONUtil.getString(json, GeoJSON.TYPE);\n        switch (type) {\n        case GeoJSON.FEATURE_COLLECTION:\n            List<Object> features = GeoJSONUtil.getList(json, GeoJSON.FEATURES);\n            for (Object feature : features) {\n                addAttributes((Map<String, Object>) feature, bindings);\n            }\n            break;\n        case GeoJSON.FEATURE:\n            addAttributes(json, bindings);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid type\");\n        }\n\n        if (bindings.isEmpty()) {\n            // Empty FeatureCollection\n            return null;\n        }\n\n        SimpleFeatureTypeBuilder sftb = new SimpleFeatureTypeBuilder();\n        sftb.setName(\"FeatureType\");\n        sftb.setNamespaceURI(\"http://oskari.org\");\n        sftb.setDefaultGeometry(GeoJSONUtil.DEFAULT_GEOMETRY_ATTRIBUTE_NAME);\n        sftb.setCRS(crs);\n\n        for (Map.Entry<String, Class<?>> attribute : bindings.entrySet()) {\n            String name = attribute.getKey();\n            Class<?> cl = attribute.getValue();\n            if (cl.isAssignableFrom(Geometry.class)) {\n                sftb.add(name, cl, crs);\n            } else {\n                sftb.add(name, cl);\n            }\n        }\n\n        return sftb.buildFeatureType();\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static void addAttributes(Map<String, Object> json,\n            Map<String, Class<?>> bindings) {\n        if (!GeoJSON.FEATURE.equals(GeoJSONUtil.getString(json, GeoJSON.TYPE))) {\n            throw new IllegalArgumentException(\"type was not \" + GeoJSON.FEATURE);\n        }\n\n        Object geom = json.get(GeoJSON.GEOMETRY);\n        if (geom != null) {\n            String key = GeoJSONUtil.DEFAULT_GEOMETRY_ATTRIBUTE_NAME;\n            Class<? extends Geometry> geometryType = (Class<? extends Geometry>) geom.getClass();\n            Class<? extends Geometry> currentType = (Class<? extends Geometry>) bindings.get(key);\n            Class<? extends Geometry> newType = getOverrideGeometryType(geometryType, currentType);\n            if (newType != null) {\n                bindings.put(key, newType);\n            }\n        }\n\n        Map<String, Object> properties = GeoJSONUtil.getMap(json, GeoJSON.PROPERTIES);\n        if (properties == null) {\n            return;\n        }\n        for (Map.Entry<String, Object> e : properties.entrySet()) {\n            String key = e.getKey();\n            if (GeoJSONUtil.DEFAULT_GEOMETRY_ATTRIBUTE_NAME.equals(key)) {\n                continue;\n            }\n            Object value = e.getValue();\n            if (value == null) {\n                continue;\n            }\n            if (value instanceof Geometry) {\n                Class<? extends Geometry> geometryType = (Class<? extends Geometry>) value.getClass();\n                Class<? extends Geometry> currentType = (Class<? extends Geometry>) bindings.get(key);\n                Class<? extends Geometry> newType = getOverrideGeometryType(geometryType, currentType);\n                if (newType != null) {\n                    bindings.put(key, newType);\n                }\n                continue;\n            }\n            Class<?> currentClass = value.getClass();\n            Class<?> storedClass = bindings.get(key);\n            if (storedClass == null) {\n                bindings.put(key, currentClass);\n                continue;\n            }\n            if (storedClass != currentClass) {\n                Class<?> newClass = getOverrideType(currentClass, storedClass);\n                if (newClass != null) {\n                    bindings.put(key, newClass);\n                }\n            }\n        }\n    }\n\n    private static Class<? extends Geometry> getOverrideGeometryType(\n            Class<? extends Geometry> geometryType,\n            Class<? extends Geometry> currentStoredType) {\n        // Don't have anything yet - use what we got\n        if (currentStoredType == null) {\n            return geometryType;\n        }\n        // Already at GeometryCollection - do nothing\n        if (currentStoredType == GeometryCollection.class) {\n            return currentStoredType;\n        }\n        // If they are equal do nothing - what's stored is good\n        if (currentStoredType == geometryType) {\n            return currentStoredType;\n        }\n        // Check if we have MultiPoint and the value is Point etc.\n        if (isMultiVersionOf(currentStoredType, geometryType)) {\n            // If so do nothing - what's stored is good\n            return null;\n        }\n        // Check if the value is multi version of we currently have\n        if (isMultiVersionOf(geometryType, currentStoredType)) {\n            // Then use the multi version\n            return geometryType;\n        }\n        // They weren't the same and they weren't compatible Multi* versions of each other\n        // => Widen to Geometrycollection\n        return GeometryCollection.class;\n    }\n\n    private static boolean isMultiVersionOf(\n            Class<? extends Geometry> a,\n            Class<? extends Geometry> b) {\n        if (a == MultiPoint.class) {\n            return b == Point.class;\n        }\n        if (a == MultiLineString.class) {\n            return b == LineString.class;\n        }\n        if (a == MultiPolygon.class) {\n            return b == Polygon.class;\n        }\n        return false;\n    }\n\n    // TODO: Improve me\n    private static Class<?> getOverrideType(Class<?> currentClass, Class<?> storedClass) {\n        boolean isCurrentNumber = currentClass.isAssignableFrom(Number.class);\n        boolean isStoredNumber = storedClass.isAssignableFrom(Number.class);\n        if (isCurrentNumber && isStoredNumber) {\n            // Int and Double for example\n            // => Just widen to Double\n            if (storedClass == Double.class) {\n                // But it's already Double so don't change anything\n                return null;\n            }\n            return Double.class;\n        }\n        if (isStoredNumber) {\n            // Stored is a number but current isn't\n            // It's hopefully a String, let's use that\n            return currentClass;\n        }\n\n        return null;\n    }\n\n    /**\n     * Replaces feature.geometry fields that are currently of type Map<String, Object>\n     */\n    public static void replaceGeometry(Map<String, Object> geojson,\n            Function<Map<String, Object>, Object> mapper) {\n        String type = GeoJSONUtil.getString(geojson, GeoJSON.TYPE);\n        if (type == null) {\n            throw new IllegalArgumentException(\"Invalid GeoJSON object, missing 'type'\");\n        }\n        switch (type) {\n        case GeoJSON.FEATURE_COLLECTION:\n            replaceGeometryFeatureCollection(geojson, mapper);\n            break;\n        case GeoJSON.FEATURE:\n            replaceGeometryFeature(geojson, mapper);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Not GeoJSON FeatureCollection or Feature\");\n        }\n    }\n\n    /**\n     * Replaces feature.properties values that are currently of type Map<String, Object>\n     */\n    public static void replaceMapProperties(Map<String, Object> geojson,\n            Function<Map<String, Object>, Object> mapper) {\n        String type = GeoJSONUtil.getString(geojson, GeoJSON.TYPE);\n        if (type == null) {\n            throw new IllegalArgumentException(\"Invalid GeoJSON object, missing 'type'\");\n        }\n        switch (type) {\n        case GeoJSON.FEATURE_COLLECTION:\n            replaceMapPropertiesFeatureCollection(geojson, mapper);\n            break;\n        case GeoJSON.FEATURE:\n            replaceMapPropertiesFeature(geojson, mapper);\n            break;\n        default:\n            throw new IllegalArgumentException(\"Not GeoJSON FeatureCollection or Feature\");\n        }\n    }\n\n    private static void replaceGeometryFeatureCollection(Map<String, Object> featureCollection,\n            Function<Map<String, Object>, Object> mapper) {\n        String type = GeoJSONUtil.getString(featureCollection, GeoJSON.TYPE);\n        if (!GeoJSON.FEATURE_COLLECTION.equals(type)) {\n            throw new IllegalArgumentException(\"type was not \" + GeoJSON.FEATURE_COLLECTION);\n        }\n\n        List<Object> features = GeoJSONUtil.getList(featureCollection, GeoJSON.FEATURES);\n        for (int i = 0; i < features.size(); i++) {\n            Map<String, Object> feature = GeoJSONUtil.getMap(features, i);\n            replaceGeometryFeature(feature, mapper);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static void replaceGeometryFeature(Map<String, Object> feature,\n            Function<Map<String, Object>, Object> mapper) {\n        String type = GeoJSONUtil.getString(feature, GeoJSON.TYPE);\n        if (!GeoJSON.FEATURE.equals(type)) {\n            throw new IllegalArgumentException(\"type was not \" + GeoJSON.FEATURE);\n        }\n\n        Object geometry = feature.get(GeoJSON.GEOMETRY);\n        if (geometry != null && geometry instanceof Map) {\n            geometry = mapper.apply((Map<String, Object>) geometry);\n            feature.put(GeoJSON.GEOMETRY, geometry);\n        }\n    }\n\n    private static void replaceMapPropertiesFeatureCollection(Map<String, Object> featureCollection,\n            Function<Map<String, Object>, Object> mapper) {\n        String type = GeoJSONUtil.getString(featureCollection, GeoJSON.TYPE);\n        if (!GeoJSON.FEATURE_COLLECTION.equals(type)) {\n            throw new IllegalArgumentException(\"type was not \" + GeoJSON.FEATURE_COLLECTION);\n        }\n\n        List<Object> features = GeoJSONUtil.getList(featureCollection, GeoJSON.FEATURES);\n        for (int i = 0; i < features.size(); i++) {\n            Map<String, Object> feature = GeoJSONUtil.getMap(features, i);\n            replaceMapPropertiesFeature(feature, mapper);\n        }\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    private static void replaceMapPropertiesFeature(Map<String, Object> feature,\n            Function<Map<String, Object>, Object> mapper) {\n        String type = GeoJSONUtil.getString(feature, GeoJSON.TYPE);\n        if (!GeoJSON.FEATURE.equals(type)) {\n            throw new IllegalArgumentException(\"type was not \" + GeoJSON.FEATURE);\n        }\n\n        Map<String, Object> properties = GeoJSONUtil.getMap(feature, GeoJSON.PROPERTIES);\n        if (properties == null) {\n            return;\n        }\n        for (String key : properties.keySet()) {\n            if (GeoJSONUtil.DEFAULT_GEOMETRY_ATTRIBUTE_NAME.equals(key)) {\n                continue;\n            }\n            Object o = properties.get(key);\n            if (o != null && o instanceof Map) {\n                properties.put(key, mapper.apply((Map<String, Object>) o));\n            }\n        }\n    }\n\n}\n", "CoreMatchers.endsWith;\r\nimport static org.hamcrest.CoreMatchers.startsWith;\r\n\r\nimport gherkin.formatter.ansi.AnsiEscapes;\r\nimport gherkin.formatter.model.Result;\r\n\r\nimport java.io.ByteArrayOutputStream;\r\nimport java.io.PrintStream;\r\nimport java.util.Locale;\r\n\r\nimport org.junit.Test;\r\n\r\npublic class SummaryCounterTest {\r\n    public static final long ONE_MILLI_SECOND = 1000000;\r\n    private static final long ONE_HOUR = 60 * SummaryCounter.ONE_MINUTE;\r\n\r\n    @Test\r\n    public void should_print_zero_scenarios_zero_steps_if_nothing_has_executed() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), startsWith(String.format(\r\n                \"0 Scenarios%n\" +\r\n                \"0 Steps%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_only_print_sub_counts_if_not_zero() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        Result passedResult = createResultWithStatus(Result.PASSED);\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.addStep(passedResult);\r\n        counter.addStep(passedResult);\r\n        counter.addStep(passedResult);\r\n        counter.addScenario(Result.PASSED);\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), startsWith(String.format(\r\n                \"1 Scenarios (1 passed)%n\" +\r\n                \"3 Steps (3 passed)%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_print_sub_counts_in_order_failed_skipped_pending_undefined_passed() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        addOneStepScenario(counter, Result.PASSED);\r\n        addOneStepScenario(counter, Result.FAILED);\r\n        addOneStepScenario(counter, SummaryCounter.PENDING);\r\n        addOneStepScenario(counter, Result.UNDEFINED.getStatus());\r\n        addOneStepScenario(counter, Result.SKIPPED.getStatus());\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), startsWith(String.format(\r\n                \"5 Scenarios (1 failed, 1 skipped, 1 pending, 1 undefined, 1 passed)%n\" +\r\n                \"5 Steps (1 failed, 1 skipped, 1 pending, 1 undefined, 1 passed)%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_print_sub_counts_in_order_failed_skipped_undefined_passed_in_color() {\r\n        SummaryCounter counter = createColorSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        addOneStepScenario(counter, Result.PASSED);\r\n        addOneStepScenario(counter, Result.FAILED);\r\n        addOneStepScenario(counter, SummaryCounter.PENDING);\r\n        addOneStepScenario(counter, Result.UNDEFINED.getStatus());\r\n        addOneStepScenario(counter, Result.SKIPPED.getStatus());\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        String colorSubCounts =\r\n                AnsiEscapes.RED + \"1 failed\" + AnsiEscapes.RESET + \", \" +\r\n                AnsiEscapes.CYAN + \"1 skipped\" + AnsiEscapes.RESET + \", \" +\r\n                AnsiEscapes.YELLOW + \"1 pending\" + AnsiEscapes.RESET + \", \" +\r\n                AnsiEscapes.YELLOW + \"1 undefined\" + AnsiEscapes.RESET + \", \" +\r\n                AnsiEscapes.GREEN + \"1 passed\" + AnsiEscapes.RESET;\r\n        assertThat(baos.toString(), startsWith(String.format(\r\n                \"5 Scenarios (\" + colorSubCounts + \")%n\" +\r\n                \"5 Steps (\" + colorSubCounts + \")%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_print_zero_m_zero_s_if_nothing_has_executed() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), endsWith(String.format(\r\n                \"0m0.000s%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_include_hook_time_and_step_time_has_executed() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.addHookTime(ONE_MILLI_SECOND);\r\n        counter.addStep(new Result(Result.PASSED, ONE_MILLI_SECOND, null));\r\n        counter.addStep(new Result(Result.PASSED, ONE_MILLI_SECOND, null));\r\n        counter.addHookTime(ONE_MILLI_SECOND);\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), endsWith(String.format(\r\n                \"0m0.004s%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_print_minutes_seconds_and_milliseconds() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.addStep(new Result(Result.PASSED, SummaryCounter.ONE_MINUTE, null));\r\n        counter.addStep(new Result(Result.PASSED, SummaryCounter.ONE_SECOND, null));\r\n        counter.addStep(new Result(Result.PASSED, ONE_MILLI_SECOND, null));\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), endsWith(String.format(\r\n                \"1m1.001s%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_print_minutes_instead_of_hours() {\r\n        SummaryCounter counter = createMonochromeSummaryCounter();\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.addStep(new Result(Result.PASSED, ONE_HOUR, null));\r\n        counter.addStep(new Result(Result.PASSED, SummaryCounter.ONE_MINUTE, null));\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), endsWith(String.format(\r\n                \"61m0.000s%n\")));\r\n    }\r\n\r\n    @Test\r\n    public void should_use_locale_for_decimal_separator() {\r\n        SummaryCounter counter = new SummaryCounter(true, Locale.GERMANY);\r\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\r\n\r\n        counter.addStep(new Result(Result.PASSED, SummaryCounter.ONE_MINUTE, null));\r\n        counter.addStep(new Result(Result.PASSED, SummaryCounter.ONE_SECOND, null));\r\n        counter.addStep(new Result(Result.PASSED, ONE_MILLI_SECOND, null));\r\n        counter.printSummary(new PrintStream(baos));\r\n\r\n        assertThat(baos.toString(), endsWith(String.format(\r\n                \"1m1,001s%n\")));\r\n    }\r\n\r\n    private void addOneStepScenario(SummaryCounter counter, String status) {\r\n        counter.addStep(createResultWithStatus(status));\r\n        counter.addScenario(status);\r\n    }\r\n\r\n    private Result createResultWithStatus(String status) {\r\n        return new Result(status, 0l, null);\r\n    }\r\n\r\n    private SummaryCounter createMonochromeSummaryCounter() {\r\n        return new SummaryCounter(true, Locale.US);\r\n    }\r\n\r\n    private SummaryCounter createColorSummaryCounter() {\r\n        return new SummaryCounter(false, Locale.US);\r\n    }\r\n}\r\n", "013 Flow Powered <https://flowpowered.com/>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage com.flowpowered.commons.store;\n\nimport java.io.BufferedInputStream;\nimport java.io.BufferedOutputStream;\nimport java.io.DataInputStream;\nimport java.io.DataOutputStream;\nimport java.io.EOFException;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.util.Iterator;\nimport java.util.Map.Entry;\n\n/**\n * This implements a SimpleStore that is stored in memory. The save and load methods can be used to write the map to a binary file.\n */\npublic class BinaryFileStore extends MemoryStore<Integer> {\n    private Path path;\n    private boolean dirty = true;\n\n    public BinaryFileStore(Path path) {\n        super();\n        this.path = path;\n    }\n\n    public BinaryFileStore() {\n        this(null);\n    }\n\n    public synchronized void setPath(Path path) {\n        this.path = path;\n    }\n\n    public synchronized Path getPath() {\n        return path;\n    }\n\n    @Override\n    public synchronized boolean clear() {\n        dirty = true;\n        return super.clear();\n    }\n\n    @Override\n    public synchronized boolean save() {\n        if (!dirty) {\n            return true;\n        }\n\n        boolean saved = true;\n        DataOutputStream out = null;\n        try {\n            out = new DataOutputStream(new BufferedOutputStream(Files.newOutputStream(path)));\n            Iterator<Entry<String, Integer>> itr = super.getEntrySet().iterator();\n\n            while (itr.hasNext()) {\n                Entry<String, Integer> next = itr.next();\n                out.writeInt(next.getValue());\n                out.writeUTF(next.getKey());\n            }\n        } catch (IOException ioe) {\n            ioe.printStackTrace();\n            saved = false;\n        } finally {\n            try {\n                if (out != null) {\n                    out.close();\n                }\n            } catch (IOException ioe) {\n                ioe.printStackTrace();\n                saved = false;\n            }\n            if (saved) {\n                dirty = false;\n            }\n        }\n        return saved;\n    }\n\n    @Override\n    public synchronized boolean load() {\n        boolean loaded = true;\n        DataInputStream in = null;\n        try {\n            in = new DataInputStream(new BufferedInputStream(Files.newInputStream(path)));\n\n            boolean eof = false;\n            while (!eof) {\n                try {\n                    Integer id = in.readInt();\n                    String key = in.readUTF();\n                    set(key, id);\n                } catch (EOFException eofe) {\n                    eof = true;\n                }\n            }\n        } catch (IOException ioe) {\n            loaded = false;\n        } finally {\n            try {\n                if (in != null) {\n                    in.close();\n                }\n            } catch (IOException ioe) {\n                loaded = false;\n            }\n        }\n        if (loaded) {\n            dirty = false;\n        }\n        return loaded;\n    }\n\n    @Override\n    public synchronized Integer remove(String key) {\n        Integer value = super.remove(key);\n        if (value != null) {\n            dirty = true;\n        }\n        return value;\n    }\n\n    @Override\n    public synchronized Integer set(String key, Integer value) {\n        dirty = true;\n        return super.set(key, value);\n    }\n}\n", "quis.ec.Curve;\nimport de.quisquis.ec.Generator;\n\nimport java.security.InvalidAlgorithmParameterException;\nimport java.security.KeyPair;\nimport java.security.KeyPairGenerator;\nimport java.security.NoSuchAlgorithmException;\nimport java.security.NoSuchProviderException;\nimport java.security.SecureRandom;\n\nimport java.security.spec.ECGenParameterSpec;\n\n/** A JCA-based @link{Generator} implementation.\n *\n * @author Peter Conrad\n */\npublic class BouncyGenerator implements Generator {\n    private final KeyPairGenerator generator;\n\n    /** Constructor defining the curve on which keys are to be used.\n     * @param curve the standardized curve on which to generate keys\n     */\n    public BouncyGenerator(Curve curve) {\n        try {\n            generator = KeyPairGenerator.getInstance(\"EC\", \"BC\");\n            generator.initialize(new ECGenParameterSpec(curve.getIdentifier()),\n                                 new SecureRandom());\n        } catch (NoSuchAlgorithmException | InvalidAlgorithmParameterException\n                 | NoSuchProviderException e) {\n            throw new IllegalStateException(\"Unsupported curve \" + curve + \"?!\");\n        }\n    }\n\n    /** @return a newly generated key pair on this Generator's curve */\n    @Override\n    public KeyPair generate() {\n        return generator.generateKeyPair();\n    }\n}\n", " granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*\n * To change this template, choose Tools | Templates\n * and open the template in the editor.\n */\npackage org.broad.igv.data;\n\nimport org.broad.igv.feature.LocusScore;\nimport org.broad.igv.track.WindowFunction;\n\n/**\n * @author jrobinso\n */\npublic class BasicScore implements LocusScore {\n\n    protected int start;\n    protected int end;\n    protected float score;\n\n    public BasicScore(int start, int end, float score) {\n\n        this.start = start;\n        this.end = end;\n        this.score = score;\n    }\n\n    public BasicScore(BasicScore bs) {\n        this.start = bs.start;\n        this.end = bs.end;\n        this.score = bs.score;\n    }\n\n    public BasicScore copy() {\n        return new BasicScore(this);\n    }\n\n    /**\n     * This method is required by the Tribble interface but not used.  To save space the chromosome is not stored, return null\n     * @return\n     */\n    public String getChr() {\n        return null;\n    }\n\n    @Override\n    public String getContig() {\n        return null;\n    }\n\n    public int getStart() {\n        return start;\n    }\n\n    public float getScore() {\n        return score;\n    }\n\n    public void setStart(int start) {\n        this.start = start;\n    }\n\n    public int getEnd() {\n        return end;\n    }\n\n    public void setEnd(int end) {\n        this.end = end;\n    }\n\n    @Override\n    public String toString() {\n        return String.format(\"BasicScore: %d-%d ; %f\", getStart(), getEnd(), getScore());\n    }\n\n    public String getValueString(double position, WindowFunction windowFunction) {\n        StringBuffer buf = new StringBuffer();\n        buf.append(String.format(\"Value: %g at position %d\",  score, (int)position));\n        if(windowFunction != null) {\n            buf.append(\"<br>Window function: \" + windowFunction);\n        }\n        return buf.toString();\n    }\n\n}\n", ".persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.validation.constraints.NotNull;\nimport javax.validation.constraints.Size;\n\n@Entity\npublic class Device {\n\n  @Id\n  @GeneratedValue\n  private Long id;\n\n  @NotNull\n  @Column(unique = true)\n  @Size(max = 50)\n  private String serialNo;\n\n  public String getSerialNo() {\n    return serialNo;\n  }\n\n  public void setSerialNo(String serialNo) {\n    this.serialNo = serialNo;\n  }\n\n  public Long getId() {\n    return id;\n  }\n\n  public void setId(Long id) {\n    this.id = id;\n  }\n\n  @Override\n  public boolean equals(Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Device device = (Device) o;\n    return Objects.equals(id, device.id) &&\n        Objects.equals(serialNo, device.serialNo);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(id, serialNo);\n  }\n}\n", "ission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal\n in the Software without restriction, including without limitation the rights\n to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n copies of the Software, and to permit persons to whom the Software is\n furnished to do so, subject to the following conditions:\n\n The above copyright notice and this permission notice shall be included in\n all copies or substantial portions of the Software.\n\n THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n THE SOFTWARE.\n */\n\npackage nitezh.ministock.utils;\n\nimport org.junit.Test;\n\nimport java.text.ParseException;\nimport java.util.Locale;\n\nimport static org.junit.Assert.assertEquals;\n\n\npublic class NumberToolsTests {\n\n    @Test\n    public void trimWithNumberLessThan10AndScale1() throws ParseException {\n        // Arrange\n        String expected = \"9.1\";\n\n        // Act\n        String result = NumberTools.trim(\"9.1\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan10AndScale2() throws ParseException {\n        // Arrange\n        String expected = \"8.99\";\n\n        // Act\n        String result = NumberTools.trim(\"8.99\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan10AndScale4() throws ParseException {\n        // Arrange\n        String expected = \"2.5900\";\n\n        // Act\n        String result = NumberTools.trim(\"2.5900\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan10AndScale5() throws ParseException {\n        // Arrange\n        String expected = \"9.3451\";\n\n        // Act\n        String result = NumberTools.trim(\"9.34512\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan100AndScale1() throws ParseException {\n        // Arrange\n        String expected = \"12.30\";\n\n        // Act\n        String result = NumberTools.trim(\"12.3\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan100AndScale2() throws ParseException {\n        // Arrange\n        String expected = \"21.23\";\n\n        // Act\n        String result = NumberTools.trim(\"21.23\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan100AndScale4() throws ParseException {\n        // Arrange\n        String expected = \"43.26\";\n\n        // Act\n        String result = NumberTools.trim(\"43.2572\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n\n    @Test\n    public void trimWithNumberLessThan100AndScale5() throws ParseException {\n        // Arrange\n        String expected = \"98.33\";\n\n        // Act\n        String result = NumberTools.trim(\"98.33442\", Locale.US);\n\n        // Assert\n        assertEquals(expected, result);\n    }\n}\n", "uttons.api.ButtonsPlugin;\nimport tehnut.buttons.api.IWidgetPlugin;\nimport tehnut.buttons.api.IWidgetRegistry;\nimport tehnut.buttons.api.WidgetTexture;\n\nimport static joshie.harvest.core.lib.HFModInfo.MODID;\n\n@ButtonsPlugin\npublic class Buttons extends IWidgetPlugin.Base {\n    public static final ResourceLocation RESOURCE = new ResourceLocation(MODID, \"textures/gui/gui_widgets.png\");\n    public static final WidgetTexture BLANK = new WidgetTexture(\n            new ResourceLocation(\"buttons\", \"textures/gui_widgets.png\"),\n            0,\n            0,\n            0,\n            0\n    );\n\n    @Override\n    public void register(IWidgetRegistry registry) {\n        registry.addUtilityButton(new ButtonSeason());\n        registry.addUtilityButton(new ButtonWeather());\n    }\n}\n", " {\n\t\tSystem.out.println(removeElement(new int[] { 3, 2, 2, 3 }, 3));\n\t\tSystem.out.println(removeElement(new int[] { 0, 1, 2, 2, 3, 0, 4, 2 }, 2));\n\t}\n\n\tpublic static int removeElement(int[] nums, int val) {\n\n\t}\n\n}\n", "entation.\n\n*/\n\npublic class Instrumentation\n{\n\t\n\tprivate int queryExecutionTime = 0;\n\tprivate int requestHandlingTime = 0;\n\tprivate int responseWriteTime = 0;\n\tprivate int pageContextWriteTime = 0;\n\t\n\t\n\t\n\t/**\n\t\n\t* set the query excecution of the request.\n\t\n\t* @param queryExecutionTime  Query execution time for the request.\n\t\n\t*/\n\t\n\tpublic void setQueryExecutionTime(int queryExecutionTime)\n\t{\n\t\tthis.queryExecutionTime = queryExecutionTime;\n\t}\n\t\n\t/**\n\t\n\t* get the query excecution of the request.\n\t\n\t* @return Returns the query execution time for the request.\n\t\n\t*/\n\t\n\tpublic int getQueryExecutionTime()\n\t{\n\t\treturn queryExecutionTime;\n\t}\n\t\n\t/**\n\t\n\t* set the request handling time.\n\t\n\t* @param requestHandlingTime  Request handling time.\n\t\n\t*/\n\t\n\tpublic void setRequestHandlingTime(int requestHandlingTime)\n\t{\n\t\tthis.requestHandlingTime = requestHandlingTime;\n\t}\n\t\n\t/**\n\t\n\t* get the request handling time.\n\t\n\t* @return Returns the request handling time.\n\t\n\t*/\n\t\n\tpublic int getRequestHandlingTime()\n\t{\n\t\treturn requestHandlingTime;\n\t}\n\t\n\t/**\n\t\n\t* set the response write time.\n\t\n\t* @param responseWriteTime  Response write time.\n\t\n\t*/\n\t\n\tpublic void setResponseWriteTime(int responseWriteTime)\n\t{\n\t\tthis.responseWriteTime = responseWriteTime;\n\t}\n\t\n\t/**\n\t\n\t* get the response write time.\n\t\n\t* @return Returns the response write time.\n\t\n\t*/\n\t\n\tpublic int getResponseWriteTime()\n\t{\n\t\treturn responseWriteTime;\n\t}\n\t\n\t/**\n\t\n\t* set the page context write time.\n\t\n\t* @param pageContextWriteTime  Page context write time.\n\t\n\t*/\n\t\n\tpublic void setPageContextWriteTime(int pageContextWriteTime)\n\t{\n\t\tthis.pageContextWriteTime = pageContextWriteTime;\n\t}\n\t\n\t/**\n\t\n\t* get the page context write time.\n\t\n\t* @return Returns the page context write time.\n\t\n\t*/\n\t\n\tpublic int getPageContextWriteTime()\n\t{\n\t\treturn pageContextWriteTime;\n\t}\n\t\n}\n", "cense\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage fr.azelart.artnetstack.domain.enums;\n\n/**\n * Communication Type Enumeration.\n * @author Corentin Azelart.\n *\n */\npublic enum NetworkCommunicationTypeEnum {\n\n\t/** BROADCAST. */\n\tBROADCAST,\n\n\t/** UNICAST. */\n\tUNICAST,\n}\n", ";\n\nimport jfdi.logic.events.AddTaskDoneEvent;\nimport jfdi.logic.events.AddTaskFailedEvent;\nimport jfdi.storage.apis.TaskAttributes;\nimport jfdi.ui.Constants;\nimport jfdi.ui.Constants.ListStatus;\nimport jfdi.ui.Constants.MsgType;\n\npublic class AddHandler extends CommandHandler {\n\n    private static AddHandler instance = new AddHandler();\n\n    private AddHandler() {\n    }\n\n    public static AddHandler getInstance() {\n        return instance;\n    }\n\n    @Subscribe\n    public void handleAddTaskDoneEvent(AddTaskDoneEvent e) {\n\n        TaskAttributes task = e.getTask();\n\n        switch (controller.displayStatus) {\n            case INCOMPLETE:\n                controller.switchContext(ListStatus.INCOMPLETE, true);\n                break;\n            case OVERDUE:\n                if (task.isOverdue()) {\n                    controller.switchContext(ListStatus.OVERDUE, true);\n                } else {\n                    controller.switchContext(ListStatus.INCOMPLETE, true);\n                }\n                break;\n            case UPCOMING:\n                if (task.isUpcoming()) {\n                    controller.switchContext(ListStatus.UPCOMING, true);\n                } else {\n                    controller.switchContext(ListStatus.INCOMPLETE, true);\n                }\n                break;\n            case ALL:\n                controller.appendTaskToDisplayList(task, true);\n                break;\n            case COMPLETE:\n                controller.switchContext(ListStatus.INCOMPLETE, true);\n                break;\n            case SURPRISE:\n                controller.switchContext(ListStatus.INCOMPLETE, true);\n                break;\n            case SEARCH:\n                controller.switchContext(ListStatus.INCOMPLETE, true);\n                break;\n            default:\n                break;\n        }\n\n        controller.updateNotiBubbles();\n        int index = findCurrentIndex(task);\n        controller.listMain.scrollTo(index); // not working properly for\n                                             // overdue, upcoming and search\n                                             // when index > 5\n        logger.fine(String.format(Constants.LOG_ADDED_SUCCESS, task.getId()));\n        controller.relayFb(String.format(Constants.CMD_SUCCESS_ADDED, index, task.getDescription()), MsgType.SUCCESS);\n    }\n\n    @Subscribe\n    public void handleAddTaskFailEvent(AddTaskFailedEvent e) {\n\n        switch (e.getError()) {\n            case EMPTY_DESCRIPTION:\n                controller.relayFb(Constants.CMD_ERROR_CANT_ADD_EMPTY, MsgType.ERROR);\n                logger.fine(String.format(Constants.LOG_ADD_FAIL_EMPTY));\n                break;\n            case DUPLICATED_TASK:\n                controller.relayFb(Constants.CMD_ERROR_CANT_ADD_DUPLICATE, MsgType.ERROR);\n                logger.fine(String.format(Constants.LOG_ADD_FAIL_DUPLICATE));\n                break;\n            default:\n                break;\n        }\n    }\n\n}\n", "amework.web.bind.annotation.RequestMapping;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.context.request.NativeWebRequest;\nimport java.util.Optional;\nimport javax.annotation.Generated;\n\n@Generated(value = \"org.openapitools.codegen.languages.SpringCodegen\", date = \"2022-02-13T02:39:21.029908Z[Etc/UTC]\")\n@Controller\n@RequestMapping(\"${openapi.swaggyJenkins.base-path:}\")\npublic class JobApiController implements JobApi {\n\n    private final NativeWebRequest request;\n\n    @Autowired\n    public JobApiController(NativeWebRequest request) {\n        this.request = request;\n    }\n\n    @Override\n    public Optional<NativeWebRequest> getRequest() {\n        return Optional.ofNullable(request);\n    }\n\n}\n", "s;\n\nimport android.os.Parcel;\nimport android.os.Parcelable;\n\npublic class Point implements Parcelable\n{\n    public Point(){}\n    public Point(Point p0){}\n    public Point(int p0, int p1){}\n    public String toString(){ return null; }\n    public boolean equals(Object p0){ return false; }\n    public final boolean equals(int p0, int p1){ return false; }\n    public final void negate(){}\n    public final void offset(int p0, int p1){}\n    public int describeContents(){ return 0; }\n    public int hashCode(){ return 0; }\n    public int x = 0;\n    public int y = 0;\n    public static Parcelable.Creator<Point> CREATOR = null;\n    public void readFromParcel(Parcel p0){}\n    public void set(int p0, int p1){}\n    public void writeToParcel(Parcel p0, int p1){}\n}\n", " game.Player;\nimport java.util.ArrayList;\nimport java.util.List;\nimport view.Point;\n\n/**\n *\n * @author Robbert\n */\npublic class Queen extends Piece {\n    \n    public Queen(Player player) {\n        super(player);\n    }\n\n    @Override\n    public List<List<PlayerField>> getLegalFieldsInOrder(PlayerBoard pb, PlayerField from) {\n        Coordinate c = from.getCoordinate();\n        List<List<PlayerField>> listOfFields = new ArrayList<List<PlayerField>>();\n\n        Rook tmpRook = new Rook();\n        listOfFields.addAll(tmpRook.getLegalFieldsInOrder(pb, from));\n        Bishop tmpBishop = new Bishop();\n        listOfFields.addAll(tmpBishop.getLegalFieldsInOrder(pb, from));\n        \n        return listOfFields;\n    }\n\n\t@Override\n\tpublic String getLetter() {\n\t\treturn \"Q\";\n\t}\n\n\t@Override\n\tpublic Point[] getPolygon() {\n\t\treturn new Point[] {\n\t\t\tnew Point(-0.2,0),\n\t\t\tnew Point(-0.5,0.5),\n\t\t\tnew Point(-0.1,0),\n\t\t\tnew Point(0,0.5),\n\t\t\tnew Point(0.1,0),\n\t\t\tnew Point(0.5,0.5),\n\t\t\tnew Point(0.2,0),\n\t\t\tnew Point(0.5,-0.5),\n\t\t\tnew Point(-0.5,-0.5)\n\t\t};\n\t}\n}\n", "ivate String actualValue;\r\n\t\r\n\tpublic StringValue(Context context, String actualValue) {\r\n\t\tsuper(context);\r\n\t\tthis.actualValue = actualValue;\r\n\t}\r\n\t\r\n\tpublic String getActualValue() {\r\n\t\treturn actualValue;\r\n\t}\r\n\t\r\n}\r\n", "r;\n\nimport org.joda.money.CurrencyUnit;\nimport org.joda.money.Money;\nimport org.joda.time.DateTime;\nimport org.joda.time.DateTimeZone;\n\nimport java.util.Map;\n\nimport javax.inject.Singleton;\n\nimport dagger.Module;\nimport dagger.Provides;\n\n/**\n * Module providing dependencies for Google's GSON library.\n */\n@Module\npublic class GsonModule {\n    @Provides\n    @Singleton\n    GsonBuilder provideDefaultGsonBuilder() {\n        GsonBuilder gsonBuilder = new GsonBuilder();\n        gsonBuilder.registerTypeAdapter(Money.class, new MoneyTypeConverter());\n        gsonBuilder.registerTypeAdapter(CurrencyUnit.class, new CurrencyUnitTypeConverter());\n        gsonBuilder.registerTypeAdapter(DateTime.class, new DateTimeTypeConvertor());\n        gsonBuilder.registerTypeAdapter(DateTimeZone.class, new DateTimeZoneTypeConvertor());\n        gsonBuilder.registerTypeAdapter(Map.class, new JsonToMapDeserializer());\n        return gsonBuilder;\n    }\n\n    @Provides\n    @Singleton\n    Gson provideGson(GsonBuilder gsonBuilder) {\n        return gsonBuilder.create();\n    }\n}\n", " Created by yo1000 on 2016/07/10.\n */\npublic class FizzBuzzTest {\n    @Test\n    public void fizzTest() {\n        FizzBuzz fizzBuzz = new FizzBuzz();\n\n        Assert.assertEquals(fizzBuzz.fizz(1), \"\");\n        Assert.assertEquals(fizzBuzz.fizz(2), \"\");\n        Assert.assertEquals(fizzBuzz.fizz(3), \"Fizz\");\n        Assert.assertEquals(fizzBuzz.fizz(4), \"\");\n        Assert.assertEquals(fizzBuzz.fizz(5), \"\");\n        Assert.assertEquals(fizzBuzz.fizz(6), \"Fizz\");\n        Assert.assertEquals(fizzBuzz.fizz(15), \"Fizz\");\n    }\n\n    @Test\n    public void buzzTest() {\n        FizzBuzz fizzBuzz = new FizzBuzz();\n\n        Assert.assertEquals(fizzBuzz.buzz(1), \"\");\n        Assert.assertEquals(fizzBuzz.buzz(2), \"\");\n        Assert.assertEquals(fizzBuzz.buzz(3), \"\");\n        Assert.assertEquals(fizzBuzz.buzz(4), \"\");\n        Assert.assertEquals(fizzBuzz.buzz(5), \"Buzz\");\n        Assert.assertEquals(fizzBuzz.buzz(6), \"\");\n        Assert.assertEquals(fizzBuzz.buzz(15), \"Buzz\");\n    }\n\n    @Test\n    public void fizzBuzzTest() {\n        FizzBuzz fizzBuzz = new FizzBuzz();\n\n        Assert.assertEquals(fizzBuzz.fizzBuzz(1), \"1\");\n        Assert.assertEquals(fizzBuzz.fizzBuzz(2), \"2\");\n        Assert.assertEquals(fizzBuzz.fizzBuzz(3), \"Fizz\");\n        Assert.assertEquals(fizzBuzz.fizzBuzz(4), \"4\");\n        Assert.assertEquals(fizzBuzz.fizzBuzz(5), \"Buzz\");\n        Assert.assertEquals(fizzBuzz.fizzBuzz(6), \"Fizz\");\n        Assert.assertEquals(fizzBuzz.fizzBuzz(15), \"FizzBuzz\");\n    }\n}\n", "nse agreements.  See the NOTICE file\n       distributed with this work for additional information\n       regarding copyright ownership.  The ASF licenses this file\n       to you under the Apache License, Version 2.0 (the\n       \"License\"); you may not use this file except in compliance\n       with the License.  You may obtain a copy of the License at\n\n         http://www.apache.org/licenses/LICENSE-2.0\n\n       Unless required by applicable law or agreed to in writing,\n       software distributed under the License is distributed on an\n       \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n       KIND, either express or implied.  See the License for the\n       specific language governing permissions and limitations\n       under the License.\n */\n\npackage com.icitic.wficsapp;\n\nimport android.app.Dialog;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\nimport android.os.Message;\nimport android.view.Gravity;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.Window;\nimport android.view.WindowManager;\nimport android.widget.LinearLayout;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport org.apache.cordova.*;\nimport org.json.JSONException;\n\nimport asp.citic.ptframework.PTFramework;\nimport asp.citic.ptframework.PTFrameworkListener;\nimport asp.citic.ptframework.common.constants.PTConfig;\nimport asp.citic.ptframework.common.constants.PTFrameworkConstants;\nimport asp.citic.ptframework.logger.PTLogger;\nimport asp.citic.ptframework.message.PTMessageCenter;\nimport asp.citic.ptframework.plugin.unzip.ProgressActivity;\n\npublic class MainActivity extends CordovaActivity implements PTFrameworkListener.CustomEventListener{\n\n    private String TAG = \"MainActivity\";\n    private String url = \"file:///\" + PTFrameworkConstants.PTResourceConstant.PATH_RELEASE+\"index.html\";\n    protected Dialog loadingDialog;\n    private Handler mHandler = new Handler(){\n        @Override\n        public void handleMessage(Message msg) {\n            super.handleMessage(msg);\n            switch (msg.what){\n                case 0:\n                    Toast.makeText(MainActivity.this,\"\u8d44\u6e90\u538b\u7f29\u5305\u4e3a\u7a7a\",Toast.LENGTH_LONG).show();\n                    break;\n                case 1:\n                    increModule();\n                    break;\n                case 2:\n                    //\u9690\u85cf\u8fdb\u5ea6\u6761\n                    dismissDialog();\n                    loadUrl(url);\n                    break;\n            }\n        }\n    };\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        PTLogger.debug(TAG,\"\u8fdb\u5165MainActivity\");\n        loadingDialog = createLoadingDialog(MainActivity.this,\"\u9a8c\u8bc1\u8d44\u6e90\u5b89\u5168\");\n        //\u534f\u5546\u79d8\u94a5\n        PTFramework.communicationSecurityModel();\n        Bundle extras = getIntent().getExtras();\n        if (extras != null && extras.getBoolean(\"cdvStartInBackground\", false)) {\n            moveTaskToBack(true);\n        }\n        PTMessageCenter.addListener(this);\n        if (asp.citic.ptframework.BuildConfig.PUB_TYPE == PTConfig.PUB_DEBUG){\n            loadUrl(launchUrl);\n        }else{\n            new Thread() {\n                @Override\n                public void run() {\n                    super.run();\n                    //\u89e3\u538b\u6570\u636e\u5305\n                    PTFramework.unzipModel();\n                }\n            }.start();\n        }\n    }\n\n    @Override\n    protected void onActivityResult(int requestCode, int resultCode, Intent intent) {\n        super.onActivityResult(requestCode, resultCode, intent);\n        if (resultCode == 1001){\n            increModule();\n        }\n    }\n\n    /**\n     * \u8c03\u7528\u589e\u91cf\u66f4\u65b0\u6a21\u5757\n     */\n    private void increModule() {\n        //\u663e\u793a\u8fdb\u5ea6\u6761\n        showDialog();\n        new Thread() {\n            @Override\n            public void run() {\n                super.run();\n                //\u8d44\u6e90\u5b89\u5168\u548c\u589e\u91cf\u66f4\u65b0\n                PTFramework.resourceSecurityModule();\n                PTFramework.incrementalUpdateModule();\n\n            }\n        }.start();\n    }\n    public static Dialog createLoadingDialog(Context context, String msg) {\n        LayoutInflater inflater = LayoutInflater.from(context);\n        View v = inflater.inflate(R.layout.dialog_loading, null);// \u5f97\u5230\u52a0\u8f7dview\n        LinearLayout layout = (LinearLayout) v\n                .findViewById(R.id.dialog_loading_view);// \u52a0\u8f7d\u5e03\u5c40\n        TextView tipTextView = (TextView) v.findViewById(R.id.tipTextView);// \u63d0\u793a\u6587\u5b57\n        tipTextView.setText(msg);// \u8bbe\u7f6e\u52a0\u8f7d\u4fe1\u606f\n\n        Dialog loadingDialog = new Dialog(context, R.style.MyDialogStyle);// \u521b\u5efa\u81ea\u5b9a\u4e49\u6837\u5f0fdialog\n        loadingDialog.setCancelable(true); // \u662f\u5426\u53ef\u4ee5\u6309\u201c\u8fd4\u56de\u952e\u201d\u6d88\u5931\n        loadingDialog.setCanceledOnTouchOutside(false); // \u70b9\u51fb\u52a0\u8f7d\u6846\u4ee5\u5916\u7684\u533a\u57df\n        loadingDialog.setContentView(layout, new LinearLayout.LayoutParams(\n                LinearLayout.LayoutParams.MATCH_PARENT,\n                LinearLayout.LayoutParams.MATCH_PARENT));// \u8bbe\u7f6e\u5e03\u5c40\n        /**\n         *\u5c06\u663e\u793aDialog\u7684\u65b9\u6cd5\u5c01\u88c5\u5728\u8fd9\u91cc\u9762\n         */\n        Window window = loadingDialog.getWindow();\n        WindowManager.LayoutParams lp = window.getAttributes();\n        lp.width = WindowManager.LayoutParams.MATCH_PARENT;\n        lp.height = WindowManager.LayoutParams.WRAP_CONTENT;\n        window.setGravity(Gravity.CENTER);\n        window.setAttributes(lp);\n        window.setWindowAnimations(R.style.PopWindowAnimStyle);\n        return loadingDialog;\n    }\n\n    /**\n     * \u663e\u793adialog\n     *\n     */\n    public void showDialog() {\n        if (loadingDialog != null && !loadingDialog.isShowing()) {\n            loadingDialog.show();\n        }\n    }\n    /**\n     * \u5173\u95eddialog\n     *\n     */\n    public void dismissDialog() {\n        if (loadingDialog != null && loadingDialog.isShowing()) {\n            loadingDialog.dismiss();\n            loadingDialog = null;\n        }\n    }\n    @Override\n    public void onCustomEvent(int event, Object obj) throws JSONException {\n        PTLogger.info(TAG, \"\u5ba2\u6237\u7aef\u6536\u5230\u7684\u4e8b\u4ef6ID: \" + String.valueOf(event));\n        switch (event){\n            case PTMessageCenter.EVENT_CONSULTKEY_CHANGE:\n                break;\n            case PTMessageCenter.EVENT_EMPTY_ZIPPACK:\n                //\u4e0d\u53bb\u89e3\u538b\n                mHandler.sendEmptyMessage(0);\n                break;\n            case PTMessageCenter.EVENT_NO_UNZIP:\n                //\u4e0d\u53bb\u89e3\u538b\n                mHandler.sendEmptyMessage(1);\n                break;\n            case PTMessageCenter.EVENT_UNZIP_START:\n                //\u5f00\u59cb\u89e3\u538b\n                Intent intent = new Intent(MainActivity.this,ProgressActivity.class);\n                startActivityForResult(intent,1000);\n                break;\n            case PTMessageCenter.EVENT_CHECK_FILELIST:\n                int status = (Integer) obj;\n                if (status == PTFrameworkConstants.PTCheckStatusConstant.CHECK_FAILED) {\n                    PTLogger.info(TAG, \"\u5faa\u73af\u9a8c\u7b7e\u5931\u8d25: \" + String.valueOf(event));\n                }else{\n                    PTLogger.info(TAG, \"\u5faa\u73af\u9a8c\u7b7e\u6210\u529f\uff0c\u52a0\u8f7drelease\u4e0b\u7684index\u6587\u4ef6\uff1a\" + url);\n                }\n                mHandler.sendEmptyMessage(2);\n                break;\n        }\n    }\n\n    @Override\n    public void onDestroy() {\n        super.onDestroy();\n        dismissDialog();\n        PTMessageCenter.removeListener(this);\n    }\n}\n", "k.GlobalScreen;\nimport org.jnativehook.NativeHookException;\nimport org.jnativehook.keyboard.NativeKeyEvent;\nimport org.jnativehook.keyboard.NativeKeyListener;\nimport org.jnativehook.mouse.NativeMouseEvent;\nimport org.jnativehook.mouse.NativeMouseInputListener;\nimport org.mn.dropzone.eventlistener.DropzoneDragEvent;\nimport org.mn.dropzone.eventlistener.DropzoneDragEventListener;\nimport org.mn.dropzone.util.Util;\n\nimport javafx.application.Platform;\nimport javafx.embed.swing.JFXPanel;\nimport javafx.scene.Group;\nimport javafx.scene.Scene;\nimport javafx.scene.image.ImageView;\nimport javafx.scene.paint.Color;\n\n/**\n * Dropzone for SDS\n * \n * @author Michael Netter\n *\n */\npublic class DropzonePopOver implements NativeMouseInputListener, NativeKeyListener {\n\n\tpublic static final int WIDTH = 330;\n\tpublic static final int HEIGHT = 140;\n\t\n\tpublic static final int POPOVER_TEXT_SIZE_DEFAULT = 12;\n\tpublic static final int POPOVER_TEXT_SIZE_LARGE = 16;\n\tpublic static final double POPOVER_OPACITY = 0.88;\n\n\tpublic static final Color TEXT_COLOR_DEFAULT = Color.rgb(220, 220, 220);\n\tpublic static final Color TEXT_COLOR_HOVERED = Color.rgb(120, 120, 120);\n\t\n\tpublic static final int POPOVER_DURATION = 3500;\n\n\tprivate JFXPanel fxPanel;\n\tprivate DropzonePopOverUI popOverUI;\n\n\tprivate boolean isCtrlKeyPressed = false;\n\tprivate boolean isAltKeyPressed = false;\n\n\t/**\n\t * \n\t * @param pos\n\t */\n\tpublic DropzonePopOver() {\n\t\tfxPanel = new JFXPanel();\n\t\tinitUI();\n\t\tinitNativeMouseMotionListener();\n\n\t\t// show hide once to fix position bug\n\t\tpopOverUI.showPopOver(false);\n\t\tpopOverUI.hidePopOver();\n\t}\n\n\t/**\n\t * Use jnativehook to detect mouse drag events and show popover\n\t */\n\tprivate void initNativeMouseMotionListener() {\n\t\ttry {\n\t\t\tGlobalScreen.registerNativeHook();\n\t\t} catch (NativeHookException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tGlobalScreen.addNativeMouseMotionListener(this);\n\t\tGlobalScreen.addNativeMouseListener(this);\n\t\tGlobalScreen.addNativeKeyListener(this);\n\t}\n\n\t/**\n\t * Init JavaFX components\n\t */\n\tprivate void initUI() {\n\t\t// Run on the JavaFX thread\n\t\tPlatform.runLater(new Runnable() {\n\t\t\t@Override\n\t\t\tpublic void run() {\n\t\t\t\tinitFX(fxPanel);\n\t\t\t}\n\t\t});\n\t\tpopOverUI = new DropzonePopOverUI(this);\n\n\t}\n\n\t/**\n\t * Init JFXPanel which serves as a bridge between Swing and JavaFX\n\t * \n\t * @param fxPanel\n\t */\n\tprivate void initFX(JFXPanel fxPanel) {\n\t\t// This method is invoked on the JavaFX thread\n\t\tGroup root = new Group();\n\t\tScene scene = new Scene(root, Color.ALICEBLUE);\n\t\tfxPanel.setScene(scene);\n\t}\n\n\tpublic JFXPanel getJFXPanel() {\n\t\treturn fxPanel;\n\t}\n\n\tpublic boolean isCtrlKeyPressed() {\n\t\treturn isCtrlKeyPressed;\n\t}\n\tpublic boolean isAltKeyPressed() {\n\t\treturn isAltKeyPressed;\n\t}\n\n\t/**\n\t * Show popover with given message and icon\n\t */\n\tpublic void showMessage(String msg, ImageView icon, Color textColor, int textSize) {\n\t\tpopOverUI.showPopOver(msg, icon, textColor, textSize);\n\t}\n\n\t/*\n\t * Listeners #############################################################\n\t */\n\tprivate EventListenerList listeners = new EventListenerList();\n\n\tpublic void addDragEventListener(DropzoneDragEventListener listener) {\n\t\tlisteners.add(DropzoneDragEventListener.class, listener);\n\t}\n\n\t/**\n\t * Notify Listeners of a date data change\n\t * \n\t * @param event\n\t */\n\tprotected synchronized void notifyDragEventListener(DropzoneDragEvent event) {\n\t\tfor (DropzoneDragEventListener l : listeners.getListeners(DropzoneDragEventListener.class)) {\n\t\t\tl.handleDragEvent(event);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void nativeMouseClicked(NativeMouseEvent nativeEvent) {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic void nativeMousePressed(NativeMouseEvent nativeEvent) {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic void nativeMouseReleased(NativeMouseEvent nativeEvent) {\t\n\t\t// check if ctrl is pressed\n\t\tisCtrlKeyPressed = (nativeEvent.getModifiers() & NativeKeyEvent.CTRL_MASK) > 0;\n\t\tisAltKeyPressed = (nativeEvent.getModifiers() & NativeKeyEvent.ALT_MASK) > 0;\n\t\tpopOverUI.hidePopOver();\n\t}\n\n\t@Override\n\tpublic void nativeMouseMoved(NativeMouseEvent nativeEvent) {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic void nativeMouseDragged(NativeMouseEvent nativeEvent) {\n\t\tif (Util.isInActivationZone(nativeEvent)) {\n\t\t\t// trigger show popover\n\t\t\tpopOverUI.showPopOver(false);\n\t\t}\n\t}\n\n\t@Override\n\tpublic void nativeKeyTyped(NativeKeyEvent nativeEvent) {\n\t\t// do nothing\n\t}\n\n\t@Override\n\tpublic void nativeKeyPressed(NativeKeyEvent nativeEvent) {\n\t\tif (nativeEvent.getKeyCode() == NativeKeyEvent.VC_CONTROL) {\n\t\t\tisCtrlKeyPressed = true;\n\t\t}\n\t\tif (nativeEvent.getKeyCode() == NativeKeyEvent.VC_ALT) {\n\t\t\tisAltKeyPressed = true;\n\t\t}\n\t}\n\n\t@Override\n\tpublic void nativeKeyReleased(NativeKeyEvent nativeEvent) {\n\t\tif (nativeEvent.getKeyCode() == NativeKeyEvent.VC_CONTROL) {\n\t\t\tisCtrlKeyPressed = false;\n\t\t}\n\t\tif (nativeEvent.getKeyCode() == NativeKeyEvent.VC_ALT) {\n\t\t\tisAltKeyPressed = false;\n\t\t}\n\t}\n\n}", "JMenu;\r\nimport javax.swing.JMenuBar;\r\nimport javax.swing.JMenuItem;\r\n\r\nimport java.awt.GridBagLayout;\r\nimport javax.swing.JPanel;\r\n\r\nimport com.runetooncraft.warpigeon.pigionsdk.*;\r\n\r\nimport java.awt.GridBagConstraints;\r\nimport java.awt.Insets;\r\nimport java.awt.event.ActionEvent;\r\nimport java.awt.event.ActionListener;\r\n\r\npublic class SDKFrame extends JFrame {\r\n\tprivate static final long serialVersionUID = 1L;\r\n\tpublic GridBagLayout gridBagLayout;\r\n\tpublic JPanel GamePanel, RightSidePanel;\r\n\tpublic SDKBotPanel BottomPanel;\r\n\tpublic SDKTopRightPanel TopRightPanel;\r\n\tpublic JPanel TileSelection = new TileSelection();\r\n\tpublic Newlevel newlevel = new Newlevel();\r\n\tpublic OpenLevel openlevel = new OpenLevel();\r\n\tpublic ExpandLevel expandLevel = new ExpandLevel();\r\n\tpublic JMenuItem mntmSave = new JMenuItem(\"Save\");\r\n\tpublic JMenuItem OpenLevel, AddLayer, DeleteLayer, mntmNewTile, mntmExpand;\r\n\tpublic JMenu mnLevel;\r\n\tpublic JMenu mnRenderLayers;\r\n\tpublic SDKTopPanel TopPanel;\r\n\t\r\n\tpublic SDKFrame() {\r\n\t\tgridBagLayout = new GridBagLayout();\r\n\t\tgridBagLayout.columnWidths = new int[]{818, 600, 0};\r\n\t\tgridBagLayout.rowHeights = new int[]{100, 457, 100, 0};\r\n\t\tgridBagLayout.columnWeights = new double[]{1.0, 1.0, Double.MIN_VALUE};\r\n\t\tgridBagLayout.rowWeights = new double[]{1.0, 1.0, 1.0, Double.MIN_VALUE};\r\n\t\tgetContentPane().setLayout(gridBagLayout);\r\n\t\t\r\n\t\tTopPanel = new SDKTopPanel();\r\n\t\tGridBagConstraints gbc_TopPanel = new GridBagConstraints();\r\n\t\tgbc_TopPanel.insets = new Insets(0, 0, 5, 5);\r\n\t\tgbc_TopPanel.fill = GridBagConstraints.BOTH;\r\n\t\tgbc_TopPanel.gridx = 0;\r\n\t\tgbc_TopPanel.gridy = 0;\r\n\t\tgetContentPane().add(TopPanel, gbc_TopPanel);\r\n\t\t\r\n\t\tTopRightPanel = new SDKTopRightPanel();\r\n\t\tGridBagConstraints gbc_TopRightPanel = new GridBagConstraints();\r\n\t\tgbc_TopRightPanel.insets = new Insets(0, 0, 5, 0);\r\n\t\tgbc_TopRightPanel.fill = GridBagConstraints.BOTH;\r\n\t\tgbc_TopRightPanel.gridx = 1;\r\n\t\tgbc_TopRightPanel.gridy = 0;\r\n\t\tgetContentPane().add(TopRightPanel, gbc_TopRightPanel);\r\n\t\t\r\n\t\tGamePanel = new JPanel();\r\n\t\tGridBagConstraints gbc_GamePanel = new GridBagConstraints();\r\n\t\tgbc_GamePanel.insets = new Insets(0, 0, 5, 5);\r\n\t\tgbc_GamePanel.fill = GridBagConstraints.BOTH;\r\n\t\tgbc_GamePanel.gridx = 0;\r\n\t\tgbc_GamePanel.gridy = 1;\r\n\t\tgetContentPane().add(GamePanel, gbc_GamePanel);\r\n\t\t\r\n\t\tRightSidePanel = TileSelection;\r\n\t\tGridBagConstraints gbc_RightSidePanel = new GridBagConstraints();\r\n\t\tgbc_RightSidePanel.gridheight = 2;\r\n\t\tgbc_RightSidePanel.fill = GridBagConstraints.BOTH;\r\n\t\tgbc_RightSidePanel.gridx = 1;\r\n\t\tgbc_RightSidePanel.gridy = 1;\r\n\t\tgetContentPane().add(RightSidePanel, gbc_RightSidePanel);\r\n\t\t\r\n\t\tBottomPanel = new SDKBotPanel();\r\n\t\tGridBagConstraints gbc_BottomPanel = new GridBagConstraints();\r\n\t\tgbc_BottomPanel.insets = new Insets(0, 0, 0, 5);\r\n\t\tgbc_BottomPanel.fill = GridBagConstraints.BOTH;\r\n\t\tgbc_BottomPanel.gridx = 0;\r\n\t\tgbc_BottomPanel.gridy = 2;\r\n\t\tgetContentPane().add(BottomPanel, gbc_BottomPanel);\r\n\t\t\r\n\t\tJMenuBar menuBar = new JMenuBar();\r\n\t\tsetJMenuBar(menuBar);\r\n\t\t\r\n\t\tJMenu mnFile = new JMenu(\"File\");\r\n\t\tmenuBar.add(mnFile);\r\n\t\t\r\n\t\tJMenuItem mntmNewLevel = new JMenuItem(\"New Level\");\r\n\t\tmntmNewLevel.addActionListener(new ActionListener() {\r\n\t\t\tpublic void actionPerformed(ActionEvent e) {\r\n\t\t\t\tnewlevel.setVisible(true);\r\n\t\t\t}\r\n\t\t});\r\n\t\tmnFile.add(mntmNewLevel);\r\n\t\t\r\n\t\tOpenLevel = new JMenuItem(\"Open Level\");\r\n\t\tmnFile.add(OpenLevel);\r\n\t\tmnFile.add(mntmSave);\r\n\t\t\r\n\t\tJMenu mnLayer = new JMenu(\"Layer\");\r\n\t\tmenuBar.add(mnLayer);\r\n\t\t\r\n\t\tmnRenderLayers = new JMenu(\"Render Layers\");\r\n\t\tmnLayer.add(mnRenderLayers);\r\n\t\t\r\n\t\tAddLayer = new JMenuItem(\"Add Layer\");\r\n\t\tmnLayer.add(AddLayer);\r\n\t\t\r\n\t\tDeleteLayer = new JMenuItem(\"Delete Layer\");\r\n\t\tmnLayer.add(DeleteLayer);\r\n\t\t\r\n\t\tmnLevel = new JMenu(\"Level\");\r\n\t\tmenuBar.add(mnLevel);\r\n\t\t\r\n\t\tmntmExpand = new JMenuItem(\"Expand\");\r\n\t\tmnLevel.add(mntmExpand);\r\n\t}\r\n\t\r\n\tpublic void setGameSize(int widthPixels, int heightPixels, int scale) { //delete this comment\r\n\t\tint[] Widths = gridBagLayout.columnWidths;\r\n\t\tint[] Heights = gridBagLayout.rowHeights;\r\n\t\tint width = 0,height = 0;\r\n\t\twidth = widthPixels + Widths[1] + Widths[2]; \r\n\t\theight = 100 + heightPixels + Heights[2] + Heights[3];\r\n\t\tsetSize(width, height);\r\n\t\tthis.setBounds(0, 0, width, height);\r\n\t\t\r\n\t\tSystem.out.println(\"Setting columnWidths to \" + widthPixels + \",\" + Widths[1] + \",\" + Widths[2]);\r\n\t\tSystem.out.println(\"Setting rowHeights to \" + Heights[0] + \",\" + heightPixels + \",\" + Heights[2] + \",\" + Heights[3]);\r\n\t\t\r\n\t\tgridBagLayout.columnWidths = new int[]{widthPixels, Widths[1], Widths[2]};\r\n\t\tgridBagLayout.rowHeights = new int[]{Heights[0], heightPixels, Heights[2], Heights[3]};\r\n\t\t\r\n\t\t//IntStreams can be used once Java 8 is out\r\n\r\n\t\tTopRightPanel.HeightPane.setValue(Integer.toString(heightPixels/ (scale / 1000)));\r\n\t\tTopRightPanel.WidthPane.setValue(Integer.toString(widthPixels / (scale / 1000)));\r\n\t\tTopRightPanel.ScalePane.setValue(Integer.toString(scale));\r\n\t}\r\n}", "\nimport edu.cmu.ml.rtw.generic.data.annotation.DataSet;\r\nimport edu.cmu.ml.rtw.generic.data.annotation.Datum;\r\nimport edu.cmu.ml.rtw.generic.data.annotation.Datum.Tools.LabelIndicator;\r\nimport edu.cmu.ml.rtw.generic.data.annotation.DatumContext;\r\nimport edu.cmu.ml.rtw.generic.parse.AssignmentList;\r\nimport edu.cmu.ml.rtw.generic.parse.Obj;\r\n\r\n/**\r\n * FeatureIdentity returns a vector D(d) for double\r\n * extractor D applied to datum d.\r\n * \r\n * Parameters:\r\n *  doubleExtractor - the extractor used to extract a double\r\n *  from a datum\r\n * \r\n * @author Bill McDowell\r\n *\r\n * @param <D> datum type\r\n * @param <L> datum label type\r\n */\r\npublic class FeatureIdentity<D extends Datum<L>, L> extends Feature<D, L> {\r\n\tprotected Datum.Tools.DoubleExtractor<D, L> doubleExtractor;\r\n\tprotected String[] parameterNames = {\"doubleExtractor\"};\r\n\t\r\n\tprotected int vocabularySize;\r\n\t\r\n\tpublic FeatureIdentity() {\r\n\t\t\r\n\t}\r\n\t\r\n\tpublic FeatureIdentity(DatumContext<D, L> context) {\r\n\t\tthis.context = context;\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic boolean init(DataSet<D, L> dataSet) {\r\n\t\tIterator<D> dataIter = dataSet.iterator();\r\n\t\tif (!dataIter.hasNext())\r\n\t\t\treturn false;\r\n\t\t\r\n\t\tD datum = dataSet.iterator().next();\r\n\t\tthis.vocabularySize = this.doubleExtractor.extract(datum).length;\r\n\t\t\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Map<Integer, Double> computeVector(D datum, int offset, Map<Integer, Double> vector) {\r\n\t\tdouble[] values = this.doubleExtractor.extract(datum);\r\n\t\tfor (int i = 0; i < this.vocabularySize; i++)\r\n\t\t\tif (values[i] != 0)\r\n\t\t\t\tvector.put(i + offset, values[i]);\r\n\t\treturn vector;\r\n\t}\r\n\r\n\r\n\t@Override\r\n\tpublic int getVocabularySize() {\r\n\t\treturn this.vocabularySize;\r\n\t}\r\n\r\n\r\n\t@Override\r\n\tpublic String[] getParameterNames() {\r\n\t\treturn this.parameterNames;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic Obj getParameterValue(String parameter) {\r\n\t\tif (parameter.equals(\"doubleExtractor\"))\r\n\t\t\treturn Obj.stringValue((this.doubleExtractor == null) ? \"\" : this.doubleExtractor.toString());\r\n\t\treturn null;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic boolean setParameterValue(String parameter, Obj parameterValue) {\r\n\t\tif (parameter.equals(\"doubleExtractor\"))\r\n\t\t\tthis.doubleExtractor = this.context.getDatumTools().getDoubleExtractor(this.context.getMatchValue(parameterValue));\r\n\t\telse\r\n\t\t\treturn false;\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String getVocabularyTerm(int index) {\r\n\t\treturn String.valueOf(index);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected boolean setVocabularyTerm(int index, String term) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t\r\n\t@Override\r\n\tpublic String getGenericName() {\r\n\t\treturn \"Identity\";\r\n\t}\r\n\t\r\n\t@Override\r\n\tpublic Feature<D, L> makeInstance(DatumContext<D, L> context) {\r\n\t\treturn new FeatureIdentity<D, L>(context);\r\n\t}\r\n\r\n\t@Override\r\n\tprotected <T extends Datum<Boolean>> Feature<T, Boolean> makeBinaryHelper(\r\n\t\t\tDatumContext<T, Boolean> context, LabelIndicator<L> labelIndicator,\r\n\t\t\tFeature<T, Boolean> binaryFeature) {\r\n\t\treturn binaryFeature;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected boolean fromParseInternalHelper(AssignmentList internalAssignments) {\r\n\t\treturn true;\r\n\t}\r\n\r\n\t@Override\r\n\tprotected AssignmentList toParseInternalHelper(AssignmentList internalAssignments) {\r\n\t\treturn internalAssignments;\r\n\t}\r\n\t\r\n\t@Override\r\n\tprotected boolean cloneHelper(Feature<D, L> clone) {\r\n\t\treturn true;\r\n\t}\r\n}\r\n", "ta.entity.jpa.ReflectiveEntity;\n\nimport javax.persistence.*;\nimport java.util.Date;\nimport java.util.Locale;\n\nimport static com.solvedbysunrise.identity.internationalization.LocaleUtil.convertToLocale;\nimport static javax.persistence.GenerationType.IDENTITY;\n\n@MappedSuperclass\npublic abstract class Email extends ReflectiveEntity {\n\n    static final String EMAIL_TABLE = \"EMAIL\";\n    static final String EMAIL_CONTENT_TABLE = \"EMAIL_CONTENT\";\n\n    static final String ID = \"ID\";\n    static final String ENTITY_ID = \"ENTITY_ID\";\n    static final String GUID = \"GUID\";\n    static final String TYPE = \"TYPE\";\n    static final String TO_ADDRESS = \"TO_ADDRESS\";\n    static final String CONFIRMATION_ID = \"CONFIRMATION_ID\";\n    static final String SENT_DATE = \"SENT_DATE\";\n    static final String TEXT_PAYLOAD = \"TEXT_PAYLOAD\";\n    static final String HTML_PAYLOAD = \"HTML_PAYLOAD\";\n    static final String LANGUAGE_CODE = \"LANGUAGE_CODE\";\n    static final String COUNTRY_CODE = \"COUNTRY_CODE\";\n\n    private static final long serialVersionUID = -8836773247883L;\n\n    @Id\n    @GeneratedValue(strategy = IDENTITY)\n    @Column(name = ID)\n    private Long id;\n\n    @Column(name = ENTITY_ID, nullable = false, updatable = false)\n    private Long entityId;\n\n    @Column(name = GUID, nullable = false, updatable = false)\n    private String guid;\n\n    @Enumerated(EnumType.STRING)\n    @Column(name = TYPE, nullable = false, updatable = false)\n    private EmailType type;\n\n    @Column(name = TO_ADDRESS, nullable = false, updatable = false)\n    private String toAddress;\n\n    @Column(name = CONFIRMATION_ID, nullable = true, updatable = true)\n    private String confirmationId;\n\n    @Column(name = SENT_DATE, nullable = true, updatable = true)\n    private Date sentDate;\n\n    @Column(name = LANGUAGE_CODE, nullable = true, updatable = true)\n    private String languageCode;\n\n    @Column(name = COUNTRY_CODE, nullable = true, updatable = true)\n    private String countryCode;\n\n    public Long getId() {\n        return id;\n    }\n\n    public void setId(Long id) {\n        this.id = id;\n    }\n\n    public Long getEntityId() {\n        return entityId;\n    }\n\n    public void setEntityId(Long entityId) {\n        this.entityId = entityId;\n    }\n\n    public String getGuid() {\n        return guid;\n    }\n\n    public void setGuid(String guid) {\n        this.guid = guid;\n    }\n\n    public EmailType getType() {\n        return type;\n    }\n\n    public void setType(EmailType type) {\n        this.type = type;\n    }\n\n    public String getToAddress() {\n        return toAddress;\n    }\n\n    public void setToAddress(String toAddress) {\n        this.toAddress = toAddress;\n    }\n\n    public Date getSentDate() {\n        return sentDate;\n    }\n\n    public void setSentDate(Date sentDate) {\n        this.sentDate = sentDate;\n    }\n\n    public String getConfirmationId() {\n        return confirmationId;\n    }\n\n    public void setConfirmationId(String confirmationId) {\n        this.confirmationId = confirmationId;\n    }\n\n    public String getLanguageCode() {\n        return languageCode;\n    }\n\n    public void setLanguageCode(String languageCode) {\n        this.languageCode = languageCode;\n    }\n\n    public String getCountryCode() {\n        return countryCode;\n    }\n\n    public void setCountryCode(String countryCode) {\n        this.countryCode = countryCode;\n    }\n\n    @Transient\n    public void setLocale(final Locale locale) {\n        setLanguageCode(locale.getLanguage());\n        setCountryCode(locale.getCountry());\n    }\n\n    @Transient\n    public Locale getLocale() {\n        return convertToLocale(getLanguageCode(), getCountryCode());\n    }\n\n    abstract public void setTextPayload(final String textPayload);\n\n    abstract public String getTextPayload();\n\n    abstract public void setHtmlPayload(final String htmlPayload);\n\n    abstract public String getHtmlPayload();\n\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage javax.security.auth.kerberos;\n\nimport java.util.*;\nimport java.security.Permission;\nimport java.security.PermissionCollection;\nimport java.io.ObjectStreamField;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectInputStream;\nimport java.io.IOException;\n\n/**\n * This class is used to protect Kerberos services and the\n * credentials necessary to access those services. There is a one to\n * one mapping of a service principal and the credentials necessary\n * to access the service. Therefore granting access to a service\n * principal implicitly grants access to the credential necessary to\n * establish a security context with the service principal. This\n * applies regardless of whether the credentials are in a cache\n * or acquired via an exchange with the KDC. The credential can\n * be either a ticket granting ticket, a service ticket or a secret\n * key from a key table.\n * <p>\n * A ServicePermission contains a service principal name and\n * a list of actions which specify the context the credential can be\n * used within.\n * <p>\n * The service principal name is the canonical name of the\n * {@code KereberosPrincipal} supplying the service, that is\n * the KerberosPrincipal represents a Kerberos service\n * principal. This name is treated in a case sensitive manner.\n * An asterisk may appear by itself, to signify any service principal.\n * <p>\n * Granting this permission implies that the caller can use a cached\n * credential (TGT, service ticket or secret key) within the context\n * designated by the action. In the case of the TGT, granting this\n * permission also implies that the TGT can be obtained by an\n * Authentication Service exchange.\n * <p>\n * The possible actions are:\n *\n * <pre>\n *    initiate -              allow the caller to use the credential to\n *                            initiate a security context with a service\n *                            principal.\n *\n *    accept -                allow the caller to use the credential to\n *                            accept security context as a particular\n *                            principal.\n * </pre>\n *\n * For example, to specify the permission to access to the TGT to\n * initiate a security context the permission is constructed as follows:\n *\n * <pre>\n *     ServicePermission(\"krbtgt/EXAMPLE.COM@EXAMPLE.COM\", \"initiate\");\n * </pre>\n * <p>\n * To obtain a service ticket to initiate a context with the \"host\"\n * service the permission is constructed as follows:\n * <pre>\n *     ServicePermission(\"host/foo.example.com@EXAMPLE.COM\", \"initiate\");\n * </pre>\n * <p>\n * For a Kerberized server the action is \"accept\". For example, the permission\n * necessary to access and use the secret key of the  Kerberized \"host\"\n * service (telnet and the likes)  would be constructed as follows:\n *\n * <pre>\n *     ServicePermission(\"host/foo.example.com@EXAMPLE.COM\", \"accept\");\n * </pre>\n *\n * @since 1.4\n */\n\npublic final class ServicePermission extends Permission\n    implements java.io.Serializable {\n\n    private static final long serialVersionUID = -1227585031618624935L;\n\n    /**\n     * Initiate a security context to the specified service\n     */\n    private final static int INITIATE   = 0x1;\n\n    /**\n     * Accept a security context\n     */\n    private final static int ACCEPT     = 0x2;\n\n    /**\n     * All actions\n     */\n    private final static int ALL        = INITIATE|ACCEPT;\n\n    /**\n     * No actions.\n     */\n    private final static int NONE    = 0x0;\n\n    // the actions mask\n    private transient int mask;\n\n    /**\n     * the actions string.\n     *\n     * @serial\n     */\n\n    private String actions; // Left null as long as possible, then\n                            // created and re-used in the getAction function.\n\n    /**\n     * Create a new {@code ServicePermission}\n     * with the specified {@code servicePrincipal}\n     * and {@code action}.\n     *\n     * @param servicePrincipal the name of the service principal.\n     * An asterisk may appear by itself, to signify any service principal.\n     * <p>\n     * @param action the action string\n     */\n    public ServicePermission(String servicePrincipal, String action) {\n        super(servicePrincipal);\n        init(servicePrincipal, getMask(action));\n    }\n\n\n    /**\n     * Initialize the ServicePermission object.\n     */\n    private void init(String servicePrincipal, int mask) {\n\n        if (servicePrincipal == null)\n                throw new NullPointerException(\"service principal can't be null\");\n\n        if ((mask & ALL) != mask)\n            throw new IllegalArgumentException(\"invalid actions mask\");\n\n        this.mask = mask;\n    }\n\n\n    /**\n     * Checks if this Kerberos service permission object \"implies\" the\n     * specified permission.\n     * <P>\n     * If none of the above are true, {@code implies} returns false.\n     * @param p the permission to check against.\n     *\n     * @return true if the specified permission is implied by this object,\n     * false if not.\n     */\n    public boolean implies(Permission p) {\n        if (!(p instanceof ServicePermission))\n            return false;\n\n        ServicePermission that = (ServicePermission) p;\n\n        return ((this.mask & that.mask) == that.mask) &&\n            impliesIgnoreMask(that);\n    }\n\n\n    boolean impliesIgnoreMask(ServicePermission p) {\n        return ((this.getName().equals(\"*\")) ||\n                this.getName().equals(p.getName()));\n    }\n\n    /**\n     * Checks two ServicePermission objects for equality.\n     * <P>\n     * @param obj the object to test for equality with this object.\n     *\n     * @return true if <i>obj</i> is a ServicePermission, and has the\n     *  same service principal, and actions as this\n     * ServicePermission object.\n     */\n    public boolean equals(Object obj) {\n        if (obj == this)\n            return true;\n\n        if (! (obj instanceof ServicePermission))\n            return false;\n\n        ServicePermission that = (ServicePermission) obj;\n        return ((this.mask & that.mask) == that.mask) &&\n            this.getName().equals(that.getName());\n\n\n    }\n\n    /**\n     * Returns the hash code value for this object.\n     *\n     * @return a hash code value for this object.\n     */\n\n    public int hashCode() {\n        return (getName().hashCode() ^ mask);\n    }\n\n\n    /**\n     * Returns the \"canonical string representation\" of the actions in the\n     * specified mask.\n     * Always returns present actions in the following order:\n     * initiate, accept.\n     *\n     * @param mask a specific integer action mask to translate into a string\n     * @return the canonical string representation of the actions\n     */\n    private static String getActions(int mask)\n    {\n        StringBuilder sb = new StringBuilder();\n        boolean comma = false;\n\n        if ((mask & INITIATE) == INITIATE) {\n            if (comma) sb.append(',');\n            else comma = true;\n            sb.append(\"initiate\");\n        }\n\n        if ((mask & ACCEPT) == ACCEPT) {\n            if (comma) sb.append(',');\n            else comma = true;\n            sb.append(\"accept\");\n        }\n\n        return sb.toString();\n    }\n\n    /**\n     * Returns the canonical string representation of the actions.\n     * Always returns present actions in the following order:\n     * initiate, accept.\n     */\n    public String getActions() {\n        if (actions == null)\n            actions = getActions(this.mask);\n\n        return actions;\n    }\n\n\n    /**\n     * Returns a PermissionCollection object for storing\n     * ServicePermission objects.\n     * <br>\n     * ServicePermission objects must be stored in a manner that\n     * allows them to be inserted into the collection in any order, but\n     * that also enables the PermissionCollection implies method to\n     * be implemented in an efficient (and consistent) manner.\n     *\n     * @return a new PermissionCollection object suitable for storing\n     * ServicePermissions.\n     */\n    public PermissionCollection newPermissionCollection() {\n        return new KrbServicePermissionCollection();\n    }\n\n    /**\n     * Return the current action mask.\n     *\n     * @return the actions mask.\n     */\n    int getMask() {\n        return mask;\n    }\n\n    /**\n     * Convert an action string to an integer actions mask.\n     *\n     * @param action the action string\n     * @return the action mask\n     */\n    private static int getMask(String action) {\n\n        if (action == null) {\n            throw new NullPointerException(\"action can't be null\");\n        }\n\n        if (action.equals(\"\")) {\n            throw new IllegalArgumentException(\"action can't be empty\");\n        }\n\n        int mask = NONE;\n\n        char[] a = action.toCharArray();\n\n        int i = a.length - 1;\n        if (i < 0)\n            return mask;\n\n        while (i != -1) {\n            char c;\n\n            // skip whitespace\n            while ((i!=-1) && ((c = a[i]) == ' ' ||\n                               c == '\\r' ||\n                               c == '\\n' ||\n                               c == '\\f' ||\n                               c == '\\t'))\n                i--;\n\n            // check for the known strings\n            int matchlen;\n\n            if (i >= 7 && (a[i-7] == 'i' || a[i-7] == 'I') &&\n                          (a[i-6] == 'n' || a[i-6] == 'N') &&\n                          (a[i-5] == 'i' || a[i-5] == 'I') &&\n                          (a[i-4] == 't' || a[i-4] == 'T') &&\n                          (a[i-3] == 'i' || a[i-3] == 'I') &&\n                          (a[i-2] == 'a' || a[i-2] == 'A') &&\n                          (a[i-1] == 't' || a[i-1] == 'T') &&\n                          (a[i] == 'e' || a[i] == 'E'))\n            {\n                matchlen = 8;\n                mask |= INITIATE;\n\n            } else if (i >= 5 && (a[i-5] == 'a' || a[i-5] == 'A') &&\n                                 (a[i-4] == 'c' || a[i-4] == 'C') &&\n                                 (a[i-3] == 'c' || a[i-3] == 'C') &&\n                                 (a[i-2] == 'e' || a[i-2] == 'E') &&\n                                 (a[i-1] == 'p' || a[i-1] == 'P') &&\n                                 (a[i] == 't' || a[i] == 'T'))\n            {\n                matchlen = 6;\n                mask |= ACCEPT;\n\n            } else {\n                // parse error\n                throw new IllegalArgumentException(\n                        \"invalid permission: \" + action);\n            }\n\n            // make sure we didn't just match the tail of a word\n            // like \"ackbarfaccept\".  Also, skip to the comma.\n            boolean seencomma = false;\n            while (i >= matchlen && !seencomma) {\n                switch(a[i-matchlen]) {\n                case ',':\n                    seencomma = true;\n                    break;\n                case ' ': case '\\r': case '\\n':\n                case '\\f': case '\\t':\n                    break;\n                default:\n                    throw new IllegalArgumentException(\n                            \"invalid permission: \" + action);\n                }\n                i--;\n            }\n\n            // point i at the location of the comma minus one (or -1).\n            i -= matchlen;\n        }\n\n        return mask;\n    }\n\n\n    /**\n     * WriteObject is called to save the state of the ServicePermission\n     * to a stream. The actions are serialized, and the superclass\n     * takes care of the name.\n     */\n    private void writeObject(java.io.ObjectOutputStream s)\n        throws IOException\n    {\n        // Write out the actions. The superclass takes care of the name\n        // call getActions to make sure actions field is initialized\n        if (actions == null)\n            getActions();\n        s.defaultWriteObject();\n    }\n\n    /**\n     * readObject is called to restore the state of the\n     * ServicePermission from a stream.\n     */\n    private void readObject(java.io.ObjectInputStream s)\n         throws IOException, ClassNotFoundException\n    {\n        // Read in the action, then initialize the rest\n        s.defaultReadObject();\n        init(getName(),getMask(actions));\n    }\n\n\n    /*\n      public static void main(String args[]) throws Exception {\n      ServicePermission this_ =\n      new ServicePermission(args[0], \"accept\");\n      ServicePermission that_ =\n      new ServicePermission(args[1], \"accept,initiate\");\n      System.out.println(\"-----\\n\");\n      System.out.println(\"this.implies(that) = \" + this_.implies(that_));\n      System.out.println(\"-----\\n\");\n      System.out.println(\"this = \"+this_);\n      System.out.println(\"-----\\n\");\n      System.out.println(\"that = \"+that_);\n      System.out.println(\"-----\\n\");\n\n      KrbServicePermissionCollection nps =\n      new KrbServicePermissionCollection();\n      nps.add(this_);\n      nps.add(new ServicePermission(\"nfs/example.com@EXAMPLE.COM\",\n      \"accept\"));\n      nps.add(new ServicePermission(\"host/example.com@EXAMPLE.COM\",\n      \"initiate\"));\n      System.out.println(\"nps.implies(that) = \" + nps.implies(that_));\n      System.out.println(\"-----\\n\");\n\n      Enumeration e = nps.elements();\n\n      while (e.hasMoreElements()) {\n      ServicePermission x =\n      (ServicePermission) e.nextElement();\n      System.out.println(\"nps.e = \" + x);\n      }\n\n      }\n    */\n\n}\n\n\nfinal class KrbServicePermissionCollection extends PermissionCollection\n    implements java.io.Serializable {\n\n    // Not serialized; see serialization section at end of class\n    private transient List<Permission> perms;\n\n    public KrbServicePermissionCollection() {\n        perms = new ArrayList<Permission>();\n    }\n\n    /**\n     * Check and see if this collection of permissions implies the permissions\n     * expressed in \"permission\".\n     *\n     * @param permission the Permission object to compare\n     *\n     * @return true if \"permission\" is a proper subset of a permission in\n     * the collection, false if not.\n     */\n    public boolean implies(Permission permission) {\n        if (! (permission instanceof ServicePermission))\n                return false;\n\n        ServicePermission np = (ServicePermission) permission;\n        int desired = np.getMask();\n        int effective = 0;\n        int needed = desired;\n\n        synchronized (this) {\n            int len = perms.size();\n\n            // need to deal with the case where the needed permission has\n            // more than one action and the collection has individual permissions\n            // that sum up to the needed.\n\n            for (int i = 0; i < len; i++) {\n                ServicePermission x = (ServicePermission) perms.get(i);\n\n                //System.out.println(\"  trying \"+x);\n                if (((needed & x.getMask()) != 0) && x.impliesIgnoreMask(np)) {\n                    effective |=  x.getMask();\n                    if ((effective & desired) == desired)\n                        return true;\n                    needed = (desired ^ effective);\n                }\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds a permission to the ServicePermissions. The key for\n     * the hash is the name.\n     *\n     * @param permission the Permission object to add.\n     *\n     * @exception IllegalArgumentException - if the permission is not a\n     *                                       ServicePermission\n     *\n     * @exception SecurityException - if this PermissionCollection object\n     *                                has been marked readonly\n     */\n    public void add(Permission permission) {\n        if (! (permission instanceof ServicePermission))\n            throw new IllegalArgumentException(\"invalid permission: \"+\n                                               permission);\n        if (isReadOnly())\n            throw new SecurityException(\"attempt to add a Permission to a readonly PermissionCollection\");\n\n        synchronized (this) {\n            perms.add(0, permission);\n        }\n    }\n\n    /**\n     * Returns an enumeration of all the ServicePermission objects\n     * in the container.\n     *\n     * @return an enumeration of all the ServicePermission objects.\n     */\n\n    public Enumeration<Permission> elements() {\n        // Convert Iterator into Enumeration\n        synchronized (this) {\n            return Collections.enumeration(perms);\n        }\n    }\n\n    private static final long serialVersionUID = -4118834211490102011L;\n\n    // Need to maintain serialization interoperability with earlier releases,\n    // which had the serializable field:\n    // private Vector permissions;\n\n    /**\n     * @serialField permissions java.util.Vector\n     *     A list of ServicePermission objects.\n     */\n    private static final ObjectStreamField[] serialPersistentFields = {\n        new ObjectStreamField(\"permissions\", Vector.class),\n    };\n\n    /**\n     * @serialData \"permissions\" field (a Vector containing the ServicePermissions).\n     */\n    /*\n     * Writes the contents of the perms field out as a Vector for\n     * serialization compatibility with earlier releases.\n     */\n    private void writeObject(ObjectOutputStream out) throws IOException {\n        // Don't call out.defaultWriteObject()\n\n        // Write out Vector\n        Vector<Permission> permissions = new Vector<>(perms.size());\n\n        synchronized (this) {\n            permissions.addAll(perms);\n        }\n\n        ObjectOutputStream.PutField pfields = out.putFields();\n        pfields.put(\"permissions\", permissions);\n        out.writeFields();\n    }\n\n    /*\n     * Reads in a Vector of ServicePermissions and saves them in the perms field.\n     */\n    @SuppressWarnings(\"unchecked\")\n    private void readObject(ObjectInputStream in)\n        throws IOException, ClassNotFoundException\n    {\n        // Don't call defaultReadObject()\n\n        // Read in serialized fields\n        ObjectInputStream.GetField gfields = in.readFields();\n\n        // Get the one we want\n        Vector<Permission> permissions =\n                (Vector<Permission>)gfields.get(\"permissions\", null);\n        perms = new ArrayList<Permission>(permissions.size());\n        perms.addAll(permissions);\n    }\n}\n", "va.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ArmazenarResultadoDaPartida {\n\n    public void realizarPartida(\n            final String jogador1, final String jogador2) {\n\n        List<String> jogadores = new ArrayList<String>() {{\n            add(jogador1);\n            add(jogador2);\n        }};\n\n        Collections.shuffle(jogadores);\n        String vencedor = jogadores.get(0);\n        String perdedor = jogadores.get(1);\n\n        String chave = \"scores\";\n        double pontosVencedor = 10;\n        double pontosPerdedor = -5;\n\n        Jedis jedis = new Jedis(\"localhost\");\n\n        double scoreVencedor =\n                jedis.zincrby(chave, pontosVencedor, vencedor);\n\n        double scorePerdedor =\n                jedis.zincrby(chave, pontosPerdedor, perdedor);\n\n        System.out.println(\n                String.format(\n                        \"%s venceu (score: %.0f) | %s perdeu (score: %.0f)\",\n                        vencedor,\n                        scoreVencedor,\n                        perdedor,\n                        scorePerdedor\n                )\n        );\n    }\n\n    public static void main(String[] args) {\n        ArmazenarResultadoDaPartida partidas =\n                new ArmazenarResultadoDaPartida();\n\n        for (int rodada = 1; rodada <= 5; rodada++) {\n            System.out.println(String.format(\"Rodada %d\", rodada));\n            partidas.realizarPartida(\"Aragorn\", \"Gandalf\");\n            partidas.realizarPartida(\"Aragorn\", \"Legolas\");\n            partidas.realizarPartida(\"Aragorn\", \"Frodo\");\n            partidas.realizarPartida(\"Gandalf\", \"Bilbo\");\n            partidas.realizarPartida(\"Gandalf\", \"Gimli\");\n            partidas.realizarPartida(\"Gandalf\", \"Sam\");\n            partidas.realizarPartida(\"Frodo\", \"Boromir\");\n            partidas.realizarPartida(\"Frodo\", \"Gollum\");\n            partidas.realizarPartida(\"Gollum\", \"Boromir\");\n            partidas.realizarPartida(\"Sam\", \"Gimli\");\n        }\n\n    }\n}\n", "om/jad.html\r\n// Decompiler options: packimports(3) \r\n\r\npackage com.mstar.supportv4.viewpager;\r\n\r\nimport android.view.ViewConfiguration;\r\n\r\n// Referenced classes of package com.mstar.supportv4.viewpager:\r\n//            ViewConfigurationCompatFroyo\r\n\r\npublic class ViewConfigurationCompat\r\n{\r\n    static class BaseViewConfigurationVersionImpl\r\n        implements ViewConfigurationVersionImpl\r\n    {\r\n\r\n        public int getScaledPagingTouchSlop(ViewConfiguration viewconfiguration)\r\n        {\r\n            return viewconfiguration.getScaledTouchSlop();\r\n        }\r\n\r\n        BaseViewConfigurationVersionImpl()\r\n        {\r\n        }\r\n    }\r\n\r\n    static class FroyoViewConfigurationVersionImpl\r\n        implements ViewConfigurationVersionImpl\r\n    {\r\n\r\n        public int getScaledPagingTouchSlop(ViewConfiguration viewconfiguration)\r\n        {\r\n            return ViewConfigurationCompatFroyo.getScaledPagingTouchSlop(viewconfiguration);\r\n        }\r\n\r\n        FroyoViewConfigurationVersionImpl()\r\n        {\r\n        }\r\n    }\r\n\r\n    static interface ViewConfigurationVersionImpl\r\n    {\r\n\r\n        public abstract int getScaledPagingTouchSlop(ViewConfiguration viewconfiguration);\r\n    }\r\n\r\n\r\n    public ViewConfigurationCompat()\r\n    {\r\n    }\r\n\r\n    public static int getScaledPagingTouchSlop(ViewConfiguration viewconfiguration)\r\n    {\r\n        return IMPL.getScaledPagingTouchSlop(viewconfiguration);\r\n    }\r\n\r\n    static final ViewConfigurationVersionImpl IMPL;\r\n\r\n    static \r\n    {\r\n        if(android.os.Build.VERSION.SDK_INT >= 11)\r\n            IMPL = new FroyoViewConfigurationVersionImpl();\r\n        else\r\n            IMPL = new BaseViewConfigurationVersionImpl();\r\n    }\r\n}\r\n", "GradientDecent;\nimport com.google.common.util.concurrent.AtomicDouble;\nimport data.DataSet;\nimport model.Predictable;\nimport model.Trainable;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport java.util.Arrays;\nimport java.util.concurrent.atomic.AtomicInteger;\nimport java.util.stream.IntStream;\n\n/**\n * Created by hanxuan on 10/1/15 for machine_learning.\n */\npublic class Perceptron implements Predictable, Trainable, GradientDecent, Decent {\n\n    public static double ALPHA = 0.001;\n\n    public static int BUCKET_COUNT = 1;\n\n    public static double COST_DECENT_THRESHOLD = 0.00000001;\n\n    public static int MAX_ROUND = 5000;\n\n    public static int PRINT_GAP = 500;\n\n    private static int ITER_COUNT = 1;\n\n    private static final Logger log = LogManager.getLogger(Perceptron.class);\n\n    private double[] w = null;\n\n    private DataSet data = null;\n\n    public Perceptron() {}\n\n    @Override\n    public void initialize(DataSet d) {\n        this.data = d;\n    }\n\n    @Override\n    public double predict(double[] feature) {\n        return score(feature) > 0 ? 1 : -1;\n    }\n\n    @Override\n    public double score(double[] feature) {\n        return hypothesis(feature, w);\n    }\n\n    @Override\n    public void train() {\n        double[] initTheta = new double[data.getFeatureLength()];\n        double finalCost = loop(data.getInstanceLength(), BUCKET_COUNT, initTheta, COST_DECENT_THRESHOLD, MAX_ROUND, PRINT_GAP);\n        log.info(\"Training finished, final cost: {}\", finalCost);\n        log.info(\"theta: {}\", initTheta);\n        log.info(\"Norm theta: {}\", Arrays.stream(initTheta).map(x -> x / initTheta[0]).toArray());\n        w = initTheta;\n    }\n\n    @Override\n    public <T> void gGradient(int start, int end, T params) {\n\n        double[] theta = (double[]) params;\n\n        IntStream.range(0, data.getInstanceLength()).forEach(\n                i -> {\n                    double[] X = data.getInstance(i);\n                    double y = data.getLabel(i);\n                    if (hypothesis(X, theta) * y <= 0) {\n                        IntStream.range(0, theta.length).forEach(j -> theta[j] += X[j] * y);\n                    }\n                }\n        );\n    }\n\n    @Override\n    public <T> double cost(T params) {\n\n        double[] theta = (double[]) params;\n\n        AtomicDouble cost = new AtomicDouble(0);\n        AtomicInteger mistakeCounter = new AtomicInteger(0);\n        IntStream.range(0, data.getInstanceLength()).forEach(\n                i -> {\n                    double[] X = data.getInstance(i);\n                    double test = hypothesis(X, theta) * data.getLabel(i);\n                    if (test <= 0) {\n                        cost.getAndAdd(test * -1.0);\n                        mistakeCounter.getAndIncrement();\n                    }\n                }\n        );\n\n        log.info(\"ITERATION: {}, TOTAL_MISTAKE : {}, COST: {}\", ITER_COUNT++, mistakeCounter.get(), cost.get());\n\n        return cost.get();\n    }\n\n    @Override\n    public <T> void parameterGradient(int start, int end, T theta) {\n        gGradient(start, end, theta);\n    }\n\n    private double hypothesis(double[] X, double[] theta) {\n        return IntStream.range(0, X.length).mapToDouble(i -> X[i] * theta[i]).sum();\n    }\n}\n", "port graphql.execution.DataFetcherExceptionHandler;\nimport graphql.execution.DataFetcherExceptionHandlerParameters;\nimport graphql.execution.DataFetcherExceptionHandlerResult;\nimport graphql.execution.ExecutionPath;\nimport graphql.language.SourceLocation;\nimport net.twasi.core.logger.TwasiLogger;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class GraphQLExceptionHandler implements DataFetcherExceptionHandler {\n    @Override\n    public DataFetcherExceptionHandlerResult onException(DataFetcherExceptionHandlerParameters handlerParameters) {\n        Throwable exception = handlerParameters.getException();\n        SourceLocation sourceLocation = handlerParameters.getField().getSingleField().getSourceLocation();\n        ExecutionPath path = handlerParameters.getPath();\n        TwasiLogger.log.debug(\"Data fetcher exception while resolving GraphQL request\", exception);\n\n        if (exception instanceof TwasiGraphQLHandledException) {\n            TwasiGraphQLHandledException handledException = (TwasiGraphQLHandledException) exception;\n            return DataFetcherExceptionHandlerResult.newResult(handledException.getGraphQLException(sourceLocation, path)).build();\n        }\n\n        TwasiLogger.log.debug(\"Data fetcher failed with unhandled exception.\", exception);\n        return DataFetcherExceptionHandlerResult.newResult(new GraphQLError() {\n            @Override\n            public String getMessage() {\n                return \"Unknown error occurred.\";\n            }\n\n            @Override\n            public List<SourceLocation> getLocations() {\n                return Collections.singletonList(sourceLocation);\n            }\n\n            @Override\n            public Map<String, Object> getExtensions() {\n                HashMap<String, Object> values = new HashMap<>();\n                values.put(\"localisedKey\", \"error.unknown\");\n                return values;\n            }\n\n            @Override\n            public ErrorClassification getErrorType() {\n                return null;\n            }\n\n            @Override\n            public List<Object> getPath() {\n                return Collections.singletonList(path);\n            }\n        }).build();\n    }\n}", ".Autowired;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.ui.Model;\nimport org.springframework.util.StringUtils;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.InitBinder;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\n\nimport java.util.List;\nimport java.util.logging.Logger;\n\n/**\n * Client controller, fetches Account info from the microservice via\n * {@link WebAccountsService}.\n */\n@Controller\npublic class WebAccountsController {\n\n\t@Autowired\n\tprotected WebAccountsService accountsService;\n\n\tprotected Logger logger = Logger.getLogger(WebAccountsController.class\n\t\t\t.getName());\n\n\tpublic WebAccountsController(WebAccountsService accountsService) {\n\t\tthis.accountsService = accountsService;\n\t}\n\n\t@InitBinder\n\tpublic void initBinder(WebDataBinder binder) {\n\t\tbinder.setAllowedFields(\"accountNumber\", \"searchText\");\n\t}\n\n\t@RequestMapping(\"/accounts\")\n\tpublic String goHome() {\n\t\treturn \"index\";\n\t}\n\n\t@RequestMapping(\"/accounts/{accountNumber}\")\n\tpublic String byNumber(Model model,\n\t\t\t@PathVariable(\"accountNumber\") String accountNumber) {\n\n\t\tlogger.info(\"web-service byNumber() invoked: \" + accountNumber);\n\n\t\tedu.cmu.sad.microservices.accounts.Account account = accountsService.findByNumber(accountNumber);\n\t\tlogger.info(\"web-service byNumber() found: \" + account);\n\t\tmodel.addAttribute(\"account\", account);\n\t\treturn \"account\";\n\t}\n\n\t@RequestMapping(\"/accounts/owner/{text}\")\n\tpublic String ownerSearch(Model model, @PathVariable(\"text\") String name) {\n\t\tlogger.info(\"web-service byOwner() invoked: \" + name);\n\n\t\tList<edu.cmu.sad.microservices.accounts.Account> accounts = accountsService.byOwnerContains(name);\n\t\tlogger.info(\"web-service byOwner() found: \" + accounts);\n\t\tmodel.addAttribute(\"search\", name);\n\t\tif (accounts != null)\n\t\t\tmodel.addAttribute(\"accounts\", accounts);\n\t\treturn \"accounts\";\n\t}\n\n\t@RequestMapping(value = \"/accounts/search\", method = RequestMethod.GET)\n\tpublic String searchForm(Model model) {\n\t\tmodel.addAttribute(\"searchCriteria\", new SearchCriteria());\n\t\treturn \"accountSearch\";\n\t}\n\n\t@RequestMapping(value = \"/accounts/dosearch\")\n\tpublic String doSearch(Model model, SearchCriteria criteria,\n\t\t\tBindingResult result) {\n\t\tlogger.info(\"web-service search() invoked: \" + criteria);\n\n\t\tcriteria.validate(result);\n\n\t\tif (result.hasErrors())\n\t\t\treturn \"accountSearch\";\n\n\t\tString accountNumber = criteria.getAccountNumber();\n\t\tif (StringUtils.hasText(accountNumber)) {\n\t\t\treturn byNumber(model, accountNumber);\n\t\t} else {\n\t\t\tString searchText = criteria.getSearchText();\n\t\t\treturn ownerSearch(model, searchText);\n\t\t}\n\t}\n}\n", "granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage org.curioswitch.scrapers.instagram.server.models;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\nimport com.fasterxml.jackson.databind.annotation.JsonDeserialize;\nimport org.checkerframework.checker.nullness.qual.Nullable;\nimport org.curioswitch.common.server.framework.immutables.CurioStyle;\nimport org.immutables.value.Value.Immutable;\n\n/** A {@link GraphImage} is a post on Instagram. */\n@Immutable\n@CurioStyle\n@JsonDeserialize(as = ImmutableGraphImage.class)\npublic interface GraphImage {\n  /** The Instagram ID of the caption. */\n  @JsonProperty(\"shortcode\")\n  String getShortcode();\n\n  /** The location the caption was taken. */\n  @JsonProperty(\"location\")\n  @Nullable\n  Location getLocation();\n}\n", "ass ImageAssets{\n\t\n\tprivate static final int WIDTH = 32, HEIGHT = 32;\n\t\n\tpublic static BufferedImage[] desert, dirt, grass, mud, road, snow, tree, water;\n\tpublic static BufferedImage[] player;\n\tpublic static BufferedImage rock;\n\t\n\tpublic static void init(){\n\t\t\n\t\tImageLoader loader = new ImageLoader();\n\t\tSpriteManager grassSheet = new SpriteManager(loader.loadImage(\"res/images/environment_tilesets/grass.png\"));\n\t\tSpriteManager playerSheet = new SpriteManager(loader.loadImage(\"res/images/warrior_m.png\"));\n\t\t\n\t\tdesert = new BufferedImage[35];\n\t\tdirt = new BufferedImage[35];\n\t\tgrass = new BufferedImage[12];\n\t\tint i = 0;\n\t\tfor(int y = 0; y < 4; y++){\n\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\tgrass[i] = grassSheet.crop(x, y, WIDTH, HEIGHT);\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\tmud = new BufferedImage[35];\n\t\troad = new BufferedImage[35];\n\t\tsnow = new BufferedImage[35];\n\t\ttree = new BufferedImage[35];\n\t\twater = new BufferedImage[35];\n\t\t\n\t\tplayer = new BufferedImage[12];\n\t\tint k = 0;\n\t\tfor(int y = 0; y < 4; y++){\n\t\t\tfor(int x = 0; x < 3; x++){\n\t\t\t\tplayer[k] = playerSheet.crop(x, y, 32, 36);\n\t\t\t\tk++;\n\t\t\t}\n\t\t}\n\t\t\n\t}\n}\n", "11 the original author or authors.\n * See the notice.md file distributed with this work for additional\n * information regarding copyright ownership.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\npackage org.iq80.snappy;\n\nimport java.io.IOException;\nimport java.io.OutputStream;\n\n/**\n * This class implements an output stream for writing Snappy compressed data.\n * The output format is the stream header \"snappy\\0\" followed by one or more\n * compressed blocks of data, each of which is preceded by a seven byte header.\n * <p/>\n * The first byte of the header is a flag indicating if the block is compressed\n * or not. A value of 0x00 means uncompressed, and 0x01 means compressed.\n * <p/>\n * The second and third bytes are the size of the block in the stream as a big\n * endian number. This value is never zero as empty blocks are never written.\n * The maximum allowed length is 32k (1 << 15).\n * <p/>\n * The remaining four byes are crc32c checksum of the user input data masked\n * with the following function: {@code ((crc >>> 15) | (crc << 17)) + 0xa282ead8 }\n * <p/>\n * An uncompressed block is simply copied from the input, thus guaranteeing\n * that the output is never larger than the input (not including the header).\n * <p>\n * <b>NOTE:</b>This data produced by this class is not compatible with the\n * {@code x-snappy-framed} specification. It can only be read by\n * {@link SnappyInputStream}.\n * </p>\n *\n * @deprecated Use {@link SnappyFramedOutputStream} which implements\n * the standard {@code x-snappy-framed} specification.\n */\n@Deprecated\npublic class SnappyOutputStream\n        extends AbstractSnappyOutputStream\n{\n    static final byte[] STREAM_HEADER = new byte[] {'s', 'n', 'a', 'p', 'p', 'y', 0};\n\n    // the header format requires the max block size to fit in 15 bits -- do not change!\n    static final int MAX_BLOCK_SIZE = 1 << 15;\n\n    /**\n     * Write out the uncompressed content if the compression ratio (compressed length / raw length) exceeds this value.\n     */\n    public static final double MIN_COMPRESSION_RATIO = 7.0 / 8.0;\n    \n    /**\n     * Creates a Snappy output stream to write data to the specified underlying output stream.\n     *\n     * @param out the underlying output stream\n     */\n    \n    public SnappyOutputStream(OutputStream out, boolean calculateChecksums)\n            throws IOException\n    {\n        super(out, MAX_BLOCK_SIZE, MIN_COMPRESSION_RATIO, calculateChecksums);\n    }\n\n    /**\n     * Creates a Snappy output stream with block checksums disabled.  This is only useful for\n     * apples-to-apples benchmarks with other compressors that do not perform block checksums.\n     *\n     * @param out the underlying output stream\n     */\n    public static SnappyOutputStream newChecksumFreeBenchmarkOutputStream(OutputStream out)\n            throws IOException\n    {\n        return new SnappyOutputStream(out, false);\n    }\n\n    \n    protected void writeHeader(OutputStream out)\n            throws IOException\n    {\n        out.write(STREAM_HEADER);\n    }\n\n    \n    protected int calculateCRC32C(byte[] data, int offset, int length)\n    {\n        return calculateChecksums ? super.calculateCRC32C(data, offset, length) : 0;\n    }\n\n    \n    protected void writeBlock(OutputStream out, byte[] data, int offset, int length, boolean compressed, int crc32c)\n            throws IOException\n    {\n        // write compressed flag\n        out.write(compressed ? 0x01 : 0x00);\n\n        // write length\n        out.write(length >>> 8);\n        out.write(length);\n\n        // write crc32c of user input data\n        out.write(crc32c >>> 24);\n        out.write(crc32c >>> 16);\n        out.write(crc32c >>> 8);\n        out.write(crc32c);\n\n        // write data\n        out.write(data, offset, length);\n    }\n}\n", "rg.rest.sec.model.Role;\r\n\r\npublic interface IRoleService extends IService< Role >{\r\n\t\r\n\tRole findByName( final String name );\r\n\t\r\n}\r\n", "enkins.appd.rest.types.MetricData;\n\n\nimport org.codehaus.jackson.map.DeserializationConfig;\nimport org.codehaus.jackson.map.ObjectMapper;\nimport org.codehaus.jackson.type.TypeReference;\nimport org.junit.Test;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * TODO update header from template\n */\npublic class RestConnectionTest {\n  private final ObjectMapper jsonMapper = new ObjectMapper();\n\n  private static final String jsonOutput = \"      [{\\n\" +\n      \"        \\\"frequency\\\": \\\"TEN_MIN\\\",\\n\" +\n      \"        \\\"metricId\\\": 38357,\\n\" +\n      \"        \\\"metricPath\\\": \\\"Overall Application Performance|Average Response Time (ms)\\\",\\n\" +\n      \"        \\\"metricValues\\\": [\\n\" +\n      \"            {\\n\" +\n      \"                \\\"current\\\": 19,\\n\" +\n      \"                \\\"max\\\": 54104,\\n\" +\n      \"                \\\"min\\\": 0,\\n\" +\n      \"                \\\"startTimeInMillis\\\": 1356877200000,\\n\" +\n      \"                \\\"value\\\": 6\\n\" +\n      \"            },\\n\" +\n      \"            {\\n\" +\n      \"                \\\"current\\\": 5,\\n\" +\n      \"                \\\"max\\\": 54098,\\n\" +\n      \"                \\\"min\\\": 0,\\n\" +\n      \"                \\\"startTimeInMillis\\\": 1356877800000,\\n\" +\n      \"                \\\"value\\\": 6\\n\" +\n      \"            }\\n\" +\n      \"        ]\\n\" +\n      \"    }]\\n\";\n\n  @Test\n  public void testJsonParsing() throws IOException {\n      jsonMapper.configure(DeserializationConfig.Feature.FAIL_ON_UNKNOWN_PROPERTIES, false);\n\n      List<MetricData> metricList = jsonMapper.readValue(jsonOutput, new TypeReference<List<MetricData>>() {});\n\n    assertEquals(1, metricList.size());\n    MetricData resultData = metricList.get(0);\n    assertEquals(\"TEN_MIN\", resultData.getFrequency());\n    assertEquals(2, resultData.getMetricValues().size());\n    assertEquals(5, resultData.getMetricValues().get(1).getCurrent().intValue());\n  }\n}\n", "\nimport org.springframework.cloud.netflix.feign.FeignClient;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RequestPart;\nimport org.springframework.web.multipart.MultipartFile;\n\nimport static org.springframework.http.MediaType.APPLICATION_OCTET_STREAM_VALUE;\n\n@FeignClient(serviceId = \"elsie-deesight\", configuration = MultipartSupportConfig.class)\npublic interface ElsieDeeSightFeignClient {\n\n  @RequestMapping(\n      value = \"/elsie-deesight/classifyImage\",\n      method = RequestMethod.POST,\n      produces = APPLICATION_OCTET_STREAM_VALUE\n  )\n  ResponseEntity<byte[]> classifyImage(final @RequestPart MultipartFile image);\n}", "ode generated by Microsoft (R) AutoRest Code Generator.\n\npackage com.azure.resourcemanager.sql.models;\n\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.fasterxml.jackson.annotation.JsonValue;\n\n/** Defines values for RecommendedIndexAction. */\npublic enum RecommendedIndexAction {\n    /** Enum value Create. */\n    CREATE(\"Create\"),\n\n    /** Enum value Drop. */\n    DROP(\"Drop\"),\n\n    /** Enum value Rebuild. */\n    REBUILD(\"Rebuild\");\n\n    /** The actual serialized value for a RecommendedIndexAction instance. */\n    private final String value;\n\n    RecommendedIndexAction(String value) {\n        this.value = value;\n    }\n\n    /**\n     * Parses a serialized value to a RecommendedIndexAction instance.\n     *\n     * @param value the serialized value to parse.\n     * @return the parsed RecommendedIndexAction object, or null if unable to parse.\n     */\n    @JsonCreator\n    public static RecommendedIndexAction fromString(String value) {\n        RecommendedIndexAction[] items = RecommendedIndexAction.values();\n        for (RecommendedIndexAction item : items) {\n            if (item.toString().equalsIgnoreCase(value)) {\n                return item;\n            }\n        }\n        return null;\n    }\n\n    @JsonValue\n    @Override\n    public String toString() {\n        return this.value;\n    }\n}\n", "a.en.Given;\nimport cucumber.api.java.en.Then;\nimport cucumber.api.java.en.When;\nimport cucumber.deps.com.thoughtworks.xstream.annotations.XStreamConverter;\n\nimport java.util.List;\n\nimport static org.testng.Assert.assertEquals;\n\npublic class ShoppingStepdefs {\n    private RpnCalculator calc = new RpnCalculator();\n\n    @Given(\"^the following groceries:$\")\n    public void the_following_groceries(List<Grocery> groceries) {\n        for (Grocery grocery : groceries) {\n            calc.push(grocery.price.value);\n            calc.push(\"+\");\n        }\n    }\n\n    @When(\"^I pay (\\\\d+)$\")\n    public void i_pay(int amount) {\n        calc.push(amount);\n        calc.push(\"-\");\n    }\n\n    @Then(\"^my change should be (\\\\d+)$\")\n    public void my_change_should_be_(int change) {\n        assertEquals(-calc.value().intValue(), change);\n    }\n\n    public static class Grocery {\n        public String name;\n        @XStreamConverter(Price.Converter.class)\n        public Price price;\n\n        public Grocery() {\n            super();\n        }\n    }\n\n    public static class Price {\n        public int value;\n\n        public Price(int value) {\n            this.value = value;\n        }\n\n        public static class Converter extends Transformer<Price> {\n            @Override\n            public Price transform(String value) {\n                return new Price(Integer.parseInt(value));\n            }\n        }\n    }\n}\n", ".Pattern;\n\npublic class I18nLexer implements Lexer {\n    private static final Pattern COMMENT_OR_EMPTY_LINE_PATTERN = Pattern.compile(\"^\\\\s*#|^\\\\s*$\");\n    private static final Pattern LANGUAGE_PATTERN = Pattern.compile(\"^\\\\s*#\\\\s*language\\\\s*:\\\\s*([a-zA-Z\\\\-]+)\");\n    private final Listener listener;\n    private I18n i18n;\n\n    public I18nLexer(Listener listener) {\n        this(listener, false);\n    }\n\n    public I18nLexer(Listener listener, boolean forceRubyDummy) {\n        this.listener = listener;\n    }\n\n    /**\n     * @return the i18n language from the previous scanned source.\n     */\n    public I18n getI18nLanguage() {\n        return i18n;\n    }\n\n    public void scan(String source) {\n        createDelegate(source).scan(source);\n    }\n\n    private Lexer createDelegate(String source) {\n        i18n = i18nLanguage(source);\n        return i18n.lexer(listener);\n    }\n\n    private I18n i18nLanguage(String source) {\n        String key = \"en\";\n        for (String line : source.split(\"\\\\n\")) {\n            if (!COMMENT_OR_EMPTY_LINE_PATTERN.matcher(line).find()) {\n                break;\n            }\n            Matcher matcher = LANGUAGE_PATTERN.matcher(line);\n            if (matcher.find()) {\n                key = matcher.group(1);\n                break;\n            }\n        }\n        return new I18n(key);\n    }\n}", "t java.io.BufferedWriter;\nimport static java.lang.System.err;\nimport static java.lang.System.exit;\n\n/**\n * \n * @author Charles Munger\n */\npublic class MasterOutputMakerStandard implements MasterOutputMaker \n{\n    private static final int CHAR_BUFFER_SIZE = 8 * 1024;\n    \n    @Override\n    public void write(FileSystem fileSystem, int numWorkers)\n    {\n        char[] charBuffer = new char[ CHAR_BUFFER_SIZE ]; \n        BufferedReader bufferedReader = null;\n        BufferedWriter bufferedWriter = fileSystem.getFileOutputStream();\n        try {\n            for (int fileNum = 1; fileNum <= numWorkers; fileNum++)\n            {\n                try {\n                    bufferedReader = fileSystem.getWorkerOutputFileInputStream(fileNum);\n                } catch(Exception e) {\n                    System.out.println(\"Error getting input stream for file \" +fileNum + \" with message \" + e.getLocalizedMessage());\n                }\n                int readBytes;\n                while((readBytes = bufferedReader.read( charBuffer )) != -1)\n                {\n                    bufferedWriter.write( charBuffer, 0, readBytes );\n                }\n                bufferedReader.close();\n            }\n            bufferedWriter.close();\n        } catch (Exception exception) {\n            err.println(\"StandardMasterOutputMaker.write: Error: \" + exception.getMessage());\n            exit(1);\n        }\n    }\n}", "leDefinition;\nimport graphql.schema.GraphQLType;\nimport graphql.schema.SchemaUtil;\nimport graphql.validation.*;\n\npublic class VariablesAreInputTypes extends AbstractRule {\n\n    private SchemaUtil schemaUtil = new SchemaUtil();\n\n    public VariablesAreInputTypes(ValidationContext validationContext, ValidationErrorCollector validationErrorCollector) {\n        super(validationContext, validationErrorCollector);\n    }\n\n    @Override\n    public void checkVariableDefinition(VariableDefinition variableDefinition) {\n        TypeName unmodifiedAstType = getValidationUtil().getUnmodifiedType(variableDefinition.getType());\n\n        GraphQLType type = getValidationContext().getSchema().getType(unmodifiedAstType.getName());\n        if (type == null) return;\n        if (!schemaUtil.isInputType(type)) {\n            String message = \"Wrong type for a variable\";\n            addError(new ValidationError(ValidationErrorType.NonInputTypeOnVariable, variableDefinition.getSourceLocation(), message));\n        }\n    }\n}\n", " android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.content.IntentFilter;\nimport android.content.pm.PackageManager;\nimport android.os.Build;\nimport android.os.Bundle;\nimport android.support.v4.app.ActivityCompat;\nimport android.support.v4.content.ContextCompat;\nimport android.support.v7.app.AlertDialog;\nimport android.support.v7.app.AppCompatActivity;\nimport android.text.Html;\nimport android.text.TextUtils;\nimport android.util.Log;\nimport android.widget.Button;\n\nimport com.afollestad.materialdialogs.MaterialDialog;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport de.danoeh.antennapod.R;\nimport de.danoeh.antennapod.core.preferences.UserPreferences;\nimport de.danoeh.antennapod.core.util.Converter;\nimport de.danoeh.antennapod.core.util.StorageUtils;\n\n/** Is show if there is now external storage available. */\npublic class StorageErrorActivity extends AppCompatActivity {\n\n\tprivate static final String TAG = \"StorageErrorActivity\";\n\n    private static final String[] EXTERNAL_STORAGE_PERMISSIONS = {\n            Manifest.permission.READ_EXTERNAL_STORAGE,\n            Manifest.permission.WRITE_EXTERNAL_STORAGE };\n    private static final int PERMISSION_REQUEST_EXTERNAL_STORAGE = 42;\n\n\t@Override\n\tprotected void onCreate(Bundle savedInstanceState) {\n\t\tsetTheme(UserPreferences.getTheme());\n\t\tsuper.onCreate(savedInstanceState);\n\n\t\tsetContentView(R.layout.storage_error);\n\n\t\tButton btnChooseDataFolder = (Button) findViewById(R.id.btnChooseDataFolder);\n\t\tbtnChooseDataFolder.setOnClickListener(v -> {\n            if (Build.VERSION_CODES.KITKAT <= Build.VERSION.SDK_INT &&\n                    Build.VERSION.SDK_INT <= Build.VERSION_CODES.LOLLIPOP_MR1) {\n                showChooseDataFolderDialog();\n            } else {\n                openDirectoryChooser();\n            }\n        });\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {\n            int readPermission = ActivityCompat.checkSelfPermission(this,\n                    Manifest.permission.READ_EXTERNAL_STORAGE);\n            int writePermission = ActivityCompat.checkSelfPermission(this,\n                    Manifest.permission.WRITE_EXTERNAL_STORAGE);\n            if (readPermission != PackageManager.PERMISSION_GRANTED ||\n                    writePermission != PackageManager.PERMISSION_GRANTED) {\n                requestPermission();\n            }\n        }\n    }\n\n    private void requestPermission() {\n        ActivityCompat.requestPermissions(this, EXTERNAL_STORAGE_PERMISSIONS,\n                PERMISSION_REQUEST_EXTERNAL_STORAGE);\n    }\n\n    private void openDirectoryChooser() {\n        Intent intent = new Intent(this, DirectoryChooserActivity.class);\n        startActivityForResult(intent, DirectoryChooserActivity.RESULT_CODE_DIR_SELECTED);\n    }\n\n    @Override\n    public void onRequestPermissionsResult(int requestCode,\n                                           String[] permissions,\n                                           int[] grantResults) {\n        if (requestCode != PERMISSION_REQUEST_EXTERNAL_STORAGE || grantResults.length != 2) {\n            return;\n        }\n        if (grantResults[0] != PackageManager.PERMISSION_GRANTED ||\n                grantResults[1] != PackageManager.PERMISSION_GRANTED) {\n            new MaterialDialog.Builder(this)\n                    .content(R.string.choose_data_directory_permission_rationale)\n                    .positiveText(android.R.string.ok)\n                    .onPositive((dialog, which) -> requestPermission())\n                    .onNegative((dialog, which) -> finish())\n                    .show();\n        }\n    }\n\n    @Override\n    protected void onResume() {\n        super.onResume();\n        if (StorageUtils.storageAvailable()) {\n            leaveErrorState();\n        } else {\n            registerReceiver(mediaUpdate, new IntentFilter(Intent.ACTION_MEDIA_MOUNTED));\n        }\n    }\n\n\t@Override\n\tprotected void onPause() {\n\t\tsuper.onPause();\n\t\ttry {\n\t\t\tunregisterReceiver(mediaUpdate);\n\t\t} catch (IllegalArgumentException e) {\n            Log.e(TAG, Log.getStackTraceString(e));\n\t\t}\n\t}\n\n    // see PreferenceController.showChooseDataFolderDialog()\n    private void showChooseDataFolderDialog() {\n        File dataFolder =  UserPreferences.getDataFolder(null);\n        if(dataFolder == null) {\n            new MaterialDialog.Builder(this)\n                    .title(R.string.error_label)\n                    .content(R.string.external_storage_error_msg)\n                    .neutralText(android.R.string.ok)\n                    .show();\n            return;\n        }\n        String dataFolderPath = dataFolder.getAbsolutePath();\n        int selectedIndex = -1;\n        File[] mediaDirs = ContextCompat.getExternalFilesDirs(this, null);\n        List<String> folders = new ArrayList<>(mediaDirs.length);\n        List<CharSequence> choices = new ArrayList<>(mediaDirs.length);\n        for(int i=0; i < mediaDirs.length; i++) {\n            File dir = mediaDirs[i];\n            if(dir == null || !dir.exists() || !dir.canRead() || !dir.canWrite()) {\n                continue;\n            }\n            String path = mediaDirs[i].getAbsolutePath();\n            folders.add(path);\n            if(dataFolderPath.equals(path)) {\n                selectedIndex = i;\n            }\n            int index = path.indexOf(\"Android\");\n            String choice;\n            if(index >= 0) {\n                choice = path.substring(0, index);\n            } else {\n                choice = path;\n            }\n            long bytes = StorageUtils.getFreeSpaceAvailable(path);\n            String freeSpace = String.format(getString(R.string.free_space_label),\n                    Converter.byteToString(bytes));\n            choices.add(Html.fromHtml(\"<html><small>\" + choice + \" [\" + freeSpace + \"]\"\n                    + \"</small></html>\"));\n        }\n        if(choices.size() == 0) {\n            new MaterialDialog.Builder(this)\n                    .title(R.string.error_label)\n                    .content(R.string.external_storage_error_msg)\n                    .neutralText(android.R.string.ok)\n                    .show();\n            return;\n        }\n        MaterialDialog dialog = new MaterialDialog.Builder(this)\n                .title(R.string.choose_data_directory)\n                .content(R.string.choose_data_directory_message)\n                .items(choices.toArray(new CharSequence[choices.size()]))\n                .itemsCallbackSingleChoice(selectedIndex, (dialog1, itemView, which, text) -> {\n                    String folder = folders.get(which);\n                    UserPreferences.setDataFolder(folder);\n                    leaveErrorState();\n                    return true;\n                })\n                .negativeText(R.string.cancel_label)\n                .cancelable(true)\n                .build();\n        dialog.show();\n    }\n\n\tpublic void onActivityResult(int requestCode, int resultCode, Intent data) {\n\t\tif (resultCode == Activity.RESULT_OK &&\n\t\t\t\trequestCode == DirectoryChooserActivity.RESULT_CODE_DIR_SELECTED) {\n            String dir = data.getStringExtra(DirectoryChooserActivity.RESULT_SELECTED_DIR);\n\n            File path;\n            if (dir != null) {\n                path = new File(dir);\n            } else {\n                path = getExternalFilesDir(null);\n            }\n            if(path == null) {\n                return;\n            }\n            String message = null;\n\t\t\tif(!path.exists()) {\n\t\t\t\tmessage = String.format(getString(R.string.folder_does_not_exist_error), dir);\n\t\t\t} else if(!path.canRead()) {\n\t\t\t\tmessage = String.format(getString(R.string.folder_not_readable_error), dir);\n\t\t\t} else if(!path.canWrite()) {\n\t\t\t\tmessage = String.format(getString(R.string.folder_not_writable_error), dir);\n\t\t\t}\n\n\t\t\tif(message == null) {\n\t\t\t\tLog.d(TAG, \"Setting data folder: \" + dir);\n\t\t\t\tUserPreferences.setDataFolder(dir);\n\t\t\t\tleaveErrorState();\n\t\t\t} else {\n\t\t\t\tAlertDialog.Builder ab = new AlertDialog.Builder(this);\n\t\t\t\tab.setMessage(message);\n\t\t\t\tab.setPositiveButton(android.R.string.ok, null);\n\t\t\t\tab.show();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate void leaveErrorState() {\n\t\tfinish();\n\t\tstartActivity(new Intent(this, MainActivity.class));\n\t}\n\n\tprivate BroadcastReceiver mediaUpdate = new BroadcastReceiver() {\n\n\t\t@Override\n\t\tpublic void onReceive(Context context, Intent intent) {\n\t\t\tif (TextUtils.equals(intent.getAction(), Intent.ACTION_MEDIA_MOUNTED)) {\n\t\t\t\tif (intent.getBooleanExtra(\"read-only\", true)) {\n\t\t\t\t\tLog.d(TAG, \"Media was mounted; Finishing activity\");\n\t\t\t\t\tleaveErrorState();\n\t\t\t\t} else {\n\t\t\t\t\tLog.d(TAG, \"Media seemed to have been mounted read only\");\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t};\n\n}\n", "nted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\npackage com.wujilin.doorbell;\n\n/**\n * A convenience class to extend when you only want to listen for a subset of ringing callbacks.\n */\npublic class SimpleRingListener implements RingListener {\n\n    @Override\n    public void onComplete() {\n        // do nothing\n    }\n\n    @Override\n    public void onAllow() {\n        // do nothing\n    }\n\n    @Override\n    public void onBlock() {\n        // do nothing\n    }\n}\n", "stax.driver.core.UserType;\nimport org.sfm.datastax.DatastaxColumnKey;\nimport org.sfm.datastax.DatastaxMapperFactory;\nimport org.sfm.map.Mapper;\nimport org.sfm.map.MapperConfig;\nimport org.sfm.map.column.FieldMapperColumnDefinition;\nimport org.sfm.map.mapper.FieldMapperMapperBuilder;\nimport org.sfm.map.mapper.MapperSourceImpl;\nimport org.sfm.reflect.Getter;\nimport org.sfm.reflect.meta.ClassMeta;\n\nimport java.lang.reflect.Type;\nimport java.util.Iterator;\n\npublic class DatastaxUDTGetter<T> implements Getter<GettableByIndexData, T> {\n    private final Mapper<GettableByIndexData, T> mapper;\n    private final int index;\n\n    public DatastaxUDTGetter(Mapper<GettableByIndexData, T> mapper, int index) {\n        this.mapper = mapper;\n        this.index = index;\n    }\n\n    @Override\n    public T get(GettableByIndexData target) throws Exception {\n        return mapper.map(target.getUDTValue(index));\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    public static <P> Getter<GettableByIndexData, P> newInstance(DatastaxMapperFactory factory, Type target,  UserType tt, int index) {\n        Mapper<GettableByIndexData, P> mapper = newUDTMapper(target, tt, factory);\n        return new DatastaxUDTGetter<P>(mapper, index);\n    }\n\n    public static <P> Mapper<GettableByIndexData, P> newUDTMapper(Type target, UserType tt, DatastaxMapperFactory factory) {\n        FieldMapperMapperBuilder<GettableByIndexData, P, DatastaxColumnKey> builder = newFieldMapperBuilder(factory, target);\n\n        Iterator<UserType.Field> iterator = tt.iterator();\n        int i = 0;\n        while(iterator.hasNext()) {\n            UserType.Field f = iterator.next();\n            FieldMapperColumnDefinition<DatastaxColumnKey> identity = FieldMapperColumnDefinition.identity();\n            builder.addMapping(new DatastaxColumnKey(f.getName(), i, f.getType()), identity);\n            i ++;\n        }\n\n        return builder.mapper();\n    }\n\n    public static <P> FieldMapperMapperBuilder<GettableByIndexData, P, DatastaxColumnKey> newFieldMapperBuilder(DatastaxMapperFactory factory, Type target) {\n        MapperConfig<DatastaxColumnKey, FieldMapperColumnDefinition<DatastaxColumnKey>> config = factory.mapperConfig();\n        MapperSourceImpl<GettableByIndexData, DatastaxColumnKey> mapperSource = new MapperSourceImpl<GettableByIndexData, DatastaxColumnKey>(GettableByIndexData.class, new RowGetterFactory(factory));\n        ClassMeta<P> classMeta = factory.getClassMeta(target);\n        return new FieldMapperMapperBuilder<GettableByIndexData, P, DatastaxColumnKey>(\n                mapperSource,\n                classMeta,\n                config,\n                new DatastaxMappingContextFactoryBuilder()\n                );\n    }\n}\n", "t com.google.inject.Guice;\nimport com.google.inject.Injector;\nimport com.google.inject.persist.PersistFilter;\nimport com.google.inject.persist.jpa.JpaPersistModule;\nimport com.google.inject.servlet.ServletModule;\nimport jp.kde.lod.jacquet.mediaselector.model.*;\nimport jp.kde.lod.jacquet.mediaselector.model.dao.DefaultDaoProvider;\nimport jp.kde.lod.jacquet.mediaselector.model.dao.DefaultMediaDao;\nimport jp.kde.lod.jacquet.mediaselector.model.dao.DefaultUserDao;\nimport jp.kde.lod.jacquet.mediaselector.controller.servlethandler.DefaultServletHandler;\nimport jp.kde.lod.jacquet.mediaselector.model.storage.DefaultQueryStorage;\nimport jp.kde.lod.jacquet.mediaselector.model.storage.DefaultUpdateStorage;\n\nimport javax.servlet.ServletContext;\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * Created by Clement on 16/05/2015.\n */\npublic final class WebContext {\n    private WebContext() {\n\n    }\n\n    private static final String SESSION_USER_KEY = \"user\";\n\n    private static Injector INJECTOR = Guice.createInjector(new AbstractModule() {\n        @Override\n        protected void configure() {\n            super.bind(MediaDao.class).to(DefaultMediaDao.class);\n            super.bind(UserDao.class).to(DefaultUserDao.class);\n            super.bind(DaoProvider.class).to(DefaultDaoProvider.class);\n            super.bind(QueryStorage.class).to(DefaultQueryStorage.class);\n            super.bind(UpdateStorage.class).to(DefaultUpdateStorage.class);\n\n            super.install(new ServletModule() {\n                @Override\n                protected void configureServlets() {\n                    super.configureServlets();\n\n                    super.install(new JpaPersistModule(\"mediaselector\"));\n                    super.filter(\"/*\").through(PersistFilter.class);\n                }\n            });\n        }\n    });\n\n    public static DefaultServletHandler getServletHandler(ServletContext context,\n                                                                HttpServletRequest request,\n                                                                HttpServletResponse response) {\n        DefaultServletHandler handler = INJECTOR.getInstance(DefaultServletHandler.class);\n        handler.setContext(context);\n        handler.setRequest(request);\n        handler.setResponse(response);\n        handler.initDaoProvider();\n\n        QueryStorage queryStorage = handler.getQueryStorage();\n        queryStorage.add(\"getMainResourceType\", handler.getAbsolutePath(\"/sparql/get-main-resource-type.rq\"));\n        queryStorage.add(\"getMedia\", handler.getAbsolutePath(\"/sparql/get-media.rq\"));\n        queryStorage.add(\"getMediaCounter\", handler.getAbsolutePath(\"/sparql/get-media-counter.rq\"));\n        queryStorage.add(\"isMainResourceRated\", handler.getAbsolutePath(\"/sparql/is-main-resource-rated.rq\"));\n        queryStorage.add(\"getLikeCount\", handler.getAbsolutePath(\"/sparql/get-like-count.rq\"));\n        queryStorage.add(\"getUsersLikes\", handler.getAbsolutePath(\"/sparql/get-users-likes.rq\"));\n        queryStorage.add(\"getUserUri\", handler.getAbsolutePath(\"/sparql/get-user-uri.rq\"));\n        queryStorage.add(\"getOwnedMedias\", handler.getAbsolutePath(\"/sparql/get-owned-medias.rq\"));\n        queryStorage.add(\"getUnratedResources\", handler.getAbsolutePath(\"/sparql/get-unrated-resources.rq\"));\n        queryStorage.add(\"searchMedia\", handler.getAbsolutePath(\"/sparql/search-media.rq\"));\n        queryStorage.add(\"searchResources\", handler.getAbsolutePath(\"/sparql/external/search-resources.rq\"));\n        queryStorage.add(\"searchResourcesLang\", handler.getAbsolutePath(\"/sparql/external/search-resources-lang.rq\"));\n        queryStorage.add(\"getMainResource\", handler.getAbsolutePath(\"/sparql/external/get-main-resource.rq\"));\n        queryStorage.add(\"getMainResourceLang\", handler.getAbsolutePath(\"/sparql/external/get-main-resource-lang.rq\"));\n        queryStorage.add(\"getSubscriptions\", handler.getAbsolutePath(\"/sparql/get-subscriptions.rq\"));\n        queryStorage.add(\"getUserSubscribedCount\", handler.getAbsolutePath(\"/sparql/get-user-subscribed-count.rq\"));\n        queryStorage.add(\"isUserSubscribed\", handler.getAbsolutePath(\"/sparql/is-user-subscribed.rq\"));\n\n        UpdateStorage updateStorage = handler.getUpdateStorage();\n        updateStorage.add(\"deleteMainResource\", handler.getAbsolutePath(\"/sparqlu/delete-main-resource.ru\"));\n        updateStorage.add(\"deleteMainResourceType\", handler.getAbsolutePath(\"/sparqlu/delete-main-resource-type.ru\"));\n        updateStorage.add(\"deleteMedia\", handler.getAbsolutePath(\"/sparqlu/delete-media.ru\"));\n        updateStorage.add(\"insertMainResource\", handler.getAbsolutePath(\"/sparqlu/insert-main-resource.ru\"));\n        updateStorage.add(\"insertMainResourceType\", handler.getAbsolutePath(\"/sparqlu/insert-main-resource-type.ru\"));\n        updateStorage.add(\"insertMedia\", handler.getAbsolutePath(\"/sparqlu/insert-media.ru\"));\n        updateStorage.add(\"setMediaCounter\", handler.getAbsolutePath(\"/sparqlu/set-media-counter.ru\"));\n        updateStorage.add(\"saveUser\", handler.getAbsolutePath(\"/sparqlu/save-user.ru\"));\n        updateStorage.add(\"insertRate\", handler.getAbsolutePath(\"/sparqlu/insert-rate.ru\"));\n        updateStorage.add(\"deleteRate\", handler.getAbsolutePath(\"/sparqlu/delete-rate.ru\"));\n        updateStorage.add(\"subscribeUserToMedia\", handler.getAbsolutePath(\"/sparqlu/subscribe-user-to-media.ru\"));\n        updateStorage.add(\"unsubscribeUserToMedia\", handler.getAbsolutePath(\"/sparqlu/unsubscribe-user-to-media.ru\"));\n\n        return handler;\n    }\n\n    public static String getSessionUserKey() {\n        return SESSION_USER_KEY;\n    }\n\n    public static Injector getInjector() {\n        return INJECTOR;\n    }\n}\n", "apper;\r\nimport com.xmomen.module.base.entity.CdActivityAddress;\r\nimport com.xmomen.module.base.entity.CdActivityAddressExample;\r\nimport org.apache.ibatis.annotations.Param;\r\n\r\npublic interface CdActivityAddressMapper extends MybatisMapper {\r\n    int countByExample(CdActivityAddressExample example);\r\n\r\n    int deleteByExample(CdActivityAddressExample example);\r\n\r\n    int insertSelective(CdActivityAddress record);\r\n\r\n    int updateByExampleSelective(@Param(\"record\") CdActivityAddress record, @Param(\"example\") CdActivityAddressExample example);\r\n}", "tor.Entity;\nimport de.greenrobot.daogenerator.Property;\nimport de.greenrobot.daogenerator.Schema;\nimport de.greenrobot.daogenerator.ToMany;\n\npublic class MyDaoGenerator {\n    public static void main(String args[]) throws Exception {\n        Schema schema = new Schema(3, \"com.ua.viktor.amp.dao\");\n\n        Entity question = schema.addEntity(\"Question\");\n        question.addIdProperty();\n        question.addStringProperty(\"text\").notNull();\n        question.addIntProperty(\"ID\");\n\n        Entity answers = schema.addEntity(\"Answers\");\n        answers.addIdProperty();\n        answers.addStringProperty(\"text\").notNull();\n        answers.addIntProperty(\"ID\");\n\n        Entity choice = schema.addEntity(\"Choice\");\n        choice.setTableName(\"CHOICES\");\n        choice.addIdProperty();\n        choice.addStringProperty(\"item\");\n        choice.addIntProperty(\"ID\");\n        choice.addIntProperty(\"count\");\n        Property questionId = choice.addLongProperty(\"questionId\").notNull().getProperty();\n        choice.addToOne(question, questionId);\n\n        ToMany questionToChoice = question.addToMany(choice, questionId);\n        questionToChoice.setName(\"question\");\n\n\n\n\n        new DaoGenerator().generateAll(schema, \"../AMP/app/src/main/java\");\n    }\n}\n", "t org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.hamcrest.CoreMatchers.*;\n\n/**\n * Created by soive on 16.06.2016.\n */\n@RunWith(MockitoJUnitRunner.class)\npublic class HashTest {\n\n    @Test\n    public void testHashing() {\n        String pass = \"aaaaa\";\n        String result = HashUtils.HashText(pass);\n        assertThat(result, is(\"ed968e840d10d2d313a870bc131a4e2c311d7ad09bdf32b3418147221f51a6e2\"));\n    }\n\n\n}\n", "{\r\n    private long pageTimeout;\r\n    private int maxHttpConnections;\r\n    private long maxPageRetrievalSize;\r\n    private long maxFileRetrievalSize;\r\n    private String userAgentString;\r\n    \r\n    public long getPageTimeout()\r\n    {\r\n\t   return pageTimeout;\r\n    }\r\n\r\n    public int getMaxHttpConnections()\r\n    {\r\n\t   return maxHttpConnections;\r\n    }\r\n\r\n    public void setMaxHttpConnections(int maxHttpConnections)\r\n    {\r\n\t   this.maxHttpConnections = maxHttpConnections;\r\n    }\r\n\r\n    public void setPageTimeout(long pageTimeout)\r\n    {\r\n\t   this.pageTimeout = pageTimeout;\r\n    }\r\n\r\n    public void setMaxPageRetrievalSize(long maxPageRetrievalSize)\r\n    {\r\n\t   this.maxPageRetrievalSize = maxPageRetrievalSize;\r\n    }\r\n\r\n    public long getMaxPageRetrievalSize()\r\n    {\r\n\t   return maxPageRetrievalSize;\r\n    }\r\n\r\n\tpublic void setMaxFileRetrievalSize(long maxFileRetrievalSize)\r\n\t{\r\n\t\tthis.maxFileRetrievalSize = maxFileRetrievalSize;\r\n\t}\r\n\r\n\tpublic long getMaxFileRetrievalSize()\r\n\t{\r\n\t\treturn maxFileRetrievalSize;\r\n\t}\r\n\r\n\tpublic void setUserAgentString(String userAgentString)\r\n\t{\r\n\t\tthis.userAgentString = userAgentString;\r\n\t}\r\n\r\n\tpublic String getUserAgentString()\r\n\t{\r\n\t\treturn userAgentString;\r\n\t}\r\n}\r\n", "ic void merge(int A[], int m, int B[], int n) {\n\t\tint pa = m - 1;\n\t\tint pb = n - 1;\n\t\tint pc = m + n - 1;\n\t\twhile (pa >= 0 && pb >= 0) {\n\t\t\tif (A[pa] > B[pb]) {\n\t\t\t\tA[pc--] = A[pa--];\n\t\t\t} else {\n\t\t\t\tA[pc--] = B[pb--];\n\t\t\t}\n\t\t}\n\t\twhile (pa >= 0) {\n\t\t\tA[pc--] = A[pa--];\n\t\t}\n\t\twhile (pb >= 0) {\n\t\t\tA[pc--] = B[pb--];\n\t\t}\n\t}\n\n\t/**\n\t * http://leetcode.com/onlinejudge#question_21\n\t */\n\tpublic ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n\t\tif (l1 == null) {\n\t\t\treturn l2;\n\t\t} else if (l2 == null) {\n\t\t\treturn l1;\n\t\t} else {\n\t\t\tListNode l = null;\n\t\t\tListNode tail = l;\n\t\t\twhile (l1 != null && l2 != null) {\n\t\t\t\tListNode node;\n\t\t\t\tif (l1.val < l2.val) {\n\t\t\t\t\tnode = l1;\n\t\t\t\t\tl1 = l1.next;\n\n\t\t\t\t} else {\n\t\t\t\t\tnode = l2;\n\t\t\t\t\tl2 = l2.next;\n\t\t\t\t}\n\t\t\t\tnode.next = null;\n\t\t\t\tif (l == null) {\n\t\t\t\t\tl = node;\n\t\t\t\t\ttail = node;\n\t\t\t\t} else {\n\t\t\t\t\ttail.next = node;\n\t\t\t\t\ttail = node;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (l1 != null) {\n\t\t\t\ttail.next = l1;\n\t\t\t} else {\n\t\t\t\ttail.next = l2;\n\t\t\t}\n\t\t\treturn l;\n\t\t}\n\t}\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * @test\n * @bug     5007165\n * @summary Basic Test for LoggingMXBean (direct access to MXBean)\n * @author  Mandy Chung\n *\n * @build LoggingMXBeanTest2\n * @run main LoggingMXBeanTest2\n */\n\nimport java.util.logging.*;\nimport java.util.List;\nimport java.util.ListIterator;\n\npublic class LoggingMXBeanTest2\n{\n\n    static LoggingMXBean mbean = LogManager.getLoggingMXBean();\n    static String LOGGER_NAME_1 = \"com.sun.management.Logger\";\n    static String LOGGER_NAME_2 = \"com.sun.management.Logger.Logger2\";\n    static String UNKNOWN_LOGGER_NAME = \"com.sun.management.Unknown\";\n\n    public LoggingMXBeanTest2() throws Exception {\n\n        Logger logger1 = Logger.getLogger( LOGGER_NAME_1 );\n        logger1.setLevel(Level.FINE);\n        Logger logger2 = Logger.getLogger( LOGGER_NAME_2 );\n        logger2.setLevel(null);\n\n        /*\n         *  Check for the existence of our new Loggers\n         */\n        System.out.println(\"Test Logger Name retrieval (getLoggerNames)\");\n        boolean log1 = false, log2 = false;\n        List loggers = mbean.getLoggerNames();\n        if (loggers == null || loggers.size() < 2) {\n            throw new RuntimeException(\n                \"Could not Detect the presense of the new Loggers\");\n        }\n\n        for (ListIterator iter = loggers.listIterator(); iter.hasNext(); ) {\n            String logger = (String) iter.next();\n            if (logger.equals(LOGGER_NAME_1)) {\n                log1 = true;\n                System.out.println(\"  : Found new Logger : \" + logger);\n            }\n            if (logger.equals(LOGGER_NAME_2)) {\n                log2 = true;\n                System.out.println(\"  : Found new Logger : \" + logger);\n            }\n        }\n        if ( log1 && log2 )\n            System.out.println(\"  : PASSED.\" );\n        else {\n            System.out.println(\"  : FAILED.  Could not Detect the new Loggers.\" );\n            throw new RuntimeException(\n                \"Could not Detect the presense of the new Loggers\");\n        }\n\n        System.out.println(\"Test getLoggerLevel\");\n        String l1 = mbean.getLoggerLevel(LOGGER_NAME_1);\n        System.out.println(\"  : Level for Logger \" + LOGGER_NAME_1 + \" : \" + l1);\n        if (!l1.equals(Level.FINE.getName())) {\n            throw new RuntimeException(\n                \"Expected level for \" + LOGGER_NAME_1 + \" = \" +\n                 Level.FINE.getName() + \" but got \" + l1);\n        }\n        String l2 = mbean.getLoggerLevel(LOGGER_NAME_2);\n        System.out.println(\"  : Level for Logger \" + LOGGER_NAME_2 + \" : \" + l2);\n        if (!l2.equals(\"\")) {\n            throw new RuntimeException(\n                \"Expected level for \" + LOGGER_NAME_2 + \" = \\\"\\\"\" +\n                 \" but got \" + l2);\n        }\n        String l3 = mbean.getLoggerLevel(UNKNOWN_LOGGER_NAME);\n        System.out.println(\"  : Level for unknown logger : \" + l3);\n        if (l3 != null) {\n            throw new RuntimeException(\n                \"Expected level for \" + UNKNOWN_LOGGER_NAME + \" = null\" +\n                 \" but got \" + l3);\n        }\n\n        System.out.println(\"Test setLoggerLevel\");\n        mbean.setLoggerLevel(LOGGER_NAME_1, \"INFO\");\n        System.out.println(\"  : Set Level for Logger \" + LOGGER_NAME_1 + \" to: INFO\");\n        Level l = logger1.getLevel();\n        if (l != Level.INFO) {\n            throw new RuntimeException(\n                \"Expected level for \" + LOGGER_NAME_1 + \" = \" +\n                 Level.INFO + \" but got \" + l);\n        }\n\n        mbean.setLoggerLevel(LOGGER_NAME_2, \"SEVERE\");\n        System.out.println(\"  : Set Level for Logger \" + LOGGER_NAME_2 + \" to: SERVER\");\n        l = logger2.getLevel();\n        if (l != Level.SEVERE) {\n            throw new RuntimeException(\n                \"Expected level for \" + LOGGER_NAME_2 + \" = \" +\n                 Level.SEVERE+ \" but got \" + l);\n        }\n\n        mbean.setLoggerLevel(LOGGER_NAME_1, null);\n        System.out.println(\"  : Set Level for Logger \" + LOGGER_NAME_1 + \" to: null\");\n        l = logger1.getLevel();\n        if (l != null) {\n            throw new RuntimeException(\n                \"Expected level for \" + LOGGER_NAME_1 + \" = null \" +\n                 \" but got \" + l);\n        }\n\n        boolean iaeCaught = false;\n        System.out.println(\"  : Set Level for unknown Logger to: FINE\");\n        try {\n            mbean.setLoggerLevel(UNKNOWN_LOGGER_NAME, \"FINE\");\n        } catch (IllegalArgumentException e) {\n            // expected\n            iaeCaught = true;\n            System.out.println(\"      : IllegalArgumentException caught as expected\");\n        }\n        if (!iaeCaught) {\n            throw new RuntimeException(\n                \"Expected IllegalArgumentException for setting level for \" +\n                UNKNOWN_LOGGER_NAME + \" not thrown\");\n        }\n        iaeCaught = false;\n        System.out.println(\"  : Set Level for Logger \" + LOGGER_NAME_1 + \" to: DUMMY\");\n        try {\n            mbean.setLoggerLevel(LOGGER_NAME_1, \"DUMMY\");\n        } catch (IllegalArgumentException e) {\n            // expected\n            iaeCaught = true;\n            System.out.println(\"      : IllegalArgumentException caught as expected\");\n        }\n        if (!iaeCaught) {\n            throw new RuntimeException(\n                \"Expected IllegalArgumentException for invalid level.\");\n        }\n\n\n        System.out.println(\"Test getParentLoggerName\");\n        String p1 = mbean.getParentLoggerName(LOGGER_NAME_2);\n        System.out.println(\"  : Parent Logger for \" + LOGGER_NAME_2 + \" : \" + p1);\n        if (!p1.equals(LOGGER_NAME_1)) {\n            throw new RuntimeException(\n                \"Expected parent for \" + LOGGER_NAME_2 + \" = \" +\n                LOGGER_NAME_1 + \" but got \" + p1);\n        }\n        String p2 = mbean.getParentLoggerName(\"\");\n        System.out.println(\"  : Parent Logger for \\\"\\\" : \" + p2);\n        if (!p2.equals(\"\")) {\n            throw new RuntimeException(\n                \"Expected parent for root logger \\\"\\\" = \\\"\\\"\" +\n                \" but got \" + p2);\n        }\n        String p3 = mbean.getParentLoggerName(UNKNOWN_LOGGER_NAME);\n        System.out.println(\"  : Parent Logger for unknown logger : \" + p3);\n        if (p3 != null) {\n            throw new RuntimeException(\n                \"Expected level for \" + UNKNOWN_LOGGER_NAME + \" = null\" +\n                 \" but got \" + p3);\n        }\n    }\n\n    public static void main(String[] argv) throws Exception {\n        LoggingMXBeanTest2 p = new LoggingMXBeanTest2();\n    }\n}\n", " template file, choose Tools | Templates\n * and open the template in the editor.\n */\npackage com.inmobiliaria.model;\n\nimport com.fasterxml.jackson.annotation.JsonView;\nimport com.inmobiliaria.entities.Employee;\nimport com.inmobiliaria.util.Message;\nimport com.mkyong.web.jsonview.Views;\n\n/**\n *\n * @author ley\n */\npublic class AjaxResponseBodyEmployee {\n\n        @JsonView(Views.Public.class)\n\tMessage msg;\n\t@JsonView(Views.Public.class)\n\tEmployee result;\n\n    public Message getMsg() {\n        return msg;\n    }\n\n    public void setMsg(Message msg) {\n        this.msg = msg;\n    }\n\n    public Employee getResult() {\n        return result;\n    }\n\n    public void setResult(Employee result) {\n        this.result = result;\n    }\n\n    @Override\n    public String toString() {\n        return \"AjaxResponseResult [msg=\" + msg.getMessage() + \", code=\" + msg.getType() + \", result=\" + result + \"]\";\n    }\n\n}\n", ";\r\nimport java.util.Date;\r\nimport javax.persistence.Column;\r\nimport javax.persistence.Entity;\r\nimport javax.persistence.GeneratedValue;\r\nimport javax.persistence.Id;\r\nimport javax.persistence.Table;\r\nimport javax.persistence.Version;\r\n\r\n@Entity\r\n@Table(name = \"cd_activity_address\")\r\npublic class CdActivityAddress extends BaseMybatisModel {\r\n    /**\r\n     * \u4e3b\u952e\r\n     */\r\n    private Integer id;\r\n\r\n    /**\r\n     * \u5361\u53f7\r\n     */\r\n    private String couponNumber;\r\n\r\n    /**\r\n     * \r\n     */\r\n    private String consignmentName;\r\n\r\n    /**\r\n     * \u6536\u8d27\u624b\u673a\u53f7\r\n     */\r\n    private String consignmentPhone;\r\n\r\n    /**\r\n     * \u6536\u8d27\u5730\u5740\r\n     */\r\n    private String consignmentAddress;\r\n\r\n    /**\r\n     * \u8d60\u9001\u65e5\u671f\r\n     */\r\n    private Date sendTime;\r\n\r\n    /**\r\n     * \u8d60\u9001\u4efd\u6570\r\n     */\r\n    private Integer sendCount;\r\n\r\n    @Column(name = \"ID\")\r\n    @Id\r\n    @GeneratedValue(generator = \"UUIDGenerator\")\r\n    public Integer getId() {\r\n        return id;\r\n    }\r\n\r\n    public void setId(Integer id) {\r\n        this.id = id;\r\n        if(id == null){\r\n              removeValidField(\"id\");\r\n              return;\r\n        }\r\n        addValidField(\"id\");\r\n    }\r\n\r\n    @Column(name = \"COUPON_NUMBER\")\r\n    public String getCouponNumber() {\r\n        return couponNumber;\r\n    }\r\n\r\n    public void setCouponNumber(String couponNumber) {\r\n        this.couponNumber = couponNumber;\r\n        if(couponNumber == null){\r\n              removeValidField(\"couponNumber\");\r\n              return;\r\n        }\r\n        addValidField(\"couponNumber\");\r\n    }\r\n\r\n    @Column(name = \"CONSIGNMENT_NAME\")\r\n    public String getConsignmentName() {\r\n        return consignmentName;\r\n    }\r\n\r\n    public void setConsignmentName(String consignmentName) {\r\n        this.consignmentName = consignmentName;\r\n        if(consignmentName == null){\r\n              removeValidField(\"consignmentName\");\r\n              return;\r\n        }\r\n        addValidField(\"consignmentName\");\r\n    }\r\n\r\n    @Column(name = \"CONSIGNMENT_PHONE\")\r\n    public String getConsignmentPhone() {\r\n        return consignmentPhone;\r\n    }\r\n\r\n    public void setConsignmentPhone(String consignmentPhone) {\r\n        this.consignmentPhone = consignmentPhone;\r\n        if(consignmentPhone == null){\r\n              removeValidField(\"consignmentPhone\");\r\n              return;\r\n        }\r\n        addValidField(\"consignmentPhone\");\r\n    }\r\n\r\n    @Column(name = \"CONSIGNMENT_ADDRESS\")\r\n    public String getConsignmentAddress() {\r\n        return consignmentAddress;\r\n    }\r\n\r\n    public void setConsignmentAddress(String consignmentAddress) {\r\n        this.consignmentAddress = consignmentAddress;\r\n        if(consignmentAddress == null){\r\n              removeValidField(\"consignmentAddress\");\r\n              return;\r\n        }\r\n        addValidField(\"consignmentAddress\");\r\n    }\r\n\r\n    @Column(name = \"SEND_TIME\")\r\n    public Date getSendTime() {\r\n        return sendTime;\r\n    }\r\n\r\n    public void setSendTime(Date sendTime) {\r\n        this.sendTime = sendTime;\r\n        if(sendTime == null){\r\n              removeValidField(\"sendTime\");\r\n              return;\r\n        }\r\n        addValidField(\"sendTime\");\r\n    }\r\n\r\n    @Column(name = \"SEND_COUNT\")\r\n    public Integer getSendCount() {\r\n        return sendCount;\r\n    }\r\n\r\n    public void setSendCount(Integer sendCount) {\r\n        this.sendCount = sendCount;\r\n        if(sendCount == null){\r\n              removeValidField(\"sendCount\");\r\n              return;\r\n        }\r\n        addValidField(\"sendCount\");\r\n    }\r\n}", "d/or its affiliates.  All rights reserved.\n *\n */\n\npackage com.sleepycat.bind.serial;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.ObjectInputStream;\nimport java.io.ObjectOutputStream;\nimport java.io.ObjectStreamClass;\nimport java.io.Serializable;\nimport java.math.BigInteger;\nimport java.util.HashMap;\n\nimport com.sleepycat.compat.DbCompat;\nimport com.sleepycat.db.Cursor;\nimport com.sleepycat.db.CursorConfig;\nimport com.sleepycat.db.Database;\nimport com.sleepycat.db.DatabaseConfig;\nimport com.sleepycat.db.DatabaseEntry;\nimport com.sleepycat.db.DatabaseException;\nimport com.sleepycat.db.EnvironmentConfig;\nimport com.sleepycat.db.LockMode;\nimport com.sleepycat.db.OperationStatus;\nimport com.sleepycat.db.Transaction;\nimport com.sleepycat.util.FastInputStream;\nimport com.sleepycat.util.FastOutputStream;\nimport com.sleepycat.util.RuntimeExceptionWrapper;\nimport com.sleepycat.util.UtfOps;\n\n/**\n * A <code>ClassCatalog</code> that is stored in a <code>Database</code>.\n *\n * <p>A single <code>StoredClassCatalog</code> object is normally used along\n * with a set of databases that stored serialized objects.</p>\n *\n * @author Mark Hayes\n *\n * @see <a href=\"SerialBinding.html#evolution\">Class Evolution</a>\n */\npublic class StoredClassCatalog implements ClassCatalog {\n\n    /*\n     * Record types ([key] [data]):\n     *\n     * [0] [next class ID]\n     * [1 / class ID] [ObjectStreamClass (class format)]\n     * [2 / class name] [ClassInfo (has 8 byte class ID)]\n     */\n    private static final byte REC_LAST_CLASS_ID = (byte) 0;\n    private static final byte REC_CLASS_FORMAT = (byte) 1;\n    private static final byte REC_CLASS_INFO = (byte) 2;\n\n    private static final byte[] LAST_CLASS_ID_KEY = {REC_LAST_CLASS_ID};\n\n    private Database db;\n    private HashMap<String, ClassInfo> classMap;\n    private HashMap<BigInteger, ObjectStreamClass> formatMap;\n    private LockMode writeLockMode;\n    private boolean cdbMode;\n    private boolean txnMode;\n\n    /**\n     * Creates a catalog based on a given database. To save resources, only a\n     * single catalog object should be used for each unique catalog database.\n     *\n     * @param database an open database to use as the class catalog.  It must\n     * be a BTREE database and must not allow duplicates.\n     *\n     * @throws DatabaseException if an error occurs accessing the database.\n     *\n     * @throws IllegalArgumentException if the database is not a BTREE database\n     * or if it configured to allow duplicates.\n     */\n    public StoredClassCatalog(Database database)\n        throws DatabaseException, IllegalArgumentException {\n\n        db = database;\n        DatabaseConfig dbConfig = db.getConfig();\n        EnvironmentConfig envConfig = db.getEnvironment().getConfig();\n\n        writeLockMode = (DbCompat.getInitializeLocking(envConfig) ||\n                         envConfig.getTransactional()) ? LockMode.RMW\n                                                       : LockMode.DEFAULT;\n        cdbMode = DbCompat.getInitializeCDB(envConfig);\n        txnMode = dbConfig.getTransactional();\n\n        if (!DbCompat.isTypeBtree(dbConfig)) {\n            throw new IllegalArgumentException\n                (\"The class catalog must be a BTREE database.\");\n        }\n        if (DbCompat.getSortedDuplicates(dbConfig) ||\n            DbCompat.getUnsortedDuplicates(dbConfig)) {\n            throw new IllegalArgumentException\n                (\"The class catalog database must not allow duplicates.\");\n        }\n\n        /*\n         * Create the class format and class info maps. Note that these are not\n         * synchronized, and therefore the methods that use them are\n         * synchronized.\n         */\n        classMap = new HashMap<String, ClassInfo>();\n        formatMap = new HashMap<BigInteger, ObjectStreamClass>();\n\n        DatabaseEntry key = new DatabaseEntry(LAST_CLASS_ID_KEY);\n        DatabaseEntry data = new DatabaseEntry();\n        if (dbConfig.getReadOnly()) {\n            /* Check that the class ID record exists. */\n            OperationStatus status = db.get(null, key, data, null);\n            if (status != OperationStatus.SUCCESS) {\n                throw DbCompat.unexpectedState\n                    (\"A read-only catalog database may not be empty\");\n            }\n        } else {\n            /* Add the initial class ID record if it doesn't exist.  */\n            data.setData(new byte[1]); // zero ID\n\n            /*\n             * Query the record before writing it to the database, to avoid\n             * ReplicaWriteException while opening a StoredClassCatalog on the\n             * replicas.\n             */\n            OperationStatus status = db.get(null, key, data, null);\n            if (status == OperationStatus.NOTFOUND) {\n                db.putNoOverwrite(null, key, data);\n            }\n        }\n    }\n\n    // javadoc is inherited\n    public synchronized void close()\n        throws DatabaseException {\n\n        if (db != null) {\n            db.close();\n        }\n        db = null;\n        formatMap = null;\n        classMap = null;\n    }\n\n    // javadoc is inherited\n    public synchronized byte[] getClassID(ObjectStreamClass classFormat)\n        throws DatabaseException, ClassNotFoundException {\n\n        ClassInfo classInfo = getClassInfo(classFormat);\n        return classInfo.getClassID();\n    }\n\n    // javadoc is inherited\n    public synchronized ObjectStreamClass getClassFormat(byte[] classID)\n        throws DatabaseException, ClassNotFoundException {\n\n        return getClassFormat(classID, new DatabaseEntry());\n    }\n\n    /**\n     * Internal function for getting the class format.  Allows passing the\n     * DatabaseEntry object for the data, so the bytes of the class format can\n     * be examined afterwards.\n     */\n    private ObjectStreamClass getClassFormat(byte[] classID,\n                                             DatabaseEntry data)\n        throws DatabaseException, ClassNotFoundException {\n\n        /* First check the map and, if found, add class info to the map. */\n\n        BigInteger classIDObj = new BigInteger(classID);\n        ObjectStreamClass classFormat = formatMap.get(classIDObj);\n        if (classFormat == null) {\n\n            /* Make the class format key. */\n\n            byte[] keyBytes = new byte[classID.length + 1];\n            keyBytes[0] = REC_CLASS_FORMAT;\n            System.arraycopy(classID, 0, keyBytes, 1, classID.length);\n            DatabaseEntry key = new DatabaseEntry(keyBytes);\n\n            /* Read the class format. */\n\n            OperationStatus status = db.get(null, key, data, LockMode.DEFAULT);\n            if (status != OperationStatus.SUCCESS) {\n                throw new ClassNotFoundException(\"Catalog class ID not found\");\n            }\n            try {\n                ObjectInputStream ois =\n                    new ObjectInputStream(\n                        new ByteArrayInputStream(data.getData(),\n                                                 data.getOffset(),\n                                                 data.getSize()));\n                classFormat = (ObjectStreamClass) ois.readObject();\n            } catch (IOException e) {\n                throw RuntimeExceptionWrapper.wrapIfNeeded(e);\n            }\n\n            /* Update the class format map. */\n\n            formatMap.put(classIDObj, classFormat);\n        }\n        return classFormat;\n    }\n\n    /**\n     * Get the ClassInfo for a given class name, adding it and its\n     * ObjectStreamClass to the database if they are not already present, and\n     * caching both of them using the class info and class format maps.  When a\n     * class is first loaded from the database, the stored ObjectStreamClass is\n     * compared to the current ObjectStreamClass loaded by the Java class\n     * loader; if they are different, a new class ID is assigned for the\n     * current format.\n     */\n    private ClassInfo getClassInfo(ObjectStreamClass classFormat)\n        throws DatabaseException, ClassNotFoundException {\n\n        /*\n         * First check for a cached copy of the class info, which if\n         * present always contains the class format object.\n         */\n        String className = classFormat.getName();\n        ClassInfo classInfo = classMap.get(className);\n        if (classInfo != null) {\n            return classInfo;\n        } else {\n            /* Make class info key.  */\n            char[] nameChars = className.toCharArray();\n            byte[] keyBytes = new byte[1 + UtfOps.getByteLength(nameChars)];\n            keyBytes[0] = REC_CLASS_INFO;\n            UtfOps.charsToBytes(nameChars, 0, keyBytes, 1, nameChars.length);\n            DatabaseEntry key = new DatabaseEntry(keyBytes);\n\n            /* Read class info.  */\n            DatabaseEntry data = new DatabaseEntry();\n            OperationStatus status = db.get(null, key, data, LockMode.DEFAULT);\n            if (status != OperationStatus.SUCCESS) {\n            \n                /*\n                 * Workaround for a Harmony bug that appears on Android.  The\n                 * ObjectStreamClass is not properly initialized, and using it\n                 * later will cause NullPointerException.  Serializing it and\n                 * then deserializing it causes is to be initialized properly.\n                 * [#18163]\n                 */\n                if (DbCompat.isDalvik()) {\n                    try {\n                        /* Serialize classFormat first. */\n                        FastOutputStream fo = new FastOutputStream();\n                        ObjectOutputStream oos = new ObjectOutputStream(fo);\n                        oos.writeObject(classFormat);\n                        byte[] bytes = fo.toByteArray();\n                        /* Then deserialize classFormat. */\n                        FastInputStream fi = new FastInputStream(bytes);\n                        ObjectInputStream ois = new ObjectInputStream(fi);\n                        classFormat = (ObjectStreamClass) ois.readObject();\n                    } catch (Exception e) {\n                        throw RuntimeExceptionWrapper.wrapIfNeeded(e);\n                    }\n                }\n                \n                /*\n                 * Not found in the database, write class info and class\n                 * format.\n                 */\n                classInfo = putClassInfo(new ClassInfo(), className, key,\n                                         classFormat);\n            } else {\n                /*\n                 * Read class info to get the class format key, then read class\n                 * format.\n                 */\n                classInfo = new ClassInfo(data);\n                DatabaseEntry formatData = new DatabaseEntry();\n                ObjectStreamClass storedClassFormat =\n                    getClassFormat(classInfo.getClassID(), formatData);\n\n                /*\n                 * Compare the stored class format to the current class format,\n                 * and if they are different then generate a new class ID.\n                 */\n                if (!areClassFormatsEqual(storedClassFormat,\n                                          getBytes(formatData),\n                                          classFormat)) {\n                    classInfo = putClassInfo(classInfo, className, key,\n                                             classFormat);\n                }\n\n                /* Update the class info map.  */\n                classInfo.setClassFormat(classFormat);\n                classMap.put(className, classInfo);\n            }\n        }\n        return classInfo;\n    }\n\n    /**\n     * Assign a new class ID (increment the current ID record), write the\n     * ObjectStreamClass record for this new ID, and update the ClassInfo\n     * record with the new ID also.  The ClassInfo passed as an argument is the\n     * one to be updated.\n     */\n    private ClassInfo putClassInfo(ClassInfo classInfo,\n                                   String className,\n                                   DatabaseEntry classKey,\n                                   ObjectStreamClass classFormat)\n        throws DatabaseException {\n\n        /* An intent-to-write cursor is needed for CDB. */\n        CursorConfig cursorConfig = null;\n        if (cdbMode) {\n            cursorConfig = new CursorConfig();\n            DbCompat.setWriteCursor(cursorConfig, true);\n        }\n        Cursor cursor = null;\n        Transaction txn = null;\n        try {\n            if (txnMode) {\n                txn = db.getEnvironment().beginTransaction(null, null);\n            }\n            cursor = db.openCursor(txn, cursorConfig);\n\n            /* Get the current class ID. */\n            DatabaseEntry key = new DatabaseEntry(LAST_CLASS_ID_KEY);\n            DatabaseEntry data = new DatabaseEntry();\n            OperationStatus status = cursor.getSearchKey(key, data,\n                                                         writeLockMode);\n            if (status != OperationStatus.SUCCESS) {\n                throw DbCompat.unexpectedState(\"Class ID not initialized\");\n            }\n            byte[] idBytes = getBytes(data);\n\n            /* Increment the ID by one and write the updated record.  */\n            idBytes = incrementID(idBytes);\n            data.setData(idBytes);\n            cursor.put(key, data);\n\n            /*\n             * Write the new class format record whose key is the ID just\n             * assigned.\n             */\n            byte[] keyBytes = new byte[1 + idBytes.length];\n            keyBytes[0] = REC_CLASS_FORMAT;\n            System.arraycopy(idBytes, 0, keyBytes, 1, idBytes.length);\n            key.setData(keyBytes);\n\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            ObjectOutputStream oos;\n            try {\n                oos = new ObjectOutputStream(baos);\n                oos.writeObject(classFormat);\n            } catch (IOException e) {\n                throw RuntimeExceptionWrapper.wrapIfNeeded(e);\n            }\n            data.setData(baos.toByteArray());\n\n            cursor.put(key, data);\n\n            /*\n             * Write the new class info record, using the key passed in; this\n             * is done last so that a reader who gets the class info record\n             * first will always find the corresponding class format record.\n             */\n            classInfo.setClassID(idBytes);\n            classInfo.toDbt(data);\n\n            cursor.put(classKey, data);\n\n            /*\n             * Update the maps before closing the cursor, so that the cursor\n             * lock prevents other writers from duplicating this entry.\n             */\n            classInfo.setClassFormat(classFormat);\n            classMap.put(className, classInfo);\n            formatMap.put(new BigInteger(idBytes), classFormat);\n            return classInfo;\n        } finally {\n            if (cursor != null) {\n                cursor.close();\n            }\n            if (txn != null) {\n                txn.commit();\n            }\n        }\n    }\n\n    private static byte[] incrementID(byte[] key) {\n\n        BigInteger id = new BigInteger(key);\n        id = id.add(BigInteger.valueOf(1));\n        return id.toByteArray();\n    }\n\n    /**\n     * Holds the class format key for a class, maintains a reference to the\n     * ObjectStreamClass.  Other fields can be added when we need to store more\n     * information per class.\n     */\n    private static class ClassInfo implements Serializable {\n        static final long serialVersionUID = 3845446969989650562L;\n\n        private byte[] classID;\n        private transient ObjectStreamClass classFormat;\n\n        ClassInfo() {\n        }\n\n        ClassInfo(DatabaseEntry dbt) {\n\n            byte[] data = dbt.getData();\n            int len = data[0];\n            classID = new byte[len];\n            System.arraycopy(data, 1, classID, 0, len);\n        }\n\n        void toDbt(DatabaseEntry dbt) {\n\n            byte[] data = new byte[1 + classID.length];\n            data[0] = (byte) classID.length;\n            System.arraycopy(classID, 0, data, 1, classID.length);\n            dbt.setData(data);\n        }\n\n        void setClassID(byte[] classID) {\n\n            this.classID = classID;\n        }\n\n        byte[] getClassID() {\n\n            return classID;\n        }\n\n        ObjectStreamClass getClassFormat() {\n\n            return classFormat;\n        }\n\n        void setClassFormat(ObjectStreamClass classFormat) {\n\n            this.classFormat = classFormat;\n        }\n    }\n\n    /**\n     * Return whether two class formats are equal.  This determines whether a\n     * new class format is needed for an object being serialized.  Formats must\n     * be identical in all respects, or a new format is needed.\n     */\n    private static boolean areClassFormatsEqual(ObjectStreamClass format1,\n                                                byte[] format1Bytes,\n                                                ObjectStreamClass format2) {\n        try {\n            if (format1Bytes == null) { // using cached format1 object\n                format1Bytes = getObjectBytes(format1);\n            }\n            byte[] format2Bytes = getObjectBytes(format2);\n            return java.util.Arrays.equals(format2Bytes, format1Bytes);\n        } catch (IOException e) { return false; }\n    }\n\n    /*\n     * We can return the same byte[] for 0 length arrays.\n     */\n    private static byte[] ZERO_LENGTH_BYTE_ARRAY = new byte[0];\n\n    private static byte[] getBytes(DatabaseEntry dbt) {\n        byte[] b = dbt.getData();\n        if (b == null) {\n            return null;\n        }\n        if (dbt.getOffset() == 0 && b.length == dbt.getSize()) {\n            return b;\n        }\n        int len = dbt.getSize();\n        if (len == 0) {\n            return ZERO_LENGTH_BYTE_ARRAY;\n        } else {\n            byte[] t = new byte[len];\n            System.arraycopy(b, dbt.getOffset(), t, 0, t.length);\n            return t;\n        }\n    }\n\n    private static byte[] getObjectBytes(Object o)\n        throws IOException {\n\n        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n        ObjectOutputStream oos = new ObjectOutputStream(baos);\n        oos.writeObject(o);\n        return baos.toByteArray();\n    }\n\n    /**\n     * For BDB JE, returns the ClassLoader property of the catalog database\n     * environment.  This ensures that the Environment's ClassLoader property\n     * is used for loading all user-supplied classes.\n     *\n     * <p>For BDB, this method returns null because no Environment ClassLoader\n     * property is available.  This method may be overridden to return a\n     * ClassLoader.</p>\n     */\n    public ClassLoader getClassLoader() {\n        try {\n            return DbCompat.getClassLoader(db.getEnvironment());\n        } catch (DatabaseException e) {\n\n            /*\n             * DatabaseException is declared to be thrown by getEnvironment in\n             * DB (not JE), but this should never happen in practice.\n             */\n            throw new RuntimeException(e);\n        }\n    }\n}\n", "o = k;\n\t}\n\t@Override\n\tpublic boolean equals(Object o) {\n\t\t//if (this == o) return true;// opzionale\n\t\tif (o instanceof Data) {\n\t\t\tData d = (Data) o;\n\t\t\treturn this.giorno == d.giorno && this.mese == d.mese && this.anno == d.anno;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n}\n\n\npublic class ProvaEquals {\n\tpublic static void main(String[] args) {\n\t\tData d1 = new Data(3, 4, 2007);\n\t\tData d2 = new Data(3, 4, 2007);\n\t\tSystem.out.println(d1.equals(d2));\n\t\tSystem.out.println(d1.equals(\"nondata\"));\t\t\n\t}\n\n}\n", "port java.util.HashMap;\nimport java.util.Set;\nimport java.util.UUID;\n\nimport org.bukkit.BanList;\nimport org.bukkit.Bukkit;\nimport org.bukkit.configuration.Configuration;\nimport org.bukkit.configuration.file.FileConfiguration;\nimport org.bukkit.entity.Player;\n\nimport com.alecgorge.minecraft.jsonapi.APIException;\nimport com.alecgorge.minecraft.jsonapi.JSONAPI;\nimport com.alecgorge.minecraft.jsonapi.dynamic.API_Method;\nimport com.alecgorge.minecraft.jsonapi.dynamic.JSONAPIMethodProvider;\nimport com.earth2me.essentials.Essentials;\nimport com.earth2me.essentials.User;\n\npublic class EssentialsAPIMethods implements JSONAPIMethodProvider {\n\tprivate Essentials\tess;\n\t\n\tpublic EssentialsAPIMethods(JSONAPI api) {\n\t\tif (api.getServer().getPluginManager().getPlugin(\"Essentials\") != null) {\n\t\t\tapi.getCaller().registerMethods(this);\n\t\t}\n\t}\n\n\t@API_Method(name = \"essentials.reload\", description = \"Reloads the plugin\", argumentDescriptions = { \"void\" }, returnDescription = \"void\")\n\tpublic void reload() {\n\t\tess.reload();\n\t}\n\n\t@API_Method(name = \"essentials.config.get_keys\", argumentDescriptions = { \"void\" }, returnDescription = \"Gets the list of keys as Set<string>\")\n\tpublic Set<String> get_configuration() {\n\t\tFileConfiguration x = ess.getConfig();\n\t\treturn x.getKeys(true);\n\t}\n\n\t@API_Method(name = \"essentials.config.get_text\", argumentDescriptions = { \"void\" }, returnDescription = \"Gets the whole configuration file as String\")\n\tpublic String get_configuration_text() {\n\t\tFileConfiguration x = ess.getConfig();\n\t\treturn x.saveToString();\n\t}\n\n\t@API_Method(name = \"essentials.config.get_value\", argumentDescriptions = { \"Path to the key\" }, returnDescription = \"path as key.key.key...\")\n\tpublic Object get_configuration_value(String path) {\n\t\tFileConfiguration x = ess.getConfig();\n\t\treturn x.get(path);\n\t}\n\n\n\t@API_Method(name = \"essentials.config.set_value\", argumentDescriptions = { \"Path to config key\", \"The value to set\", \"Should the plugin be reloaded after changing the value\" }, returnDescription = \"path as key.key.key...\")\n\tpublic boolean set_configuration_value(String path, Object value, boolean should_reload) throws IOException {\n\t\tFileConfiguration x = ess.getConfig();\n\t\tx.set(path, value);\n\t\tFile configFile = new File(Bukkit.getServer().getPluginManager().getPlugin(\"Essentials\").getDataFolder(), \"config.yml\");\n\t\tx.save(configFile);\n\t\tif (should_reload) {\n\t\t\treload();\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@API_Method(name = \"essentials.config.restore_default\", description = \"Resets the configuration file to it's default\", argumentDescriptions = { \"Should the plugin be reloaded after the operation\" }, returnDescription = \"true on success\")\n\tpublic boolean restore_default(boolean should_reload) {\n\t\tConfiguration conf = ess.getConfig().getDefaults();\n\t\tess.getConfig().setDefaults(conf);\n\t\tif (should_reload) {\n\t\t\treload();\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@API_Method(name = \"essentials.users.get_uuid\", description = \"Returns the UUID of a player(has to be online)\", argumentDescriptions = { \"Username\" }, returnDescription = \"on success\")\n\tpublic Object get_uuid(String name) throws APIException {\n\t\tif (ess.getUser(name).getBase().isOnline()) {\n\t\t\tObject x = ess.getUser(name).getBase().getUniqueId();\n\t\t\treturn x;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.add_mail\", description = \"Adds a mail to users' mailbox\", argumentDescriptions = { \"Username\", \"Contents of the message\" }, returnDescription = \"true on success\")\n\tpublic boolean send_mail(String name, String message) {\n\t\tess.getUser(name).addMail(message);\n\t\treturn true;\n\t}\n\n\n\t@API_Method(name = \"essentials.users.add_mail_all\", description = \"Adds a mail to all users\", argumentDescriptions = { \"Contents of the message\" }, returnDescription = \"true on success\")\n\tpublic boolean send_mail_all(String message) {\n\t\tfor (UUID userUuid : ess.getUserMap().getAllUniqueUsers()) {\n\t\t\tUser user = ess.getUserMap().getUser(userUuid);\n\t\t\tif (user != null) {\n\t\t\t\tuser.addMail(message);\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\n\t@API_Method(name = \"essentials.users.set_afk\", description = \"Change status of AFK of user\", argumentDescriptions = { \"Status to set (true - AFK)\" }, returnDescription = \"true on success\")\n\tpublic boolean set_afk(String name, Boolean status) throws APIException {\n\t\tif (ess.getUser(name).getBase().isOnline()) {\n\t\t\tess.getUser(name).setAfk(status);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.get_base\", description = \"Change status of AFK of user\", argumentDescriptions = { \"Status to set\" }, returnDescription = \"true on success\")\n\tpublic Object get_base(String name) throws APIException {\n\t\treturn ess.getUser(name).getBase().getPlayer();\n\t}\n\n\n\t@API_Method(name = \"essentials.users.tp_back\", description = \"Teleport player to last location\", argumentDescriptions = { \"Username\" }, returnDescription = \"true on success\")\n\tpublic boolean tp_back(String name) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tif (user.getLastLocation() == null) {\n\t\t\t\tthrow new APIException(\"noLocationFound\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\tuser.getTeleport().back();\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\tcatch (Exception ex) {\n\t\t\t\t\tthrow new APIException(ex.toString());\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.clear_inventory\", description = \"Clear inventory and armor of player\", argumentDescriptions = { \"Username\", \"Clear armor?\" }, returnDescription = \"true on success\")\n\tpublic boolean clear_inventory(String name, Boolean armor) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.getBase().getInventory().clear();\n\t\t\tif (armor) {\n\t\t\t\tuser.getBase().getInventory().setArmorContents(null);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.burn\", description = \"Set the player on fire.\", argumentDescriptions = { \"Username\", \"Time\" }, returnDescription = \"true on success\")\n\tpublic boolean burn(String name, Integer time) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.getBase().setFireTicks(time);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.fly\", description = \"Change fly mode of player.\", argumentDescriptions = { \"Username\", \"Mode (true - flying)\" }, returnDescription = \"true on success\")\n\tpublic boolean fly(String name, Boolean mode) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.getBase().setFlying(mode);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.get_pos\", description = \"Return location of player\", argumentDescriptions = { \"Username\" }, returnDescription = \"Location of player on success\")\n\tpublic Object get_pos(String name) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\treturn user.getLocation();\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.toggle_god\", description = \"Change god mode of player\", argumentDescriptions = { \"Username\", \"Mode\" }, returnDescription = \"true on success\")\n\tpublic Boolean toggle_god(String name, Boolean mode) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.setGodModeEnabled(mode);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.heal\", description = \"Heal the player\", argumentDescriptions = { \"Username\" }, returnDescription = \"true on success\")\n\tpublic Boolean heal(String name) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.getBase().setHealth(20);\n\t\t\tuser.getBase().setFoodLevel(20);\n\t\t\tuser.getBase().setFireTicks(0);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.set_nick\", description = \"Change the nickanme of player\", argumentDescriptions = { \"Username\", \"Nickname to set\" }, returnDescription = \"true on success\")\n\tpublic Boolean set_nick(String name, String nickname) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tfor (Player p : Bukkit.getOnlinePlayers()) {\n\t\t\t\tif (p.getDisplayName().toLowerCase().equals(nickname.toLowerCase())) {\n\t\t\t\t\tthrow new APIException(\"Nickname is used\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tuser.setNickname(nickname);\n\t\t\tuser.setDisplayNick();\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.clear_nick\", description = \"Clear the nickanme of player\", argumentDescriptions = { \"Username\" }, returnDescription = \"true on success\")\n\tpublic Boolean clear_nick(String name) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.setNickname(null);\n\t\t\tuser.setDisplayNick();\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.clear_all_powertools\", description = \"Clear all powertools of player\", argumentDescriptions = { \"Username\" }, returnDescription = \"true on success\")\n\tpublic Boolean clear_all_powertools(String name) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.clearAllPowertools();\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.seen\", description = \"Return the last logout time of player.\", argumentDescriptions = { \"Username\" }, returnDescription = \"Timestamp if offline, -1 if online\")\n\tpublic Object seen(String name) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\treturn -1;\n\t\t}\n\t\telse {\n\t\t\treturn user.getLastLogout();\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.vanish\", description = \"Change visible of player\", argumentDescriptions = { \"Username\", \"Mode to set\" }, returnDescription = \"true on success\")\n\tpublic Boolean vanish(String name, Boolean mode) throws APIException {\n\t\tUser user = ess.getUser(name);\n\t\tif (user.getBase().isOnline()) {\n\t\t\tuser.setVanished(mode);\n\t\t\treturn true;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"User is not online\");\n\t\t}\n\t}\n\n\n\t@API_Method(name = \"essentials.users.player_get_all\", description = \"Return all informations about player\", argumentDescriptions = { \"Username\" }, returnDescription = \"on success\")\n\tpublic HashMap<String, Object> player_get_all(String name) throws APIException {\n\t\tHashMap<String, Object> result = new HashMap<String, Object>();\n\t\tUser user1 = ess.getUser(name);\n\t\tif (user1.getBase().hasPlayedBefore()) {\n\t\t\tif (user1.getBase().isOnline()) {\n\t\t\t\tUser user = ess.getUser(name);\n\t\t\t\tresult.put(\"name\", user.getName());\n\t\t\t\tresult.put(\"nick\", user.getNickname());\n\t\t\t\tresult.put(\"money\", user.getMoney());\n\t\t\t\tresult.put(\"gamemode\", user.getBase().getGameMode());\n\t\t\t\tresult.put(\"godmode\", user.isGodModeEnabled());\n\t\t\t\tresult.put(\"fly\", user.isGodModeEnabled());\n\t\t\t\tresult.put(\"afk\", user.isAfk());\n\t\t\t\tresult.put(\"jail\", user.isJailed());\n\t\t\t\tif (user.isJailed()) {\n\t\t\t\t\tresult.put(\"jail_timeout\", user.getJailTimeout());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult.put(\"jail_timeout\", null);\n\t\t\t\t}\n\t\t\t\tresult.put(\"mute\", user.isMuted());\n\t\t\t\tif (user.isMuted()) {\n\t\t\t\t\tresult.put(\"mute_timeout\", user.getMuteTimeout());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult.put(\"mute_timeout\", null);\n\t\t\t\t}\n\t\t\t\tresult.put(\"can_build\", user.canBuild());\n\t\t\t\tresult.put(\"vanish\", user.isVanished());\n\t\t\t\tresult.put(\"bed_spawn_location\", user.getBase().getBedSpawnLocation());\n\t\t\t\tresult.put(\"ban\", user.getBase().isBanned());\n\t\t\t\tif (user.getBase().isBanned()) {\n\t\t\t\t\tresult.put(\"ban_reason\", Bukkit.getBanList(BanList.Type.NAME).getBanEntry(user.getName()).getReason().replaceAll(\"\ufffd\", \"\"));\n\t\t\t\t\tresult.put(\"ban_timeout\", Bukkit.getBanList(BanList.Type.NAME).getBanEntry(user.getName()).getExpiration());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult.put(\"ban_reason\", null);\n\t\t\t\t\tresult.put(\"ban_timeout\", null);\n\t\t\t\t}\n\t\t\t\tresult.put(\"can_pickup_items\", user.getBase().getCanPickupItems());\n\t\t\t\tresult.put(\"fire_ticks\", user.getBase().getFireTicks());\n\t\t\t\tresult.put(\"homes\", user.getHomes());\n\t\t\t\tresult.put(\"mails\", user.getMails());\n\t\t\t\tresult.put(\"walk_speed\", user.getBase().getWalkSpeed());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tUser user = ess.getOfflineUser(name);\n\t\t\t\tresult.put(\"name\", user.getName());\n\t\t\t\tresult.put(\"last_ip\", user.getLastLoginAddress());\n\t\t\t\tresult.put(\"nick\", user.getNickname());\n\t\t\t\tresult.put(\"money\", user.getMoney());\n\t\t\t\tresult.put(\"bed_spawn_location\", user.getBase().getBedSpawnLocation());\n\t\t\t\tresult.put(\"ban\", user.getBase().isBanned());\n\t\t\t\tif (user.getBase().isBanned()) {\n\t\t\t\t\tresult.put(\"ban_reason\", Bukkit.getBanList(BanList.Type.NAME).getBanEntry(user.getName()).getReason().replaceAll(\"\ufffd\", \"\"));\n\t\t\t\t\tresult.put(\"ban_timeout\", Bukkit.getBanList(BanList.Type.NAME).getBanEntry(user.getName()).getExpiration());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult.put(\"ban_reason\", null);\n\t\t\t\t\tresult.put(\"ban_timeout\", null);\n\t\t\t\t}\n\t\t\t\tresult.put(\"homes\", user.getHomes());\n\t\t\t\tresult.put(\"mails\", user.getMails());\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t\telse {\n\t\t\tthrow new APIException(\"Player has never been on the server.\");\n\t\t}\n\t}\n}\n", "on obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\n * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n * OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\n * WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage com.techshroom.tscore.math.processor.token;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport com.techshroom.tscore.math.processor.InfixProcessor;\n\npublic class DeferredInfixToken extends InfixProcessor implements Token {\n    private final List<Token> values;\n    private int ind = 0;\n\n    public DeferredInfixToken(List<Token> val) {\n        // string value not used\n        super(val.toString());\n        values = new ArrayList<Token>(val);\n    }\n\n    @Override\n    public String value() {\n        return process().toString();\n    }\n\n    @Override\n    public void doTheHardWork() {\n        doTokenize();\n        generateResult();\n    }\n\n    private void doTokenize() {\n        for (Token t : values) {\n            super_onToken(t, ind);\n            ind += t.value().length();\n        }\n    }\n\n    private void super_onToken(Token t, int index) {\n        super.onToken(t, index);\n    }\n\n    @Override\n    protected void onToken(Token t, int index) {\n        throw new UnsupportedOperationException(\n                \"A deffered parser cannot accept more tokens\");\n    }\n\n    @Override\n    public String toString() {\n        return values.toString() + \" (Deferred)\";\n    }\n\n    @Override\n    public int hashCode() {\n        return values.hashCode();\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        if (this == obj)\n            return true;\n        if (obj instanceof DeferredInfixToken) {\n            DeferredInfixToken other = (DeferredInfixToken) obj;\n            return values.equals(other.values);\n        }\n        return true;\n    }\n}\n", "springframework.data.annotation.Id;\nimport org.springframework.data.mongodb.core.mapping.Document;\n\n@Document\n@Value\n@Builder\npublic class Comic {\n\n    @Id\n    private String id;\n    private String title;\n    private String description;\n    private String issueNumber;\n\n}\n", "nted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included\n * in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage org.takes.rs;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Locale;\nimport lombok.EqualsAndHashCode;\nimport lombok.ToString;\nimport org.takes.Response;\nimport org.takes.misc.Condition;\nimport org.takes.misc.Select;\n\n/**\n * Response decorator, without a header.\n *\n * <p>The class is immutable and thread-safe.\n *\n * @author Yegor Bugayenko (yegor@teamed.io)\n * @version $Id$\n * @since 0.9\n */\n@ToString(callSuper = true)\n@EqualsAndHashCode(callSuper = true)\npublic final class RsWithoutHeader extends RsWrap {\n\n    /**\n     * Ctor.\n     * @param res Original response\n     * @param name Header name\n     */\n    public RsWithoutHeader(final Response res, final CharSequence name) {\n        super(\n             // @checkstyle AnonInnerLengthCheck (50 lines)\n            new Response() {\n                @Override\n                public Iterable<String> head() throws IOException {\n                    final String prefix = String.format(\n                        \"%s:\", name.toString().toLowerCase(Locale.ENGLISH)\n                    );\n                    return new Select<String>(\n                        res.head(),\n                        new Condition<String>() {\n                            @Override\n                            public boolean fits(final String header) {\n                                return !header.toLowerCase(Locale.ENGLISH)\n                                    .startsWith(prefix);\n                            }\n                        }\n                    );\n                }\n                @Override\n                public InputStream body() throws IOException {\n                    return res.body();\n                }\n            }\n        );\n    }\n}\n", "", "erated by MyBatis Generator.\r\n     * This field corresponds to the database column MOCHA_SECU_ROLE.ID\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    private String id;\r\n\r\n    /**\r\n     * This field was generated by MyBatis Generator.\r\n     * This field corresponds to the database column MOCHA_SECU_ROLE.NAME\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    private String name;\r\n\r\n    /**\r\n     * This field was generated by MyBatis Generator.\r\n     * This field corresponds to the database column MOCHA_SECU_ROLE.CREATE_TIME\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    private Long createTime;\r\n\r\n    /**\r\n     * This field was generated by MyBatis Generator.\r\n     * This field corresponds to the database column MOCHA_SECU_ROLE.DESCN\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    private String descn;\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method returns the value of the database column MOCHA_SECU_ROLE.ID\r\n     *\r\n     * @return the value of MOCHA_SECU_ROLE.ID\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public String getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method sets the value of the database column MOCHA_SECU_ROLE.ID\r\n     *\r\n     * @param id the value for MOCHA_SECU_ROLE.ID\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public void setId(String id) {\r\n        this.id = id == null ? null : id.trim();\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method returns the value of the database column MOCHA_SECU_ROLE.NAME\r\n     *\r\n     * @return the value of MOCHA_SECU_ROLE.NAME\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public String getName() {\r\n        return name;\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method sets the value of the database column MOCHA_SECU_ROLE.NAME\r\n     *\r\n     * @param name the value for MOCHA_SECU_ROLE.NAME\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public void setName(String name) {\r\n        this.name = name == null ? null : name.trim();\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method returns the value of the database column MOCHA_SECU_ROLE.CREATE_TIME\r\n     *\r\n     * @return the value of MOCHA_SECU_ROLE.CREATE_TIME\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public Long getCreateTime() {\r\n        return createTime;\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method sets the value of the database column MOCHA_SECU_ROLE.CREATE_TIME\r\n     *\r\n     * @param createTime the value for MOCHA_SECU_ROLE.CREATE_TIME\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public void setCreateTime(Long createTime) {\r\n        this.createTime = createTime;\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method returns the value of the database column MOCHA_SECU_ROLE.DESCN\r\n     *\r\n     * @return the value of MOCHA_SECU_ROLE.DESCN\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public String getDescn() {\r\n        return descn;\r\n    }\r\n\r\n    /**\r\n     * This method was generated by MyBatis Generator.\r\n     * This method sets the value of the database column MOCHA_SECU_ROLE.DESCN\r\n     *\r\n     * @param descn the value for MOCHA_SECU_ROLE.DESCN\r\n     *\r\n     * @mbggenerated Wed Feb 20 16:25:27 CST 2013\r\n     */\r\n    public void setDescn(String descn) {\r\n        this.descn = descn == null ? null : descn.trim();\r\n    }\r\n\t\r\n\t@Override\r\n   \tpublic String toString() {\r\n   \t\tStringBuilder builder = new StringBuilder();\r\n   \t\tbuilder.append(\"Role [id=\")\r\n   \t\t\t\t.append(this.id)\r\n   \t\t\t\t.append(\",name=\")\r\n   \t\t\t\t.append(this.name)\r\n   \t\t\t\t.append(\",createTime=\")\r\n   \t\t\t\t.append(this.createTime)\r\n   \t\t\t\t.append(\",descn=\")\r\n   \t\t\t\t.append(this.descn)\r\n   \t\t\t\t.append(\"]\\n\");\r\n   \t\treturn builder.toString();\r\n   \t}\r\n}", "stion_102\n * \n * @author fanzhang\n * \n */\npublic class LevelOrderTraverseBinaryTree {\n\tpublic ArrayList<ArrayList<Integer>> levelOrder(TreeNode root) {\n\t\tArrayList<ArrayList<Integer>> results = new ArrayList<ArrayList<Integer>>();\n\t\tif (root != null) {\n\t\t\tresults.add(new ArrayList<Integer>());\n\t\t\tLinkedList<TreeNode> queue = new LinkedList<TreeNode>();\n\t\t\tqueue.addLast(root);\n\t\t\tqueue.addLast(null);\n\t\t\twhile (!queue.isEmpty()) {\n\t\t\t\tTreeNode node = queue.removeFirst();\n\t\t\t\tif (node != null) {\n\t\t\t\t\tresults.get(results.size() - 1).add(node.val);\n\t\t\t\t\tif (node.left != null) {\n\t\t\t\t\t\tqueue.addLast(node.left);\n\t\t\t\t\t}\n\t\t\t\t\tif (node.right != null) {\n\t\t\t\t\t\tqueue.addLast(node.right);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tif (queue.isEmpty()) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresults.add(new ArrayList<Integer>());\n\t\t\t\t\t\tqueue.addLast(null);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn results;\n\t}\n\n\t/**\n\t * http://leetcode.com/onlinejudge#question_107\n\t */\n\tpublic ArrayList<ArrayList<Integer>> levelOrderBottom(TreeNode root) {\n\t\tArrayList<ArrayList<Integer>> result = new ArrayList<ArrayList<Integer>>();\n\t\ttraverseBottom(result, root, 0);\n\t\treturn result;\n\t}\n\n\tprivate void traverseBottom(ArrayList<ArrayList<Integer>> result, TreeNode root, int level) {\n\t\tif (root == null) {\n\t\t\treturn;\n\t\t} else {\n\t\t\tint size = result.size();\n\t\t\tif (level == size) {\n\t\t\t\tresult.add(0, new ArrayList<Integer>());\n\t\t\t\tresult.get(0).add(root.val);\n\t\t\t} else {\n\t\t\t\tresult.get(size - level - 1).add(root.val);\n\t\t\t}\n\t\t\ttraverseBottom(result, root.left, level + 1);\n\t\t\ttraverseBottom(result, root.right, level + 1);\n\t\t}\n\t}\n}\n", "ier;\n\n/**\n * Represents an identifier in the Impala database.\n */\npublic class ImpalaIdentifier implements Identifier {\n    private final String id;\n\n    private ImpalaIdentifier(final String id) {\n        this.id = id;\n    }\n\n    /**\n     * Get the quoted identifier as a {@link String}.\n     *\n     * @return quoted identifier\n     */\n    @Override\n    public String quote() {\n        return \"`\" + this.id + \"`\";\n    }\n\n    /**\n     * Create a new {@link ImpalaIdentifier}.\n     *\n     * @param id the identifier as {@link String}\n     * @return new {@link ImpalaIdentifier} instance\n     */\n    public static ImpalaIdentifier of(final String id) {\n        if (validate(id)) {\n            return new ImpalaIdentifier(id);\n        } else {\n            throw new AssertionError(\"E-ID-6: Unable to create identifier \\\"\" + id //\n                    + \"\\\" because it contains illegal characters.\" //\n                    + \" For information about valid identifiers, please refer to\" //\n                    + \" https://docs.cloudera.com/documentation/enterprise/latest/topics/impala_identifiers.html\");\n        }\n    }\n\n    private static boolean validate(final String id) {\n        return !id.contains(\"`\");\n    }\n\n    @Override\n    public boolean equals(final Object o) {\n        if (this == o) {\n            return true;\n        }\n        if (!(o instanceof ImpalaIdentifier)) {\n            return false;\n        }\n        final ImpalaIdentifier that = (ImpalaIdentifier) o;\n        return Objects.equals(this.id, that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(this.id);\n    }\n}\n", "rsion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.example.james.sunshine;\n\nimport android.annotation.TargetApi;\nimport android.database.Cursor;\nimport android.test.AndroidTestCase;\n\nimport com.example.james.sunshine.data.WeatherContract;\n\npublic class TestFetchWeatherTask extends AndroidTestCase{\n    static final String ADD_LOCATION_SETTING = \"Sunnydale, CA\";\n    static final String ADD_LOCATION_CITY = \"Sunnydale\";\n    static final double ADD_LOCATION_LAT = 34.425833;\n    static final double ADD_LOCATION_LON = -119.714167;\n\n    /*\n        Students: uncomment testAddLocation after you have written the AddLocation function.\n        This test will only run on API level 11 and higher because of a requirement in the\n        content provider.\n     */\n    @TargetApi(11)\n    public void testAddLocation() {\n        // start from a clean state\n        getContext().getContentResolver().delete(WeatherContract.LocationEntry.CONTENT_URI,\n                WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + \" = ?\",\n                new String[]{ADD_LOCATION_SETTING});\n\n        FetchWeatherTask fwt = new FetchWeatherTask(getContext());\n        long locationId = fwt.addLocation(ADD_LOCATION_SETTING, ADD_LOCATION_CITY,\n                ADD_LOCATION_LAT, ADD_LOCATION_LON);\n\n        // does addLocation return a valid record ID?\n        assertFalse(\"Error: addLocation returned an invalid ID on insert\",\n                locationId == -1);\n\n        // test all this twice\n        for ( int i = 0; i < 2; i++ ) {\n\n            // does the ID point to our location?\n            Cursor locationCursor = getContext().getContentResolver().query(\n                    WeatherContract.LocationEntry.CONTENT_URI,\n                    new String[]{\n                            WeatherContract.LocationEntry._ID,\n                            WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING,\n                            WeatherContract.LocationEntry.COLUMN_CITY_NAME,\n                            WeatherContract.LocationEntry.COLUMN_COORD_LAT,\n                            WeatherContract.LocationEntry.COLUMN_COORD_LONG\n                    },\n                    WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + \" = ?\",\n                    new String[]{ADD_LOCATION_SETTING},\n                    null);\n\n            // these match the indices of the projection\n            if (locationCursor.moveToFirst()) {\n                assertEquals(\"Error: the queried value of locationId does not match the returned value\" +\n                        \"from addLocation\", locationCursor.getLong(0), locationId);\n                assertEquals(\"Error: the queried value of location setting is incorrect\",\n                        locationCursor.getString(1), ADD_LOCATION_SETTING);\n                assertEquals(\"Error: the queried value of location city is incorrect\",\n                        locationCursor.getString(2), ADD_LOCATION_CITY);\n                assertEquals(\"Error: the queried value of latitude is incorrect\",\n                        locationCursor.getDouble(3), ADD_LOCATION_LAT);\n                assertEquals(\"Error: the queried value of longitude is incorrect\",\n                        locationCursor.getDouble(4), ADD_LOCATION_LON);\n            } else {\n                fail(\"Error: the id you used to query returned an empty cursor\");\n            }\n\n            // there should be no more records\n            assertFalse(\"Error: there should be only one record returned from a location query\",\n                    locationCursor.moveToNext());\n\n            // add the location again\n            long newLocationId = fwt.addLocation(ADD_LOCATION_SETTING, ADD_LOCATION_CITY,\n                    ADD_LOCATION_LAT, ADD_LOCATION_LON);\n\n            assertEquals(\"Error: inserting a location again should return the same ID\",\n                    locationId, newLocationId);\n        }\n        // reset our state back to normal\n        getContext().getContentResolver().delete(WeatherContract.LocationEntry.CONTENT_URI,\n                WeatherContract.LocationEntry.COLUMN_LOCATION_SETTING + \" = ?\",\n                new String[]{ADD_LOCATION_SETTING});\n\n        // clean up the test so that other tests can use the content provider\n        getContext().getContentResolver().\n                acquireContentProviderClient(WeatherContract.LocationEntry.CONTENT_URI).\n                getLocalContentProvider().shutdown();\n    }\n}\n", "on;\nimport java.nio.file.Files;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\npublic class FilesTest {\n\n    private static final Path PATH = Paths.get(\"sample-file.txt\");\n    private static final String TEXT = \"abc\";\n\n    @Test\n    public void readString() throws IOException {\n        String content = Files.readString(PATH);\n        assertThat(content, equalTo(TEXT));\n    }\n\n    @Test\n    public void writeString() throws IOException {\n        Path writePath = Files.writeString(PATH, TEXT);\n        assertThat(writePath, equalTo(PATH));\n    }\n}\n", "oid.AndroidApplication;\nimport com.badlogic.gdx.backends.android.AndroidApplicationConfiguration;\nimport com.epicness.main.Renderer;\n\npublic class AndroidLauncher extends AndroidApplication {\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        AndroidApplicationConfiguration config = new AndroidApplicationConfiguration();\n        initialize(new Renderer(), config);\n    }\n}\n", "ring center) {\n\t\treturn \"http://api.map.baidu.com/staticimage?width=320&height=300&center=\" + center + \"&markers=\" + center\n\t\t\t\t+ \"&scale=2&zoom=12\";\n\t}\n\n\tpublic static String getMakerUrl(String center, String address) {\n\t\tString[] coordinate = center.split(\",\");\n\t\tString lng = coordinate[0];\n\t\tString lat = coordinate[1];\n\t\tcenter = lat + \",\" + lng;\n\t\treturn \"http://api.map.baidu.com/marker?location=\" + center + \"&title=\u9152\u5bb4\u5730\u5740&content=\" + address + \"&output=html&src=invitation\";\n\t}\n\n}\n", ".Bundle;\nimport android.support.annotation.Nullable;\nimport android.support.v7.app.ActionBar;\nimport android.support.v7.app.AppCompatActivity;\nimport android.support.v7.widget.LinearLayoutManager;\nimport android.support.v7.widget.RecyclerView;\nimport android.support.v7.widget.Toolbar;\nimport android.view.Menu;\nimport android.view.MenuItem;\n\nimport com.gdgand.rxjava.rxjavasample.R;\nimport com.gdgand.rxjava.rxjavasample.scroll.adapter.FasterAdapter;\nimport com.gdgand.rxjava.rxjavasample.scroll.adapter.NormalAdapter;\nimport com.gdgand.rxjava.rxjavasample.scroll.realm.FasterListData;\n\nimport butterknife.BindView;\nimport butterknife.ButterKnife;\nimport io.realm.Realm;\nimport io.realm.RealmConfiguration;\nimport rx.Observable;\n\npublic class FasterListActivity extends AppCompatActivity {\n\n    @BindView(R.id.list_fasterlist)\n    RecyclerView lvFasterList;\n\n    private FasterAdapter fasterAdapter;\n    private NormalAdapter normalAdapter;\n\n    @Override\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_fasterlist);\n\n        setUpActionbar();\n\n        ButterKnife.bind(this);\n\n        fasterAdapter = new FasterAdapter(FasterListActivity.this);\n        normalAdapter = new NormalAdapter(FasterListActivity.this);\n\n        ProgressDialog dialog = ProgressDialog.show(FasterListActivity.this, null, \"\ub85c\ub529 \uc911...\", true);\n\n        Realm.setDefaultConfiguration(new RealmConfiguration.Builder(FasterListActivity.this)\n                .build());\n        Realm realm = Realm.getDefaultInstance();\n        realm.beginTransaction();\n        realm.deleteAll();\n        realm.commitTransaction();\n        realm.executeTransactionAsync(realm1 -> {\n            Observable.range(1, 13000)\n                    .subscribe(index -> {\n                        FasterListData object = realm1.createObject(FasterListData.class);\n                        object.setPosition(index);\n\n                        normalAdapter.add(\"Index : \" + index);\n                        fasterAdapter.add(\"Index : \" + index);\n                    }, Throwable::printStackTrace);\n        }, () -> {\n            lvFasterList.setLayoutManager(new LinearLayoutManager(FasterListActivity.this));\n            lvFasterList.setAdapter(normalAdapter);\n            dialog.dismiss();\n        });\n    }\n\n    private void setUpActionbar() {\n        Toolbar toolbar = (Toolbar) findViewById(R.id.tb_fastlist);\n        setSupportActionBar(toolbar);\n\n        ActionBar actionBar = getSupportActionBar();\n        actionBar.setDisplayHomeAsUpEnabled(true);\n        actionBar.setHomeButtonEnabled(true);\n    }\n\n\n    @Override\n    public boolean onPrepareOptionsMenu(Menu menu) {\n        menu.clear();\n        getMenuInflater().inflate(R.menu.fasterlist, menu);\n        return true;\n    }\n\n    @Override\n    public boolean onOptionsItemSelected(MenuItem item) {\n        switch (item.getItemId()) {\n            case R.id.menu_fasterlist_non_observable:\n                lvFasterList.setAdapter(normalAdapter);\n                normalAdapter.notifyDataSetChanged();\n                break;\n            case R.id.menu_fasterlist_with_observable:\n                lvFasterList.setAdapter(fasterAdapter);\n                fasterAdapter.notifyDataSetChanged();\n                break;\n        }\n\n        return true;\n    }\n}\n", "JSONException;\nimport org.json.JSONObject;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.ParameterizedType;\nimport java.lang.reflect.Type;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Iterator;\nimport java.util.List;\n\n/**\n * AttributeMapper is used to map the json:api attribute node to\n * your object fields.\n *\n * You can create your own AttributeMapper and set it via {@link Morpheus#Morpheus(AttributeMapper)}.\n */\npublic class AttributeMapper {\n  private Deserializer deserializer;\n  private Gson gson;\n\n  public AttributeMapper() {\n    deserializer = new Deserializer();\n    gson = new Gson();\n  }\n\n  public AttributeMapper(Deserializer deserializer, Gson gson) {\n    this.deserializer = deserializer;\n    this.gson = gson;\n  }\n\n  /**\n   * Will map the attributes of the JSONAPI attribute object.\n   * JSONArrays will get mapped as {@literal List<Object>}.\n   * JSONObject will get mapped as {@literal ArrayMap<String, Object>}.\n   * Everything else will get mapped without changes.\n   *\n   * @param jsonApiResource Object extended with {@link Resource} that will get the field set.\n   * @param attributesJsonObject {@link JSONObject} with json:api attributes object\n   * @param field Field that will be set.\n   * @param jsonFieldName Name of the json-field in attributesJsonObject to get data from.\n   */\n  public void mapAttributeToObject(Resource jsonApiResource, JSONObject attributesJsonObject,\n                                   Field field, String jsonFieldName) {\n\n    Object object = null;\n    try {\n      object = attributesJsonObject.get(jsonFieldName);\n    } catch (JSONException e) {\n      Logger.debug(\"JSON attributes does not contain \" + jsonFieldName);\n      return;\n    }\n\n    if (object instanceof JSONArray) {\n\n      List<Object> list = null;\n      try {\n        list = createListFromJSONArray(attributesJsonObject.getJSONArray(jsonFieldName), field);\n      } catch (JSONException e) {\n        Logger.debug(jsonFieldName + \" is not an valid JSONArray.\");\n      }\n\n      deserializer.setField(jsonApiResource, field.getName(), list);\n\n    } else if (object.getClass() == JSONObject.class) {\n      Object obj = gson.fromJson(object.toString(), field.getType());\n      deserializer.setField(jsonApiResource, field.getName(), obj);\n    } else {\n      deserializer.setField(jsonApiResource, field.getName(), object);\n    }\n\n  }\n\n  /**\n   * Will loop through JSONArray and return values as List<Object>.\n   *\n   * @param jsonArray JSONArray with values.\n   * @return List<Object> of JSONArray values.\n   */\n  private List<Object> createListFromJSONArray(JSONArray jsonArray, Field field) {\n    Type genericFieldType = field.getGenericType();\n    List<Object> objectArrayList = new ArrayList<>();\n\n    if(genericFieldType instanceof ParameterizedType) {\n      ParameterizedType aType = (ParameterizedType) genericFieldType;\n      Type[] fieldArgTypes = aType.getActualTypeArguments();\n      for (Type fieldArgType : fieldArgTypes) {\n        final Class fieldArgClass = (Class) fieldArgType;\n\n        for (int i = 0; jsonArray.length() > i; i++) {\n          Object obj = null;\n          Object jsonObject = null;\n\n          try {\n            jsonObject = jsonArray.get(i);\n          } catch (JSONException e) {\n            Logger.debug(\"JSONArray does not contain index \" + i + \".\");\n            continue;\n          }\n\n          // if this is a String, it wont use gson because it can throw a malformed json exception\n          // that case happens if there is a String with \":\" in it.\n          if (fieldArgClass == String.class) {\n            obj = jsonObject.toString();\n          } else {\n            try {\n              obj = gson.fromJson(jsonArray.get(i).toString(), fieldArgClass);\n            } catch (JSONException e) {\n              Logger.debug(\"JSONArray does not contain index \" + i + \".\");\n            }\n          }\n\n          objectArrayList.add(obj);\n        }\n      }\n    }\n\n    return objectArrayList;\n  }\n\n  /**\n   * Will loop through JSONObject and return values as map.\n   *\n   * @param jsonObject JSONObject for meta.\n   * @return HashMap with meta values.\n   */\n  public HashMap<String, Object> createMapFromJSONObject(JSONObject jsonObject) {\n    HashMap<String, Object> metaMap = new HashMap<>();\n\n    for(Iterator<String> iter = jsonObject.keys(); iter.hasNext();) {\n      String key = iter.next();\n\n      try {\n        metaMap.put(key, jsonObject.get(key));\n      } catch (JSONException e) {\n        Logger.debug(\"JSON does not contain \" + key + \".\");\n      }\n    }\n\n    return metaMap;\n  }\n\n}\n", "\n}\n", "oo.ycsb.workloads.YCSBTransactionalCreateRequest;\nimport com.yahoo.ycsb.workloads.YCSBTransactionalReadRequest;\nimport com.yahoo.ycsb.workloads.YCSBTransactionalUpdateRequest;\n\nimport org.infinispan.Cache;\nimport org.infinispan.atomic.AtomicMap;\nimport org.infinispan.atomic.AtomicMapLookup;\nimport org.infinispan.manager.DefaultCacheManager;\nimport org.infinispan.manager.EmbeddedCacheManager;\nimport org.infinispan.util.FastCopyHashMap.EntrySet;\nimport org.infinispan.util.logging.Log;\nimport org.infinispan.util.logging.LogFactory;\n\nimport java.io.IOException;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.Vector;\n\n/**\n * This is a client implementation for Infinispan 5.x.\n *\n * Some settings:\n *\n * @author Manik Surtani (manik AT jboss DOT org)\n */\npublic class InfinispanClient extends DB {\n\n\tprivate static final int OK = 0;\n\tprivate static final int ERROR = -1;\n\tprivate static final int NOT_FOUND = -2;\n\n\t// An optimisation for clustered mode\n\tprivate final boolean clustered;\n\n\tprivate EmbeddedCacheManager infinispanManager;\n\n\t//private static final Log logger = LogFactory.getLog(InfinispanClient.class);\n\n\tpublic InfinispanClient() {\n\t\t\n\t\tclustered = Boolean.getBoolean(\"infin\" +\n\t\t\t\t\"ispan.clustered\");\n\t\t\n\t}\n\n\tpublic void init() throws DBException {\n\t\t\t\n\t\t\t\n\t\t\t\t\n\t\t\t\t\tinfinispanManager = new DefaultCacheManager();\n\t\t\t\t\n\t\n\t}\n\n\tpublic void cleanup() {\n\t\tinfinispanManager.stop();\n\t\tinfinispanManager = null;\n\t}\n\n\tpublic int read(String table, String key, Set<String> fields, HashMap<String, String> result) {\n\t\ttry {\n\t\t\tMap<String, String> row;\n\t\t\tif (clustered) {\n\t\t\t\trow = AtomicMapLookup.getAtomicMap(infinispanManager.getCache(table), key, false);\n\t\t\t} else {\n\t\t\t\tCache<String, Map<String, String>> cache = infinispanManager.getCache(table);\n\t\t\t\trow = cache.get(key);\n\t\t\t}\n\t\t\tif (row != null) {\n\t\t\t\tresult.clear();\n\t\t\t\tif (fields == null || fields.isEmpty()) {\n\t\t\t\t\t\n\t\t\t\t\tfor(String k : row.keySet())\n\t\t\t\t\t\tresult.put(k, row.get(k));\t\n\t\t\t\t} else {\n\t\t\t\t\tfor (String field : fields) result.put(field,row.get(field));\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn OK;\n\t\t} catch (Exception e) {\n\t\t\treturn ERROR;\n\t\t}\n\t}\n\n\tpublic int scan(String table, String startkey, int recordcount, Set<String> fields, Vector<HashMap<String, String>> result) {\n\t\t//logger.warn(\"Infinispan does not support scan semantics\");\n\t\treturn OK;\n\t}\n\n\tpublic int update(String table, String key, HashMap<String, String> values) {\n\t\ttry {\n\t\t\tif (clustered) {\n\t\t\t\tAtomicMap<String, String> row = AtomicMapLookup.getAtomicMap(infinispanManager.getCache(table), key);\n\t\t\t\tfor(String k : values.keySet())\n\t\t\t\t\trow.put(k, values.get(k));\n\t\t\t} else {\n\t\t\t\tCache<String, Map<String, String>> cache = infinispanManager.getCache(table);\n\t\t\t\tMap<String, String> row = cache.get(key);\n\t\t\t\tif (row == null) {\n\t\t\t\t\trow = values;\n\t\t\t\t\tcache.put(key, row);\n\t\t\t\t} else {\n\t\t\t\t\tfor(String k : values.keySet())\n\t\t\t\t\t\trow.put(k, values.get(k));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn OK;\n\t\t} catch (Exception e) {\n\t\t\treturn ERROR;\n\t\t}\n\t}\n\n\tpublic int insert(String table, String key, HashMap<String, String> values) {\n\t\ttry {\n\t\t\tif (clustered) {\n\t\t\t\tAtomicMap<String, String> row = AtomicMapLookup.getAtomicMap(infinispanManager.getCache(table), key);\n\t\t\t\trow.clear();\n\t\t\t\tfor(String k : values.keySet())\n\t\t\t\t\trow.put(k, values.get(k));\n\n\t\t\t} else {\n\t\t\t\tinfinispanManager.getCache(table).put(key, values);\n\t\t\t}\n\n\t\t\treturn OK;\n\t\t} catch (Exception e) {\n\t\t\treturn ERROR;\n\t\t}\n\t}\n\n\tpublic int delete(String table, String key) {\n\t\ttry {\n\t\t\tif (clustered)\n\t\t\t\tAtomicMapLookup.removeAtomicMap(infinispanManager.getCache(table), key);\n\t\t\telse\n\t\t\t\tinfinispanManager.getCache(table).remove(key);\n\t\t\treturn OK;\n\t\t} catch (Exception e) {\n\t\t\treturn ERROR;\n\t\t}\n\t}\n\n\t@Override\n\tpublic int createTransaction(YCSBTransactionalCreateRequest createRequest) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int readTransaction(List<YCSBTransactionalReadRequest> readList) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n\n\t@Override\n\tpublic int updateTransaction(List<YCSBTransactionalReadRequest> readList,\n\t\t\tList<YCSBTransactionalUpdateRequest> updateList) {\n\t\t// TODO Auto-generated method stub\n\t\treturn 0;\n\t}\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator 1.0.0.0\n * Changes may cause incorrect behavior and will be lost if the code is\n * regenerated.\n */\n\npackage com.microsoft.azure.keyvault.models;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * The certificate issuer set parameters.\n */\npublic class CertificateIssuerSetParameters {\n    /**\n     * The issuer provider.\n     */\n    @JsonProperty(value = \"provider\", required = true)\n    private String provider;\n\n    /**\n     * The credentials to be used for the issuer.\n     */\n    @JsonProperty(value = \"credentials\")\n    private IssuerCredentials credentials;\n\n    /**\n     * Details of the organization as provided to the issuer.\n     */\n    @JsonProperty(value = \"org_details\")\n    private OrganizationDetails organizationDetails;\n\n    /**\n     * Attributes of the issuer object.\n     */\n    @JsonProperty(value = \"attributes\")\n    private IssuerAttributes attributes;\n\n    /**\n     * Get the provider value.\n     *\n     * @return the provider value\n     */\n    public String provider() {\n        return this.provider;\n    }\n\n    /**\n     * Set the provider value.\n     *\n     * @param provider the provider value to set\n     * @return the CertificateIssuerSetParameters object itself.\n     */\n    public CertificateIssuerSetParameters withProvider(String provider) {\n        this.provider = provider;\n        return this;\n    }\n\n    /**\n     * Get the credentials value.\n     *\n     * @return the credentials value\n     */\n    public IssuerCredentials credentials() {\n        return this.credentials;\n    }\n\n    /**\n     * Set the credentials value.\n     *\n     * @param credentials the credentials value to set\n     * @return the CertificateIssuerSetParameters object itself.\n     */\n    public CertificateIssuerSetParameters withCredentials(IssuerCredentials credentials) {\n        this.credentials = credentials;\n        return this;\n    }\n\n    /**\n     * Get the organizationDetails value.\n     *\n     * @return the organizationDetails value\n     */\n    public OrganizationDetails organizationDetails() {\n        return this.organizationDetails;\n    }\n\n    /**\n     * Set the organizationDetails value.\n     *\n     * @param organizationDetails the organizationDetails value to set\n     * @return the CertificateIssuerSetParameters object itself.\n     */\n    public CertificateIssuerSetParameters withOrganizationDetails(OrganizationDetails organizationDetails) {\n        this.organizationDetails = organizationDetails;\n        return this;\n    }\n\n    /**\n     * Get the attributes value.\n     *\n     * @return the attributes value\n     */\n    public IssuerAttributes attributes() {\n        return this.attributes;\n    }\n\n    /**\n     * Set the attributes value.\n     *\n     * @param attributes the attributes value to set\n     * @return the CertificateIssuerSetParameters object itself.\n     */\n    public CertificateIssuerSetParameters withAttributes(IssuerAttributes attributes) {\n        this.attributes = attributes;\n        return this;\n    }\n\n}\n", "ort de.kumpelblase2.remoteentities.api.RemoteEntityType;\nimport de.kumpelblase2.remoteentities.api.features.InventoryFeature;\nimport de.kumpelblase2.remoteentities.entities.RemotePlayer;\nimport de.kumpelblase2.remoteentities.exceptions.NoNameException;\nimport de.kumpelblase2.remoteentities.exceptions.NoTypeException;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.Answers;\nimport org.mockito.Mock;\nimport org.mockito.runners.MockitoJUnitRunner;\nimport static org.junit.Assert.assertEquals;\nimport static org.mockito.Mockito.*;\n\n@RunWith(MockitoJUnitRunner.class)\npublic class CreateEntityContextTest\n{\n\t@Mock\n\tEntityManager m_entityManager;\n\t@Mock(answer = Answers.RETURNS_DEEP_STUBS)\n\tRemoteEntity m_remoteEntity;\n\t@Mock(answer = Answers.RETURNS_DEEP_STUBS)\n\tRemotePlayer m_remotePlayer;\n\n\t@Before\n\tpublic void setup()\n\t{\n\t\twhen(this.m_entityManager.getNextFreeID(anyInt())).thenReturn(1);\n\t\twhen(this.m_entityManager.createEntity(any(RemoteEntityType.class), anyInt())).thenReturn(this.m_remoteEntity);\n\t\twhen(this.m_entityManager.createNamedEntity(any(RemoteEntityType.class), anyInt(), anyString())).thenReturn(this.m_remotePlayer);\n\t\twhen(this.m_remotePlayer.getName()).thenCallRealMethod();\n\t\tRemoteEntityType.addType(\"Human\", null, null, true);\n\t\tRemoteEntityType.addType(\"Pig\", null, null, false);\n\t}\n\n\t@Test(expected = NoTypeException.class)\n\tpublic void testFailType()\n\t{\n\t\tnew CreateEntityContext(this.m_entityManager).create();\n\t}\n\n\t@Test(expected = NoNameException.class)\n\tpublic void testFailNoName()\n\t{\n\t\tnew CreateEntityContext(this.m_entityManager).withType(RemoteEntityType.valueOf(\"Human\")).create();\n\t}\n\n\t@Test\n\tpublic void testCreateNotNamed()\n\t{\n\t\tRemoteEntity created = new CreateEntityContext(this.m_entityManager).withType(RemoteEntityType.valueOf(\"Pig\")).withFeatures(mock(InventoryFeature.class)).create();\n\t\tassertEquals(\"Created entity and saved entity should be equal\", this.m_remoteEntity, created);\n\t\tverify(created.getFeatures(), times(1)).addFeature(any(InventoryFeature.class));\n\t\tverify(created, never()).setName(anyString());\n\t\tverify(created, never()).setSpeed(anyDouble());\n\t\tverify(created, times(1)).setStationary(eq(false));\n\t\tverify(created, times(1)).setPushable(eq(true));\n\t}\n\n\t@Test\n\tpublic void testCreateNamed()\n\t{\n\t\tRemoteEntity created = new CreateEntityContext(this.m_entityManager).withType(RemoteEntityType.valueOf(\"Human\")).withName(\"Test\").create();\n\t\tassertEquals(\"Created entity and saved entity should be equal\", this.m_remotePlayer, created);\n\t\tverify(created, never()).setSpeed(anyDouble());\n\t\tverify(created, times(1)).setStationary(eq(false));\n\t\tverify(created, times(1)).setPushable(eq(true));\n\t}\n}", "agricraft.api.v1;\n\nimport net.minecraftforge.fml.common.API;\n", "{\n\n\t/**\n\t * \n\t */\n\tprivate static final long serialVersionUID = 1L;\n\tprivate Integer id;\n\tprivate String text;\n\tprivate boolean selected;\n\tpublic Integer getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(Integer id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getText() {\n\t\treturn text;\n\t}\n\tpublic void setText(String text) {\n\t\tthis.text = text;\n\t}\n\tpublic boolean isSelected() {\n\t\treturn selected;\n\t}\n\tpublic void setSelected(boolean selected) {\n\t\tthis.selected = selected;\n\t}\n\t\n\tpublic ComboBoxBean(){\n\t\tsuper();\n\t}\n\tpublic ComboBoxBean(Integer id,String text,boolean selected){\n\t\tsuper();\n\t\tthis.id = id;\n\t\tthis.text = text;\n\t\tthis.selected = selected;\n\t}\n\t\n\t\n}\n", "r;\n\nimport de.danoeh.antennapod.core.feed.FeedItem;\nimport de.danoeh.antennapod.core.feed.FeedMedia;\nimport de.danoeh.antennapod.core.storage.DBWriter;\n\n/**\n * Provides method for sorting the queue according to rules.\n */\npublic class QueueSorter {\n    public enum Rule {\n        ALPHA_ASC,\n        ALPHA_DESC,\n        DATE_ASC,\n        DATE_DESC,\n        DURATION_ASC,\n        DURATION_DESC\n    }\n\n    public static void sort(final Context context, final Rule rule, final boolean broadcastUpdate) {\n        Comparator<FeedItem> comparator = null;\n\n        switch (rule) {\n            case ALPHA_ASC:\n                comparator = (f1, f2) -> f1.getTitle().compareTo(f2.getTitle());\n                break;\n            case ALPHA_DESC:\n                comparator = (f1, f2) -> f2.getTitle().compareTo(f1.getTitle());\n                break;\n            case DATE_ASC:\n                comparator = (f1, f2) -> f1.getPubDate().compareTo(f2.getPubDate());\n                break;\n            case DATE_DESC:\n                comparator = (f1, f2) -> f2.getPubDate().compareTo(f1.getPubDate());\n                break;\n            case DURATION_ASC:\n                comparator = (f1, f2) -> {\n                    FeedMedia f1Media = f1.getMedia();\n                    FeedMedia f2Media = f2.getMedia();\n                    int duration1 = f1Media != null ? f1Media.getDuration() : -1;\n                    int duration2 = f2Media != null ? f2Media.getDuration() : -1;\n\n                    if (duration1 == -1 || duration2 == -1)\n                        return duration2 - duration1;\n                    else\n                        return duration1 - duration2;\n                };\n                break;\n            case DURATION_DESC:\n                comparator = (f1, f2) -> {\n                    FeedMedia f1Media = f1.getMedia();\n                    FeedMedia f2Media = f2.getMedia();\n                    int duration1 = f1Media != null ? f1Media.getDuration() : -1;\n                    int duration2 = f2Media != null ? f2Media.getDuration() : -1;\n\n                    return -1 * (duration1 - duration2);\n                };\n            default:\n        }\n\n        if (comparator != null) {\n            DBWriter.sortQueue(comparator, broadcastUpdate);\n        }\n    }\n}\n", "mport javax.annotation.Resource;\n\nimport org.spring.ibatis.example.dao.ProductDao;\nimport org.spring.ibatis.example.model.Product;\nimport org.springframework.stereotype.Repository;\n\nimport com.ibatis.sqlmap.client.SqlMapClient;\n\n@Repository(value=\"productDaoImpl\")\npublic class ProductDaoImpl implements ProductDao {\n\t\n\tprivate SqlMapClient sqlMapClient;\n\t\n\tpublic SqlMapClient getSqlMapClient() {\n\t\treturn sqlMapClient;\n\t}\n\t\n\t//\u5c06sqlMapClient\u6ce8\u5165\n\t@Resource(name=\"sqlMapClient\")\n\tpublic void setSqlMapClient(SqlMapClient sqlMapClient) {\n\t\tthis.sqlMapClient = sqlMapClient;\n\t}\n\n\n\t@SuppressWarnings(\"unchecked\")\n\tpublic List<Product> listAll() {\n\t\ttry {\n\t\t\treturn getSqlMapClient().queryForList(\"org.spring.ibatis.example.model.Product.selectAll\");\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\t\n\tpublic boolean save(Product product) {\n\t\ttry {\n\t\t\tObject object = getSqlMapClient().insert(\"org.spring.ibatis.example.model.Product.save\", product);\n\t\t\treturn object==null?false:true;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic boolean update(Product product) {\n\t\ttry {\n\t\t\tint n=getSqlMapClient().update(\"org.spring.ibatis.example.model.Product.update\", product);\n\t\t\treturn n==1?true:false;\n\t\t} catch (SQLException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn false;\n\t}\n\n\n\tpublic Product getModel(int id) {\n\t\ttry {\n\t\t\treturn (Product) getSqlMapClient().queryForObject(\"org.spring.ibatis.example.model.Product.selectById\", id);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\n\n\t@Override\n\t@SuppressWarnings(\"unchecked\")\n\tpublic List<Product> selectLikeName(String name) {\n\t\ttry {\n\t\t\treturn getSqlMapClient().queryForList(\"org.spring.ibatis.example.model.Product.selectProductLikeName\",name);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn null;\n\t}\n\t\n}", "    private static final char L_PAREN    = '(';\n    private static final char R_PAREN    = ')';    \n    private static final char L_HAT    = '<';\n    private static final char R_HAT    = '>';\n    \n\tint startIndex;\n\tint endIndex;\n\tString label;\n\tVector<ParenthesesBlockCCG> subBlocks;\n    \n\tpublic ParenthesesBlockCCG(int startIndex) {\n\t\tthis.startIndex = startIndex;\n\t\tsubBlocks = new Vector<ParenthesesBlockCCG>();\n\t\tlabel = \"\";\n\t}\n\t\n    public static ParenthesesBlockCCG getParenthesesBlocks(String s) {\n        Stack<ParenthesesBlockCCG> stack = new Stack<ParenthesesBlockCCG>();\n        ParenthesesBlockCCG currentBlock = new ParenthesesBlockCCG(0);\n        stack.push(currentBlock);\n        boolean insideHatParenthesis = false;\n        for (int i = 1; i < s.length(); i++) {\n        \tchar c = s.charAt(i);\n            if (c == L_PAREN && !insideHatParenthesis)   {            \t            \t\n            \tParenthesesBlockCCG newBlock = new ParenthesesBlockCCG(i);\n            \tcurrentBlock.subBlocks.add(newBlock);\n            \tstack.push(newBlock);           \n            \tcurrentBlock = newBlock;\n            }\n            else if (c == R_PAREN && !insideHatParenthesis) {      \n            \tcurrentBlock = stack.pop();\n            \tcurrentBlock.endIndex = i;\n            \tcurrentBlock.subBlocks.trimToSize();\n            \tcurrentBlock.label = currentBlock.label.trim();       \n            \tif (!stack.isEmpty()) currentBlock = stack.peek();\n            }\n            else {\n            \tif (c == L_HAT) insideHatParenthesis =  true;\n            \telse if (c == R_HAT) insideHatParenthesis =  false;\n            \tif (currentBlock.subBlocks.isEmpty()){\n            \t\tcurrentBlock.label += c;\n            \t}\n            }\n        }\n        return currentBlock;\n    }\n    \n    public String toString() {\n    \tString result = L_PAREN + label;\n    \tif (!subBlocks.isEmpty()) {\n    \t\tresult += \" \";\n\t    \tfor(ParenthesesBlockCCG p : subBlocks) {\n\t    \t\tresult += p.toString() + \" \";\n\t    \t}\n    \t}\n    \tresult += R_PAREN;\n    \treturn result;\n    }\n\n    public static void main(String[] args) {\n    \tString p = \"(<T S[dcl] 0 2> (<T S[dcl] 1 2> (<T NP 0 1> (<T N 1 2> (<L N/N NNP NNP Mr. N_142/N_142>) (<L N NNP NNP Vinken N>) ) ) (<T S[dcl]\\\\NP 0 2> (<L (S[dcl]\\\\NP)/NP VBZ VBZ is (S[dcl]\\\\NP_87)/NP_88>) (<T NP 0 2> (<T NP 0 1> (<L N NN NN chairman N>) ) (<T NP\\\\NP 0 2> (<L (NP\\\\NP)/NP IN IN of (NP_99\\\\NP_99)/NP_100>) (<T NP 0 2> (<T NP 0 1> (<T N 1 2> (<L N/N NNP NNP Elsevier N_109/N_109>) (<L N NNP NNP N.V. N>) ) ) (<T NP[conj] 1 2> (<L , , , , ,>) (<T NP 1 2> (<L NP[nb]/N DT DT the NP[nb]_131/N_131>) (<T N 1 2> (<L N/N NNP NNP Dutch N_126/N_126>) (<T N 1 2> (<L N/N VBG VBG publishing N_119/N_119>) (<L N NN NN group N>) ) ) ) ) ) ) ) ) ) (<L . . . . .>) )\";\n    \t//String p = \"(a (b (c (d (e) (f) ) ) ) )\";\n    \tParenthesesBlockCCG pb = getParenthesesBlocks(p);\n    \tSystem.out.println(p);\n    \tSystem.out.println(pb);\n    \tSystem.out.println(pb.toString().equals(p));\n    }\n\n}\n\n\n\n\n\n", " * License: https://github.com/sel-project/sel-utils/blob/master/LICENSE\n * Repository: https://github.com/sel-project/sel-utils\n * Generated from https://github.com/sel-project/sel-utils/blob/master/xml/protocol/pocket105.xml\n */\npackage sul.protocol.pocket105.types;\n\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\nimport sul.utils.*;\n\npublic class Skin extends Stream {\n\n\tpublic String name;\n\tpublic byte[] data = new byte[0];\n\n\tpublic Skin() {}\n\n\tpublic Skin(String name, byte[] data) {\n\t\tthis.name = name;\n\t\tthis.data = data;\n\t}\n\n\t@Override\n\tpublic int length() {\n\t\treturn Buffer.varuintLength(name.getBytes(StandardCharsets.UTF_8).length) + name.getBytes(StandardCharsets.UTF_8).length + Buffer.varuintLength(data.length) + data.length;\n\t}\n\n\t@Override\n\tpublic byte[] encode() {\n\t\tthis._buffer = new byte[this.length()];\n\t\tbyte[] bfz=name.getBytes(StandardCharsets.UTF_8); this.writeVaruint((int)bfz.length); this.writeBytes(bfz);\n\t\tthis.writeVaruint((int)data.length); this.writeBytes(data);\n\t\treturn this.getBuffer();\n\t}\n\n\t@Override\n\tpublic void decode(byte[] buffer) {\n\t\tthis._buffer = buffer;\n\t\tint bvbfz=this.readVaruint(); name=new String(this.readBytes(bvbfz), StandardCharsets.UTF_8);\n\t\tint brde=this.readVaruint(); data=this.readBytes(brde);\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn \"Skin(name: \" + this.name + \", data: \" + Arrays.toString(this.data) + \")\";\n\t}\n\n\n}", ".ContestWrapper;\nimport org.xcolab.client.contest.pojo.wrapper.ProposalWrapper;\n\nimport java.util.Comparator;\nimport java.util.List;\n\n/**\n * Utility class to sort lists of contests or proposals by a string parameter\n */\npublic class ProposalPickerSortingUtil {\n\n    public static void sortContestsList(String sortOrder, String sortColumn,\n            List<ContestWrapper> contests) {\n        if (sortColumn != null) {\n\n            Comparator<ContestWrapper> comparator;\n            switch (sortColumn.toLowerCase()) {\n                case \"name\":\n                    comparator = Comparator.comparing(ContestWrapper::getTitleWithEndYear);\n                    break;\n                case \"comments\":\n                    comparator = Comparator.comparing(ContestWrapper::getTotalCommentsCount);\n                    break;\n                case \"what\":\n                    comparator = Comparator.comparing(ContestWrapper::getWhatName);\n                    break;\n                case \"where\":\n                    comparator = Comparator.comparing(ContestWrapper::getWhereName);\n                    break;\n                case \"who\":\n                    comparator = Comparator.comparing(ContestWrapper::getWhoName);\n                    break;\n                case \"how\":\n                    comparator = Comparator.comparing(ContestWrapper::getHowName);\n                    break;\n                default:\n                    comparator = Comparator.comparing(ContestWrapper::getProposalsCount);\n            }\n            if (sortOrder != null && sortOrder.toLowerCase().equals(\"desc\")) {\n                comparator = comparator.reversed();\n            }\n            contests.sort(comparator);\n        }\n    }\n\n    public static void sortProposalsList(String sortOrder, String sortColumn,\n            List<ProposalWrapper> proposals) {\n\n        if (sortColumn != null) {\n\n            Comparator<ProposalWrapper> comparator;\n            switch (sortColumn.toLowerCase()) {\n                case \"contest\":\n                    comparator = Comparator.comparing(o -> o.getContest().getQuestion());\n                    break;\n                case \"proposal\":\n                    comparator = Comparator.comparing(ProposalWrapper::getName);\n                    break;\n                case \"author\":\n                    comparator = Comparator.comparing(ProposalWrapper::getAuthorName);\n                    break;\n                case \"date\":\n                    comparator = Comparator.comparing(ProposalWrapper::getCreatedAt);\n                    break;\n                case \"supporters\":\n                    comparator = Comparator.comparing(ProposalWrapper::getSupportersCountCached);\n                    break;\n                case \"comments\":\n                    comparator = Comparator.comparing(ProposalWrapper::getCommentsCount);\n                    break;\n                default:\n                    throw new UnsupportedOperationException(\"Unknown sort column\");\n            }\n            if (sortOrder != null && sortOrder.toLowerCase().equals(\"desc\")) {\n                comparator = comparator.reversed();\n            }\n            proposals.sort(comparator);\n        }\n    }\n}\n", "m  {[type]}  String s             [description]\r\n * @param  {[type]}  String t             [description]\r\n * @return {Boolean}        [description]\r\n */\r\n    public boolean isAnagram(String s, String t) {\r\n        if (s == null || s.length() == 0) {\r\n            return t == null || t.length() == 0;\r\n        }\r\n\r\n        if (s.length() != t.length()) {\r\n            return false;\r\n        }\r\n\r\n        /*\r\n            Use HashMap to keep track of the occurrences of characters\r\n         */\r\n\r\n        HashMap<Character, Integer> map = new HashMap<Character, Integer>();\r\n\r\n        for (int i = 0; i < s.length(); i++) {\r\n            char c = s.charAt(i);\r\n\r\n            if (map.containsKey(c)) {\r\n                map.put(c, map.get(c) + 1);\r\n            } else {\r\n                map.put(c, 1);\r\n            }\r\n        }\r\n\r\n        for (int i = 0; i < t.length(); i++) {\r\n            char c = t.charAt(i);\r\n\r\n            if (!map.containsKey(c) || map.get(c) <= 0) {\r\n                return false;\r\n            } else {\r\n                map.put(c, map.get(c) - 1);\r\n            }\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n", "s) {\n\t\t// directions and gather user input\n\t\tScanner s = new Scanner(System.in);\n\n\t\tSystem.out.println(\"Enter the letter you would like to start with: \");\n\t\tchar first = s.next().charAt(0);\n\n\t\tSystem.out.println(\"Enter the letter you would like to end at: \");\n\t\tchar last = s.next().charAt(0);\n\n\t\ts.close();\n\t\t\n\t\t// calculate and print requested alphabet range\n\t\tSystem.out.println(\"The alphabet range you requested is as follows: \");\n\t\tif (first > last) {\n\t\t\tSystem.out.println(\"Sorry, \" + first + \" occurs in the alphabet after \" + last);\n\t\t} else {\n\t\t\tfor(char current = first; current <= last; current++) {\n\t\t\t\tSystem.out.printf(current + \" \" );\n\t\t\t}\n\t\t\tSystem.out.println();\n\t\t}\n\t}\n\n}\n", "}User;\nimport javax.ejb.Local;\n\n/**\n * @see {{ userClassNamePrefix | capitalize }}User\n * @author {{ authorFirstName }} {{ authorLastName }} <{{ authorEmail }}>\n */\n@Local\npublic interface I{{ userClassNamePrefix | capitalize }}UserDao {\n\t/**\n\t * Persist a new user\n\t */\n\tvoid persist({{ userClassNamePrefix | capitalize }}User user);\n\n\t/**\n\t * Retrieves a {{ userClassNamePrefix | lower }} user by email address.\n\t *\n\t * @param email email address of the {{ userClassNamePrefix | lower }} user\n\t * @return User if found, null otherwise.\n\t */\n\t{{ userClassNamePrefix | capitalize }}User findByEmail(String email);\n}\n", "Util;\n\nimport java.io.BufferedReader;\nimport java.io.File;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by julianliebl on 07.03.2015.\n */\npublic class JBakeConnector {\n    private static JBakeConnector mStaticInstance;\n    private static Process mServerProcess;\n\n    \n    private JBakeConnector(){}\n    \n    private static JBakeConnector getInstance(){\n        if(mStaticInstance == null){\n            mStaticInstance = new JBakeConnector();\n        }\n        return mStaticInstance;\n    }    \n    \n    private void runInBackground(StatusTask task) {\n        Thread thread = new Thread(task);\n        thread.setDaemon(true);\n        thread.start();\n    }\n\n    private abstract static class StatusTask implements Runnable {\n        @Override\n        public void run() {\n            execute();\n            onFinished();\n        }\n\n        abstract void execute();\n\n        abstract void onFinished();\n    }\n    \n    public enum CommandStatus{\n        STARTING, FINISHED        \n    }\n    \n    public interface CommandStatusListener{\n        void onStatusChange(CommandStatus status);\n    }\n    \n    public static void stopServer(){\n        getInstance().stopServerLocal();\n    }\n    \n    private void stopServerLocal(){\n        if (mServerProcess != null) {\n            System.out.println(\"Stopping the server...\");\n            mServerProcess.destroyForcibly();\n            mServerProcess = null;\n            System.out.println(\"Done!\");\n        }\n    }\n    \n    public static void toggleServer(CommandStatusListener listener){\n        getInstance().toggleServerLocal(listener);        \n    }\n    \n    private void toggleServerLocal(CommandStatusListener listener){\n        runInBackground(new StatusTask() {\n            @Override\n            void execute() {\n                if (mServerProcess != null) {\n                    stopServerLocal();\n                } else {\n                    listener.onStatusChange(CommandStatus.STARTING);\n                    \n                    File mDestinationFolder = Settings.getInstance().getDestinationFolderPath();\n                    File mJBakeSourceFolder = Settings.getInstance().getJBakeFolderPath();\n                    \n                    System.out.println(\"Starting the server by using the following command:\");\n                    ProcessBuilder pb = new ProcessBuilder(\"java\", \"-jar\", \"jbake-core.jar\", \"-s\", mDestinationFolder.getAbsolutePath());\n                    pb.command().stream().forEach(commandPart -> System.out.print(commandPart + \" \"));\n                    System.out.println();\n                    pb.directory(mJBakeSourceFolder);\n\n                    try {\n                        mServerProcess = pb.start();\n\n                        InputStream stdoutStream = mServerProcess.getInputStream();\n                        InputStream stderrStream = mServerProcess.getErrorStream();\n\n                        final BufferedReader stdoutReader = new BufferedReader(\n                                new InputStreamReader(stdoutStream));\n                        final BufferedReader stderrReader = new BufferedReader(\n                                new InputStreamReader(stderrStream));\n\n                        String stdoutLine;\n                        String stderrLine = null;\n                        while ((stdoutLine = stdoutReader.readLine()) != null || (stderrLine = stderrReader.readLine()) != null) {\n                            if (stdoutLine != null) {\n                                System.out.println(stdoutLine);\n                            }\n                            if (stderrLine != null) {\n                                System.out.println(stderrLine);\n                            }\n                        }\n\n                        stdoutReader.close();\n                        stdoutStream.close();\n\n                        stderrReader.close();\n                        stderrStream.close();\n\n                        if(mServerProcess != null){\n                            mServerProcess.waitFor();\n                            mServerProcess.destroy();\n                        }\n                    } catch (Exception e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n\n            @Override\n            void onFinished() {\n                listener.onStatusChange(CommandStatus.FINISHED);\n            }\n        });        \n    }\n    \n    public static void bake(CommandStatusListener listener){\n        getInstance().bakeLocal(listener);\n    }\n    \n    //TODO: remove dependency on Settings with chained commands\n    private void bakeLocal(CommandStatusListener listener){\n        runInBackground(new StatusTask() {\n            @Override\n            void execute() {\n                listener.onStatusChange(CommandStatus.STARTING);\n                \n                File mSourceFolder      = Settings.getInstance().getSourceFolderPath();\n                File mDestinationFolder = Settings.getInstance().getDestinationFolderPath();\n                File mJBakeSourceFolder = Settings.getInstance().getJBakeFolderPath();\n                \n                if(mSourceFolder == null){\n                    System.out.println(\"ERROR: Please select a valid source directory!\");\n                    return;\n                }\n\n                if(mDestinationFolder == null){\n                    System.out.println(\"ERROR: Please select a valid destination directory!\");\n                    return;\n                }\n\n                if(mJBakeSourceFolder == null){\n                    System.out.println(\"ERROR: Please select a valid JBake directory!\");\n                    return;\n                }\n\n                System.out.println(\"Starting to bake by using the following command:\");\n                \n                List<String> args = new ArrayList<>();\n                //default\n                args.add(\"java\");\n                args.add(\"-jar\");\n\n                //locale\n                String localeCountry = Settings.getInstance().getLocaleCountry();\n                if (localeCountry != null) args.add(\"-Duser.country=\" + localeCountry);\n                String localeLanguage = Settings.getInstance().getLocaleLanguage();\n                if (localeLanguage != null) args.add(\"-Duser.language=\" + localeLanguage);\n\n                //JBake\n                args.add(\"jbake-core.jar\");\n\n                //folders\n                if (mSourceFolder.list() == null || mSourceFolder.list().length == 0) {\n                    //TODO: Implement template selection\n\n                    ZipUtil.unpack(\n                            new File(mJBakeSourceFolder.getAbsolutePath() + \"/example_project_freemarker.zip\"),\n                            mSourceFolder\n                    );\n                }\n\n                args.add(\"-b\");\n                args.add(mSourceFolder.getAbsolutePath());\n                args.add(mDestinationFolder.getAbsolutePath());\n\n                ProcessBuilder pb = new ProcessBuilder(args.toArray(new String[args.size()]));\n                pb.directory(mJBakeSourceFolder);\n                pb.command().stream().forEach(commandPart -> System.out.print(commandPart + \" \"));\n\n                try {\n                    Process process = pb.start();\n\n                    InputStream stdoutStream = process.getInputStream();\n                    InputStream stderrStream = process.getErrorStream();\n\n                    final BufferedReader stdoutReader = new BufferedReader(\n                            new InputStreamReader(stdoutStream));\n                    final BufferedReader stderrReader = new BufferedReader(\n                            new InputStreamReader(stderrStream));\n\n                    String stdoutLine;\n                    String stderrLine = null;\n                    while ((stdoutLine = stdoutReader.readLine()) != null || (stderrLine = stderrReader.readLine()) != null) {\n                        if (stdoutLine != null) {\n                            System.out.println(stdoutLine);\n                        }\n                        if (stderrLine != null) {\n                            System.out.println(stderrLine);\n                        }\n                    }\n\n                    stdoutReader.close();\n                    stdoutStream.close();\n\n                    stderrReader.close();\n                    stderrStream.close();\n\n                    process.waitFor();\n                    process.destroy();\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n            }\n\n            @Override\n            void onFinished() {\n                listener.onStatusChange(CommandStatus.FINISHED);\n            }\n        });\n        \n        \n        \n    }\n}\n", "orld;\r\nimport draco18s.decay.entities.MaterialEntity;\r\n\r\nimport net.minecraft.block.Block;\r\nimport net.minecraft.block.BlockContainer;\r\nimport net.minecraft.block.material.Material;\r\nimport net.minecraft.client.renderer.texture.IconRegister;\r\nimport net.minecraft.creativetab.CreativeTabs;\r\nimport net.minecraft.entity.player.EntityPlayer;\r\nimport net.minecraft.tileentity.TileEntity;\r\nimport net.minecraft.world.World;\r\n\r\npublic class WormDecay extends BlockContainer\r\n{\r\n    public static int tubeBlock;\r\n\r\n    public WormDecay(int par1, Material par3Material, int tubeBlockID)\r\n    {\r\n        super(par1, par3Material);\r\n        //setTickRandomly(true);\r\n        setHardness(2.0F);\r\n        setStepSound(soundStoneFootstep);\r\n        setCreativeTab(CreativeTabs.tabBlock);\r\n        setUnlocalizedName(\"Wormy Decay\");\r\n        tubeBlock = tubeBlockID;\r\n    }\r\n\r\n    public void registerIcons(IconRegister iconRegister)\r\n    {\r\n        blockIcon = iconRegister.registerIcon(\"DecayingWorld:wormflesh\");\r\n    }\r\n\r\n    public void updateTick(World world, int x, int y, int z, Random par5Random)\r\n    {\r\n        if (par5Random.nextDouble() > 1.0D) //odds of actually updating\r\n        {\r\n            return;\r\n        }\r\n\r\n        int i = x;\r\n        int j = y;\r\n        int k = z;\r\n        int meta = world.getBlockMetadata(x, y, z);\r\n        MaterialEntity ent = (MaterialEntity)world.getBlockTileEntity(x, y, z);\r\n        int meID = ent.materialBlockID;\r\n        int meMD = ent.materialBlockMeta;\r\n        //System.out.println(\"Entity info - \" + meID + \":\" + meMD);\r\n        world.setBlock(x + 1, y,   z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y + 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y - 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y,   z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y + 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y - 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y,   z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y + 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x + 1, y - 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y,   z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y + 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y - 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y,   z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y + 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y - 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y,   z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y + 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x - 1, y - 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y + 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y - 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y + 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y + 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y,   z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y - 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y - 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        world.setBlock(x,   y,   z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        //System.out.println(\"Direction: \" + meta);\r\n        //System.out.println(x + \",\" + y + \",\" + z);\r\n        int tempmeta = meta;\r\n\r\n        if (par5Random.nextDouble() < 0.3D)  //odds of changing direction for one update\r\n        {\r\n            int a = 0;\r\n\r\n            if (meta < 8)\r\n            {\r\n                a = ((par5Random.nextDouble() > 0.5) ? 0 : 1);\r\n\r\n                if (meta % 2 == 0)\r\n                {\r\n                    a += ((par5Random.nextDouble() > 0.333) ? 0 : 8);\r\n                }\r\n\r\n                if (a == 0)\r\n                {\r\n                    a = -1;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (meta % 2 == 0)\r\n                {\r\n                    a = -8;\r\n                }\r\n                else\r\n                {\r\n                    a = -9;\r\n                }\r\n            }\r\n\r\n            if (meta + a == -1)\r\n            {\r\n                tempmeta = 7;\r\n            }\r\n            else if (meta + a == 16)\r\n            {\r\n                tempmeta = 8;\r\n            }\r\n            else if (meta == 7 && a == 1)\r\n            {\r\n                tempmeta = 0;\r\n            }\r\n            else if (meta == 8 && a == -1)\r\n            {\r\n                tempmeta = 15;\r\n            }\r\n            else\r\n            {\r\n                tempmeta = (meta + a) % 16;\r\n            }\r\n\r\n            //world.setBlockMetadata(x, y, z, meta);\r\n        }\r\n\r\n        switch (tempmeta)\r\n        {\r\n            case 0:\r\n                x++;\r\n                break;\r\n\r\n            case 1:\r\n                x++;\r\n                z++;\r\n                break;\r\n\r\n            case 2:\r\n                z++;\r\n                break;\r\n\r\n            case 3:\r\n                x--;\r\n                z++;\r\n                break;\r\n\r\n            case 4:\r\n                x--;\r\n                break;\r\n\r\n            case 5:\r\n                x--;\r\n                z--;\r\n                break;\r\n\r\n            case 6:\r\n                z--;\r\n                break;\r\n\r\n            case 7:\r\n                x++;\r\n                z--;\r\n                break;\r\n\r\n            case 8:\r\n                x++;\r\n                y++;\r\n                break;\r\n\r\n            case 9:\r\n                x++;\r\n                y--;\r\n                break;\r\n\r\n            case 10:\r\n                z++;\r\n                y++;\r\n                break;\r\n\r\n            case 11:\r\n                z++;\r\n                y--;\r\n                break;\r\n\r\n            case 12:\r\n                x--;\r\n                y++;\r\n                break;\r\n\r\n            case 13:\r\n                x--;\r\n                y--;\r\n                break;\r\n\r\n            case 14:\r\n                z--;\r\n                y++;\r\n                break;\r\n\r\n            case 15:\r\n                z--;\r\n                y--;\r\n                break;\r\n        }\r\n\r\n        //System.out.println(x + \",\" + y + \",\" + z);\r\n        world.setBlock(x,   y,   z,   this.blockID, meta, 3);\r\n        ent = (MaterialEntity)world.getBlockTileEntity(x, y, z);\r\n\r\n        if (ent != null)\r\n        {\r\n            ent.materialBlockID = meID;\r\n            ent.materialBlockMeta = meMD;\r\n        }\r\n\r\n        //System.out.println(i + \",\" + j + \",\" + k);\r\n        world.setBlock(i, j, k, DecayingWorld.wormInterior.blockID, 4, 3);\r\n\r\n        //System.out.println(\" \");\r\n        if (par5Random.nextDouble() < 0.1D)  //odds of changing direction\r\n        {\r\n            int a = 0;\r\n\r\n            if (meta < 8)\r\n            {\r\n                a = ((par5Random.nextDouble() > 0.5) ? 0 : 1);\r\n\r\n                if (meta % 2 == 0)\r\n                {\r\n                    a += ((par5Random.nextDouble() > 0.333) ? 0 : 8);\r\n                }\r\n\r\n                if (a == 0)\r\n                {\r\n                    a = -1;\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (meta % 2 == 0)\r\n                {\r\n                    a = -8;\r\n                }\r\n                else\r\n                {\r\n                    a = -9;\r\n                }\r\n            }\r\n\r\n            if (meta + a == -1)\r\n            {\r\n                meta = 7;\r\n            }\r\n            else if (meta + a == 16)\r\n            {\r\n                meta = 8;\r\n            }\r\n            else if (meta == 7 && a == 1)\r\n            {\r\n                meta = 0;\r\n            }\r\n            else if (meta == 8 && a == -1)\r\n            {\r\n                meta = 15;\r\n            }\r\n            else\r\n            {\r\n                meta = (meta + a) % 16;\r\n            }\r\n\r\n            if (y < 5)\r\n            {\r\n                if (meta > 8 && meta % 2 == 1)\r\n                {\r\n                    if (par5Random.nextDouble() < 0.0625)\r\n                    {\r\n                        meta -= 9;\r\n                    }\r\n                }\r\n            }\r\n\r\n            world.setBlockMetadataWithNotify(x, y, z, meta, 3);\r\n        }\r\n\r\n        world.scheduleBlockUpdate(x, y, z, blockID, 100);\r\n    }\r\n\r\n    @Override\r\n    public void onBlockAdded(World par1World, int x, int y, int z)\r\n    {\r\n        par1World.scheduleBlockUpdate(x, y, z, blockID, 100);\r\n    }\r\n\r\n    @Override\r\n    public int onBlockPlaced(World par1World, int x, int y, int z, int par5, float par6, float par7, float par8, int par9)\r\n    {\r\n        int r = new Random().nextInt(16);\r\n        //System.out.println(\"Randomizing direction: \" + r);\r\n        par1World.setBlock(x + 1, y,   z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y + 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y - 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y,   z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y + 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y - 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y,   z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y + 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x + 1, y - 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y,   z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y + 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y - 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y,   z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y + 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y - 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y,   z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y + 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x - 1, y - 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y + 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y - 1, z,   DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y + 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y + 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y,   z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y - 1, z + 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y - 1, z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        par1World.setBlock(x,   y,   z - 1, DecayingWorld.wormInterior.blockID, 8, 3);\r\n        //par1World.setBlock(x, y, z, this.blockID, r);\r\n        par1World.scheduleBlockUpdate(x, y, z, blockID, 100);\r\n        /*MaterialEntity ent = (MaterialEntity)par1World.getBlockTileEntity(x, y, z);\r\n        ent.materialBlockID = Block.cobblestone.blockID;\r\n        ent.materialBlockMeta = 0;*/\r\n        return r;\r\n    }\r\n\r\n    public int quantityDropped(Random par1Random)\r\n    {\r\n        return 0;\r\n    }\r\n\r\n    @Override\r\n    public TileEntity createNewTileEntity(World world)\r\n    {\r\n        return new MaterialEntity();\r\n    }\r\n}\r\n", "and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n * Redistributions of source code must retain the above copyright notice, this\n * list of conditions and the following disclaimer.\n *\n * Redistributions in binary form must reproduce the above copyright notice,\n * this list of conditions and the following disclaimer in the documentation\n * and/or other materials provided with the distribution.\n *\n * Neither the name of the HSQL Development Group nor the names of its\n * contributors may be used to endorse or promote products derived from this\n * software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL HSQL DEVELOPMENT GROUP, HSQLDB.ORG,\n * OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n\npackage org.hsqldb.rowio;\n\nimport org.hsqldb.Row;\nimport org.hsqldb.persist.Crypto;\nimport org.hsqldb.types.Type;\n\n/**\n * @author Fred Toussi (fredt@users dot sourceforge.net)\n * @version 2.0.1\n * @since 1.9.0\n */\npublic class RowOutputBinaryEncode extends RowOutputBinary {\n\n    final Crypto crypto;\n\n    public RowOutputBinaryEncode(Crypto crypto, int initialSize, int scale) {\n\n        super(initialSize, scale);\n\n        this.crypto = crypto;\n    }\n\n    public void writeData(Row row, Type[] types) {\n\n        if (crypto == null) {\n            super.writeData(row, types);\n        } else {\n            int start = count;\n\n            ensureRoom(row.getStorageSize());\n            writeInt(0);\n            super.writeData(row, types);\n\n            int origLength = count - start - INT_STORE_SIZE;\n            int newLength = crypto.encode(buffer, start + INT_STORE_SIZE,\n                                          origLength, buffer,\n                                          start + INT_STORE_SIZE);\n\n            writeIntData(newLength, start);\n\n            count = start + INT_STORE_SIZE + newLength;\n        }\n    }\n\n    /**\n     *  Calculate the size of byte array required to store a row.\n     *\n     * @param  row - a database row\n     * @return  size of byte array\n     * @exception  HsqlException When data is inconsistent\n     */\n    public int getSize(Row row) {\n\n        int size = super.getSize(row);\n\n        if (crypto != null) {\n            size = crypto.getEncodedSize(size - INT_STORE_SIZE)\n                   + INT_STORE_SIZE * 2;\n        }\n\n        return size;\n    }\n\n    public RowOutputInterface duplicate() {\n        return new RowOutputBinaryEncode(crypto, 128, this.scale);\n    }\n}\n", "final String ESC_PREFIX       = \"\\u001b[\";\n    public static final String ESC_SUFFIX       = \"m\";\n    public static final String ESC_SEP          = \";\";\n\n    public static final String SGR_RESET        = \"0\";\n    public static final String SGR_BRIGHT       = \"1\";\n    public static final String SGR_DIM          = \"2\";\n    public static final String SGR_ITALIC       = \"3\";\n    public static final String SGR_UNDERLINE    = \"4\";\n    public static final String SGR_BLINKSLOW    = \"5\";\n    public static final String SGR_BLINKFAST    = \"6\";\n    public static final String SGR_REVERSE      = \"7\";\n    public static final String SGR_HIDDEN       = \"8\";\n    public static final String SGR_CROSSEDOUT   = \"9\";\n\n    public static final String SGR_FG_BLACK     = \"30\";\n    public static final String SGR_FG_RED       = \"31\";\n    public static final String SGR_FG_GREEN     = \"32\";\n    public static final String SGR_FG_YELLOW    = \"33\";\n    public static final String SGR_FG_BLUE      = \"34\";\n    public static final String SGR_FG_MAGENTA   = \"35\";\n    public static final String SGR_FG_CYAN      = \"36\";\n    public static final String SGR_FG_WHITE     = \"37\";\n\n    public static final String SGR_BG_BLACK     = \"40\";\n    public static final String SGR_BG_RED       = \"41\";\n    public static final String SGR_BG_GREEN     = \"42\";\n    public static final String SGR_BG_YELLOW    = \"43\";\n    public static final String SGR_BG_BLUE      = \"44\";\n    public static final String SGR_BG_MAGENTA   = \"45\";\n    public static final String SGR_BG_CYAN      = \"46\";\n    public static final String SGR_BG_WHITE     = \"47\";\n\n    public static final String ESC_NORMAL       = ESC_PREFIX\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BLINKSLOW    = ESC_PREFIX\n                                                    + SGR_BLINKSLOW\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BLINKFAST    = ESC_PREFIX\n                                                    + SGR_BLINKFAST\n                                                    + ESC_SUFFIX;\n\n    public static final String ESC_FG_BLACK     = ESC_PREFIX\n                                                    + SGR_FG_BLACK\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_RED       = ESC_PREFIX\n                                                    + SGR_FG_RED\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_GREEN     = ESC_PREFIX\n                                                    + SGR_FG_GREEN\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_YELLOW    = ESC_PREFIX\n                                                    + SGR_FG_YELLOW\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_BLUE      = ESC_PREFIX\n                                                    + SGR_FG_BLUE\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_MAGENTA   = ESC_PREFIX\n                                                    + SGR_FG_MAGENTA\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_CYAN      = ESC_PREFIX\n                                                    + SGR_FG_CYAN\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FG_WHITE     = ESC_PREFIX\n                                                    + SGR_FG_WHITE\n                                                    + ESC_SUFFIX;\n\n    public static final String ESC_BG_BLACK     = ESC_PREFIX\n                                                    + SGR_BG_BLACK\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_RED       = ESC_PREFIX\n                                                    + SGR_BG_RED\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_GREEN     = ESC_PREFIX\n                                                    + SGR_BG_GREEN\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_YELLOW    = ESC_PREFIX\n                                                    + SGR_BG_YELLOW\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_BLUE      = ESC_PREFIX\n                                                    + SGR_BG_BLUE\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_MAGENTA   = ESC_PREFIX\n                                                    + SGR_BG_MAGENTA\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_CYAN      = ESC_PREFIX\n                                                    + SGR_BG_CYAN\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BG_WHITE     = ESC_PREFIX\n                                                    + SGR_BG_WHITE\n                                                    + ESC_SUFFIX;\n\n    public static final String ESC_FGB_BLACK    = ESC_PREFIX\n                                                    + SGR_FG_BLACK\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_RED      = ESC_PREFIX\n                                                    + SGR_FG_RED\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_GREEN    = ESC_PREFIX\n                                                    + SGR_FG_GREEN\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_YELLOW   = ESC_PREFIX\n                                                    + SGR_FG_YELLOW\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_BLUE     = ESC_PREFIX\n                                                    + SGR_FG_BLUE\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_MAGENTA  = ESC_PREFIX\n                                                    + SGR_FG_MAGENTA\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_CYAN     = ESC_PREFIX\n                                                    + SGR_FG_CYAN\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_FGB_WHITE    = ESC_PREFIX\n                                                    + SGR_FG_WHITE\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n\n    public static final String ESC_BGB_BLACK    = ESC_PREFIX\n                                                    + SGR_BG_BLACK\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_RED      = ESC_PREFIX\n                                                    + SGR_BG_RED\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_GREEN    = ESC_PREFIX\n                                                    + SGR_BG_GREEN\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_YELLOW   = ESC_PREFIX\n                                                    + SGR_BG_YELLOW\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_BLUE     = ESC_PREFIX\n                                                    + SGR_BG_BLUE\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_MAGENTA  = ESC_PREFIX\n                                                    + SGR_BG_MAGENTA\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_CYAN     = ESC_PREFIX\n                                                    + SGR_BG_CYAN\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n    public static final String ESC_BGB_WHITE    = ESC_PREFIX\n                                                    + SGR_BG_WHITE\n                                                    + ESC_SEP\n                                                    + SGR_BRIGHT\n                                                    + ESC_SUFFIX;\n\n    public static enum TraceLevel\n    {\n        QUIET(0),\n        INIT(1),\n        API(2),\n        CALLBK(3),\n        EVENT(4),\n        FUNC(5),\n        TASK(6),\n        UTIL(7),\n        HIFREQ(8);\n\n        private int value;\n\n        TraceLevel(int value)\n        {\n            this.value = value;\n        }   //TraceLevel\n\n        public int getValue()\n        {\n            return this.value;\n        }   //getValue\n\n    }   //enum TraceLevel\n\n    public static enum MsgLevel\n    {\n        FATAL(1),\n        ERR(2),\n        WARN(3),\n        INFO(4),\n        VERBOSE(5);\n\n        private int value;\n\n        MsgLevel(int value)\n        {\n            this.value = value;\n        }   //MsgLevel\n\n        public int getValue()\n        {\n            return this.value;\n        }   //getValue\n\n    }   //enum MsgLevel\n\n    private static int indentLevel = 0;\n\n    private String instanceName;\n    private boolean traceEnabled;\n    private TraceLevel traceLevel;\n    private MsgLevel msgLevel;\n    private double nextTraceTime;\n\n    public void setDbgTraceConfig(\n            boolean traceEnabled,\n            TraceLevel traceLevel,\n            MsgLevel msgLevel)\n    {\n        this.traceEnabled = traceEnabled;\n        this.traceLevel = traceLevel;\n        this.msgLevel = msgLevel;\n    }   //setDbgTraceConfig\n\n    public TrcDbgTrace(\n            final String instanceName,\n            boolean traceEnabled,\n            TraceLevel traceLevel,\n            MsgLevel msgLevel)\n    {\n        this.instanceName = instanceName;\n        setDbgTraceConfig(traceEnabled, traceLevel, msgLevel);\n        this.nextTraceTime = Timer.getFPGATimestamp();\n    }   //TrcDbgTrace\n\n    public void traceEnter(\n            final String funcName,\n            final TraceLevel funcLevel,\n            final String format,\n            Object... args)\n    {\n        if (traceEnabled &&\n            funcLevel.getValue() <= traceLevel.getValue())\n        {\n            printTracePrefix(funcName, true, false);\n            System.out.printf(format, args);\n            System.out.print(\")\\n\" + ESC_NORMAL);\n        }\n    }   //traceEnter\n\n    public void traceEnter(\n            final String funcName,\n            final TraceLevel funcLevel)\n    {\n        if (traceEnabled &&\n            funcLevel.getValue() <= traceLevel.getValue())\n        {\n            printTracePrefix(funcName, true, true);\n        }\n    }   //traceEnter\n\n    public void traceExit(\n            final String funcName,\n            final TraceLevel funcLevel,\n            final String format,\n            Object... args)\n    {\n        if (traceEnabled &&\n            funcLevel.getValue() <= traceLevel.getValue())\n        {\n            printTracePrefix(funcName, false, false);\n            System.out.printf(format, args);\n            System.out.print(\"\\n\" + ESC_NORMAL);\n        }\n    }   //traceExitMsg\n\n    public void traceExit(\n            final String funcName,\n            final TraceLevel funcLevel)\n    {\n        if (traceEnabled &&\n            funcLevel.getValue() <= traceLevel.getValue())\n        {\n            printTracePrefix(funcName, false, true);\n        }\n    }   //traceExit\n\n    public void traceFatal(\n            final String funcName,\n            final String format,\n            Object... args)\n    {\n        traceMsg(funcName, MsgLevel.FATAL, 0.0, format, args);\n    }   //traceFatal\n\n    public void traceErr(\n            final String funcName,\n            final String format,\n            Object... args)\n    {\n        traceMsg(funcName, MsgLevel.ERR, 0.0, format, args);\n    }   //traceErr\n\n    public void traceWarn(\n            final String funcName,\n            final String format,\n            Object... args)\n    {\n        traceMsg(funcName, MsgLevel.WARN, 0.0, format, args);\n    }   //traceWarn\n\n    public void traceInfo(\n            final String funcName,\n            final String format,\n            Object... args)\n    {\n        traceMsg(funcName, MsgLevel.INFO, 0.0, format, args);\n    }   //traceInfo\n\n    public void traceVerbose(\n            final String funcName,\n            final String format,\n            Object... args)\n    {\n        traceMsg(funcName, MsgLevel.VERBOSE, 0.0, format, args);\n    }   //traceVerbose\n\n    public void tracePeriodic(\n            final String funcName,\n            double traceInterval,\n            final String format,\n            Object... args)\n    {\n        traceMsg(funcName, MsgLevel.INFO, traceInterval, format, args);\n    }   //tracePeriodic\n\n    private void traceMsg(\n            final String funcName,\n            MsgLevel level,\n            double traceInterval,\n            final String format,\n            Object... args)\n    {\n        if (level.getValue() <= msgLevel.getValue())\n        {\n            double currTime = Timer.getFPGATimestamp();\n            if (currTime >= nextTraceTime)\n            {\n                nextTraceTime = currTime + traceInterval;\n                printMsgPrefix(funcName, level);\n                System.out.printf(format, args);\n                System.out.print(\"\\n\" + ESC_NORMAL);\n            }\n        }\n    }   //traceMsg\n\n    private void printTracePrefix(\n            final String funcName,\n            boolean enter,\n            boolean newline)\n    {\n        if (enter)\n        {\n            indentLevel++;\n        }\n\n        System.out.print(ESC_FGB_MAGENTA);\n        for (int i = 0; i < indentLevel; i++)\n        {\n            System.out.print(\"| \");\n        }\n\n        System.out.print(instanceName + \".\" + funcName);\n\n        if (enter)\n        {\n            System.out.print(newline? \"()\\n\": \"(\");\n        }\n        else\n        {\n            System.out.print(newline? \"!\\n\" + ESC_NORMAL: \"\");\n            indentLevel--;\n        }\n    }   //printTracePrefix\n\n    private void printMsgPrefix(\n            final String funcName,\n            MsgLevel level)\n    {\n        String prefix;\n        String color;\n\n        switch (level)\n        {\n        case FATAL:\n            prefix = \"_Fatal: \";\n            color = ESC_PREFIX + SGR_FG_YELLOW +\n                    ESC_SEP + SGR_BRIGHT +\n                    ESC_SEP + SGR_BG_RED +\n                    ESC_SUFFIX;\n            break;\n\n        case ERR:\n            prefix = \"_Err: \";\n            color = ESC_FGB_RED;\n            break;\n\n        case WARN:\n            prefix = \"_Warn: \";\n            color = ESC_FGB_YELLOW;\n            break;\n\n        case INFO:\n            prefix = \"_Info: \";\n            color = ESC_FGB_GREEN;\n            break;\n\n        case VERBOSE:\n            prefix = \"_Verbose: \";\n            color = ESC_FGB_WHITE;\n            break;\n\n        default:\n            prefix = \"_Unk: \";\n            color = ESC_NORMAL;\n            break;\n        }\n\n        System.out.print(color + instanceName + \".\" + funcName + prefix);\n    }   //printMsgPrefix\n\n}   //class TrcDbgTrace\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\npackage javax.sql.rowset.serial;\n\nimport java.sql.SQLException;\n\n/**\n * Indicates and an error with the serialization or de-serialization of\n * SQL types such as <code>BLOB, CLOB, STRUCT or ARRAY</code> in\n * addition to SQL types such as <code>DATALINK and JAVAOBJECT</code>\n *\n */\npublic class SerialException extends java.sql.SQLException {\n\n    /**\n     * Creates a new <code>SerialException</code> without a\n     * message.\n     */\n     public SerialException() {\n     }\n\n    /**\n     * Creates a new <code>SerialException</code> with the\n     * specified message.\n     *\n     * @param msg the detail message\n     */\n    public SerialException(String msg) {\n        super(msg);\n    }\n\n    static final long serialVersionUID = -489794565168592690L;\n}\n", "7 Manuel Vogel\n *\n *  Permission is hereby granted, free of charge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n *\n *  https://opensource.org/licenses/MIT\n */\n\nimport com.gitlab.mavogel.vislab.dtos.category.CategoryDto;\n\n/**\n * Created by mavogel on 1/23/17.\n */\npublic class FullProductDto {\n\n    private long id;\n    private String name;\n    private double price;\n    private String details;\n    private CategoryDto category;\n\n    public FullProductDto() {\n    }\n\n    public FullProductDto(final long id, final String name, final double price, final String details, final CategoryDto category) {\n        this.id = id;\n        this.name = name;\n        this.price = price;\n        this.details = details;\n        this.category = category;\n    }\n\n    public long getId() {\n        return id;\n    }\n\n    public void setId(final long id) {\n        this.id = id;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(final String name) {\n        this.name = name;\n    }\n\n    public double getPrice() {\n        return price;\n    }\n\n    public void setPrice(final double price) {\n        this.price = price;\n    }\n\n    public String getDetails() {\n        return details;\n    }\n\n    public void setDetails(final String details) {\n        this.details = details;\n    }\n\n    public CategoryDto getCategory() {\n        return category;\n    }\n\n    public void setCategory(final CategoryDto category) {\n        this.category = category;\n    }\n}\n", "unit.Assert;\nimport org.junit.Test;\n\n/**\n * Created by Maks on 5/23/2017.\n */\npublic class RodCuttingTest {\n\n    @Test\n    public  void solution1TestCase1(){\n        RodCutting rc=new RodCutting();\n        Integer price [] = { 1, 5, 8, 9, 10, 17, 17, 20 };\n        int res=rc.recursive(price,4);\n        int exp=10;\n        Assert.assertEquals(exp, res);\n    }\n}\n", "port com.tmoncorp.mobile.util.common.cache.Cache;\nimport com.tmoncorp.mobile.util.common.cache.CacheStorage;\nimport com.tmoncorp.mobile.util.common.cache.CacheType;\nimport com.tmoncorp.mobile.util.common.cache.httpcache.HttpCacheType;\n\nimport javax.inject.Inject;\nimport javax.ws.rs.GET;\nimport javax.ws.rs.Path;\n\n@Path(\"/local/asyncOnly\")\npublic class AsyncOnlyLocalCacheTestResource {\n\n\n\n\t@Inject\n\tCacheTestRepository cacheTestRepository;\n\n\t@GET\n\t@Cache(type = CacheType.ASYNC_ONLY, storage = CacheStorage.LOCAL, expiration = 4)\n\t@Path(\"default\")\n\tpublic String getSync(){\n\t\treturn cacheTestRepository.makeValue();\n\t}\n\n\t@GET\n\t@Cache(type = CacheType.ASYNC_ONLY,storage = CacheStorage.LOCAL,expiration = 4,setOnError = false)\n\t@Path(\"setOnError\")\n\tpublic String getSetOnError(){\n\t\treturn cacheTestRepository.makeOnce();\n\t}\n\n\t@GET\n\t@Cache(type = CacheType.ASYNC_ONLY,storage = CacheStorage.LOCAL,expiration = 4,compress=true)\n\t@Path(\"compress\")\n\tpublic Object getCompressed(){\n\t\treturn cacheTestRepository.makeValue();\n\t}\n\n\t@GET\n\t@Cache(type = CacheType.ASYNC_ONLY,storage = CacheStorage.LOCAL,expiration = 4, browserCache = HttpCacheType.NONE)\n\t@Path(\"browserCache\")\n\tpublic String getBrowserCacheNone(){\n\t\treturn cacheTestRepository.makeValue();\n\t}\n\n}\n", "   public Long id;\n    public Template leftTemplate;\n    public Template rightTemplate;\n    public String code;\n    public String name;\n    public String description;\n    public LinkType type;\n    public Map<String, ElementPermission> leftStatusPermissions;\n    public Map<String, ElementPermission> rightStatusPermissions;\n    public Map<String, ElementPermission> rolePermissions;\n\n    @Override\n    public int hashCode() {\n        return (this.id != null ? this.id.hashCode() : super.hashCode());\n    }\n\n    @Override\n    public boolean equals(Object obj) {\n        boolean equality = false;\n        if (obj instanceof Link) {\n            final Link other = (Link) obj;\n            if (this.id != null) {\n                equality = this.id.equals(other.id);\n            } else {\n                equality = super.equals(obj);\n            }\n        }\n        return equality;\n    }\n\n    @Override\n    public String toString() {\n        return \"Link{\" + \"code=\" + code + \", leftTemplate=\" + leftTemplate + \", rightTemplate=\" + rightTemplate + '}';\n    }\n}\n", "ameters;\n\nimport org.spongycastle.asn1.ASN1Encodable;\nimport org.spongycastle.asn1.ASN1ObjectIdentifier;\nimport org.spongycastle.asn1.ASN1Primitive;\nimport org.spongycastle.asn1.cryptopro.CryptoProObjectIdentifiers;\nimport org.spongycastle.asn1.nist.NISTObjectIdentifiers;\nimport org.spongycastle.asn1.oiw.OIWObjectIdentifiers;\nimport org.spongycastle.asn1.pkcs.PKCSObjectIdentifiers;\nimport org.spongycastle.asn1.teletrust.TeleTrusTObjectIdentifiers;\n\n/**\n * General JCA/JCE utility methods.\n */\npublic class JcaJceUtils\n{\n    private JcaJceUtils()\n    {\n\n    }\n\n    /**\n     * Extract an ASN.1 encodable from an AlgorithmParameters object.\n     *\n     * @param params the object to get the encoding used to create the return value.\n     * @return an ASN.1 object representing the primitives making up the params parameter.\n     * @throws IOException if an encoding cannot be extracted.\n     */\n    public static ASN1Encodable extractParameters(AlgorithmParameters params)\n        throws IOException\n    {\n        // we try ASN.1 explicitly first just in case and then role back to the default.\n        ASN1Encodable asn1Params;\n        try\n        {\n            asn1Params = ASN1Primitive.fromByteArray(params.getEncoded(\"ASN.1\"));\n        }\n        catch (Exception ex)\n        {\n            asn1Params = ASN1Primitive.fromByteArray(params.getEncoded());\n        }\n\n        return asn1Params;\n    }\n\n    /**\n     * Load an AlgorithmParameters object with the passed in ASN.1 encodable - if possible.\n     *\n     * @param params the AlgorithmParameters object to be initialised.\n     * @param sParams the ASN.1 encodable to initialise params with.\n     * @throws IOException if the parameters cannot be initialised.\n     */\n    public static void loadParameters(AlgorithmParameters params, ASN1Encodable sParams)\n        throws IOException\n    {\n        // we try ASN.1 explicitly first just in case and then role back to the default.\n        try\n        {\n            params.init(sParams.toASN1Primitive().getEncoded(), \"ASN.1\");\n        }\n        catch (Exception ex)\n        {\n            params.init(sParams.toASN1Primitive().getEncoded());\n        }\n    }\n\n    /**\n     * Attempt to find a standard JCA name for the digest represented by the past in OID.\n     *\n     * @param digestAlgOID the OID of the digest algorithm of interest.\n     * @return a string representing the standard name - the OID as a string if none available.\n     */\n    public static String getDigestAlgName(\n        ASN1ObjectIdentifier digestAlgOID)\n    {\n        if (PKCSObjectIdentifiers.md5.equals(digestAlgOID))\n        {\n            return \"MD5\";\n        }\n        else if (OIWObjectIdentifiers.idSHA1.equals(digestAlgOID))\n        {\n            return \"SHA1\";\n        }\n        else if (NISTObjectIdentifiers.id_sha224.equals(digestAlgOID))\n        {\n            return \"SHA224\";\n        }\n        else if (NISTObjectIdentifiers.id_sha256.equals(digestAlgOID))\n        {\n            return \"SHA256\";\n        }\n        else if (NISTObjectIdentifiers.id_sha384.equals(digestAlgOID))\n        {\n            return \"SHA384\";\n        }\n        else if (NISTObjectIdentifiers.id_sha512.equals(digestAlgOID))\n        {\n            return \"SHA512\";\n        }\n        else if (TeleTrusTObjectIdentifiers.ripemd128.equals(digestAlgOID))\n        {\n            return \"RIPEMD128\";\n        }\n        else if (TeleTrusTObjectIdentifiers.ripemd160.equals(digestAlgOID))\n        {\n            return \"RIPEMD160\";\n        }\n        else if (TeleTrusTObjectIdentifiers.ripemd256.equals(digestAlgOID))\n        {\n            return \"RIPEMD256\";\n        }\n        else if (CryptoProObjectIdentifiers.gostR3411.equals(digestAlgOID))\n        {\n            return \"GOST3411\";\n        }\n        else\n        {\n            return digestAlgOID.getId();\n        }\n    }\n}\n", "\n\n    public Cclass() {\n        System.out.println(\"C constructor\");\n    }\n}\n", "java.util.stream.Collectors;\nimport org.knowm.xchange.Exchange;\nimport org.knowm.xchange.currency.CurrencyPair;\nimport org.knowm.xchange.dto.Order.OrderType;\nimport org.knowm.xchange.dto.marketdata.OrderBook;\nimport org.knowm.xchange.dto.marketdata.Ticker;\nimport org.knowm.xchange.dto.trade.LimitOrder;\nimport org.knowm.xchange.exceptions.ExchangeException;\nimport org.knowm.xchange.huobi.HuobiAdapters;\nimport org.knowm.xchange.huobi.dto.marketdata.HuobiDepth;\nimport org.knowm.xchange.service.marketdata.MarketDataService;\n\npublic class HuobiMarketDataService extends HuobiMarketDataServiceRaw implements MarketDataService {\n\n  public HuobiMarketDataService(Exchange exchange) {\n    super(exchange);\n  }\n\n  @Override\n  public Ticker getTicker(CurrencyPair currencyPair, Object... args) throws IOException {\n    return HuobiAdapters.adaptTicker(getHuobiTicker(currencyPair), currencyPair);\n  }\n\n  @Override\n  public OrderBook getOrderBook(CurrencyPair currencyPair, Object... args) throws IOException {\n\n    String depthType = \"step0\";\n\n    if (args != null && args.length == 1) {\n      Object arg0 = args[0];\n      if (!(arg0 instanceof String)) {\n        throw new ExchangeException(\"Argument 0 must be an String!\");\n      } else {\n        depthType = (String) arg0;\n      }\n    }\n    HuobiDepth depth = getHuobiDepth(currencyPair, depthType);\n    List<LimitOrder> bids =\n        depth\n            .getBids()\n            .entrySet()\n            .stream()\n            .map(\n                e ->\n                    new LimitOrder(\n                        OrderType.BID, e.getValue(), currencyPair, null, null, e.getKey()))\n            .collect(Collectors.toList());\n    List<LimitOrder> asks =\n        depth\n            .getAsks()\n            .entrySet()\n            .stream()\n            .map(\n                e ->\n                    new LimitOrder(\n                        OrderType.ASK, e.getValue(), currencyPair, null, null, e.getKey()))\n            .collect(Collectors.toList());\n    return new OrderBook(null, asks, bids);\n  }\n}\n", "mons.mail.EmailException;\nimport org.c4sg.dto.ProjectDTO;\nimport org.c4sg.entity.Project;\nimport org.c4sg.entity.User;\nimport org.c4sg.exception.UserProjectException;\n\npublic interface ProjectService {\n\n    Project findById(int id);\n    Project findByName(String name);\n    ProjectDTO saveUserProject(Integer userId, Integer projectId) throws RuntimeException;\n    Project createProject(Project project);\n    Project updateProject(Project project);\n    void deleteProject(int id);\n    void apply(User user, Project project) throws IOException, EmailException;\n    List<ProjectDTO> findProjects();\n    List<Project> findByKeyword(String keyWord);\n    List<ProjectDTO> getAppliedProjects(Integer userId);\n    List<Project> getProjectsByOrganization(Integer orgId);\n    List<ProjectDTO> findByUser(Integer userId);\n}\n", "port javax.swing.AbstractAction;\r\nimport javax.swing.ImageIcon;\r\n\r\nimport kroki.app.KrokiMockupToolApp;\r\nimport kroki.app.controller.TabbedPaneController;\r\nimport kroki.app.state.AddState;\r\nimport kroki.app.state.State;\r\nimport kroki.app.utils.CursorResource;\r\nimport kroki.app.utils.ImageResource;\r\nimport kroki.app.utils.StringResource;\r\nimport kroki.mockup.model.Composite;\r\nimport kroki.mockup.model.border.TitledBorder;\r\nimport kroki.profil.ComponentType;\r\nimport kroki.profil.group.ElementsGroup;\r\nimport kroki.profil.group.GroupOrientation;\r\n\r\n/**\r\n *\r\n * @author Vladan Marseni\u0107 (vladan.marsenic@gmail.com)\r\n */\r\npublic class AddGroupBoxAction extends AbstractAction {\r\n\r\n\tprivate static final long serialVersionUID = 1L;\r\n\t\r\n\tprivate ImageIcon smallIcon = new ImageIcon(ImageResource.getImageResource(\"action.addGroupBox.smallImage\"));\r\n\tprivate Image addEnabledIcon = CursorResource.getCursorResource(\"action.addGroupBox.smallImage\");\r\n\tprivate Image addDisabledIcon = CursorResource.getCursorResource(\"action.denied.smallImage\");\r\n\r\n    public AddGroupBoxAction() {\r\n        putValue(SMALL_ICON, smallIcon);\r\n        putValue(NAME, StringResource.getStringResource(\"action.addGroupBox.name\"));\r\n        putValue(SHORT_DESCRIPTION, StringResource.getStringResource(\"action.addGroupBox.description\"));\r\n    }\r\n\r\n    public void actionPerformed(ActionEvent e) {\r\n        TabbedPaneController tabbedPaneController = KrokiMockupToolApp.getInstance().getTabbedPaneController();\r\n        //Canvas currentCanvas = tabbedPaneController.getCurrentTabContent();\r\n        tabbedPaneController.changeCursorImage(addEnabledIcon);\r\n        tabbedPaneController.getContext().goNext(State.ADD_STATE);\r\n\r\n        ElementsGroup elementsGroup = new ElementsGroup(\"elementsGroup\", enabled, ComponentType.PANEL);\r\n        elementsGroup.setGroupOrientation(GroupOrientation.area);\r\n        ((Composite) elementsGroup.getComponent()).setBorder(new TitledBorder());\r\n        ((AddState) tabbedPaneController.getContext().getCurrentState()).setElement(elementsGroup);\r\n        ((AddState) tabbedPaneController.getContext().getCurrentState()).setAddEnabledIcon(addEnabledIcon);\r\n        ((AddState) tabbedPaneController.getContext().getCurrentState()).setAddDisabledIcon(addDisabledIcon);\r\n    }\r\n}\r\n", "C 2015, The Pistoia Alliance\r\n *\r\n * Permission is hereby granted, free of charge, to any person obtaining a copy\r\n * of this software and associated documentation files (the \"Software\"), to deal\r\n * in the Software without restriction, including without limitation the rights\r\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n * copies of the Software, and to permit persons to whom the Software is\r\n * furnished to do so, subject to the following conditions:\r\n *\r\n * The above copyright notice and this permission notice shall be included in\r\n * all copies or substantial portions of the Software.\r\n *\r\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\r\n * SOFTWARE.\r\n *****************************************************************************\r\n */\r\npackage parsertest.simplepolymerssectiontest;\r\n\r\nimport java.io.IOException;\r\n\r\nimport org.helm.notation2.parser.StateMachineParser;\r\nimport org.helm.notation2.parser.exceptionparser.ExceptionState;\r\nimport org.helm.notation2.parser.exceptionparser.SimplePolymerSectionException;\r\nimport org.helm.notation2.parser.simplepolymerssection.BetweenMonomerParser;\r\nimport org.helm.notation2.parser.simplepolymerssection.BetweenParser;\r\nimport org.helm.notation2.parser.simplepolymerssection.SimplePolymersNotationParser;\r\nimport org.jdom2.JDOMException;\r\nimport org.testng.annotations.Test;\r\n\r\n/**\r\n * BetweenInlineMonomerParser\r\n * \r\n * @author hecht\r\n */\r\npublic class BetweenInlineMonomerParser {\r\n\r\n  StateMachineParser parser;\r\n\r\n  @Test\r\n  public void goToSimplePolymerNotationParser() throws ExceptionState, IOException, JDOMException {\r\n    parser = new StateMachineParser();\r\n    parser.setState(new BetweenMonomerParser(parser));\r\n    parser.doAction('.');\r\n\r\n    if (!(parser.getState() instanceof SimplePolymersNotationParser)) {\r\n      throw new SimplePolymerSectionException(\"\");\r\n    }\r\n  }\r\n\r\n  @Test\r\n  public void goToConnection() throws ExceptionState, IOException, JDOMException {\r\n    parser = new StateMachineParser();\r\n    parser.setState(new BetweenMonomerParser(parser));\r\n    parser.doAction('}');\r\n\r\n    if (!(parser.getState() instanceof BetweenParser)) {\r\n      throw new SimplePolymerSectionException(\"\");\r\n    }\r\n  }\r\n\r\n  @Test(expectedExceptions = SimplePolymerSectionException.class)\r\n  public void goToWithException() throws ExceptionState, IOException, JDOMException {\r\n    parser = new StateMachineParser();\r\n    parser.setState(new BetweenMonomerParser(parser));\r\n    parser.doAction('h');\r\n  }\r\n}\r\n", "e, for the tree below:\n        5\n       / \\\n      4   8\n     /   / \\\n    11  13  4\n   /  \\      \\\n  7    2      1\nThe root-to-leaf paths are:\n 5 4 11 7\n 5 4 11 2\n 5 8 13\n 5 8 4 1\n*/\n\n package treesPackage;\n\n public class Prob8PrintPaths {\n\n  public static void printPaths(Node root) {\n    int[] pathsArray = new int[1000];\n    printPaths(root, pathsArray, 0);\n  }\n\n  private static void printPaths(Node root, int[] pathsArray, int index) {\n\n    if (root == null) return;\n\n    pathsArray[index++] = root.getData();\n\n    if (root.getLeftChild() == null && root.getRightChild() == null) {\n      printArray(pathsArray, index);\n      return;\n    }  else {\n      printPaths(root.getLeftChild(), pathsArray, index);\n      printPaths(root.getRightChild(), pathsArray, index);\n    }\n\n  }\n\n  public static void printArray(int[] arr, int len) {\n    for (int i = 0; i < len; i++)\n      System.out.print(arr[i] + \" \");\n    System.out.println();\n  }\n\n  public static void main(String[] args) {\n    /*\n          5\n         / \\\n        4   8\n       /   / \\\n      11  13  4\n     /  \\      \\\n    7    2      1\n\n    */\n    Node node1 = new Node(5);\n    Node node2 = new Node(4);\n    Node node3 = new Node(8);\n    Node node4 = new Node(11);\n    Node node5 = new Node(13);\n    Node node6 = new Node(4);\n    Node node7 = new Node(7);\n    Node node8 = new Node(2);\n    Node node9 = new Node(1);\n\n    node1.setLeftChild(node2);\n    node1.setRightChild(node3);\n\n    node2.setLeftChild(node4);\n\n    node3.setLeftChild(node5);\n    node3.setRightChild(node6);\n\n    node4.setLeftChild(node7);\n    node4.setRightChild(node8);\n\n    node6.setRightChild(node9);\n\n    printPaths(node1);\n  }\n }", "rt java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\n\n/**\n * @author Octopod - octopodsquad@gmail.com\n */\npublic class CommandMethod\n{\n\tCommand command;\n\tMethod method;\n\tClass<?>[] types;\n\tAnnotation[][] param_annotations;\n\tObject instance;\n\n\tpublic CommandMethod(Method method, Object instance)\n\t{\n\t\tthis.command = method.getAnnotation(Command.class);\n\t\tthis.method = method;\n\t\tthis.instance = instance;\n\t\tthis.types = method.getParameterTypes();\n\t\tthis.param_annotations = method.getParameterAnnotations();\n\t}\n\n\tpublic void dispatch(ServerCommandSource source, String... args)\n\t{\n\t\tif(!source.hasPermission(command.permission()))\n\t\t{\n\t\t\tsource.sendMessage(\"&cSorry, you don't have permission to use this commands.\");\n\t\t\treturn;\n\t\t}\n\n\t\tObject[] parameters = convertArguments(source, args);\n\n\t\tif(parameters != null)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tmethod.invoke(instance, parameters);\n\t\t\t}\n\t\t\tcatch (Exception e)\n\t\t\t{\n\t\t\t\tsource.sendMessage(\"&cAn error has occured while executing this commands.\");\n\t\t\t\te.printStackTrace();\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate Object[] convertArguments(ServerCommandSource source, String[] args)\n\t{\n\t\tObject[] parameters = new Object[types.length];\n\t\tparameters[0] = source;\n\t\tfor(int i = 1; i < types.length; i++)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\tif(i > (args.length))\n\t\t\t\t{\n\t\t\t\t\t//Try to resolve using default value\n\t\t\t\t\tDefault def = getAnnotation(param_annotations[i], Default.class);\n\t\t\t\t\tif(def == null)\n\t\t\t\t\t{\n\t\t\t\t\t\tsource.sendMessage(\"&8[&b\" + command.usage().replace(\"<commands>\", command.aliases()[0]) + \"&8]: &6\" + command.description());\n\t\t\t\t\t\treturn null;\n\t\t\t\t\t}\n\t\t\t\t\tparameters[i] = resolve(def.value(), types[i]);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparameters[i] = resolve(args[i - 1], types[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t\tcatch (IllegalArgumentException e)\n\t\t\t{\n\t\t\t\tsource.sendMessage(\"&c\" + e.getMessage());\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\treturn parameters;\n\t}\n\n\tprivate static <T> T getAnnotation(Annotation[] annotations, Class<T> type)\n\t{\n\t\tfor(Annotation annotation: annotations)\n\t\t{\n\t\t\tif(type.isInstance(annotation)) return type.cast(annotation);\n\t\t}\n\t\treturn null;\n\t}\n\n\t@SuppressWarnings(\"unchecked\")\n\tprivate static <T> T resolve(String arg, Class<T> type)\n\t{\n\t\tif(type == String.class)\n\t\t{\n\t\t\treturn type.cast(arg);\n\t\t}\n\t\telse if(type.isEnum())\n\t\t{\n\t\t\treturn type.cast(Enum.valueOf((Class<? extends Enum>) type, arg.toUpperCase()));\n\t\t}\n\t\telse if(type == int.class || type == Integer.class)\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\treturn (T)(Integer)Integer.parseInt(arg);\n\t\t\t}\n\t\t\tcatch (NumberFormatException e)\n\t\t\t{\n\t\t\t\tthrow new IllegalArgumentException(\"Expected an integer, but recieved \" + arg);\n\t\t\t}\n\t\t}\n\t\tthrow new IllegalArgumentException(\"Argument type not supported: \" + type.getName());\n\t}\n}\n", "g and other contributors\n * Released under the MIT license\n * https://opensource.org/licenses/MIT\n */\npackage org.mifmi.commons4j.graphics.image;\n\nimport java.awt.Graphics2D;\nimport java.awt.RenderingHints;\nimport java.awt.RenderingHints.Key;\nimport java.awt.image.BufferedImage;\nimport java.io.BufferedOutputStream;\nimport java.io.ByteArrayOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.OutputStream;\nimport java.util.Map;\n\nimport javax.imageio.ImageIO;\n\npublic class ImageUtilz {\n\t\n\tprivate ImageUtilz() {\n\t}\n\n\tpublic static byte[] shrinkAsByteArray(InputStream is, String formatName, int maxWidth, int maxHeight, Map<Key, Object> hints) throws IOException {\n\t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n\t\ttry {\n\t\t\tBufferedOutputStream bos = new BufferedOutputStream(baos);\n\t\t\ttry {\n\t\t\t\tshrink(is, bos, formatName, maxWidth, maxHeight, hints);\n\t\t\t\tbos.flush();\n\t\t\t\treturn baos.toByteArray();\n\t\t\t} finally {\n\t\t\t\tbos.close();\n\t\t\t}\n\t\t} finally {\n\t\t\tbaos.close();\n\t\t}\n\t}\n\tpublic static void shrink(InputStream is, OutputStream os, String formatName, int maxWidth, int maxHeight, Map<Key, Object> hints) throws IOException {\n\t\tBufferedImage shrinkImage = shrink(is, maxWidth, maxHeight, hints);\n\t\tImageIO.write(shrinkImage, formatName, os);\n\t}\n\tpublic static BufferedImage shrink(InputStream is, int maxWidth, int maxHeight, Map<Key, Object> hints) throws IOException {\n\t\tBufferedImage image;\n\t\ttry {\n\t\t\timage = ImageIO.read(is);\n\t\t} catch (IOException e) {\n\t\t\tthrow e;\n\t\t}\n\t\t\n\t\tdouble scale = calcScale(image.getWidth(), image.getHeight(), maxWidth, maxHeight);\n\t\tif (1.0 <= scale) {\n\t\t\t// FIXME\n\t\t}\n\t\t\n\t\tBufferedImage shrinkImage = resize(image, scale, hints);\n\t\treturn shrinkImage;\n\t}\n\t\n\tpublic static BufferedImage resize(BufferedImage image, double scale, Map<Key, Object> hints) {\n\t\t// see: http://www.javainthebox.com/2010/07/java-3.html\n\t\t\n\t\tint targetWidth = (int)(image.getWidth() * scale);\n\t\tint targetHeight = (int)(image.getHeight() * scale);\n\n\t\tBufferedImage currentImage = image;\n\n\t\twhile (true) {\n\t\t\tint currentWidth = currentImage.getWidth();\n\t\t\tint currentHeight = currentImage.getHeight();\n\t\t\t\n\t\t\tif (currentWidth <= targetWidth || currentHeight <= targetHeight) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t\n\t\t\tint delta = currentWidth - targetWidth;\n\t\t\tint nextWidth = currentWidth >> 1;\n\t\t\tint nextHeight = currentHeight >> 1;\n\t\t\tboolean isFinal = false;\n\t\t\tif (delta <= nextWidth) {\n\t\t\t\t// \u6700\u7d42\u7684\u306a\u30a4\u30e1\u30fc\u30b8\u3068\u30b5\u30a4\u30ba\u306e\u5dee\u304c\u3001\u6b21\u306b\u7e2e\u5c0f\u3059\u308b\u30b5\u30a4\u30ba\u3088\u308a\u3082\u5c0f\u3055\u3044\u5834\u5408\n\t\t\t\tnextWidth = targetWidth;\n\t\t\t\tnextHeight = targetHeight;\n\t\t\t\tisFinal = true;\n\t\t\t}\n\t\t\t\n\t\t\tBufferedImage tmpImage = new BufferedImage(nextWidth, nextHeight, BufferedImage.TYPE_INT_RGB);\n\t\t\tGraphics2D g2d = tmpImage.createGraphics();\n\t\t\ttry {\n\t\t\t\tif (hints != null) {\n\t\t\t\t\tfor (Map.Entry<Key, Object> hint : hints.entrySet()) {\n\t\t\t\t\t\tg2d.setRenderingHint(hint.getKey(), hint.getValue());\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tg2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);\n\t\t\t\tg2d.drawImage(currentImage, 0, 0, tmpImage.getWidth(), tmpImage.getHeight(), null);\n\t\t\t} finally {\n\t\t\t\tg2d.dispose();\n\t\t\t}\n\t\t\tcurrentImage = tmpImage;\n\t\t\t\n\t\t\tif (isFinal) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\n\t\treturn currentImage;\n\t}\n\t\n\tpublic static double calcScale(int srcWidth, int srcHeight, int destWidth, int destHeight) {\n\t\tdouble scaleWidth = (double)destWidth / srcWidth;\n\t\tdouble scaleHeight = (double)destHeight / srcHeight;\n\t\treturn Math.min(scaleWidth, scaleHeight);\n\t}\n}\n", "n 2017/04/11.\n */\npublic class ErrorCodeResponse extends Response<ErrorCode> {\n}\n", "Agent;\n\n/**\n * UserAgents from latest to oldest for Psbot\n */\npublic class Psbot extends UserAgent {\t\n\t\n\tpublic String[] getAllUserAgentStrings() {\n\t\tString [] userAgentStrings = {\n\t\t\t\"psbot/0.1 (+http://www.picsearch.com/bot.html)\"\n\t\t};\n\t\treturn userAgentStrings;\n\t}\n}", "mport android.content.Context;\nimport android.database.Cursor;\nimport android.graphics.Color;\nimport android.os.Bundle;\nimport android.provider.ContactsContract;\nimport android.view.Menu;\nimport android.view.MenuInflater;\nimport android.view.MenuItem;\nimport android.view.View;\nimport android.widget.AdapterView;\nimport android.widget.ArrayAdapter;\nimport android.widget.CheckBox;\nimport android.widget.ListView;\nimport android.widget.TextView;\nimport android.widget.Toast;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\n\n\n/**\n * Created by Oscar on 2013-10-08.\n */\npublic class ViewCollaboratorsActivity extends Activity {\n\n    private ListView contactsListView;\n    private ArrayList<User> contacts;\n    private TextView noCollaborators;\n\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.view_collaborators_activity);\n\n\n        noCollaborators = (TextView) findViewById(R.id.no_collaborators);\n\n        noCollaborators.setVisibility(View.GONE);\n\n        getActionBar().setDisplayHomeAsUpEnabled(true);\n\n        contactsListView = (ListView) findViewById(R.id.collaborators_list_view);\n        contacts = TodoList.getCollaboratorsFromCurrentList();\n\n        if(contacts.size() == 0){\n            noCollaborators.setVisibility(View.VISIBLE);\n        }\n\n        final CollaboratorsListAdapter listAdapter = new CollaboratorsListAdapter(this, contacts,\n                android.R.layout.simple_selectable_list_item);\n        contactsListView.setAdapter(listAdapter);\n        getActionBar().setDisplayShowTitleEnabled(false);\n    }\n}", "bel() {\r\n\t\treturn label;\r\n\t}\r\n\r\n\tpublic void setLabel(String label) {\r\n\t\tthis.label = label;\r\n\t}\r\n\r\n}", "mon.JavaStandardVersion;\n\n/**\n * \u65e5\u4ed8\u306eUtil\u30af\u30e9\u30b9<br>\n * only Java STD class.\n * \n * @author pollseed\n * \n */\n@JavaStandardVersion\npublic class DateUtils {\n\n    /**\n     * \u73fe\u5728\u5e74\u6708\u65e5\u3092\u8fd4\u5374\u3057\u307e\u3059.\n     * \n     * @return\n     */\n    public static Date now() {\n        return new Date();\n    }\n\n    /**\n     * \u660e\u65e5\u3092\u8fd4\u5374\u3057\u307e\u3059.\n     * \n     * @return\n     */\n    public static Date yesterday() {\n        return add(now(), -1);\n    }\n\n    /**\n     * \u6628\u65e5\u3092\u8fd4\u5374\u3057\u307e\u3059.\n     * \n     * @return\n     */\n    public static Date tomorrow() {\n        return add(now(), +1);\n    }\n\n    /**\n     * \u6307\u5b9a\u3057\u305f\u65e5\u4ed8\u304b\u3089\u6307\u5b9a\u3057\u305f\u6570\u5024\u3092\u52a0\u7b97\u3057\u307e\u3059.\n     * \n     * @param date\n     * @param value\n     * @return\n     */\n    protected static Date add(final Date date, final int value) {\n        final Calendar cal = Calendar.getInstance();\n        cal.setTime(date);\n        cal.add(Calendar.DAY_OF_MONTH, value);\n        return cal.getTime();\n    }\n\n    /**\n     * \u6307\u5b9a\u3057\u305f\u65e5\u4ed8\u3092\u6bd4\u8f03\u3057\u3001\u305d\u306e\u5dee\u5206\u3092\u8fd4\u5374\u3057\u307e\u3059.\n     * \n     * @param one\n     * @param another\n     * @return\n     */\n    protected static Integer compare(final Date one, final Date another) {\n        if (one == null || another == null) {\n            return null;\n        }\n        final Calendar cal1 = Calendar.getInstance();\n        final Calendar cal2 = Calendar.getInstance();\n        cal1.setTime(one);\n        cal2.setTime(another);\n        int age = Math.abs(cal1.get(Calendar.YEAR) - cal2.get(Calendar.YEAR));\n        return cal1.getTime().before(cal2.getTime()) ? age-- : age;\n    }\n\n}\n", "MIT License:\n//\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n//\n// The above copyright notice and this permission notice shall be included in\n// all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n// THE SOFTWARE.\n\npackage org.capnproto;\n\npublic interface FromPointerReaderBlobDefault<T> {\n    T fromPointerReaderBlobDefault(SegmentReader segment, int pointer, java.nio.ByteBuffer defaultBuffer,\n                                   int defaultOffset, int defaultSize);\n}\n", "t.FList;\nimport drjoliv.jfunc.data.list.Functions;\nimport drjoliv.jfunc.function.F0;\nimport drjoliv.jfunc.function.F1;\nimport drjoliv.jfunc.nums.Longs;\n\npublic class Euler06 implements F0<String> {\n\n  public static long euler06() {\n    F1<FList<Long>, Long> sqrAndSum = F1.compose(Longs::sum, Functions.map(i -> i * i));\n    F1<FList<Long>, Long> sumAndSqu = F1.compose(i -> i * i, Longs::sum);\n    Long l = sqrAndSum.call(range(1L,10L));\n    Long ll = sumAndSqu.call(range(1L,10L));\n    return ll - l;\n  }\n\n  @Override\n  public String call() {\n    return String.valueOf(euler06());\n  }\n\n}\n", "o.backups.target.impl.DatabaseBackupTargetDTO;\nimport ru.vyukov.bakapa.dump.DumpResult;\nimport ru.vyukov.bakapa.dump.DumpUtilWrapper;\nimport ru.vyukov.bakapa.dump.AbstractDatabaseDumpWrapperUtil;\n\nimport java.io.IOException;\n\n/**\n * @author Oleg Vyukov\n */\n@Slf4j\npublic class MongoDbDump extends AbstractDatabaseDumpWrapperUtil implements DumpUtilWrapper {\n\n\n\n    public MongoDbDump(DatabaseBackupTargetDTO databaseBackupTarget) {\n        super(databaseBackupTarget);\n    }\n\n    @Override\n    public DumpResult dump() throws IOException {\n        throw new IllegalStateException(\"not implemented\");\n    }\n\n    @Override\n    public void close() throws IOException {\n        throw new IllegalStateException(\"not implemented\");\n    }\n}", "eements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.zongtui.classifier;\n\nimport java.io.Closeable;\n\nimport com.zongtui.classifier.math.Vector;\n\n/**\n * The simplest interface for online learning algorithms.\n */\npublic interface OnlineLearner extends Closeable {\n  /**\n   * Updates the model using a particular target variable value and a feature vector.\n   * <p/>\n   * There may an assumption that if multiple passes through the training data are necessary, then\n   * the training examples will be presented in the same order.  This is because the order of\n   * training examples may be used to assign records to different data splits for evaluation by\n   * cross-validation.  Without the order invariance, records might be assigned to training and test\n   * splits and error estimates could be seriously affected.\n   * <p/>\n   * If re-ordering is necessary, then using the alternative API which allows a tracking key to be\n   * added to the training example can be used.\n   *\n   * @param actual   The value of the target variable.  This value should be in the half-open\n   *                 interval [0..n) where n is the number of target categories.\n   * @param instance The feature vector for this example.\n   */\n  void train(int actual, Vector instance);\n\n  /**\n   * Updates the model using a particular target variable value and a feature vector.\n   * <p/>\n   * There may an assumption that if multiple passes through the training data are necessary that\n   * the tracking key for a record will be the same for each pass and that there will be a\n   * relatively large number of distinct tracking keys and that the low-order bits of the tracking\n   * keys will not correlate with any of the input variables.  This tracking key is used to assign\n   * training examples to different test/training splits.\n   * <p/>\n   * Examples of useful tracking keys include id-numbers for the training records derived from\n   * a database id for the base table from the which the record is derived, or the offset of\n   * the original data record in a data file.\n   *\n   * @param trackingKey The tracking key for this training example.\n   * @param groupKey     An optional value that allows examples to be grouped in the computation of\n   * the update to the model.\n   * @param actual   The value of the target variable.  This value should be in the half-open\n   *                 interval [0..n) where n is the number of target categories.\n   * @param instance The feature vector for this example.\n   */\n  void train(long trackingKey, String groupKey, int actual, Vector instance);\n\n  /**\n   * Updates the model using a particular target variable value and a feature vector.\n   * <p/>\n   * There may an assumption that if multiple passes through the training data are necessary that\n   * the tracking key for a record will be the same for each pass and that there will be a\n   * relatively large number of distinct tracking keys and that the low-order bits of the tracking\n   * keys will not correlate with any of the input variables.  This tracking key is used to assign\n   * training examples to different test/training splits.\n   * <p/>\n   * Examples of useful tracking keys include id-numbers for the training records derived from\n   * a database id for the base table from the which the record is derived, or the offset of\n   * the original data record in a data file.\n   *\n   * @param trackingKey The tracking key for this training example.\n   * @param actual   The value of the target variable.  This value should be in the half-open\n   *                 interval [0..n) where n is the number of target categories.\n   * @param instance The feature vector for this example.\n   */\n  void train(long trackingKey, int actual, Vector instance);\n\n  /**\n   * Prepares the classifier for classification and deallocates any temporary data structures.\n   *\n   * An online classifier should be able to accept more training after being closed, but\n   * closing the classifier may make classification more efficient.\n   */\n  @Override\n  void close();\n}\n", "s SaveResult {\n  private Link SourceDocument = null;\n  private Link DestDocument = null;\n  private List<Link> AdditionalItems = new ArrayList<Link>();\n  /**\n\t * getSourceDocument\n\t * Gets Link\n\t * @return SourceDocument\n\t */\n  public Link getSourceDocument() {\n    return SourceDocument;\n  }\n\n\t/**\n\t * setSourceDocument\n\t * Sets Link\n\t * @param SourceDocument Link\n\t */\n  public void setSourceDocument(Link SourceDocument) {\n    this.SourceDocument = SourceDocument;\n  }\n\n  /**\n\t * getDestDocument\n\t * Gets Link\n\t * @return DestDocument\n\t */\n  public Link getDestDocument() {\n    return DestDocument;\n  }\n\n\t/**\n\t * setDestDocument\n\t * Sets Link\n\t * @param DestDocument Link\n\t */\n  public void setDestDocument(Link DestDocument) {\n    this.DestDocument = DestDocument;\n  }\n\n  /**\n\t * getAdditionalItems\n\t * Gets List<Link>\n\t * @return AdditionalItems\n\t */\n  public List<Link> getAdditionalItems() {\n    return AdditionalItems;\n  }\n\n\t/**\n\t * setAdditionalItems\n\t * Sets List<Link>\n\t * @param AdditionalItems List<Link>\n\t */\n  public void setAdditionalItems(List<Link> AdditionalItems) {\n    this.AdditionalItems = AdditionalItems;\n  }\n\n  @Override\n  public String toString()  {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class SaveResult {\\n\");\n    sb.append(\"  SourceDocument: \").append(SourceDocument).append(\"\\n\");\n    sb.append(\"  DestDocument: \").append(DestDocument).append(\"\\n\");\n    sb.append(\"  AdditionalItems: \").append(AdditionalItems).append(\"\\n\");\n    sb.append(\"}\\n\");\n    return sb.toString();\n  }\n}\n\n", "by a BSD-style license that can be\n// found in the LICENSE file.\n\npackage org.chromium.net;\n\nimport static org.hamcrest.CoreMatchers.equalTo;\nimport static org.hamcrest.CoreMatchers.notNullValue;\nimport static org.hamcrest.CoreMatchers.nullValue;\nimport static org.junit.Assert.assertThat;\nimport static org.junit.Assert.fail;\nimport static org.mockito.Matchers.any;\nimport static org.mockito.Matchers.anyBoolean;\nimport static org.mockito.Matchers.anyInt;\nimport static org.mockito.Matchers.anyLong;\nimport static org.mockito.Matchers.anyString;\nimport static org.mockito.Matchers.eq;\nimport static org.mockito.Matchers.isNull;\nimport static org.mockito.Mockito.doNothing;\nimport static org.mockito.Mockito.doReturn;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.spy;\nimport static org.mockito.Mockito.times;\nimport static org.mockito.Mockito.verify;\nimport static org.mockito.Mockito.verifyZeroInteractions;\nimport static org.mockito.Mockito.when;\n\nimport android.accounts.Account;\nimport android.accounts.AccountManager;\nimport android.accounts.AccountManagerCallback;\nimport android.accounts.AccountManagerFuture;\nimport android.accounts.AuthenticatorException;\nimport android.accounts.OperationCanceledException;\nimport android.app.Activity;\nimport android.app.Application;\nimport android.content.BroadcastReceiver;\nimport android.content.Context;\nimport android.content.Intent;\nimport android.os.Bundle;\nimport android.os.Handler;\n\nimport junit.framework.Assert;\n\nimport org.chromium.base.ApplicationStatus;\nimport org.chromium.base.BaseChromiumApplication;\nimport org.chromium.base.ContextUtils;\nimport org.chromium.base.test.shadows.ShadowMultiDex;\nimport org.chromium.net.HttpNegotiateAuthenticator.GetAccountsCallback;\nimport org.chromium.net.HttpNegotiateAuthenticator.RequestData;\nimport org.chromium.testing.local.LocalRobolectricTestRunner;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.mockito.ArgumentCaptor;\nimport org.mockito.Captor;\nimport org.mockito.Mock;\nimport org.mockito.MockitoAnnotations;\nimport org.robolectric.Robolectric;\nimport org.robolectric.annotation.Config;\nimport org.robolectric.annotation.Implementation;\nimport org.robolectric.annotation.Implements;\nimport org.robolectric.shadows.ShadowAccountManager;\nimport org.robolectric.shadows.ShadowApplication;\n\nimport java.io.IOException;\nimport java.util.List;\n\n/**\n * Robolectric tests for HttpNegotiateAuthenticator\n */\n@RunWith(LocalRobolectricTestRunner.class)\n@Config(manifest = Config.NONE, application = BaseChromiumApplication.class,\n        shadows = {HttpNegotiateAuthenticatorTest.ExtendedShadowAccountManager.class,\n                ShadowMultiDex.class})\npublic class HttpNegotiateAuthenticatorTest {\n    /**\n     * User the AccountManager to inject a mock instance.\n     * Note: Shadow classes need to be public and static.\n     */\n    @Implements(AccountManager.class)\n    public static class ExtendedShadowAccountManager extends ShadowAccountManager {\n        @Implementation\n        public static AccountManager get(Context context) {\n            return sMockAccountManager;\n        }\n    }\n\n    @Mock\n    private static AccountManager sMockAccountManager;\n    @Captor\n    private ArgumentCaptor<AccountManagerCallback<Bundle>> mBundleCallbackCaptor;\n    @Captor\n    private ArgumentCaptor<AccountManagerCallback<Account[]>> mAccountCallbackCaptor;\n    @Captor\n    private ArgumentCaptor<Bundle> mBundleCaptor;\n\n    @Before\n    public void setUp() {\n        MockitoAnnotations.initMocks(this);\n        ContextUtils.initApplicationContextForJUnitTests(Robolectric.application);\n    }\n\n    @After\n    public void tearDown() {\n        ApplicationStatus.destroyForJUnitTests();\n    }\n\n    /**\n     * Test of {@link HttpNegotiateAuthenticator#getNextAuthToken}\n     */\n    @Test\n    public void testGetNextAuthToken() {\n        final String accountType = \"Dummy_Account\";\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(accountType);\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n\n        authenticator.getNextAuthToken(0, \"test_principal\", \"\", true);\n\n        verify(sMockAccountManager).getAuthTokenByFeatures(\n                eq(accountType),\n                eq(\"SPNEGO:HOSTBASED:test_principal\"),\n                eq(new String[] {\"SPNEGO\"}),\n                any(Activity.class),\n                isNull(Bundle.class),\n                mBundleCaptor.capture(),\n                mBundleCallbackCaptor.capture(),\n                any(Handler.class));\n\n        assertThat(\"There is no existing context\",\n                mBundleCaptor.getValue().get(HttpNegotiateConstants.KEY_SPNEGO_CONTEXT),\n                nullValue());\n        assertThat(\"The existing token is empty\",\n                mBundleCaptor.getValue().getString(HttpNegotiateConstants.KEY_INCOMING_AUTH_TOKEN),\n                equalTo(\"\"));\n        assertThat(\"Delegation is allowed\",\n                mBundleCaptor.getValue().getBoolean(HttpNegotiateConstants.KEY_CAN_DELEGATE),\n                equalTo(true));\n        assertThat(\"getAuthTokenByFeatures was called with a callback\",\n                mBundleCallbackCaptor.getValue(), notNullValue());\n    }\n\n    /**\n     * Test of {@link HttpNegotiateAuthenticator#getNextAuthToken} without a visible activity.\n     * This emulates the behavior with WebView, where the application is a generic one and doesn't\n     * set up the ApplicationStatus the same way.\n     */\n    @Test\n    @Config(application = Application.class)\n    public void testGetNextAuthTokenWithoutActivity() {\n        final String accountType = \"Dummy_Account\";\n        final Account[] returnedAccount = {new Account(\"name\", accountType)};\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(accountType);\n\n        authenticator.getNextAuthToken(1234, \"test_principal\", \"\", true);\n\n        Assert.assertNull(ApplicationStatus.getLastTrackedFocusedActivity());\n        verify(sMockAccountManager).getAccountsByTypeAndFeatures(\n                eq(accountType),\n                eq(new String[]{\"SPNEGO\"}),\n                mAccountCallbackCaptor.capture(),\n                any(Handler.class));\n\n        mAccountCallbackCaptor.getValue().run(makeFuture(returnedAccount));\n\n        verify(sMockAccountManager).getAuthToken(\n                any(Account.class),\n                eq(\"SPNEGO:HOSTBASED:test_principal\"),\n                mBundleCaptor.capture(),\n                eq(true),\n                any(HttpNegotiateAuthenticator.GetTokenCallback.class),\n                any(Handler.class));\n\n        assertThat(\"There is no existing context\",\n                mBundleCaptor.getValue().get(HttpNegotiateConstants.KEY_SPNEGO_CONTEXT),\n                nullValue());\n        assertThat(\"The existing token is empty\",\n                mBundleCaptor.getValue().getString(HttpNegotiateConstants.KEY_INCOMING_AUTH_TOKEN),\n                equalTo(\"\"));\n        assertThat(\"Delegation is allowed\",\n                mBundleCaptor.getValue().getBoolean(HttpNegotiateConstants.KEY_CAN_DELEGATE),\n                equalTo(true));\n    }\n\n    /** Tests the behavior of {@link HttpNegotiateAuthenticator.GetAccountsCallback} */\n    @Test\n    public void testGetAccountCallback() {\n        String type = \"Dummy_Account\";\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(type);\n        RequestData requestData = new RequestData();\n        requestData.nativeResultObject = 42;\n        requestData.accountManager = sMockAccountManager;\n        GetAccountsCallback callback = authenticator.new GetAccountsCallback(requestData);\n\n        // Should fail because there are no accounts\n        callback.run(makeFuture(new Account[]{}));\n        verify(authenticator).nativeSetResult(\n                eq(42L),\n                eq(NetError.ERR_MISSING_AUTH_CREDENTIALS),\n                isNull(String.class));\n\n        // Should succeed, for a single account we use it for the AccountManager#getAuthToken call.\n        Account testAccount = new Account(\"a\", type);\n        callback.run(makeFuture(new Account[]{testAccount}));\n        verify(sMockAccountManager).getAuthToken(\n                eq(testAccount),\n                anyString(),\n                any(Bundle.class),\n                eq(true),\n                any(HttpNegotiateAuthenticator.GetTokenCallback.class),\n                any(Handler.class));\n\n        // Should fail because there is more than one account\n        callback.run(makeFuture(new Account[]{new Account(\"a\", type), new Account(\"b\", type)}));\n        verify(authenticator, times(2)).nativeSetResult(\n                eq(42L),\n                eq(NetError.ERR_MISSING_AUTH_CREDENTIALS),\n                isNull(String.class));\n    }\n\n    /**\n     * Tests the behavior of {@link HttpNegotiateAuthenticator.GetTokenCallback} when the result it\n     * receives contains an intent rather than a token directly.\n     */\n    @Test\n    public void testGetTokenCallbackWithIntent() {\n        String type = \"Dummy_Account\";\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(type);\n        RequestData requestData = new RequestData();\n        requestData.nativeResultObject = 42;\n        requestData.authTokenType = \"foo\";\n        requestData.account = new Account(\"a\", type);\n        requestData.accountManager = sMockAccountManager;\n        Bundle b = new Bundle();\n        b.putParcelable(AccountManager.KEY_INTENT, new Intent());\n\n        authenticator.new GetTokenCallback(requestData).run(makeFuture(b));\n        verifyZeroInteractions(sMockAccountManager);\n\n        // Verify that the broadcast receiver is registered\n        Intent intent = new Intent(AccountManager.LOGIN_ACCOUNTS_CHANGED_ACTION);\n        ShadowApplication shadowApplication = Robolectric.getShadowApplication();\n        List<BroadcastReceiver> receivers = shadowApplication.getReceiversForIntent(intent);\n        assertThat(\"There is one registered broadcast receiver\", receivers.size(), equalTo(1));\n\n        // Send the intent to the receiver.\n        BroadcastReceiver receiver = receivers.get(0);\n        receiver.onReceive(Robolectric.getShadowApplication().getApplicationContext(), intent);\n\n        // Verify that the auth token is properly requested from the account manager.\n        verify(sMockAccountManager).getAuthToken(\n                eq(new Account(\"a\", type)),\n                eq(\"foo\"),\n                isNull(Bundle.class),\n                eq(true),\n                any(HttpNegotiateAuthenticator.GetTokenCallback.class),\n                any(Handler.class));\n    }\n\n    /**\n     * Test of callback called when getting the auth token completes.\n     */\n    @Test\n    public void testAccountManagerCallbackRun() {\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(\"Dummy_Account\");\n\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n\n        // Call getNextAuthToken to get the callback\n        authenticator.getNextAuthToken(1234, \"test_principal\", \"\", true);\n        verify(sMockAccountManager)\n                .getAuthTokenByFeatures(anyString(), anyString(), any(String[].class),\n                        any(Activity.class), any(Bundle.class), any(Bundle.class),\n                        mBundleCallbackCaptor.capture(), any(Handler.class));\n\n        Bundle resultBundle = new Bundle();\n        Bundle context = new Bundle();\n        context.putString(\"String\", \"test_context\");\n        resultBundle.putInt(HttpNegotiateConstants.KEY_SPNEGO_RESULT, HttpNegotiateConstants.OK);\n        resultBundle.putBundle(HttpNegotiateConstants.KEY_SPNEGO_CONTEXT, context);\n        resultBundle.putString(AccountManager.KEY_AUTHTOKEN, \"output_token\");\n        mBundleCallbackCaptor.getValue().run(makeFuture(resultBundle));\n        verify(authenticator).nativeSetResult(1234, 0, \"output_token\");\n\n        // Check that the next call to getNextAuthToken uses the correct context\n        authenticator.getNextAuthToken(5678, \"test_principal\", \"\", true);\n        verify(sMockAccountManager, times(2))\n                .getAuthTokenByFeatures(anyString(), anyString(), any(String[].class),\n                        any(Activity.class), any(Bundle.class), mBundleCaptor.capture(),\n                        mBundleCallbackCaptor.capture(), any(Handler.class));\n\n        assertThat(\"The spnego context is preserved between calls\",\n                mBundleCaptor.getValue().getBundle(HttpNegotiateConstants.KEY_SPNEGO_CONTEXT),\n                equalTo(context));\n\n        // Test exception path\n        mBundleCallbackCaptor.getValue().run(\n                this.<Bundle>makeFuture(new OperationCanceledException()));\n        verify(authenticator).nativeSetResult(5678, NetError.ERR_UNEXPECTED, null);\n    }\n\n    @Test\n    public void testPermissionDenied() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(\"Dummy_Account\");\n\n        doReturn(true).when(authenticator)\n                .lacksPermission(any(Context.class), anyString(), anyBoolean());\n\n        authenticator.getNextAuthToken(1234, \"test_principal\", \"\", true);\n        verify(authenticator)\n                .nativeSetResult(anyLong(), eq(NetError.ERR_MISCONFIGURED_AUTH_ENVIRONMENT),\n                        isNull(String.class));\n    }\n\n    @Test\n    public void testAccountManagerCallbackNullErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(null, NetError.ERR_UNEXPECTED);\n    }\n\n    @Test\n    public void testAccountManagerCallbackUnexpectedErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_UNEXPECTED, NetError.ERR_UNEXPECTED);\n    }\n\n    @Test\n    public void testAccountManagerCallbackAbortedErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_ABORTED, NetError.ERR_ABORTED);\n    }\n\n    @Test\n    public void testAccountManagerCallbackSecLibErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS,\n                NetError.ERR_UNEXPECTED_SECURITY_LIBRARY_STATUS);\n    }\n\n    @Test\n    public void testAccountManagerCallbackInvalidResponseErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(\n                HttpNegotiateConstants.ERR_INVALID_RESPONSE, NetError.ERR_INVALID_RESPONSE);\n    }\n\n    @Test\n    public void testAccountManagerCallbackInvalidAuthCredsErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_INVALID_AUTH_CREDENTIALS,\n                NetError.ERR_INVALID_AUTH_CREDENTIALS);\n    }\n\n    @Test\n    public void testAccountManagerCallbackUnsuppAutchSchemeErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_UNSUPPORTED_AUTH_SCHEME,\n                NetError.ERR_UNSUPPORTED_AUTH_SCHEME);\n    }\n\n    @Test\n    public void testAccountManagerCallbackMissingAuthCredsErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_MISSING_AUTH_CREDENTIALS,\n                NetError.ERR_MISSING_AUTH_CREDENTIALS);\n    }\n\n    @Test\n    public void testAccountManagerCallbackUndocSecLibErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(HttpNegotiateConstants.ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS,\n                NetError.ERR_UNDOCUMENTED_SECURITY_LIBRARY_STATUS);\n    }\n\n    @Test\n    public void testAccountManagerCallbackMalformedIdentityErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        checkErrorReturn(\n                HttpNegotiateConstants.ERR_MALFORMED_IDENTITY, NetError.ERR_MALFORMED_IDENTITY);\n    }\n\n    @Test\n    public void testAccountManagerCallbackInvalidErrorReturns() {\n        Robolectric.buildActivity(Activity.class).create().start().resume().visible();\n        // 9999 is not a valid return value\n        checkErrorReturn(9999, NetError.ERR_UNEXPECTED);\n    }\n\n    private void checkErrorReturn(Integer spnegoError, int expectedError) {\n        HttpNegotiateAuthenticator authenticator = createWithoutNative(\"Dummy_Account\");\n\n        // Call getNextAuthToken to get the callback\n        authenticator.getNextAuthToken(1234, \"test_principal\", \"\", true);\n        verify(sMockAccountManager).getAuthTokenByFeatures(\n                anyString(),\n                anyString(),\n                any(String[].class),\n                any(Activity.class),\n                any(Bundle.class),\n                any(Bundle.class),\n                mBundleCallbackCaptor.capture(),\n                any(Handler.class));\n\n        Bundle resultBundle = new Bundle();\n        if (spnegoError != null) {\n            resultBundle.putInt(HttpNegotiateConstants.KEY_SPNEGO_RESULT, spnegoError);\n        }\n        mBundleCallbackCaptor.getValue().run(makeFuture(resultBundle));\n        verify(authenticator).nativeSetResult(anyLong(), eq(expectedError), anyString());\n    }\n\n    /**\n     * Returns a future that successfully returns the provided result.\n     * Hides mocking related annoyances: compiler warnings and irrelevant catch clauses.\n     */\n    private <T> AccountManagerFuture<T> makeFuture(T result) {\n        // Avoid warning when creating mock accountManagerFuture, can't take .class of an\n        // instantiated generic type, yet compiler complains if I leave it uninstantiated.\n        @SuppressWarnings(\"unchecked\")\n        AccountManagerFuture<T> accountManagerFuture = mock(AccountManagerFuture.class);\n        try {\n            when(accountManagerFuture.getResult()).thenReturn(result);\n        } catch (OperationCanceledException | AuthenticatorException | IOException e) {\n            // Can never happen - artifact of Mockito.\n            fail();\n        }\n        return accountManagerFuture;\n    }\n\n    /**\n     * Returns a future that fails with the provided exception when trying to get its result.\n     * Hides mocking related annoyances: compiler warnings and irrelevant catch clauses.\n     */\n    private <T> AccountManagerFuture<T> makeFuture(Exception ex) {\n        // Avoid warning when creating mock accountManagerFuture, can't take .class of an\n        // instantiated generic type, yet compiler complains if I leave it uninstantiated.\n        @SuppressWarnings(\"unchecked\")\n        AccountManagerFuture<T> accountManagerFuture = mock(AccountManagerFuture.class);\n        try {\n            when(accountManagerFuture.getResult()).thenThrow(ex);\n        } catch (OperationCanceledException | AuthenticatorException | IOException e) {\n            // Can never happen - artifact of Mockito.\n            fail();\n        }\n        return accountManagerFuture;\n    }\n\n    /**\n     * Returns a new authenticator as a spy so that we can override and intercept the native method\n     * calls.\n     */\n    private HttpNegotiateAuthenticator createWithoutNative(String accountType) {\n        HttpNegotiateAuthenticator authenticator =\n                spy(HttpNegotiateAuthenticator.create(accountType));\n        doNothing().when(authenticator).nativeSetResult(anyLong(), anyInt(), anyString());\n        doReturn(false)\n                .when(authenticator)\n                .lacksPermission(any(Context.class), anyString(), anyBoolean());\n        return authenticator;\n    }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.cognitiveservices.search.videosearch.models;\n\nimport java.util.List;\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * The TrendingVideosSubcategory model.\n */\npublic class TrendingVideosSubcategory {\n    /**\n     * The title property.\n     */\n    @JsonProperty(value = \"title\", required = true)\n    private String title;\n\n    /**\n     * The tiles property.\n     */\n    @JsonProperty(value = \"tiles\", required = true)\n    private List<TrendingVideosTile> tiles;\n\n    /**\n     * Get the title value.\n     *\n     * @return the title value\n     */\n    public String title() {\n        return this.title;\n    }\n\n    /**\n     * Set the title value.\n     *\n     * @param title the title value to set\n     * @return the TrendingVideosSubcategory object itself.\n     */\n    public TrendingVideosSubcategory withTitle(String title) {\n        this.title = title;\n        return this;\n    }\n\n    /**\n     * Get the tiles value.\n     *\n     * @return the tiles value\n     */\n    public List<TrendingVideosTile> tiles() {\n        return this.tiles;\n    }\n\n    /**\n     * Set the tiles value.\n     *\n     * @param tiles the tiles value to set\n     * @return the TrendingVideosSubcategory object itself.\n     */\n    public TrendingVideosSubcategory withTiles(List<TrendingVideosTile> tiles) {\n        this.tiles = tiles;\n        return this;\n    }\n\n}\n", ".View;\nimport android.widget.TextView;\n\nimport com.example.tanut.mapsearch.R;\nimport com.google.android.gms.maps.GoogleMap;\nimport com.google.android.gms.maps.model.Marker;\n\n/**\n * Created by rishi on 10/22/2017.\n */\n\npublic class CustomInfoViewAdapter implements GoogleMap.InfoWindowAdapter {\n\n    private final LayoutInflater mInflater;\n\n    public CustomInfoViewAdapter(LayoutInflater inflater) {\n        this.mInflater = inflater;\n    }\n\n    @Override\n    public View getInfoWindow(Marker marker) {\n        return null;\n    }\n\n    @Override\n    public View getInfoContents(Marker marker) {\n        final View popup = mInflater.inflate(R.layout.info_window_layout, null);\n\n        ((TextView) popup.findViewById(R.id.NameTv)).setText(marker.getTitle());\n\n        ((TextView) popup.findViewById(R.id.locationGeo)).setText(marker.getPosition().toString());\n\n        ((TextView) popup.findViewById(R.id.locationAdd)).setText(marker.getSnippet());\n\n        return popup;\n    }\n}\n", "util.Map.Entry;\nimport javax.annotation.PostConstruct;\nimport javax.enterprise.context.RequestScoped;\nimport javax.inject.Named;\nimport org.omnifaces.util.Faces;\n\n@Named\n@RequestScoped\npublic class RequestBean {\n    \n    private List<RequestHeader> headers;\n    private List<SessionEntry> sessionEntries;\n    \n    private String key;\n    private String value;\n    \n    @PostConstruct\n    public void initialize() {\n        headers = new ArrayList<RequestHeader>();\n        for (Entry<String,String> e : Faces.getRequestHeaderMap().entrySet()) {\n            RequestHeader header = new RequestHeader(e.getKey(), e.getValue());\n            headers.add(header);\n        }\n        \n        sessionEntries = new ArrayList<SessionEntry>();\n        for (Entry<String, Object> e : Faces.getSessionMap().entrySet()) {\n            SessionEntry se = new SessionEntry(e.getKey(), e.getValue());\n            sessionEntries.add(se);\n        }\n    }\n    \n    public String save() {\n        Faces.setSessionAttribute(key, value);\n        return Faces.getViewId() + \"?faces-redirect=true\";\n    } \n    \n    public List<RequestHeader> getRequestHeader() {\n        return headers;\n    }\n    \n    public List<SessionEntry> getSessionEntry() {\n        return sessionEntries;\n    }\n\n    public String getKey() {\n        return key;\n    }\n\n    public void setKey(String key) {\n        this.key = key;\n    }\n\n    public String getValue() {\n        return value;\n    }\n\n    public void setValue(String value) {\n        this.value = value;\n    }\n    \n}\n", "ic android.os.Build.VERSION_CODES.N_MR1;\nimport static android.os.Build.VERSION_CODES.O;\nimport static android.os.Build.VERSION_CODES.O_MR1;\nimport static android.os.Build.VERSION_CODES.P;\nimport static org.robolectric.RuntimeEnvironment.getApiLevel;\n\nimport android.annotation.SuppressLint;\nimport android.content.res.AssetManager;\nimport android.graphics.FontFamily;\nimport android.graphics.Typeface;\nimport android.util.ArrayMap;\nimport java.io.File;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport org.robolectric.annotation.HiddenApi;\nimport org.robolectric.annotation.Implementation;\nimport org.robolectric.annotation.Implements;\nimport org.robolectric.annotation.RealObject;\nimport org.robolectric.annotation.Resetter;\nimport org.robolectric.res.FsFile;\nimport org.robolectric.shadow.api.Shadow;\nimport org.robolectric.util.ReflectionHelpers;\nimport org.robolectric.util.ReflectionHelpers.ClassParameter;\n\n@Implements(value = Typeface.class, looseSignatures = true)\n@SuppressLint(\"NewApi\")\npublic class ShadowTypeface {\n  private static Map<Long, FontDesc> FONTS = new HashMap<>();\n  private static long nextFontId = 1;\n  private FontDesc description;\n  @RealObject private Typeface realTypeface;\n\n  @HiddenApi\n  @Implementation\n  protected void __constructor__(int fontId) {\n    description = findById((long) fontId);\n  }\n\n  @HiddenApi\n  @Implementation\n  protected void __constructor__(long fontId) {\n    description = findById(fontId);\n  }\n\n  @Implementation\n  protected static Typeface create(String familyName, int style) {\n    return createUnderlyingTypeface(familyName, style);\n  }\n\n  @Implementation\n  protected static Typeface create(Typeface family, int style) {\n    if (family == null) {\n      return createUnderlyingTypeface(null, style);\n    } else {\n      ShadowTypeface shadowTypeface = Shadow.extract(family);\n      return createUnderlyingTypeface(shadowTypeface.getFontDescription().getFamilyName(), style);\n    }\n  }\n\n  @Implementation\n  protected static Typeface createFromAsset(AssetManager mgr, String path) {\n    ShadowAssetManager shadowAssetManager = Shadow.extract(mgr);\n    Collection<FsFile> assetDirs = shadowAssetManager.getAllAssetDirs();\n    for (FsFile assetDir : assetDirs) {\n      FsFile[] files = assetDir.listFiles(new StartsWith(path));\n      FsFile assetFile = assetDir.join(path);\n      if (assetFile.exists() || files.length != 0) {\n        return createUnderlyingTypeface(path, Typeface.NORMAL);\n      }\n    }\n\n    throw new RuntimeException(\"Font asset not found \" + path);\n  }\n\n  @Implementation(minSdk = O)\n  protected static Typeface createFromResources(AssetManager mgr, String path, int cookie) {\n    return createUnderlyingTypeface(path, Typeface.NORMAL);\n  }\n\n  @Implementation\n  protected static Typeface createFromFile(File path) {\n    String familyName = path.toPath().getFileName().toString();\n    return createUnderlyingTypeface(familyName, Typeface.NORMAL);\n  }\n\n  @Implementation\n  protected static Typeface createFromFile(String path) {\n    return createFromFile(new File(path));\n  }\n\n  @Implementation\n  protected int getStyle() {\n    return description.getStyle();\n  }\n\n  @HiddenApi\n  @Implementation(minSdk = LOLLIPOP)\n  protected static Typeface createFromFamilies(Object /*FontFamily[]*/ families) {\n    return null;\n  }\n\n  @HiddenApi\n  @Implementation(minSdk = LOLLIPOP, maxSdk = N_MR1)\n  protected static Typeface createFromFamiliesWithDefault(Object /*FontFamily[]*/ families) {\n    return null;\n  }\n\n  @Implementation(minSdk = O, maxSdk = O_MR1)\n  protected static Typeface createFromFamiliesWithDefault(\n      Object /*FontFamily[]*/ families, Object /* int */ weight, Object /* int */ italic) {\n    return createUnderlyingTypeface(\"fake-font\", Typeface.NORMAL);\n  }\n\n  @Implementation(minSdk = P)\n  protected static Typeface createFromFamiliesWithDefault(\n      Object /*FontFamily[]*/ families,\n      Object /* String */ fallbackName,\n      Object /* int */ weight,\n      Object /* int */ italic) {\n    return createUnderlyingTypeface((String) fallbackName, Typeface.NORMAL);\n  }\n\n  @Implementation(minSdk = P)\n  protected static void buildSystemFallback(String xmlPath, String fontDir,\n      ArrayMap<String, Typeface> fontMap, ArrayMap<String, FontFamily[]> fallbackMap) {\n    fontMap.put(\"sans-serif\", createUnderlyingTypeface(\"sans-serif\", 0));\n  }\n\n\n  @Resetter\n  synchronized public static void reset() {\n    FONTS.clear();\n  }\n\n  private static Typeface createUnderlyingTypeface(String familyName, int style) {\n    long thisFontId = nextFontId++;\n    FONTS.put(thisFontId, new FontDesc(familyName, style));\n    if (getApiLevel() >= LOLLIPOP) {\n      return ReflectionHelpers.callConstructor(Typeface.class, ClassParameter.from(long.class, thisFontId));\n    } else {\n      return ReflectionHelpers.callConstructor(Typeface.class, ClassParameter.from(int.class, (int) thisFontId));\n    }\n  }\n\n  private synchronized static FontDesc findById(long fontId) {\n    if (FONTS.containsKey(fontId)) {\n      return FONTS.get(fontId);\n    }\n    throw new RuntimeException(\"Unknown font id: \" + fontId);\n  }\n\n  /**\n   * Returns the font description.\n   *\n   * @return Font description.\n   */\n  public FontDesc getFontDescription() {\n    return description;\n  }\n\n  public static class FontDesc {\n    public final String familyName;\n    public final int style;\n\n    public FontDesc(String familyName, int style) {\n      this.familyName = familyName;\n      this.style = style;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n      if (this == o) return true;\n      if (o == null || getClass() != o.getClass()) return false;\n\n      FontDesc fontDesc = (FontDesc) o;\n\n      if (style != fontDesc.style) return false;\n      if (familyName != null ? !familyName.equals(fontDesc.familyName) : fontDesc.familyName != null)\n        return false;\n\n      return true;\n    }\n\n    @Override\n    public int hashCode() {\n      int result = familyName != null ? familyName.hashCode() : 0;\n      result = 31 * result + style;\n      return result;\n    }\n\n    public String getFamilyName() {\n      return familyName;\n    }\n\n    public int getStyle() {\n      return style;\n    }\n  }\n\n  private static class StartsWith implements FsFile.Filter {\n    private final String contains;\n\n    public StartsWith(String contains) {\n      this.contains = contains;\n    }\n\n    @Override\n    public boolean accept(FsFile file) {\n      return file.getName().startsWith(contains);\n    }\n  }\n}\n", "idation.Valid;\n\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.security.core.userdetails.User;\nimport org.springframework.stereotype.Controller;\nimport org.springframework.validation.BindingResult;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.servlet.ModelAndView;\nimport org.springframework.web.servlet.mvc.support.RedirectAttributes;\n\nimport br.edu.ufcg.computacao.si1.model.Anuncio;\nimport br.edu.ufcg.computacao.si1.model.Usuario;\nimport br.edu.ufcg.computacao.si1.model.form.AnuncioForm;\n\n@Controller\n@RequestMapping(value = \"/user\")\npublic class UserAnuncioController extends AnuncioAbstractController {\n\n  @Override\n  @RequestMapping(value = \"/cadastrar/anuncio\", method = RequestMethod.GET)\n  public ModelAndView getPageCadastrarAnuncio(AnuncioForm anuncioForm) {\n    ModelAndView model = new ModelAndView();\n\n    model.addObject(\"tipos\", anuncioForm.getTipos());\n    model.setViewName(\"user/cadastrar_anuncio\");\n\n    return model;\n  }\n\n  @Override\n  @RequestMapping(value = \"/cadastrar/anuncio\", method = RequestMethod.POST)\n  public ModelAndView cadastroAnuncio(@Valid AnuncioForm anuncioForm, BindingResult result,\n      RedirectAttributes attributes) {\n    if (result.hasErrors()) {\n      return getPageCadastrarAnuncio(anuncioForm);\n    }\n\n    Anuncio anuncio = new Anuncio();\n    anuncio.setTitulo(anuncioForm.getTitulo());\n    anuncio.setPreco(anuncioForm.getPreco());\n    anuncio.setTipo(anuncioForm.getTipo());\n    anuncio.setCategoria(anuncioForm.getCategoria());\n    \n    User springUser =  (User) SecurityContextHolder.getContext().getAuthentication().getPrincipal();\n    Optional<Usuario> criador = usuarioService.getByEmail(springUser.getUsername());\n    anuncio.setCriador(criador.get());\n    \n    anuncioService.create(anuncio);\n\n    attributes.addFlashAttribute(\"mensagem\", \"An\u00fancio cadastrado com sucesso!\");\n    return new ModelAndView(\"redirect:/user/cadastrar/anuncio\");\n  }\n\n  // @RequestMapping(value = \"/saldos\", method = RequestMethod.GET)\n  // public ModelAndView getPageListarSaldos() {\n  // ModelAndView model = new ModelAndView();\n  //\n  // model.setViewName(\"sharedProfile/listar_saldos\");\n  // model.addObject(\"saldos\", \"Em Constru\u00e7\u00e3o\");\n  //\n  // return model;\n  // }\n\n}\n", "\npackage POGOProtos.Map;\n\npublic final class MapCellOuterClass {\n  private MapCellOuterClass() {}\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistryLite registry) {\n  }\n\n  public static void registerAllExtensions(\n      com.google.protobuf.ExtensionRegistry registry) {\n    registerAllExtensions(\n        (com.google.protobuf.ExtensionRegistryLite) registry);\n  }\n  public interface MapCellOrBuilder extends\n      // @@protoc_insertion_point(interface_extends:POGOProtos.Map.MapCell)\n      com.google.protobuf.MessageOrBuilder {\n\n    /**\n     * <pre>\n     * S2 geographic area that the cell covers (http://s2map.com/) (https://code.google.com/archive/p/s2-geometry-library/)\n     * </pre>\n     *\n     * <code>optional uint64 s2_cell_id = 1;</code>\n     */\n    long getS2CellId();\n\n    /**\n     * <code>optional int64 current_timestamp_ms = 2;</code>\n     */\n    long getCurrentTimestampMs();\n\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    java.util.List<POGOProtos.Map.Fort.FortDataOuterClass.FortData> \n        getFortsList();\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    POGOProtos.Map.Fort.FortDataOuterClass.FortData getForts(int index);\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    int getFortsCount();\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder> \n        getFortsOrBuilderList();\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder getFortsOrBuilder(\n        int index);\n\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> \n        getSpawnPointsList();\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    POGOProtos.Map.SpawnPointOuterClass.SpawnPoint getSpawnPoints(int index);\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    int getSpawnPointsCount();\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n        getSpawnPointsOrBuilderList();\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder getSpawnPointsOrBuilder(\n        int index);\n\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    java.util.List<java.lang.String>\n        getDeletedObjectsList();\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    int getDeletedObjectsCount();\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    java.lang.String getDeletedObjects(int index);\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    com.google.protobuf.ByteString\n        getDeletedObjectsBytes(int index);\n\n    /**\n     * <code>optional bool is_truncated_list = 7;</code>\n     */\n    boolean getIsTruncatedList();\n\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    java.util.List<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary> \n        getFortSummariesList();\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary getFortSummaries(int index);\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    int getFortSummariesCount();\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder> \n        getFortSummariesOrBuilderList();\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder getFortSummariesOrBuilder(\n        int index);\n\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> \n        getDecimatedSpawnPointsList();\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    POGOProtos.Map.SpawnPointOuterClass.SpawnPoint getDecimatedSpawnPoints(int index);\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    int getDecimatedSpawnPointsCount();\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n        getDecimatedSpawnPointsOrBuilderList();\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder getDecimatedSpawnPointsOrBuilder(\n        int index);\n\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    java.util.List<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon> \n        getWildPokemonsList();\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon getWildPokemons(int index);\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    int getWildPokemonsCount();\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder> \n        getWildPokemonsOrBuilderList();\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder getWildPokemonsOrBuilder(\n        int index);\n\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    java.util.List<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon> \n        getCatchablePokemonsList();\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon getCatchablePokemons(int index);\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    int getCatchablePokemonsCount();\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder> \n        getCatchablePokemonsOrBuilderList();\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder getCatchablePokemonsOrBuilder(\n        int index);\n\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    java.util.List<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon> \n        getNearbyPokemonsList();\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon getNearbyPokemons(int index);\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    int getNearbyPokemonsCount();\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    java.util.List<? extends POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder> \n        getNearbyPokemonsOrBuilderList();\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder getNearbyPokemonsOrBuilder(\n        int index);\n  }\n  /**\n   * <pre>\n   * A cell is a geographical \"zone\" containing objects like pokemon, gyms, and pokestops.\n   * </pre>\n   *\n   * Protobuf type {@code POGOProtos.Map.MapCell}\n   */\n  public  static final class MapCell extends\n      com.google.protobuf.GeneratedMessageV3 implements\n      // @@protoc_insertion_point(message_implements:POGOProtos.Map.MapCell)\n      MapCellOrBuilder {\n    // Use MapCell.newBuilder() to construct.\n    private MapCell(com.google.protobuf.GeneratedMessageV3.Builder<?> builder) {\n      super(builder);\n    }\n    private MapCell() {\n      s2CellId_ = 0L;\n      currentTimestampMs_ = 0L;\n      forts_ = java.util.Collections.emptyList();\n      spawnPoints_ = java.util.Collections.emptyList();\n      deletedObjects_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n      isTruncatedList_ = false;\n      fortSummaries_ = java.util.Collections.emptyList();\n      decimatedSpawnPoints_ = java.util.Collections.emptyList();\n      wildPokemons_ = java.util.Collections.emptyList();\n      catchablePokemons_ = java.util.Collections.emptyList();\n      nearbyPokemons_ = java.util.Collections.emptyList();\n    }\n\n    @java.lang.Override\n    public final com.google.protobuf.UnknownFieldSet\n    getUnknownFields() {\n      return com.google.protobuf.UnknownFieldSet.getDefaultInstance();\n    }\n    private MapCell(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      this();\n      int mutable_bitField0_ = 0;\n      try {\n        boolean done = false;\n        while (!done) {\n          int tag = input.readTag();\n          switch (tag) {\n            case 0:\n              done = true;\n              break;\n            default: {\n              if (!input.skipField(tag)) {\n                done = true;\n              }\n              break;\n            }\n            case 8: {\n\n              s2CellId_ = input.readUInt64();\n              break;\n            }\n            case 16: {\n\n              currentTimestampMs_ = input.readInt64();\n              break;\n            }\n            case 26: {\n              if (!((mutable_bitField0_ & 0x00000004) == 0x00000004)) {\n                forts_ = new java.util.ArrayList<POGOProtos.Map.Fort.FortDataOuterClass.FortData>();\n                mutable_bitField0_ |= 0x00000004;\n              }\n              forts_.add(\n                  input.readMessage(POGOProtos.Map.Fort.FortDataOuterClass.FortData.parser(), extensionRegistry));\n              break;\n            }\n            case 34: {\n              if (!((mutable_bitField0_ & 0x00000008) == 0x00000008)) {\n                spawnPoints_ = new java.util.ArrayList<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint>();\n                mutable_bitField0_ |= 0x00000008;\n              }\n              spawnPoints_.add(\n                  input.readMessage(POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.parser(), extensionRegistry));\n              break;\n            }\n            case 42: {\n              if (!((mutable_bitField0_ & 0x00000100) == 0x00000100)) {\n                wildPokemons_ = new java.util.ArrayList<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon>();\n                mutable_bitField0_ |= 0x00000100;\n              }\n              wildPokemons_.add(\n                  input.readMessage(POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.parser(), extensionRegistry));\n              break;\n            }\n            case 50: {\n              java.lang.String s = input.readStringRequireUtf8();\n              if (!((mutable_bitField0_ & 0x00000010) == 0x00000010)) {\n                deletedObjects_ = new com.google.protobuf.LazyStringArrayList();\n                mutable_bitField0_ |= 0x00000010;\n              }\n              deletedObjects_.add(s);\n              break;\n            }\n            case 56: {\n\n              isTruncatedList_ = input.readBool();\n              break;\n            }\n            case 66: {\n              if (!((mutable_bitField0_ & 0x00000040) == 0x00000040)) {\n                fortSummaries_ = new java.util.ArrayList<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary>();\n                mutable_bitField0_ |= 0x00000040;\n              }\n              fortSummaries_.add(\n                  input.readMessage(POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.parser(), extensionRegistry));\n              break;\n            }\n            case 74: {\n              if (!((mutable_bitField0_ & 0x00000080) == 0x00000080)) {\n                decimatedSpawnPoints_ = new java.util.ArrayList<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint>();\n                mutable_bitField0_ |= 0x00000080;\n              }\n              decimatedSpawnPoints_.add(\n                  input.readMessage(POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.parser(), extensionRegistry));\n              break;\n            }\n            case 82: {\n              if (!((mutable_bitField0_ & 0x00000200) == 0x00000200)) {\n                catchablePokemons_ = new java.util.ArrayList<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon>();\n                mutable_bitField0_ |= 0x00000200;\n              }\n              catchablePokemons_.add(\n                  input.readMessage(POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.parser(), extensionRegistry));\n              break;\n            }\n            case 90: {\n              if (!((mutable_bitField0_ & 0x00000400) == 0x00000400)) {\n                nearbyPokemons_ = new java.util.ArrayList<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon>();\n                mutable_bitField0_ |= 0x00000400;\n              }\n              nearbyPokemons_.add(\n                  input.readMessage(POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.parser(), extensionRegistry));\n              break;\n            }\n          }\n        }\n      } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n        throw e.setUnfinishedMessage(this);\n      } catch (java.io.IOException e) {\n        throw new com.google.protobuf.InvalidProtocolBufferException(\n            e).setUnfinishedMessage(this);\n      } finally {\n        if (((mutable_bitField0_ & 0x00000004) == 0x00000004)) {\n          forts_ = java.util.Collections.unmodifiableList(forts_);\n        }\n        if (((mutable_bitField0_ & 0x00000008) == 0x00000008)) {\n          spawnPoints_ = java.util.Collections.unmodifiableList(spawnPoints_);\n        }\n        if (((mutable_bitField0_ & 0x00000100) == 0x00000100)) {\n          wildPokemons_ = java.util.Collections.unmodifiableList(wildPokemons_);\n        }\n        if (((mutable_bitField0_ & 0x00000010) == 0x00000010)) {\n          deletedObjects_ = deletedObjects_.getUnmodifiableView();\n        }\n        if (((mutable_bitField0_ & 0x00000040) == 0x00000040)) {\n          fortSummaries_ = java.util.Collections.unmodifiableList(fortSummaries_);\n        }\n        if (((mutable_bitField0_ & 0x00000080) == 0x00000080)) {\n          decimatedSpawnPoints_ = java.util.Collections.unmodifiableList(decimatedSpawnPoints_);\n        }\n        if (((mutable_bitField0_ & 0x00000200) == 0x00000200)) {\n          catchablePokemons_ = java.util.Collections.unmodifiableList(catchablePokemons_);\n        }\n        if (((mutable_bitField0_ & 0x00000400) == 0x00000400)) {\n          nearbyPokemons_ = java.util.Collections.unmodifiableList(nearbyPokemons_);\n        }\n        makeExtensionsImmutable();\n      }\n    }\n    public static final com.google.protobuf.Descriptors.Descriptor\n        getDescriptor() {\n      return POGOProtos.Map.MapCellOuterClass.internal_static_POGOProtos_Map_MapCell_descriptor;\n    }\n\n    protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n        internalGetFieldAccessorTable() {\n      return POGOProtos.Map.MapCellOuterClass.internal_static_POGOProtos_Map_MapCell_fieldAccessorTable\n          .ensureFieldAccessorsInitialized(\n              POGOProtos.Map.MapCellOuterClass.MapCell.class, POGOProtos.Map.MapCellOuterClass.MapCell.Builder.class);\n    }\n\n    private int bitField0_;\n    public static final int S2_CELL_ID_FIELD_NUMBER = 1;\n    private long s2CellId_;\n    /**\n     * <pre>\n     * S2 geographic area that the cell covers (http://s2map.com/) (https://code.google.com/archive/p/s2-geometry-library/)\n     * </pre>\n     *\n     * <code>optional uint64 s2_cell_id = 1;</code>\n     */\n    public long getS2CellId() {\n      return s2CellId_;\n    }\n\n    public static final int CURRENT_TIMESTAMP_MS_FIELD_NUMBER = 2;\n    private long currentTimestampMs_;\n    /**\n     * <code>optional int64 current_timestamp_ms = 2;</code>\n     */\n    public long getCurrentTimestampMs() {\n      return currentTimestampMs_;\n    }\n\n    public static final int FORTS_FIELD_NUMBER = 3;\n    private java.util.List<POGOProtos.Map.Fort.FortDataOuterClass.FortData> forts_;\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    public java.util.List<POGOProtos.Map.Fort.FortDataOuterClass.FortData> getFortsList() {\n      return forts_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder> \n        getFortsOrBuilderList() {\n      return forts_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    public int getFortsCount() {\n      return forts_.size();\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    public POGOProtos.Map.Fort.FortDataOuterClass.FortData getForts(int index) {\n      return forts_.get(index);\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n     */\n    public POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder getFortsOrBuilder(\n        int index) {\n      return forts_.get(index);\n    }\n\n    public static final int SPAWN_POINTS_FIELD_NUMBER = 4;\n    private java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> spawnPoints_;\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    public java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> getSpawnPointsList() {\n      return spawnPoints_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n        getSpawnPointsOrBuilderList() {\n      return spawnPoints_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    public int getSpawnPointsCount() {\n      return spawnPoints_.size();\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint getSpawnPoints(int index) {\n      return spawnPoints_.get(index);\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n     */\n    public POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder getSpawnPointsOrBuilder(\n        int index) {\n      return spawnPoints_.get(index);\n    }\n\n    public static final int DELETED_OBJECTS_FIELD_NUMBER = 6;\n    private com.google.protobuf.LazyStringList deletedObjects_;\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    public com.google.protobuf.ProtocolStringList\n        getDeletedObjectsList() {\n      return deletedObjects_;\n    }\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    public int getDeletedObjectsCount() {\n      return deletedObjects_.size();\n    }\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    public java.lang.String getDeletedObjects(int index) {\n      return deletedObjects_.get(index);\n    }\n    /**\n     * <code>repeated string deleted_objects = 6;</code>\n     */\n    public com.google.protobuf.ByteString\n        getDeletedObjectsBytes(int index) {\n      return deletedObjects_.getByteString(index);\n    }\n\n    public static final int IS_TRUNCATED_LIST_FIELD_NUMBER = 7;\n    private boolean isTruncatedList_;\n    /**\n     * <code>optional bool is_truncated_list = 7;</code>\n     */\n    public boolean getIsTruncatedList() {\n      return isTruncatedList_;\n    }\n\n    public static final int FORT_SUMMARIES_FIELD_NUMBER = 8;\n    private java.util.List<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary> fortSummaries_;\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    public java.util.List<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary> getFortSummariesList() {\n      return fortSummaries_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder> \n        getFortSummariesOrBuilderList() {\n      return fortSummaries_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    public int getFortSummariesCount() {\n      return fortSummaries_.size();\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary getFortSummaries(int index) {\n      return fortSummaries_.get(index);\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n     */\n    public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder getFortSummariesOrBuilder(\n        int index) {\n      return fortSummaries_.get(index);\n    }\n\n    public static final int DECIMATED_SPAWN_POINTS_FIELD_NUMBER = 9;\n    private java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> decimatedSpawnPoints_;\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    public java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> getDecimatedSpawnPointsList() {\n      return decimatedSpawnPoints_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n        getDecimatedSpawnPointsOrBuilderList() {\n      return decimatedSpawnPoints_;\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    public int getDecimatedSpawnPointsCount() {\n      return decimatedSpawnPoints_.size();\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint getDecimatedSpawnPoints(int index) {\n      return decimatedSpawnPoints_.get(index);\n    }\n    /**\n     * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n     */\n    public POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder getDecimatedSpawnPointsOrBuilder(\n        int index) {\n      return decimatedSpawnPoints_.get(index);\n    }\n\n    public static final int WILD_POKEMONS_FIELD_NUMBER = 5;\n    private java.util.List<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon> wildPokemons_;\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    public java.util.List<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon> getWildPokemonsList() {\n      return wildPokemons_;\n    }\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder> \n        getWildPokemonsOrBuilderList() {\n      return wildPokemons_;\n    }\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    public int getWildPokemonsCount() {\n      return wildPokemons_.size();\n    }\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon getWildPokemons(int index) {\n      return wildPokemons_.get(index);\n    }\n    /**\n     * <pre>\n     * Pokemon within 2 steps or less.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n     */\n    public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder getWildPokemonsOrBuilder(\n        int index) {\n      return wildPokemons_.get(index);\n    }\n\n    public static final int CATCHABLE_POKEMONS_FIELD_NUMBER = 10;\n    private java.util.List<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon> catchablePokemons_;\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    public java.util.List<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon> getCatchablePokemonsList() {\n      return catchablePokemons_;\n    }\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder> \n        getCatchablePokemonsOrBuilderList() {\n      return catchablePokemons_;\n    }\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    public int getCatchablePokemonsCount() {\n      return catchablePokemons_.size();\n    }\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon getCatchablePokemons(int index) {\n      return catchablePokemons_.get(index);\n    }\n    /**\n     * <pre>\n     * Pokemon within 1 step or none.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n     */\n    public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder getCatchablePokemonsOrBuilder(\n        int index) {\n      return catchablePokemons_.get(index);\n    }\n\n    public static final int NEARBY_POKEMONS_FIELD_NUMBER = 11;\n    private java.util.List<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon> nearbyPokemons_;\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    public java.util.List<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon> getNearbyPokemonsList() {\n      return nearbyPokemons_;\n    }\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    public java.util.List<? extends POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder> \n        getNearbyPokemonsOrBuilderList() {\n      return nearbyPokemons_;\n    }\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    public int getNearbyPokemonsCount() {\n      return nearbyPokemons_.size();\n    }\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon getNearbyPokemons(int index) {\n      return nearbyPokemons_.get(index);\n    }\n    /**\n     * <pre>\n     * Pokemon farther away than 2 steps, but still in the area.\n     * </pre>\n     *\n     * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n     */\n    public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder getNearbyPokemonsOrBuilder(\n        int index) {\n      return nearbyPokemons_.get(index);\n    }\n\n    private byte memoizedIsInitialized = -1;\n    public final boolean isInitialized() {\n      byte isInitialized = memoizedIsInitialized;\n      if (isInitialized == 1) return true;\n      if (isInitialized == 0) return false;\n\n      memoizedIsInitialized = 1;\n      return true;\n    }\n\n    public void writeTo(com.google.protobuf.CodedOutputStream output)\n                        throws java.io.IOException {\n      if (s2CellId_ != 0L) {\n        output.writeUInt64(1, s2CellId_);\n      }\n      if (currentTimestampMs_ != 0L) {\n        output.writeInt64(2, currentTimestampMs_);\n      }\n      for (int i = 0; i < forts_.size(); i++) {\n        output.writeMessage(3, forts_.get(i));\n      }\n      for (int i = 0; i < spawnPoints_.size(); i++) {\n        output.writeMessage(4, spawnPoints_.get(i));\n      }\n      for (int i = 0; i < wildPokemons_.size(); i++) {\n        output.writeMessage(5, wildPokemons_.get(i));\n      }\n      for (int i = 0; i < deletedObjects_.size(); i++) {\n        com.google.protobuf.GeneratedMessageV3.writeString(output, 6, deletedObjects_.getRaw(i));\n      }\n      if (isTruncatedList_ != false) {\n        output.writeBool(7, isTruncatedList_);\n      }\n      for (int i = 0; i < fortSummaries_.size(); i++) {\n        output.writeMessage(8, fortSummaries_.get(i));\n      }\n      for (int i = 0; i < decimatedSpawnPoints_.size(); i++) {\n        output.writeMessage(9, decimatedSpawnPoints_.get(i));\n      }\n      for (int i = 0; i < catchablePokemons_.size(); i++) {\n        output.writeMessage(10, catchablePokemons_.get(i));\n      }\n      for (int i = 0; i < nearbyPokemons_.size(); i++) {\n        output.writeMessage(11, nearbyPokemons_.get(i));\n      }\n    }\n\n    public int getSerializedSize() {\n      int size = memoizedSize;\n      if (size != -1) return size;\n\n      size = 0;\n      if (s2CellId_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeUInt64Size(1, s2CellId_);\n      }\n      if (currentTimestampMs_ != 0L) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeInt64Size(2, currentTimestampMs_);\n      }\n      for (int i = 0; i < forts_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(3, forts_.get(i));\n      }\n      for (int i = 0; i < spawnPoints_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(4, spawnPoints_.get(i));\n      }\n      for (int i = 0; i < wildPokemons_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(5, wildPokemons_.get(i));\n      }\n      {\n        int dataSize = 0;\n        for (int i = 0; i < deletedObjects_.size(); i++) {\n          dataSize += computeStringSizeNoTag(deletedObjects_.getRaw(i));\n        }\n        size += dataSize;\n        size += 1 * getDeletedObjectsList().size();\n      }\n      if (isTruncatedList_ != false) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeBoolSize(7, isTruncatedList_);\n      }\n      for (int i = 0; i < fortSummaries_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(8, fortSummaries_.get(i));\n      }\n      for (int i = 0; i < decimatedSpawnPoints_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(9, decimatedSpawnPoints_.get(i));\n      }\n      for (int i = 0; i < catchablePokemons_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(10, catchablePokemons_.get(i));\n      }\n      for (int i = 0; i < nearbyPokemons_.size(); i++) {\n        size += com.google.protobuf.CodedOutputStream\n          .computeMessageSize(11, nearbyPokemons_.get(i));\n      }\n      memoizedSize = size;\n      return size;\n    }\n\n    private static final long serialVersionUID = 0L;\n    @java.lang.Override\n    public boolean equals(final java.lang.Object obj) {\n      if (obj == this) {\n       return true;\n      }\n      if (!(obj instanceof POGOProtos.Map.MapCellOuterClass.MapCell)) {\n        return super.equals(obj);\n      }\n      POGOProtos.Map.MapCellOuterClass.MapCell other = (POGOProtos.Map.MapCellOuterClass.MapCell) obj;\n\n      boolean result = true;\n      result = result && (getS2CellId()\n          == other.getS2CellId());\n      result = result && (getCurrentTimestampMs()\n          == other.getCurrentTimestampMs());\n      result = result && getFortsList()\n          .equals(other.getFortsList());\n      result = result && getSpawnPointsList()\n          .equals(other.getSpawnPointsList());\n      result = result && getDeletedObjectsList()\n          .equals(other.getDeletedObjectsList());\n      result = result && (getIsTruncatedList()\n          == other.getIsTruncatedList());\n      result = result && getFortSummariesList()\n          .equals(other.getFortSummariesList());\n      result = result && getDecimatedSpawnPointsList()\n          .equals(other.getDecimatedSpawnPointsList());\n      result = result && getWildPokemonsList()\n          .equals(other.getWildPokemonsList());\n      result = result && getCatchablePokemonsList()\n          .equals(other.getCatchablePokemonsList());\n      result = result && getNearbyPokemonsList()\n          .equals(other.getNearbyPokemonsList());\n      return result;\n    }\n\n    @java.lang.Override\n    public int hashCode() {\n      if (memoizedHashCode != 0) {\n        return memoizedHashCode;\n      }\n      int hash = 41;\n      hash = (19 * hash) + getDescriptorForType().hashCode();\n      hash = (37 * hash) + S2_CELL_ID_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getS2CellId());\n      hash = (37 * hash) + CURRENT_TIMESTAMP_MS_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashLong(\n          getCurrentTimestampMs());\n      if (getFortsCount() > 0) {\n        hash = (37 * hash) + FORTS_FIELD_NUMBER;\n        hash = (53 * hash) + getFortsList().hashCode();\n      }\n      if (getSpawnPointsCount() > 0) {\n        hash = (37 * hash) + SPAWN_POINTS_FIELD_NUMBER;\n        hash = (53 * hash) + getSpawnPointsList().hashCode();\n      }\n      if (getDeletedObjectsCount() > 0) {\n        hash = (37 * hash) + DELETED_OBJECTS_FIELD_NUMBER;\n        hash = (53 * hash) + getDeletedObjectsList().hashCode();\n      }\n      hash = (37 * hash) + IS_TRUNCATED_LIST_FIELD_NUMBER;\n      hash = (53 * hash) + com.google.protobuf.Internal.hashBoolean(\n          getIsTruncatedList());\n      if (getFortSummariesCount() > 0) {\n        hash = (37 * hash) + FORT_SUMMARIES_FIELD_NUMBER;\n        hash = (53 * hash) + getFortSummariesList().hashCode();\n      }\n      if (getDecimatedSpawnPointsCount() > 0) {\n        hash = (37 * hash) + DECIMATED_SPAWN_POINTS_FIELD_NUMBER;\n        hash = (53 * hash) + getDecimatedSpawnPointsList().hashCode();\n      }\n      if (getWildPokemonsCount() > 0) {\n        hash = (37 * hash) + WILD_POKEMONS_FIELD_NUMBER;\n        hash = (53 * hash) + getWildPokemonsList().hashCode();\n      }\n      if (getCatchablePokemonsCount() > 0) {\n        hash = (37 * hash) + CATCHABLE_POKEMONS_FIELD_NUMBER;\n        hash = (53 * hash) + getCatchablePokemonsList().hashCode();\n      }\n      if (getNearbyPokemonsCount() > 0) {\n        hash = (37 * hash) + NEARBY_POKEMONS_FIELD_NUMBER;\n        hash = (53 * hash) + getNearbyPokemonsList().hashCode();\n      }\n      hash = (29 * hash) + unknownFields.hashCode();\n      memoizedHashCode = hash;\n      return hash;\n    }\n\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(\n        com.google.protobuf.ByteString data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(\n        com.google.protobuf.ByteString data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(byte[] data)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(\n        byte[] data,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws com.google.protobuf.InvalidProtocolBufferException {\n      return PARSER.parseFrom(data, extensionRegistry);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseDelimitedFrom(java.io.InputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseDelimitedFrom(\n        java.io.InputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseDelimitedWithIOException(PARSER, input, extensionRegistry);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(\n        com.google.protobuf.CodedInputStream input)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input);\n    }\n    public static POGOProtos.Map.MapCellOuterClass.MapCell parseFrom(\n        com.google.protobuf.CodedInputStream input,\n        com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n        throws java.io.IOException {\n      return com.google.protobuf.GeneratedMessageV3\n          .parseWithIOException(PARSER, input, extensionRegistry);\n    }\n\n    public Builder newBuilderForType() { return newBuilder(); }\n    public static Builder newBuilder() {\n      return DEFAULT_INSTANCE.toBuilder();\n    }\n    public static Builder newBuilder(POGOProtos.Map.MapCellOuterClass.MapCell prototype) {\n      return DEFAULT_INSTANCE.toBuilder().mergeFrom(prototype);\n    }\n    public Builder toBuilder() {\n      return this == DEFAULT_INSTANCE\n          ? new Builder() : new Builder().mergeFrom(this);\n    }\n\n    @java.lang.Override\n    protected Builder newBuilderForType(\n        com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n      Builder builder = new Builder(parent);\n      return builder;\n    }\n    /**\n     * <pre>\n     * A cell is a geographical \"zone\" containing objects like pokemon, gyms, and pokestops.\n     * </pre>\n     *\n     * Protobuf type {@code POGOProtos.Map.MapCell}\n     */\n    public static final class Builder extends\n        com.google.protobuf.GeneratedMessageV3.Builder<Builder> implements\n        // @@protoc_insertion_point(builder_implements:POGOProtos.Map.MapCell)\n        POGOProtos.Map.MapCellOuterClass.MapCellOrBuilder {\n      public static final com.google.protobuf.Descriptors.Descriptor\n          getDescriptor() {\n        return POGOProtos.Map.MapCellOuterClass.internal_static_POGOProtos_Map_MapCell_descriptor;\n      }\n\n      protected com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n          internalGetFieldAccessorTable() {\n        return POGOProtos.Map.MapCellOuterClass.internal_static_POGOProtos_Map_MapCell_fieldAccessorTable\n            .ensureFieldAccessorsInitialized(\n                POGOProtos.Map.MapCellOuterClass.MapCell.class, POGOProtos.Map.MapCellOuterClass.MapCell.Builder.class);\n      }\n\n      // Construct using POGOProtos.Map.MapCellOuterClass.MapCell.newBuilder()\n      private Builder() {\n        maybeForceBuilderInitialization();\n      }\n\n      private Builder(\n          com.google.protobuf.GeneratedMessageV3.BuilderParent parent) {\n        super(parent);\n        maybeForceBuilderInitialization();\n      }\n      private void maybeForceBuilderInitialization() {\n        if (com.google.protobuf.GeneratedMessageV3\n                .alwaysUseFieldBuilders) {\n          getFortsFieldBuilder();\n          getSpawnPointsFieldBuilder();\n          getFortSummariesFieldBuilder();\n          getDecimatedSpawnPointsFieldBuilder();\n          getWildPokemonsFieldBuilder();\n          getCatchablePokemonsFieldBuilder();\n          getNearbyPokemonsFieldBuilder();\n        }\n      }\n      public Builder clear() {\n        super.clear();\n        s2CellId_ = 0L;\n\n        currentTimestampMs_ = 0L;\n\n        if (fortsBuilder_ == null) {\n          forts_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000004);\n        } else {\n          fortsBuilder_.clear();\n        }\n        if (spawnPointsBuilder_ == null) {\n          spawnPoints_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000008);\n        } else {\n          spawnPointsBuilder_.clear();\n        }\n        deletedObjects_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n        bitField0_ = (bitField0_ & ~0x00000010);\n        isTruncatedList_ = false;\n\n        if (fortSummariesBuilder_ == null) {\n          fortSummaries_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000040);\n        } else {\n          fortSummariesBuilder_.clear();\n        }\n        if (decimatedSpawnPointsBuilder_ == null) {\n          decimatedSpawnPoints_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000080);\n        } else {\n          decimatedSpawnPointsBuilder_.clear();\n        }\n        if (wildPokemonsBuilder_ == null) {\n          wildPokemons_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000100);\n        } else {\n          wildPokemonsBuilder_.clear();\n        }\n        if (catchablePokemonsBuilder_ == null) {\n          catchablePokemons_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000200);\n        } else {\n          catchablePokemonsBuilder_.clear();\n        }\n        if (nearbyPokemonsBuilder_ == null) {\n          nearbyPokemons_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000400);\n        } else {\n          nearbyPokemonsBuilder_.clear();\n        }\n        return this;\n      }\n\n      public com.google.protobuf.Descriptors.Descriptor\n          getDescriptorForType() {\n        return POGOProtos.Map.MapCellOuterClass.internal_static_POGOProtos_Map_MapCell_descriptor;\n      }\n\n      public POGOProtos.Map.MapCellOuterClass.MapCell getDefaultInstanceForType() {\n        return POGOProtos.Map.MapCellOuterClass.MapCell.getDefaultInstance();\n      }\n\n      public POGOProtos.Map.MapCellOuterClass.MapCell build() {\n        POGOProtos.Map.MapCellOuterClass.MapCell result = buildPartial();\n        if (!result.isInitialized()) {\n          throw newUninitializedMessageException(result);\n        }\n        return result;\n      }\n\n      public POGOProtos.Map.MapCellOuterClass.MapCell buildPartial() {\n        POGOProtos.Map.MapCellOuterClass.MapCell result = new POGOProtos.Map.MapCellOuterClass.MapCell(this);\n        int from_bitField0_ = bitField0_;\n        int to_bitField0_ = 0;\n        result.s2CellId_ = s2CellId_;\n        result.currentTimestampMs_ = currentTimestampMs_;\n        if (fortsBuilder_ == null) {\n          if (((bitField0_ & 0x00000004) == 0x00000004)) {\n            forts_ = java.util.Collections.unmodifiableList(forts_);\n            bitField0_ = (bitField0_ & ~0x00000004);\n          }\n          result.forts_ = forts_;\n        } else {\n          result.forts_ = fortsBuilder_.build();\n        }\n        if (spawnPointsBuilder_ == null) {\n          if (((bitField0_ & 0x00000008) == 0x00000008)) {\n            spawnPoints_ = java.util.Collections.unmodifiableList(spawnPoints_);\n            bitField0_ = (bitField0_ & ~0x00000008);\n          }\n          result.spawnPoints_ = spawnPoints_;\n        } else {\n          result.spawnPoints_ = spawnPointsBuilder_.build();\n        }\n        if (((bitField0_ & 0x00000010) == 0x00000010)) {\n          deletedObjects_ = deletedObjects_.getUnmodifiableView();\n          bitField0_ = (bitField0_ & ~0x00000010);\n        }\n        result.deletedObjects_ = deletedObjects_;\n        result.isTruncatedList_ = isTruncatedList_;\n        if (fortSummariesBuilder_ == null) {\n          if (((bitField0_ & 0x00000040) == 0x00000040)) {\n            fortSummaries_ = java.util.Collections.unmodifiableList(fortSummaries_);\n            bitField0_ = (bitField0_ & ~0x00000040);\n          }\n          result.fortSummaries_ = fortSummaries_;\n        } else {\n          result.fortSummaries_ = fortSummariesBuilder_.build();\n        }\n        if (decimatedSpawnPointsBuilder_ == null) {\n          if (((bitField0_ & 0x00000080) == 0x00000080)) {\n            decimatedSpawnPoints_ = java.util.Collections.unmodifiableList(decimatedSpawnPoints_);\n            bitField0_ = (bitField0_ & ~0x00000080);\n          }\n          result.decimatedSpawnPoints_ = decimatedSpawnPoints_;\n        } else {\n          result.decimatedSpawnPoints_ = decimatedSpawnPointsBuilder_.build();\n        }\n        if (wildPokemonsBuilder_ == null) {\n          if (((bitField0_ & 0x00000100) == 0x00000100)) {\n            wildPokemons_ = java.util.Collections.unmodifiableList(wildPokemons_);\n            bitField0_ = (bitField0_ & ~0x00000100);\n          }\n          result.wildPokemons_ = wildPokemons_;\n        } else {\n          result.wildPokemons_ = wildPokemonsBuilder_.build();\n        }\n        if (catchablePokemonsBuilder_ == null) {\n          if (((bitField0_ & 0x00000200) == 0x00000200)) {\n            catchablePokemons_ = java.util.Collections.unmodifiableList(catchablePokemons_);\n            bitField0_ = (bitField0_ & ~0x00000200);\n          }\n          result.catchablePokemons_ = catchablePokemons_;\n        } else {\n          result.catchablePokemons_ = catchablePokemonsBuilder_.build();\n        }\n        if (nearbyPokemonsBuilder_ == null) {\n          if (((bitField0_ & 0x00000400) == 0x00000400)) {\n            nearbyPokemons_ = java.util.Collections.unmodifiableList(nearbyPokemons_);\n            bitField0_ = (bitField0_ & ~0x00000400);\n          }\n          result.nearbyPokemons_ = nearbyPokemons_;\n        } else {\n          result.nearbyPokemons_ = nearbyPokemonsBuilder_.build();\n        }\n        result.bitField0_ = to_bitField0_;\n        onBuilt();\n        return result;\n      }\n\n      public Builder clone() {\n        return (Builder) super.clone();\n      }\n      public Builder setField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          Object value) {\n        return (Builder) super.setField(field, value);\n      }\n      public Builder clearField(\n          com.google.protobuf.Descriptors.FieldDescriptor field) {\n        return (Builder) super.clearField(field);\n      }\n      public Builder clearOneof(\n          com.google.protobuf.Descriptors.OneofDescriptor oneof) {\n        return (Builder) super.clearOneof(oneof);\n      }\n      public Builder setRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          int index, Object value) {\n        return (Builder) super.setRepeatedField(field, index, value);\n      }\n      public Builder addRepeatedField(\n          com.google.protobuf.Descriptors.FieldDescriptor field,\n          Object value) {\n        return (Builder) super.addRepeatedField(field, value);\n      }\n      public Builder mergeFrom(com.google.protobuf.Message other) {\n        if (other instanceof POGOProtos.Map.MapCellOuterClass.MapCell) {\n          return mergeFrom((POGOProtos.Map.MapCellOuterClass.MapCell)other);\n        } else {\n          super.mergeFrom(other);\n          return this;\n        }\n      }\n\n      public Builder mergeFrom(POGOProtos.Map.MapCellOuterClass.MapCell other) {\n        if (other == POGOProtos.Map.MapCellOuterClass.MapCell.getDefaultInstance()) return this;\n        if (other.getS2CellId() != 0L) {\n          setS2CellId(other.getS2CellId());\n        }\n        if (other.getCurrentTimestampMs() != 0L) {\n          setCurrentTimestampMs(other.getCurrentTimestampMs());\n        }\n        if (fortsBuilder_ == null) {\n          if (!other.forts_.isEmpty()) {\n            if (forts_.isEmpty()) {\n              forts_ = other.forts_;\n              bitField0_ = (bitField0_ & ~0x00000004);\n            } else {\n              ensureFortsIsMutable();\n              forts_.addAll(other.forts_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.forts_.isEmpty()) {\n            if (fortsBuilder_.isEmpty()) {\n              fortsBuilder_.dispose();\n              fortsBuilder_ = null;\n              forts_ = other.forts_;\n              bitField0_ = (bitField0_ & ~0x00000004);\n              fortsBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getFortsFieldBuilder() : null;\n            } else {\n              fortsBuilder_.addAllMessages(other.forts_);\n            }\n          }\n        }\n        if (spawnPointsBuilder_ == null) {\n          if (!other.spawnPoints_.isEmpty()) {\n            if (spawnPoints_.isEmpty()) {\n              spawnPoints_ = other.spawnPoints_;\n              bitField0_ = (bitField0_ & ~0x00000008);\n            } else {\n              ensureSpawnPointsIsMutable();\n              spawnPoints_.addAll(other.spawnPoints_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.spawnPoints_.isEmpty()) {\n            if (spawnPointsBuilder_.isEmpty()) {\n              spawnPointsBuilder_.dispose();\n              spawnPointsBuilder_ = null;\n              spawnPoints_ = other.spawnPoints_;\n              bitField0_ = (bitField0_ & ~0x00000008);\n              spawnPointsBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getSpawnPointsFieldBuilder() : null;\n            } else {\n              spawnPointsBuilder_.addAllMessages(other.spawnPoints_);\n            }\n          }\n        }\n        if (!other.deletedObjects_.isEmpty()) {\n          if (deletedObjects_.isEmpty()) {\n            deletedObjects_ = other.deletedObjects_;\n            bitField0_ = (bitField0_ & ~0x00000010);\n          } else {\n            ensureDeletedObjectsIsMutable();\n            deletedObjects_.addAll(other.deletedObjects_);\n          }\n          onChanged();\n        }\n        if (other.getIsTruncatedList() != false) {\n          setIsTruncatedList(other.getIsTruncatedList());\n        }\n        if (fortSummariesBuilder_ == null) {\n          if (!other.fortSummaries_.isEmpty()) {\n            if (fortSummaries_.isEmpty()) {\n              fortSummaries_ = other.fortSummaries_;\n              bitField0_ = (bitField0_ & ~0x00000040);\n            } else {\n              ensureFortSummariesIsMutable();\n              fortSummaries_.addAll(other.fortSummaries_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.fortSummaries_.isEmpty()) {\n            if (fortSummariesBuilder_.isEmpty()) {\n              fortSummariesBuilder_.dispose();\n              fortSummariesBuilder_ = null;\n              fortSummaries_ = other.fortSummaries_;\n              bitField0_ = (bitField0_ & ~0x00000040);\n              fortSummariesBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getFortSummariesFieldBuilder() : null;\n            } else {\n              fortSummariesBuilder_.addAllMessages(other.fortSummaries_);\n            }\n          }\n        }\n        if (decimatedSpawnPointsBuilder_ == null) {\n          if (!other.decimatedSpawnPoints_.isEmpty()) {\n            if (decimatedSpawnPoints_.isEmpty()) {\n              decimatedSpawnPoints_ = other.decimatedSpawnPoints_;\n              bitField0_ = (bitField0_ & ~0x00000080);\n            } else {\n              ensureDecimatedSpawnPointsIsMutable();\n              decimatedSpawnPoints_.addAll(other.decimatedSpawnPoints_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.decimatedSpawnPoints_.isEmpty()) {\n            if (decimatedSpawnPointsBuilder_.isEmpty()) {\n              decimatedSpawnPointsBuilder_.dispose();\n              decimatedSpawnPointsBuilder_ = null;\n              decimatedSpawnPoints_ = other.decimatedSpawnPoints_;\n              bitField0_ = (bitField0_ & ~0x00000080);\n              decimatedSpawnPointsBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getDecimatedSpawnPointsFieldBuilder() : null;\n            } else {\n              decimatedSpawnPointsBuilder_.addAllMessages(other.decimatedSpawnPoints_);\n            }\n          }\n        }\n        if (wildPokemonsBuilder_ == null) {\n          if (!other.wildPokemons_.isEmpty()) {\n            if (wildPokemons_.isEmpty()) {\n              wildPokemons_ = other.wildPokemons_;\n              bitField0_ = (bitField0_ & ~0x00000100);\n            } else {\n              ensureWildPokemonsIsMutable();\n              wildPokemons_.addAll(other.wildPokemons_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.wildPokemons_.isEmpty()) {\n            if (wildPokemonsBuilder_.isEmpty()) {\n              wildPokemonsBuilder_.dispose();\n              wildPokemonsBuilder_ = null;\n              wildPokemons_ = other.wildPokemons_;\n              bitField0_ = (bitField0_ & ~0x00000100);\n              wildPokemonsBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getWildPokemonsFieldBuilder() : null;\n            } else {\n              wildPokemonsBuilder_.addAllMessages(other.wildPokemons_);\n            }\n          }\n        }\n        if (catchablePokemonsBuilder_ == null) {\n          if (!other.catchablePokemons_.isEmpty()) {\n            if (catchablePokemons_.isEmpty()) {\n              catchablePokemons_ = other.catchablePokemons_;\n              bitField0_ = (bitField0_ & ~0x00000200);\n            } else {\n              ensureCatchablePokemonsIsMutable();\n              catchablePokemons_.addAll(other.catchablePokemons_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.catchablePokemons_.isEmpty()) {\n            if (catchablePokemonsBuilder_.isEmpty()) {\n              catchablePokemonsBuilder_.dispose();\n              catchablePokemonsBuilder_ = null;\n              catchablePokemons_ = other.catchablePokemons_;\n              bitField0_ = (bitField0_ & ~0x00000200);\n              catchablePokemonsBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getCatchablePokemonsFieldBuilder() : null;\n            } else {\n              catchablePokemonsBuilder_.addAllMessages(other.catchablePokemons_);\n            }\n          }\n        }\n        if (nearbyPokemonsBuilder_ == null) {\n          if (!other.nearbyPokemons_.isEmpty()) {\n            if (nearbyPokemons_.isEmpty()) {\n              nearbyPokemons_ = other.nearbyPokemons_;\n              bitField0_ = (bitField0_ & ~0x00000400);\n            } else {\n              ensureNearbyPokemonsIsMutable();\n              nearbyPokemons_.addAll(other.nearbyPokemons_);\n            }\n            onChanged();\n          }\n        } else {\n          if (!other.nearbyPokemons_.isEmpty()) {\n            if (nearbyPokemonsBuilder_.isEmpty()) {\n              nearbyPokemonsBuilder_.dispose();\n              nearbyPokemonsBuilder_ = null;\n              nearbyPokemons_ = other.nearbyPokemons_;\n              bitField0_ = (bitField0_ & ~0x00000400);\n              nearbyPokemonsBuilder_ = \n                com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ?\n                   getNearbyPokemonsFieldBuilder() : null;\n            } else {\n              nearbyPokemonsBuilder_.addAllMessages(other.nearbyPokemons_);\n            }\n          }\n        }\n        onChanged();\n        return this;\n      }\n\n      public final boolean isInitialized() {\n        return true;\n      }\n\n      public Builder mergeFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws java.io.IOException {\n        POGOProtos.Map.MapCellOuterClass.MapCell parsedMessage = null;\n        try {\n          parsedMessage = PARSER.parsePartialFrom(input, extensionRegistry);\n        } catch (com.google.protobuf.InvalidProtocolBufferException e) {\n          parsedMessage = (POGOProtos.Map.MapCellOuterClass.MapCell) e.getUnfinishedMessage();\n          throw e.unwrapIOException();\n        } finally {\n          if (parsedMessage != null) {\n            mergeFrom(parsedMessage);\n          }\n        }\n        return this;\n      }\n      private int bitField0_;\n\n      private long s2CellId_ ;\n      /**\n       * <pre>\n       * S2 geographic area that the cell covers (http://s2map.com/) (https://code.google.com/archive/p/s2-geometry-library/)\n       * </pre>\n       *\n       * <code>optional uint64 s2_cell_id = 1;</code>\n       */\n      public long getS2CellId() {\n        return s2CellId_;\n      }\n      /**\n       * <pre>\n       * S2 geographic area that the cell covers (http://s2map.com/) (https://code.google.com/archive/p/s2-geometry-library/)\n       * </pre>\n       *\n       * <code>optional uint64 s2_cell_id = 1;</code>\n       */\n      public Builder setS2CellId(long value) {\n        \n        s2CellId_ = value;\n        onChanged();\n        return this;\n      }\n      /**\n       * <pre>\n       * S2 geographic area that the cell covers (http://s2map.com/) (https://code.google.com/archive/p/s2-geometry-library/)\n       * </pre>\n       *\n       * <code>optional uint64 s2_cell_id = 1;</code>\n       */\n      public Builder clearS2CellId() {\n        \n        s2CellId_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private long currentTimestampMs_ ;\n      /**\n       * <code>optional int64 current_timestamp_ms = 2;</code>\n       */\n      public long getCurrentTimestampMs() {\n        return currentTimestampMs_;\n      }\n      /**\n       * <code>optional int64 current_timestamp_ms = 2;</code>\n       */\n      public Builder setCurrentTimestampMs(long value) {\n        \n        currentTimestampMs_ = value;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional int64 current_timestamp_ms = 2;</code>\n       */\n      public Builder clearCurrentTimestampMs() {\n        \n        currentTimestampMs_ = 0L;\n        onChanged();\n        return this;\n      }\n\n      private java.util.List<POGOProtos.Map.Fort.FortDataOuterClass.FortData> forts_ =\n        java.util.Collections.emptyList();\n      private void ensureFortsIsMutable() {\n        if (!((bitField0_ & 0x00000004) == 0x00000004)) {\n          forts_ = new java.util.ArrayList<POGOProtos.Map.Fort.FortDataOuterClass.FortData>(forts_);\n          bitField0_ |= 0x00000004;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Fort.FortDataOuterClass.FortData, POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder, POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder> fortsBuilder_;\n\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public java.util.List<POGOProtos.Map.Fort.FortDataOuterClass.FortData> getFortsList() {\n        if (fortsBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(forts_);\n        } else {\n          return fortsBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public int getFortsCount() {\n        if (fortsBuilder_ == null) {\n          return forts_.size();\n        } else {\n          return fortsBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public POGOProtos.Map.Fort.FortDataOuterClass.FortData getForts(int index) {\n        if (fortsBuilder_ == null) {\n          return forts_.get(index);\n        } else {\n          return fortsBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder setForts(\n          int index, POGOProtos.Map.Fort.FortDataOuterClass.FortData value) {\n        if (fortsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureFortsIsMutable();\n          forts_.set(index, value);\n          onChanged();\n        } else {\n          fortsBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder setForts(\n          int index, POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder builderForValue) {\n        if (fortsBuilder_ == null) {\n          ensureFortsIsMutable();\n          forts_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          fortsBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder addForts(POGOProtos.Map.Fort.FortDataOuterClass.FortData value) {\n        if (fortsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureFortsIsMutable();\n          forts_.add(value);\n          onChanged();\n        } else {\n          fortsBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder addForts(\n          int index, POGOProtos.Map.Fort.FortDataOuterClass.FortData value) {\n        if (fortsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureFortsIsMutable();\n          forts_.add(index, value);\n          onChanged();\n        } else {\n          fortsBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder addForts(\n          POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder builderForValue) {\n        if (fortsBuilder_ == null) {\n          ensureFortsIsMutable();\n          forts_.add(builderForValue.build());\n          onChanged();\n        } else {\n          fortsBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder addForts(\n          int index, POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder builderForValue) {\n        if (fortsBuilder_ == null) {\n          ensureFortsIsMutable();\n          forts_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          fortsBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder addAllForts(\n          java.lang.Iterable<? extends POGOProtos.Map.Fort.FortDataOuterClass.FortData> values) {\n        if (fortsBuilder_ == null) {\n          ensureFortsIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, forts_);\n          onChanged();\n        } else {\n          fortsBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder clearForts() {\n        if (fortsBuilder_ == null) {\n          forts_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000004);\n          onChanged();\n        } else {\n          fortsBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public Builder removeForts(int index) {\n        if (fortsBuilder_ == null) {\n          ensureFortsIsMutable();\n          forts_.remove(index);\n          onChanged();\n        } else {\n          fortsBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder getFortsBuilder(\n          int index) {\n        return getFortsFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder getFortsOrBuilder(\n          int index) {\n        if (fortsBuilder_ == null) {\n          return forts_.get(index);  } else {\n          return fortsBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder> \n           getFortsOrBuilderList() {\n        if (fortsBuilder_ != null) {\n          return fortsBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(forts_);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder addFortsBuilder() {\n        return getFortsFieldBuilder().addBuilder(\n            POGOProtos.Map.Fort.FortDataOuterClass.FortData.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder addFortsBuilder(\n          int index) {\n        return getFortsFieldBuilder().addBuilder(\n            index, POGOProtos.Map.Fort.FortDataOuterClass.FortData.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortData forts = 3;</code>\n       */\n      public java.util.List<POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder> \n           getFortsBuilderList() {\n        return getFortsFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Fort.FortDataOuterClass.FortData, POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder, POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder> \n          getFortsFieldBuilder() {\n        if (fortsBuilder_ == null) {\n          fortsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.Fort.FortDataOuterClass.FortData, POGOProtos.Map.Fort.FortDataOuterClass.FortData.Builder, POGOProtos.Map.Fort.FortDataOuterClass.FortDataOrBuilder>(\n                  forts_,\n                  ((bitField0_ & 0x00000004) == 0x00000004),\n                  getParentForChildren(),\n                  isClean());\n          forts_ = null;\n        }\n        return fortsBuilder_;\n      }\n\n      private java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> spawnPoints_ =\n        java.util.Collections.emptyList();\n      private void ensureSpawnPointsIsMutable() {\n        if (!((bitField0_ & 0x00000008) == 0x00000008)) {\n          spawnPoints_ = new java.util.ArrayList<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint>(spawnPoints_);\n          bitField0_ |= 0x00000008;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.SpawnPointOuterClass.SpawnPoint, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder, POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> spawnPointsBuilder_;\n\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> getSpawnPointsList() {\n        if (spawnPointsBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(spawnPoints_);\n        } else {\n          return spawnPointsBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public int getSpawnPointsCount() {\n        if (spawnPointsBuilder_ == null) {\n          return spawnPoints_.size();\n        } else {\n          return spawnPointsBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint getSpawnPoints(int index) {\n        if (spawnPointsBuilder_ == null) {\n          return spawnPoints_.get(index);\n        } else {\n          return spawnPointsBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder setSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint value) {\n        if (spawnPointsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.set(index, value);\n          onChanged();\n        } else {\n          spawnPointsBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder setSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder builderForValue) {\n        if (spawnPointsBuilder_ == null) {\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          spawnPointsBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder addSpawnPoints(POGOProtos.Map.SpawnPointOuterClass.SpawnPoint value) {\n        if (spawnPointsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.add(value);\n          onChanged();\n        } else {\n          spawnPointsBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder addSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint value) {\n        if (spawnPointsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.add(index, value);\n          onChanged();\n        } else {\n          spawnPointsBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder addSpawnPoints(\n          POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder builderForValue) {\n        if (spawnPointsBuilder_ == null) {\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.add(builderForValue.build());\n          onChanged();\n        } else {\n          spawnPointsBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder addSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder builderForValue) {\n        if (spawnPointsBuilder_ == null) {\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          spawnPointsBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder addAllSpawnPoints(\n          java.lang.Iterable<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> values) {\n        if (spawnPointsBuilder_ == null) {\n          ensureSpawnPointsIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, spawnPoints_);\n          onChanged();\n        } else {\n          spawnPointsBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder clearSpawnPoints() {\n        if (spawnPointsBuilder_ == null) {\n          spawnPoints_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000008);\n          onChanged();\n        } else {\n          spawnPointsBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public Builder removeSpawnPoints(int index) {\n        if (spawnPointsBuilder_ == null) {\n          ensureSpawnPointsIsMutable();\n          spawnPoints_.remove(index);\n          onChanged();\n        } else {\n          spawnPointsBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder getSpawnPointsBuilder(\n          int index) {\n        return getSpawnPointsFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder getSpawnPointsOrBuilder(\n          int index) {\n        if (spawnPointsBuilder_ == null) {\n          return spawnPoints_.get(index);  } else {\n          return spawnPointsBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n           getSpawnPointsOrBuilderList() {\n        if (spawnPointsBuilder_ != null) {\n          return spawnPointsBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(spawnPoints_);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder addSpawnPointsBuilder() {\n        return getSpawnPointsFieldBuilder().addBuilder(\n            POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder addSpawnPointsBuilder(\n          int index) {\n        return getSpawnPointsFieldBuilder().addBuilder(\n            index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint spawn_points = 4;</code>\n       */\n      public java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder> \n           getSpawnPointsBuilderList() {\n        return getSpawnPointsFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.SpawnPointOuterClass.SpawnPoint, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder, POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n          getSpawnPointsFieldBuilder() {\n        if (spawnPointsBuilder_ == null) {\n          spawnPointsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.SpawnPointOuterClass.SpawnPoint, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder, POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder>(\n                  spawnPoints_,\n                  ((bitField0_ & 0x00000008) == 0x00000008),\n                  getParentForChildren(),\n                  isClean());\n          spawnPoints_ = null;\n        }\n        return spawnPointsBuilder_;\n      }\n\n      private com.google.protobuf.LazyStringList deletedObjects_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n      private void ensureDeletedObjectsIsMutable() {\n        if (!((bitField0_ & 0x00000010) == 0x00000010)) {\n          deletedObjects_ = new com.google.protobuf.LazyStringArrayList(deletedObjects_);\n          bitField0_ |= 0x00000010;\n         }\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public com.google.protobuf.ProtocolStringList\n          getDeletedObjectsList() {\n        return deletedObjects_.getUnmodifiableView();\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public int getDeletedObjectsCount() {\n        return deletedObjects_.size();\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public java.lang.String getDeletedObjects(int index) {\n        return deletedObjects_.get(index);\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public com.google.protobuf.ByteString\n          getDeletedObjectsBytes(int index) {\n        return deletedObjects_.getByteString(index);\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public Builder setDeletedObjects(\n          int index, java.lang.String value) {\n        if (value == null) {\n    throw new NullPointerException();\n  }\n  ensureDeletedObjectsIsMutable();\n        deletedObjects_.set(index, value);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public Builder addDeletedObjects(\n          java.lang.String value) {\n        if (value == null) {\n    throw new NullPointerException();\n  }\n  ensureDeletedObjectsIsMutable();\n        deletedObjects_.add(value);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public Builder addAllDeletedObjects(\n          java.lang.Iterable<java.lang.String> values) {\n        ensureDeletedObjectsIsMutable();\n        com.google.protobuf.AbstractMessageLite.Builder.addAll(\n            values, deletedObjects_);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public Builder clearDeletedObjects() {\n        deletedObjects_ = com.google.protobuf.LazyStringArrayList.EMPTY;\n        bitField0_ = (bitField0_ & ~0x00000010);\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>repeated string deleted_objects = 6;</code>\n       */\n      public Builder addDeletedObjectsBytes(\n          com.google.protobuf.ByteString value) {\n        if (value == null) {\n    throw new NullPointerException();\n  }\n  checkByteStringIsUtf8(value);\n        ensureDeletedObjectsIsMutable();\n        deletedObjects_.add(value);\n        onChanged();\n        return this;\n      }\n\n      private boolean isTruncatedList_ ;\n      /**\n       * <code>optional bool is_truncated_list = 7;</code>\n       */\n      public boolean getIsTruncatedList() {\n        return isTruncatedList_;\n      }\n      /**\n       * <code>optional bool is_truncated_list = 7;</code>\n       */\n      public Builder setIsTruncatedList(boolean value) {\n        \n        isTruncatedList_ = value;\n        onChanged();\n        return this;\n      }\n      /**\n       * <code>optional bool is_truncated_list = 7;</code>\n       */\n      public Builder clearIsTruncatedList() {\n        \n        isTruncatedList_ = false;\n        onChanged();\n        return this;\n      }\n\n      private java.util.List<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary> fortSummaries_ =\n        java.util.Collections.emptyList();\n      private void ensureFortSummariesIsMutable() {\n        if (!((bitField0_ & 0x00000040) == 0x00000040)) {\n          fortSummaries_ = new java.util.ArrayList<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary>(fortSummaries_);\n          bitField0_ |= 0x00000040;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder> fortSummariesBuilder_;\n\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public java.util.List<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary> getFortSummariesList() {\n        if (fortSummariesBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(fortSummaries_);\n        } else {\n          return fortSummariesBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public int getFortSummariesCount() {\n        if (fortSummariesBuilder_ == null) {\n          return fortSummaries_.size();\n        } else {\n          return fortSummariesBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary getFortSummaries(int index) {\n        if (fortSummariesBuilder_ == null) {\n          return fortSummaries_.get(index);\n        } else {\n          return fortSummariesBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder setFortSummaries(\n          int index, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary value) {\n        if (fortSummariesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureFortSummariesIsMutable();\n          fortSummaries_.set(index, value);\n          onChanged();\n        } else {\n          fortSummariesBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder setFortSummaries(\n          int index, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder builderForValue) {\n        if (fortSummariesBuilder_ == null) {\n          ensureFortSummariesIsMutable();\n          fortSummaries_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          fortSummariesBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder addFortSummaries(POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary value) {\n        if (fortSummariesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureFortSummariesIsMutable();\n          fortSummaries_.add(value);\n          onChanged();\n        } else {\n          fortSummariesBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder addFortSummaries(\n          int index, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary value) {\n        if (fortSummariesBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureFortSummariesIsMutable();\n          fortSummaries_.add(index, value);\n          onChanged();\n        } else {\n          fortSummariesBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder addFortSummaries(\n          POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder builderForValue) {\n        if (fortSummariesBuilder_ == null) {\n          ensureFortSummariesIsMutable();\n          fortSummaries_.add(builderForValue.build());\n          onChanged();\n        } else {\n          fortSummariesBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder addFortSummaries(\n          int index, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder builderForValue) {\n        if (fortSummariesBuilder_ == null) {\n          ensureFortSummariesIsMutable();\n          fortSummaries_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          fortSummariesBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder addAllFortSummaries(\n          java.lang.Iterable<? extends POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary> values) {\n        if (fortSummariesBuilder_ == null) {\n          ensureFortSummariesIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, fortSummaries_);\n          onChanged();\n        } else {\n          fortSummariesBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder clearFortSummaries() {\n        if (fortSummariesBuilder_ == null) {\n          fortSummaries_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000040);\n          onChanged();\n        } else {\n          fortSummariesBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public Builder removeFortSummaries(int index) {\n        if (fortSummariesBuilder_ == null) {\n          ensureFortSummariesIsMutable();\n          fortSummaries_.remove(index);\n          onChanged();\n        } else {\n          fortSummariesBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder getFortSummariesBuilder(\n          int index) {\n        return getFortSummariesFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder getFortSummariesOrBuilder(\n          int index) {\n        if (fortSummariesBuilder_ == null) {\n          return fortSummaries_.get(index);  } else {\n          return fortSummariesBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder> \n           getFortSummariesOrBuilderList() {\n        if (fortSummariesBuilder_ != null) {\n          return fortSummariesBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(fortSummaries_);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder addFortSummariesBuilder() {\n        return getFortSummariesFieldBuilder().addBuilder(\n            POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder addFortSummariesBuilder(\n          int index) {\n        return getFortSummariesFieldBuilder().addBuilder(\n            index, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.Fort.FortSummary fort_summaries = 8;</code>\n       */\n      public java.util.List<POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder> \n           getFortSummariesBuilderList() {\n        return getFortSummariesFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder> \n          getFortSummariesFieldBuilder() {\n        if (fortSummariesBuilder_ == null) {\n          fortSummariesBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummary.Builder, POGOProtos.Map.Fort.FortSummaryOuterClass.FortSummaryOrBuilder>(\n                  fortSummaries_,\n                  ((bitField0_ & 0x00000040) == 0x00000040),\n                  getParentForChildren(),\n                  isClean());\n          fortSummaries_ = null;\n        }\n        return fortSummariesBuilder_;\n      }\n\n      private java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> decimatedSpawnPoints_ =\n        java.util.Collections.emptyList();\n      private void ensureDecimatedSpawnPointsIsMutable() {\n        if (!((bitField0_ & 0x00000080) == 0x00000080)) {\n          decimatedSpawnPoints_ = new java.util.ArrayList<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint>(decimatedSpawnPoints_);\n          bitField0_ |= 0x00000080;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.SpawnPointOuterClass.SpawnPoint, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder, POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> decimatedSpawnPointsBuilder_;\n\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> getDecimatedSpawnPointsList() {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(decimatedSpawnPoints_);\n        } else {\n          return decimatedSpawnPointsBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public int getDecimatedSpawnPointsCount() {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          return decimatedSpawnPoints_.size();\n        } else {\n          return decimatedSpawnPointsBuilder_.getCount();\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint getDecimatedSpawnPoints(int index) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          return decimatedSpawnPoints_.get(index);\n        } else {\n          return decimatedSpawnPointsBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder setDecimatedSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint value) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.set(index, value);\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder setDecimatedSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder builderForValue) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder addDecimatedSpawnPoints(POGOProtos.Map.SpawnPointOuterClass.SpawnPoint value) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.add(value);\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder addDecimatedSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint value) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.add(index, value);\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder addDecimatedSpawnPoints(\n          POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder builderForValue) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.add(builderForValue.build());\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder addDecimatedSpawnPoints(\n          int index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder builderForValue) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder addAllDecimatedSpawnPoints(\n          java.lang.Iterable<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPoint> values) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          ensureDecimatedSpawnPointsIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, decimatedSpawnPoints_);\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder clearDecimatedSpawnPoints() {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          decimatedSpawnPoints_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000080);\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public Builder removeDecimatedSpawnPoints(int index) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          ensureDecimatedSpawnPointsIsMutable();\n          decimatedSpawnPoints_.remove(index);\n          onChanged();\n        } else {\n          decimatedSpawnPointsBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder getDecimatedSpawnPointsBuilder(\n          int index) {\n        return getDecimatedSpawnPointsFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder getDecimatedSpawnPointsOrBuilder(\n          int index) {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          return decimatedSpawnPoints_.get(index);  } else {\n          return decimatedSpawnPointsBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n           getDecimatedSpawnPointsOrBuilderList() {\n        if (decimatedSpawnPointsBuilder_ != null) {\n          return decimatedSpawnPointsBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(decimatedSpawnPoints_);\n        }\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder addDecimatedSpawnPointsBuilder() {\n        return getDecimatedSpawnPointsFieldBuilder().addBuilder(\n            POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder addDecimatedSpawnPointsBuilder(\n          int index) {\n        return getDecimatedSpawnPointsFieldBuilder().addBuilder(\n            index, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.getDefaultInstance());\n      }\n      /**\n       * <code>repeated .POGOProtos.Map.SpawnPoint decimated_spawn_points = 9;</code>\n       */\n      public java.util.List<POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder> \n           getDecimatedSpawnPointsBuilderList() {\n        return getDecimatedSpawnPointsFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.SpawnPointOuterClass.SpawnPoint, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder, POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder> \n          getDecimatedSpawnPointsFieldBuilder() {\n        if (decimatedSpawnPointsBuilder_ == null) {\n          decimatedSpawnPointsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.SpawnPointOuterClass.SpawnPoint, POGOProtos.Map.SpawnPointOuterClass.SpawnPoint.Builder, POGOProtos.Map.SpawnPointOuterClass.SpawnPointOrBuilder>(\n                  decimatedSpawnPoints_,\n                  ((bitField0_ & 0x00000080) == 0x00000080),\n                  getParentForChildren(),\n                  isClean());\n          decimatedSpawnPoints_ = null;\n        }\n        return decimatedSpawnPointsBuilder_;\n      }\n\n      private java.util.List<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon> wildPokemons_ =\n        java.util.Collections.emptyList();\n      private void ensureWildPokemonsIsMutable() {\n        if (!((bitField0_ & 0x00000100) == 0x00000100)) {\n          wildPokemons_ = new java.util.ArrayList<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon>(wildPokemons_);\n          bitField0_ |= 0x00000100;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder> wildPokemonsBuilder_;\n\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public java.util.List<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon> getWildPokemonsList() {\n        if (wildPokemonsBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(wildPokemons_);\n        } else {\n          return wildPokemonsBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public int getWildPokemonsCount() {\n        if (wildPokemonsBuilder_ == null) {\n          return wildPokemons_.size();\n        } else {\n          return wildPokemonsBuilder_.getCount();\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon getWildPokemons(int index) {\n        if (wildPokemonsBuilder_ == null) {\n          return wildPokemons_.get(index);\n        } else {\n          return wildPokemonsBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder setWildPokemons(\n          int index, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon value) {\n        if (wildPokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.set(index, value);\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder setWildPokemons(\n          int index, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder builderForValue) {\n        if (wildPokemonsBuilder_ == null) {\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder addWildPokemons(POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon value) {\n        if (wildPokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.add(value);\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder addWildPokemons(\n          int index, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon value) {\n        if (wildPokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.add(index, value);\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder addWildPokemons(\n          POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder builderForValue) {\n        if (wildPokemonsBuilder_ == null) {\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.add(builderForValue.build());\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder addWildPokemons(\n          int index, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder builderForValue) {\n        if (wildPokemonsBuilder_ == null) {\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder addAllWildPokemons(\n          java.lang.Iterable<? extends POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon> values) {\n        if (wildPokemonsBuilder_ == null) {\n          ensureWildPokemonsIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, wildPokemons_);\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder clearWildPokemons() {\n        if (wildPokemonsBuilder_ == null) {\n          wildPokemons_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000100);\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public Builder removeWildPokemons(int index) {\n        if (wildPokemonsBuilder_ == null) {\n          ensureWildPokemonsIsMutable();\n          wildPokemons_.remove(index);\n          onChanged();\n        } else {\n          wildPokemonsBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder getWildPokemonsBuilder(\n          int index) {\n        return getWildPokemonsFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder getWildPokemonsOrBuilder(\n          int index) {\n        if (wildPokemonsBuilder_ == null) {\n          return wildPokemons_.get(index);  } else {\n          return wildPokemonsBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder> \n           getWildPokemonsOrBuilderList() {\n        if (wildPokemonsBuilder_ != null) {\n          return wildPokemonsBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(wildPokemons_);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder addWildPokemonsBuilder() {\n        return getWildPokemonsFieldBuilder().addBuilder(\n            POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.getDefaultInstance());\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder addWildPokemonsBuilder(\n          int index) {\n        return getWildPokemonsFieldBuilder().addBuilder(\n            index, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.getDefaultInstance());\n      }\n      /**\n       * <pre>\n       * Pokemon within 2 steps or less.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.WildPokemon wild_pokemons = 5;</code>\n       */\n      public java.util.List<POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder> \n           getWildPokemonsBuilderList() {\n        return getWildPokemonsFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder> \n          getWildPokemonsFieldBuilder() {\n        if (wildPokemonsBuilder_ == null) {\n          wildPokemonsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemon.Builder, POGOProtos.Map.Pokemon.WildPokemonOuterClass.WildPokemonOrBuilder>(\n                  wildPokemons_,\n                  ((bitField0_ & 0x00000100) == 0x00000100),\n                  getParentForChildren(),\n                  isClean());\n          wildPokemons_ = null;\n        }\n        return wildPokemonsBuilder_;\n      }\n\n      private java.util.List<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon> catchablePokemons_ =\n        java.util.Collections.emptyList();\n      private void ensureCatchablePokemonsIsMutable() {\n        if (!((bitField0_ & 0x00000200) == 0x00000200)) {\n          catchablePokemons_ = new java.util.ArrayList<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon>(catchablePokemons_);\n          bitField0_ |= 0x00000200;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder> catchablePokemonsBuilder_;\n\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public java.util.List<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon> getCatchablePokemonsList() {\n        if (catchablePokemonsBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(catchablePokemons_);\n        } else {\n          return catchablePokemonsBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public int getCatchablePokemonsCount() {\n        if (catchablePokemonsBuilder_ == null) {\n          return catchablePokemons_.size();\n        } else {\n          return catchablePokemonsBuilder_.getCount();\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon getCatchablePokemons(int index) {\n        if (catchablePokemonsBuilder_ == null) {\n          return catchablePokemons_.get(index);\n        } else {\n          return catchablePokemonsBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder setCatchablePokemons(\n          int index, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon value) {\n        if (catchablePokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.set(index, value);\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder setCatchablePokemons(\n          int index, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder builderForValue) {\n        if (catchablePokemonsBuilder_ == null) {\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder addCatchablePokemons(POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon value) {\n        if (catchablePokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.add(value);\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder addCatchablePokemons(\n          int index, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon value) {\n        if (catchablePokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.add(index, value);\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder addCatchablePokemons(\n          POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder builderForValue) {\n        if (catchablePokemonsBuilder_ == null) {\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.add(builderForValue.build());\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder addCatchablePokemons(\n          int index, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder builderForValue) {\n        if (catchablePokemonsBuilder_ == null) {\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder addAllCatchablePokemons(\n          java.lang.Iterable<? extends POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon> values) {\n        if (catchablePokemonsBuilder_ == null) {\n          ensureCatchablePokemonsIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, catchablePokemons_);\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder clearCatchablePokemons() {\n        if (catchablePokemonsBuilder_ == null) {\n          catchablePokemons_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000200);\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public Builder removeCatchablePokemons(int index) {\n        if (catchablePokemonsBuilder_ == null) {\n          ensureCatchablePokemonsIsMutable();\n          catchablePokemons_.remove(index);\n          onChanged();\n        } else {\n          catchablePokemonsBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder getCatchablePokemonsBuilder(\n          int index) {\n        return getCatchablePokemonsFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder getCatchablePokemonsOrBuilder(\n          int index) {\n        if (catchablePokemonsBuilder_ == null) {\n          return catchablePokemons_.get(index);  } else {\n          return catchablePokemonsBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder> \n           getCatchablePokemonsOrBuilderList() {\n        if (catchablePokemonsBuilder_ != null) {\n          return catchablePokemonsBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(catchablePokemons_);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder addCatchablePokemonsBuilder() {\n        return getCatchablePokemonsFieldBuilder().addBuilder(\n            POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.getDefaultInstance());\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder addCatchablePokemonsBuilder(\n          int index) {\n        return getCatchablePokemonsFieldBuilder().addBuilder(\n            index, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.getDefaultInstance());\n      }\n      /**\n       * <pre>\n       * Pokemon within 1 step or none.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.MapPokemon catchable_pokemons = 10;</code>\n       */\n      public java.util.List<POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder> \n           getCatchablePokemonsBuilderList() {\n        return getCatchablePokemonsFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder> \n          getCatchablePokemonsFieldBuilder() {\n        if (catchablePokemonsBuilder_ == null) {\n          catchablePokemonsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemon.Builder, POGOProtos.Map.Pokemon.MapPokemonOuterClass.MapPokemonOrBuilder>(\n                  catchablePokemons_,\n                  ((bitField0_ & 0x00000200) == 0x00000200),\n                  getParentForChildren(),\n                  isClean());\n          catchablePokemons_ = null;\n        }\n        return catchablePokemonsBuilder_;\n      }\n\n      private java.util.List<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon> nearbyPokemons_ =\n        java.util.Collections.emptyList();\n      private void ensureNearbyPokemonsIsMutable() {\n        if (!((bitField0_ & 0x00000400) == 0x00000400)) {\n          nearbyPokemons_ = new java.util.ArrayList<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon>(nearbyPokemons_);\n          bitField0_ |= 0x00000400;\n         }\n      }\n\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder> nearbyPokemonsBuilder_;\n\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public java.util.List<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon> getNearbyPokemonsList() {\n        if (nearbyPokemonsBuilder_ == null) {\n          return java.util.Collections.unmodifiableList(nearbyPokemons_);\n        } else {\n          return nearbyPokemonsBuilder_.getMessageList();\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public int getNearbyPokemonsCount() {\n        if (nearbyPokemonsBuilder_ == null) {\n          return nearbyPokemons_.size();\n        } else {\n          return nearbyPokemonsBuilder_.getCount();\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon getNearbyPokemons(int index) {\n        if (nearbyPokemonsBuilder_ == null) {\n          return nearbyPokemons_.get(index);\n        } else {\n          return nearbyPokemonsBuilder_.getMessage(index);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder setNearbyPokemons(\n          int index, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon value) {\n        if (nearbyPokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.set(index, value);\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.setMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder setNearbyPokemons(\n          int index, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder builderForValue) {\n        if (nearbyPokemonsBuilder_ == null) {\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.set(index, builderForValue.build());\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.setMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder addNearbyPokemons(POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon value) {\n        if (nearbyPokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.add(value);\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.addMessage(value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder addNearbyPokemons(\n          int index, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon value) {\n        if (nearbyPokemonsBuilder_ == null) {\n          if (value == null) {\n            throw new NullPointerException();\n          }\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.add(index, value);\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.addMessage(index, value);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder addNearbyPokemons(\n          POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder builderForValue) {\n        if (nearbyPokemonsBuilder_ == null) {\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.add(builderForValue.build());\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.addMessage(builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder addNearbyPokemons(\n          int index, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder builderForValue) {\n        if (nearbyPokemonsBuilder_ == null) {\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.add(index, builderForValue.build());\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.addMessage(index, builderForValue.build());\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder addAllNearbyPokemons(\n          java.lang.Iterable<? extends POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon> values) {\n        if (nearbyPokemonsBuilder_ == null) {\n          ensureNearbyPokemonsIsMutable();\n          com.google.protobuf.AbstractMessageLite.Builder.addAll(\n              values, nearbyPokemons_);\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.addAllMessages(values);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder clearNearbyPokemons() {\n        if (nearbyPokemonsBuilder_ == null) {\n          nearbyPokemons_ = java.util.Collections.emptyList();\n          bitField0_ = (bitField0_ & ~0x00000400);\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.clear();\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public Builder removeNearbyPokemons(int index) {\n        if (nearbyPokemonsBuilder_ == null) {\n          ensureNearbyPokemonsIsMutable();\n          nearbyPokemons_.remove(index);\n          onChanged();\n        } else {\n          nearbyPokemonsBuilder_.remove(index);\n        }\n        return this;\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder getNearbyPokemonsBuilder(\n          int index) {\n        return getNearbyPokemonsFieldBuilder().getBuilder(index);\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder getNearbyPokemonsOrBuilder(\n          int index) {\n        if (nearbyPokemonsBuilder_ == null) {\n          return nearbyPokemons_.get(index);  } else {\n          return nearbyPokemonsBuilder_.getMessageOrBuilder(index);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public java.util.List<? extends POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder> \n           getNearbyPokemonsOrBuilderList() {\n        if (nearbyPokemonsBuilder_ != null) {\n          return nearbyPokemonsBuilder_.getMessageOrBuilderList();\n        } else {\n          return java.util.Collections.unmodifiableList(nearbyPokemons_);\n        }\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder addNearbyPokemonsBuilder() {\n        return getNearbyPokemonsFieldBuilder().addBuilder(\n            POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.getDefaultInstance());\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder addNearbyPokemonsBuilder(\n          int index) {\n        return getNearbyPokemonsFieldBuilder().addBuilder(\n            index, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.getDefaultInstance());\n      }\n      /**\n       * <pre>\n       * Pokemon farther away than 2 steps, but still in the area.\n       * </pre>\n       *\n       * <code>repeated .POGOProtos.Map.Pokemon.NearbyPokemon nearby_pokemons = 11;</code>\n       */\n      public java.util.List<POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder> \n           getNearbyPokemonsBuilderList() {\n        return getNearbyPokemonsFieldBuilder().getBuilderList();\n      }\n      private com.google.protobuf.RepeatedFieldBuilderV3<\n          POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder> \n          getNearbyPokemonsFieldBuilder() {\n        if (nearbyPokemonsBuilder_ == null) {\n          nearbyPokemonsBuilder_ = new com.google.protobuf.RepeatedFieldBuilderV3<\n              POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemon.Builder, POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.NearbyPokemonOrBuilder>(\n                  nearbyPokemons_,\n                  ((bitField0_ & 0x00000400) == 0x00000400),\n                  getParentForChildren(),\n                  isClean());\n          nearbyPokemons_ = null;\n        }\n        return nearbyPokemonsBuilder_;\n      }\n      public final Builder setUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return this;\n      }\n\n      public final Builder mergeUnknownFields(\n          final com.google.protobuf.UnknownFieldSet unknownFields) {\n        return this;\n      }\n\n\n      // @@protoc_insertion_point(builder_scope:POGOProtos.Map.MapCell)\n    }\n\n    // @@protoc_insertion_point(class_scope:POGOProtos.Map.MapCell)\n    private static final POGOProtos.Map.MapCellOuterClass.MapCell DEFAULT_INSTANCE;\n    static {\n      DEFAULT_INSTANCE = new POGOProtos.Map.MapCellOuterClass.MapCell();\n    }\n\n    public static POGOProtos.Map.MapCellOuterClass.MapCell getDefaultInstance() {\n      return DEFAULT_INSTANCE;\n    }\n\n    private static final com.google.protobuf.Parser<MapCell>\n        PARSER = new com.google.protobuf.AbstractParser<MapCell>() {\n      public MapCell parsePartialFrom(\n          com.google.protobuf.CodedInputStream input,\n          com.google.protobuf.ExtensionRegistryLite extensionRegistry)\n          throws com.google.protobuf.InvalidProtocolBufferException {\n          return new MapCell(input, extensionRegistry);\n      }\n    };\n\n    public static com.google.protobuf.Parser<MapCell> parser() {\n      return PARSER;\n    }\n\n    @java.lang.Override\n    public com.google.protobuf.Parser<MapCell> getParserForType() {\n      return PARSER;\n    }\n\n    public POGOProtos.Map.MapCellOuterClass.MapCell getDefaultInstanceForType() {\n      return DEFAULT_INSTANCE;\n    }\n\n  }\n\n  private static final com.google.protobuf.Descriptors.Descriptor\n    internal_static_POGOProtos_Map_MapCell_descriptor;\n  private static final \n    com.google.protobuf.GeneratedMessageV3.FieldAccessorTable\n      internal_static_POGOProtos_Map_MapCell_fieldAccessorTable;\n\n  public static com.google.protobuf.Descriptors.FileDescriptor\n      getDescriptor() {\n    return descriptor;\n  }\n  private static  com.google.protobuf.Descriptors.FileDescriptor\n      descriptor;\n  static {\n    java.lang.String[] descriptorData = {\n      \"\\n\\034POGOProtos/Map/MapCell.proto\\022\\016POGOProt\" +\n      \"os.Map\\032\\037POGOProtos/Map/SpawnPoint.proto\\032\" +\n      \"\\\"POGOProtos/Map/Fort/FortData.proto\\032%POG\" +\n      \"OProtos/Map/Fort/FortSummary.proto\\032*POGO\" +\n      \"Protos/Map/Pokemon/NearbyPokemon.proto\\032(\" +\n      \"POGOProtos/Map/Pokemon/WildPokemon.proto\" +\n      \"\\032\\'POGOProtos/Map/Pokemon/MapPokemon.prot\" +\n      \"o\\\"\\201\\004\\n\\007MapCell\\022\\022\\n\\ns2_cell_id\\030\\001 \\001(\\004\\022\\034\\n\\024cur\" +\n      \"rent_timestamp_ms\\030\\002 \\001(\\003\\022,\\n\\005forts\\030\\003 \\003(\\0132\\035\" +\n      \".POGOProtos.Map.Fort.FortData\\0220\\n\\014spawn_p\",\n      \"oints\\030\\004 \\003(\\0132\\032.POGOProtos.Map.SpawnPoint\\022\" +\n      \"\\027\\n\\017deleted_objects\\030\\006 \\003(\\t\\022\\031\\n\\021is_truncated\" +\n      \"_list\\030\\007 \\001(\\010\\0228\\n\\016fort_summaries\\030\\010 \\003(\\0132 .PO\" +\n      \"GOProtos.Map.Fort.FortSummary\\022:\\n\\026decimat\" +\n      \"ed_spawn_points\\030\\t \\003(\\0132\\032.POGOProtos.Map.S\" +\n      \"pawnPoint\\022:\\n\\rwild_pokemons\\030\\005 \\003(\\0132#.POGOP\" +\n      \"rotos.Map.Pokemon.WildPokemon\\022>\\n\\022catchab\" +\n      \"le_pokemons\\030\\n \\003(\\0132\\\".POGOProtos.Map.Pokem\" +\n      \"on.MapPokemon\\022>\\n\\017nearby_pokemons\\030\\013 \\003(\\0132%\" +\n      \".POGOProtos.Map.Pokemon.NearbyPokemonb\\006p\",\n      \"roto3\"\n    };\n    com.google.protobuf.Descriptors.FileDescriptor.InternalDescriptorAssigner assigner =\n        new com.google.protobuf.Descriptors.FileDescriptor.    InternalDescriptorAssigner() {\n          public com.google.protobuf.ExtensionRegistry assignDescriptors(\n              com.google.protobuf.Descriptors.FileDescriptor root) {\n            descriptor = root;\n            return null;\n          }\n        };\n    com.google.protobuf.Descriptors.FileDescriptor\n      .internalBuildGeneratedFileFrom(descriptorData,\n        new com.google.protobuf.Descriptors.FileDescriptor[] {\n          POGOProtos.Map.SpawnPointOuterClass.getDescriptor(),\n          POGOProtos.Map.Fort.FortDataOuterClass.getDescriptor(),\n          POGOProtos.Map.Fort.FortSummaryOuterClass.getDescriptor(),\n          POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.getDescriptor(),\n          POGOProtos.Map.Pokemon.WildPokemonOuterClass.getDescriptor(),\n          POGOProtos.Map.Pokemon.MapPokemonOuterClass.getDescriptor(),\n        }, assigner);\n    internal_static_POGOProtos_Map_MapCell_descriptor =\n      getDescriptor().getMessageTypes().get(0);\n    internal_static_POGOProtos_Map_MapCell_fieldAccessorTable = new\n      com.google.protobuf.GeneratedMessageV3.FieldAccessorTable(\n        internal_static_POGOProtos_Map_MapCell_descriptor,\n        new java.lang.String[] { \"S2CellId\", \"CurrentTimestampMs\", \"Forts\", \"SpawnPoints\", \"DeletedObjects\", \"IsTruncatedList\", \"FortSummaries\", \"DecimatedSpawnPoints\", \"WildPokemons\", \"CatchablePokemons\", \"NearbyPokemons\", });\n    POGOProtos.Map.SpawnPointOuterClass.getDescriptor();\n    POGOProtos.Map.Fort.FortDataOuterClass.getDescriptor();\n    POGOProtos.Map.Fort.FortSummaryOuterClass.getDescriptor();\n    POGOProtos.Map.Pokemon.NearbyPokemonOuterClass.getDescriptor();\n    POGOProtos.Map.Pokemon.WildPokemonOuterClass.getDescriptor();\n    POGOProtos.Map.Pokemon.MapPokemonOuterClass.getDescriptor();\n  }\n\n  // @@protoc_insertion_point(outer_class_scope)\n}\n", "blic class L {\n    public static void w(String tag, Object message) {\n        if (BuildConfig.LOG) {\n            Log.w(tag, String.valueOf(message));\n        }\n    }\n\n    public static void d(String tag, Object message) {\n        if (BuildConfig.LOG) {\n            Log.d(tag, String.valueOf(message));\n        }\n    }\n\n    public static void i(String tag, Object message) {\n        if (BuildConfig.LOG) {\n            Log.i(tag, String.valueOf(message));\n        }\n    }\n\n    public static void e(String tag, Object message) {\n        e(tag, message, null);\n    }\n\n    public static void e(String tag, Object message, Throwable e) {\n        if (BuildConfig.LOG) {\n            Log.e(tag, String.valueOf(message), e);\n        }\n    }\n}\n", "IWebLocator;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic interface IRow extends IWebLocator, IText {\n\n    default List<Integer> getColumns(int columns, int[] excludedColumns) {\n        List<Integer> excluded = new ArrayList<>();\n        for (int excludedColumn : excludedColumns) {\n            excluded.add(excludedColumn);\n        }\n\n        List<Integer> columnsList = new ArrayList<>();\n        for (int i = 1; i <= columns; i++) {\n            if (!excluded.contains(i)) {\n                columnsList.add(i);\n            }\n        }\n        return columnsList;\n    }\n}", "05, 2006, 2007, 2008, 2009, 2010, 2011 VMware, Inc.\n *\n * The contents of this file are subject to the Zimbra Public License\n * Version 1.3 (\"License\"); you may not use this file except in\n * compliance with the License.  You may obtain a copy of the License at\n * http://www.zimbra.com/license.\n *\n * Software distributed under the License is distributed on an \"AS IS\"\n * basis, WITHOUT WARRANTY OF ANY KIND, either express or implied.\n * ***** END LICENSE BLOCK *****\n */\n\npackage com.zimbra.cs.lmtpserver;\n\nimport java.io.ByteArrayInputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Set;\nimport java.util.concurrent.CopyOnWriteArrayList;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.ReentrantLock;\n\nimport javax.mail.MessagingException;\nimport javax.mail.internet.MimeMessage;\n\nimport com.google.common.base.Function;\nimport com.google.common.base.Strings;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.MapMaker;\nimport com.google.common.collect.Multimap;\nimport com.zimbra.common.account.Key.AccountBy;\nimport com.zimbra.common.lmtp.LmtpClient;\nimport com.zimbra.common.lmtp.LmtpProtocolException;\nimport com.zimbra.common.localconfig.DebugConfig;\nimport com.zimbra.common.localconfig.LC;\nimport com.zimbra.common.mime.Rfc822ValidationInputStream;\nimport com.zimbra.common.service.ServiceException;\nimport com.zimbra.common.util.BufferStream;\nimport com.zimbra.common.util.ByteUtil;\nimport com.zimbra.common.util.CopyInputStream;\nimport com.zimbra.common.util.LruMap;\nimport com.zimbra.common.util.MapUtil;\nimport com.zimbra.common.util.TimeoutMap;\nimport com.zimbra.common.util.ZimbraLog;\nimport com.zimbra.cs.account.Account;\nimport com.zimbra.cs.account.Config;\nimport com.zimbra.cs.account.Provisioning;\nimport com.zimbra.cs.account.Server;\nimport com.zimbra.cs.filter.RuleManager;\nimport com.zimbra.cs.mailbox.DeliveryContext;\nimport com.zimbra.cs.mailbox.DeliveryOptions;\nimport com.zimbra.cs.mailbox.Flag;\nimport com.zimbra.cs.mailbox.Folder;\nimport com.zimbra.cs.mailbox.MailItem;\nimport com.zimbra.cs.mailbox.MailServiceException;\nimport com.zimbra.cs.mailbox.Mailbox;\nimport com.zimbra.cs.mailbox.MailboxManager;\nimport com.zimbra.cs.mailbox.Message;\nimport com.zimbra.cs.mailbox.MessageCache;\nimport com.zimbra.cs.mailbox.Notification;\nimport com.zimbra.cs.mailbox.QuotaWarning;\nimport com.zimbra.cs.mime.ParsedMessage;\nimport com.zimbra.cs.mime.ParsedMessageOptions;\nimport com.zimbra.cs.service.util.ItemId;\nimport com.zimbra.cs.store.Blob;\nimport com.zimbra.cs.store.BlobInputStream;\nimport com.zimbra.cs.store.MailboxBlob;\nimport com.zimbra.cs.store.StoreManager;\nimport com.zimbra.cs.util.Zimbra;\n\npublic class ZimbraLmtpBackend implements LmtpBackend {\n\n    private static List<LmtpCallback> callbacks = new CopyOnWriteArrayList<LmtpCallback>();\n    private static Map<String, Set<Integer>> receivedMessageIDs;\n    private static final Map<Integer, ReentrantLock> mailboxDeliveryLocks = createMailboxDeliveryLocks();\n\n    private final LmtpConfig config;\n\n    public ZimbraLmtpBackend(LmtpConfig lmtpConfig) {\n        config = lmtpConfig;\n        checkDedupeCacheSize(); // This initializes receivedMessageIDs\n    }\n\n    /**\n     * Adds an instance of an LMTP callback class that will be triggered\n     * before and after a message is added to a user mailbox.\n     */\n    public static void addCallback(LmtpCallback callback) {\n        if (callback == null) {\n            ZimbraLog.lmtp.error(\"\", new IllegalStateException(\"LmtpCallback cannot be null\"));\n            return;\n        }\n        ZimbraLog.lmtp.info(\"Adding LMTP callback: %s\", callback.getClass().getName());\n        callbacks.add(callback);\n    }\n\n    static {\n        addCallback(Notification.getInstance());\n        addCallback(QuotaWarning.getInstance());\n    }\n\n    private static Map<Integer, ReentrantLock> createMailboxDeliveryLocks() {\n        Function<Integer, ReentrantLock> lockCreator = new Function<Integer,  ReentrantLock>() {\n            @Override\n            public ReentrantLock apply(Integer from) {\n                return new ReentrantLock();\n            }\n        };\n        return new MapMaker().makeComputingMap(lockCreator);\n    }\n\n    @Override public LmtpReply getAddressStatus(LmtpAddress address) {\n        String addr = address.getEmailAddress();\n\n        try {\n            Provisioning prov = Provisioning.getInstance();\n            Account acct = prov.get(AccountBy.name, addr);\n            if (acct == null) {\n                ZimbraLog.lmtp.info(\"rejecting address \" + addr + \": no account\");\n                return LmtpReply.NO_SUCH_USER;\n            }\n\n            String acctStatus = acct.getAccountStatus(prov);\n            if (acctStatus == null) {\n                ZimbraLog.lmtp.warn(\"rejecting address \" + addr + \": no account status\");\n                return LmtpReply.NO_SUCH_USER;\n            }\n\n            if (acctStatus.equals(Provisioning.ACCOUNT_STATUS_MAINTENANCE)) {\n                ZimbraLog.lmtp.info(\"try again for address \" + addr + \": account status maintenance\");\n                return LmtpReply.MAILBOX_DISABLED;\n            }\n\n            if (Provisioning.onLocalServer(acct)) {\n                address.setOnLocalServer(true);\n            } else if (Provisioning.getInstance().getServer(acct) != null) {\n                address.setOnLocalServer(false);\n                address.setRemoteServer(acct.getMailHost());\n            } else {\n                ZimbraLog.lmtp.warn(\"try again for address \" + addr + \": mailbox is not on this server\");\n                return LmtpReply.MAILBOX_NOT_ON_THIS_SERVER;\n            }\n\n            if (acctStatus.equals(Provisioning.ACCOUNT_STATUS_PENDING)) {\n                ZimbraLog.lmtp.info(\"rejecting address \" + addr + \": account status pending\");\n                return LmtpReply.NO_SUCH_USER;\n            }\n\n            if (acctStatus.equals(Provisioning.ACCOUNT_STATUS_CLOSED)) {\n                ZimbraLog.lmtp.info(\"rejecting address \" + addr + \": account status closed\");\n                return LmtpReply.NO_SUCH_USER;\n            }\n\n            if (acctStatus.equals(Provisioning.ACCOUNT_STATUS_ACTIVE) ||\n                acctStatus.equals(Provisioning.ACCOUNT_STATUS_LOCKOUT) ||\n                acctStatus.equals(Provisioning.ACCOUNT_STATUS_LOCKED))\n            {\n                return LmtpReply.RECIPIENT_OK;\n            }\n\n            ZimbraLog.lmtp.info(\"rejecting address \" + addr + \": unknown account status \" + acctStatus);\n            return LmtpReply.NO_SUCH_USER;\n\n        } catch (ServiceException e) {\n            if (e.isReceiversFault()) {\n                ZimbraLog.lmtp.warn(\"try again for address \" + addr + \": exception occurred\", e);\n                return LmtpReply.MAILBOX_DISABLED;\n            } else {\n                ZimbraLog.lmtp.warn(\"rejecting address \" + addr + \": exception occurred\", e);\n                return LmtpReply.NO_SUCH_USER;\n            }\n        }\n    }\n\n    private boolean dedupe(ParsedMessage pm, Mailbox mbox)\n    throws ServiceException {\n        if (pm == null || mbox == null || !mbox.getAccount().isPrefMessageIdDedupingEnabled())\n            return false;\n\n        checkDedupeCacheSize();\n        String msgid = getMessageID(pm);\n        if (msgid == null || msgid.equals(\"\"))\n            return false;\n\n        synchronized (ZimbraLmtpBackend.class) {\n            Set<Integer> mboxIds = receivedMessageIDs.get(msgid);\n            if (mboxIds != null && mboxIds.contains(mbox.getId())) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Returns the value of the {@code Message-ID} header, or the most\n     * recent {@code Resent-Message-ID} header, if set.\n     */\n    private String getMessageID(ParsedMessage pm) {\n        try {\n            String id = pm.getMimeMessage().getHeader(\"Resent-Message-ID\", null);\n            if (!Strings.isNullOrEmpty(id)) {\n                ZimbraLog.lmtp.debug(\"Resent-Message-ID=%s\", id);\n                return id;\n            }\n        } catch (MessagingException e) {\n            ZimbraLog.lmtp.warn(\"Unable to determine Resent-Message-ID header value\", e);\n        }\n        String id = pm.getMessageID();\n        ZimbraLog.lmtp.debug(\"Resent-Message-ID not found.  Message-ID=%s\", id);\n        return id;\n    }\n\n    /**\n     * If the configured Message-ID cache size has changed, create a new cache and copy\n     * values from the old one.\n     */\n    private void checkDedupeCacheSize() {\n        try {\n            Config config = Provisioning.getInstance().getConfig();\n            int cacheSize = config.getMessageIdDedupeCacheSize();\n            long entryTimeout = config.getMessageIdDedupeCacheTimeout();\n            synchronized (ZimbraLmtpBackend.class) {\n                Map<String, Set<Integer>> newMap = null;\n                if (receivedMessageIDs == null) {\n                    // if non-zero entry timeout is specified then use a timeout map, else use an lru map\n                    receivedMessageIDs = entryTimeout == 0 ?\n                            new LruMap<String, Set<Integer>>(cacheSize) :\n                            new TimeoutMap<String, Set<Integer>>(entryTimeout);\n                } else if (receivedMessageIDs instanceof LruMap) {\n                    if (entryTimeout != 0) {\n                        // change to a timeout map\n                        newMap = MapUtil.newTimeoutMap(entryTimeout);\n                    } else if (((LruMap) receivedMessageIDs).getMaxSize() != cacheSize) {\n                        // adjust lru map size\n                        newMap = MapUtil.newLruMap(cacheSize);\n                    }\n                } else if (receivedMessageIDs instanceof TimeoutMap) {\n                    if (entryTimeout == 0) {\n                        // change to a lru map\n                        newMap = MapUtil.newLruMap(cacheSize);\n                    } else {\n                        ((TimeoutMap) receivedMessageIDs).setTimeout(entryTimeout);\n                    }\n                }\n                if (newMap != null) {\n                    // Copy entries from the old map to the new one.  The old map\n                    // is iterated in order from least-recently accessed to last accessed.\n                    // If the new map size is smaller, we'll get the latest entries.\n                    newMap.putAll(receivedMessageIDs);\n                    receivedMessageIDs = newMap;\n                }\n            }\n        } catch (ServiceException e) {\n            ZimbraLog.lmtp.warn(\"Unable to update dedupe cache size.\", e);\n            // create an empty lru map if it doesn't exist already.\n            synchronized (ZimbraLmtpBackend.class) {\n                if (receivedMessageIDs == null) {\n                    receivedMessageIDs = new LruMap<String, Set<Integer>>(0);\n                }\n            }\n        }\n    }\n\n    private void addToDedupeCache(ParsedMessage pm, Mailbox mbox) {\n        if (pm == null || mbox == null)\n            return;\n        String msgid = getMessageID(pm);\n        if (msgid == null || msgid.equals(\"\"))\n            return;\n\n        synchronized (ZimbraLmtpBackend.class) {\n            Set<Integer> mboxIds = receivedMessageIDs.get(msgid);\n            if (mboxIds == null) {\n                mboxIds = new HashSet<Integer>();\n                receivedMessageIDs.put(msgid, mboxIds);\n            }\n            mboxIds.add(mbox.getId());\n        }\n    }\n\n    private void removeFromDedupeCache(String msgid, Mailbox mbox) {\n        if (mbox == null || Strings.isNullOrEmpty(msgid))\n            return;\n\n        synchronized (ZimbraLmtpBackend.class) {\n            Set<Integer> mboxIds = receivedMessageIDs.get(msgid);\n            if (mboxIds != null) {\n                mboxIds.remove(mbox.getId());\n            }\n        }\n    }\n\n    private enum DeliveryAction {\n        discard, // local delivery is disabled\n        defer,   // can not deliver to mailbox right now - backup maybe in progress\n        deliver  // OK to deliver\n    }\n\n    private static class RecipientDetail {\n        public Account account;\n        public Mailbox mbox;\n        public ParsedMessage pm;\n        public boolean esd; // whether endSharedDelivery should be called\n        public DeliveryAction action;\n\n        public RecipientDetail(Account a, Mailbox m, ParsedMessage p, boolean endSharedDelivery, DeliveryAction da) {\n            account = a;\n            mbox = m;\n            pm = p;\n            esd = endSharedDelivery;\n            action = da;\n        }\n    }\n\n    @Override\n    public void deliver(LmtpEnvelope env, InputStream in, int sizeHint) throws UnrecoverableLmtpException {\n        CopyInputStream cis = null;\n        Blob blob = null;\n        try {\n            int bufLen = Provisioning.getInstance().getLocalServer().getMailDiskStreamingThreshold();\n            cis = new CopyInputStream(in, sizeHint, bufLen, bufLen);\n            in = cis;\n\n//            MimeParserInputStream mpis = null;\n//            if (ZMimeMessage.usingZimbraParser()) {\n//                mpis = new MimeParserInputStream(in);\n//                in = mpis;\n//            }\n\n            Rfc822ValidationInputStream validator = null;\n            if (LC.zimbra_lmtp_validate_messages.booleanValue()) {\n                validator = new Rfc822ValidationInputStream(in, LC.zimbra_lmtp_max_line_length.longValue());\n                in = validator;\n            }\n\n            try {\n                blob = StoreManager.getInstance().storeIncoming(in);\n            } catch (IOException ioe) {\n                throw new UnrecoverableLmtpException(\"Error in storing incoming message\", ioe);\n            }\n\n            if (validator != null && !validator.isValid()) {\n                try {\n                    StoreManager.getInstance().delete(blob);\n                } catch (IOException e) {\n                    ZimbraLog.lmtp.warn(\"Error in deleting blob %s\", blob, e);\n                }\n                setDeliveryStatuses(env.getRecipients(), LmtpReply.INVALID_BODY_PARAMETER);\n                return;\n            }\n\n            BufferStream bs = cis.getBufferStream();\n            byte[] data = bs.isPartial() ? null : bs.getBuffer();\n\n            BlobInputStream bis = null;\n            MimeMessage mm = null;\n//            if (mpis != null) {\n//                try {\n//                    if (data == null) {\n//                        bis = new BlobInputStream(blob);\n//                        mpis.setSource(bis);\n//                    } else {\n//                        mpis.setSource(data);\n//                    }\n//                } catch (IOException ioe) {\n//                    throw new UnrecoverableLmtpException(\"Error in accessing incoming message\", ioe);\n//                }\n//\n//                mm = new ZMimeMessage(mpis.getMessage(null));\n//            }\n\n            try {\n                deliverMessageToLocalMailboxes(blob, bis, data, mm, env);\n            } catch (Exception e) {\n                ZimbraLog.lmtp.warn(\"Exception delivering mail (temporary failure)\", e);\n                setDeliveryStatuses(env.getLocalRecipients(), LmtpReply.TEMPORARY_FAILURE);\n            }\n\n            try {\n                deliverMessageToRemoteMailboxes(blob, data, env);\n            } catch (Exception e) {\n                ZimbraLog.lmtp.warn(\"Exception delivering remote mail\", e);\n                setDeliveryStatuses(env.getRemoteRecipients(), LmtpReply.TEMPORARY_FAILURE);\n            }\n        } catch (ServiceException e) {\n            ZimbraLog.lmtp.warn(\"Exception delivering mail (temporary failure)\", e);\n            setDeliveryStatuses(env.getRecipients(), LmtpReply.TEMPORARY_FAILURE);\n        } finally {\n            if (cis != null) {\n                cis.release();\n            }\n\n            if (blob != null) {\n                try {\n                    // clean up the incoming blob\n                    StoreManager.getInstance().delete(blob);\n                } catch (IOException e) {\n                    ZimbraLog.lmtp.warn(\"Error in deleting blob %s\", blob, e);\n                }\n            }\n        }\n    }\n\n    private void deliverMessageToLocalMailboxes(Blob blob, BlobInputStream bis, byte[] data, MimeMessage mm, LmtpEnvelope env)\n        throws ServiceException, IOException {\n\n        List<LmtpAddress> recipients = env.getLocalRecipients();\n        String envSender = env.getSender().getEmailAddress();\n\n        boolean shared = recipients.size() > 1;\n        List<Integer> targetMailboxIds = new ArrayList<Integer>(recipients.size());\n\n        Map<LmtpAddress, RecipientDetail> rcptMap = new HashMap<LmtpAddress, RecipientDetail>(recipients.size());\n        try {\n            // Examine attachments indexing option for all recipients and\n            // prepare ParsedMessage versions needed.  Parsing is done before\n            // attempting delivery to any recipient.  Therefore, parse error\n            // will result in non-delivery to all recipients.\n\n            // ParsedMessage for users with attachments indexing\n            ParsedMessage pmAttachIndex = null;\n            // ParsedMessage for users without attachments indexing\n            ParsedMessage pmNoAttachIndex = null;\n\n            // message id for logging\n            String msgId = null;\n\n            for (LmtpAddress recipient : recipients) {\n                String rcptEmail = recipient.getEmailAddress();\n\n                Account account;\n                Mailbox mbox;\n                boolean attachmentsIndexingEnabled;\n                try {\n                    account = Provisioning.getInstance().get(AccountBy.name, rcptEmail);\n                    if (account == null) {\n                        ZimbraLog.mailbox.warn(\"No account found delivering mail to \" + rcptEmail);\n                        continue;\n                    }\n                    mbox = MailboxManager.getInstance().getMailboxByAccount(account);\n                    if (mbox == null) {\n                        ZimbraLog.mailbox.warn(\"No mailbox found delivering mail to \" + rcptEmail);\n                        continue;\n                    }\n                    attachmentsIndexingEnabled = mbox.attachmentsIndexingEnabled();\n                } catch (ServiceException se) {\n                    if (se.isReceiversFault()) {\n                        ZimbraLog.mailbox.info(\"Recoverable exception getting mailbox for \" + rcptEmail, se);\n                        rcptMap.put(recipient, new RecipientDetail(null, null, null, false, DeliveryAction.defer));\n                    } else {\n                        ZimbraLog.mailbox.warn(\"Unrecoverable exception getting mailbox for \" + rcptEmail, se);\n                    }\n                    continue;\n                }\n\n                if (account != null && mbox != null) {\n                    ParsedMessageOptions pmo;\n                    if (mm != null) {\n                        pmo = new ParsedMessageOptions().setContent(mm).setDigest(blob.getDigest()).setSize(blob.getRawSize());\n                    } else {\n                        pmo = new ParsedMessageOptions(blob, data);\n                    }\n\n                    ParsedMessage pm;\n                    if (attachmentsIndexingEnabled) {\n                        if (pmAttachIndex == null) {\n                            pmo.setAttachmentIndexing(true);\n                            ZimbraLog.lmtp.debug(\"Creating ParsedMessage from %s with attachment indexing enabled\", data == null ? \"file\" : \"memory\");\n                            pmAttachIndex = new ParsedMessage(pmo);\n                        }\n                        pm = pmAttachIndex;\n                    } else {\n                        if (pmNoAttachIndex == null) {\n                            pmo.setAttachmentIndexing(false);\n                            ZimbraLog.lmtp.debug(\"Creating ParsedMessage from %s with attachment indexing disabled\", data == null ? \"file\" : \"memory\");\n                            pmNoAttachIndex = new ParsedMessage(pmo);\n                        }\n                        pm = pmNoAttachIndex;\n                    }\n\n                    msgId = pm.getMessageID();\n\n                    if (account.isPrefMailLocalDeliveryDisabled()) {\n                        ZimbraLog.lmtp.debug(\"Local delivery disabled for account %s\", rcptEmail);\n                        rcptMap.put(recipient, new RecipientDetail(account, mbox, pm, false, DeliveryAction.discard));\n                        continue;\n                    }\n\n                    // For non-shared delivery (i.e. only one recipient),\n                    // always deliver regardless of backup mode.\n                    DeliveryAction da = DeliveryAction.deliver;\n                    boolean endSharedDelivery = false;\n                    if (shared) {\n                        if (mbox.beginSharedDelivery()) {\n                            endSharedDelivery = true;\n                        } else {\n                            // Skip delivery to mailboxes in backup mode.\n                            da = DeliveryAction.defer;\n                        }\n                    }\n                    rcptMap.put(recipient, new RecipientDetail(account, mbox, pm, endSharedDelivery, da));\n                    if (da == DeliveryAction.deliver) {\n                        targetMailboxIds.add(mbox.getId());\n                    }\n                }\n            }\n\n            ZimbraLog.removeAccountFromContext();\n            if (ZimbraLog.lmtp.isInfoEnabled()) {\n                ZimbraLog.lmtp.info(\"Delivering message: size=%s, nrcpts=%d, sender=%s, msgid=%s\",\n                                    env.getSize() == 0 ? \"unspecified\" : Integer.toString(env.getSize()) + \" bytes\",\n                                    recipients.size(),\n                                    env.getSender(),\n                                    msgId == null ? \"\" : msgId);\n            }\n\n            DeliveryContext sharedDeliveryCtxt = new DeliveryContext(shared, targetMailboxIds);\n            sharedDeliveryCtxt.setIncomingBlob(blob);\n\n            // We now know which addresses are valid and which ParsedMessage\n            // version each recipient needs.  Deliver!\n            for (LmtpAddress recipient : recipients) {\n                String rcptEmail = recipient.getEmailAddress();\n                LmtpReply reply = LmtpReply.TEMPORARY_FAILURE;\n                RecipientDetail rd = rcptMap.get(recipient);\n                if (rd.account != null)\n                    ZimbraLog.addAccountNameToContext(rd.account.getName());\n                if (rd.mbox != null)\n                    ZimbraLog.addMboxToContext(rd.mbox.getId());\n\n                boolean success = false;\n                try {\n                    if (rd != null) {\n                        switch (rd.action) {\n                        case discard:\n                            ZimbraLog.lmtp.info(\"accepted and discarded message from=%s,to=%s: local delivery is disabled\",\n                                    envSender, rcptEmail);\n                            if (rd.account.getPrefMailForwardingAddress() != null) {\n                                // mail forwarding is set up\n                                for (LmtpCallback callback : callbacks) {\n                                    ZimbraLog.lmtp.debug(\"Executing callback %s\", callback.getClass().getName());\n                                    callback.forwardWithoutDelivery(rd.account, rd.mbox, envSender, rcptEmail, rd.pm);\n                                }\n                            }\n                            reply = LmtpReply.DELIVERY_OK;\n                            break;\n                        case deliver:\n                            Account account = rd.account;\n                            Mailbox mbox = rd.mbox;\n                            ParsedMessage pm = rd.pm;\n                            List<ItemId> addedMessageIds = null;\n                            ReentrantLock lock = mailboxDeliveryLocks.get(mbox.getId());\n                            boolean acquiredLock;\n                            try {\n                                // Wait for the lock, up to the timeout\n                                acquiredLock = lock.tryLock(LC.zimbra_mailbox_lock_timeout.intValue(), TimeUnit.SECONDS);\n                            } catch (InterruptedException e) {\n                                acquiredLock = false;\n                            }\n                            if (!acquiredLock) {\n                                ZimbraLog.lmtp.info(\"try again for message from=%s,to=%s: another mail delivery in progress.\",\n                                        envSender, rcptEmail);\n                                reply = LmtpReply.TEMPORARY_FAILURE;\n                                break;\n                            }\n                            try {\n                                if (dedupe(pm, mbox)) {\n                                    // message was already delivered to this mailbox\n                                    ZimbraLog.lmtp.info(\"Not delivering message with duplicate Message-ID %s\", pm.getMessageID());\n                                } else if (recipient.getSkipFilters()) {\n                                    msgId = pm.getMessageID();\n                                    int folderId = Mailbox.ID_FOLDER_INBOX;\n                                    if (recipient.getFolder() != null) {\n                                        try {\n                                            Folder folder = mbox.getFolderByPath(null, recipient.getFolder());\n                                            folderId = folder.getId();\n                                        } catch (ServiceException se) {\n                                            if (se.getCode().equals(MailServiceException.NO_SUCH_FOLDER)) {\n                                                Folder folder = mbox.createFolder(null, recipient.getFolder(),\n                                                        new Folder.FolderOptions().setDefaultView(MailItem.Type.MESSAGE));\n                                                folderId = folder.getId();\n                                            } else {\n                                                throw se;\n                                            }\n                                        }\n                                    }\n                                    int flags = Flag.BITMASK_UNREAD;\n                                    if (recipient.getFlags() != null) {\n                                        flags = Flag.toBitmask(recipient.getFlags());\n                                    }\n                                    DeliveryOptions dopt = new DeliveryOptions().setFolderId(folderId);\n                                    dopt.setFlags(flags).setTags(recipient.getTags()).setRecipientEmail(rcptEmail);\n                                    Message msg = mbox.addMessage(null, pm, dopt, sharedDeliveryCtxt);\n                                    addedMessageIds = Lists.newArrayList(new ItemId(msg));\n                                } else if (!DebugConfig.disableIncomingFilter) {\n                                    // Get msgid first, to avoid having to reopen and reparse the blob\n                                    // file if Mailbox.addMessageInternal() closes it.\n                                    pm.getMessageID();\n                                    addedMessageIds = RuleManager.applyRulesToIncomingMessage(\n                                            null, mbox, pm, (int) blob.getRawSize(), rcptEmail, sharedDeliveryCtxt,\n                                            Mailbox.ID_FOLDER_INBOX, false);\n                                } else {\n                                    pm.getMessageID();\n                                    DeliveryOptions dopt = new DeliveryOptions().setFolderId(Mailbox.ID_FOLDER_INBOX);\n                                    dopt.setFlags(Flag.BITMASK_UNREAD).setRecipientEmail(rcptEmail);\n                                    Message msg = mbox.addMessage(null, pm, dopt, sharedDeliveryCtxt);\n                                    addedMessageIds = Lists.newArrayList(new ItemId(msg));\n                                }\n                                success = true;\n                                if (addedMessageIds != null && addedMessageIds.size() > 0) {\n                                    addToDedupeCache(pm, mbox);\n                                }\n                            } finally {\n                                lock.unlock();\n                            }\n\n                            if (addedMessageIds != null && addedMessageIds.size() > 0) {\n                                // Execute callbacks\n                                for (LmtpCallback callback : callbacks) {\n                                    for (ItemId id : addedMessageIds) {\n                                        if (id.belongsTo(mbox)) {\n                                            // Message was added to the local mailbox, as opposed to a mountpoint.\n                                            ZimbraLog.lmtp.debug(\"Executing callback %s\", callback.getClass().getName());\n                                            try {\n                                                Message msg = mbox.getMessageById(null, id.getId());\n                                                callback.afterDelivery(account, mbox, envSender, rcptEmail, msg);\n                                            } catch (Throwable t) {\n                                                if (t instanceof OutOfMemoryError) {\n                                                    Zimbra.halt(\"LMTP callback failed\", t);\n                                                } else {\n                                                    ZimbraLog.lmtp.warn(\"LMTP callback threw an exception\", t);\n                                                }\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                            reply = LmtpReply.DELIVERY_OK;\n                            break;\n                        case defer:\n                            // Delivery to mailbox skipped.  Let MTA retry again later.\n                            // This case happens for shared delivery to a mailbox in\n                            // backup mode.\n                            ZimbraLog.lmtp.info(\"try again for message from=%s,to=%s: mailbox skipped\",\n                                    envSender, rcptEmail);\n                            reply = LmtpReply.TEMPORARY_FAILURE;\n                            break;\n                        }\n                    } else {\n                        // Account or mailbox not found.\n                        ZimbraLog.lmtp.info(\"rejecting message from=%s,to=%s: account or mailbox not found\",\n                                envSender, rcptEmail);\n                        reply = LmtpReply.PERMANENT_FAILURE;\n                    }\n                } catch (ServiceException e) {\n                    if (e.getCode().equals(MailServiceException.QUOTA_EXCEEDED)) {\n                        ZimbraLog.lmtp.info(\"rejecting message from=%s,to=%s: overquota\", envSender, rcptEmail);\n                        if (config.isPermanentFailureWhenOverQuota()) {\n                            reply = LmtpReply.PERMANENT_FAILURE_OVER_QUOTA;\n                        } else {\n                            reply = LmtpReply.TEMPORARY_FAILURE_OVER_QUOTA;\n                        }\n                    } else if (e.isReceiversFault()) {\n                        ZimbraLog.lmtp.info(\"try again for message from=%s,to=%s\", envSender, rcptEmail, e);\n                        reply = LmtpReply.TEMPORARY_FAILURE;\n                    } else {\n                        ZimbraLog.lmtp.info(\"rejecting message from=%s,to=%s\", envSender, rcptEmail, e);\n                        reply = LmtpReply.PERMANENT_FAILURE;\n                    }\n                } catch (Exception e) {\n                    reply = LmtpReply.TEMPORARY_FAILURE;\n                    ZimbraLog.lmtp.warn(\"try again for message from=%s,to=%s\", envSender, rcptEmail, e);\n                } finally {\n                    if (rd.action == DeliveryAction.deliver && !success) {\n                        // Message was not delivered.  Remove it from the dedupe\n                        // cache so we don't dedupe it on LMTP retry.\n                        removeFromDedupeCache(msgId, rd.mbox);\n                    }\n                    recipient.setDeliveryStatus(reply);\n                    if (shared && rd != null && rd.esd) {\n                        rd.mbox.endSharedDelivery();\n                        rd.esd = false;\n                    }\n                }\n            }\n\n            // If this message is being streamed from disk, cache it\n            ParsedMessage mimeSource = pmAttachIndex != null ? pmAttachIndex : pmNoAttachIndex;\n            MailboxBlob mblob = sharedDeliveryCtxt.getMailboxBlob();\n            if (mblob != null && mimeSource != null) {\n                if (bis == null) {\n                    bis = mimeSource.getBlobInputStream();\n                }\n                if (bis != null) {\n                    try {\n                        // Update the MimeMessage with the blob that's stored inside the mailbox,\n                        // since the incoming blob will be deleted.\n                            Blob storedBlob = mblob.getLocalBlob();\n                            bis.fileMoved(storedBlob.getFile());\n                            MessageCache.cacheMessage(mblob.getDigest(), mimeSource.getOriginalMessage(), mimeSource.getMimeMessage());\n                    } catch (IOException e) {\n                        ZimbraLog.lmtp.warn(\"Unable to cache message for \" + mblob, e);\n                    }\n                }\n            }\n        } finally {\n            // If there were any stray exceptions after the call to\n            // beginSharedDelivery that caused endSharedDelivery to be not\n            // called, we check and fix those here.\n            if (shared) {\n                for (RecipientDetail rd : rcptMap.values()) {\n                    if (rd.esd && rd.mbox != null)\n                        rd.mbox.endSharedDelivery();\n                }\n            }\n        }\n    }\n\n    private void deliverMessageToRemoteMailboxes(Blob blob, byte[] data, LmtpEnvelope env) {\n        Multimap<String, LmtpAddress> serverToRecipientsMap = env.getRemoteServerToRecipientsMap();\n        for (String server : serverToRecipientsMap.keySet()) {\n            LmtpClient lmtpClient = null;\n            InputStream in = null;\n            Collection<LmtpAddress> serverRecipients = serverToRecipientsMap.get(server);\n            try {\n                Server serverObj = Provisioning.getInstance().getServerByName(server);\n                lmtpClient = new LmtpClient(server, new Integer(serverObj.getAttr(Provisioning.A_zimbraLmtpBindPort)), null);\n                in = data == null ? blob.getInputStream() : new ByteArrayInputStream(data);\n                boolean success = lmtpClient.sendMessage(in,\n                                                         getRecipientsEmailAddress(serverRecipients),\n                                                         env.getSender().getEmailAddress(),\n                                                         blob.getFile().getName(),\n                                                         blob.getRawSize());\n                if (success) {\n                    setDeliveryStatuses(serverRecipients, LmtpReply.DELIVERY_OK);\n                } else {\n                    ZimbraLog.lmtp.warn(\"Unsuccessful remote mail delivery - LMTP response: %s\", lmtpClient.getResponse());\n                    setDeliveryStatuses(serverRecipients, LmtpReply.TEMPORARY_FAILURE);\n                }\n            } catch (LmtpProtocolException e) {\n                ZimbraLog.lmtp.warn(\"Unsuccessful remote mail delivery - LMTP response: %s\", e.getMessage());\n                setDeliveryStatuses(serverRecipients, LmtpReply.TEMPORARY_FAILURE);\n            } catch (Exception e) {\n                ZimbraLog.lmtp.warn(\"Exception delivering remote mail\", e);\n                setDeliveryStatuses(serverRecipients, LmtpReply.TEMPORARY_FAILURE);\n            } finally {\n                ByteUtil.closeStream(in);\n                if (lmtpClient != null) {\n                    lmtpClient.close();\n                }\n            }\n        }\n    }\n\n    private static String[] getRecipientsEmailAddress(Collection<LmtpAddress> recipients) {\n        LmtpAddress[] recipientsArray = recipients.toArray(new LmtpAddress[recipients.size()]);\n        String[] recipientEmailAddrs = new String[recipientsArray.length];\n        for (int i = 0; i < recipientsArray.length; i ++) {\n            recipientEmailAddrs[i] = recipientsArray[i].getEmailAddress();\n        }\n        return recipientEmailAddrs;\n    }\n\n    private void setDeliveryStatuses(Collection<LmtpAddress> recipients, LmtpReply reply) {\n        for (LmtpAddress recipient : recipients)\n            recipient.setDeliveryStatus(reply);\n    }\n}\n", "tity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\n\n@Entity\npublic class Bookmark {\n\n    @JsonIgnore\n    @ManyToOne\n    private Account account;\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    Bookmark() { // jpa only\n    }\n\n    public Bookmark(Account account, String uri, String description) {\n        this.uri = uri;\n        this.description = description;\n        this.account = account;\n    }\n\n    public String uri;\n    public String description;\n\n    public Account getAccount() {\n        return account;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getUri() {\n        return uri;\n    }\n\n    public String getDescription() {\n        return description;\n    }\n}", ".\npackage com.tunnelvisionlabs.util.concurrent;\n\nimport com.tunnelvisionlabs.util.validation.NotNull;\nimport com.tunnelvisionlabs.util.validation.Nullable;\nimport com.tunnelvisionlabs.util.validation.Requires;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Deque;\nimport java.util.List;\nimport java.util.Queue;\nimport java.util.concurrent.CompletableFuture;\nimport java.util.function.Predicate;\n\n/**\n * A thread-safe, asynchronously pollable queue.\n *\n * <p>Copied from Microsoft/vs-threading@14f77875.</p>\n *\n * @param <T> The type of values kept by the queue.\n */\npublic class AsyncQueue<T> {\n\t/**\n\t * The object to lock when reading/writing the internal data structures.\n\t */\n\tprivate final Object syncObject = new Object();\n\n\t/**\n\t * The futures wanting to poll elements from the queue. Lazily constructed.\n\t */\n\tprivate Queue<CompletableFuture<T>> pollingFutures;\n\n\t/**\n\t * The future returned by {@link #getFuture()}. Lazily constructed.\n\t *\n\t * <p>Volatile to allow the check-lock-check pattern in {@link #getFuture()} to be reliable, in the event that\n\t * within the lock, one thread initializes the value and assigns the field and the weak memory model allows the\n\t * assignment prior to the initialization. Another thread outside the lock might observe the non-null field and\n\t * start accessing the field before it is actually initialized. Volatile prevents CPU reordering of commands around\n\t * the assignment (or read) of this field.</p>\n\t */\n\tprivate volatile CompletableFuture<Void> future;\n\n\t/**\n\t * The internal queue of elements. Lazily constructed.\n\t */\n\tprivate Deque<T> queueElements;\n\n\t/**\n\t * A value indicating whether {@link #complete()} has been called.\n\t */\n\tprivate boolean completeSignaled;\n\n\t/**\n\t * A flag indicating whether {@link #onCompleted()} has been invoked.\n\t */\n\tprivate boolean onCompletedInvoked;\n\n\t/**\n\t * Constructs a new instance of the {@link AsyncQueue} class.\n\t */\n\tpublic AsyncQueue() {\n\t}\n\n\t/**\n\t * Gets a value indicating whether the queue is currently empty.\n\t */\n\tpublic final boolean isEmpty() {\n\t\treturn this.size() == 0;\n\t}\n\n\t/**\n\t * Gets the number of elements currently in the queue.\n\t */\n\tpublic final int size() {\n\t\tsynchronized (syncObject) {\n\t\t\treturn this.queueElements != null ? this.queueElements.size() : 0;\n\t\t}\n\t}\n\n\t/**\n\t * Gets a value indicating whether the queue has completed.\n\t *\n\t * <p>\n\t * This is arguably redundant with {@link #getFuture()}.isDone(), but this property won't cause the lazy\n\t * instantiation of the {@link CompletableFuture} that {@link #getFuture()} may if there is no other reason for the\n\t * {@link CompletableFuture} to exist.</p>\n\t */\n\tpublic final boolean isCompleted() {\n\t\tsynchronized (syncObject) {\n\t\t\treturn this.completeSignaled && this.isEmpty();\n\t\t}\n\t}\n\n\t/**\n\t * Gets a future that completes when {@link #complete()} is called.\n\t */\n\tpublic CompletableFuture<Void> getFuture() {\n\t\tif (future == null) {\n\t\t\tsynchronized (syncObject) {\n\t\t\t\tif (future == null) {\n\t\t\t\t\tif (isCompleted()) {\n\t\t\t\t\t\treturn Futures.completedNull();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfuture = new CompletableFuture<>();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn future;\n\t}\n\n\t/**\n\t * Gets the synchronization object used by this queue.\n\t */\n\tprotected final Object getSyncRoot() {\n\t\treturn this.syncObject;\n\t}\n\n\t/**\n\t * Gets the initial capacity for the queue.\n\t */\n\tprotected int getInitialCapacity() {\n\t\treturn 4;\n\t}\n\n\t/**\n\t * Signals that no further elements will be added.\n\t */\n\tpublic final void complete() {\n\t\tsynchronized (syncObject) {\n\t\t\tcompleteSignaled = true;\n\t\t}\n\n\t\tcompleteIfNecessary();\n\t}\n\n\t/**\n\t * Adds an element to the tail of the queue.\n\t *\n\t * @param value The value to add.\n\t */\n\tpublic final void add(@NotNull T value) {\n\t\tif (!this.tryAdd(value)) {\n\t\t\tthrow new IllegalStateException(\"InvalidAfterCompleted\");\n\t\t}\n\t}\n\n\t/**\n\t * Adds an element to the tail of the queue if it has not yet completed.\n\t *\n\t * @param value The value to add.\n\t * @return {@code true} if the value was added to the queue; {@code false} if the queue is already completed.\n\t */\n\tpublic final boolean tryAdd(@NotNull T value) {\n\t\tRequires.notNull(value, \"value\");\n\n\t\tCompletableFuture<T> poller = null;\n\t\tsynchronized (syncObject) {\n\t\t\tif (completeSignaled) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tif (pollingFutures != null) {\n\t\t\t\twhile (!pollingFutures.isEmpty()) {\n\t\t\t\t\tpoller = pollingFutures.poll();\n\t\t\t\t\tif (poller != null && poller.isDone()) {\n\t\t\t\t\t\t// Skip this one\n\t\t\t\t\t\tpoller = null;\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (poller == null) {\n\t\t\t\t// There were no waiting pollers, so actually add this element to our queue.\n\t\t\t\tif (queueElements == null) {\n\t\t\t\t\tqueueElements = new ArrayDeque<>(this.getInitialCapacity());\n\t\t\t\t}\n\n\t\t\t\tqueueElements.add(value);\n\t\t\t}\n\t\t}\n\n\t\t// important because we'll transition a task to complete.\n\t\tassert !Thread.holdsLock(syncObject);\n\n\t\t// We only transition this future to complete outside of our lock so\n\t\t// we don't accidentally inline continuations inside our lock.\n\t\tif (poller != null) {\n\t\t\t// There was already someone waiting for an element to process, so\n\t\t\t// immediately allow them to begin work and skip our internal queue.\n\t\t\tif (!poller.complete(value)) {\n\t\t\t\t// Retry the add in the event of a race.\n\t\t\t\treturn tryAdd(value);\n\t\t\t}\n\t\t}\n\n\t\tonAdded(value, poller != null);\n\n\t\treturn true;\n\t}\n\n\t/**\n\t * Gets the value at the head of the queue without removing it from the queue, if it is non-empty.\n\t *\n\t * @return The value at the head of the queue; or {@code null} if the queue is empty.\n\t */\n\t@Nullable\n\tpublic final T peek() {\n\t\tsynchronized (syncObject) {\n\t\t\tif (queueElements != null) {\n\t\t\t\treturn queueElements.peek();\n\t\t\t} else {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t}\n\n//        /// <summary>\n//        /// Gets the value at the head of the queue without removing it from the queue.\n//        /// </summary>\n//        /// <exception cref=\"InvalidOperationException\">Thrown if the queue is empty.</exception>\n//        public T Peek()\n//        {\n//            T value;\n//            if (!this.TryPeek(out value))\n//            {\n//                Verify.FailOperation(Strings.QueueEmpty);\n//            }\n//\n//            return value;\n//        }\n\n\t/**\n\t * Gets a future whose result is the element at the head of the queue.\n\t *\n\t * @return A future whose result is the head element.\n\t */\n\tpublic final CompletableFuture<T> pollAsync() {\n\t\treturn pollAsync(CancellationToken.none());\n\t}\n\n\t/**\n\t * Gets a future whose result is the element at the head of the queue.\n\t *\n\t * @return A future whose result is the head element.\n\t */\n\tpublic final CompletableFuture<T> pollAsync(@NotNull CancellationToken cancellationToken) {\n\t\tCompletableFuture<T> completableFuture = new CompletableFuture<>();\n\t\tif (cancellationToken.canBeCancelled()) {\n\t\t\tCancellationTokenRegistration registration = cancellationToken.register(() -> completableFuture.cancel(false));\n\t\t\tcompletableFuture.whenComplete((result, exception) -> registration.close());\n\t\t}\n\n\t\tsynchronized (syncObject) {\n\t\t\tT value = pollInternal(null);\n\t\t\tif (value != null) {\n\t\t\t\tcompletableFuture.complete(value);\n\t\t\t} else {\n\t\t\t\tif (pollingFutures == null) {\n\t\t\t\t\tpollingFutures = new ArrayDeque<>();\n\t\t\t\t}\n\n\t\t\t\tpollingFutures.add(completableFuture);\n\t\t\t}\n\t\t}\n\n\t\tcompleteIfNecessary();\n\t\treturn completableFuture;\n\t}\n\n\t/**\n\t * Immediately polls the element from the head of the queue if one is available, otherwise returns {@code null}.\n\t *\n\t * @return The element from the head of the queue; or {@code null} if the queue is empty.\n\t */\n\t@Nullable\n\tpublic final T poll() {\n\t\tT result = pollInternal(null);\n\t\tcompleteIfNecessary();\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns a copy of this queue as a list.\n\t */\n\t@NotNull\n\tfinal List<T> toList() {\n\t\tsynchronized (syncObject) {\n\t\t\treturn new ArrayList<>(queueElements);\n\t\t}\n\t}\n\n\t/**\n\t * Immediately polls the element from the head of the queue if one is available that satisfies the specified check;\n\t * otherwise returns {@code null}.\n\t *\n\t * @param valueCheck The test on the head element that must succeed to poll.\n\t * @return The element from the head of the queue; or {@code null} if the queue is empty or the first element does\n\t * not match the predicate.\n\t */\n\t@Nullable\n\tprotected final T poll(@NotNull Predicate<? super T> valueCheck) {\n\t\tRequires.notNull(valueCheck, \"valueCheck\");\n\n\t\tT result = pollInternal(valueCheck);\n\t\tcompleteIfNecessary();\n\t\treturn result;\n\t}\n\n\t/**\n\t * Invoked when a value is added.\n\t *\n\t * @param value The added value.\n\t * @param alreadyDispatched {@code true} if the item will skip the queue because a poller was already waiting for an\n\t * item; {@code false} if the item was actually added to the queue.\n\t */\n\tprotected void onAdded(T value, boolean alreadyDispatched) {\n\t}\n\n\t/**\n\t * Invoked when a value is polled.\n\t *\n\t * @param value The polled value.\n\t */\n\tprotected void onPolled(T value) {\n\t}\n\n\t/**\n\t * Invoked when the queue is completed.\n\t */\n\tprotected void onCompleted() {\n\t}\n\n\t/**\n\t * Immediately polls the element from the head of the queue if one is available, otherwise returns {@code null}.\n\t *\n\t * @param valueCheck The test on the head element that must succeed to poll.\n\t * @return The element from the head of the queue; or {@code null} if the queue is empty or the first element does\n\t * not match the predicate.\n\t */\n\tprivate T pollInternal(@Nullable Predicate<? super T> valueCheck) {\n\t\tT value;\n\t\tboolean polled;\n\t\tsynchronized (syncObject) {\n\t\t\tif (queueElements != null && !queueElements.isEmpty() && (valueCheck == null || valueCheck.test(queueElements.peek()))) {\n\t\t\t\tvalue = queueElements.poll();\n\t\t\t\tpolled = true;\n\t\t\t} else {\n\t\t\t\tvalue = null;\n\t\t\t\tpolled = false;\n\t\t\t}\n\t\t}\n\n\t\tif (polled) {\n\t\t\tonPolled(value);\n\t\t}\n\n\t\treturn value;\n\t}\n\n\tprivate void cancelPoller(CompletableFuture<T> poller) {\n\t\tsynchronized (syncObject) {\n\t\t\tif (pollingFutures != null) {\n\t\t\t\tpollingFutures.remove(poller);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Transitions this queue to a completed state if signaled and the queue is empty.\n\t */\n\tprivate void completeIfNecessary() {\n\t\t// important because we'll transition a task to complete.\n\t\tassert !Thread.holdsLock(syncObject);\n\n\t\tboolean transitionFuture;\n\t\tboolean invokeOnCompleted = false;\n\t\tList<CompletableFuture<T>> futuresToCancel = null;\n\t\tsynchronized (syncObject) {\n\t\t\ttransitionFuture = completeSignaled && (queueElements == null || queueElements.isEmpty());\n\t\t\tif (transitionFuture) {\n\t\t\t\tinvokeOnCompleted = !onCompletedInvoked;\n\t\t\t\tonCompletedInvoked = true;\n\n\t\t\t\tif (pollingFutures != null) {\n\t\t\t\t\tfor (CompletableFuture<T> pollingFuture : pollingFutures) {\n\t\t\t\t\t\tif (pollingFuture.isDone()) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (futuresToCancel == null) {\n\t\t\t\t\t\t\tfuturesToCancel = new ArrayList<>();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfuturesToCancel.add(pollingFuture);\n\t\t\t\t\t}\n\n\t\t\t\t\tpollingFutures.clear();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (transitionFuture) {\n\t\t\tif (future != null) {\n\t\t\t\tfuture.complete(null);\n\t\t\t}\n\n\t\t\tif (invokeOnCompleted) {\n\t\t\t\tonCompleted();\n\t\t\t}\n\n\t\t\tif (futuresToCancel != null) {\n\t\t\t\tfor (CompletableFuture<T> futureToCancel : futuresToCancel) {\n\t\t\t\t\tfutureToCancel.cancel(true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "void process(String line);\r\n}\r\n", "mport org.cthul.monad.Unsafe;\nimport org.cthul.monad.util.ExceptionType;\n\npublic class GeneralError<X extends Exception> extends AbstractErrorState<GeneralError<X>, X> {\n\n    public GeneralError(Unsafe<?, ? extends X> result) {\n        super(result);\n    }\n\n    public GeneralError(X exception) {\n        super(exception);\n    }\n\n    public GeneralError(Supplier<? extends X> exceptionSource) {\n        super(exceptionSource);\n    }\n\n    public GeneralError(ExceptionType<? extends X> exceptionType, Status status, String message, Object... args) {\n        super(exceptionType, status, message, args);\n    }\n\n    protected GeneralError(AbstractErrorState<?, ? extends X> source) {\n        super(source);\n    }\n}\n", "ted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage com.deegeu.facebook.messenger.model.send.builder;\n\nimport com.deegeu.facebook.messenger.model.send.PassengerInfo;\nimport org.apache.commons.lang3.builder.ToStringBuilder;\n\n/**\n *\n * @author dspiess\n */\nfinal public class PassengerInfoBuilder {\n\n    private String name;\n\n    private String ticketNumber;\n\n    private String passengerId;\n    \n    public PassengerInfoBuilder() { }\n\n    public PassengerInfoBuilder name(String name) {\n        this.name = name;\n        return this;\n    }\n\n    public PassengerInfoBuilder ticketNumber(String ticketNumber) {\n        this.ticketNumber = ticketNumber;\n        return this;\n    }\n\n    public PassengerInfoBuilder passengerId(String passengerId) {\n        this.passengerId = passengerId;\n        return this;\n    }\n    \n    public PassengerInfo build() {\n        validatePassengerInfo();\n        \n        PassengerInfo info = new PassengerInfo();\n        \n        info.setName(this.name);\n        info.setPassengerId(this.passengerId);\n        info.setTicketNumber(this.ticketNumber);\n        \n        return info;\n    }\n\n    private void validatePassengerInfo() throws IllegalArgumentException {\n        if (this.name == null) {\n            throw new IllegalArgumentException(\"PassengerInfo 'name' cannot be null.\");\n        }\n        \n        if (this.passengerId == null) {\n            throw new IllegalArgumentException(\"PassengerInfo 'passengerId' cannot be null.\");\n        }\n    }\n    \n    @Override\n    public String toString() {\n        return ToStringBuilder.reflectionToString(this);\n    }\n}\n", "| |        | |  \n *      | | | |__) |   __ _  | | __ |  \\| |   ___  | |_ \n *  _   | | |  _  /   / _` | | |/ / | . ` |  / _ \\ | __|\n * | |__| | | | \\ \\  | (_| | |   <  | |\\  | |  __/ | |_ \n *  \\____/  |_|  \\_\\  \\__,_| |_|\\_\\ |_| \\_|  \\___|  \\__|\n *                                                  \n * The MIT License (MIT)\n *\n * Copyright (c) 2016, 2017 MarfGamer\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.  \n */\npackage me.kernelfreeze.bedrockproxy.raknet.client;\n\nimport io.netty.bootstrap.Bootstrap;\nimport io.netty.buffer.ByteBuf;\nimport io.netty.channel.Channel;\nimport io.netty.channel.ChannelOption;\nimport io.netty.channel.EventLoopGroup;\nimport io.netty.channel.nio.NioEventLoopGroup;\nimport io.netty.channel.socket.DatagramPacket;\nimport io.netty.channel.socket.nio.NioDatagramChannel;\nimport me.kernelfreeze.bedrockproxy.raknet.*;\nimport me.kernelfreeze.bedrockproxy.raknet.client.discovery.DiscoveredServer;\nimport me.kernelfreeze.bedrockproxy.raknet.client.discovery.DiscoveryMode;\nimport me.kernelfreeze.bedrockproxy.raknet.client.discovery.DiscoveryThread;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.Reliability;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.login.ConnectionRequest;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.login.OpenConnectionRequestOne;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.login.OpenConnectionRequestTwo;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.message.CustomPacket;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.message.acknowledge.Acknowledge;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.status.UnconnectedPing;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.status.UnconnectedPingOpenConnections;\nimport me.kernelfreeze.bedrockproxy.raknet.protocol.status.UnconnectedPong;\nimport me.kernelfreeze.bedrockproxy.raknet.session.RakNetServerSession;\nimport me.kernelfreeze.bedrockproxy.raknet.session.RakNetState;\nimport me.kernelfreeze.bedrockproxy.raknet.session.UnumRakNetPeer;\nimport me.kernelfreeze.bedrockproxy.raknet.util.RakNetUtils;\nimport me.kernelfreeze.bedrockproxy.raknet.util.map.IntMap;\n\nimport java.net.InetAddress;\nimport java.net.InetSocketAddress;\nimport java.net.UnknownHostException;\nimport java.util.ArrayList;\nimport java.util.Random;\nimport java.util.concurrent.ConcurrentHashMap;\n\nimport static me.kernelfreeze.bedrockproxy.raknet.protocol.MessageIdentifier.*;\n\n/**\n * Used to connect to servers using the RakNet protocol.\n *\n * @author MarfGamer\n */\npublic class RakNetClient implements UnumRakNetPeer, RakNetClientListener {\n\n    // Used to discover systems without relying on the main thread\n    private static DiscoveryThread discoverySystem = new DiscoveryThread();\n\n    // Client data\n    private final long guid;\n    private final long timestamp;\n    /**\n     * synchronize this first! (<code>externalServers</code> goes second!)\n     */\n    private final ConcurrentHashMap<InetSocketAddress, DiscoveredServer> discovered;\n    /**\n     * synchronize this second! (<code>discovered</code> goes first!)\n     */\n    private final ConcurrentHashMap<InetSocketAddress, DiscoveredServer> externalServers;\n    // Networking data\n    private final Bootstrap bootstrap;\n    private final EventLoopGroup group;\n    private final RakNetClientHandler handler;\n    private final IntMap<MaximumTransferUnit> maximumTransferUnits;\n    private int discoveryPort;\n    private DiscoveryMode discoveryMode;\n    // Session management\n    private Channel channel;\n    private SessionPreparation preparation;\n    private volatile RakNetServerSession session;\n    private volatile RakNetClientListener listener;\n\n    /**\n     * Constructs a <code>RakNetClient</code> with the specified\n     * <code>DiscoveryMode</code> and server discovery port.\n     *\n     * @param discoveryMode how the client will discover servers. If this is set to\n     *                      <code>null</code>, the client will enable set it to\n     *                      <code>DiscoveryMode.ALL_CONNECTIONS</code> as long as the port\n     *                      is greater than -1.\n     * @param discoveryPort the port the client will attempt to discover servers on.\n     */\n    public RakNetClient(DiscoveryMode discoveryMode, int discoveryPort) {\n        // Set client data\n        this.guid = new Random().nextLong();\n        this.timestamp = System.currentTimeMillis();\n\n        // Set discovery data\n        this.discoveryPort = discoveryPort;\n        this.discoveryMode = discoveryMode;\n        if (discoveryMode == null) {\n            this.discoveryMode = (discoveryPort > -1 ? DiscoveryMode.ALL_CONNECTIONS : DiscoveryMode.NONE);\n        }\n        this.discovered = new ConcurrentHashMap<InetSocketAddress, DiscoveredServer>();\n        this.externalServers = new ConcurrentHashMap<InetSocketAddress, DiscoveredServer>();\n\n        // Set networking data\n        this.bootstrap = new Bootstrap();\n        this.group = new NioEventLoopGroup();\n        this.handler = new RakNetClientHandler(this);\n\n        // Add maximum transfer units\n        this.maximumTransferUnits = new IntMap<MaximumTransferUnit>();\n        this.addMaximumTransferUnit(new MaximumTransferUnit(RakNetUtils.getMaximumTransferUnit(), 2));\n        this.addMaximumTransferUnit(new MaximumTransferUnit(1464, 3));\n        this.addMaximumTransferUnit(new MaximumTransferUnit(1172, 4));\n        this.addMaximumTransferUnit(new MaximumTransferUnit(RakNet.MINIMUM_TRANSFER_UNIT, 5));\n\n        // Initiate bootstrap data\n        try {\n            bootstrap.channel(NioDatagramChannel.class).group(group).handler(handler);\n            bootstrap.option(ChannelOption.SO_BROADCAST, true).option(ChannelOption.SO_REUSEADDR, false);\n            this.channel = bootstrap.bind(0).sync().channel();\n        } catch (InterruptedException e) {\n            e.printStackTrace();\n        }\n\n        // Set listener\n        this.listener = this;\n\n        // Initiate discovery system if it is not yet started\n        if (discoverySystem.isRunning() == false) {\n            discoverySystem.start();\n        }\n        discoverySystem.addClient(this);\n    }\n\n    /**\n     * Constructs a <code>RakNetClient</code> with the specified server\n     * discovery port with the <code>DiscoveryMode</code> set to\n     * <code>DiscoveryMode.ALL_CONNECTIONS</code>.\n     *\n     * @param discoveryPort the port the client will attempt to discover servers on.\n     */\n    public RakNetClient(int discoveryPort) {\n        this(null, discoveryPort);\n    }\n\n    /**\n     * Constructs a <code>RakNetClient</code> with the\n     * <code>DiscoveryMode</code> set to <code>DiscoveryMode.NONE</code> and the\n     * discovery port set to -1.\n     */\n    public RakNetClient() {\n        this(-1);\n    }\n\n    /**\n     * @return the client's networking protocol version.\n     */\n    public final int getProtocolVersion() {\n        return RakNet.CLIENT_NETWORK_PROTOCOL;\n    }\n\n    /**\n     * @return the client's globally unique ID.\n     */\n    public final long getGloballyUniqueId() {\n        return this.guid;\n    }\n\n    /**\n     * @return the client's timestamp.\n     */\n    public final long getTimestamp() {\n        return (System.currentTimeMillis() - this.timestamp);\n    }\n\n    /**\n     * @return the client's discovery port.\n     */\n    public final int getDiscoveryPort() {\n        return this.discoveryPort;\n    }\n\n    /**\n     * Sets the client's discovery port.\n     *\n     * @param discoveryPort the new discovery port.\n     */\n    public final void setDiscoveryPort(int discoveryPort) {\n        this.discoveryPort = discoveryPort;\n    }\n\n    /**\n     * @return the client's discovery mode.\n     */\n    public final DiscoveryMode getDiscoveryMode() {\n        return this.discoveryMode;\n    }\n\n    /**\n     * Sets the client's discovery mode.\n     *\n     * @param mode how the client will discover servers on the local network.\n     */\n    public final void setDiscoveryMode(DiscoveryMode mode) {\n        this.discoveryMode = (mode != null ? mode : DiscoveryMode.NONE);\n        synchronized (discovered) {\n            if (this.discoveryMode == DiscoveryMode.NONE) {\n                if (listener != null) {\n                    for (InetSocketAddress address : discovered.keySet()) {\n                        listener.onServerForgotten(address);\n                    }\n                }\n                discovered.clear(); // We are not discovering servers anymore!\n            }\n        }\n    }\n\n    /**\n     * Adds a server to the client's external server discovery list. This\n     * functions like the normal discovery system but is not affected by the\n     * <code>DiscoveryMode</code> or discovery port set for the client.\n     *\n     * @param address yhe server address.\n     */\n    public final void addExternalServer(InetSocketAddress address) {\n        synchronized (externalServers) {\n            if (!externalServers.contains(address)) {\n                externalServers.put(address, new DiscoveredServer(address, -1, null));\n                listener.onExternalServerAdded(address);\n            }\n        }\n    }\n\n    /**\n     * Adds a server to the client's external server discovery list. This\n     * functions like the normal discovery system but is not affected by the\n     * <code>DiscoveryMode</code> or discovery port set for the client.\n     *\n     * @param address the server address.\n     * @param port    the server port.\n     */\n    public final void addExternalServer(InetAddress address, int port) {\n        this.addExternalServer(new InetSocketAddress(address, port));\n    }\n\n    /**\n     * Adds a server to the client's external server discovery list. This\n     * functions like the normal discovery system but is not affected by the\n     * <code>DiscoveryMode</code> or discovery port set for the client.\n     *\n     * @param address the server address.\n     * @param port    the server port.\n     * @throws UnknownHostException if the specified address is an unknown host.\n     */\n    public final void addExternalServer(String address, int port) throws UnknownHostException {\n        this.addExternalServer(InetAddress.getByName(address), port);\n    }\n\n    /**\n     * Removes an external server from the client's external server discovery\n     * list.\n     *\n     * @param address the server address.\n     */\n    public final void removeExternalServer(InetSocketAddress address) {\n        synchronized (externalServers) {\n            if (externalServers.contains(address)) {\n                externalServers.remove(address);\n                listener.onExternalServerRemoved(address);\n            }\n        }\n    }\n\n    /**\n     * Removes an external server from the client's external server discovery\n     * list.\n     *\n     * @param address the server address.\n     * @param port    the server port.\n     */\n    public final void removeExternalServer(InetAddress address, int port) {\n        this.removeExternalServer(new InetSocketAddress(address, port));\n    }\n\n    /**\n     * Removes an external server from the client's external server discovery\n     * list.\n     *\n     * @param address the server address.\n     * @param port    the server port.\n     * @throws UnknownHostException if the specified address is an unknown host.\n     */\n    public final void removeExternalServer(String address, int port) throws UnknownHostException {\n        this.removeExternalServer(InetAddress.getByName(address), port);\n    }\n\n    /**\n     * @return the external servers as an array.\n     */\n    public final DiscoveredServer[] getExternalServers() {\n        synchronized (externalServers) {\n            return externalServers.values().toArray(new DiscoveredServer[externalServers.size()]);\n        }\n    }\n\n    /**\n     * Adds a <code>MaximumTransferUnit</code> that can be used by the client\n     * during connection.\n     *\n     * @param maximumTransferUnit the maximum transfer unit.\n     */\n    public final void addMaximumTransferUnit(MaximumTransferUnit maximumTransferUnit) {\n        maximumTransferUnits.put(maximumTransferUnit.getMaximumTransferUnit(), maximumTransferUnit);\n    }\n\n    /**\n     * Adds a <code>MaximumTransferUnit</code> that can be used by the client\n     * during connection.\n     *\n     * @param maximumTransferUnit the maximum transfer unit.\n     * @param retries             the amount of retries before the client moves on to the lower\n     *                            maximum transfer unit.\n     */\n    public final void addMaximumTransferUnit(int maximumTransferUnit, int retries) {\n        this.addMaximumTransferUnit(new MaximumTransferUnit(maximumTransferUnit, retries));\n    }\n\n    /**\n     * Removes a <code>MaximumTransferUnit</code> that was being used by the\n     * client based on it's maximum transfer unit.\n     *\n     * @param maximumTransferUnit the maximum transfer unit to remove.\n     */\n    public final void removeMaximumTransferUnit(int maximumTransferUnit) {\n        maximumTransferUnits.remove(maximumTransferUnit);\n    }\n\n    /**\n     * Removes a <code>MaximumTransferUnit</code> that was being used by the\n     * client.\n     *\n     * @param maximumTransferUnit the maximum transfer unit to remove.\n     */\n    public final void removeMaximumTransferUnit(MaximumTransferUnit maximumTransferUnit) {\n        this.removeMaximumTransferUnit(maximumTransferUnit);\n    }\n\n    /**\n     * @return the <code>MaximumTransferUnit</code>'s the client uses during\n     * login.\n     */\n    public final MaximumTransferUnit[] getMaximumTransferUnits() {\n        return maximumTransferUnits.values().toArray(new MaximumTransferUnit[maximumTransferUnits.size()]);\n    }\n\n    /**\n     * @return the session the client is connected to.\n     */\n    public final RakNetServerSession getSession() {\n        return this.session;\n    }\n\n    /**\n     * @return the client's listener.\n     */\n    public final RakNetClientListener getListener() {\n        return this.listener;\n    }\n\n    /**\n     * Sets the client's listener.\n     *\n     * @param listener the client's new listener.\n     * @return the client.\n     */\n    public final RakNetClient setListener(RakNetClientListener listener) {\n        if (listener == null) {\n            throw new NullPointerException(\"Listener must not be null!\");\n        }\n        this.listener = listener;\n        return this;\n    }\n\n    /**\n     * @return true if the client is connected.\n     */\n    public final boolean isConnected() {\n        if (session != null) {\n            return (session.getState() == RakNetState.CONNECTED);\n        }\n        return false;\n    }\n\n    /**\n     * Called whenever the handler catches an exception in Netty.\n     *\n     * @param address the address that caused the exception.\n     * @param cause   the exception caught by the handler.\n     */\n    protected final void handleHandlerException(InetSocketAddress address, Throwable cause) {\n        listener.onHandlerException(address, cause);\n        if (preparation != null) {\n            if (address.equals(preparation.address)) {\n                preparation.cancelReason = new NettyHandlerException(this, handler, cause);\n            }\n        } else {\n            if (session != null) {\n                if (address.equals(preparation.address)) {\n                    this.disconnect(cause.getClass().getName() + \": \" + cause.getLocalizedMessage());\n                }\n            }\n        }\n    }\n\n    /**\n     * Handles a packet received by the handler.\n     *\n     * @param packet the packet to handle.\n     * @param sender the address of the sender.\n     */\n    public final void handleMessage(RakNetPacket packet, InetSocketAddress sender) {\n        short packetId = packet.getId();\n\n        // This packet has to do with server discovery so it isn't handled here\n        if (packetId == ID_UNCONNECTED_PONG) {\n            UnconnectedPong pong = new UnconnectedPong(packet);\n            pong.decode();\n            if (pong.identifier != null) {\n                this.updateDiscoveryData(sender, pong);\n            }\n        }\n\n        // Are we still logging in?\n        if (preparation != null) {\n            if (sender.equals(preparation.address)) {\n                preparation.handleMessage(packet);\n                return;\n            }\n        }\n\n        // Only handle these from the server we're connected to!\n        if (session != null) {\n            if (sender.equals(session.getAddress())) {\n                if (packetId >= ID_RESERVED_3 && packetId <= ID_RESERVED_9) {\n                    CustomPacket custom = new CustomPacket(packet);\n                    custom.decode();\n\n                    session.handleCustom(custom);\n                } else if (packetId == Acknowledge.ACKNOWLEDGED || packetId == Acknowledge.NOT_ACKNOWLEDGED) {\n                    Acknowledge acknowledge = new Acknowledge(packet);\n                    acknowledge.decode();\n\n                    session.handleAcknowledge(acknowledge);\n                }\n            }\n        }\n    }\n\n    /**\n     * Sends a raw message to the specified address. Be careful when using this\n     * method, because if it is used incorrectly it could break server sessions\n     * entirely! If you are wanting to send a message to a session, you are\n     * probably looking for the\n     * {@link me.kernelfreeze.bedrockproxy.raknet.session.RakNetSession#sendMessage(me.kernelfreeze.bedrockproxy.raknet.protocol.Reliability, me.kernelfreeze.bedrockproxy.raknet.Packet)\n     * sendMessage} method.\n     *\n     * @param buf     the buffer to send.\n     * @param address the address to send the buffer to.\n     */\n    public final void sendNettyMessage(ByteBuf buf, InetSocketAddress address) {\n        channel.writeAndFlush(new DatagramPacket(buf, address));\n    }\n\n    /**\n     * Sends a raw message to the specified address. Be careful when using this\n     * method, because if it is used incorrectly it could break server sessions\n     * entirely! If you are wanting to send a message to a session, you are\n     * probably looking for the\n     * {@link me.kernelfreeze.bedrockproxy.raknet.session.RakNetSession#sendMessage(me.kernelfreeze.bedrockproxy.raknet.protocol.Reliability, me.kernelfreeze.bedrockproxy.raknet.Packet)\n     * sendMessage} method.\n     *\n     * @param packet  the packet to send.\n     * @param address the address to send the packet to.\n     */\n    public final void sendNettyMessage(Packet packet, InetSocketAddress address) {\n        this.sendNettyMessage(packet.buffer(), address);\n    }\n\n    /**\n     * Sends a raw message to the specified address. Be careful when using this\n     * method, because if it is used incorrectly it could break server sessions\n     * entirely! If you are wanting to send a message to a session, you are\n     * probably looking for the\n     * {@link me.kernelfreeze.bedrockproxy.raknet.session.RakNetSession#sendMessage(me.kernelfreeze.bedrockproxy.raknet.protocol.Reliability, int)\n     * sendMessage} method.\n     *\n     * @param packetId the ID of the packet to send.\n     * @param address  the address to send the packet to.\n     */\n    public final void sendNettyMessage(int packetId, InetSocketAddress address) {\n        this.sendNettyMessage(new RakNetPacket(packetId), address);\n    }\n\n    /**\n     * Updates the discovery data in the client by sending pings and removing\n     * servers that have taken too long to respond to a ping.\n     */\n    public final void updateDiscoveryData() {\n        // Remove all servers that have timed out\n        synchronized (discovered) {\n            synchronized (externalServers) {\n                ArrayList<InetSocketAddress> forgottenServers = new ArrayList<InetSocketAddress>();\n                for (InetSocketAddress discoveredServerAddress : discovered.keySet()) {\n                    DiscoveredServer discoveredServer = discovered.get(discoveredServerAddress);\n                    if (System.currentTimeMillis()\n                            - discoveredServer.getDiscoveryTimestamp() >= DiscoveredServer.SERVER_TIMEOUT_MILLI) {\n                        forgottenServers.add(discoveredServerAddress);\n                        listener.onServerForgotten(discoveredServerAddress);\n                    }\n                }\n                discovered.keySet().removeAll(forgottenServers);\n\n                // Broadcast ping to local network\n                if (discoveryMode != DiscoveryMode.NONE && discoveryPort > -1) {\n                    UnconnectedPing ping = new UnconnectedPing();\n                    if (discoveryMode == DiscoveryMode.OPEN_CONNECTIONS) {\n                        ping = new UnconnectedPingOpenConnections();\n                    }\n                    ping.timestamp = this.getTimestamp();\n                    ping.encode();\n\n                    this.sendNettyMessage(ping, new InetSocketAddress(\"255.255.255.255\", discoveryPort));\n                }\n\n                // Send ping to external servers\n                synchronized (externalServers) {\n                    if (!externalServers.isEmpty()) {\n                        UnconnectedPing ping = new UnconnectedPing();\n                        ping.timestamp = this.getTimestamp();\n                        ping.encode();\n\n                        for (InetSocketAddress externalAddress : externalServers.keySet()) {\n                            this.sendNettyMessage(ping, externalAddress);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * This method handles the specified <code>UnconnectedPong</code> packet and\n     * updates the discovery data accordingly.\n     *\n     * @param sender the sender of the <code>UnconnectedPong</code> packet.\n     * @param pong   the <code>UnconnectedPong</code> packet to handle.\n     */\n    public final void updateDiscoveryData(InetSocketAddress sender, UnconnectedPong pong) {\n        // Is this a local or an external server?\n        synchronized (discovered) {\n            synchronized (externalServers) {\n                if (sender.getAddress().isSiteLocalAddress() && !externalServers.containsKey(sender)) {\n                    // This is a local server\n                    if (!discovered.containsKey(sender)) {\n                        // Server discovered\n                        discovered.put(sender,\n                                new DiscoveredServer(sender, System.currentTimeMillis(), pong.identifier));\n                        if (listener != null) {\n                            listener.onServerDiscovered(sender, pong.identifier);\n                        }\n                    } else {\n                        // Server already discovered, but data has changed\n                        DiscoveredServer server = discovered.get(sender);\n                        server.setDiscoveryTimestamp(System.currentTimeMillis());\n                        if (!pong.identifier.equals(server.getIdentifier())) {\n                            server.setIdentifier(pong.identifier);\n                            if (listener != null) {\n                                listener.onServerIdentifierUpdate(sender, pong.identifier);\n                            }\n                        }\n                    }\n                } else {\n                    // This is an external server\n                    if (externalServers.containsKey(sender)) {\n                        DiscoveredServer server = externalServers.get(sender);\n                        server.setDiscoveryTimestamp(System.currentTimeMillis());\n                        if (!pong.identifier.equals(server.getIdentifier())) {\n                            server.setIdentifier(pong.identifier);\n                            listener.onExternalServerIdentifierUpdate(sender, pong.identifier);\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Connects the client to a server with the specified address.\n     *\n     * @param address the address of the server to connect to.\n     * @throws RakNetException if an error occurs during connection or login.\n     */\n    public final void connect(InetSocketAddress address) throws RakNetException {\n        // Make sure we have a listener\n        if (this.listener == null) {\n            throw new NoListenerException();\n        }\n\n        // Reset client data\n        if (this.isConnected()) {\n            this.disconnect(\"Disconnected\");\n        }\n        MaximumTransferUnit[] units = MaximumTransferUnit.sort(this.getMaximumTransferUnits());\n        this.preparation = new SessionPreparation(this, units[0].getMaximumTransferUnit());\n        preparation.address = address;\n\n        // Send OPEN_CONNECTION_REQUEST_ONE with a decreasing MTU\n        int retriesLeft = 0;\n        for (MaximumTransferUnit unit : units) {\n            retriesLeft += unit.getRetries();\n            while (unit.retry() > 0 && preparation.loginPackets[0] == false && preparation.cancelReason == null) {\n                OpenConnectionRequestOne connectionRequestOne = new OpenConnectionRequestOne();\n                connectionRequestOne.maximumTransferUnit = unit.getMaximumTransferUnit();\n                connectionRequestOne.protocolVersion = this.getProtocolVersion();\n                connectionRequestOne.encode();\n                this.sendNettyMessage(connectionRequestOne, address);\n\n                RakNetUtils.threadLock(500);\n            }\n        }\n\n        // Reset MaximumTransferUnit's so they can be used again\n        for (MaximumTransferUnit unit : maximumTransferUnits.values()) {\n            unit.reset();\n        }\n\n        // If the server didn't respond then it is offline\n        if (preparation.loginPackets[0] == false && preparation.cancelReason == null) {\n            preparation.cancelReason = new ServerOfflineException(this, preparation.address);\n        }\n\n        // Send OPEN_CONNECTION_REQUEST_TWO until a response is received\n        while (retriesLeft > 0 && preparation.loginPackets[1] == false && preparation.cancelReason == null) {\n            OpenConnectionRequestTwo connectionRequestTwo = new OpenConnectionRequestTwo();\n            connectionRequestTwo.clientGuid = this.guid;\n            connectionRequestTwo.address = preparation.address;\n            connectionRequestTwo.maximumTransferUnit = preparation.maximumTransferUnit;\n            connectionRequestTwo.encode();\n\n            if (!connectionRequestTwo.failed()) {\n                this.sendNettyMessage(connectionRequestTwo, address);\n                RakNetUtils.threadLock(500);\n            } else {\n                preparation.cancelReason = new PacketBufferException(this, connectionRequestTwo);\n            }\n        }\n\n        // If the server didn't respond then it is offline\n        if (preparation.loginPackets[1] == false && preparation.cancelReason == null) {\n            preparation.cancelReason = new ServerOfflineException(this, preparation.address);\n        }\n\n        // If the session was set we are connected\n        if (preparation.readyForSession()) {\n            // Set session and delete preparation data\n            this.session = preparation.createSession(channel);\n            this.preparation = null;\n\n            // Send connection packet\n            ConnectionRequest connectionRequest = new ConnectionRequest();\n            connectionRequest.clientGuid = this.guid;\n            connectionRequest.timestamp = (System.currentTimeMillis() - this.timestamp);\n            connectionRequest.encode();\n            session.sendMessage(Reliability.RELIABLE_ORDERED, connectionRequest);\n\n            // Initiate connection loop required for the session to function\n            this.initConnection();\n        } else {\n            // Reset the connection data, it failed\n            RakNetException cancelReason = preparation.cancelReason;\n            this.preparation = null;\n            this.session = null;\n            throw cancelReason;\n        }\n    }\n\n    /**\n     * Connects the client to a server with the specified address.\n     *\n     * @param address the address of the server to connect to.\n     * @param port    the port of the server to connect to.\n     * @throws RakNetException if an error occurs during connection or login.\n     */\n    public final void connect(InetAddress address, int port) throws RakNetException {\n        this.connect(new InetSocketAddress(address, port));\n    }\n\n    /**\n     * Connects the client to a server with the specified address.\n     *\n     * @param address the address of the server to connect to.\n     * @param port    the port of the server to connect to.\n     * @throws RakNetException      if an error occurs during connection or login.\n     * @throws UnknownHostException if the specified address is an unknown host.\n     */\n    public final void connect(String address, int port) throws RakNetException, UnknownHostException {\n        this.connect(InetAddress.getByName(address), port);\n    }\n\n    /**\n     * Connects the the client to the specified discovered server.\n     *\n     * @param server the discovered server to connect to.\n     * @throws RakNetException if an error occurs during connection or login.\n     */\n    public final void connect(DiscoveredServer server) throws RakNetException {\n        this.connect(server.getAddress());\n    }\n\n    /**\n     * Connects the client to a server with the specified address on it's own\n     * <code>Thread</code>.\n     *\n     * @param address the address of the server to connect to.\n     * @return the Thread the client is running on.\n     */\n    public final synchronized Thread connectThreaded(InetSocketAddress address) {\n        // Give the thread a reference\n        RakNetClient client = this;\n\n        // Create and start the thread\n        Thread thread = new Thread() {\n            @Override\n            public synchronized void run() {\n                try {\n                    client.connect(address);\n                } catch (Throwable throwable) {\n                    client.getListener().onThreadException(throwable);\n                }\n            }\n        };\n        thread.start();\n\n        // Return the thread so it can be modified\n        return thread;\n    }\n\n    /**\n     * Connects the client to a server with the specified address on it's own\n     * <code>Thread</code>.\n     *\n     * @param address the address of the server to connect to.\n     * @param port    the port of the server to connect to.\n     * @return the Thread the client is running on.\n     */\n    public final Thread connectThreaded(InetAddress address, int port) {\n        return this.connectThreaded(new InetSocketAddress(address, port));\n    }\n\n    /**\n     * Connects the client to a server with the specified address on it's own\n     * <code>Thread</code>.\n     *\n     * @param address the address of the server to connect to.\n     * @param port    the port of the server to connect to.\n     * @return the Thread the client is running on.\n     * @throws UnknownHostException if the specified address is an unknown host.\n     */\n    public final Thread connectThreaded(String address, int port) throws UnknownHostException {\n        return this.connectThreaded(InetAddress.getByName(address), port);\n    }\n\n    /**\n     * Connects the the client to the specified discovered server on it's own\n     * <code>Thread</code>.\n     *\n     * @param server the discovered server to connect to.\n     * @return the Thread the client is running on.\n     */\n    public final Thread connectThreaded(DiscoveredServer server) {\n        return this.connectThreaded(server.getAddress());\n    }\n\n    /**\n     * Starts the loop needed for the client to stay connected to the server.\n     */\n    private final void initConnection() throws RakNetException {\n        while (session != null) {\n            session.update();\n        }\n    }\n\n    @Override\n    public final void sendMessage(Reliability reliability, int channel, Packet packet) {\n        if (this.isConnected()) {\n            session.sendMessage(reliability, channel, packet);\n        }\n    }\n\n    /**\n     * Disconnects the client from the server if it is connected to one.\n     *\n     * @param reason the reason the client disconnected from the server.\n     */\n    public final void disconnect(String reason) {\n        if (session != null) {\n            session.closeConnection();\n            this.getListener().onDisconnect(session, reason);\n        }\n        this.session = null;\n    }\n\n    /**\n     * Disconnects the client from the server if it is connected to one.\n     */\n    public final void disconnect() {\n        this.disconnect(\"Disconnected\");\n    }\n\n    /**\n     * Shuts down the client for good, once this is called the client can no\n     * longer connect to servers.\n     */\n    public final void shutdown() {\n        // Close channel\n        channel.close();\n        group.shutdownGracefully();\n\n        // Shutdown discovery system if needed\n        discoverySystem.removeClient(this);\n        if (discoverySystem.getClients().length <= 0) {\n            discoverySystem.shutdown();\n            discoverySystem = new DiscoveryThread();\n        }\n    }\n\n    /**\n     * Disconnects from the server and shuts down the client for good, once this\n     * is called the client can no longer connect to servers.\n     *\n     * @param reason the reason the client shutdown.\n     */\n    public final void disconnectAndShutdown(String reason) {\n        this.disconnect(reason);\n        this.shutdown();\n    }\n\n    /**\n     * Disconnects from the server and shuts down the client for good, once this\n     * is called the client can no longer connect to servers.\n     */\n    public final void disconnectAndShutdown() {\n        this.disconnectAndShutdown(\"Shutdown\");\n    }\n\n    @Override\n    public final void finalize() {\n        this.shutdown();\n    }\n\n}\n", ";\nimport org.opencv.core.Mat;\nimport org.opencv.core.Size;\nimport org.opencv.imgproc.Imgproc;\n\nimport java.io.File;\nimport java.util.List;\n\nimport us.semanter.app.vision.TaskNode;\nimport us.semanter.app.vision.VisionUtil;\n\npublic class Thumbnailer extends TaskNode {\n    public final static String TASK_NAME = \"thumbnail\";\n\n    public Thumbnailer(Context ctx, TaskNode parent) {\n        super(ctx, parent);\n    }\n    public Thumbnailer(Context ctx, TaskNode parent, TaskNode task) { super(ctx, parent, task); }\n    public Thumbnailer(Context ctx, TaskNode parent, List<TaskNode> children) {\n        super(ctx, parent, children);\n    }\n\n    @Override\n    public void operateOn(String parentID, String sourcePath) {\n        Mat source = VisionUtil.matFromFile(sourcePath);\n\n        Mat thumbnail = new Mat(96, 96, CvType.CV_8UC3);\n        Imgproc.resize(source, thumbnail, new Size(thumbnail.width(), thumbnail.height()));\n\n        // save in result tree\n        dispatch(saveResult(new File(sourcePath), parentID, thumbnail).getPath());\n    }\n\n    @Override\n    public String getTaskName() {\n        return TASK_NAME;\n    }\n}\n", "eeds them into JModClassLoader when asked\n * \n * @author aucguy\n */\npublic class CLResourceProvider implements ResourceProvider {\n\tprotected ClassLoader classloader;\n\n\tpublic CLResourceProvider(ClassLoader classloader) {\n\t\tthis.classloader = classloader;\n\t}\n\n\t@Override\n\tpublic URL findResource(String name) {\n\t\treturn this.classloader.getResource(name);\n\t}\n}\n", "ort javax.ws.rs.Path;\nimport javax.ws.rs.PathParam;\nimport javax.ws.rs.Produces;\nimport javax.ws.rs.core.MediaType;\nimport javax.ws.rs.core.Response;\n\nimport org.sistcoop.producto.representations.idm.ComisionRepresentation;\nimport org.sistcoop.producto.representations.idm.search.SearchResultsRepresentation;\n\npublic interface ComisionesResource {\n\n    @Path(\"/{comision}\")\n    public ComisionResource comision(@PathParam(\"comision\") String comision);\n\n    @POST\n    public Response create(ComisionRepresentation representation);\n\n    @GET\n    @Produces(MediaType.APPLICATION_JSON)\n    public SearchResultsRepresentation<ComisionRepresentation> search();\n\n}\n", "ments Comparable<Book> {\n    private String title;\n    private int year;\n    private List<String> authors;\n\n    public Book(String title, int year, String... authors) {\n        this.setTitle(title);\n        this.setYear(year);\n        this.setAuthors(authors);\n    }\n\n    public String getTitle() {\n        return this.title;\n    }\n\n    private void setTitle(String title) {\n        this.title = title;\n    }\n\n    public int getYear() {\n        return this.year;\n    }\n\n    private void setYear(int year) {\n        this.year = year;\n    }\n\n    public List<String> getAuthors() {\n        return this.authors;\n    }\n\n    private void setAuthors(String... authors) {\n        this.authors = Arrays.asList(authors);\n    }\n\n    @Override\n    public int compareTo(Book book) {\n        if(this.title.compareTo(book.title)==0){\n            return Integer.compare(this.year,book.year);\n        }\n\n        return this.title.compareTo(book.title);\n    }\n}\n", "ng bit_buf;\r\n\tpublic int bit_left;\r\n    public int[] buf;\r\n    public int buf_ptr, buf_end;\r\n    public int size_in_bits;\r\n\t\r\n}\r\n", "mbok.ToString;\n\n/**\n * @author : xiaomo\n */\n@Data\n@ToString(callSuper = false)\n@NoArgsConstructor\npublic class User {\n\n    private Long id;\n\n    private String name;\n\n    private Integer age;\n\n    public User(Long id, String name, Integer age) {\n        this.id = id;\n        this.name = name;\n        this.age = age;\n    }\n\n    public User(String name, Integer age) {\n        this.name = name;\n        this.age = age;\n    }\n\n}\n", "ComponentMapper;\nimport com.artemis.Entity;\nimport com.artemis.annotations.Wire;\nimport com.artemis.systems.EntityProcessingSystem;\nimport com.badlogic.gdx.graphics.Color;\nimport com.badlogic.gdx.graphics.OrthographicCamera;\nimport com.badlogic.gdx.graphics.glutils.ShapeRenderer;\nimport com.badlogic.gdx.math.Rectangle;\nimport com.badlogic.gdx.math.Vector2;\nimport io.piotrjastrzebski.monster.game.components.*;\n\n/**\n * Created by PiotrJ on 22/08/15.\n */\n@Wire\npublic class DebugRenderer extends EntityProcessingSystem {\n\tprotected ComponentMapper<Position> mPosition;\n\tprotected ComponentMapper<Rotation> mRotation;\n\tprotected ComponentMapper<Bounds> mBounds;\n\tprotected ComponentMapper<Tint> mTint;\n\n\t@Wire(name = \"game-cam\") OrthographicCamera camera;\n\t@Wire ShapeRenderer renderer;\n\n\tpublic DebugRenderer () {\n\t\tsuper(Aspect.all(Position.class, Rotation.class, Bounds.class));\n\t}\n\n\t@Override protected void begin () {\n\t\trenderer.setProjectionMatrix(camera.combined);\n\t\trenderer.begin(ShapeRenderer.ShapeType.Line);\n\t\trenderer.setColor(Color.WHITE);\n\t}\n\n\t@Override protected void process (Entity e) {\n\t\tVector2 pos = mPosition.get(e).pos;\n\t\tfloat rotation = mRotation.get(e).rotation;\n\t\tRectangle bounds = mBounds.get(e).bounds;\n\t\tTint tint = mTint.getSafe(e);\n\t\tif (tint != null) {\n\t\t\trenderer.setColor(tint.color);\n\t\t} else {\n\t\t\trenderer.setColor(Color.WHITE);\n\t\t}\n\t\trenderer.rect(pos.x, pos.y, bounds.width / 2, bounds.height / 2, bounds.width, bounds.height, 1, 1, rotation);\n\t}\n\n\t@Override protected void end () {\n\t\trenderer.end();\n\t}\n}\n", "05, 2006, 2007, 2008, 2009, 2010, 2011 John Currier\n *\n * SchemaSpy is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * SchemaSpy is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\npackage org.schemaspy.util;\n\nimport org.schemaspy.Config;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.lang.invoke.MethodHandles;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n\n/**\n * @author John Currier\n */\npublic class ConnectionURLBuilder {\n    private final Config config;\n    private final Properties dbType;\n    private final Logger LOGGER = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n\n    /**\n     * @param config\n     * @param properties\n     */\n    public ConnectionURLBuilder(Config config, Properties properties) {\n        this.config = config;\n        this.dbType = properties;\n    }\n\n    public String build() {\n        List<String> args = getArgs();\n        List<String> remaining = config.getRemainingParameters();\n        args.addAll(remaining);\n\n        String connectionURL = dbType.getProperty(\"connectionSpec\");\n        DbSpecificConfig dbConfig = new DbSpecificConfig(config.getDbType(), config.getDbProperties());\n        for (DbSpecificOption option : dbConfig.getOptions()) {\n            option.setValue(getParam(args, option));\n\n            LOGGER.debug(option.toString());\n\n            // replace e.g. <host> with myDbHost\n            connectionURL = connectionURL.replaceAll(\"\\\\<\" + option.getName() + \"\\\\>\", option.getValue());\n        }\n\n        for (DbSpecificOption option : dbConfig.getOptions()) {\n            int idx = remaining.indexOf(\"-\" + option.getName());\n            if (idx >= 0) {\n                remaining.remove(idx);  // -paramKey\n                remaining.remove(idx);  // paramValue\n            }\n        }\n\n        LOGGER.trace(\"connectionURL: {}\", connectionURL);\n\n        return connectionURL;\n    }\n\n    private List<String> getArgs() {\n        List<String> args = new ArrayList<>();\n\n        for (String key : config.getDbSpecificOptions().keySet()) {\n            args.add((key.startsWith(\"-\") ? \"\" : \"-\") + key);\n            args.add(config.getDbSpecificOptions().get(key));\n        }\n        return args;\n    }\n\n    private String getParam(List<String> args, DbSpecificOption option) {\n        String param = null;\n        int paramIndex = args.indexOf(\"-\" + option.getName());\n\n        if (paramIndex < 0) {\n            if (config != null)\n                param = config.getParam(option.getName());  // not in args...might be one of\n            // the common db params\n            if (\"hostOptionalPort\".equals(option.getName())) {\n                param = getHostOptionalPort();\n            }\n            if (param == null)\n                throw new Config.MissingRequiredParameterException(option.getName(), option.getDescription(), true);\n        } else {\n            args.remove(paramIndex);\n            param = args.get(paramIndex);\n            args.remove(paramIndex);\n        }\n\n        return param;\n    }\n\n    private String getHostOptionalPort() {\n        String hostOptionalPort = config.getHost();\n        if (hostOptionalPort == null) {\n            return null;\n        }\n        String hostPortSeparator = dbType.getProperty(\"hostPortSeparator\", \":\");\n        Integer port = config.getPort();\n        if (hostOptionalPort.contains(hostPortSeparator)) {\n            return hostOptionalPort;\n        }\n        if (port != null) {\n            return hostOptionalPort + hostPortSeparator + port;\n        }\n        return hostOptionalPort;\n    }\n}\n", ".support.wearable.activity.WearableActivity;\nimport android.util.Log;\nimport android.view.LayoutInflater;\nimport android.view.View;\n\nimport com.eveningoutpost.dexdrip.Models.BgReading;\nimport com.github.mikephil.charting.charts.LineChart;\nimport com.github.mikephil.charting.components.Legend;\nimport com.github.mikephil.charting.components.XAxis;\nimport com.github.mikephil.charting.components.YAxis;\nimport com.github.mikephil.charting.data.Entry;\nimport com.github.mikephil.charting.data.LineData;\nimport com.github.mikephil.charting.data.LineDataSet;\nimport com.github.mikephil.charting.utils.ColorTemplate;\n\nimport java.util.ArrayList;\n\n\npublic class MainActivity extends WearableActivity {\n    private View myLayout;\n\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        //setContentView(R.layout.activity_main);\n\n        Bundle extras = this.getIntent().getExtras();\n        if (extras != null && extras.getBoolean(\"stop\", true)) {\n            this.finish();\n        }\n        gsonstringobject();\n        // Inflate the layout that we're using for the watch face\n        LayoutInflater inflater = (LayoutInflater) getSystemService(Context.LAYOUT_INFLATER_SERVICE);\n        myLayout = inflater.inflate(R.layout.wear_drip_watchface_layout, null);\n\n\n        LineChart lineChart = (LineChart) myLayout.findViewById(R.id.chart);\n        lineChart.setDescription(\"\");\n        lineChart.setNoDataTextDescription(\"You need to provide data for the chart.\");\n\n        ArrayList<Entry> entries = new ArrayList<>();\n        entries.add(new Entry(4f, 0));\n        entries.add(new Entry(8f, 1));\n        entries.add(new Entry(6f, 2));\n        entries.add(new Entry(2f, 3));\n        entries.add(new Entry(18f, 4));\n        entries.add(new Entry(9f, 5));\n\n        LineDataSet dataset = new LineDataSet(entries, \"# of Calls\");\n\n        ArrayList<String> labels = new ArrayList<String>();\n        labels.add(\"January\");\n        labels.add(\"February\");\n        labels.add(\"March\");\n        labels.add(\"April\");\n        labels.add(\"May\");\n        labels.add(\"June\");\n\n        LineData data = new LineData(labels, dataset);\n        //dataset.setColors(ColorTemplate.COLORFUL_COLORS);\n        //dataset.setColors(ColorTemplate.VORDIPLOM_COLORS);\n        //dataset.setColors(ColorTemplate.JOYFUL_COLORS);\n        dataset.setColors(ColorTemplate.LIBERTY_COLORS);\n        //dataset.setColors(ColorTemplate.PASTEL_COLORS);\n        dataset.setDrawCubic(true);\n        dataset.setDrawFilled(true);\n        dataset.setDrawCircles(false);\n        dataset.setDrawValues(false);\n\n        lineChart.setPinchZoom(false);\n        lineChart.setDragEnabled(false);\n        lineChart.setScaleEnabled(false);\n        lineChart.setDrawGridBackground(false);\n        lineChart.setTouchEnabled(false);\n        lineChart.setData(data);\n        lineChart.animateY(5000);\n\n        // get the legend (only possible after setting data)\n        Legend l = lineChart.getLegend();\n        l.setEnabled(false);\n\n        XAxis xl = lineChart.getXAxis();\n        xl.setDrawGridLines(true);\n        xl.setEnabled(false);\n\n        YAxis leftAxis = lineChart.getAxisLeft();\n        leftAxis.setDrawGridLines(false);\n\n        YAxis rightAxis = lineChart.getAxisRight();\n        rightAxis.setEnabled(false);\n\n\n    }\n\n    public void gsonstringobject() {\n        BgReading m1BgReading;\n        m1BgReading = BgReading.last();\n        if (m1BgReading != null) {\n            String gsonstring = m1BgReading.toS();\n            Log.e(\"gson: \", gsonstring);\n        } else {\n            Log.e(\"gson: \", \"null\");\n        }\n    }\n}", "delUpdated;\n\nimport javax.swing.*;\nimport java.awt.*;\n\npublic class IntegerLabelView extends JPanel implements IModelUpdated {\n\n    //    Center align\n    final boolean CENTER_ALIGN = false;\n\n    //    Padding top\n    final int PADDING_TOP = 0;\n\n    //    Padding left\n    final int PADDING_LEFT = 0;\n\n    String text;\n    Value value;\n    int thickness;\n    float fontSize;\n    Color textColor;\n    boolean isLeftAlign;\n    int textWidth;\n\n    StyledLabel label;\n    IntegerView integerView;\n\n    public IntegerLabelView(\n            String text,\n            Value value,\n            int thickness,\n            float fontSize,\n            Color textColor,\n            boolean isLeftAlign,\n            int textWidth) {\n        this.text = text;\n        this.value = value;\n        this.thickness = thickness;\n        this.fontSize = fontSize;\n        this.textColor = textColor;\n        this.isLeftAlign = isLeftAlign;\n        this.textWidth = textWidth;\n    }\n\n    public void initialize() {\n        setLayout(null);\n        setBackground(getParent().getBackground());\n\n        this.label = new StyledLabel(text, fontSize, textColor, isLeftAlign);\n        label.setPreferredSize(new Dimension(textWidth, (int) getMinimumSize().getHeight()));\n        label.setMaximumSize(new Dimension(textWidth, (int) getMinimumSize().getHeight()));\n        label.setMinimumSize(new Dimension(textWidth, (int) getMinimumSize().getHeight()));\n        label.setBounds(PADDING_LEFT, PADDING_TOP, textWidth, (int) getMinimumSize().getHeight());\n        add(label);\n        label.repaint();\n\n        this.integerView = new IntegerView(value, fontSize, textColor, CENTER_ALIGN, thickness);\n        integerView.setPreferredSize(new Dimension((int) getMinimumSize().getWidth() - textWidth, (int) getMinimumSize().getHeight()));\n        integerView.setMaximumSize(new Dimension((int) getMinimumSize().getWidth() - textWidth, (int) getMinimumSize().getHeight()));\n        integerView.setMinimumSize(new Dimension((int) getMinimumSize().getWidth() - textWidth, (int) getMinimumSize().getHeight()));\n        integerView.setBounds(PADDING_LEFT + textWidth, PADDING_TOP, (int) getMinimumSize().getWidth() - textWidth, (int) getMinimumSize().getHeight());\n        add(integerView);\n        integerView.repaint();\n    }\n\n    @Override\n    public void modelChanged() {\n        integerView.modelChanged();\n    }\n}", " Jamie Mansfield <https://github.com/jamierocks>\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.neptunepowered.vanilla;\n\nimport net.canarymod.Canary;\nimport net.canarymod.api.Server;\nimport net.minecraft.server.MinecraftServer;\nimport org.neptunepowered.common.Neptune;\n\npublic class NeptuneVanilla {\n\n    public static void main(String[] args) {\n        MinecraftServer.main(args);\n        initNeptune();\n        Canary.setServer((Server) MinecraftServer.getServer());\n    }\n\n    private static void initNeptune() {\n        new Neptune();\n    }\n}\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage examples.ntp;\n\nimport org.apache.commons.net.ntp.NtpUtils;\nimport org.apache.commons.net.ntp.NtpV3Impl;\nimport org.apache.commons.net.ntp.NtpV3Packet;\nimport org.apache.commons.net.ntp.TimeStamp;\n\nimport java.io.IOException;\nimport java.net.DatagramPacket;\nimport java.net.DatagramSocket;\n\n/**\n * The SimpleNTPServer class is a UDP implementation of a server for the\n * Network Time Protocol (NTP) version 3 as described in RFC 1305.\n * It is a minimal NTP server that doesn't actually adjust the time but\n * only responds to NTP datagram requests with response sent back to\n * originating host with info filled out using the current clock time.\n * To be used for debugging or testing.\n *\n * To prevent this from interfering with the actual NTP service it can be\n * run from any local port.\n */\npublic class SimpleNTPServer implements Runnable {\n\n    private int port;\n\n    private volatile boolean running;\n    private boolean started;\n\n    private DatagramSocket socket;\n\n    /**\n     * Create SimpleNTPServer listening on default NTP port.\n     */\n    public SimpleNTPServer()\n    {\n        this(NtpV3Packet.NTP_PORT);\n    }\n\n    /**\n     * Create SimpleNTPServer.\n     *\n     * @param port the local port the server socket is bound to, or\n     *             <code>zero</code> for a system selected free port.\n     * @throws IllegalArgumentException if port number less than 0\n     */\n    public SimpleNTPServer(int port)\n    {\n        if (port < 0) {\n            throw new IllegalArgumentException();\n        }\n        this.port = port;\n    }\n\n    public int getPort()\n    {\n        return port;\n    }\n\n    /**\n     * Return state of whether time service is running.\n     *\n     * @return true if time service is running\n     */\n    public boolean isRunning()\n    {\n        return running;\n    }\n\n    /**\n     * Return state of whether time service is running.\n     *\n     * @return true if time service is running\n     */\n    public boolean isStarted()\n    {\n        return started;\n    }\n\n    /**\n     * Connect to server socket and listen for client connections.\n     *\n     * @throws IOException if an I/O error occurs when creating the socket.\n     */\n    public void connect() throws IOException\n    {\n        if (socket == null)\n        {\n            socket = new DatagramSocket(port);\n            // port = 0 is bound to available free port\n            if (port == 0) {\n                port = socket.getLocalPort();\n            }\n            System.out.println(\"Running NTP service on port \" + port + \"/UDP\");\n        }\n    }\n\n    /**\n     * Start time service and provide time to client connections.\n     *\n     * @throws java.io.IOException if an I/O error occurs when creating the socket.\n     */\n    public void start() throws IOException\n    {\n        if (socket == null)\n        {\n            connect();\n        }\n        if (!started)\n        {\n            started = true;\n            new Thread(this).start();\n        }\n    }\n\n    /**\n     * main thread to service client connections.\n     */\n    @Override\n    public void run()\n    {\n        running = true;\n        byte buffer[] = new byte[48];\n        final DatagramPacket request = new DatagramPacket(buffer, buffer.length);\n        do {\n            try {\n                socket.receive(request);\n                final long rcvTime = System.currentTimeMillis();\n                handlePacket(request, rcvTime);\n            } catch (IOException e) {\n                if (running)\n                {\n                    e.printStackTrace();\n                }\n                // otherwise socket thrown exception during shutdown\n            }\n        } while (running);\n    }\n\n    /**\n     * Handle incoming packet. If NTP packet is client-mode then respond\n     * to that host with a NTP response packet otherwise ignore.\n     *\n     * @param request incoming DatagramPacket\n     * @param rcvTime time packet received\n     *\n     * @throws IOException  if an I/O error occurs.\n     */\n    protected void handlePacket(DatagramPacket request, long rcvTime) throws IOException\n    {\n        NtpV3Packet message = new NtpV3Impl();\n        message.setDatagramPacket(request);\n        System.out.printf(\"NTP packet from %s mode=%s%n\", request.getAddress().getHostAddress(),\n                NtpUtils.getModeName(message.getMode()));\n        if (message.getMode() == NtpV3Packet.MODE_CLIENT) {\n            NtpV3Packet response = new NtpV3Impl();\n\n            response.setStratum(1);\n            response.setMode(NtpV3Packet.MODE_SERVER);\n            response.setVersion(NtpV3Packet.VERSION_3);\n            response.setPrecision(-20);\n            response.setPoll(0);\n            response.setRootDelay(62);\n            response.setRootDispersion((int) (16.51 * 65.536));\n\n            // originate time as defined in RFC-1305 (t1)\n            response.setOriginateTimeStamp(message.getTransmitTimeStamp());\n            // Receive Time is time request received by server (t2)\n            response.setReceiveTimeStamp(TimeStamp.getNtpTime(rcvTime));\n            response.setReferenceTime(response.getReceiveTimeStamp());\n            response.setReferenceId(0x4C434C00); // LCL (Undisciplined Local Clock)\n\n            // Transmit time is time reply sent by server (t3)\n            response.setTransmitTime(TimeStamp.getNtpTime(System.currentTimeMillis()));\n\n            DatagramPacket dp = response.getDatagramPacket();\n            dp.setPort(request.getPort());\n            dp.setAddress(request.getAddress());\n            socket.send(dp);\n        }\n        // otherwise if received packet is other than CLIENT mode then ignore it\n    }\n\n    /**\n     * Close server socket and stop listening.\n     */\n    public void stop()\n    {\n        running = false;\n        if (socket != null)\n        {\n            socket.close();  // force closing of the socket\n            socket = null;\n        }\n        started = false;\n    }\n\n    public static void main(String[] args)\n    {\n        int port = NtpV3Packet.NTP_PORT;\n        if (args.length != 0)\n        {\n            try {\n                port = Integer.parseInt(args[0]);\n            } catch (NumberFormatException nfe) {\n                nfe.printStackTrace();\n            }\n        }\n        SimpleNTPServer timeServer = new SimpleNTPServer(port);\n        try {\n            timeServer.start();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n\n}\n", "public interface UserService {\n    public void save(User user) ;\n    public List<User> findAll();\n    public User findByUsername(String username);\n}\n", "/\npublic interface EngineFactory {\n    /**\n     * \u521b\u5efa\u65b0\u9a8c\u8bc1\u7801\u5f15\u64ce\u3002\n     *\n     * @param captcha \u9a8c\u8bc1\u7801\u914d\u7f6e\u4fe1\u606f\u3002\n     * @return \u9a8c\u8bc1\u7801\u5f15\u64ce\u5b9e\u4f8b\u3002\n     */\n    CaptchaEngine createCaptchaEngine(CaptchaModel captcha);\n}\n", "static IECApi instance() {\n        if (instance == null) {\n            try {\n                instance = (IECApi) Class.forName(\"extracells.ECApiInstance\")\n                        .getMethod(\"instance\").invoke(null);\n            } catch (Exception e) {\n            }\n        }\n        return instance;\n    }\n}\n", "epository;\nimport org.apache.log4j.Logger;\nimport org.openqa.selenium.Platform;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.firefox.FirefoxDriver;\nimport org.openqa.selenium.firefox.FirefoxProfile;\nimport org.openqa.selenium.firefox.internal.ProfilesIni;\nimport org.openqa.selenium.remote.DesiredCapabilities;\nimport org.openqa.selenium.remote.RemoteWebDriver;\nimport org.openqa.selenium.safari.SafariDriver;\n\nimport java.net.URL;\n\n/**\n * Created by Antinomy on 15/7/8.\n */\npublic class DriverFactory {\n\n    private static Logger logger = Logger.getLogger(DriverFactory.class);\n\n    public static WebDriver getRunningEnv(String ruuningEnv) throws Exception {\n\n        WebDriver result = null;\n\n        PageConfRepository env = new PageConfRepository(\"env/runningEnv.yaml\");\n\n        DesiredCapabilities aDesiredcap = getDesiredCapabilities(ruuningEnv, env);\n\n        logger.info(\"read ruuningEnv: [\"+ruuningEnv+\"]!!\");\n        String runAt = env.getConf(ruuningEnv, \"RunAt\");\n        logger.info(\"RunAt: [\"+runAt+\"]!!\");\n\n        if (runAt.equalsIgnoreCase(\"local\")) {\n            result = newLocalDriver(aDesiredcap);\n            logger.info(\"new Local Driver Start !!\");\n            return result;\n        }\n\n        result = new RemoteWebDriver(new URL(runAt), aDesiredcap);\n        logger.info(\"new Remote WebDriver Start !!!\");\n        return result;\n    }\n\n    private static DesiredCapabilities getDesiredCapabilities(String ruuningEnv, PageConfRepository env) throws NoConfigException {\n        DesiredCapabilities aDesiredcap = new DesiredCapabilities();\n\n        String browerName = env.getConf(ruuningEnv, \"BrowserName\");\n        aDesiredcap.setBrowserName(browerName);\n\n        String browerVersion = env.getConf(ruuningEnv, \"Version\");\n        if (browerVersion != null && !browerVersion.equalsIgnoreCase(\"any\"))\n            aDesiredcap.setVersion(browerVersion);\n\n        String platform = env.getConf(ruuningEnv, \"Platform\");\n        aDesiredcap.setPlatform(getPlatform(platform));\n\n        initDriverPath(env, browerName, platform);\n\n        return aDesiredcap;\n    }\n\n    private static void initDriverPath(PageConfRepository env, String browerName, String platform) {\n\n        if (isChrome(browerName) && isMac(platform)) {\n            String chromeDriverPath = env.getDriverPath(\"ChromeDriver\", \"chromedriver\");\n            System.setProperty(\"webdriver.chrome.driver\", chromeDriverPath);\n            logger.info(\"InitDriverPath : \" + chromeDriverPath);\n        }\n\n    }\n\n    private static WebDriver newLocalDriver(DesiredCapabilities aDesiredcap) {\n        WebDriver result = null;\n        String browserName = aDesiredcap.getBrowserName();\n\n        if (isFirefox(browserName)) {\n            ProfilesIni allProfiles = new ProfilesIni();\n            FirefoxProfile profile = allProfiles.getProfile(\"default\");\n            profile.setEnableNativeEvents(true);\n            profile.setPreference(\"IsRelative\",0);\n\n            result = new FirefoxDriver(profile);\n            return result;\n        }\n\n        if (isSafari(browserName)) {\n            result = new SafariDriver(aDesiredcap);\n            return result;\n        }\n\n        if (isChrome(browserName)) {\n            result = new ChromeDriver(aDesiredcap);\n            return result;\n        }\n\n        return result;\n    }\n\n    private static boolean isChrome(String browserName) {\n        return browserName.equalsIgnoreCase(\"chrome\");\n    }\n\n    private static boolean isSafari(String browserName) {\n        return browserName.equalsIgnoreCase(\"safari\");\n    }\n\n    private static boolean isFirefox(String browserName) {\n        return browserName.equalsIgnoreCase(\"firefox\");\n    }\n\n    private static Platform getPlatform(String platform) {\n\n        if (isMac(platform))\n            return Platform.MAC;\n\n        if (isLinux(platform))\n            return Platform.LINUX;\n\n        if (isWindows(platform))\n            return Platform.WINDOWS;\n\n        return Platform.ANY;\n    }\n\n    private static boolean isWindows(String platform) {\n        return platform.equalsIgnoreCase(\"WINDOWS\");\n    }\n\n    private static boolean isLinux(String platform) {\n        return platform.equalsIgnoreCase(\"LINUX\");\n    }\n\n    private static boolean isMac(String platform) {\n        return platform.equalsIgnoreCase(\"MAC\");\n    }\n\n}\n", "ereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\npackage blue.lapis.common.schedule;\n\nimport blue.lapis.common.schedule.time.Duration;\nimport blue.lapis.common.schedule.time.RealDuration;\nimport blue.lapis.common.schedule.time.RealTime;\n\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\n\npublic class TimeTest {\n\n    @Before\n    public void initTests() {\n\n    }\n\n    @Test\n    public void reversible() {\n        long fiveSeconds = (long) RealDuration.minutes(RealDuration.seconds(5).asMinutes()).asSeconds();\n        Assert.assertEquals(5L, fiveSeconds);\n\n        fiveSeconds = (long) RealDuration.centuries(RealDuration.seconds(5).asCenturies()).asSeconds();\n        Assert.assertEquals(5L, fiveSeconds);\n    }\n\n    @Test\n    public void knownAmounts() {\n        long twoMinutes = (long) RealDuration.seconds(120).asMinutes();\n        Assert.assertEquals(2L, twoMinutes);\n\n        //TODO: large, out-of-phase known amounts\n    }\n\n    @Test\n    public void checkUnits() {\n        //All of these quantities are super well known. Every one of these should be millisecond-accurate.\n\n        Assert.assertEquals(Duration.ONE_WEEK.asMilliseconds(), RealDuration.days(7).asMilliseconds());\n\n        Assert.assertEquals(Duration.ONE_DAY.asMilliseconds(), RealDuration.hours(24).asMilliseconds());\n\n        Assert.assertEquals(Duration.ONE_HOUR.asMilliseconds(), RealDuration.minutes(60).asMilliseconds());\n\n        Assert.assertEquals(Duration.ONE_MINUTE.asMilliseconds(), RealDuration.seconds(60).asMilliseconds());\n\n        //This one *seems* kind of superfluous, but it's good to run it through the whole wringer anyway.\n        Assert.assertEquals(Duration.ONE_SECOND.asMilliseconds(),\n                RealDuration.milliseconds(1000).asMilliseconds());\n    }\n\n    @Test\n    public void stringOutput() {\n        //verify that RealDuration.toString() outputs correct, readable information.\n\n        String display = new RealTime.DurationBuilder()\n                .years(1)\n                .seconds(10)\n                .build()\n                .toString();\n\n        Assert.assertEquals(\"1 years 10 sec\", display);\n\n        display = new RealTime.DurationBuilder()\n                .seconds(81)\n                .milliseconds(13861)\n                .build()\n                .toString();\n\n        Assert.assertEquals(\"1 min 34 sec 861 msec\", display);\n\n        display = RealDuration.seconds(0).toString();\n\n        Assert.assertEquals(\"zero\", display);\n\n        display = RealDuration.hours(-10).toString();\n\n        Assert.assertEquals(\"-10 hr\", display);\n    }\n\n}", "List;\n\nimport de.greenrobot.event.EventBus;\nimport retrofit.RestAdapter;\nimport yss.sheldon.ychacknews.service.StoryService;\n\n\n/**\n * Created by yss on 9/28/2015.\n */\npublic class TopStoryJob extends ApiJob {\n\n    @Override\n    public void onAdded() {\n\n    }\n\n    @Override\n    public void onRun() throws Throwable {\n        StoryService service = adapter.create(StoryService.class);\n        List<Integer> list = service.GetTopStories();\n        if (list != null && list.size() > 0) {\n            EventBus.getDefault().post(list);\n        }\n    }\n\n    @Override\n    protected void onCancel() {\n\n    }\n}\n", "gerFactory;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.kafka.core.KafkaTemplate;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class Sender {\n\n\tprivate static final Logger LOGGER = LoggerFactory.getLogger(Sender.class);\n\n\t@Autowired\n\tprivate KafkaTemplate<String, String> kafkaTemplate;\n\n\tpublic void send(String topic, String payload) {\n\t\tLOGGER.info(\"sending payload='{}' to topic='{}'\", payload, topic);\n\t\tkafkaTemplate.send(topic, payload);\n\t}\n}\n", ".enums.StudantsEnum.LASTNAME;\n\nimport java.util.Deque;\n\nimport javax.xml.stream.events.StartElement;\n\nimport br.com.mlassakoski.xml.entities.models.ParserDTO;\nimport org.springframework.stereotype.Component;\n\nimport br.com.mlassakoski.xml.entities.enums.StudantsEnum;\nimport br.com.mlassakoski.xml.entities.interfaces.StartElementParseInterface;\n\n@Component\npublic class StartLastName implements StartElementParseInterface {\n\n    @Override\n    public void parse(final StartElement startElement, final StudantsEnum tag,\n                      Deque<StudantsEnum> stack, ParserDTO parserDTO) {\n\n        stack.push(LASTNAME);\n    }\n}\n", "AsReturn(int i) {\n        String retVal = \"\";\n        switch (i) {\n        case 0:\n            retVal = \"foo\";\n            break;\n        case 1:\n            retVal = \"foo\";\n            break;\n        default:\n            retVal = \"fizzbuzz\";\n        }\n        return retVal;\n    }\n    \n    public String fieldSameAsReturn(int i) {\n        switch (i) {\n        case 0:\n            thing = \"foo\";\n            return thing;\n        case 1:\n            thing = \"foo\";\n            return thing;\n        default:\n            thing = \"fizzbuzz\";\n        }\n        return thing;\n    }\n    \n    public StringBuilder localDiffAsReturn(int i) {\n        String retVal = \"\";\n        switch (i) {\n        case 0:\n            retVal = \"foo\";\n            break;\n        case 1:\n            retVal = \"foo\";\n            break;\n        default:\n            retVal = \"fizzbuzz\";\n        }\n        return new StringBuilder(retVal);\n    }\n    \n    public StringBuilder fieldDiffAsReturn(int i) {\n        switch (i) {\n        case 0:\n            thing = \"foo\";\n            break;\n        case 1:\n            thing = \"foo\";\n            break;\n        default:\n            thing = \"fizzbuzz\";\n        }\n        return new StringBuilder(thing);\n    }\n    \n    @Override\n    public String toString() {\n        return thing;\n    }\n\n}\n"], "perplexity": [2.1374714374542236, 1.956141710281372, 2.586782693862915, 2.4912455081939697, 3.3689379692077637, 3.28951096534729, 2.525338888168335, 3.69714093208313, 3.3262100219726562, 3.5220630168914795, 1.9016848802566528, 2.6620070934295654, 3.1795008182525635, 2.726290702819824, 2.9523086547851562, 1.5214593410491943, 5.00199556350708, 1.3627052307128906, 1.9720090627670288, 2.616001605987549, 2.9028282165527344, 11.7232084274292, 2.519761085510254, 1.8514013290405273, 2.833902597427368, 2.9140353202819824, 2.703411340713501, 2.1258153915405273, 2.935755968093872, 9.011569023132324, 1.5744999647140503, 2.492582082748413, 3.935495615005493, 1.8652665615081787, 2.3181138038635254, 2.7128047943115234, 2.1903154850006104, 1.378975510597229, 2.5592074394226074, 3.215013265609741, 2.424612045288086, 3.5260589122772217, 2.0764262676239014, 2.200043201446533, 10.39413070678711, 1.4621403217315674, 1.4245085716247559, 1.7396422624588013, 3.2224767208099365, 4.201987266540527, 3.08573579788208, 7.657949447631836, 1.691694736480713, 4.391510963439941, 2.497802257537842, 3.253493547439575, 1.6196988821029663, 3.2519400119781494, 2.920330047607422, 2.5573174953460693, 2.2068517208099365, 1.9887710809707642, 1.8202582597732544, 1.9525033235549927, 1.9120163917541504, 6.979090213775635, 4.0736565589904785, 3.924044132232666, 2.2834835052490234, 2.439919948577881, 1.433060646057129, 2.63558030128479, 3.5897388458251953, 5.505353927612305, 1.847861409187317, 3.3939409255981445, 2.8851420879364014, 3.069120407104492, 1.5561784505844116, 5.039539337158203, 2.511812448501587, 4.429023742675781, 2.1188747882843018, 2.4715094566345215, 2.2557525634765625, 2.351022720336914, 3.126237154006958, 1.9597203731536865, 2.2635834217071533, 3.5653316974639893, 2.2238988876342773, 8.493365287780762, 3.088935613632202, 2.7529921531677246, 2.991299867630005, 2.6705024242401123, 1.8101459741592407, 1.9431074857711792, 2.27826189994812, 3.1824352741241455, 1.6098226308822632, 6.4976983070373535, 2.8764636516571045, 2.352785587310791, 2.343079090118408, 3.317863941192627, 2.9966366291046143, 2.3233797550201416, 5.865996360778809, 1.6611390113830566, 2.7550816535949707, 2.4019908905029297, 6.176769256591797, 2.190575361251831, 21.47838592529297, 2.1234896183013916, 3.0583419799804688, 4.428837776184082, 2.045748233795166, 2.7839345932006836, 8.934185028076172, 2.175644636154175, 1.6391597986221313, 2.571930408477783, 2.727562665939331, 2.925649881362915, 1.7377266883850098, 3.9372544288635254, 1.2369346618652344, 2.6783735752105713, 1.4468742609024048, 2.217237949371338, 2.194016456604004, 2.2698633670806885, 6.080809116363525, 1.806623935699463, 5.927984237670898, 3.50602650642395, 1.7915374040603638, 2.56466007232666, 2.7169721126556396, 1.9761950969696045, 3.7197635173797607, 6.456546306610107, 8.738669395446777, 1.3898234367370605, 3.8760673999786377, 3.5241966247558594, 3.4516215324401855, 2.792158365249634, 4.163724899291992, 2.342219352722168, 4.273374080657959, 1.9239983558654785, 1.5654090642929077, 4.095631122589111, 5.442704200744629, 4.848148345947266, 4.753547668457031, 9.929511070251465, 2.0861010551452637, 2.1284995079040527, 2.9947824478149414, 2.2209341526031494, 1.6423307657241821, 1.2468165159225464, 4.414646625518799, 3.9250288009643555, 5.566458702087402, 2.9259681701660156, 2.6383392810821533, 2.5232083797454834, 2.050114154815674, 1.7419782876968384, 2.8675038814544678, 4.393404960632324, 4.0664591789245605, 2.2894105911254883, 7.711296081542969, 3.32250714302063, 2.0553133487701416, 2.3626954555511475, 2.1819334030151367, 11.144680976867676, 1.5170706510543823, 1.9074960947036743, 2.589681386947632, 2.151258945465088, 2.882341146469116, 1.9618792533874512, 2.0102081298828125, 2.360109329223633, 7.368359088897705, 1.9684417247772217, 2.0080535411834717, 2.876047372817993, 2.3917486667633057, 3.3813319206237793, 1.812924861907959, 2.3788020610809326, 1.4680589437484741, 2.2890453338623047, 8.988178253173828, 2.9978973865509033, 2.184343099594116, 1.450774908065796, 3.296304225921631, 4.739066123962402, 1.9047462940216064, 4.71494722366333, 2.4420769214630127, 2.777392625808716, 2.3280575275421143, 1.9879534244537354, 1.9483847618103027, 2.999366283416748, 2.7782058715820312, 3.010915994644165, 3.276724338531494, 3.3138585090637207, 2.1721091270446777, 2.35386061668396, 1.6979920864105225, 1.9140232801437378, 4.143197536468506, 2.228344202041626, 2.606156826019287, 1.8019278049468994, 1.7922680377960205, 1.6796690225601196, 2.502706527709961, 3.1149706840515137, 1.8762273788452148, 8.534627914428711, 4.644839763641357, 1.7335712909698486, 2.2161874771118164, 2.9635777473449707, 8.931320190429688, 1.4956165552139282, 3.4146218299865723, 2.3039207458496094, 3.3014981746673584, 1.879045844078064, 3.0998027324676514, 2.6674463748931885, 2.5462191104888916, 2.8562238216400146, 3.9268798828125, 10.063234329223633, 3.7109217643737793, 2.112591505050659, 2.1643524169921875, 2.6190173625946045, 1.9475139379501343, 3.21360445022583, 1.6539870500564575, 3.8089494705200195, 2.080974578857422, 1.1860123872756958, 1.9471665620803833, 2.9847772121429443, 4.372393608093262, 4.067997455596924, 2.878063917160034, 3.958566188812256, 2.3137311935424805, 7.909201145172119, 1.739776372909546, 2.803764581680298, 2.268549680709839, 1.9064745903015137, 2.9359066486358643, 2.8552374839782715, 2.8436245918273926, 1.8290812969207764, 2.476158618927002, 2.8854546546936035, 3.47648024559021, 3.2244820594787598, 2.7368061542510986, 10.123132705688477, 1.9136457443237305, 3.329986810684204, 2.0455691814422607, 1.7777622938156128, 2.7147676944732666, 3.8800301551818848, 2.599149703979492, 2.0233020782470703, 3.582317590713501, 1.9299421310424805, 4.45115327835083, 4.043128967285156, 2.727246046066284, 2.928867816925049, 3.077547311782837, 2.5456531047821045, 4.258008003234863, 1.567214846611023, 1.7631285190582275, 4.208292007446289, 7.3748698234558105, 5.645241737365723, 4.805611610412598, 2.265676975250244, 2.695751190185547, 2.200819730758667, 7.006647109985352, 3.9195897579193115, 4.980080604553223, 2.017645835876465, 1.9594058990478516, 2.2355401515960693, 21.87820053100586, 2.8833844661712646, 3.479336977005005, 1.498600959777832, 4.229506015777588, 2.641753673553467, 2.563981056213379, 4.206336498260498, 3.546701669692993, 1.607308268547058, 3.4191503524780273, 3.1308224201202393, 4.443979263305664, 6.210417747497559, 2.2991671562194824, 2.1557676792144775, 2.1574835777282715, 3.22029709815979, 3.1292412281036377, 3.0974316596984863, 3.2434961795806885, 3.3242671489715576, 1.6608208417892456, 4.440563678741455, 3.6681969165802, 3.234734535217285, 2.748795986175537, 2.6432762145996094, 2.8937079906463623, 1.8323884010314941, 2.1849594116210938, 3.6009111404418945, 1.980330228805542, 9.995985984802246, 3.907472610473633, 2.5392682552337646, 2.920492172241211, 1.6257933378219604, 2.0540931224823, 3.300039529800415, 1.7890465259552002, 1.9234334230422974, 2.69313645362854, 14.625114440917969, 2.940380573272705, 3.1255080699920654, 1.8070807456970215, 2.9303667545318604, 6.70625638961792, 9.777400970458984, 2.0939435958862305, 11.53403091430664, 1.8610223531723022, 6.942326068878174, 3.485123634338379, 3.8494014739990234, 3.6471974849700928, 2.0593597888946533, 3.549895763397217, 2.148489475250244, 2.5679140090942383, 3.371695041656494, 3.509819984436035, 1.6951922178268433, 2.120976686477661, 3.083010673522949, 2.7838995456695557, 5.380552291870117, 3.6764769554138184, 4.511595249176025, 2.9725780487060547, 2.2442827224731445, 2.4544425010681152, 3.6881165504455566, 4.383715629577637, 2.7575061321258545, 1.7204246520996094, 3.8085691928863525, 1.9130778312683105, 2.795435905456543, 3.1646900177001953, 4.462813854217529, 3.5701372623443604, 4.033529281616211, 2.0197880268096924, 1.9232996702194214, 3.229414939880371, 4.898054122924805, 2.259058952331543, 31.02940559387207, 2.1619772911071777, 2.493454933166504, 2.420196771621704, 3.570690155029297, 5.088076114654541, 8.264632225036621, 4.078917503356934, 3.7049121856689453, 4.804901123046875, 3.174520254135132, 2.342864990234375, 2.4902708530426025, 2.5923666954040527, 4.114044666290283, 2.3413496017456055, 2.675656795501709, 2.837869167327881, 2.0308542251586914, 3.796642780303955, 2.7670235633850098, 31.141382217407227, 8.327559471130371, 7.664018630981445, 2.2844059467315674, 7.750773906707764, 3.8676793575286865, 2.335663318634033, 1.7814393043518066, 2.3683695793151855, 2.019714593887329, 3.6202285289764404, 4.1721882820129395, 9.008785247802734, 2.103545665740967, 3.057526111602783, 2.8977930545806885, 1.5355623960494995, 1.5495516061782837, 4.574309825897217, 1.581479787826538, 2.9861228466033936, 1.8703707456588745, 2.6549651622772217, 3.193589687347412, 4.92624044418335, 1.9783287048339844, 3.386084794998169, 1.7276581525802612, 3.4366796016693115, 3.528787136077881, 2.400839328765869, 15.087031364440918, 2.487813711166382, 2.5633795261383057, 6.065127849578857, 8.323225021362305, 3.9746508598327637, 2.330556869506836, 27.999540328979492, 2.1254892349243164, 9.489684104919434, 3.9699106216430664, 1.5314027070999146, 2.9196319580078125, 7.575669288635254, 2.65779972076416, 2.2242066860198975, 3.1181514263153076, 3.847679853439331, 2.199955940246582, 2.5829508304595947, 1.7977330684661865, 1.974897861480713, 4.834253787994385, 1.8619378805160522, 2.816288471221924, 2.59293532371521, 2.436523675918579, 1.730378270149231, 2.6283771991729736, 3.227032423019409, 5.791755199432373, 2.885676622390747, 3.0080490112304688, 2.4739861488342285, 3.3845691680908203, 1.9797286987304688, 1.728067398071289, 3.6678590774536133, 2.6345880031585693, 5.180678844451904, 1.843888759613037, 2.3063623905181885, 2.218446969985962, 1.8979430198669434, 1.9614691734313965, 3.1653668880462646, 2.284609079360962, 2.827409267425537, 7.8547773361206055, 2.9367024898529053, 2.9032540321350098, 2.941746950149536, 2.5628812313079834, 1.8493554592132568, 3.3823680877685547, 2.2192320823669434, 2.4128403663635254, 2.5757479667663574, 2.299865961074829, 1.7566555738449097, 33.794960021972656, 2.5727529525756836, 2.2602884769439697, 1.4438011646270752, 8.150004386901855, 3.7944395542144775, 2.8125500679016113, 2.9578661918640137, 3.255368232727051, 2.177232027053833, 2.448474407196045, 1.2691980600357056, 3.450368642807007, 4.651523113250732, 3.569263458251953, 1.5150986909866333, 4.42883825302124, 4.77266263961792, 5.138064861297607, 2.5466489791870117, 2.5573742389678955, 3.126132011413574, 2.957249641418457, 3.080872058868408, 3.3357136249542236, 26.83222770690918, 2.6496782302856445, 2.564159393310547, 1.7717387676239014, 8.204896926879883, 7.1521077156066895, 2.6512293815612793, 1.9211910963058472, 3.093491315841675, 2.8258113861083984, 4.915165901184082, 2.6888508796691895, 1.812941074371338, 1.317772388458252, 20.839832305908203, 3.038039207458496, 1.7706211805343628, 3.2894604206085205, 4.273905277252197, 3.587345838546753, 7.79587984085083, 4.721846103668213, 1.436189889907837, 2.599708080291748, 3.9694252014160156, 2.7968292236328125, 2.2055470943450928, 2.770977020263672, 2.224220037460327, 4.363404273986816, 3.8227546215057373, 3.3835389614105225, 1.87931227684021, 2.0414187908172607, 4.158781051635742, 4.03015661239624, 1.7558965682983398, 4.036752223968506, 1.7995096445083618, 9.124100685119629, 2.4495553970336914, 1.6181769371032715, 4.009059429168701, 5.046307563781738, 1.9974827766418457, 5.072757244110107, 10.759811401367188, 9.528228759765625, 1.7515703439712524, 2.2601311206817627, 2.5089199542999268, 2.293900489807129, 2.603144407272339, 2.2570486068725586, 3.8817687034606934, 3.088627815246582, 3.688997745513916, 2.0271527767181396, 2.9918782711029053, 5.870332717895508, 2.0963921546936035, 1.8104218244552612, 3.708641290664673, 1.4611021280288696, 21.58533477783203, 3.6124463081359863, 2.1141488552093506, 2.689570665359497, 2.156982183456421, 3.4031693935394287, 3.38219952583313, 3.5008904933929443, 3.91153621673584, 59.23561096191406, 2.6584105491638184, 2.1158690452575684, 1.580889344215393, 2.916545867919922, 2.21867299079895, 1.9318079948425293, 4.248750686645508, 33.86764907836914, 6.862664699554443, 2.7728195190429688, 4.710058689117432, 3.342061996459961, 8.243834495544434, 3.377044439315796, 3.836045503616333, 1.8346097469329834, 3.4317121505737305, 2.284736156463623, 2.5209691524505615, 1.8334417343139648, 2.7232165336608887, 1.8285614252090454, 1.6934012174606323, 2.838892698287964, 16.774749755859375, 1.861236572265625, 1.6834737062454224, 2.2179958820343018, 1.9703726768493652, 3.846569776535034, 2.4826908111572266, 5.132565498352051, 1.8874112367630005, 4.118143081665039, 3.4023144245147705, 4.726253509521484, 2.3829164505004883, 3.0434136390686035, 2.0804803371429443, 3.965428352355957, 2.422051191329956, 3.0524039268493652, 2.6416831016540527, 4.900489807128906, 3.9663076400756836, 1.3771761655807495, 1.7999221086502075, 7.648251533508301, 7.3481926918029785, 3.088813304901123, 1.3237072229385376, 1.9245760440826416, 28.11233901977539, 3.0451231002807617, 1.6576355695724487, 2.939007520675659, 2.451080560684204, 4.665825843811035, 1.8887255191802979, 2.739537239074707, 2.7684550285339355, 1.5986710786819458, 2.5723185539245605, 2.317051887512207, 4.451034069061279, 3.5218923091888428, 3.591076612472534, 4.881559371948242, 5.747885227203369, 4.191105842590332, 2.4832603931427, 2.131396532058716, 1.6288716793060303, 1.7335985898971558, 3.0828306674957275, 6.108210563659668, 2.2448830604553223, 3.159925699234009, 2.8622348308563232, 4.479990482330322, 4.7265424728393555, 4.382896900177002, 1.8521709442138672, 3.497133255004883, 2.165175676345825, 2.4910874366760254, 1.7703607082366943, 3.1973013877868652, 3.8375778198242188, 2.3706419467926025, 2.4498188495635986, 2.5484485626220703, 1.817151665687561, 3.5494041442871094, 2.852583646774292, 2.3920187950134277, 2.6906816959381104, 17.259836196899414, 1.5682915449142456, 2.648794412612915, 3.3605244159698486, 3.3723506927490234, 2.504042863845825, 2.2720816135406494, 2.597616195678711, 2.6189517974853516, 2.9297590255737305, 3.3803341388702393, 1.7272510528564453, 2.461918830871582, 2.282042980194092, 1.7353566884994507, 2.1271603107452393, 2.6211440563201904, 1.615968108177185, 12.77430534362793, 3.10833477973938, 3.8707733154296875, 2.8378841876983643, 2.121915102005005, 2.8878133296966553, 1.992571234703064, 1.4272425174713135, 1.5911003351211548, 7.813806533813477, 1.5202516317367554, 2.7950963973999023, 4.6174492835998535, 2.452833652496338, 1.7586561441421509, 2.881387710571289, 3.6953866481781006, 2.9564690589904785, 3.1151974201202393, 2.6478402614593506, 2.058525800704956, 1.873948574066162, 1.6383041143417358, 2.3363800048828125, 1.9598323106765747, 3.6566848754882812, 2.2798798084259033, 3.7025716304779053, 4.045572280883789, 2.639514684677124, 6.714824676513672, 2.7264552116394043, 2.217552900314331, 2.580024242401123, 1.927760362625122, 3.065113067626953, 3.7003655433654785, 2.9033501148223877, 4.2673234939575195, 5.419307708740234, 9.672489166259766, 2.752849817276001, 1.635780692100525, 3.2303855419158936, 2.6617958545684814, 1.9955486059188843, 2.574816942214966, 2.862658977508545, 2.5172853469848633, 3.437241315841675, 2.6378111839294434, 2.8918824195861816, 4.47022008895874, 2.6120686531066895, 2.6687920093536377, 2.3072381019592285, 3.1621925830841064, 5.744387149810791, 1.8865715265274048, 3.1621968746185303, 2.1855063438415527, 2.1071648597717285, 7.439736366271973, 14.82382583618164, 2.84193754196167, 2.5171642303466797, 1.5387306213378906, 1.8456870317459106, 15.486763000488281, 2.3109962940216064, 1.9699681997299194, 1.9198598861694336, 4.873611927032471, 1.428116798400879, 1.8568100929260254, 1.7752552032470703, 2.7006888389587402, 2.411388874053955, 2.153320550918579, 3.4648334980010986, 3.2952685356140137, 3.7820096015930176, 5.599423885345459, 47.28478240966797, 3.4996798038482666, 11.286378860473633, 2.881025791168213, 3.484659194946289, 3.8537347316741943, 2.974292039871216, 19.39089012145996, 4.339775085449219, 3.159787654876709, 3.3964295387268066, 2.000474214553833, 2.361145257949829, 2.4504103660583496, 2.512615442276001, 1.3234894275665283, 2.0033438205718994, 3.2853424549102783, 2.0176689624786377, 4.794442176818848, 2.1234591007232666, 2.976142644882202, 3.1252968311309814, 3.4652462005615234, 2.0409274101257324, 2.025075912475586, 18.377473831176758, 8.028855323791504, 4.033350944519043, 2.2899208068847656, 1.563530683517456, 3.831796407699585, 2.371333360671997, 2.1174545288085938, 2.226868152618408, 2.061631441116333, 1.719398856163025, 3.2053141593933105, 6.185389518737793, 1.8955191373825073, 36.17152786254883, 1.7908971309661865, 1.9753222465515137, 1.6504786014556885, 4.1372785568237305, 1.9921869039535522, 1.504271388053894, 1.5236303806304932, 4.902891159057617, 3.5600039958953857, 1.5872807502746582, 2.2745730876922607, 3.208383798599243, 3.2537336349487305, 3.326552152633667, 2.644512414932251, 3.4953904151916504, 2.7245864868164062, 1.4433658123016357, 2.939598560333252, 2.602100372314453, 2.1333515644073486, 2.721652030944824, 1.680165410041809, 3.2629780769348145, 2.566988945007324, 2.8223977088928223, 2.930304527282715, 2.901772975921631, 2.5445337295532227, 2.120328426361084, 2.949812412261963, 3.655158042907715, 5.1879401206970215, 3.0708577632904053, 3.409095287322998, 2.2689361572265625, 3.2266054153442383, 2.6469614505767822, 3.661911964416504, 3.719778299331665, 2.4779748916625977, 1.835167646408081, 2.6313817501068115, 1.899024248123169, 2.8729727268218994, 3.563152313232422, 6.124302864074707, 1.6943079233169556, 1.851995587348938, 1.756575107574463, 2.7030792236328125, 1.3976423740386963, 3.3408799171447754, 2.5875422954559326, 1.7280343770980835, 1.9885964393615723, 4.45276403427124, 2.5840353965759277, 10.534326553344727, 1.2681831121444702, 1.8435167074203491, 2.6201555728912354, 2.878981590270996, 2.320362091064453, 3.414064407348633, 5.01443338394165, 2.546677827835083, 2.7554588317871094, 42.69488525390625, 2.2865569591522217, 1.3928260803222656, 2.456080436706543, 11.754328727722168, 1.6323786973953247, 1.9319933652877808, 1.9572428464889526, 3.9771411418914795, 3.1313765048980713, 2.0679776668548584, 1.948127031326294, 3.3590564727783203, 4.494779109954834, 2.178799867630005, 1.8822143077850342, 2.511204957962036, 1.8426564931869507, 2.1215100288391113, 1.424471139907837, 5.687509536743164, 2.5161120891571045, 2.8439104557037354, 2.4461071491241455, 7.420658111572266, 2.220773935317993, 3.1765456199645996, 3.0846145153045654, 2.147433280944824, 2.189256191253662, 2.775453567504883, 2.3245978355407715, 7.796592712402344, 7.087671279907227, 2.830658197402954, 2.602255344390869, 2.3714261054992676, 1.9250253438949585, 4.495635032653809, 3.0752904415130615, 3.2390642166137695, 1.6354010105133057, 2.3663299083709717, 1.5347479581832886, 2.8778553009033203, 2.3081893920898438, 2.4952375888824463, 2.3745505809783936, 1.3689242601394653, 2.4529647827148438, 2.6388845443725586, 2.8250648975372314, 2.0137033462524414, 2.6667935848236084, 10.794893264770508, 3.277465343475342, 1.6690964698791504, 2.2229721546173096, 3.3068645000457764, 5.150254249572754, 2.748368263244629, 1.7459410429000854, 8.604736328125, 2.39265513420105, 3.3097846508026123, 2.4646151065826416, 3.0496888160705566, 2.157911777496338, 1.9105442762374878, 2.986084461212158, 3.8543407917022705, 3.6536521911621094, 4.156759262084961, 2.331247329711914, 2.549776315689087, 6.171150207519531, 2.376837730407715, 4.706736087799072, 1.9522991180419922], "avg_perplexity": 3.719331268787384}
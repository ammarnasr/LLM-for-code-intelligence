{"text": ["\nimport org.apache.commons.lang.builder.ToStringBuilder;\nimport org.apache.commons.lang.builder.ToStringStyle;\n\npublic class QueryCommandPacket extends CommandPacket {\n\n\tprivate String queryString;\n\n\tpublic QueryCommandPacket() {\n\t\tsetCommand((byte) 0x03);\n\t}\n\n\tpublic void fromBytes(byte[] data) throws IOException {\n\t}\n\n\tpublic byte[] toBytes() throws IOException {\n\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n\t\tout.write(getCommand());\n\t\tout.write(getQueryString().getBytes(\"UTF-8\"));// \u94fe\u63a5\u5efa\u7acb\u65f6\u9ed8\u8ba4\u6307\u5b9a\u7f16\u7801\u4e3aUTF-8\n\t\treturn out.toByteArray();\n\t}\n\n\tpublic void setQueryString(String queryString) {\n\t\tthis.queryString = queryString;\n\t}\n\n\tpublic String getQueryString() {\n\t\treturn queryString;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\tString s = ToStringBuilder.reflectionToString(this,\n\t\t\t\tToStringStyle.MULTI_LINE_STYLE);\n\t\treturn s;\n\t}\n}\n", "ements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.apache.deltaspike.security.impl.authorization;\n\nimport java.lang.annotation.Annotation;\nimport java.lang.reflect.Method;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\nimport javax.enterprise.context.spi.CreationalContext;\nimport javax.enterprise.inject.spi.Annotated;\nimport javax.enterprise.inject.spi.InjectionPoint;\nimport javax.interceptor.InvocationContext;\n\nimport org.apache.deltaspike.core.util.metadata.builder.ParameterValueRedefiner;\nimport org.apache.deltaspike.security.api.authorization.annotation.SecurityParameterBinding;\n\n/**\n * Responsible for supplying requested method invocation values to the security binding method.\n */\npublic class SecurityParameterValueRedefiner implements ParameterValueRedefiner\n{\n    private CreationalContext<?> creationalContext;\n    private InvocationContext invocation;\n\n    public SecurityParameterValueRedefiner(CreationalContext<?> creationalContext, InvocationContext invocation)\n    {\n        this.invocation = invocation;\n        this.creationalContext = creationalContext;\n    }\n\n    @Override\n    public Object redefineParameterValue(ParameterValue value)\n    {\n\n        InjectionPoint injectionPoint = value.getInjectionPoint();\n        if (injectionPoint != null)\n        {\n            if (value.getInjectionPoint().getAnnotated().getBaseType().equals(InvocationContext.class))\n            {\n                return invocation;\n            }\n            else\n            {\n                Annotated securingParameterAnnotatedType = injectionPoint.getAnnotated();\n                Set<Annotation> securingParameterAnnotations = securingParameterAnnotatedType.getAnnotations();\n\n                Set<Annotation> requiredBindingAnnotations = new HashSet<Annotation>();\n                for (Annotation annotation : securingParameterAnnotations)\n                {\n                    if (annotation.annotationType().isAnnotationPresent(SecurityParameterBinding.class))\n                    {\n                        requiredBindingAnnotations.add(annotation);\n                    }\n                }\n\n                if (!requiredBindingAnnotations.isEmpty())\n                {\n                    Method method = invocation.getMethod();\n                    Annotation[][] businessMethodParameterAnnotations = method.getParameterAnnotations();\n                    for (int i = 0; i < businessMethodParameterAnnotations.length; i++)\n                    {\n                        List<Annotation> businessParameterAnnotations = Arrays\n                                    .asList(businessMethodParameterAnnotations[i]);\n                        for (Annotation annotation : requiredBindingAnnotations)\n                        {\n                            if (businessParameterAnnotations.contains(annotation))\n                            {\n                                return invocation.getParameters()[i];\n                            }\n                        }\n                    }\n\n                    throw new IllegalStateException(\"Missing required security parameter binding \"\n                                + requiredBindingAnnotations + \" on method invocation [\"\n                                + method.getDeclaringClass().getName() + \".\" + method.getName()\n                                + Arrays.asList(method.getParameterTypes()).toString().replaceFirst(\"\\\\[\", \"(\")\n                                            .replaceFirst(\"\\\\]$\", \")\") + \"]\");\n\n                }\n            }\n        }\n\n        return value.getDefaultValue(creationalContext);\n    }\n}\n", "Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.jbpm.ruleflow.core.factory;\n\nimport org.jbpm.process.core.datatype.DataType;\nimport org.jbpm.process.core.context.exception.ActionExceptionHandler;\nimport org.jbpm.process.core.context.exception.ExceptionHandler;\nimport org.jbpm.process.core.context.exception.ExceptionScope;\nimport org.jbpm.process.core.context.variable.Variable;\nimport org.jbpm.process.core.context.variable.VariableScope;\nimport org.jbpm.ruleflow.core.RuleFlowNodeContainerFactory;\nimport org.jbpm.workflow.core.Node;\nimport org.jbpm.workflow.core.NodeContainer;\nimport org.jbpm.workflow.core.impl.DroolsConsequenceAction;\nimport org.jbpm.workflow.core.node.CompositeContextNode;\n\n/**\n *\n */\npublic class CompositeNodeFactory extends RuleFlowNodeContainerFactory {\n\n\tprivate RuleFlowNodeContainerFactory nodeContainerFactory;\n\tprivate NodeContainer nodeContainer;\n\tprivate long linkedIncomingNodeId = -1;\n\tprivate long linkedOutgoingNodeId = -1;\n\t\n    public CompositeNodeFactory(RuleFlowNodeContainerFactory nodeContainerFactory, NodeContainer nodeContainer, long id) {\n    \tthis.nodeContainerFactory = nodeContainerFactory;\n    \tthis.nodeContainer = nodeContainer;\n    \tCompositeContextNode compositeNode = new CompositeContextNode();\n        compositeNode.setId(id);\n        setNodeContainer(compositeNode);\n    }\n    \n    protected CompositeContextNode getCompositeNode() {\n    \treturn (CompositeContextNode) getNodeContainer();\n    }\n\n    public CompositeNodeFactory name(String name) {\n        getCompositeNode().setName(name);\n        return this;\n    }\n\n    public CompositeNodeFactory variable(String name, DataType type) {\n    \treturn variable(name, type, null);\n    }\n    \n    public CompositeNodeFactory variable(String name, DataType type, Object value) {\n    \tVariable variable = new Variable();\n    \tvariable.setName(name);\n    \tvariable.setType(type);\n    \tvariable.setValue(value);\n    \tVariableScope variableScope = (VariableScope)\n\t\t\tgetCompositeNode().getDefaultContext(VariableScope.VARIABLE_SCOPE);\n\t\tif (variableScope == null) {\n\t\t\tvariableScope = new VariableScope();\n\t\t\tgetCompositeNode().addContext(variableScope);\n\t\t\tgetCompositeNode().setDefaultContext(variableScope);\n\t\t}\n\t\tvariableScope.getVariables().add(variable);\n        return this;\n    }\n    \n    public CompositeNodeFactory exceptionHandler(String exception, ExceptionHandler exceptionHandler) {\n    \tExceptionScope exceptionScope = (ExceptionScope)\n\t\t\tgetCompositeNode().getDefaultContext(ExceptionScope.EXCEPTION_SCOPE);\n\t\tif (exceptionScope == null) {\n\t\t\texceptionScope = new ExceptionScope();\n\t\t\tgetCompositeNode().addContext(exceptionScope);\n\t\t\tgetCompositeNode().setDefaultContext(exceptionScope);\n\t\t}\n\t\texceptionScope.setExceptionHandler(exception, exceptionHandler);\n    \treturn this;\n    }\n    \n    public CompositeNodeFactory exceptionHandler(String exception, String dialect, String action) {\n    \tActionExceptionHandler exceptionHandler = new ActionExceptionHandler();\n    \texceptionHandler.setAction(new DroolsConsequenceAction(dialect, action));\n    \treturn exceptionHandler(exception, exceptionHandler);\n    }\n    \n    public CompositeNodeFactory linkIncomingConnections(long nodeId) {\n    \tthis.linkedIncomingNodeId = nodeId;\n        return this;\n    }\n\n    public CompositeNodeFactory linkOutgoingConnections(long nodeId) {\n    \tthis.linkedOutgoingNodeId = nodeId;\n    \treturn this;\n    }\n\n    public RuleFlowNodeContainerFactory done() {\n    \tif (linkedIncomingNodeId != -1) {\n    \t\tgetCompositeNode().linkIncomingConnections(\n\t\t\t\tNode.CONNECTION_DEFAULT_TYPE,\n\t\t        linkedIncomingNodeId, Node.CONNECTION_DEFAULT_TYPE);\n    \t}\n    \tif (linkedOutgoingNodeId != -1) {\n    \t\tgetCompositeNode().linkOutgoingConnections(\n\t\t\t\tlinkedOutgoingNodeId, Node.CONNECTION_DEFAULT_TYPE,\n\t            Node.CONNECTION_DEFAULT_TYPE);\n    \t}\n        nodeContainer.addNode(getCompositeNode());\n        return nodeContainerFactory;\n    }\n\n}\n", ";\nimport retrofit2.converter.moshi.MoshiConverterFactory;\n\npublic final class ApiModule {\n\n    public static OverpassService provideOverpassService() {\n        return provideOverpassService(null);\n    }\n\n    public static OverpassService provideOverpassService(final OkHttpClient okHttpClient) {\n        return createRetrofit(OverpassService.BASE_URL, okHttpClient)\n                .create(OverpassService.class);\n    }\n\n    private static Retrofit createRetrofit(final String baseUrl, final OkHttpClient okHttpClient) {\n        OkHttpClient httpClient = okHttpClient;\n        if (httpClient == null) {\n            httpClient = new OkHttpClient();\n        }\n\n        return new Retrofit.Builder()\n                .baseUrl(baseUrl)\n                .addConverterFactory(MoshiConverterFactory.create())\n                .client(httpClient)\n                .build();\n    }\n\n}\n\n", "ements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.jackrabbit.oak.jcr;\n\nimport static java.lang.Math.log;\nimport static java.lang.Math.pow;\nimport static java.util.concurrent.TimeUnit.MILLISECONDS;\nimport static javax.jcr.observation.Event.NODE_ADDED;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assume.assumeTrue;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.concurrent.Callable;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.ExecutionException;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.Future;\nimport java.util.concurrent.Semaphore;\nimport java.util.concurrent.atomic.AtomicReference;\n\nimport javax.jcr.Node;\nimport javax.jcr.NodeIterator;\nimport javax.jcr.Repository;\nimport javax.jcr.RepositoryException;\nimport javax.jcr.Session;\nimport javax.jcr.SimpleCredentials;\nimport javax.jcr.observation.EventIterator;\nimport javax.jcr.observation.EventListener;\n\nimport org.apache.commons.math3.distribution.BinomialDistribution;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.MathInternalError;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.NullArgumentException;\nimport org.apache.commons.math3.exception.OutOfRangeException;\nimport org.apache.commons.math3.exception.util.LocalizedFormats;\nimport org.apache.jackrabbit.api.JackrabbitRepository;\nimport org.apache.jackrabbit.oak.fixture.DocumentMongoFixture;\nimport org.apache.jackrabbit.oak.fixture.NodeStoreFixture;\nimport org.apache.jackrabbit.oak.jcr.session.RefreshStrategy;\nimport org.apache.jackrabbit.oak.plugins.document.DocumentNodeStore;\nimport org.apache.jackrabbit.oak.segment.fixture.SegmentTarFixture;\nimport org.apache.jackrabbit.oak.spi.state.NodeStore;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport com.google.common.collect.Lists;\n\nimport ch.qos.logback.classic.Level;\nimport ch.qos.logback.classic.LoggerContext;\n\n/**\n * Scalability test asserting certain operations scale not worse than {@code O(n log n)}\n * in the size of their input.\n *\n * These tests are disabled by default due to their long running time. On the command line\n * specify {@code -DLargeOperationIT=true} to enable them.\n */\n@RunWith(Parameterized.class)\npublic class LargeOperationIT {\n    private static final Logger LOG = LoggerFactory.getLogger(LargeOperationIT.class);\n    private static final boolean enabled = Boolean.getBoolean(LargeOperationIT.class.getSimpleName());\n\n    /**\n     * Significance level for the binomial test being performed to establish\n     * the {@code O(n log n)} performance bound.\n     * @see #assertOnLgn(String, Iterable, java.util.List, boolean)\n     */\n    public static final double ALPHA = 0.05;\n\n    /** Scales defining the input sizes against which the tests run */\n    private static final Iterable<Integer> SEGMENT_SCALES = createSequence(1024, 1048576, 40);\n    private static final Iterable<Integer> MONGO_SCALES = createSequence(128, 131072, 40);\n\n    private final NodeStoreFixture fixture;\n    private final Iterable<Integer> scales;\n\n    private NodeStore nodeStore;\n    private Repository repository;\n    private Session session;\n\n    public LargeOperationIT(NodeStoreFixture fixture, Iterable<Integer> scales) {\n        assumeTrue(enabled);\n        this.fixture = fixture;\n        this.scales = scales;\n    }\n\n    /**\n     * Create a geometrically increasing sequence of values\n     * @param from    first value. Must be > 0\n     * @param to      last value. Must be > {@code from}\n     * @param count   number of values\n     * @return  geometrically increasing sequence of {@code count} values\n     * between {@code from} and {@code to}\n     */\n    private static List<Integer> createSequence(int from, int to, int count) {\n        double slope = pow(to / (double) from, 1 / ((double) count - 1));\n        List<Integer> seq = Lists.newArrayList();\n        int c = 0;\n        int v = from;\n        do {\n            seq.add(v);\n            v = (int) (slope * v);\n        } while (++c < count);\n        return seq;\n    }\n\n    @Parameterized.Parameters\n    public static Collection<Object[]> fixtures() throws Exception {\n        List<Object[]> fixtures = Lists.newArrayList();\n        SegmentTarFixture segmentFixture = new SegmentTarFixture();\n        if (segmentFixture.isAvailable()) {\n            fixtures.add(new Object[] {segmentFixture, SEGMENT_SCALES});\n        }\n        DocumentMongoFixture documentFixture = new DocumentMongoFixture();\n        if (documentFixture.isAvailable()) {\n            fixtures.add(new Object[]{documentFixture, MONGO_SCALES});\n        }\n        return fixtures;\n    }\n\n    private Session createAdminSession() throws RepositoryException {\n        return repository.login(new SimpleCredentials(\"admin\", \"admin\".toCharArray()));\n    }\n\n    private static void safeLogout(Session session) {\n        try {\n            session.logout();\n        } catch (Exception ignore) {}\n    }\n\n    @Before\n    public void setup() throws RepositoryException {\n        // Disable noisy logging we want to ignore for these tests\n        ((LoggerContext)LoggerFactory.getILoggerFactory())\n                .getLogger(DocumentNodeStore.class).setLevel(Level.ERROR);\n        ((LoggerContext)LoggerFactory.getILoggerFactory())\n                .getLogger(\"org.apache.jackrabbit.oak.jcr.observation.ChangeProcessor\").setLevel(Level.ERROR);\n        ((LoggerContext)LoggerFactory.getILoggerFactory())\n                .getLogger(RefreshStrategy.class).setLevel(Level.ERROR);\n\n        nodeStore = fixture.createNodeStore();\n        repository  = new Jcr(nodeStore).createRepository();\n        session = createAdminSession();\n    }\n\n    @After\n    public void tearDown() {\n        safeLogout(session);\n        if (repository instanceof JackrabbitRepository) {\n            ((JackrabbitRepository) repository).shutdown();\n        }\n        fixture.dispose(nodeStore);\n    }\n\n    /**\n     * Assert that the actual runtime performance is bounded by {@code O(n log n)} where\n     * {@code n} is the size of the input.\n     * <p>\n     * This is done by comparing the slope of the measured running times against the\n     * slope of {@code n log n}  (i.e. {@code d/dn n log n = 1 + log n}) for the respective\n     * input size. The number of values for which the measured running time does not exceed that\n     * bound is used as a test statistic for the subsequent\n     * <a href=\"http://en.wikipedia.org/wiki/Binomial_test\">binomial test</a>. The test passes\n     * if the binomial test with a significance level of {@link #ALPHA} passes and fails otherwise.\n     *\n     * @param name    name of the test\n     * @param scales  the sizes of the inputs\n     * @param executionTimes  the execution times corresponding to the {@code scales}\n     * @param knownIssue  log when the assertion doesn't hold but don't throw {@link AssertionError}\n     */\n    private static void assertOnLgn(String name, Iterable<Integer> scales,\n            List<Double> executionTimes, boolean knownIssue) {\n        Double n0 = null;\n        Double t0 = null;\n        int successes = 0;\n        Iterator<Integer> ns = scales.iterator();\n        for (double t : executionTimes) {\n            double n = ns.next();\n            if (n0 != null) {\n                double dt = (t - t0) / (n - n0);  // slope of the measured running times\n                double bound = 1 + log(n);        // bound of the slope for the respective input size\n                if (dt < bound) {\n                    successes++;\n                }\n            }\n            n0 = n;\n            t0 = t;\n        }\n\n        // number of trials is one less due to the numeric differentiation\n        int trials = executionTimes.size() - 1;\n        double p = new BinomialTest().binomialTest(\n                trials, successes, 0.5, BinomialTest.AlternativeHypothesis.GREATER_THAN);\n\n        boolean pass = p <= ALPHA;\n        if (pass) {\n            LOG.info(\"{} scales O(n lg n). p-value={} <= \" + ALPHA, name, p);\n        } else {\n            LOG.error(\"{} does not scale O(n lg n). p-value={} > \" + ALPHA, name, p);\n        }\n        LOG.info(\"Number of trials={}, Number of successes={}\", trials, successes);\n        LOG.info(\"scales={}\", scales);\n        LOG.info(\"executionTimes={}\", executionTimes);\n        assertTrue(name + \"does not scale O(n lg n). p-value=\" + p + \" > \" + ALPHA, knownIssue || pass);\n    }\n\n    /**\n     * Assert that large commits scale linearly wrt. to the number of changed items.\n     * @throws RepositoryException\n     * @throws InterruptedException\n     */\n    @Test\n    public void largeCommit() throws RepositoryException, InterruptedException {\n        final Node n = session.getRootNode().addNode(\"large-commit\", \"oak:Unstructured\");\n        final ContentGenerator contentGenerator = new ContentGenerator();\n\n        ArrayList<Double> executionTimes = Lists.newArrayList();\n        for (int scale : scales) {\n            ScalabilityTest test = new ScalabilityTest(scale) {\n                @Override\n                void before(int scale) throws RepositoryException {\n                    contentGenerator.addNodes(n, scale);\n                }\n\n                @Override\n                void run(int scale) throws RepositoryException {\n                    session.save();\n                }\n            };\n            double t = test.run();\n            executionTimes.add(t);\n            LOG.info(\"Committing {} node took {} ns/node\", scale, t);\n        }\n        assertOnLgn(\"large commit\", scales, executionTimes, false);\n    }\n\n    /**\n     * Assert copy scales linearly with the number of items copied\n     * @throws RepositoryException\n     * @throws InterruptedException\n     */\n    @Test\n    public void largeCopy() throws RepositoryException, InterruptedException {\n        final Node n = session.getRootNode().addNode(\"large-copy\", \"oak:Unstructured\");\n        final ContentGenerator contentGenerator = new ContentGenerator(1000);\n\n        ArrayList<Double> executionTimes = Lists.newArrayList();\n        for (int scale : scales) {\n            ScalabilityTest test = new ScalabilityTest(scale) {\n                @Override\n                void before(int scale) throws RepositoryException {\n                    Node s = n.addNode(\"s\" + scale);\n                    contentGenerator.addNodes(s, scale);\n                }\n\n                @Override\n                void run(int scale) throws RepositoryException {\n                    session.getWorkspace().copy(\"/large-copy/s\" + scale, \"/large-copy/t\" + scale);\n                }\n            };\n            double t = test.run();\n            executionTimes.add(t);\n            LOG.info(\"Copying {} node took {} ns/node\", scale, t);\n        }\n        boolean knownIssue = fixture.getClass() == DocumentMongoFixture.class;  // FIXME OAK-1698\n        assertOnLgn(\"large copy\", scales, executionTimes, knownIssue);\n    }\n\n    /**\n     * Assert move scales linearly with the number of items copied\n     * @throws RepositoryException\n     * @throws InterruptedException\n     */\n    @Test\n    public void largeMove() throws RepositoryException, InterruptedException {\n        final Node n = session.getRootNode().addNode(\"large-move\", \"oak:Unstructured\");\n        final ContentGenerator contentGenerator = new ContentGenerator(1000);\n\n        ArrayList<Double> executionTimes = Lists.newArrayList();\n        for (int scale : scales) {\n            ScalabilityTest test = new ScalabilityTest(scale) {\n                @Override\n                void before(int scale) throws RepositoryException {\n                    Node s = n.addNode(\"s\" + scale);\n                    contentGenerator.addNodes(s, scale);\n                }\n\n                @Override\n                void run(int scale) throws RepositoryException {\n                    session.getWorkspace().move(\"/large-move/s\" + scale, \"/large-move/t\" + scale);\n                }\n            };\n            double t = test.run();\n            executionTimes.add(t);\n            LOG.info(\"Moving {} node took {} ns/node\", scale, t);\n        }\n        boolean knownIssue = fixture.getClass() == DocumentMongoFixture.class;  // FIXME OAK-1698\n        assertOnLgn(\"large move\", scales, executionTimes, knownIssue);\n    }\n\n    @Test\n    public void largeRemove() throws RepositoryException, InterruptedException {\n        final Node n = session.getRootNode().addNode(\"large-remove\", \"oak:Unstructured\");\n        final ContentGenerator contentGenerator = new ContentGenerator(1000);\n\n        ArrayList<Double> executionTimes = Lists.newArrayList();\n        for (int scale : scales) {\n            ScalabilityTest test = new ScalabilityTest(scale) {\n                @Override\n                void before(int scale) throws RepositoryException {\n                    Node s = n.addNode(\"s\" + scale);\n                    contentGenerator.addNodes(s, scale);\n                }\n\n                @Override\n                void run(int scale) throws RepositoryException {\n                    session.getNode(\"/large-remove/s\" + scale).remove();\n                    session.save();\n                }\n            };\n            double t = test.run();\n            executionTimes.add(t);\n            LOG.info(\"Removing {} node took {} ns/node\", scale, t);\n        }\n        boolean knownIssue = fixture.getClass() == DocumentMongoFixture.class;  // FIXME OAK-1698\n        assertOnLgn(\"large remove\", scales, executionTimes, knownIssue);\n    }\n\n    /**\n     * Assert adding siblings scales linearly with the number of already existing siblings.\n     * @throws RepositoryException\n     * @throws InterruptedException\n     */\n    @Test\n    public void manySiblings() throws RepositoryException, InterruptedException {\n        final Node n = session.getRootNode().addNode(\"many-siblings\", \"oak:Unstructured\");\n\n        ArrayList<Double> executionTimes = Lists.newArrayList();\n        for (int scale : scales) {\n            ScalabilityTest test = new ScalabilityTest(scale) {\n                @Override\n                void before(int scale) throws RepositoryException {\n                    Node s = n.addNode(\"s\" + scale);\n                    for (int k = 0; k < scale; k++) {\n                        s.addNode(\"s\" + k);\n                    }\n                }\n\n                @Override\n                void run(int scale) throws RepositoryException {\n                    Node s = n.getNode(\"s\" + scale);\n                    for (int k = 0; k < 100; k++) {\n                        s.addNode(\"t\" + k);\n                    }\n                    session.save();\n                }\n            };\n            double t = test.run();\n            executionTimes.add(t);\n            LOG.info(\"Adding 100 siblings next to {} siblings took {} ns/node\", scale, t);\n        }\n        boolean knownIssue = fixture.getClass() == DocumentMongoFixture.class;  // FIXME OAK-1698\n        assertOnLgn(\"many siblings\", scales, executionTimes, knownIssue);\n    }\n\n    /**\n     * Assert processing of pending observation events scales linearly with the\n     * number of pending events.\n     * @throws RepositoryException\n     * @throws InterruptedException\n     */\n    @Test\n    public void largeNumberOfPendingEvents() throws RepositoryException, InterruptedException {\n        final Node n = session.getRootNode().addNode(\"pending-events\", \"oak:Unstructured\");\n        final ContentGenerator contentGenerator = new ContentGenerator(1000);\n\n        ArrayList<Double> executionTimes = Lists.newArrayList();\n        for (int scale : scales) {\n            final Observer observer = new Observer(scale, 100);\n            try {\n                ScalabilityTest test = new ScalabilityTest(scale) {\n                    @Override\n                    void before(int scale) throws RepositoryException {\n                        contentGenerator.addNodes(n, scale);\n                    }\n\n                    @Override\n                    void run(int scale) throws InterruptedException {\n                        observer.waitForEvents(scale);\n                    }\n                };\n                double t = test.run();\n                executionTimes.add(t);\n                LOG.info(\"{} pending events took {} ns/event to process\", scale, t);\n            } finally {\n                try {\n                    observer.dispose();\n                } catch (Exception ignore) {}\n            }\n        }\n        boolean knownIssue = fixture.getClass() == DocumentMongoFixture.class;  // FIXME OAK-1698\n        assertOnLgn(\"large number of pending events\", scales, executionTimes, knownIssue);\n    }\n\n    @Test\n    public void slowListener() throws RepositoryException, ExecutionException, InterruptedException {\n        Node n = session.getRootNode().addNode(\"slow-events\", \"oak:Unstructured\");\n        final DelayedEventHandling delayedEventHandling = new DelayedEventHandling(n, 100, 10);\n        Future<Void> result = delayedEventHandling.start();\n\n        try {\n            ArrayList<Double> executionTimes = Lists.newArrayList();\n            for (int scale : scales) {\n                ScalabilityTest test = new ScalabilityTest(scale) {\n                    @Override\n                    void run(int scale) throws InterruptedException {\n                        delayedEventHandling.waitForNodes(scale);\n                    }\n                };\n                double t = test.run();\n                executionTimes.add(t);\n                LOG.info(\"Adding {} nodes took {} ns/node\", scale, t);\n            }\n            boolean knownIssue = fixture.getClass() == DocumentMongoFixture.class;  // FIXME OAK-1698\n            assertOnLgn(\"slow listeners\", scales, executionTimes, knownIssue);\n        } finally {\n            delayedEventHandling.stop();\n            result.get();\n        }\n    }\n\n    //------------------------------------------------------------< ContentGenerator >---\n\n    private static class ContentGenerator {\n        private static final int FAN_OUT = 10;\n        private final int saveInterval;\n\n        private int count;\n\n        public ContentGenerator(int saveInterval) {\n            this.saveInterval = saveInterval;\n        }\n\n        public ContentGenerator() {\n            this(Integer.MAX_VALUE);\n        }\n\n        public void addNodes(Node node, int count) throws RepositoryException {\n            LOG.info(\"Adding {} nodes to {}\", count, node.getPath());\n            this.count = count;\n            while (createContent(node));\n            if (saveInterval < Integer.MAX_VALUE) {\n                node.getSession().save();\n            }\n        }\n\n        private boolean createContent(Node node) throws RepositoryException {\n            NodeIterator nodes = node.getNodes();\n            if (nodes.hasNext()) {\n                while (nodes.hasNext()) {\n                    if (!createContent(nodes.nextNode())) {\n                        return false;\n                    }\n                }\n                return true;\n            } else {\n                boolean result = true;\n                for (int c = 0; c < FAN_OUT && (result = addNode(node)); c++);\n                return result;\n            }\n        }\n\n        boolean addNode(Node node) throws RepositoryException {\n            node.addNode(\"n\" + count--);\n            if (count % saveInterval == 0) {\n                node.getSession().save();\n            }\n            if (count % 1000 == 0) {\n                LOG.debug(\"add {}\", node.getPath());\n            }\n            return !isDone();\n        }\n\n        boolean isDone() {\n            return count == 0;\n        }\n    }\n\n    //------------------------------------------------------------< ScalabilityTest >---\n\n    private abstract static class ScalabilityTest {\n        private final int scale;\n\n        protected ScalabilityTest(int scale) {\n            this.scale = scale;\n        }\n\n        void before(int scale) throws RepositoryException {}\n        abstract void run(int scale) throws RepositoryException, InterruptedException;\n        void after(int scale) {}\n\n        public long run() throws RepositoryException, InterruptedException {\n            before(scale);\n            long t0 = System.nanoTime();\n            run(scale);\n            long dt = System.nanoTime() - t0;\n            after(scale);\n            return dt / scale;\n        }\n    }\n\n    //------------------------------------------------------------< Observer >---\n\n    private class Observer implements EventListener {\n        private final CountDownLatch start = new CountDownLatch(1);\n        private final int eventCount;\n        private final int listenerCount;\n        private final Session[] sessions;\n\n        private CountDownLatch done;\n\n        public Observer(int eventCount, int listenerCount) throws RepositoryException {\n            this.eventCount = eventCount;\n            this.listenerCount = listenerCount;\n            this.sessions = new Session[listenerCount];\n            for (int k = 0; k < sessions.length; k++) {\n                sessions[k] = createAdminSession();\n                sessions[k].getWorkspace().getObservationManager().addEventListener(\n                        this, NODE_ADDED, \"/\", true, null, null, false);\n            }\n        }\n\n        public void waitForEvents(int scale) throws InterruptedException {\n            done = new CountDownLatch(scale);\n            start.countDown();\n            done.await();\n        }\n\n        public void dispose() {\n            for (Session session : sessions) {\n                safeLogout(session);\n            }\n        }\n\n        @Override\n        public void onEvent(EventIterator events) {\n            try {\n                start.await();\n                while (events.hasNext()) {\n                    events.nextEvent();\n                    done.countDown();\n                }\n            } catch (Exception e) {\n                LOG.error(e.getMessage(), e);\n            }\n        }\n    }\n\n    //------------------------------------------------------------< DelayedEventHandling >---\n\n    private class DelayedEventHandling implements EventListener {\n        private final ExecutorService executor = Executors.newSingleThreadExecutor();\n        private final Semaphore openEvents = new Semaphore(0);\n        private final AtomicReference<CountDownLatch> nodeCounter =\n                new AtomicReference<CountDownLatch>(new CountDownLatch(0));\n        private final Node node;\n        private final int listenerCount;\n        private final int saveInterval;\n\n        private volatile boolean done;\n\n        private DelayedEventHandling(Node node, int listenerCount, int saveInterval) {\n            this.node = node;\n            this.listenerCount = listenerCount;\n            this.saveInterval = saveInterval;\n        }\n\n        public Future<Void> start() {\n            return executor.submit(new Callable<Void>() {\n                @Override\n                public Void call() throws Exception {\n                    final Session[] sessions = new Session[listenerCount];\n                    ContentGenerator contentGenerator = new ContentGenerator(saveInterval) {\n                        int nodeCount;\n\n                        @Override\n                        boolean addNode(Node node) throws RepositoryException {\n                            boolean result = super.addNode(node);\n                            if (++nodeCount % 2 == 0) {\n                                openEvents.release(sessions.length);\n                            }\n                            nodeCounter.get().countDown();\n                            return result;\n                        }\n\n                        @Override\n                        boolean isDone() {\n                            return done;\n                        }\n                    };\n\n                    for (int k = 0; k < sessions.length; k++) {\n                        sessions[k] = createAdminSession();\n                        sessions[k].getWorkspace().getObservationManager().addEventListener(\n                                DelayedEventHandling.this, NODE_ADDED, \"/\", true, null, null, false);\n                    }\n                    try {\n                        contentGenerator.addNodes(node, Integer.MAX_VALUE);\n                    } finally {\n                        for (Session session : sessions) {\n                            safeLogout(session);\n                        }\n                    }\n                    return null;\n                }\n            });\n        }\n\n        public void stop() {\n            done = true;\n        }\n\n        public void waitForNodes(int count) throws InterruptedException {\n            CountDownLatch counter = new CountDownLatch(count);\n            nodeCounter.set(counter);\n            counter.await();\n        }\n\n        @Override\n        public void onEvent(EventIterator events) {\n            try {\n                while (events.hasNext()) {\n                    while (!done && !openEvents.tryAcquire(10, MILLISECONDS));\n                    if (done) {\n                        break;\n                    }\n                    events.nextEvent();\n                }\n            } catch (Exception e) {\n                LOG.error(e.getMessage(), e);\n            }\n        }\n\n    }\n\n    //------------------------------------------------------------< BinomialTest >---\n    // FIXME this class is copied from commons-math3:3.3-SNAPSHOT. Remove once 3.3 is released\n\n    /**\n     * Implements binomial test statistics.\n     * <p>\n     * Exact test for the statistical significance of deviations from a\n     * theoretically expected distribution of observations into two categories.\n     *\n     * @see <a href=\"http://en.wikipedia.org/wiki/Binomial_test\">Binomial test (Wikipedia)</a>\n     * @version $Id: BinomialTest.java 1532638 2013-10-16 04:29:31Z psteitz $\n     * @since 3.3\n     */\n    private static class BinomialTest {\n\n        /**\n         * Represents an alternative hypothesis for a hypothesis test.\n         *\n         * @version $Id: AlternativeHypothesis.java 1531128 2013-10-10 22:09:25Z tn $\n         * @since 3.3\n         */\n        public enum AlternativeHypothesis {\n\n            /**\n             * Represents a two-sided test. H0: p=p0, H1: p &ne; p0\n             */\n            TWO_SIDED,\n\n            /**\n             * Represents a right-sided test. H0: p &le; p0, H1: p &gt; p0.\n             */\n            GREATER_THAN,\n\n            /**\n             * Represents a left-sided test. H0: p &ge; p0, H1: p &lt; p0.\n             */\n            LESS_THAN\n        }\n\n        /**\n         * Returns whether the null hypothesis can be rejected with the given confidence level.\n         * <p>\n         * <strong>Preconditions</strong>:\n         * <ul>\n         * <li>Number of trials must be &ge; 0.</li>\n         * <li>Number of successes must be &ge; 0.</li>\n         * <li>Number of successes must be &le; number of trials.</li>\n         * <li>Probability must be &ge; 0 and &le; 1.</li>\n         * </ul>\n         *\n         * @param numberOfTrials number of trials performed\n         * @param numberOfSuccesses number of successes observed\n         * @param probability assumed probability of a single trial under the null hypothesis\n         * @param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)\n         * @param alpha significance level of the test\n         * @return true if the null hypothesis can be rejected with confidence {@code 1 - alpha}\n         * @throws org.apache.commons.math3.exception.NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative\n         * @throws org.apache.commons.math3.exception.OutOfRangeException if {@code probability} is not between 0 and 1\n         * @throws org.apache.commons.math3.exception.MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} or\n         * if {@code alternateHypothesis} is null.\n         * @see org.apache.jackrabbit.oak.jcr.LargeOperationIT.BinomialTest.AlternativeHypothesis\n         */\n        public boolean binomialTest(int numberOfTrials, int numberOfSuccesses, double probability,\n                AlternativeHypothesis alternativeHypothesis, double alpha) {\n            double pValue = binomialTest(numberOfTrials, numberOfSuccesses, probability, alternativeHypothesis);\n            return pValue < alpha;\n        }\n\n        /**\n         * Returns the <i>observed significance level</i>, or\n         * <a href=\"http://www.cas.lancs.ac.uk/glossary_v1.1/hyptest.html#pvalue\">p-value</a>,\n         * associated with a <a href=\"http://en.wikipedia.org/wiki/Binomial_test\"> Binomial test</a>.\n         * <p>\n         * The number returned is the smallest significance level at which one can reject the null hypothesis.\n         * The form of the hypothesis depends on {@code alternativeHypothesis}.</p>\n         * <p>\n         * The p-Value represents the likelihood of getting a result at least as extreme as the sample,\n         * given the provided {@code probability} of success on a single trial. For single-sided tests,\n         * this value can be directly derived from the Binomial distribution. For the two-sided test,\n         * the implementation works as follows: we start by looking at the most extreme cases\n         * (0 success and n success where n is the number of trials from the sample) and determine their likelihood.\n         * The lower value is added to the p-Value (if both values are equal, both are added). Then we continue with\n         * the next extreme value, until we added the value for the actual observed sample.</p>\n         * <p>\n         * <strong>Preconditions</strong>:\n         * <ul>\n         * <li>Number of trials must be &ge; 0.</li>\n         * <li>Number of successes must be &ge; 0.</li>\n         * <li>Number of successes must be &le; number of trials.</li>\n         * <li>Probability must be &ge; 0 and &le; 1.</li>\n         * </ul></p>\n         *\n         * @param numberOfTrials number of trials performed\n         * @param numberOfSuccesses number of successes observed\n         * @param probability assumed probability of a single trial under the null hypothesis\n         * @param alternativeHypothesis type of hypothesis being evaluated (one- or two-sided)\n         * @return p-value\n         * @throws org.apache.commons.math3.exception.NotPositiveException if {@code numberOfTrials} or {@code numberOfSuccesses} is negative\n         * @throws org.apache.commons.math3.exception.OutOfRangeException if {@code probability} is not between 0 and 1\n         * @throws org.apache.commons.math3.exception.MathIllegalArgumentException if {@code numberOfTrials} &lt; {@code numberOfSuccesses} or\n         * if {@code alternateHypothesis} is null.\n         * @see org.apache.jackrabbit.oak.jcr.LargeOperationIT.BinomialTest.AlternativeHypothesis\n         */\n        public double binomialTest(int numberOfTrials, int numberOfSuccesses, double probability,\n                AlternativeHypothesis alternativeHypothesis) {\n            if (numberOfTrials < 0) {\n                throw new NotPositiveException(numberOfTrials);\n            }\n            if (numberOfSuccesses < 0) {\n                throw new NotPositiveException(numberOfSuccesses);\n            }\n            if (probability < 0 || probability > 1) {\n                throw new OutOfRangeException(probability, 0, 1);\n            }\n            if (numberOfTrials < numberOfSuccesses) {\n                throw new MathIllegalArgumentException(\n                        LocalizedFormats.BINOMIAL_INVALID_PARAMETERS_ORDER,\n                        numberOfTrials, numberOfSuccesses);\n            }\n            if (alternativeHypothesis == null) {\n                throw new NullArgumentException();\n            }\n\n            final BinomialDistribution distribution = new BinomialDistribution(numberOfTrials, probability);\n            switch (alternativeHypothesis) {\n                case GREATER_THAN:\n                    return 1 - distribution.cumulativeProbability(numberOfSuccesses - 1);\n                case LESS_THAN:\n                    return distribution.cumulativeProbability(numberOfSuccesses);\n                case TWO_SIDED:\n                    int criticalValueLow = 0;\n                    int criticalValueHigh = numberOfTrials;\n                    double pTotal = 0;\n\n                    while (true) {\n                        double pLow = distribution.probability(criticalValueLow);\n                        double pHigh = distribution.probability(criticalValueHigh);\n\n                        if (pLow == pHigh) {\n                            pTotal += 2 * pLow;\n                            criticalValueLow++;\n                            criticalValueHigh--;\n                        } else if (pLow < pHigh) {\n                            pTotal += pLow;\n                            criticalValueLow++;\n                        } else {\n                            pTotal += pHigh;\n                            criticalValueHigh--;\n                        }\n\n                        if (criticalValueLow > numberOfSuccesses || criticalValueHigh < numberOfSuccesses) {\n                            break;\n                        }\n                    }\n                    return pTotal;\n                default:\n                    throw new MathInternalError(LocalizedFormats. OUT_OF_RANGE_SIMPLE, alternativeHypothesis,\n                            AlternativeHypothesis.TWO_SIDED, AlternativeHypothesis.LESS_THAN);\n            }\n        }\n    }\n}", "\n\n@Annotation_002\npublic class Class_012 {\n}\n", "rt java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * SwipeItemMangerImpl is a helper class to help maintain swipe status\n */\npublic class SwipeItemManagerImpl implements SwipeItemManagerInterface {\n    public final int INVALID_POSITION = -1;\n\n    private Mode mode = Mode.Single;\n\n    protected int mOpenPosition = INVALID_POSITION;\n\n    protected Set<Integer>     mOpenPositions = new HashSet<>();\n    protected Set<SwipeLayout> mShownLayouts  = new HashSet<>();\n\n    protected RecyclerView.Adapter mAdapter;\n\n    public SwipeItemManagerImpl(RecyclerView.Adapter adapter) {\n        if (adapter == null)\n            throw new IllegalArgumentException(\"Adapter can not be null\");\n\n        if (!(adapter instanceof SwipeItemManagerInterface))\n            throw new IllegalArgumentException(\"adapter should implement the SwipeAdapterInterface\");\n\n        this.mAdapter = adapter;\n    }\n\n    public Mode getMode() {\n        return mode;\n    }\n\n    public void setMode(Mode mode) {\n        this.mode = mode;\n        mOpenPositions.clear();\n        mShownLayouts.clear();\n        mOpenPosition = INVALID_POSITION;\n    }\n\n    private void initialize(BaseSwipeAdapter.BaseSwipeableViewHolder targetViewHolder, int position) {\n        targetViewHolder.onLayoutListener = new OnLayoutListener(position);\n        targetViewHolder.swipeMemory = new SwipeMemory(position);\n        targetViewHolder.position = position;\n\n        targetViewHolder.swipeLayout.addSwipeListener(targetViewHolder.swipeMemory);\n        targetViewHolder.swipeLayout.addOnLayoutListener(targetViewHolder.onLayoutListener);\n    }\n\n    public void updateConvertView(BaseSwipeAdapter.BaseSwipeableViewHolder targetViewHolder, int position) {\n        if (targetViewHolder.onLayoutListener == null) {\n            initialize(targetViewHolder, position);\n        }\n\n        SwipeLayout swipeLayout = targetViewHolder.swipeLayout;\n        if (swipeLayout == null)\n            throw new IllegalStateException(\"can not find SwipeLayout in target view\");\n\n        mShownLayouts.add(swipeLayout);\n\n        ((SwipeMemory) targetViewHolder.swipeMemory).setPosition(position);\n        ((OnLayoutListener) targetViewHolder.onLayoutListener).setPosition(position);\n        targetViewHolder.position = position;\n    }\n\n    @Override\n    public void openItem(int position) {\n        if (mode == Mode.Multiple) {\n            if (!mOpenPositions.contains(position))\n                mOpenPositions.add(position);\n        } else {\n            mOpenPosition = position;\n        }\n    }\n\n    @Override\n    public void closeItem(int position) {\n        if (mode == Mode.Multiple) {\n            mOpenPositions.remove(position);\n        } else {\n            if (mOpenPosition == position)\n                mOpenPosition = INVALID_POSITION;\n        }\n    }\n\n    @Override\n    public void closeAllExcept(SwipeLayout layout) {\n        for (SwipeLayout s : mShownLayouts) {\n            if (s != layout)\n                s.close();\n        }\n    }\n\n    @Override\n    public void removeShownLayouts(SwipeLayout layout) {\n        mShownLayouts.remove(layout);\n    }\n\n    @Override\n    public List<Integer> getOpenItems() {\n        if (mode == Mode.Multiple) {\n            return new ArrayList<>(mOpenPositions);\n        } else {\n            return Arrays.asList(mOpenPosition);\n        }\n    }\n\n    @Override\n    public List<SwipeLayout> getOpenLayouts() {\n        return new ArrayList<>(mShownLayouts);\n    }\n\n    @Override\n    public boolean isOpen(int position) {\n        if (mode == Mode.Multiple) {\n            return mOpenPositions.contains(position);\n        } else {\n            return mOpenPosition == position;\n        }\n    }\n\n    private class OnLayoutListener implements SwipeLayout.OnLayout {\n\n        private int position;\n\n        OnLayoutListener(int position) {\n            this.position = position;\n        }\n\n        public void setPosition(int position) {\n            this.position = position;\n        }\n\n        @Override\n        public void onLayout(SwipeLayout v) {\n            if (isOpen(position)) {\n                v.open(false, false);\n            } else {\n                v.close(false, false);\n            }\n        }\n\n    }\n\n    private class SwipeMemory extends SimpleSwipeListener {\n\n        private int position;\n\n        SwipeMemory(int position) {\n            this.position = position;\n        }\n\n        @Override\n        public void onClose(SwipeLayout layout) {\n            if (mode == Mode.Multiple) {\n                mOpenPositions.remove(position);\n            } else {\n                mOpenPosition = INVALID_POSITION;\n            }\n        }\n\n        @Override\n        public void onStartOpen(SwipeLayout layout) {\n            if (mode == Mode.Single) {\n                closeAllExcept(layout);\n            }\n        }\n\n        @Override\n        public void onOpen(SwipeLayout layout) {\n            if (mode == Mode.Multiple)\n                mOpenPositions.add(position);\n            else {\n                closeAllExcept(layout);\n                mOpenPosition = position;\n            }\n        }\n\n        public void setPosition(int position) {\n            this.position = position;\n        }\n    }\n\n}\n", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.xbmc.kore.utils;\n\nimport android.content.Context;\nimport android.os.Bundle;\nimport android.support.v4.app.Fragment;\nimport android.support.v4.app.FragmentManager;\nimport android.support.v4.app.FragmentPagerAdapter;\n\nimport java.util.ArrayList;\n\n/**\n * This is a helper class that implements the management of tabs and all\n * details of connecting a ViewPager with associated TabHost.\n */\npublic class TabsAdapter extends FragmentPagerAdapter {\n    private final Context context;\n    private final ArrayList<TabInfo> tabInfos;\n\n    public static final class TabInfo {\n        private final Class<?> fragmentClass;\n        private final Bundle args;\n        private final int titleRes;\n        private final long fragmentId;\n\n        TabInfo(Class<?> fragmentClass, Bundle args, int titleRes, long fragmentId) {\n            this.fragmentClass = fragmentClass;\n            this.args = args;\n            this.titleRes = titleRes;\n            this.fragmentId = fragmentId;\n        }\n    }\n\n    public TabsAdapter(Context context, FragmentManager fragmentManager) {\n        super(fragmentManager);\n        this.context = context;\n        this.tabInfos = new ArrayList<TabInfo>();\n    }\n\n    public TabsAdapter addTab(Class<?> fragmentClass, Bundle args, int titleRes, long fragmentId) {\n        TabInfo info = new TabInfo(fragmentClass, args, titleRes, fragmentId);\n        tabInfos.add(info);\n        return this;\n    }\n\n    @Override\n    public int getCount() {\n        return tabInfos.size();\n    }\n\n    @Override\n    public Fragment getItem(int position) {\n        TabInfo info = tabInfos.get(position);\n        return Fragment.instantiate(context, info.fragmentClass.getName(), info.args);\n    }\n\n    @Override\n    public long getItemId(int position) {\n        return tabInfos.get(position).fragmentId;\n    }\n\n    @Override\n    public CharSequence getPageTitle(int position) {\n        TabInfo tabInfo = tabInfos.get(position);\n        if (tabInfo != null) {\n//            return context.getString(tabInfo.titleRes).toUpperCase(Locale.getDefault());\n            return context.getString(tabInfo.titleRes);\n        }\n        return null;\n    }\n}\n", "file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\npackage org.elasticsearch.search.query;\n\nimport com.carrotsearch.randomizedtesting.generators.RandomPicks;\n\nimport org.elasticsearch.action.admin.indices.create.CreateIndexRequestBuilder;\nimport org.elasticsearch.action.index.IndexRequestBuilder;\nimport org.elasticsearch.action.search.SearchResponse;\nimport org.elasticsearch.common.settings.Settings;\nimport org.elasticsearch.common.util.set.Sets;\nimport org.elasticsearch.common.xcontent.XContentBuilder;\nimport org.elasticsearch.common.xcontent.XContentFactory;\nimport org.elasticsearch.index.query.MatchQueryBuilder;\nimport org.elasticsearch.index.query.MultiMatchQueryBuilder;\nimport org.elasticsearch.index.query.Operator;\nimport org.elasticsearch.index.query.QueryBuilders;\nimport org.elasticsearch.index.search.MatchQuery;\nimport org.elasticsearch.search.SearchHit;\nimport org.elasticsearch.search.SearchHits;\nimport org.elasticsearch.search.sort.SortBuilders;\nimport org.elasticsearch.search.sort.SortOrder;\nimport org.elasticsearch.test.ESIntegTestCase;\nimport org.junit.Before;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ExecutionException;\n\nimport static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_REPLICAS;\nimport static org.elasticsearch.cluster.metadata.IndexMetaData.SETTING_NUMBER_OF_SHARDS;\nimport static org.elasticsearch.index.query.QueryBuilders.boolQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.disMaxQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.matchAllQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.matchPhrasePrefixQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.matchPhraseQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.matchQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.multiMatchQuery;\nimport static org.elasticsearch.index.query.QueryBuilders.termQuery;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertAcked;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertFirstHit;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertHitCount;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertNoFailures;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSearchHits;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.assertSecondHit;\nimport static org.elasticsearch.test.hamcrest.ElasticsearchAssertions.hasId;\nimport static org.hamcrest.Matchers.anyOf;\nimport static org.hamcrest.Matchers.closeTo;\nimport static org.hamcrest.Matchers.empty;\nimport static org.hamcrest.Matchers.equalTo;\nimport static org.hamcrest.Matchers.greaterThan;\nimport static org.hamcrest.Matchers.greaterThanOrEqualTo;\nimport static org.hamcrest.Matchers.lessThan;\n\npublic class MultiMatchQueryIT extends ESIntegTestCase {\n\n    @Before\n    public void init() throws Exception {\n        CreateIndexRequestBuilder builder = prepareCreate(\"test\").setSettings(Settings.builder()\n                .put(indexSettings())\n                .put(SETTING_NUMBER_OF_SHARDS, 1)\n                .put(SETTING_NUMBER_OF_REPLICAS, 0)\n                .put(\"index.analysis.analyzer.perfect_match.type\", \"custom\")\n                .put(\"index.analysis.analyzer.perfect_match.tokenizer\", \"keyword\")\n                .put(\"index.analysis.analyzer.perfect_match.filter\", \"lowercase\")\n                .put(\"index.analysis.analyzer.category.type\", \"custom\")\n                .put(\"index.analysis.analyzer.category.tokenizer\", \"whitespace\")\n                .put(\"index.analysis.analyzer.category.filter\", \"lowercase\")\n        );\n        assertAcked(builder.addMapping(\"test\", createMapping()));\n        ensureGreen();\n        int numDocs = scaledRandomIntBetween(50, 100);\n        List<IndexRequestBuilder> builders = new ArrayList<>();\n        builders.add(client().prepareIndex(\"test\", \"test\", \"theone\").setSource(\n                \"full_name\", \"Captain America\",\n                \"first_name\", \"Captain\",\n                \"last_name\", \"America\",\n                \"category\", \"marvel hero\",\n                \"skill\", 15,\n                \"int-field\", 25));\n        builders.add(client().prepareIndex(\"test\", \"test\", \"theother\").setSource(\n                \"full_name\", \"marvel hero\",\n                \"first_name\", \"marvel\",\n                \"last_name\", \"hero\",\n                \"category\", \"bogus\",\n                \"skill\", 5));\n\n        builders.add(client().prepareIndex(\"test\", \"test\", \"ultimate1\").setSource(\n                \"full_name\", \"Alpha the Ultimate Mutant\",\n                \"first_name\", \"Alpha the\",\n                \"last_name\", \"Ultimate Mutant\",\n                \"category\", \"marvel hero\",\n                \"skill\", 1));\n        builders.add(client().prepareIndex(\"test\", \"test\", \"ultimate2\").setSource(\n                \"full_name\", \"Man the Ultimate Ninja\",\n                \"first_name\", \"Man the Ultimate\",\n                \"last_name\", \"Ninja\",\n                \"category\", \"marvel hero\",\n                \"skill\", 3));\n\n        builders.add(client().prepareIndex(\"test\", \"test\", \"anotherhero\").setSource(\n                \"full_name\", \"ultimate\",\n                \"first_name\", \"wolferine\",\n                \"last_name\", \"\",\n                \"category\", \"marvel hero\",\n                \"skill\", 1));\n        List<String> firstNames = new ArrayList<>();\n        fill(firstNames, \"Captain\", between(15, 25));\n        fill(firstNames, \"Ultimate\", between(5, 10));\n        fillRandom(firstNames, between(3, 7));\n        List<String> lastNames = new ArrayList<>();\n        fill(lastNames, \"Captain\", between(3, 7));\n        fillRandom(lastNames, between(30, 40));\n        for (int i = 0; i < numDocs; i++) {\n            String first = RandomPicks.randomFrom(random(), firstNames);\n            String last = randomPickExcept(lastNames, first);\n            builders.add(client().prepareIndex(\"test\", \"test\", \"\" + i).setSource(\n                    \"full_name\", first + \" \" + last,\n                    \"first_name\", first,\n                    \"last_name\", last,\n                    \"category\", randomBoolean() ? \"marvel hero\" : \"bogus\",\n                    \"skill\", between(1, 3)));\n        }\n        indexRandom(true, false, builders);\n    }\n\n    private XContentBuilder createMapping() throws IOException {\n        return XContentFactory.jsonBuilder().startObject().startObject(\"test\")\n                .startObject(\"properties\")\n                .startObject(\"full_name\")\n                .field(\"type\", \"text\")\n                .field(\"copy_to\", \"full_name_phrase\")\n                .field(\"analyzer\", \"perfect_match\")\n                .endObject()\n                .startObject(\"category\")\n                .field(\"type\", \"text\")\n                .field(\"analyzer\", \"category\")\n                .endObject()\n                .startObject(\"first_name\")\n                .field(\"type\", \"text\")\n                .field(\"norms\", false)\n                .field(\"copy_to\", \"first_name_phrase\")\n                .endObject()\n                .startObject(\"last_name\")\n                .field(\"type\", \"text\")\n                .field(\"norms\", false)\n                .field(\"copy_to\", \"last_name_phrase\")\n                .endObject()\n                .endObject()\n                .endObject().endObject();\n    }\n\n    public void testDefaults() throws ExecutionException, InterruptedException {\n        MatchQuery.Type type = randomBoolean() ? MatchQueryBuilder.DEFAULT_TYPE : MatchQuery.Type.BOOLEAN;\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR))).get();\n        Set<String> topNIds = Sets.newHashSet(\"theone\", \"theother\");\n        for (int i = 0; i < searchResponse.getHits().hits().length; i++) {\n            topNIds.remove(searchResponse.getHits().getAt(i).getId());\n            // very likely that we hit a random doc that has the same score so orders are random since\n            // the doc id is the tie-breaker\n        }\n        assertThat(topNIds, empty());\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR).useDisMax(false).type(type))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR).type(type))).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.AND).type(type))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.AND).type(type))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n    }\n\n    public void testPhraseType() {\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"Man the Ultimate\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(Operator.OR).type(MatchQuery.Type.PHRASE))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate2\"));\n        assertHitCount(searchResponse, 1L);\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"Captain\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(Operator.OR).type(MatchQuery.Type.PHRASE))).get();\n        assertThat(searchResponse.getHits().getTotalHits(), greaterThan(1L));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"the Ul\", \"full_name_phrase\", \"first_name_phrase\", \"last_name_phrase\", \"category_phrase\")\n                        .operator(Operator.OR).type(MatchQuery.Type.PHRASE_PREFIX))).get();\n        assertSearchHits(searchResponse, \"ultimate2\", \"ultimate1\");\n        assertHitCount(searchResponse, 2L);\n    }\n\n    public void testSingleField() throws NoSuchFieldException, IllegalAccessException {\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"skill\"))).get();\n        assertNoFailures(searchResponse);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"skill\", \"int-field\")).analyzer(\"category\")).get();\n        assertNoFailures(searchResponse);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        String[] fields = {\"full_name\", \"first_name\", \"last_name\", \"last_name_phrase\", \"first_name_phrase\", \"category_phrase\", \"category\"};\n\n        String[] query = {\"marvel\",\"hero\", \"captain\",  \"america\", \"15\", \"17\", \"1\", \"5\", \"ultimate\", \"Man\",\n                \"marvel\", \"wolferine\", \"ninja\"};\n\n        // check if it's equivalent to a match query.\n        int numIters = scaledRandomIntBetween(10, 100);\n        for (int i = 0; i < numIters; i++) {\n            String field = RandomPicks.randomFrom(random(), fields);\n            int numTerms = randomIntBetween(1, query.length);\n            StringBuilder builder = new StringBuilder();\n            for (int j = 0; j < numTerms; j++) {\n                builder.append(RandomPicks.randomFrom(random(), query)).append(\" \");\n            }\n            MultiMatchQueryBuilder multiMatchQueryBuilder = randomizeType(multiMatchQuery(builder.toString(), field));\n            SearchResponse multiMatchResp = client().prepareSearch(\"test\")\n                    // _uid sort field is a tie, in case hits have the same score,\n                    // the hits will be sorted the same consistently\n                    .addSort(\"_score\", SortOrder.DESC)\n                    .addSort(\"_uid\", SortOrder.ASC)\n                    .setQuery(multiMatchQueryBuilder).get();\n            MatchQueryBuilder matchQueryBuilder = QueryBuilders.matchQuery(field, builder.toString());\n            if (getType(multiMatchQueryBuilder) != null) {\n                matchQueryBuilder.type(MatchQuery.Type.valueOf(getType(multiMatchQueryBuilder).matchQueryType().toString()));\n            }\n            SearchResponse matchResp = client().prepareSearch(\"test\")\n                    // _uid tie sort\n                    .addSort(\"_score\", SortOrder.DESC)\n                    .addSort(\"_uid\", SortOrder.ASC)\n                    .setQuery(matchQueryBuilder).get();\n            assertThat(\"field: \" + field + \" query: \" + builder.toString(), multiMatchResp.getHits().getTotalHits(), equalTo(matchResp.getHits().getTotalHits()));\n            SearchHits hits = multiMatchResp.getHits();\n            for (int j = 0; j < hits.hits().length; j++) {\n                assertThat(hits.getHits()[j].score(), equalTo(matchResp.getHits().getHits()[j].score()));\n                assertThat(hits.getHits()[j].getId(), equalTo(matchResp.getHits().getHits()[j].getId()));\n            }\n        }\n\n    }\n\n    public void testCutoffFreq() throws ExecutionException, InterruptedException {\n        final long numDocs = client().prepareSearch(\"test\").setSize(0)\n                .setQuery(matchAllQuery()).get().getHits().totalHits();\n        MatchQuery.Type type = randomBoolean() ? MatchQueryBuilder.DEFAULT_TYPE : MatchQuery.Type.BOOLEAN;\n        Float cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR).cutoffFrequency(cutoffFrequency))).get();\n        Set<String> topNIds = Sets.newHashSet(\"theone\", \"theother\");\n        for (int i = 0; i < searchResponse.getHits().hits().length; i++) {\n            topNIds.remove(searchResponse.getHits().getAt(i).getId());\n            // very likely that we hit a random doc that has the same score so orders are random since\n            // the doc id is the tie-breaker\n        }\n        assertThat(topNIds, empty());\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThanOrEqualTo(searchResponse.getHits().hits()[1].getScore()));\n\n        cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR).useDisMax(false).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n        long size = searchResponse.getHits().getTotalHits();\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR).useDisMax(false).type(type))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theone\"), hasId(\"theother\")));\n        assertThat(\"common terms expected to be a way smaller result set\", size, lessThan(searchResponse.getHits().getTotalHits()));\n\n        cutoffFrequency = randomBoolean() ? Math.min(1, numDocs * 1.f / between(10, 20)) : 1.f / between(10, 20);\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.OR).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.AND).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.AND).cutoffFrequency(cutoffFrequency).type(type))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .operator(Operator.AND).cutoffFrequency(cutoffFrequency)\n                        .analyzer(\"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n    }\n\n    public void testEquivalence() {\n\n        final int numDocs = (int) client().prepareSearch(\"test\").setSize(0)\n                .setQuery(matchAllQuery()).get().getHits().totalHits();\n        int numIters = scaledRandomIntBetween(5, 10);\n        for (int i = 0; i < numIters; i++) {\n            {\n                MatchQuery.Type type = randomBoolean() ? MatchQueryBuilder.DEFAULT_TYPE : MatchQuery.Type.BOOLEAN;\n                MultiMatchQueryBuilder multiMatchQueryBuilder = randomBoolean() ? multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\") :\n                        multiMatchQuery(\"marvel hero captain america\", \"*_name\", randomBoolean() ? \"category\" : \"categ*\");\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(randomizeType(multiMatchQueryBuilder\n                                .operator(Operator.OR).type(type))).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(disMaxQuery().\n                                add(matchQuery(\"full_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"first_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"last_name\", \"marvel hero captain america\"))\n                                .add(matchQuery(\"category\", \"marvel hero captain america\"))\n                        ).get();\n                assertEquivalent(\"marvel hero captain america\", left, right);\n            }\n\n            {\n                MatchQuery.Type type = randomBoolean() ? MatchQueryBuilder.DEFAULT_TYPE : MatchQuery.Type.BOOLEAN;\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                Operator op = randomBoolean() ? Operator.AND : Operator.OR;\n                MultiMatchQueryBuilder multiMatchQueryBuilder = randomBoolean() ? multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\") :\n                        multiMatchQuery(\"captain america\", \"*_name\", randomBoolean() ? \"category\" : \"categ*\");\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(randomizeType(multiMatchQueryBuilder\n                                .operator(op).useDisMax(false).minimumShouldMatch(minShouldMatch).type(type))).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(randomBoolean() ? termQuery(\"full_name\", \"captain america\") : matchQuery(\"full_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"first_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"last_name\", \"captain america\").operator(op))\n                                .should(matchQuery(\"category\", \"captain america\").operator(op))\n                        ).get();\n                assertEquivalent(\"captain america\", left, right);\n            }\n\n            {\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                SearchResponse left = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(randomizeType(multiMatchQuery(\"capta\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                .type(MatchQuery.Type.PHRASE_PREFIX).useDisMax(false).minimumShouldMatch(minShouldMatch))).get();\n\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(matchPhrasePrefixQuery(\"full_name\", \"capta\"))\n                                .should(matchPhrasePrefixQuery(\"first_name\", \"capta\"))\n                                .should(matchPhrasePrefixQuery(\"last_name\", \"capta\"))\n                                .should(matchPhrasePrefixQuery(\"category\", \"capta\"))\n                        ).get();\n                assertEquivalent(\"capta\", left, right);\n            }\n            {\n                String minShouldMatch = randomBoolean() ? null : \"\" + between(0, 1);\n                SearchResponse left;\n                if (randomBoolean()) {\n                    left = client().prepareSearch(\"test\").setSize(numDocs)\n                            .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                            .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                    .type(MatchQuery.Type.PHRASE).useDisMax(false).minimumShouldMatch(minShouldMatch))).get();\n                } else {\n                    left = client().prepareSearch(\"test\").setSize(numDocs)\n                            .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                            .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                                    .type(MatchQuery.Type.PHRASE).tieBreaker(1.0f).minimumShouldMatch(minShouldMatch))).get();\n                }\n                SearchResponse right = client().prepareSearch(\"test\").setSize(numDocs)\n                        .addSort(SortBuilders.scoreSort()).addSort(SortBuilders.fieldSort(\"_uid\"))\n                        .setQuery(boolQuery().minimumShouldMatch(minShouldMatch)\n                                .should(matchPhraseQuery(\"full_name\", \"captain america\"))\n                                .should(matchPhraseQuery(\"first_name\", \"captain america\"))\n                                .should(matchPhraseQuery(\"last_name\", \"captain america\"))\n                                .should(matchPhraseQuery(\"category\", \"captain america\"))\n                        ).get();\n                assertEquivalent(\"captain america\", left, right);\n            }\n        }\n    }\n\n    public void testCrossFieldMode() throws ExecutionException, InterruptedException {\n        SearchResponse searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .operator(Operator.OR))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .operator(Operator.OR))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n        assertSecondHit(searchResponse, hasId(\"theother\"));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"marvel hero\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .operator(Operator.OR))).get();\n        assertFirstHit(searchResponse, hasId(\"theother\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america 15\", \"full_name\", \"first_name\", \"last_name\", \"category\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\")\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america 15\", \"full_name\", \"first_name\", \"last_name\", \"category\", \"skill\", \"int-field\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\")\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america 15\", \"skill\", \"full_name\", \"first_name\", \"last_name\", \"category\", \"int-field\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\")\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america 15\", \"first_name\", \"last_name\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"25 15\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"25 15\", \"int-field\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"25 15\", \"first_name\", \"int-field\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"25 15\", \"int-field\", \"skill\", \"first_name\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"25 15\", \"int-field\", \"first_name\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\"))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .cutoffFrequency(0.1f)\n                        .analyzer(\"category\")\n                        .operator(Operator.OR))).get();\n        assertFirstHit(searchResponse, anyOf(hasId(\"theother\"), hasId(\"theone\")));\n        long numResults = searchResponse.getHits().totalHits();\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\")\n                        .operator(Operator.OR))).get();\n        assertThat(numResults, lessThan(searchResponse.getHits().getTotalHits()));\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n\n        // test group based on analyzer -- all fields are grouped into a cross field search\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .analyzer(\"category\")\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 1L);\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n        // counter example\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .type(randomBoolean() ? MultiMatchQueryBuilder.Type.CROSS_FIELDS : MultiMatchQueryBuilder.DEFAULT_TYPE)\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 0L);\n\n        // counter example\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"captain america marvel hero\", \"first_name\", \"last_name\", \"category\")\n                        .type(randomBoolean() ? MultiMatchQueryBuilder.Type.CROSS_FIELDS : MultiMatchQueryBuilder.DEFAULT_TYPE)\n                        .operator(Operator.AND))).get();\n        assertHitCount(searchResponse, 0L);\n\n        // test if boosts work\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"the ultimate\", \"full_name\", \"first_name\", \"last_name\", \"category\").field(\"last_name\", 10)\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .operator(Operator.AND))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate1\"));   // has ultimate in the last_name and that is boosted\n        assertSecondHit(searchResponse, hasId(\"ultimate2\"));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        // since we try to treat the matching fields as one field scores are very similar but we have a small bias towards the\n        // more frequent field that acts as a tie-breaker internally\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"the ultimate\", \"full_name\", \"first_name\", \"last_name\", \"category\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .operator(Operator.AND))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate2\"));\n        assertSecondHit(searchResponse, hasId(\"ultimate1\"));\n        assertThat(searchResponse.getHits().hits()[0].getScore(), greaterThan(searchResponse.getHits().hits()[1].getScore()));\n\n        // Test group based on numeric fields\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"skill\", \"first_name\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        // Two numeric fields together caused trouble at one point!\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"int-field\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"15\", \"int-field\", \"first_name\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS))).get();\n        assertFirstHit(searchResponse, hasId(\"theone\"));\n\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"alpha 15\", \"first_name\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .lenient(true))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate1\"));\n        /*\n         * Doesn't find theone because \"alpha 15\" isn't a number and we don't\n         * break on spaces.\n         */\n        assertHitCount(searchResponse, 1);\n\n        // Lenient wasn't always properly lenient with two numeric fields\n        searchResponse = client().prepareSearch(\"test\")\n                .setQuery(randomizeType(multiMatchQuery(\"alpha 15\", \"int-field\", \"first_name\", \"skill\")\n                        .type(MultiMatchQueryBuilder.Type.CROSS_FIELDS)\n                        .lenient(true))).get();\n        assertFirstHit(searchResponse, hasId(\"ultimate1\"));\n    }\n\n    private static final void assertEquivalent(String query, SearchResponse left, SearchResponse right) {\n        assertNoFailures(left);\n        assertNoFailures(right);\n        SearchHits leftHits = left.getHits();\n        SearchHits rightHits = right.getHits();\n        assertThat(leftHits.getTotalHits(), equalTo(rightHits.getTotalHits()));\n        assertThat(leftHits.getHits().length, equalTo(rightHits.getHits().length));\n        SearchHit[] hits = leftHits.getHits();\n        SearchHit[] rHits = rightHits.getHits();\n        for (int i = 0; i < hits.length; i++) {\n            assertThat(\"query: \" + query + \" hit: \" + i, (double) hits[i].getScore(), closeTo(rHits[i].getScore(), 0.00001d));\n        }\n        for (int i = 0; i < hits.length; i++) {\n            if (hits[i].getScore() == hits[hits.length - 1].getScore()) {\n                return; // we need to cut off here since this is the tail of the queue and we might not have fetched enough docs\n            }\n            assertThat(\"query: \" + query, hits[i].getId(), equalTo(rHits[i].getId()));\n        }\n    }\n\n    public static List<String> fill(List<String> list, String value, int times) {\n        for (int i = 0; i < times; i++) {\n            list.add(value);\n        }\n        return list;\n    }\n\n    public List<String> fillRandom(List<String> list, int times) {\n        for (int i = 0; i < times; i++) {\n            list.add(randomAsciiOfLengthBetween(1, 5));\n        }\n        return list;\n    }\n\n    public <T> T randomPickExcept(List<T> fromList, T butNot) {\n        while (true) {\n            T t = RandomPicks.randomFrom(random(), fromList);\n            if (t.equals(butNot)) {\n                continue;\n            }\n            return t;\n        }\n    }\n\n    public MultiMatchQueryBuilder randomizeType(MultiMatchQueryBuilder builder) {\n        try {\n            MultiMatchQueryBuilder.Type type = getType(builder);\n            if (type == null && randomBoolean()) {\n                return builder;\n            }\n            if (type == null) {\n                type = MultiMatchQueryBuilder.Type.BEST_FIELDS;\n            }\n            if (randomBoolean()) {\n                builder.type(type);\n            } else {\n                Object oType = type;\n                switch (type) {\n                    case BEST_FIELDS:\n                        if (randomBoolean()) {\n                            oType = MatchQuery.Type.BOOLEAN;\n                        }\n                        break;\n                    case MOST_FIELDS:\n                        if (randomBoolean()) {\n                            oType = MatchQuery.Type.BOOLEAN;\n                        }\n                        break;\n                    case CROSS_FIELDS:\n                        break;\n                    case PHRASE:\n                        if (randomBoolean()) {\n                            oType = MatchQuery.Type.PHRASE;\n                        }\n                        break;\n                    case PHRASE_PREFIX:\n                        if (randomBoolean()) {\n                            oType = MatchQuery.Type.PHRASE_PREFIX;\n                        }\n                        break;\n                }\n                builder.type(oType);\n            }\n            return builder;\n        } catch (Exception ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private MultiMatchQueryBuilder.Type getType(MultiMatchQueryBuilder builder) throws NoSuchFieldException, IllegalAccessException {\n        return builder.getType();\n    }\n}\n", "goTemplate;\n\nimport java.util.List;\nimport java.util.stream.Collectors;\n\n/**\n * This is {@link MongoDbHealthIndicator} where it attempts to collect statistics\n * on all mongodb instances configured inside CAS.\n *\n * @author Misagh Moayyed\n * @since 5.2.0\n */\npublic class MongoDbHealthIndicator extends AbstractCacheHealthIndicator {\n    private final transient MongoTemplate mongoTemplate;\n\n    public MongoDbHealthIndicator(final MongoTemplate mongoTemplate,\n                                  final long evictionThreshold, final long threshold) {\n        super(evictionThreshold, threshold);\n        this.mongoTemplate = mongoTemplate;\n    }\n\n    @Override\n    protected CacheStatistics[] getStatistics() {\n        final List<CacheStatistics> list = mongoTemplate.getCollectionNames()\n            .stream()\n            .map(c -> {\n                val col = this.mongoTemplate.getMongoDbFactory().getLegacyDb().getCollection(c);\n                return new MongoDbCacheStatistics(col);\n            })\n            .collect(Collectors.toList());\n\n        return list.toArray(new CacheStatistics[]{});\n    }\n}\n", "nder the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n * \n * http://aws.amazon.com/apache2.0\n * \n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage com.amazonaws.services.iotwireless.model.transform;\n\nimport javax.annotation.Generated;\n\nimport com.amazonaws.SdkClientException;\nimport com.amazonaws.services.iotwireless.model.*;\n\nimport com.amazonaws.protocol.*;\nimport com.amazonaws.annotation.SdkInternalApi;\n\n/**\n * LoRaWANMulticastSessionMarshaller\n */\n@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\n@SdkInternalApi\npublic class LoRaWANMulticastSessionMarshaller {\n\n    private static final MarshallingInfo<Integer> DLDR_BINDING = MarshallingInfo.builder(MarshallingType.INTEGER).marshallLocation(MarshallLocation.PAYLOAD)\n            .marshallLocationName(\"DlDr\").build();\n    private static final MarshallingInfo<Integer> DLFREQ_BINDING = MarshallingInfo.builder(MarshallingType.INTEGER).marshallLocation(MarshallLocation.PAYLOAD)\n            .marshallLocationName(\"DlFreq\").build();\n    private static final MarshallingInfo<java.util.Date> SESSIONSTARTTIME_BINDING = MarshallingInfo.builder(MarshallingType.DATE)\n            .marshallLocation(MarshallLocation.PAYLOAD).marshallLocationName(\"SessionStartTime\").timestampFormat(\"iso8601\").build();\n    private static final MarshallingInfo<Integer> SESSIONTIMEOUT_BINDING = MarshallingInfo.builder(MarshallingType.INTEGER)\n            .marshallLocation(MarshallLocation.PAYLOAD).marshallLocationName(\"SessionTimeout\").build();\n\n    private static final LoRaWANMulticastSessionMarshaller instance = new LoRaWANMulticastSessionMarshaller();\n\n    public static LoRaWANMulticastSessionMarshaller getInstance() {\n        return instance;\n    }\n\n    /**\n     * Marshall the given parameter object.\n     */\n    public void marshall(LoRaWANMulticastSession loRaWANMulticastSession, ProtocolMarshaller protocolMarshaller) {\n\n        if (loRaWANMulticastSession == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(loRaWANMulticastSession.getDlDr(), DLDR_BINDING);\n            protocolMarshaller.marshall(loRaWANMulticastSession.getDlFreq(), DLFREQ_BINDING);\n            protocolMarshaller.marshall(loRaWANMulticastSession.getSessionStartTime(), SESSIONSTARTTIME_BINDING);\n            protocolMarshaller.marshall(loRaWANMulticastSession.getSessionTimeout(), SESSIONTIMEOUT_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n\n}\n", "2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.asakusafw.compiler.flow.processor.flow;\n\nimport com.asakusafw.compiler.flow.processor.MasterCheckFlowProcessor;\nimport com.asakusafw.compiler.flow.processor.operator.MasterCheckFlowFactory;\nimport com.asakusafw.compiler.flow.processor.operator.MasterCheckFlowFactory.Selection;\nimport com.asakusafw.compiler.flow.testing.external.Ex1MockExporterDescription;\nimport com.asakusafw.compiler.flow.testing.external.Ex1MockImporterDescription;\nimport com.asakusafw.compiler.flow.testing.external.Ex2MockImporterDescription;\nimport com.asakusafw.compiler.flow.testing.model.Ex1;\nimport com.asakusafw.compiler.flow.testing.model.Ex2;\nimport com.asakusafw.vocabulary.flow.Export;\nimport com.asakusafw.vocabulary.flow.FlowDescription;\nimport com.asakusafw.vocabulary.flow.Import;\nimport com.asakusafw.vocabulary.flow.In;\nimport com.asakusafw.vocabulary.flow.JobFlow;\nimport com.asakusafw.vocabulary.flow.Out;\n\n\n/**\n * test for {@link MasterCheckFlowProcessor}.\n */\n@JobFlow(name = \"testing\")\npublic class MasterCheckFlowSelection extends FlowDescription {\n\n    private In<Ex1> in1;\n\n    private In<Ex2> in2;\n\n    private Out<Ex1> out1;\n\n    private Out<Ex1> out2;\n\n    /**\n     * Creates a new instance.\n     * @param in1 input1\n     * @param in2 input2\n     * @param out1 output1\n     * @param out2 output2\n     */\n    public MasterCheckFlowSelection(\n            @Import(name = \"e1\", description = Ex1MockImporterDescription.class)\n            In<Ex1> in1,\n            @Import(name = \"e2\", description = Ex2MockImporterDescription.class)\n            In<Ex2> in2,\n            @Export(name = \"e1\", description = Ex1MockExporterDescription.class)\n            Out<Ex1> out1,\n            @Export(name = \"e2\", description = Ex1MockExporterDescription.class)\n            Out<Ex1> out2) {\n        this.in1 = in1;\n        this.in2 = in2;\n        this.out1 = out1;\n        this.out2 = out2;\n    }\n\n    @Override\n    protected void describe() {\n        MasterCheckFlowFactory f = new MasterCheckFlowFactory();\n        Selection op = f.selection(in2, in1);\n        out1.add(op.found);\n        out2.add(op.missed);\n    }\n}\n", ".0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.springsource.loaded;\n\nimport java.lang.reflect.Modifier;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.objectweb.asm.ClassReader;\nimport org.objectweb.asm.ClassVisitor;\nimport org.objectweb.asm.ClassWriter;\nimport org.objectweb.asm.FieldVisitor;\nimport org.objectweb.asm.Label;\nimport org.objectweb.asm.MethodVisitor;\nimport org.objectweb.asm.Opcodes;\nimport org.springsource.loaded.TypeRegistry.CouldBeReloadableDecision;\nimport org.springsource.loaded.TypeRegistry.ReloadableTypeNameDecision;\nimport org.springsource.loaded.Utils.ReturnType;\n\n\n/**\n * Rewrites a class such that it is amenable to reloading. This involves:\n * <ul>\n * <li>In every method, introduce logic to check it it the latest version of that method - if it isn't dispatch to the\n * latest\n * <li>Creates additional methods to aid with field setting/getting\n * <li>Creates additional fields to help reloading (reloadable type instance, new field value holders)\n * <li>Creates catchers for inherited methods. Catchers are simply passed through unless a new version of the class\n * provides an implementation\n * </ul>\n *\n * @author Andy Clement\n * @since 0.5.0\n */\npublic class TypeRewriter implements Constants {\n\n\tprivate static Logger log = Logger.getLogger(TypeRewriter.class.getName());\n\n\tpublic static byte[] rewrite(ReloadableType rtype, byte[] bytes) {\n\t\tClassReader fileReader = new ClassReader(bytes);\n\t\tRewriteClassAdaptor classAdaptor = new RewriteClassAdaptor(rtype);\n\t\tfileReader.accept(classAdaptor, 0);\n\t\treturn classAdaptor.getBytes();\n\t}\n\n\tstatic class RewriteClassAdaptor extends ClassVisitor implements Constants {\n\n\t\tprivate ClassWriter cw;\n\n\t\tprivate String slashedname;\n\n\t\tprivate ReloadableType rtype;\n\n\t\tprivate TypeDescriptor typeDescriptor;\n\n\t\tprivate boolean clinitDone = false;\n\n\t\tprivate String supertypeName;\n\n\t\tprivate boolean isInterface;\n\n\t\tprivate int isTopmostReloadable = -1; // -1 = not computed. 0=false, 1=true\n\n\t\tprivate boolean isEnum;\n\n\t\tprivate boolean isGroovy;\n\n\t\tpublic RewriteClassAdaptor(ReloadableType rtype) {\n\t\t\tthis(rtype, new ClassWriter(ClassWriter.COMPUTE_MAXS));\n\t\t}\n\n\t\tpublic RewriteClassAdaptor(ReloadableType rtype, ClassWriter classWriter) {\n\t\t\tsuper(ASM5, classWriter);\n\t\t\tthis.rtype = rtype;\n\t\t\tthis.slashedname = rtype.getSlashedName();\n\t\t\tthis.cw = (ClassWriter) cv;\n\t\t\tthis.typeDescriptor = rtype.getTypeDescriptor();\n\t\t\tthis.isInterface = typeDescriptor.isInterface();\n\t\t\tthis.isEnum = typeDescriptor.isEnum();\n\t\t\tthis.isGroovy = typeDescriptor.isGroovyType();\n\t\t}\n\n\t\tpublic byte[] getBytes() {\n\t\t\treturn cw.toByteArray();\n\t\t}\n\n\t\tpublic ClassVisitor getClassVisitor() {\n\t\t\treturn cw;\n\t\t}\n\n\t\t@Override\n\t\tpublic void visit(int version, int access, String name, String signature, String superName,\n\t\t\t\tString[] interfaces) {\n\t\t\taccess = Utils.promoteDefaultOrPrivateOrProtectedToPublic(access);\n\t\t\tsuper.visit(version, access, name, signature, superName, interfaces);\n\n\t\t\tthis.supertypeName = superName;\n\t\t\t// Extra members in a reloadable type\n\t\t\tcreateReloadableTypeField();\n\t\t\tif (GlobalConfiguration.fieldRewriting) {\n\t\t\t\tif (!isInterface) {\n\t\t\t\t\tif (isTopmostReloadable()) {\n\t\t\t\t\t\tcreateInstanceStateManagerInstance();\n\t\t\t\t\t}\n\t\t\t\t\tcreateInstanceFieldGetterMethod();\n\t\t\t\t\tcreateInstanceFieldSetterMethod();\n\t\t\t\t\tcreateStaticFieldSetterMethod();\n\t\t\t\t\tcreateStaticFieldGetterMethod();\n\t\t\t\t\tcreateStaticInitializerForwarderMethod();\n\t\t\t\t}\n\t\t\t\tif (isTopmostReloadable()) {\n\t\t\t\t\tcreateStaticStateManagerInstance();\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!isInterface) {\n\t\t\t\tcreateManagedConstructors();\n\t\t\t\tcreateDispatcherCallingInitCtors();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Determine if this type is the top most reloadable type. Some state is only inserted into the top most\n\t\t * reloadable type in a hierarchy, rather than into every reloadable type. Typically this type will be the top\n\t\t * most reloadable if the supertype comes from a jar or is in a package we know is not reloadable (e.g.\n\t\t * java.lang).\n\t\t *\n\t\t * @return true if top most reloadable\n\t\t */\n\t\tprivate boolean isTopmostReloadable() {\n\t\t\tif (isTopmostReloadable > -1) {\n\t\t\t\treturn isTopmostReloadable == 1;\n\t\t\t}\n\t\t\tboolean result = false;\n\t\t\tTypeRegistry typeRegistry = rtype.getTypeRegistry();\n\t\t\tString supertypeName = typeDescriptor.getSupertypeName();\n\t\t\tReloadableTypeNameDecision rtnd = typeRegistry.isReloadableTypeName(supertypeName, null, null);\n\t\t\tif (rtnd.isReloadable) {\n\t\t\t\t// If splitPackages option is turned ON or super type is being explicitly included via pattern,\n\t\t\t\t// dig a bit deeper. It may still be excluded due to being in a non watched jar. (So effectively the\n\t\t\t\t// inclusion pattern does not apply to jar contents).\n\t\t\t\tif (GlobalConfiguration.allowSplitPackages || rtnd.explicitlyIncluded) {\n\t\t\t\t\tCouldBeReloadableDecision cbrd = rtnd.cbrd;\n\t\t\t\t\tif (cbrd == null) {\n\t\t\t\t\t\tcbrd = typeRegistry.couldBeReloadable(supertypeName, false);\n\t\t\t\t\t}\n\t\t\t\t\tresult = !cbrd.couldBeReloadable;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = false;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tresult = true;\n\t\t\t}\n\t\t\tisTopmostReloadable = result ? 1 : 0;\n\t\t\treturn result;\n\n\t\t\t// this would work if the supertype was always guaranteed to be dealt with before this type\n\t\t\t// return typeRegistry.getReloadableType(typeDescriptor.getSupertypeName(), false) == null;\n\n\t\t\t// original decision:\n\t\t\t// This makes a mistake for split packages\n\t\t\t//\t\t\tif (!typeRegistry.isReloadableTypeName(supertypeName)) {\n\t\t\t//\t\t\t\treturn true;\n\t\t\t//\t\t\t}\n\t\t\t//\t\t\telse {\n\t\t\t//\t\t\t\treturn false;\n\t\t\t//\t\t\t}\n\t\t}\n\n\t\tprivate void createStaticInitializerForwarderMethod() {\n\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC_STATIC, mStaticInitializerName, \"()V\", null, null);\n\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tReloadableType, \"fetchLatest\", \"()Ljava/lang/Object;\");\n\t\t\tmv.visitTypeInsn(CHECKCAST, Utils.getInterfaceName(slashedname));\n\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, Utils.getInterfaceName(slashedname), mStaticInitializerName, \"()V\");\n\t\t\tmv.visitInsn(RETURN);\n\t\t\tmv.visitMaxs(1, 0);\n\t\t\tmv.visitEnd();\n\t\t}\n\n\t\t// TODO review whether we get these up and down the hierarchy or just at the top?\n\t\t/**\n\t\t * Create the static field getter method which ensures the static state manager is initialized.\n\t\t */\n\t\tprivate void createStaticFieldGetterMethod() {\n\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC_STATIC, mStaticFieldGetterName,\n\t\t\t\t\t\"(Ljava/lang/String;)Ljava/lang/Object;\",\n\t\t\t\t\tnull, null);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\tLabel l2 = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL, l2);\n\t\t\tmv.visitTypeInsn(NEW, tStaticStateManager);\n\t\t\tmv.visitInsn(DUP);\n\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tStaticStateManager, \"<init>\", \"()V\");\n\t\t\tmv.visitFieldInsn(PUTSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\tmv.visitLabel(l2);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tStaticStateManager, \"getValue\", \"(\" + lReloadableType\n\t\t\t\t\t+ \"Ljava/lang/String;)Ljava/lang/Object;\");\n\t\t\tmv.visitInsn(ARETURN);\n\t\t\tmv.visitMaxs(3, 2);\n\t\t\tmv.visitEnd();\n\t\t}\n\n\t\tprivate void createDispatcherCallingInitCtors() {\n\t\t\tMethodMember[] ctors = typeDescriptor.getConstructors();\n\t\t\tfor (MethodMember ctor : ctors) {\n\t\t\t\tString desc = ctor.getDescriptor();\n\t\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"___init___\", desc, null, null);\n\t\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitInsn(ICONST_1);\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tReloadableType, \"getLatestDispatcherInstance\",\n\t\t\t\t\t\t\"(Z)Ljava/lang/Object;\");\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, Utils.getInterfaceName(slashedname));\n\t\t\t\tString desc2 = new StringBuffer(\"(L\").append(slashedname).append(\";\").append(\n\t\t\t\t\t\tdesc.substring(1)).toString();\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, desc, 1);\n\t\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, Utils.getInterfaceName(slashedname), \"___init___\", desc2);\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\tmv.visitMaxs(3, Utils.getParameterCount(desc) + 1);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\t\t}\n\n\t\tprivate void createManagedConstructors() {\n\t\t\tString slashedSupertypeName = typeDescriptor.getSupertypeName();\n\t\t\tif (slashedSupertypeName.equals(\"java/lang/Enum\")) { // assert isEnum\n\t\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\",\n\t\t\t\t\t\t\"(Ljava/lang/String;ILorg/springsource/loaded/C;)V\", null,\n\t\t\t\t\t\tnull);\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\tmv.visitVarInsn(ALOAD, 1);\n\t\t\t\tmv.visitVarInsn(ILOAD, 2);\n\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Enum\", \"<init>\", \"(Ljava/lang/String;I)V\");\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\tmv.visitMaxs(3, 3);\n\t\t\t\tmv.visitEnd();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (slashedSupertypeName.equals(\"groovy/lang/Closure\")) { // assert this is a closure\n\t\t\t\t// create the special constructor we want to use, not the one below\n\t\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\",\n\t\t\t\t\t\t\"(Ljava/lang/Object;Ljava/lang/Object;Lorg/springsource/loaded/C;)V\", null, null);\n\t\t\t\tTypeDescriptor superDescriptor = rtype.getTypeRegistry().getDescriptorFor(supertypeName);\n\t\t\t\tMethodMember ctor = superDescriptor.getConstructor(\"(Ljava/lang/Object;Ljava/lang/Object;)V\");\n\t\t\t\tif (ctor == null) {\n\t\t\t\t\tthrow new IllegalStateException(\"Unable to find expected constructor on Closure type\");\n\t\t\t\t}\n\t\t\t\tmv.visitVarInsn(ALOAD, 0); // this (uninitialized)\n\t\t\t\tmv.visitVarInsn(ALOAD, 1); // 'owner'\n\t\t\t\tmv.visitVarInsn(ALOAD, 2); // 'this'\n\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"groovy/lang/Closure\", \"<init>\",\n\t\t\t\t\t\t\"(Ljava/lang/Object;Ljava/lang/Object;)V\");\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\tmv.visitMaxs(3, 4);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"(Lorg/springsource/loaded/C;)V\", null, null);\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\tif (slashedSupertypeName.equals(\"java/lang/Object\")) {\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\");\n\t\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\t\tmv.visitMaxs(1, 2);\n\t\t\t\t}\n\t\t\t\telse if (slashedSupertypeName.equals(\"java/lang/Enum\")) { // assert isEnum\n\t\t\t\t\t// Call Enum.<init>(null,0)\n\t\t\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t\t\t\tmv.visitLdcInsn(0);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Enum\", \"<init>\", \"(Ljava/lang/String;I)V\");\n\t\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\t\tmv.visitMaxs(3, 3);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tReloadableType superRtype = rtype.getTypeRegistry().getReloadableType(slashedSupertypeName);\n\t\t\t\t\tif (superRtype == null) {\n\t\t\t\t\t\t// This means we are crossing a reloadable boundary (this type is reloadable, the supertype is not).\n\t\t\t\t\t\t// At this point we may be in trouble.  The only time we'll be OK is if the supertype declares a no-arg lructor\n\t\t\t\t\t\t// we can see from here\n\t\t\t\t\t\tTypeDescriptor superDescriptor = rtype.getTypeRegistry().getDescriptorFor(supertypeName);\n\t\t\t\t\t\tMethodMember ctor = superDescriptor.getConstructor(\"()V\");\n\t\t\t\t\t\tif (ctor != null) {\n\t\t\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, slashedSupertypeName, \"<init>\", \"()V\");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tString warningMessage = \"SERIOUS WARNING (current limitation): At reloadable boundary of \"\n\t\t\t\t\t\t\t\t\t+ typeDescriptor.getDottedName()\n\t\t\t\t\t\t\t\t\t+ \" supertype=\"\n\t\t\t\t\t\t\t\t\t+ supertypeName\n\t\t\t\t\t\t\t\t\t+ \" - no available default ctor for that supertype, problems may occur on reload if constructor changes\";\n\t\t\t\t\t\t\tif (GlobalConfiguration.isRuntimeLogging && log.isLoggable(Level.SEVERE)) {\n\t\t\t\t\t\t\t\tlog.log(Level.SEVERE, warningMessage);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// suppress for closure subtypes\n\t\t\t\t\t\t\tif (!(supertypeName.equals(\"groovy/lang/Closure\")\n\t\t\t\t\t\t\t\t\t|| supertypeName.startsWith(\"org/codehaus/groovy/runtime/callsite\"))) {\n\t\t\t\t\t\t\t\tif (GlobalConfiguration.verboseMode) {\n\t\t\t\t\t\t\t\t\tSystem.out.println(warningMessage);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// TODO [verify] running enumtests we see that there is an issue here with leaving the special constructor without a super call in it.\n\t\t\t\t\t\t\t// this will fail verification.\n\n\t\t\t\t\t\t\t// throw new IllegalStateException(\"at reloadable boundary, not sure how to construct \" + supertypeName);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, slashedSupertypeName, \"<init>\",\n\t\t\t\t\t\t\t\t\"(Lorg/springsource/loaded/C;)V\");\n\t\t\t\t\t}\n\t\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\t\tmv.visitMaxs(2, 2);\n\t\t\t\t}\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\n\t\t}\n\n\t\t/**\n\t\t * Create the static field setter method. Looks a bit like this:\n\t\t * <p>\n\t\t * <code><pre>\n\t\t * public static r$sets(Object newValue, String name) {\n\t\t *   if (r$fields==null) {\n\t\t *     r$fields = new SSMgr();\n\t\t *   }\n\t\t *   r$fields.setValue(reloadableTypeInstance, newValue, name);\n\t\t * }\n\t\t * </pre></code>\n\t\t */\n\t\tprivate void createStaticFieldSetterMethod() {\n\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC_STATIC, mStaticFieldSetterName, mStaticFieldSetterDescriptor,\n\t\t\t\t\tnull, null);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\tLabel l2 = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL, l2);\n\t\t\tmv.visitTypeInsn(NEW, tStaticStateManager);\n\t\t\tmv.visitInsn(DUP);\n\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tStaticStateManager, \"<init>\", \"()V\", false);\n\t\t\tmv.visitFieldInsn(PUTSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\tmv.visitLabel(l2);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\tmv.visitVarInsn(ALOAD, 1);\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tStaticStateManager, \"setValue\", \"(\" + lReloadableType\n\t\t\t\t\t+ \"Ljava/lang/Object;Ljava/lang/String;)V\", false);\n\t\t\tmv.visitInsn(RETURN);\n\t\t\tmv.visitMaxs(4, 2);\n\t\t\tmv.visitEnd();\n\t\t}\n\n\t\t/**\n\t\t * Create the instance field getter method. Looks a bit like this:\n\t\t * <p>\n\t\t * <code><pre>\n\t\t * public Object r$get(Object instance, String name) {\n\t\t *   if (this.instanceStateManager==null) {\n\t\t *     this.instanceStateManager = new InstanceStateManager();\n\t\t *   }\n\t\t *   return this.instanceStateManager.getValue(reloadableType,instance,name);\n\t\t * }\n\t\t * </pre></code>\n\t\t */\n\t\tprivate void createInstanceFieldGetterMethod() {\n\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, mInstanceFieldGetterName, mInstanceFieldGetterDescriptor,\n\t\t\t\t\tnull, null);\n\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\tLabel l1 = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL, l1);\n\t\t\t// instance state manager will only get initialised here if the constructor did not do it\n\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\tmv.visitTypeInsn(NEW, tInstanceStateManager);\n\t\t\tmv.visitInsn(DUP);\n\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tInstanceStateManager, \"<init>\",\n\t\t\t\t\t\"(Ljava/lang/Object;Lorg/springsource/loaded/ReloadableType;)V\");\n\t\t\tmv.visitFieldInsn(PUTFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\tmv.visitLabel(l1);\n\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\tmv.visitVarInsn(ALOAD, 1);\n\t\t\tmv.visitVarInsn(ALOAD, 2);\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tInstanceStateManager, \"getValue\", \"(\" + lReloadableType\n\t\t\t\t\t+ \"Ljava/lang/Object;Ljava/lang/String;)Ljava/lang/Object;\");\n\t\t\tmv.visitInsn(ARETURN);\n\t\t\tmv.visitMaxs(4, 3);\n\t\t\tmv.visitEnd();\n\t\t}\n\n\t\tprivate final static int lvThis = 0;\n\n\t\t// TODO [perf] shuffle ordering of value/instance passed in here to speed up things? (see also rewritePUTFIELD) can we reduce/remove swap\n\t\t/**\n\t\t * Create a field setter for instance fields, signature of: public void r$set(Object,Object,String)\n\t\t */\n\t\tprivate void createInstanceFieldSetterMethod() {\n\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, mInstanceFieldSetterName, mInstanceFieldSetterDescriptor,\n\t\t\t\t\tnull, null);\n\t\t\tfinal int lvNewValue = 1;\n\t\t\tfinal int lvInstance = 2;\n\t\t\tfinal int lvName = 3;\n\t\t\tmv.visitVarInsn(ALOAD, lvThis);\n\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\t// Will only get initialised here if the constructor did not do it\n\t\t\tLabel l1 = new Label();\n\t\t\tmv.visitJumpInsn(IFNONNULL, l1);\n\t\t\t// Initialise the Instance State Manager\n\t\t\tmv.visitVarInsn(ALOAD, lvThis);\n\t\t\tmv.visitTypeInsn(NEW, tInstanceStateManager);\n\t\t\tmv.visitInsn(DUP);\n\t\t\tmv.visitVarInsn(ALOAD, lvThis);\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tInstanceStateManager, \"<init>\",\n\t\t\t\t\t\"(Ljava/lang/Object;Lorg/springsource/loaded/ReloadableType;)V\");\n\t\t\tmv.visitFieldInsn(PUTFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\tmv.visitLabel(l1);\n\n\t\t\t// get the instance state manager object\n\t\t\tmv.visitVarInsn(ALOAD, lvThis);\n\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\n\t\t\t// get the reloadable type\n\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\n\t\t\t// TODO [perf] do we need to pass reloadabletype? Shouldn't the ISMgr instance know it!\n\t\t\t// call setValue\n\t\t\tmv.visitVarInsn(ALOAD, lvInstance);\n\t\t\tmv.visitVarInsn(ALOAD, lvNewValue);\n\t\t\tmv.visitVarInsn(ALOAD, lvName);\n\t\t\t// setValue(ReloadableType rtype, Object instance, Object value, String name)\n\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tInstanceStateManager, \"setValue\", \"(\" + lReloadableType\n\t\t\t\t\t+ \"Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/String;)V\");\n\t\t\tmv.visitInsn(RETURN);\n\t\t\tmv.visitMaxs(4, 4);\n\t\t\tmv.visitEnd();\n\t\t}\n\n\t\tprivate void createInstanceStateManagerInstance() {\n\t\t\tFieldVisitor f = cw.visitField(ACC_PUBLIC | ACC_TRANSIENT, fInstanceFieldsName, lInstanceStateManager,\n\t\t\t\t\tnull, null);\n\t\t\tf.visitEnd();\n\t\t}\n\n\t\tprivate void createStaticStateManagerInstance() {\n\t\t\tFieldVisitor f = cw.visitField(ACC_PUBLIC_STATIC /*| ACC_TRANSIENT*/ | ACC_FINAL, fStaticFieldsName,\n\t\t\t\t\tlStaticStateManager, null, null);\n\t\t\tf.visitEnd();\n\t\t}\n\n\t\t/**\n\t\t * Create the reloadable type field, which can later answer questions about changes or be used to access the\n\t\t * latest version of a type/method.\n\t\t */\n\t\tprivate void createReloadableTypeField() {\n\t\t\tint acc = isInterface ? ACC_PUBLIC_STATIC_FINAL : ACC_PUBLIC_STATIC; //ACC_PRIVATE_STATIC;\n\t\t\tFieldVisitor fv = cw.visitField(acc, fReloadableTypeFieldName, lReloadableType, null, null);\n\t\t\tfv.visitEnd();\n\t\t}\n\n\t\t@Override\n\t\tpublic MethodVisitor visitMethod(int flags, String name, String descriptor, String signature,\n\t\t\t\tString[] exceptions) {\n\t\t\tMethodVisitor mv = super.visitMethod(promoteIfNecessary(flags, name), name, descriptor, signature,\n\t\t\t\t\texceptions);\n\t\t\tMethodVisitor newMethodVisitor = getMethodVisitor(name, descriptor, mv);\n\t\t\treturn newMethodVisitor;\n\t\t}\n\n\t\tpublic MethodVisitor getMethodVisitor(String name, String descriptor, MethodVisitor mv) {\n\t\t\tMethodVisitor newMethodVisitor = null;\n\t\t\tif (name.charAt(0) == '<') {\n\t\t\t\tif (name.charAt(1) == 'c') { // <clinit>\n\t\t\t\t\tclinitDone = true;\n\t\t\t\t\tnewMethodVisitor = new MethodPrepender(mv, new ClinitPrepender(mv));\n\t\t\t\t}\n\t\t\t\telse { // <init>\n\t\t\t\t\tnewMethodVisitor = new AugmentingConstructorAdapter(mv, descriptor, slashedname,\n\t\t\t\t\t\t\tisTopmostReloadable());\n\t\t\t\t\t// want to create a copy of the constructor called ___init___ so it is reachable from the executor of the subtype.\n\t\t\t\t\t// All it really needs to do is call through the dispatcher to the executor for the relevant constructor.\n\t\t\t\t\t// this will force a reload of the supertype (to create the super executor) - that is something we can address later\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// what about just copying if isgroovy and name.startsWith(\"$get\");\n\t\t\t\t// Can't do this for $getStaticMetaClass so let us use $get$$ for now, until we discover why that lets us down...\n\t\t\t\t//\t\t\t\tif (isGroovy && name.startsWith(\"$get$$\")) {\n\t\t\t\t//\t\t\t\t\tnewMethodVisitor = new MethodAdapter(mv);\n\t\t\t\t//\t\t\t\t} else {\n\t\t\t\tnewMethodVisitor = new AugmentingMethodAdapter(mv, name, descriptor);\n\t\t\t\t//\t\t\t\t}\n\t\t\t}\n\t\t\treturn newMethodVisitor;\n\t\t}\n\n\t\t// Default visibility elements need promotion to public so that they can be seen from the executor\n\t\tprivate int promoteIfNecessary(int flags, String name) {\n\t\t\tint newflags = Utils.promoteDefaultOrProtectedToPublic(flags, isEnum, name);\n\t\t\treturn newflags;\n\t\t}\n\n\t\t@Override\n\t\tpublic FieldVisitor visitField(final int access, final String name, final String desc, final String signature,\n\t\t\t\tfinal Object value) {\n\t\t\t// Special casing here for serialVersionUID - not removing the final modifier.  This enables\n\t\t\t// the code in java.io.ObjectStreamClass to access it.\n\t\t\tint modAccess = 0;\n\t\t\tif ((access & ACC_FINAL) != 0) {\n\t\t\t\tif (name.equals(\"serialVersionUID\")) {\n\t\t\t\t\tmodAccess = (access & ~(ACC_PRIVATE | ACC_PROTECTED)) | ACC_PUBLIC;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// remove final\n\t\t\t\t\tmodAccess = (access & ~(ACC_PRIVATE | ACC_PROTECTED)) | ACC_PUBLIC;\n\t\t\t\t\tmodAccess = modAccess & ~ACC_FINAL;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// remove final\n\t\t\t\tmodAccess = (access & ~(ACC_PRIVATE | ACC_PROTECTED)) | ACC_PUBLIC;\n\t\t\t\tmodAccess = modAccess & ~ACC_FINAL;\n\t\t\t}\n\t\t\treturn cv.visitField(modAccess, name, desc, signature, value);\n\t\t}\n\n\t\tstatic class FieldHolder {\n\n\t\t\tfinal int access;\n\n\t\t\tfinal String name;\n\n\t\t\tfinal String desc;\n\n\t\t\tpublic FieldHolder(int access, String name, String desc) {\n\t\t\t\tthis.access = access;\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.desc = desc;\n\t\t\t}\n\t\t}\n\n\t\t@Override\n\t\tpublic void visitEnd() {\n\t\t\tif (!clinitDone) {\n\t\t\t\t// Need to add a static initializer to initialize the reloadable type field\n\t\t\t\tMethodVisitor mv = cw.visitMethod(ACC_STATIC, \"<clinit>\", \"()V\", null, null);\n\t\t\t\tnew ClinitPrepender(mv).prepend();\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\tmv.visitMaxs(3, 0);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\t\t\tgenerateCatchers();\n\t\t\tgenerateDynamicDispatchHandler();\n\t\t\tcv.visitEnd();\n\t\t}\n\n\t\t/**\n\t\t * Create a basic dynamic dispatch handler. To support changes to interfaces, a new method is added to all\n\t\t * reloadable interfaces and this needs an implementation. This method generates the implementation which\n\t\t * delegates to the reloadable interface for the type. As interfaces can't get static methods we only have to\n\t\t * worry about instance methods here.\n\t\t */\n\t\tprivate void generateDynamicDispatchHandler() {\n\t\t\tfinal int indexThis = 0;\n\t\t\tfinal int indexArgs = 1;\n\t\t\tfinal int indexTargetInstance = 2;\n\t\t\tfinal int indexNameAndDescriptor = 3;\n\n\t\t\tif (isInterface) {\n\t\t\t\tcw.visitMethod(ACC_PUBLIC_ABSTRACT, mDynamicDispatchName, mDynamicDispatchDescriptor, null, null);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, mDynamicDispatchName, mDynamicDispatchDescriptor, null,\n\t\t\t\t\t\tnull);\n\n\t\t\t\t// Sometimes we come into the dynamic dispatcher because we are handling an INVOKEINTERFACE for a method\n\t\t\t\t// not defined on the original interface.  In these cases we will find that fetchLatest() returns null because\n\t\t\t\t// the interface was reloaded, but the implementation was not (necessarily).  Should we force it to reload\n\t\t\t\t// the implementation?  That would generate the correct dispatcher...\n\n\t\t\t\t// 1. Ask the reloadable type for the latest version of the interface\n\t\t\t\t//    __DynamicallyDispatchable dispatchable = r$type.determineDispatcher(this,nameAndDescriptor)\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitVarInsn(ALOAD, indexThis);\n\t\t\t\tmv.visitVarInsn(ALOAD, indexNameAndDescriptor);\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tReloadableType, \"determineDispatcher\",\n\t\t\t\t\t\t\"(Ljava/lang/Object;Ljava/lang/String;)Lorg/springsource/loaded/__DynamicallyDispatchable;\");\n\n\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\tLabel l1 = new Label();\n\t\t\t\tmv.visitJumpInsn(IFNULL, l1);\n\t\t\t\t{\n\t\t\t\t\t// 2. package up the parameters\n\t\t\t\t\t// can I assert that 0==2 - ie. the instance being called upon is the same as the parameter passed in\n\t\t\t\t\tmv.visitVarInsn(ALOAD, indexArgs);\n\t\t\t\t\tmv.visitVarInsn(ALOAD, indexThis);\n\t\t\t\t\tmv.visitVarInsn(ALOAD, indexNameAndDescriptor);\n\n\t\t\t\t\t// 3. call it\n\t\t\t\t\t//    return dispatchable.__execute(parameters,this,nameAndDescriptor)\n\t\t\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"org/springsource/loaded/__DynamicallyDispatchable\",\n\t\t\t\t\t\t\tmDynamicDispatchName,\n\t\t\t\t\t\t\tmDynamicDispatchDescriptor);\n\t\t\t\t\tmv.visitInsn(ARETURN);\n\t\t\t\t}\n\t\t\t\tmv.visitLabel(l1);\n\t\t\t\tmv.visitInsn(POP); // POPNULL\n\n\t\t\t\t// delegate to the superclass dynamic dispatch method\n\t\t\t\t//\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t//\t\t\t\tmv.visitVarInsn(ALOAD, 1);\n\t\t\t\t//\t\t\t\tmv.visitVarInsn(ALOAD, 2);\n\t\t\t\t//\t\t\t\tmv.visitVarInsn(ALOAD, 3);\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, supertypeName, mDynamicDispatchName, mDynamicDispatchDescriptor);\n\t\t\t\t//\t\t\t\tmv.visitInsn(ARETURN);\n\n\t\t\t\t// 4. throw NoSuchMethodError\n\t\t\t\tgenThrowNoSuchMethodError(mv, indexNameAndDescriptor);\n\t\t\t\tmv.visitMaxs(5, 4);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * @param mv where to append the instructions\n\t\t * @param index the index of the String message to load and use in the exception\n\t\t */\n\t\tprivate final void genThrowNoSuchMethodError(MethodVisitor mv, int index) {\n\t\t\tmv.visitTypeInsn(NEW, \"java/lang/NoSuchMethodError\");\n\t\t\tmv.visitInsn(DUP);\n\t\t\tmv.visitVarInsn(ALOAD, index);\n\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/NoSuchMethodError\", \"<init>\", \"(Ljava/lang/String;)V\");\n\t\t\tmv.visitInsn(ATHROW);\n\t\t}\n\n\t\t/**\n\t\t * Catcher methods are 'empty' methods added to subtypes to 'catch' any virtual dispatch calls that would\n\t\t * otherwise be missed. Catchers then check to see if the type on which they are defined now provides an\n\t\t * implementation of the method in question - if it does then it is called, otherwise the catcher simply calls\n\t\t * the supertype.\n\t\t * <p>\n\t\t * Catchers typically have the same visibility as the methods for which they exist, unless those methods are\n\t\t * protected/default, in which case the catcher is made public. This enables them to be seen from the executor.\n\t\t */\n\t\tprivate void generateCatchers() {\n\t\t\tif (!GlobalConfiguration.catchersOn || isInterface) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tFieldMember[] fms = typeDescriptor.getFieldsRequiringAccessors();\n\n\t\t\tfor (FieldMember field : fms) {\n\t\t\t\tcreateProtectedFieldGetterSetter(field);\n\t\t\t}\n\n\t\t\tMethodMember[] methods = typeDescriptor.getMethods();\n\n\t\t\tfor (MethodMember method : methods) {\n\t\t\t\tif (!MethodMember.isSuperDispatcher(method)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\t// TODO topmost test?\n\t\t\t\tString name = method.getName();\n\t\t\t\tString descriptor = method.getDescriptor();\n\t\t\t\tif (GlobalConfiguration.verboseMode && log.isLoggable(Level.FINEST)) {\n\t\t\t\t\tlog.finest(\"Creating super dispatcher for method \" + name + descriptor + \" in type \" + slashedname);\n\t\t\t\t}\n\t\t\t\t// Create a superdispatcher for this method\n\t\t\t\tMethodVisitor mv = cw.visitMethod(Modifier.PUBLIC, method.getName(), method.getDescriptor(), null,\n\t\t\t\t\t\tmethod.getExceptions());\n\t\t\t\tint ps = Utils.getParameterCount(method.getDescriptor());\n\t\t\t\tReturnType methodReturnType = Utils.getReturnTypeDescriptor(method.getDescriptor());\n\t\t\t\tint lvarIndex = 0;\n\t\t\t\tmv.visitVarInsn(ALOAD, lvarIndex++); // load this\n\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, descriptor, lvarIndex);\n\t\t\t\tString targetMethod = method.getName().substring(0, method.getName().lastIndexOf(\"_$\"));\n\t\t\t\tmv.visitMethodInsn(Opcodes.INVOKESPECIAL, typeDescriptor.getSupertypeName(), targetMethod,\n\t\t\t\t\t\tmethod.getDescriptor());\n\t\t\t\tUtils.addCorrectReturnInstruction(mv, methodReturnType, false);\n\t\t\t\tint maxs = ps + 1;\n\t\t\t\tif (methodReturnType.isDoubleSlot()) {\n\t\t\t\t\tmaxs++;\n\t\t\t\t}\n\t\t\t\tmv.visitMaxs(maxs, maxs);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\n\t\t\tfor (MethodMember method : methods) {\n\t\t\t\tif (!MethodMember.isCatcher(method)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tString name = method.getName();\n\t\t\t\tString descriptor = method.getDescriptor();\n\t\t\t\tReturnType returnType = Utils.getReturnTypeDescriptor(descriptor);\n\n\t\t\t\t// 1. Create the method signature\n\t\t\t\tint flags = method.getModifiers();\n\t\t\t\tif (Modifier.isProtected(flags)) {\n\t\t\t\t\tflags = flags - Modifier.PROTECTED + Modifier.PUBLIC;\n\t\t\t\t}\n\t\t\t\tMethodVisitor mv = cw.visitMethod(flags, method.getName(), method.getDescriptor(), null,\n\t\t\t\t\t\tmethod.getExceptions());\n\n\t\t\t\t// 2. Ask the type if anything has changed from first load\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitLdcInsn(method.getId());\n\t\t\t\tmv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, tReloadableType, \"fetchLatestIfExists\",\n\t\t\t\t\t\t\"(I)Ljava/lang/Object;\");\n\n\t\t\t\t// If the return value is null, there is no implementation\n\t\t\t\tmv.visitInsn(DUP);\n\n\t\t\t\t// 3. create the if statement\n\t\t\t\tLabel l1 = new Label();\n\t\t\t\tmv.visitJumpInsn(Opcodes.IFNULL, l1);\n\n\t\t\t\t// 4. if changed then call the interface to run whatever version has been added\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, Utils.getInterfaceName(slashedname));\n\n\t\t\t\tint lvarIndex = 0;\n\t\t\t\tmv.visitVarInsn(ALOAD, lvarIndex++); // load this\n\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, descriptor, lvarIndex);\n\t\t\t\tString desc = new StringBuffer(\"(L\").append(slashedname).append(\";\").append(\n\t\t\t\t\t\tdescriptor.substring(1)).toString();\n\t\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, Utils.getInterfaceName(slashedname), name, desc);\n\t\t\t\tUtils.addCorrectReturnInstruction(mv, returnType, true);\n\n\t\t\t\t// 5. if unchanged just run the supertype version (could be another catcher...)\n\t\t\t\tmv.visitLabel(l1);\n\t\t\t\tmv.visitInsn(POP);\n\t\t\t\tint ps = Utils.getParameterCount(method.getDescriptor());\n\t\t\t\tReturnType methodReturnType = Utils.getReturnTypeDescriptor(method.getDescriptor());\n\n\t\t\t\t// A catcher for an interface method is inserted into abstract classes.  These should never be reached unless\n\t\t\t\t// they now provide an implementation (on a reload) and the subtype has deleted the implementation it had.\n\t\t\t\t// This means there is never a need to call 'super' in the logic below and getting here when there isn't\n\t\t\t\t// something to run in the executor is a bug (so we throw AbstractMethodError)\n\t\t\t\tif (MethodMember.isCatcherForInterfaceMethod(method)) {\n\t\t\t\t\tmv.visitTypeInsn(NEW, \"java/lang/IllegalStateException\");\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/AbstractMethodError\", \"<init>\", \"()V\", false);\n\t\t\t\t\tmv.visitInsn(ATHROW);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitVarInsn(ALOAD, 0); // load this\n\t\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, method.getDescriptor(), 1);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, supertypeName, method.getName(), method.getDescriptor(), false);\n\t\t\t\t\tUtils.addCorrectReturnInstruction(mv, methodReturnType, false);\n\t\t\t\t}\n\n\t\t\t\tint maxs = ps + 1;\n\t\t\t\tif (methodReturnType.isDoubleSlot()) {\n\t\t\t\t\tmaxs++;\n\t\t\t\t}\n\t\t\t\tmv.visitMaxs(maxs, maxs);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\n\t\t}\n\n\t\tprivate void insertCorrectLoad(MethodVisitor mv, ReturnType rt, int slot) {\n\t\t\tif (rt.isPrimitive()) {\n\t\t\t\tswitch (rt.descriptor.charAt(0)) {\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'S':\n\t\t\t\t\tcase 'I':\n\t\t\t\t\tcase 'B':\n\t\t\t\t\tcase 'C':\n\t\t\t\t\t\tmv.visitVarInsn(ILOAD, slot);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'F':\n\t\t\t\t\t\tmv.visitVarInsn(FLOAD, slot);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'J':\n\t\t\t\t\t\tmv.visitVarInsn(LLOAD, slot);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'D':\n\t\t\t\t\t\tmv.visitVarInsn(DLOAD, slot);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tdefault:\n\t\t\t\t\t\tthrow new IllegalStateException(rt.descriptor);\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmv.visitVarInsn(ALOAD, slot);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * For the fields that need it (protected fields from a non-reloadable supertype), create the getters and\n\t\t * setters so that the executor can read/write them.\n\t\t *\n\t\t */\n\t\tprivate void createProtectedFieldGetterSetter(FieldMember field) {\n\t\t\tString descriptor = field.descriptor;\n\t\t\tString name = field.name;\n\t\t\tReturnType rt = ReturnType.getReturnType(descriptor);\n\t\t\tif (field.isStatic()) {\n\t\t\t\tMethodVisitor mv = cw.visitMethod(Modifier.PUBLIC | Modifier.STATIC,\n\t\t\t\t\t\tUtils.getProtectedFieldGetterName(name), \"()\"\n\t\t\t\t\t\t\t\t+ descriptor,\n\t\t\t\t\t\tnull, null);\n\t\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, name, descriptor);\n\t\t\t\tUtils.addCorrectReturnInstruction(mv, rt, false);\n\t\t\t\tmv.visitMaxs(rt.isDoubleSlot() ? 2 : 1, 0);\n\t\t\t\tmv.visitEnd();\n\n\t\t\t\tmv = cw.visitMethod(Modifier.PUBLIC | Modifier.STATIC, Utils.getProtectedFieldSetterName(name), \"(\"\n\t\t\t\t\t\t+ descriptor\n\t\t\t\t\t\t+ \")V\", null, null);\n\t\t\t\tinsertCorrectLoad(mv, rt, 0);\n\t\t\t\tmv.visitFieldInsn(PUTSTATIC, slashedname, name, descriptor);\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\tmv.visitMaxs(rt.isDoubleSlot() ? 2 : 1, 1);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\t\t\telse {\n\t\t\t\tMethodVisitor mv = cw.visitMethod(Modifier.PUBLIC, Utils.getProtectedFieldGetterName(name), \"()\"\n\t\t\t\t\t\t+ descriptor,\n\t\t\t\t\t\tnull, null);\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, name, descriptor);\n\t\t\t\tUtils.addCorrectReturnInstruction(mv, rt, false);\n\t\t\t\tmv.visitMaxs(rt.isDoubleSlot() ? 2 : 1, 1);\n\t\t\t\tmv.visitEnd();\n\n\t\t\t\tmv = cw.visitMethod(Modifier.PUBLIC, Utils.getProtectedFieldSetterName(name), \"(\" + descriptor + \")V\",\n\t\t\t\t\t\tnull, null);\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\tinsertCorrectLoad(mv, rt, 1);\n\t\t\t\tmv.visitFieldInsn(PUTFIELD, slashedname, name, descriptor);\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\tmv.visitMaxs(rt.isDoubleSlot() ? 3 : 2, 2);\n\t\t\t\tmv.visitEnd();\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * The ClinitPrepender adds the code to initialize the reloadable type field at class load\n\t\t */\n\t\tclass ClinitPrepender implements Prepender, Constants {\n\n\t\t\tMethodVisitor mv;\n\n\t\t\tprivate final static String descriptorFor_getReloadableType = \"(II)\" + lReloadableType;\n\n\t\t\tprivate final static String descriptorFor_associateReloadableType = \"(\" + lReloadableType\n\t\t\t\t\t+ \"Ljava/lang/Class;)V\";\n\n\t\t\tClinitPrepender(MethodVisitor mv) {\n\t\t\t\tthis.mv = mv;\n\t\t\t}\n\n\t\t\tpublic void prepend() {\n\t\t\t\t// Discover the ReloadableType object and store it here\n\t\t\t\tmv.visitCode();\n\t\t\t\t// TODO optimization: could collapse ints into one but this snippet isn't put in many places\n\t\t\t\tmv.visitLdcInsn(rtype.getTypeRegistryId());\n\t\t\t\tmv.visitLdcInsn(rtype.getId());\n\t\t\t\tmv.visitMethodInsn(INVOKESTATIC, tRegistryType, \"getReloadableType\", descriptorFor_getReloadableType,\n\t\t\t\t\t\tfalse);\n\n\t\t\t\tmv.visitFieldInsn(PUTSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\t//\t\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\t//\t\t\t\tmv.visitLdcInsn(Type.getObjectType(rtype.getSlashedSupertypeName()));//Type(\"L\" + rtype.getSlashedSupertypeName() + \";\")); // faster way?\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tReloadableType, \"setSuperclass\", \"(Ljava/lang/Class;)V\");\n\n\t\t\t\t// only in the top most type - what about interfaces??\n\t\t\t\tif (GlobalConfiguration.fieldRewriting) {\n\t\t\t\t\tmv.visitFieldInsn(GETSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\t\t\tLabel l1 = new Label();\n\t\t\t\t\tmv.visitJumpInsn(IFNONNULL, l1);\n\t\t\t\t\tmv.visitTypeInsn(NEW, tStaticStateManager);\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tStaticStateManager, \"<init>\", \"()V\", false);\n\t\t\t\t\tmv.visitFieldInsn(PUTSTATIC, slashedname, fStaticFieldsName, lStaticStateManager);\n\t\t\t\t\tmv.visitLabel(l1);\n\t\t\t\t}\n\t\t\t\t// If the static initializer has changed, call the new version through the ___clinit___ method\n\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, tReloadableType, \"clinitchanged\", \"()I\", false);\n\t\t\t\t// 2. Create the if statement\n\t\t\t\tLabel wasZero = new Label();\n\t\t\t\tmv.visitJumpInsn(Opcodes.IFEQ, wasZero); // if == 0, jump to where we can do the original thing\n\n\t\t\t\t// 3. grab the latest dispatcher and call it through the interface\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tReloadableType, \"fetchLatest\", \"()Ljava/lang/Object;\", false);\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, Utils.getInterfaceName(slashedname));\n\t\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, Utils.getInterfaceName(slashedname), mStaticInitializerName, \"()V\");\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\t// 4. do what you were going to do anyway\n\t\t\t\tmv.visitLabel(wasZero);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Rewrites a method to include the extra checks to verify it is the most up to date version.\n\t\t */\n\t\tclass AugmentingMethodAdapter extends MethodVisitor implements Opcodes {\n\n\t\t\tint methodId;\n\n\t\t\tString name;\n\n\t\t\tString descriptor;\n\n\t\t\tMethodMember method;\n\n\t\t\tReturnType returnType;\n\n\t\t\tpublic AugmentingMethodAdapter(MethodVisitor mv, String name, String descriptor) {\n\t\t\t\tsuper(ASM5, mv);\n\t\t\t\tthis.name = name;\n\t\t\t\tthis.method = rtype.getMethod(name, descriptor);\n\t\t\t\tthis.methodId = method.getId();\n\t\t\t\tthis.descriptor = descriptor;\n\t\t\t\tthis.returnType = Utils.getReturnTypeDescriptor(descriptor);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCode() {\n\t\t\t\tsuper.visitCode();\n\t\t\t\tboolean isStaticMethod = method.isStatic();\n\t\t\t\t// 1. ask the reloadable type if anything has changed since initial load by\n\t\t\t\t//    calling 'int changed(int)' passing in the method ID\n\t\t\t\t//     0 if the method cannot have changed\n\t\t\t\t//     1 if the method has changed\n\t\t\t\t//     2 if the method has been deleted in a new version\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitLdcInsn(methodId);\n\t\t\t\tmv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, tReloadableType, \"changed\", \"(I)I\");\n\t\t\t\t// 2. Create the if statement\n\t\t\t\tLabel wasZero = new Label();\n\t\t\t\tif (!isStaticMethod) {\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t}\n\t\t\t\tmv.visitJumpInsn(Opcodes.IFEQ, wasZero); // if == 0, jump to where we can do the original thing\n\n\t\t\t\t// TODO if it isStatic then the invoke side should be pointing at the right version - do we need to cope with it not?\n\t\t\t\tif (!isStaticMethod) {\n\t\t\t\t\tLabel wasOne = new Label();\n\t\t\t\t\tmv.visitInsn(ICONST_1);\n\t\t\t\t\tmv.visitJumpInsn(IF_ICMPEQ, wasOne); // if == 1, method has changed\n\t\t\t\t\t// If here, == 2, so method has been deleted\n\t\t\t\t\t// either try an invokespecial on a super or throw a NoSuchmethodError\n\n\t\t\t\t\t// Only worth including super.xxx() call if the supertype does define it or the supertype is reloadable\n\t\t\t\t\t// Otherwise we will generate invokespecial 'Object.somethingThatCantBeThere' in some cases\n\t\t\t\t\tTypeDescriptor superDescriptor = rtype.getTypeRegistry().getDescriptorFor(supertypeName);\n\t\t\t\t\tif (!superDescriptor.definesNonPrivate(name + descriptor)) {\n\t\t\t\t\t\tinsertThrowNoSuchMethodError();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tinsertInvokeSpecialToCallSuperMethod();\n\t\t\t\t\t}\n\t\t\t\t\tmv.visitLabel(wasOne);\n\t\t\t\t}\n\t\t\t\t// 3. grab the latest dispatcher and call it through the interface\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, tReloadableType, \"fetchLatest\", \"()Ljava/lang/Object;\");\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, Utils.getInterfaceName(slashedname));\n\t\t\t\tint lvarIndex = 0;\n\t\t\t\tif (!isStaticMethod) {\n\t\t\t\t\tmv.visitVarInsn(ALOAD, lvarIndex++);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t\t\t}\n\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, descriptor, lvarIndex);\n\t\t\t\tString desc = new StringBuilder(\"(L\").append(slashedname).append(\";\").append(\n\t\t\t\t\t\tdescriptor.substring(1)).toString();\n\t\t\t\tif (method.isStatic() && MethodMember.isClash(method)) {\n\t\t\t\t\tname = \"__\" + name;\n\t\t\t\t}\n\t\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, Utils.getInterfaceName(slashedname), name, desc);\n\t\t\t\tUtils.addCorrectReturnInstruction(mv, returnType, true);\n\t\t\t\t// 4. do what you were going to do anyway\n\t\t\t\tmv.visitLabel(wasZero);\n\t\t\t\tif (!isStaticMethod) {\n\t\t\t\t\tmv.visitInsn(POP);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tprivate void insertInvokeSpecialToCallSuperMethod() {\n\t\t\t\tint lvarIndex = 0;\n\t\t\t\tif (!Modifier.isStatic(method.getModifiers())) {\n\t\t\t\t\tmv.visitVarInsn(ALOAD, lvarIndex++); // load this\n\t\t\t\t}\n\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, descriptor, lvarIndex);\n\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, supertypeName, name, descriptor);\n\t\t\t\tUtils.addCorrectReturnInstruction(mv, Utils.getReturnTypeDescriptor(descriptor), false);\n\t\t\t}\n\n\t\t\tprivate void insertThrowNoSuchMethodError() {\n\t\t\t\t// exception text should look like: a.b.c.B.foo()V\n\t\t\t\tString text = rtype.getName() + \".\" + name.replace('/', '.') + descriptor;\n\t\t\t\tmv.visitTypeInsn(NEW, \"java/lang/NoSuchMethodError\");\n\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\tmv.visitLdcInsn(text);\n\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/NoSuchMethodError\", \"<init>\", \"(Ljava/lang/String;)V\");\n\t\t\t\tmv.visitInsn(ATHROW);\n\t\t\t}\n\n\t\t}\n\n\t\tclass AugmentingConstructorAdapter extends MethodVisitor implements Opcodes {\n\n\t\t\tint ctorId;\n\n\t\t\tString name;\n\n\t\t\tString descriptor;\n\n\t\t\tMethodMember method;\n\n\t\t\tString type;\n\n\t\t\tboolean isTopMost;\n\n\t\t\tpublic AugmentingConstructorAdapter(MethodVisitor mv, String descriptor, String type, boolean isTopMost) {\n\t\t\t\tsuper(ASM5, mv);\n\t\t\t\tthis.descriptor = descriptor;\n\t\t\t\tthis.type = type;\n\t\t\t\tthis.isTopMost = isTopMost;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCode() {\n\t\t\t\tsuper.visitCode();\n\n\t\t\t\t// 1. Quick check if anything has changed\n\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\tmv.visitLdcInsn(ctorId);\n\t\t\t\tmv.visitMethodInsn(Opcodes.INVOKEVIRTUAL, tReloadableType, \"cchanged\", \"(I)Ljava/lang/Object;\");\n\t\t\t\t// return value of that call is the dispatcher to call, or null if we shouldn't do anything different\n\n\t\t\t\t// TODO throw exception if no longer defined? (Shouldn't really be called if not defined though...)\n\n\t\t\t\t// 2. if nothing has changed jump to the end and run the original code\n\t\t\t\tLabel wasNull = new Label();\n\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\tmv.visitJumpInsn(Opcodes.IFNULL, wasNull); // if == null\n\n\t\t\t\tmv.visitTypeInsn(CHECKCAST, Utils.getInterfaceName(slashedname));\n\t\t\t\t//\t\t\t\tmv.visitInsn(SWAP);\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t//\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t// Now we have the dispatcher on the stack for our type, we can't pass 'this' (aload_0) on a call yet because it is not initialized\n\t\t\t\t// have to initialize it now before we can pass it on\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, slashedname, \"<init>\", \"(Lorg/springsource/loaded/ReloadableType;)V\");\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\");\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, owner, name, desc)\n\t\t\t\tif (isEnum) {\n\t\t\t\t\tmv.visitVarInsn(ALOAD, 1);\n\t\t\t\t\tmv.visitVarInsn(ILOAD, 2);\n\t\t\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, slashedname, \"<init>\",\n\t\t\t\t\t\t\t\"(Ljava/lang/String;ILorg/springsource/loaded/C;)V\");\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmv.visitInsn(ACONST_NULL);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, slashedname, \"<init>\", \"(Lorg/springsource/loaded/C;)V\");\n\t\t\t\t}\n\n\t\t\t\t// initialize the field instance manager\n\t\t\t\t// not conditional on isTopMost because entering object construction through this route won't ever call the initialization logic in\n\t\t\t\t// the super ctor, because all that is bypassed.  We could put this initialization logic into the topmost 'special' constructor\n\t\t\t\t// that we create, that is an alternative\n\t\t\t\tif (GlobalConfiguration.fieldRewriting) {// && isTopMost) {\n\t\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\t\t\tLabel l1 = new Label();\n\t\t\t\t\tmv.visitJumpInsn(IFNONNULL, l1);\n\t\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t\tmv.visitTypeInsn(NEW, tInstanceStateManager);\n\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tInstanceStateManager, \"<init>\",\n\t\t\t\t\t\t\t\"(Ljava/lang/Object;Lorg/springsource/loaded/ReloadableType;)V\");\n\t\t\t\t\tmv.visitFieldInsn(PUTFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\t\t\tmv.visitLabel(l1);\n\t\t\t\t}\n\n\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\tUtils.createLoadsBasedOnDescriptor(mv, descriptor, 1);\n\t\t\t\t// from \"(Ljava/lang/String;J)V\" to \"(Ljava/lang/String;J)Lcom/foo/A;\"\n\t\t\t\t//\t\t\t\tString desc = new StringBuilder().append(descriptor, 0, descriptor.length() - 1).append(\"L\").append(slashedname)\n\t\t\t\t//\t\t\t\t\t\t.append(\";\").toString();\n\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL,\"\")\n\n\t\t\t\tString desc = new StringBuilder(\"(L\").append(slashedname).append(\";\").append(\n\t\t\t\t\t\tdescriptor.substring(1)).toString();\n\n\t\t\t\t//\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t//\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, \"java/lang/Object\", \"<init>\", \"()V\");\n\n\t\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, Utils.getInterfaceName(slashedname), \"___init___\", desc);\n\t\t\t\tmv.visitInsn(RETURN);\n\t\t\t\t//\t\t\t\tmv.visitTypeInsn(CHECKCAST, type);\n\n\t\t\t\t// 4. do what you were going to do anyway\n\t\t\t\tmv.visitLabel(wasNull);\n\t\t\t\tmv.visitInsn(POP);\n\t\t\t}\n\n\t\t\tint unitializedObjectsCount = 0;\n\n\t\t\t@Override\n\t\t\tpublic void visitTypeInsn(final int opcode, final String type) {\n\t\t\t\tif (opcode == NEW) {\n\t\t\t\t\tunitializedObjectsCount++;\n\t\t\t\t}\n\t\t\t\tsuper.visitTypeInsn(opcode, type);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitMethodInsn(final int opcode, final String owner, final String name, final String desc,\n\t\t\t\t\tfinal boolean itf) {\n\t\t\t\tsuper.visitMethodInsn(opcode, owner, name, desc, itf);\n\t\t\t\tif (opcode == INVOKESPECIAL) {\n\t\t\t\t\tunitializedObjectsCount--;\n\t\t\t\t}\n\t\t\t\tif (unitializedObjectsCount == -1 && isTopMost) {\n\t\t\t\t\t// Need to insert this after the relevant invokespecial\n\t\t\t\t\tif (GlobalConfiguration.fieldRewriting) {\n\t\t\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t\t\tmv.visitFieldInsn(GETFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\t\t\t\tLabel l1 = new Label();\n\t\t\t\t\t\tmv.visitJumpInsn(IFNONNULL, l1);\n\t\t\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t\t\tmv.visitTypeInsn(NEW, tInstanceStateManager);\n\t\t\t\t\t\tmv.visitInsn(DUP);\n\t\t\t\t\t\tmv.visitVarInsn(ALOAD, 0);\n\t\t\t\t\t\tmv.visitFieldInsn(Opcodes.GETSTATIC, slashedname, fReloadableTypeFieldName, lReloadableType);\n\t\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tInstanceStateManager, \"<init>\",\n\t\t\t\t\t\t\t\t\"(Ljava/lang/Object;Lorg/springsource/loaded/ReloadableType;)V\", false);\n\t\t\t\t\t\t//\t\t\t\t\t\tmv.visitMethodInsn(INVOKESPECIAL, tInstanceStateManager, \"<init>\", \"(Ljava/lang/Object;)V\");\n\t\t\t\t\t\tmv.visitFieldInsn(PUTFIELD, slashedname, fInstanceFieldsName, lInstanceStateManager);\n\t\t\t\t\t\tmv.visitLabel(l1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\t\tinterface Prepender {\n\n\t\t\tvoid prepend();\n\t\t}\n\n\t\tclass MethodPrepender extends MethodVisitor implements Opcodes {\n\n\t\t\tPrepender appender;\n\n\t\t\tpublic MethodPrepender(MethodVisitor mv, Prepender appender) {\n\t\t\t\tsuper(ASM5, mv);\n\t\t\t\tthis.appender = appender;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void visitCode() {\n\t\t\t\tsuper.visitCode();\n\t\t\t\tappender.prepend();\n\t\t\t}\n\n\t\t}\n\n\t}\n\n}\n", "mport android.os.IBinder;\nimport android.os.Parcel;\nimport android.util.Log;\n\nimport java.lang.reflect.Field;\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\n/**\n * Description:\n *\n * @author Shawn_Dut\n * @since 2017-02-21\n */\npublic class ClipboardHook {\n\n    private static final String TAG = ClipboardHook.class.getSimpleName();\n\n    public static void hookService(Context context) {\n        IBinder clipboardService = ServiceManager.getService(Context.CLIPBOARD_SERVICE);\n        String IClipboard = \"android.content.IClipboard\";\n\n        if (clipboardService != null) {\n            IBinder hookClipboardService =\n                    (IBinder) Proxy.newProxyInstance(clipboardService.getClass().getClassLoader(),\n                            clipboardService.getClass().getInterfaces(),\n                            new ServiceHook(clipboardService, IClipboard, true, new ClipboardHookHandler()));\n            ServiceManager.setService(Context.CLIPBOARD_SERVICE, hookClipboardService);\n        } else {\n            Log.e(TAG, \"ClipboardService hook failed!\");\n        }\n    }\n\n    public static class ClipboardHookHandler implements InvocationHandler {\n\n        @Override\n        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n            Log.e(TAG, \"clipboardhookhandler invoke\");\n            String methodName = method.getName();\n            int argsLength = args.length;\n            //\u6bcf\u6b21\u4ece\u672c\u5e94\u7528\u590d\u5236\u7684\u6587\u672c\uff0c\u540e\u9762\u90fd\u52a0\u4e0a\u5206\u4eab\u7684\u51fa\u5904\n            if (\"setPrimaryClip\".equals(methodName)) {\n                if (argsLength >= 2 && args[0] instanceof ClipData) {\n                    ClipData data = (ClipData) args[0];\n                    String text = data.getItemAt(0).getText().toString();\n                    text += \"this is shared from ServiceHook-----by Shawn_Dut\";\n                    args[0] = ClipData.newPlainText(data.getDescription().getLabel(), text);\n                }\n            }\n            return method.invoke(proxy, args);\n        }\n    }\n}\n", "rt.fail;\n\nimport java.io.IOException;\nimport java.util.Comparator;\nimport java.util.Iterator;\nimport java.util.Random;\n\nimport org.geirove.exmeso.ExternalMergeSort.Serializer;\n\npublic abstract class AbstractExternalMergeSortTest {\n\n    private static class RandomIntIterator implements Iterator<Integer> {\n\n        private Random rand = new Random();\n        private int size;\n        private int c;\n\n        private RandomIntIterator(int size) {\n            this.size = size;\n        }\n\n        @Override\n        public boolean hasNext() {\n            return c < size;\n        }\n\n        @Override\n        public Integer next() {\n            c++;\n            return rand.nextInt();\n        }\n\n        @Override\n        public void remove() {\n            throw new UnsupportedOperationException();\n        }\n    }\n\n    public abstract void testLargeIntegerSort() throws IOException;\n\n    protected void performLargeIntegerSort(Serializer<Integer> serializer, Comparator<Integer> comparator, boolean distinct) throws IOException {\n        // ten million elements, 500k chunks, max 19 files\n        ExternalMergeSort<Integer> sort = ExternalMergeSort.newSorter(serializer, comparator)\n                .withChunkSize(500000)\n                .withMaxOpenFiles(19)\n                .withDistinct(distinct)\n                .withCleanup(!ExternalMergeSort.debug)\n                .build();\n        int size = 10000000;\n        assertSorted(serializer, comparator, sort, new RandomIntIterator(size), size, distinct);\n    }\n\n    protected void performPrimeIntegerSort(Serializer<Integer> serializer, Comparator<Integer> comparator, boolean distinct) throws IOException {\n        ExternalMergeSort<Integer> sort = ExternalMergeSort.newSorter(serializer, comparator)\n                .withChunkSize(21)\n                .withMaxOpenFiles(7)\n                .withDistinct(distinct)\n                .withCleanup(!ExternalMergeSort.debug)\n                .build();\n        int size = 9123;\n        assertSorted(serializer, comparator, sort, new RandomIntIterator(size), size, distinct);\n    }\n\n    protected void performMultiMergeIntegerSort(Serializer<Integer> serializer, Comparator<Integer> comparator, boolean distinct) throws IOException {\n        ExternalMergeSort<Integer> sort = ExternalMergeSort.newSorter(serializer, comparator)\n                .withChunkSize(3)\n                .withMaxOpenFiles(5)\n                .withDistinct(distinct)\n                .withCleanup(!ExternalMergeSort.debug)\n                .build();\n        int size = 37;\n        assertSorted(serializer, comparator, sort, new RandomIntIterator(size), size, distinct);\n    }\n\n    private void assertSorted(Serializer<Integer> serializer, Comparator<Integer> comparator, ExternalMergeSort<Integer> sort, Iterator<Integer> input, int size, boolean distinct) throws IOException {\n        long st = System.currentTimeMillis();\n        int last = Integer.MIN_VALUE;\n        CloseableIterator<Integer> iter = sort.mergeSort(input);\n        if (ExternalMergeSort.debug) {\n            System.out.println(\"A: \" + (System.currentTimeMillis() - st) + \"ms\");\n        }\n        try {\n            int count = 0;\n            while (iter.hasNext()) {\n                count ++;\n                int i = iter.next();\n                assertTrue(i + \" not sorted after \" + last, comparator.compare(i, last) >= 0);\n                last = i;\n            }\n            if (!distinct && count != size) {\n                fail(\"Incorrect size: \" + count + \" vs \" + size);\n            }\n        } finally {\n            iter.close();\n        }\n        if (ExternalMergeSort.debug) {\n            System.out.println(\"B: \" + (System.currentTimeMillis() - st) + \"ms\");\n        }\n    }\n\n}\n", "cense\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.netflix.conductor.client.config;\n\npublic interface ConductorClientConfiguration {\n\n    /**\n     * @return the workflow input payload size threshold in KB,\n     * beyond which the payload will be processed based on {@link ConductorClientConfiguration#isExternalPayloadStorageEnabled()}.\n     */\n    int getWorkflowInputPayloadThresholdKB();\n\n    /**\n     * @return the max value of workflow input payload size threshold in KB,\n     * beyond which the payload will be rejected regardless external payload storage is enabled.\n     */\n    int getWorkflowInputMaxPayloadThresholdKB();\n\n    /**\n     * @return the task output payload size threshold in KB,\n     * beyond which the payload will be processed based on {@link ConductorClientConfiguration#isExternalPayloadStorageEnabled()}.\n     */\n    int getTaskOutputPayloadThresholdKB();\n\n    /**\n     * @return the max value of task output payload size threshold in KB,\n     * beyond which the payload will be rejected regardless external payload storage is enabled.\n     */\n    int getTaskOutputMaxPayloadThresholdKB();\n\n    /**\n     * @return the flag which controls the use of external storage for storing workflow/task\n     * input and output JSON payloads with size greater than threshold.\n     * If it is set to true, the payload is stored in external location.\n     * If it is set to false, the payload is rejected and the task/workflow execution fails.\n     */\n    boolean isExternalPayloadStorageEnabled();\n}\n", "SONObject;\n\n\npublic class ActionArgument {\n\n    private final String name;\n    private final ArgumentType type;\n    private Object value;\n\n    public ActionArgument(String name, ArgumentType type) {\n        this.name = name;\n        this.type = type;\n    }\n\n    public void setValue(Object value) {\n        this.value = value;\n    }\n\n    public Object getValue() {\n        return value;\n    }\n\n    public JSONObject toJson() {\n        JSONObject jsonObject = new JSONObject();\n        try {\n            jsonObject.put(\"name\", name);\n            jsonObject.put(\"type\", type.toString());\n            if (value != null) {\n                jsonObject.put(\"value\", value);\n            }\n        } catch (JSONException e) {\n            e.printStackTrace();\n        }\n        return jsonObject;\n    }\n\n    public String getStringValue() {\n        if (value == null) {\n            return null;\n        }\n        return type.getString(value);\n    }\n\n    public void parseValue(String value) {\n        this.value = type.parseValue(value);\n    }\n}\n", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.cloudfoundry.client.v2.securitygroups;\n\nimport org.junit.Test;\n\npublic final class ListSecurityGroupSpacesRequestTest {\n\n    @Test(expected = IllegalStateException.class)\n    public void noSecurityGroupId() {\n        ListSecurityGroupSpacesRequest.builder()\n            .build();\n    }\n\n    @Test\n    public void valid() {\n        ListSecurityGroupSpacesRequest.builder()\n            .securityGroupId(\"test-security-group-id\")\n            .build();\n    }\n\n}\n", " \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.ibm.wasdev.arduino.impl;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.StringWriter;\nimport java.net.Socket;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Enumeration;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ExecutorService;\nimport java.util.concurrent.Executors;\nimport java.util.concurrent.TimeoutException;\nimport java.util.logging.Logger;\n\nimport purejavacomm.CommPortIdentifier;\nimport purejavacomm.CommPortOwnershipListener;\nimport purejavacomm.PortInUseException;\nimport purejavacomm.SerialPort;\nimport purejavacomm.UnsupportedCommOperationException;\n\nimport com.ibm.wasdev.arduino.Arduino;\nimport com.ibm.wasdev.arduino.Callback;\nimport com.ibm.wasdev.arduino.NotificationListener;\n\npublic class ArduinoAsyncImpl implements Arduino, CommPortOwnershipListener, Runnable {\n    private final static Logger LOGGER = Logger.getLogger(ArduinoAsyncImpl.class.getName());\n\n    private static final int CMD_PIN_MODE = 1;\n    private static final int CMD_DIGITAL_READ = 2;\n    private static final int CMD_DIGITAL_WRITE = 3;\n    private static final int CMD_ANALOG_READ = 4;\n    private static final int CMD_ANALOG_WRITE = 5;\n    private static final int CMD_EEPROM_READ = 6;\n    private static final int CMD_EEPROM_WRITE = 7;\n    private static final int CMD_SRAM_READ_BYTES = 8;\n    private static final int CMD_SRAM_WRITE_BYTES = 9;\n    private static final int CMD_INVOKE = 10;\n    private static final int CMD_EEPROM_READ_STRING = 11;\n    private static final int CMD_SRAM_READ_STRING = 12;\n    private static final int CMD_CALLBACK = 13;\n    private static final int CMD_CLEAR_CALLBACKS = 15;\n    private static final int CMD_VERSION = 16;\n    private static final int CMD_REMOTE = 17;\n    private static final int CMD_CALLBACK_TRIGGERED = 31;\n    private static final int CMD_CALLBACK_RESET = 32;\n    private static final int CMD_NAMED_CALLBACK_FIRED = 33;\n    private static final int CMD_LOG = 34;\n\n    private static final int RESPONSE_OK = 0;\n\n    private static Map<Integer, String> ERROR_MSGS;\n    static {\n        ERROR_MSGS = new HashMap<Integer, String>();\n        ERROR_MSGS.put(99, \"Uknown command\");\n        ERROR_MSGS.put(98, \"Argument error\");\n        ERROR_MSGS.put(97, \"Function not found\");\n        ERROR_MSGS.put(96, \"Too many callbacks\");\n        ERROR_MSGS.put(95, \"Wrong number of function arguments\");\n        ERROR_MSGS.put(94, \"Callback function cannot have arguments\");\n        ERROR_MSGS = Collections.unmodifiableMap(ERROR_MSGS);\n    }\n\n    private List<String> possibleCommPorts;\n    \n    private CommPortIdentifier commPort;\n    private SerialPort serialPort;\n    private String commPortName;\n\n    private OutputStreamWriter portWriter;\n    private BufferedReader portReader;\n\n    private Socket socket;\n    private String ip = \"192.168.1.94\";\n    private int port = 2000;\n\n    private int speed = 115200;\n\n    private boolean asyncMode = false;\n\n    private int pendingResponseId;\n    private Thread responseReaderThread;\n    private volatile String asyncResponse;\n    private final Object responseMutex = new Object();\n\n    private Map<Integer, Callback> callbacks = new ConcurrentHashMap<Integer, Callback>();\n    private Map<String, List<NotificationListener>> notifications = new ConcurrentHashMap<String, List<NotificationListener>>();\n\n    ExecutorService executor = Executors.newFixedThreadPool(5);\n\n    private long timeout = 1000; // 1 seconds\n    private int retries = 5;\n    \n    private int debug = 0;\n\n    private String arduinoLibVersion;\n    private String arduinoName;\n    private String targetArduinoName;\n\n    public ArduinoAsyncImpl(String ip, String commPorts, int speed, int debug, String arduinoName) {\n        this.ip = ip;\n        this.possibleCommPorts = Arrays.asList(commPorts.split(\",\"));\n        this.speed = speed;\n        asyncMode = true;\n        this.debug = debug;\n        this.targetArduinoName = arduinoName;\n    }\n\n    public synchronized void open() throws IOException {\n        try {\n\n            if (ip != null) {\n                socket = new Socket(ip, port);\n                socket.setSoTimeout(10000);\n                InputStream is = socket.getInputStream();\n\n                // initial response from RN-XV wifly module is *HELLO* so read and discard\n                is.read(); is.read(); is.read(); is.read(); is.read(); is.read(); is.read();\n\n                portReader = new BufferedReader(new InputStreamReader(is));\n                portWriter = new OutputStreamWriter(socket.getOutputStream());\n\n            } else {\n                \n                if (debug > 1) \n                   jtermios.JTermios.JTermiosLogging.setLogMask(0xFF);\n                \n                this.commPort = findCommPort();\n                this.commPortName = commPort.getName();\n\n                serialPort = (SerialPort) commPort.open(this.getClass().getName(), 2000);\n                serialPort.setSerialPortParams(speed, SerialPort.DATABITS_8, SerialPort.STOPBITS_1, SerialPort.PARITY_NONE);\n\n                serialPort.setDTR(true); // needed for Arduino Leonardo and Micro\n\n                portWriter = new OutputStreamWriter(serialPort.getOutputStream());\n                portReader = new BufferedReader(new InputStreamReader(serialPort.getInputStream()));\n\n                // don't timeout the async receive thread but for sync no timeout hangs close\n                if (!!!asyncMode) serialPort.enableReceiveTimeout(3000);\n                commPort.addPortOwnershipListener(this);\n\n            }\n\n            if (asyncMode) {\n                responseReaderThread = new Thread(this);\n                responseReaderThread.start();\n            }\n            \n            updateArduinoVersion();\n            \n            if (targetArduinoName != null && !!!targetArduinoName.equals(arduinoName)) {\n                throw new IllegalStateException(\"Requested Arduino named \" + targetArduinoName + \" but found \" + arduinoName);\n            }\n            \n            LOGGER.log(java.util.logging.Level.INFO, \"Arduino\" + (arduinoName != null ? (\" \\\"\"+arduinoName+\"\\\"\") : \"\") + \" opened on \" + (ip != null ? ip : commPortName) + \" running library version: \" + arduinoLibVersion);\n\n        } catch (UnsupportedCommOperationException e) {\n            throw new IOException(e);\n        } catch (PortInUseException e) {\n            throw new IOException(e);\n        }\n    }\n\n    public boolean isOpen() {\n        return serialPort != null || socket != null;\n    }\n\n    public synchronized void close() {\n        if (commPort != null) {\n            if (commPort != null)\n                commPort.removePortOwnershipListener(this);\n            if (serialPort != null)\n                serialPort.close();\n            serialPort = null;\n            portReader = null;\n            portWriter = null;\n            responseReaderThread = null;\n            commPort = null;\n            if (socket != null) {\n                try {\n                    socket.close();\n                } catch (IOException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n            jtermios.JTermios.JTermiosLogging.setLogMask(0x00);\n            LOGGER.log(java.util.logging.Level.INFO, \"Arduino closed on \"  + (ip != null ? ip : commPortName));\n        }\n    }\n\n    private CommPortIdentifier findCommPort() {\n        CommPortIdentifier commPort = null;\n        Enumeration<?> portEnum = CommPortIdentifier.getPortIdentifiers();\n        List<String> availablePorts = new ArrayList<String>();\n        while (portEnum.hasMoreElements()) {\n            CommPortIdentifier currPortId = (CommPortIdentifier) portEnum.nextElement();\n            if (possibleCommPorts.contains(currPortId.getName())) {\n                commPort = currPortId;\n                break;\n            }\n            availablePorts.add(currPortId.getName());\n        }\n        if (commPort == null) {\n            throw new IllegalArgumentException(\"Could not find COM port from : \" + possibleCommPorts + \", in available ports: \" + availablePorts);\n        }\n        return commPort;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#pinMode(int, com.ibm.wasdev.arduino.impl.ArduinoImpl.Mode)\n     */\n    @Override\n    public void pinMode(int pin, Mode mode) throws IOException {\n        parseOkResponse(doCommand(formatCommand(CMD_PIN_MODE, pin, mode.getValue())));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#digitalRead(int)\n     */\n    @Override\n    public Level digitalRead(int pin) throws IOException {\n        return parseValueResponse(doCommand(formatCommand(CMD_DIGITAL_READ, pin))) == 0 ? Level.LOW : Level.HIGH;\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#digitalWrite(int, int)\n     */\n    @Override\n    public void digitalWrite(int pin, Level value) throws IOException {\n        parseOkResponse(doCommand(formatCommand(CMD_DIGITAL_WRITE, pin, value.getValue())));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#analogRead(int)\n     */\n    @Override\n    public int analogRead(int pin) throws IOException {\n        return parseValueResponse(doCommand(formatCommand(CMD_ANALOG_READ, pin)));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#analogWrite(int, int)\n     */\n    @Override\n    public void analogWrite(int pin, int value) throws IOException {\n        parseOkResponse(doCommand(formatCommand(CMD_ANALOG_WRITE, pin, value)));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#eepromRead(int, int)\n     */\n    @Override\n    public byte[] eepromRead(int address, int length) throws IOException {\n        if (length == 0) return new byte[0];        \n        return parseBytesResponse(doCommand(formatCommand(CMD_EEPROM_READ, address, length)));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#eepromReadString(int)\n     */\n    @Override\n    public String eepromReadString(int address) throws IOException {\n        return new String(parseBytesResponse(doCommand(formatCommand(CMD_EEPROM_READ_STRING, address))));\n    }\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#eepromWrite(int, byte[])\n     */\n    @Override\n    public void eepromWrite(int address, byte[] bytes) throws IOException {\n        if (bytes.length == 0) return; \n        StringWriter sw = new StringWriter();\n        for (int i=0; i<bytes.length; i++) {\n            sw.append(String.valueOf(bytes[i]));\n            if (i < bytes.length-1) {\n                sw.append(',');\n            }\n        }\n        parseOkResponse(doCommand(CMD_EEPROM_WRITE + \",\" + address + \",\" + bytes.length + \",\" + sw.toString() + \"\\n\"));\n    }\n    \n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#eepromWrite(int, String)\n     */\n    @Override\n    public void eepromWrite(int address, String s) throws IOException {\n        byte[] bytes = new byte[s.length()+1];\n        System.arraycopy(s.getBytes(), 0, bytes, 0, s.length());\n        bytes[s.length()] = 0; // Arduino strings are null terminated\n        eepromWrite(address, bytes);\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#sramRead(int, int)\n     */\n    @Override\n    public byte[] sramRead(int address, int length) throws IOException {\n        if (length == 0) return new byte[0];        \n        return parseBytesResponse(doCommand(formatCommand(CMD_SRAM_READ_BYTES, address, length)));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#sramReadString(int)\n     */\n    @Override\n    public String sramReadString(int address) throws IOException {\n        return new String(parseBytesResponse(doCommand(formatCommand(CMD_SRAM_READ_STRING, address))));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#sramWrite(int, byte[])\n     */\n    @Override\n    public void sramWrite(int address, byte[] bytes) throws IOException {\n        if (bytes.length == 0) return; \n        StringWriter sw = new StringWriter();\n        for (int i=0; i<bytes.length; i++) {\n            sw.append(String.valueOf(bytes[i]));\n            if (i < bytes.length-1) {\n                sw.append(',');\n            }\n        }\n        parseOkResponse(doCommand(CMD_SRAM_WRITE_BYTES + \",\" + address + \",\" + bytes.length + \",\" + sw.toString() + \"\\n\"));\n    }\n    \n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#sramWrite(int, String)\n     */\n    @Override\n    public void sramWrite(int address, String s) throws IOException {\n        byte[] bytes = new byte[s.length()+1];\n        System.arraycopy(s.getBytes(), 0, bytes, 0, s.length());\n        bytes[s.length()] = 0; // Arduino strings are null terminated\n        sramWrite(address, bytes);\n    }\n\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#invoke(string)\n     */\n    @Override\n    public int invoke(String function) throws IOException {\n        return parseValueResponse(doCommand(CMD_INVOKE + \",0,\" + function.length() + function + \"\\n\"));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#invoke(string)\n     */\n    @Override\n    public int invoke(String function, int x) throws IOException {\n        return parseValueResponse(doCommand(CMD_INVOKE + \",1,\" + x + \",\" + function.length() + function + \"\\n\"));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#invoke(string)\n     */\n    @Override\n    public int invoke(String function, int x, int y) throws IOException {\n        return parseValueResponse(doCommand(CMD_INVOKE + \",2,\" + x + \",\" + y + \",\" + function.length() + function + \"\\n\"));\n    }\n\n    /*\n     * (non-Javadoc)\n     * \n     * @see com.ibm.wasdev.arduino.impl.Arduino#digitalCallback(int, int, Callback)\n     */\n    @Override\n    public int digitalCallback(int pin, Level state, Callback cb) throws IOException {\n        if (state != Level.HIGH && state != Level.LOW)\n            throw new IllegalArgumentException(\"State must be HI or LOW\");\n        int cbid = getNextCallbackID();\n        callbacks.put(cbid, cb);\n        parseOkResponse(doCommand(formatCommand(CMD_CALLBACK, cbid, 0, state.getValue(), 0, pin)));\n        return cbid;\n    }\n\n    @Override\n    public int analogCallback(int pin, Comparitor comparitor, int value, Callback cb) throws IOException {\n        int cbid = getNextCallbackID();\n        callbacks.put(cbid, cb);\n        parseOkResponse(doCommand(formatCommand(CMD_CALLBACK, cbid, 1, value, comparitor.getValue(), pin)));\n        return cbid;\n    }\n\n    @Override\n    public int functionCallback(String function, Comparitor comparitor, int value, Callback cb) throws IOException {\n        int cbid = getNextCallbackID();\n        callbacks.put(cbid, cb);\n        parseOkResponse(doCommand(CMD_CALLBACK + \",\" + cbid + \",\" + 2 + \",\" + value + \",\" + comparitor.getValue() + \",\" + function.length()\n                + function + \"\\n\"));\n        return cbid;\n    }\n\n    @Override\n    public void addNotificationListener(String name, NotificationListener n) {\n        List<NotificationListener> ns = notifications.get(name);\n        if (ns == null) {\n            ns = new ArrayList<NotificationListener>();\n            notifications.put(name, ns);\n        }\n        ns.add(n);\n    }\n\n    @Override\n    public void removeNotificationListener(NotificationListener n) {\n        for (List<NotificationListener> ns : notifications.values()) {\n            for (NotificationListener nx : ns) { \n                if (nx.equals(n)) {\n                    ns.remove(n);\n                    return;\n                }\n            }\n        }\n    }\n\n    private String formatCommand(int command, int... args) {\n        StringBuilder sb = new StringBuilder();\n        sb.append(command);\n        for (int arg : args) {\n            sb.append(\",\");\n            sb.append(arg);\n        }\n        sb.append(\"\\n\");\n        return sb.toString();\n    }\n\n    private int[] parseResponse(String response) {\n        String[] strArray = response.split(\",\");\n        int[] intArray = new int[strArray.length];\n        for (int i = 0; i < strArray.length; i++) {\n            intArray[i] = Integer.parseInt(strArray[i]);\n        }\n        return intArray;\n    }\n\n    private int parseValueResponse(String response) throws IOException {\n        int[] intArray = parseResponse(response);\n\n        checkResponse(intArray[0]);\n\n        if (intArray.length < 2) {\n            return -1; // TODO: shouldn't this throw an exception?\n        }\n        return intArray[1];\n    }\n\n    private byte[] parseBytesResponse(String response) throws IOException {\n        String[] strArray = response.split(\",\");\n        checkResponse(Integer.parseInt(strArray[0]));\n        \n        byte[] bytes = new byte[strArray.length-1];\n        for (int i=0; i<bytes.length; i++) {\n           bytes[i] = (byte)Integer.parseInt(strArray[i+1]);            \n        }\n        \n        return bytes;\n    }\n    \n    private void parseOkResponse(String response) throws IOException {\n        int[] intArray = parseResponse(response);\n        checkResponse(intArray[0]);\n    }\n\n    private void checkResponse(int response) throws IOException {\n        if (response != RESPONSE_OK) {\n            String error;\n            if (ERROR_MSGS.containsKey(response)) {\n                error = ERROR_MSGS.get(response);\n            } else {\n                error = String.valueOf(response);\n            }\n            throw new IOException(error);\n        }\n    }\n\n    private synchronized String doCommand(String command) throws IOException {\n        int retry = 0;\n        while (retry++ < retries) {\n            try {\n                return doCommand2(command);\n            } catch (TimeoutException e) {\n                LOGGER.log(java.util.logging.Level.FINE, (\"retry \" + retry + \" after response timeout\"));\n            }\n          }\n        throw new IOException(\"no response received after \" + retries + \" retries\");\n    }\n    \n    private synchronized String doCommand2(String command) throws IOException, TimeoutException {\n        if (LOGGER.isLoggable(java.util.logging.Level.FINE)) LOGGER.log(java.util.logging.Level.FINE, \"doCommand: \" + command);\n\n        if (!!!isOpen()) {\n            open();\n        }\n\n        String response = null;\n        \n        try {\n            if (asyncMode) {\n                pendingResponseId = getNextRequestID();\n                command = pendingResponseId + \",\" + command;\n            }\n\n            String remoteName = threadRemoteName.get();\n            if (remoteName != null) {\n                command = pendingResponseId + \",\" + CMD_REMOTE + ',' + remoteName + ',' + command;\n            }\n\n            if (debug > 0) System.out.println(\"cmd: \" + command);\n\n            portWriter.write(command);\n            portWriter.flush();\n\n            if (!!!asyncMode) {\n                delay(); // without small delay sometimes response get missed resulting in hangs\n                response = portReader.readLine();\n            } else {\n                if (asyncResponse == null) {\n                    synchronized (responseMutex) {\n                        if (asyncResponse == null) {\n                            try {\n                                responseMutex.wait(timeout);\n                            } catch (InterruptedException e) {\n                                if (LOGGER.isLoggable(java.util.logging.Level.FINE))\n                                    LOGGER.log(java.util.logging.Level.FINE, \"doCommand wait interupted\", e);\n                            }\n                        }\n                    }\n                }\n                response = asyncResponse;\n                asyncResponse = null;\n            }\n\n            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) LOGGER.log(java.util.logging.Level.FINE, \"doCommand response: \" + response);\n\n            if (response != null) {\n                return response;\n            }\n\n        } catch (IOException e) {\n            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) LOGGER.log(java.util.logging.Level.FINE, \"doCommand IOException: \" + e);\n            close();\n            throw e;\n        }\n\n        //  if its got here then the response is null\n        throw new TimeoutException(\"no response received\");\n    }\n\n    protected String getRemoteName() {\n        return null;\n    }\n\n    private void delay() {\n//         try {\n//         Thread.sleep(50);\n//         } catch (InterruptedException e) {\n//         e.printStackTrace();\n//         }\n    }\n\n    public void update(String ports, String speed, String debug) {\n        if (LOGGER.isLoggable(java.util.logging.Level.FINE))\n            LOGGER.log(java.util.logging.Level.FINE, \"update \" + ports + \" \" + speed);\n        if (isOpen()) {\n            throw new IllegalStateException();\n        }\n        if (speed != null) {\n            this.speed = Integer.parseInt(speed);\n        } else {\n            this.speed = 1000000;\n        }\n        if (ports != null) {\n            possibleCommPorts = Arrays.asList(ports.split(\",\"));;\n        }\n        if (debug != null) {\n            this.debug = Integer.parseInt(debug);\n        } else {\n            this.debug = 0;\n        }\n    }\n\n    public void ownershipChange(int arg0) {\n        if (arg0 == CommPortOwnershipListener.PORT_UNOWNED) {\n            if (LOGGER.isLoggable(java.util.logging.Level.FINE))\n                LOGGER.log(java.util.logging.Level.FINE, \"CommPortOwnershipListener closing port \" + commPort.getName());\n            close();\n        }\n    }\n\n    @Override\n    public void run() {\n        BufferedReader portReader = this.portReader;\n        while (isOpen()) {\n            try {\n                delay();\n                if (this.portReader == null)\n                    return; // closed\n\n                String response = portReader.readLine();\n                if (response != null && response.startsWith(\" \"))\n                    response = response.trim();\n\n                if (debug > 0) System.out.println(\"rsp: \" + response);\n\n                if (LOGGER.isLoggable(java.util.logging.Level.FINE))\n                    LOGGER.log(java.util.logging.Level.FINE, \"run response: \" + response);\n\n                if (response != null && response.length() > 0) {\n                    int i = response.indexOf(',');\n                    if (i < 1) {\n                        LOGGER.log(java.util.logging.Level.FINE, \"invalid response: \" + response);\n                    } else {\n                        int cmd = Integer.parseInt(response.substring(0, i));\n                        if (cmd == pendingResponseId) {\n\n                            this.asyncResponse = response.substring(i + 1);\n                            synchronized (responseMutex) {\n                                responseMutex.notify();\n                            }\n\n                        } else if (cmd == CMD_CALLBACK_TRIGGERED || cmd == CMD_CALLBACK_RESET || cmd == CMD_NAMED_CALLBACK_FIRED) {\n\n                            processCallback(cmd, response);\n\n                        } else if (cmd == CMD_LOG) {\n\n                            log(response);\n\n                        } else {\n                            LOGGER.log(java.util.logging.Level.FINE, \"unknown response: \" + response);\n                        }\n                    }\n                }\n            } catch (IOException e) {\n                LOGGER.log(java.util.logging.Level.FINE, e.getMessage(), e);\n                close();\n                return;\n            }\n        }\n    }\n\n    private void log(String response) {\n        String msg = \"Arduino '\" + commPort.getName() + \"': \" + response.substring(response.indexOf(',') + 1);\n        if (LOGGER.isLoggable(java.util.logging.Level.INFO))\n            LOGGER.log(java.util.logging.Level.INFO, msg);\n    }\n\n    private void processCallback(int cmd, String response) {\n        if (cmd == CMD_NAMED_CALLBACK_FIRED) {\n            String[] strArray = response.split(\",\");\n            List<NotificationListener> nList = notifications.get(strArray[1]);\n            if (nList != null) {\n                for (NotificationListener n : nList) {\n                    runCallback(cmd, strArray[2], n, Integer.parseInt(strArray[3]));\n                }\n            }\n        } else {\n            final int[] intArray = parseResponse(response);\n            Callback cb = callbacks.get(intArray[1]);\n            runCallback(cmd, String.valueOf(intArray[1]), cb, intArray[2]);\n        }\n    }\n\n    private void runCallback(final int type, final String id, final Object cb, final int value) {\n        if (cb != null) {\n            Runnable worker = new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        if (type == CMD_CALLBACK_TRIGGERED) {\n                            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) LOGGER.log(java.util.logging.Level.FINE, \"calling callback triggered() for callbackId: \" + id);\n                            ((Callback)cb).triggered(value);\n                        } else if (type == CMD_NAMED_CALLBACK_FIRED) {\n                            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) LOGGER.log(java.util.logging.Level.FINE, \"calling event for notification: \" + id);\n                            ((NotificationListener)cb).notify(id, value);\n                        } else {\n                            if (LOGGER.isLoggable(java.util.logging.Level.FINE)) LOGGER.log(java.util.logging.Level.FINE, \"calling callback reset() for callbackId: \" + id);\n                            ((Callback)cb).reset(value);\n                        }\n                    } catch (Throwable e) {\n                        LOGGER.log(java.util.logging.Level.FINE, \"exception while running callback: \" + e.getMessage(), e);\n                    }\n                }\n            };\n            executor.execute(worker);\n        } else {\n            LOGGER.log(java.util.logging.Level.FINE, \"unknown callback: \" + id);\n        }\n    }\n\n    private int id = 0;\n\n    private synchronized int getNextRequestID() {\n        this.id = id + 1;\n        // TODO: this is a bit clunky - currently id 31 and 32 are the callback command id's\n        // 33 is call cmd.\n        // 34 is log cmd. should have a cleaner way to do this\n        if (id == 31)\n            id = id + 4;\n        if (id == 32)\n            id = id + 3;\n        if (id == 33)\n            id = id + 2;\n        if (id == 34)\n            id = id + 1;\n        return id;\n    }\n\n    private int cbid = 0;\n\n    private synchronized int getNextCallbackID() {\n        this.cbid = cbid + 1;\n        return cbid;\n    }\n\n    @Override\n    public Arduino getRemote(String name) {\n        return new RemoteArduino(this, name);\n    }\n\n    ThreadLocal<String> threadRemoteName = new ThreadLocal<String>();\n\n    public void setRemote(String name) {\n        threadRemoteName.set(name);\n    }\n\n    public void removeRemote() {\n        threadRemoteName.remove();\n    }\n\n    @Override\n    public void clearCallbacks() throws IOException {\n        parseOkResponse(doCommand(formatCommand(CMD_CLEAR_CALLBACKS)));\n    }\n\n    private void updateArduinoVersion() throws IOException {\n        String response = doCommand(formatCommand(CMD_VERSION));\n        String[] strArray = response.split(\",\");\n        checkResponse(Integer.parseInt(strArray[0]));\n        arduinoLibVersion = strArray[1];\n        if (strArray.length == 3) {\n            arduinoName = strArray[2];\n        }\n    }\n\n    public String getArduinoLibVersion() {\n        return arduinoLibVersion;\n    }\n\n    public String getArduinoName() {\n        return arduinoName;\n    }\n\n}\n", "ne or more contributor license agreements. See the NOTICE file distributed with this work\n * for additional information regarding copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations\n * under the License.\n */\npackage cop.raml.it.foo.exception;\n\npublic class FooException extends Exception {\n\n    private boolean warning = false;\n    private boolean isModal = false;\n\n    /**\n     * Default constructor\n     */\n    public FooException() {\n    }\n\n    /**\n     * Constructor\n     *\n     * @param message the detail message\n     */\n    public FooException(final String message) {\n        super(message);\n    }\n\n    /**\n     * Constructor\n     *\n     * @param message the detail message\n     * @param warning warning flag\n     */\n    public FooException(final String message, final boolean warning) {\n        super(message);\n        this.warning = warning;\n    }\n\n    /**\n     * Constructor\n     *\n     * @param message the detail message\n     * @param warning warning flag\n     * @param isModal isModal flag\n     */\n    public FooException(final String message, final boolean warning, final boolean isModal) {\n        super(message);\n        this.warning = warning;\n        this.isModal = isModal;\n    }\n\n    /**\n     * Constructs a new exception with the specified detail message and cause\n     *\n     * @param message the detail message\n     * @param cause   the cause which is saved for later retrieval\n     */\n    public FooException(final String message, final Throwable cause) {\n        super(message, cause);\n    }\n\n    /**\n     * Constructs a new exception with the specific cause\n     *\n     * @param cause the cause which is saved for later retrieval\n     */\n    public FooException(final Throwable cause) {\n        super(cause);\n    }\n\n    /**\n     * Constructs a new exception with the specified detail message, cause,\n     * suppression enabled or disabled, and writable stack trace enabled or\n     * disabled.\n     *\n     * @param message            the detail message\n     * @param cause              the cause which is saved for later retrieval\n     * @param enableSuppression  whether or not suppression is enabled or\n     *                           disabled\n     * @param writableStackTrace whether or not the stack trace should be\n     *                           writable\n     */\n    public FooException(final String message, final Throwable cause, final boolean enableSuppression,\n                        final boolean writableStackTrace) {\n        super(message, cause, enableSuppression, writableStackTrace);\n    }\n\n    public boolean isWarning() {\n        return warning;\n    }\n\n    public void setWarning(boolean warning) {\n        this.warning = warning;\n    }\n\n    public boolean isModal() {\n        return isModal;\n    }\n\n    public void setModal(boolean isModal) {\n        this.isModal = isModal;\n    }\n}\n", "nse\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License\npackage com.innerfunction.scffld.app;\n\nimport com.innerfunction.scffld.Container;\nimport com.innerfunction.scffld.PendingNamed;\nimport com.innerfunction.uri.CompoundURI;\nimport com.innerfunction.uri.URIScheme;\nimport com.innerfunction.util.KeyPath;\n\nimport java.util.Map;\n\n/**\n * An internal URI handler for the named: scheme.\n * The named: scheme allows named components of the app container to be accessed via URI.\n * The scheme handler forwards requests to the getNamed() method of the app container.\n *\n * Attached by juliangoacher on 30/03/16.\n */\npublic class NamedScheme implements URIScheme {\n\n    private Container container;\n\n    public NamedScheme(Container container) {\n        this.container = container;\n    }\n\n    public Object dereference(CompoundURI uri, Map<String,Object> params) {\n        // Break the named reference into the initial name and a trailing path.\n        // e.g. 'object.sub.property' -> name = 'object' path = 'sub.property'\n        String name = uri.getName(), path = null;\n        int idx = name.indexOf('.');\n        if( idx > -1 ) {\n            path = name.substring( idx + 1 );\n            name = name.substring( 0, idx );\n        }\n        // Get the named object.\n        Object result = container.getNamed( name );\n        // If a path is specified then evaluate that on the named object.\n        if( result != null && path != null ) {\n            // Check for pending names. These are only returned during the container's\n            // configuration cycle, and are used to resolve circular dependencies. When\n            // these are returned then just the path needs to be recorded.\n            if( result instanceof PendingNamed ) {\n                ((PendingNamed)result).setReferencePath( path );\n            }\n            else {\n                result = KeyPath.resolve( path, result );\n            }\n        }\n        return result;\n    }\n\n}\n", "t java.nio.FloatBuffer;\nimport java.nio.ShortBuffer;\n\n/**\n * LetterQuad contains the position, color, and UV texture information for a character in text.\n * \n */\nclass LetterQuad {\n    private static final Rectangle UNBOUNDED = new Rectangle(0, 0, Float.MAX_VALUE, Float.MAX_VALUE);\n    private static final float LINE_DIR = -1;\n\n    private final BitmapFont font;\n    private final char c;\n    private final int index;\n    private int style;\n\n    private BitmapCharacter bitmapChar = null;\n    private float x0 = Integer.MIN_VALUE;\n    private float y0 = Integer.MIN_VALUE;\n    private float width = Integer.MIN_VALUE;\n    private float height = Integer.MIN_VALUE;\n    private float xAdvance = 0;\n    private float u0;\n    private float v0;\n    private float u1;\n    private float v1;\n    private float lineY;\n    private boolean eol;\n\n    private LetterQuad previous;\n    private LetterQuad next;\n    private int colorInt = 0xFFFFFFFF;\n\n    private boolean rightToLeft;\n    private float alignX;\n    private float alignY;\n    private float sizeScale = 1;\n    \n    /**\n     * create head / tail\n     * @param font\n     * @param rightToLeft\n     */\n    protected LetterQuad(BitmapFont font, boolean rightToLeft) {\n        this.font = font;\n        this.c = Character.MIN_VALUE;\n        this.rightToLeft = rightToLeft;\n        this.index = -1;\n        setBitmapChar(null);\n    }\n\n    /**\n     * create letter and append to previous LetterQuad\n     * \n     * @param c\n     * @param prev previous character\n     */\n    protected LetterQuad(char c, LetterQuad prev) {\n        this.font = prev.font;\n        this.rightToLeft = prev.rightToLeft;\n        this.c = c;\n        this.index = prev.index+1;\n        this.eol = isLineFeed();\n        setBitmapChar(c);\n        prev.insert(this);\n    }\n    \n    LetterQuad addNextCharacter(char c) {\n        LetterQuad n = new LetterQuad(c, this);\n        return n;\n    }\n\n    BitmapCharacter getBitmapChar() {\n        return bitmapChar;\n    }\n    \n    char getChar() {\n        return c;\n    }\n    \n    int getIndex() {\n        return index;\n    }\n\n    private Rectangle getBound(StringBlock block) {\n        if (block.getTextBox() != null) {\n            return block.getTextBox();\n        }\n        return UNBOUNDED;\n    }\n\n    LetterQuad getPrevious() {\n        return previous;\n    }\n\n    LetterQuad getNext() {\n        return next;\n    }\n\n    public float getU0() {\n        return u0;\n    }\n\n    float getU1() {\n        return u1;\n    }\n\n    float getV0() {\n        return v0;\n    }\n\n    float getV1() {\n        return v1;\n    }\n    \n    boolean isRightToLeft(){\n        return rightToLeft;\n    }\n    \n    boolean isInvalid() {\n        return x0 == Integer.MIN_VALUE;\n    }\n\n    boolean isInvalid(StringBlock block) {\n        return isInvalid(block, 0);\n    }\n    \n    boolean isInvalid(StringBlock block, float gap) {\n        if (isHead() || isTail())\n            return false;\n        if (x0 == Integer.MIN_VALUE || y0 == Integer.MIN_VALUE) {\n            return true;\n        }\n        Rectangle bound = block.getTextBox();\n        if (bound == null) {\n            return false;\n        }\n        return x0 > 0 && bound.x+bound.width-gap < getX1();\n    }\n    \n    void clip(StringBlock block) {\n        Rectangle bound = block.getTextBox();\n        if (bound == null)\n            return;\n            \n        // Clip the right x position and texture coordinate\n        // to the string block\n        float x1 = Math.min(bound.x + bound.width, x0 + width);\n        float newWidth = x1 - x0;\n        if( newWidth == width )\n            return;\n            \n        float rescale = newWidth / width;\n        u1 = u0 + (u1 - u0) * rescale;\n        width = newWidth;  \n    }\n    \n    float getX0() {\n        return x0;\n    }\n\n    float getX1() {\n        return x0+width;\n    }\n    \n    float getNextX() {\n        return x0+xAdvance;\n    }\n    \n    float getNextLine() {\n        return lineY+LINE_DIR*font.getCharSet().getLineHeight() * sizeScale;\n    }\n\n    float getY0() {\n        return y0;\n    }\n\n    float getY1() {\n        return y0-height;\n    }\n    \n    float getWidth() {\n        return width;\n    }\n    \n    float getHeight() {\n        return height;\n    }\n\n    void insert(LetterQuad ins) {\n        LetterQuad n = next;\n        next = ins;\n        ins.next = n;\n        ins.previous = this;\n        n.previous = ins;\n    }\n    \n    void invalidate() {\n        eol = isLineFeed();\n        setBitmapChar(font.getCharSet().getCharacter(c, style));\n    }\n\n    boolean isTail() {\n        return next == null;\n    }\n\n    boolean isHead() {\n        return previous == null;\n    }\n\n    /**\n     * @return next letter\n     */\n    LetterQuad remove() {\n        this.previous.next = next;\n        this.next.previous = previous;\n        return next;\n    }\n\n    void setPrevious(LetterQuad before) {\n        this.previous = before;\n    }\n    \n    void setStyle(int style) {\n        this.style = style;\n        invalidate();\n    }\n    \n    void setColor(ColorRGBA color) {\n        this.colorInt = color.asIntRGBA();\n        invalidate();\n    }\n\n    void setAlpha(float alpha) {\n        int i = (int)(alpha * 255) & 0xFF;\n        colorInt = (colorInt & 0xffffff00) | i; \n        invalidate();\n    }\n\n    void setBitmapChar(char c) {\n        BitmapCharacterSet charSet = font.getCharSet();\n        BitmapCharacter bm = charSet.getCharacter(c, style);\n        setBitmapChar(bm);\n    }\n    \n    void setBitmapChar(BitmapCharacter bitmapChar) {\n        x0 = Integer.MIN_VALUE;\n        y0 = Integer.MIN_VALUE;\n        width = Integer.MIN_VALUE;\n        height = Integer.MIN_VALUE;\n        alignX = 0;\n        alignY = 0;\n        \n        BitmapCharacterSet charSet = font.getCharSet();\n        this.bitmapChar = bitmapChar;\n        if (bitmapChar != null) {\n            u0 = (float) bitmapChar.getX() / charSet.getWidth();\n            v0 = (float) bitmapChar.getY() / charSet.getHeight();\n            u1 = u0 + (float) bitmapChar.getWidth() / charSet.getWidth();\n            v1 = v0 + (float) bitmapChar.getHeight() / charSet.getHeight();\n        } else {\n            u0 = 0;\n            v0 = 0;\n            u1 = 0;\n            v1 = 0;\n        }\n    }\n\n    void setNext(LetterQuad next) {\n        this.next = next;\n    }\n\n    void update(StringBlock block) {\n        final float[] tabs = block.getTabPosition();\n        final float tabWidth = block.getTabWidth();\n        final Rectangle bound = getBound(block);\n        sizeScale = block.getSize() / font.getCharSet().getRenderedSize();\n        lineY = computeLineY(block);\n\n        if (isHead()) {\n            x0 = getBound(block).x;\n            y0 = lineY;\n            width = 0;\n            height = 0;\n            xAdvance = 0;\n        } else if (isTab()) {\n            x0 = previous.getNextX();\n            width = tabWidth;\n            y0 = lineY;\n            height = 0;\n            if (tabs != null && x0 < tabs[tabs.length-1]) {\n                for (int i = 0; i < tabs.length-1; i++) {\n                    if (x0 > tabs[i] && x0 < tabs[i+1]) {\n                        width = tabs[i+1] - x0;\n                    }\n                }\n            }\n            xAdvance = width;\n        } else if (bitmapChar == null) {\n            x0 = getPrevious().getX1();\n            y0 = lineY;\n            width = 0;\n            height = 0;\n            xAdvance = 0;\n        } else {\n            float xOffset = bitmapChar.getXOffset() * sizeScale;\n            float yOffset = bitmapChar.getYOffset() * sizeScale;\n            xAdvance = bitmapChar.getXAdvance() * sizeScale;\n            width = bitmapChar.getWidth() * sizeScale;\n            height = bitmapChar.getHeight() * sizeScale;\n            float incrScale = rightToLeft ? -1f : 1f;\n            float kernAmount = 0f;\n\n            if (previous.isHead() || previous.eol) {\n                x0 = bound.x;\n                \n                // The first letter quad will be drawn right at the first\n                // position... but it does not offset by the characters offset\n                // amount.  This means that we've potentially accumulated extra\n                // pixels and the next letter won't get drawn far enough unless\n                // we add this offset back into xAdvance.. by subtracting it.\n                // This is the same thing that's done below because we've\n                // technically baked the offset in just like below.  It doesn't\n                // look like it at first glance so I'm keeping it separate with\n                // this comment.\n                xAdvance -= xOffset * incrScale; \n                \n            } else {\n                x0 = previous.getNextX() + xOffset * incrScale;\n                \n                // Since x0 will have offset baked into it then we\n                // need to counteract that in xAdvance.  This is better\n                // than removing it in getNextX() because we also need\n                // to take kerning into account below... which will also\n                // get baked in.\n                // Without this, getNextX() will return values too far to\n                // the left, for example.\n                xAdvance -= xOffset * incrScale; \n            }\n            y0 = lineY + LINE_DIR*yOffset;\n\n            // Adjust for kerning\n            BitmapCharacter lastChar = previous.getBitmapChar();\n            if (lastChar != null && block.isKerning()) {\n                kernAmount = lastChar.getKerning(c) * sizeScale;\n                x0 += kernAmount * incrScale;\n                \n                // Need to unbake the kerning from xAdvance since it\n                // is baked into x0... see above.\n                //xAdvance -= kernAmount * incrScale;\n                // No, kerning is an inter-character spacing and _does_ affect\n                // all subsequent cursor positions. \n            }\n        }\n        if (isEndOfLine()) {\n            xAdvance = bound.x-x0;\n        }\n    }\n    \n    /**\n     * add temporary linewrap indicator\n     */\n    void setEndOfLine() {\n        this.eol = true;\n    }\n    \n    boolean isEndOfLine() {\n        return eol;\n    }\n    \n    boolean isLineWrap() {\n        return !isHead() && !isTail() && bitmapChar == null && c == Character.MIN_VALUE;\n    }\n    \n    private float computeLineY(StringBlock block) {\n        if (isHead()) {\n            return getBound(block).y;\n        } else if (previous.eol) {\n            return previous.getNextLine();\n        } else {\n            return previous.lineY;\n        }\n    }\n\n    \n    boolean isLineStart() {\n        return x0 == 0 || (previous != null && previous.eol);\n    }\n    \n    boolean isBlank() {\n        return c == ' ' || isTab();\n    }\n    \n    public void storeToArrays(float[] pos, float[] tc, short[] idx, byte[] colors, int quadIdx){\n        float x = x0+alignX;\n        float y = y0-alignY;\n        float xpw = x+width;\n        float ymh = y-height;\n\n        pos[0] = x;   pos[1]  = y;   pos[2]  = 0;\n        pos[3] = x;   pos[4]  = ymh; pos[5]  = 0;\n        pos[6] = xpw; pos[7]  = ymh; pos[8]  = 0;\n        pos[9] = xpw; pos[10] = y;   pos[11] = 0;\n\n        float v0 = 1f - this.v0;\n        float v1 = 1f - this.v1;\n\n        tc[0] = u0; tc[1] = v0;\n        tc[2] = u0; tc[3] = v1;\n        tc[4] = u1; tc[5] = v1;\n        tc[6] = u1; tc[7] = v0;\n\n        colors[3] = (byte) (colorInt & 0xff);\n        colors[2] = (byte) ((colorInt >> 8) & 0xff);\n        colors[1] = (byte) ((colorInt >> 16) & 0xff);\n        colors[0] = (byte) ((colorInt >> 24) & 0xff);\n        System.arraycopy(colors, 0, colors, 4,  4);\n        System.arraycopy(colors, 0, colors, 8,  4);\n        System.arraycopy(colors, 0, colors, 12, 4);\n\n        short i0 = (short) (quadIdx * 4);\n        short i1 = (short) (i0 + 1);\n        short i2 = (short) (i0 + 2);\n        short i3 = (short) (i0 + 3);\n\n        idx[0] = i0; idx[1] = i1; idx[2] = i2;\n        idx[3] = i0; idx[4] = i2; idx[5] = i3;\n    }\n    \n    public void appendPositions(FloatBuffer fb){\n        float sx = x0+alignX;\n        float sy = y0-alignY;\n        float ex = sx+width;\n        float ey = sy-height;\n        // NOTE: subtracting the height here\n        // because OGL's Ortho origin is at lower-left\n        fb.put(sx).put(sy).put(0f);\n        fb.put(sx).put(ey).put(0f);\n        fb.put(ex).put(ey).put(0f);\n        fb.put(ex).put(sy).put(0f);\n    }\n\n    public void appendPositions(ShortBuffer sb){\n        final float x1 = getX1();\n        final float y1 = getY1();\n        short x = (short) x0;\n        short y = (short) y0;\n        short xpw = (short) (x1);\n        short ymh = (short) (y1);\n        \n        sb.put(x).put(y).put((short)0);\n        sb.put(x).put(ymh).put((short)0);\n        sb.put(xpw).put(ymh).put((short)0);\n        sb.put(xpw).put(y).put((short)0);\n    }\n\n    public void appendTexCoords(FloatBuffer fb){\n        // flip coords to be compatible with OGL\n        float v0 = 1 - this.v0;\n        float v1 = 1 - this.v1;\n\n        // upper left\n        fb.put(u0).put(v0);\n        // lower left\n        fb.put(u0).put(v1);\n        // lower right\n        fb.put(u1).put(v1);\n        // upper right\n        fb.put(u1).put(v0);\n    }\n\n    public void appendColors(ByteBuffer bb){\n        bb.putInt(colorInt);\n        bb.putInt(colorInt);\n        bb.putInt(colorInt);\n        bb.putInt(colorInt);\n    }\n\n    public void appendIndices(ShortBuffer sb, int quadIndex){\n        // each quad has 4 indices\n        short v0 = (short) (quadIndex * 4);\n        short v1 = (short) (v0 + 1);\n        short v2 = (short) (v0 + 2);\n        short v3 = (short) (v0 + 3);\n\n        sb.put(v0).put(v1).put(v2);\n        sb.put(v0).put(v2).put(v3);\n//        sb.put(new short[]{ v0, v1, v2,\n//                            v0, v2, v3 });\n    }\n\n\n    @Override\n    public String toString() {\n        return String.valueOf(c);\n    }\n\n    void setAlignment(float alignX, float alignY) {\n        this.alignX = alignX;\n        this.alignY = alignY;\n    }\n\n    float getAlignX() {\n        return alignX;\n    }\n\n    float getAlignY() {\n        return alignY;\n    }\n\n    boolean isLineFeed() {\n        return c == '\\n';\n    }\n    \n    boolean isTab() {\n        return c == '\\t';\n    }\n    \n}\n", " under both the GPLv2 (found in the\n//  COPYING file in the root directory) and Apache 2.0 License\n//  (found in the LICENSE.Apache file in the root directory).\n\npackage org.rocksdb;\n\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Properties;\n\n/**\n * ColumnFamilyOptions to control the behavior of a database.  It will be used\n * during the creation of a {@link org.rocksdb.RocksDB} (i.e., RocksDB.open()).\n *\n * If {@link #dispose()} function is not called, then it will be GC'd\n * automatically and native resources will be released as part of the process.\n */\npublic class ColumnFamilyOptions extends RocksObject\n    implements ColumnFamilyOptionsInterface<ColumnFamilyOptions>,\n    MutableColumnFamilyOptionsInterface<ColumnFamilyOptions> {\n  static {\n    RocksDB.loadLibrary();\n  }\n\n  /**\n   * Construct ColumnFamilyOptions.\n   *\n   * This constructor will create (by allocating a block of memory)\n   * an {@code rocksdb::DBOptions} in the c++ side.\n   */\n  public ColumnFamilyOptions() {\n    super(newColumnFamilyOptions());\n  }\n\n  /**\n   * <p>Method to get a options instance by using pre-configured\n   * property values. If one or many values are undefined in\n   * the context of RocksDB the method will return a null\n   * value.</p>\n   *\n   * <p><strong>Note</strong>: Property keys can be derived from\n   * getter methods within the options class. Example: the method\n   * {@code writeBufferSize()} has a property key:\n   * {@code write_buffer_size}.</p>\n   *\n   * @param properties {@link java.util.Properties} instance.\n   *\n   * @return {@link org.rocksdb.ColumnFamilyOptions instance}\n   *     or null.\n   *\n   * @throws java.lang.IllegalArgumentException if null or empty\n   *     {@link Properties} instance is passed to the method call.\n   */\n  public static ColumnFamilyOptions getColumnFamilyOptionsFromProps(\n      final Properties properties) {\n    if (properties == null || properties.size() == 0) {\n      throw new IllegalArgumentException(\n          \"Properties value must contain at least one value.\");\n    }\n    ColumnFamilyOptions columnFamilyOptions = null;\n    StringBuilder stringBuilder = new StringBuilder();\n    for (final String name : properties.stringPropertyNames()){\n      stringBuilder.append(name);\n      stringBuilder.append(\"=\");\n      stringBuilder.append(properties.getProperty(name));\n      stringBuilder.append(\";\");\n    }\n    long handle = getColumnFamilyOptionsFromProps(\n        stringBuilder.toString());\n    if (handle != 0){\n      columnFamilyOptions = new ColumnFamilyOptions(handle);\n    }\n    return columnFamilyOptions;\n  }\n\n  @Override\n  public ColumnFamilyOptions optimizeForSmallDb() {\n    optimizeForSmallDb(nativeHandle_);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions optimizeForPointLookup(\n      final long blockCacheSizeMb) {\n    optimizeForPointLookup(nativeHandle_,\n        blockCacheSizeMb);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions optimizeLevelStyleCompaction() {\n    optimizeLevelStyleCompaction(nativeHandle_,\n        DEFAULT_COMPACTION_MEMTABLE_MEMORY_BUDGET);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions optimizeLevelStyleCompaction(\n      final long memtableMemoryBudget) {\n    optimizeLevelStyleCompaction(nativeHandle_,\n        memtableMemoryBudget);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions optimizeUniversalStyleCompaction() {\n    optimizeUniversalStyleCompaction(nativeHandle_,\n        DEFAULT_COMPACTION_MEMTABLE_MEMORY_BUDGET);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions optimizeUniversalStyleCompaction(\n      final long memtableMemoryBudget) {\n    optimizeUniversalStyleCompaction(nativeHandle_,\n        memtableMemoryBudget);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions setComparator(\n      final BuiltinComparator builtinComparator) {\n    assert(isOwningHandle());\n    setComparatorHandle(nativeHandle_, builtinComparator.ordinal());\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions setComparator(\n      final AbstractComparator<? extends AbstractSlice<?>> comparator) {\n    assert (isOwningHandle());\n    setComparatorHandle(nativeHandle_, comparator.getNativeHandle());\n    comparator_ = comparator;\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions setMergeOperatorName(final String name) {\n    assert (isOwningHandle());\n    if (name == null) {\n      throw new IllegalArgumentException(\n          \"Merge operator name must not be null.\");\n    }\n    setMergeOperatorName(nativeHandle_, name);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions setMergeOperator(\n      final MergeOperator mergeOperator) {\n    setMergeOperator(nativeHandle_, mergeOperator.nativeHandle_);\n    return this;\n  }\n\n  public ColumnFamilyOptions setCompactionFilter(\n        final AbstractCompactionFilter<? extends AbstractSlice<?>>\n            compactionFilter) {\n    setCompactionFilterHandle(nativeHandle_, compactionFilter.nativeHandle_);\n    compactionFilter_ = compactionFilter;\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions setWriteBufferSize(final long writeBufferSize) {\n    assert(isOwningHandle());\n    setWriteBufferSize(nativeHandle_, writeBufferSize);\n    return this;\n  }\n\n  @Override\n  public long writeBufferSize()  {\n    assert(isOwningHandle());\n    return writeBufferSize(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxWriteBufferNumber(\n      final int maxWriteBufferNumber) {\n    assert(isOwningHandle());\n    setMaxWriteBufferNumber(nativeHandle_, maxWriteBufferNumber);\n    return this;\n  }\n\n  @Override\n  public int maxWriteBufferNumber() {\n    assert(isOwningHandle());\n    return maxWriteBufferNumber(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMinWriteBufferNumberToMerge(\n      final int minWriteBufferNumberToMerge) {\n    setMinWriteBufferNumberToMerge(nativeHandle_, minWriteBufferNumberToMerge);\n    return this;\n  }\n\n  @Override\n  public int minWriteBufferNumberToMerge() {\n    return minWriteBufferNumberToMerge(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions useFixedLengthPrefixExtractor(final int n) {\n    assert(isOwningHandle());\n    useFixedLengthPrefixExtractor(nativeHandle_, n);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions useCappedPrefixExtractor(final int n) {\n    assert(isOwningHandle());\n    useCappedPrefixExtractor(nativeHandle_, n);\n    return this;\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompressionType(\n      final CompressionType compressionType) {\n    setCompressionType(nativeHandle_, compressionType.getValue());\n    return this;\n  }\n\n  @Override\n  public CompressionType compressionType() {\n    return CompressionType.getCompressionType(compressionType(nativeHandle_));\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompressionPerLevel(\n      final List<CompressionType> compressionLevels) {\n    final byte[] byteCompressionTypes = new byte[\n        compressionLevels.size()];\n    for (int i = 0; i < compressionLevels.size(); i++) {\n      byteCompressionTypes[i] = compressionLevels.get(i).getValue();\n    }\n    setCompressionPerLevel(nativeHandle_, byteCompressionTypes);\n    return this;\n  }\n\n  @Override\n  public List<CompressionType> compressionPerLevel() {\n    final byte[] byteCompressionTypes =\n        compressionPerLevel(nativeHandle_);\n    final List<CompressionType> compressionLevels = new ArrayList<>();\n    for (final Byte byteCompressionType : byteCompressionTypes) {\n      compressionLevels.add(CompressionType.getCompressionType(\n          byteCompressionType));\n    }\n    return compressionLevels;\n  }\n\n  @Override\n  public ColumnFamilyOptions setBottommostCompressionType(\n      final CompressionType bottommostCompressionType) {\n    setBottommostCompressionType(nativeHandle_,\n        bottommostCompressionType.getValue());\n    return this;\n  }\n\n  @Override\n  public CompressionType bottommostCompressionType() {\n    return CompressionType.getCompressionType(\n        bottommostCompressionType(nativeHandle_));\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompressionOptions(\n      final CompressionOptions compressionOptions) {\n    setCompressionOptions(nativeHandle_, compressionOptions.nativeHandle_);\n    this.compressionOptions_ = compressionOptions;\n    return this;\n  }\n\n  @Override\n  public CompressionOptions compressionOptions() {\n    return this.compressionOptions_;\n  }\n\n  @Override\n  public ColumnFamilyOptions setNumLevels(final int numLevels) {\n    setNumLevels(nativeHandle_, numLevels);\n    return this;\n  }\n\n  @Override\n  public int numLevels() {\n    return numLevels(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevelZeroFileNumCompactionTrigger(\n      final int numFiles) {\n    setLevelZeroFileNumCompactionTrigger(\n        nativeHandle_, numFiles);\n    return this;\n  }\n\n  @Override\n  public int levelZeroFileNumCompactionTrigger() {\n    return levelZeroFileNumCompactionTrigger(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevelZeroSlowdownWritesTrigger(\n      final int numFiles) {\n    setLevelZeroSlowdownWritesTrigger(nativeHandle_, numFiles);\n    return this;\n  }\n\n  @Override\n  public int levelZeroSlowdownWritesTrigger() {\n    return levelZeroSlowdownWritesTrigger(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevelZeroStopWritesTrigger(final int numFiles) {\n    setLevelZeroStopWritesTrigger(nativeHandle_, numFiles);\n    return this;\n  }\n\n  @Override\n  public int levelZeroStopWritesTrigger() {\n    return levelZeroStopWritesTrigger(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setTargetFileSizeBase(\n      final long targetFileSizeBase) {\n    setTargetFileSizeBase(nativeHandle_, targetFileSizeBase);\n    return this;\n  }\n\n  @Override\n  public long targetFileSizeBase() {\n    return targetFileSizeBase(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setTargetFileSizeMultiplier(\n      final int multiplier) {\n    setTargetFileSizeMultiplier(nativeHandle_, multiplier);\n    return this;\n  }\n\n  @Override\n  public int targetFileSizeMultiplier() {\n    return targetFileSizeMultiplier(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxBytesForLevelBase(\n      final long maxBytesForLevelBase) {\n    setMaxBytesForLevelBase(nativeHandle_, maxBytesForLevelBase);\n    return this;\n  }\n\n  @Override\n  public long maxBytesForLevelBase() {\n    return maxBytesForLevelBase(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevelCompactionDynamicLevelBytes(\n      final boolean enableLevelCompactionDynamicLevelBytes) {\n    setLevelCompactionDynamicLevelBytes(nativeHandle_,\n        enableLevelCompactionDynamicLevelBytes);\n    return this;\n  }\n\n  @Override\n  public boolean levelCompactionDynamicLevelBytes() {\n    return levelCompactionDynamicLevelBytes(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxBytesForLevelMultiplier(final double multiplier) {\n    setMaxBytesForLevelMultiplier(nativeHandle_, multiplier);\n    return this;\n  }\n\n  @Override\n  public double maxBytesForLevelMultiplier() {\n    return maxBytesForLevelMultiplier(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxCompactionBytes(final long maxCompactionBytes) {\n    setMaxCompactionBytes(nativeHandle_, maxCompactionBytes);\n    return this;\n  }\n\n  @Override\n  public long maxCompactionBytes() {\n    return maxCompactionBytes(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setArenaBlockSize(\n      final long arenaBlockSize) {\n    setArenaBlockSize(nativeHandle_, arenaBlockSize);\n    return this;\n  }\n\n  @Override\n  public long arenaBlockSize() {\n    return arenaBlockSize(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setDisableAutoCompactions(\n      final boolean disableAutoCompactions) {\n    setDisableAutoCompactions(nativeHandle_, disableAutoCompactions);\n    return this;\n  }\n\n  @Override\n  public boolean disableAutoCompactions() {\n    return disableAutoCompactions(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompactionStyle(\n      final CompactionStyle compactionStyle) {\n    setCompactionStyle(nativeHandle_, compactionStyle.getValue());\n    return this;\n  }\n\n  @Override\n  public CompactionStyle compactionStyle() {\n    return CompactionStyle.values()[compactionStyle(nativeHandle_)];\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxTableFilesSizeFIFO(\n      final long maxTableFilesSize) {\n    assert(maxTableFilesSize > 0); // unsigned native type\n    assert(isOwningHandle());\n    setMaxTableFilesSizeFIFO(nativeHandle_, maxTableFilesSize);\n    return this;\n  }\n\n  @Override\n  public long maxTableFilesSizeFIFO() {\n    return maxTableFilesSizeFIFO(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxSequentialSkipInIterations(\n      final long maxSequentialSkipInIterations) {\n    setMaxSequentialSkipInIterations(nativeHandle_,\n        maxSequentialSkipInIterations);\n    return this;\n  }\n\n  @Override\n  public long maxSequentialSkipInIterations() {\n    return maxSequentialSkipInIterations(nativeHandle_);\n  }\n\n  @Override\n  public MemTableConfig memTableConfig() {\n    return this.memTableConfig_;\n  }\n\n  @Override\n  public ColumnFamilyOptions setMemTableConfig(\n      final MemTableConfig memTableConfig) {\n    setMemTableFactory(\n        nativeHandle_, memTableConfig.newMemTableFactoryHandle());\n    this.memTableConfig_ = memTableConfig;\n    return this;\n  }\n\n  @Override\n  public String memTableFactoryName() {\n    assert(isOwningHandle());\n    return memTableFactoryName(nativeHandle_);\n  }\n\n  @Override\n  public TableFormatConfig tableFormatConfig() {\n    return this.tableFormatConfig_;\n  }\n\n  @Override\n  public ColumnFamilyOptions setTableFormatConfig(\n      final TableFormatConfig tableFormatConfig) {\n    setTableFactory(nativeHandle_, tableFormatConfig.newTableFactoryHandle());\n    this.tableFormatConfig_ = tableFormatConfig;\n    return this;\n  }\n\n  @Override\n  public String tableFactoryName() {\n    assert(isOwningHandle());\n    return tableFactoryName(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setInplaceUpdateSupport(\n      final boolean inplaceUpdateSupport) {\n    setInplaceUpdateSupport(nativeHandle_, inplaceUpdateSupport);\n    return this;\n  }\n\n  @Override\n  public boolean inplaceUpdateSupport() {\n    return inplaceUpdateSupport(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setInplaceUpdateNumLocks(\n      final long inplaceUpdateNumLocks) {\n    setInplaceUpdateNumLocks(nativeHandle_, inplaceUpdateNumLocks);\n    return this;\n  }\n\n  @Override\n  public long inplaceUpdateNumLocks() {\n    return inplaceUpdateNumLocks(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMemtablePrefixBloomSizeRatio(\n      final double memtablePrefixBloomSizeRatio) {\n    setMemtablePrefixBloomSizeRatio(nativeHandle_, memtablePrefixBloomSizeRatio);\n    return this;\n  }\n\n  @Override\n  public double memtablePrefixBloomSizeRatio() {\n    return memtablePrefixBloomSizeRatio(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setBloomLocality(int bloomLocality) {\n    setBloomLocality(nativeHandle_, bloomLocality);\n    return this;\n  }\n\n  @Override\n  public int bloomLocality() {\n    return bloomLocality(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxSuccessiveMerges(\n      final long maxSuccessiveMerges) {\n    setMaxSuccessiveMerges(nativeHandle_, maxSuccessiveMerges);\n    return this;\n  }\n\n  @Override\n  public long maxSuccessiveMerges() {\n    return maxSuccessiveMerges(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setOptimizeFiltersForHits(\n      final boolean optimizeFiltersForHits) {\n    setOptimizeFiltersForHits(nativeHandle_, optimizeFiltersForHits);\n    return this;\n  }\n\n  @Override\n  public boolean optimizeFiltersForHits() {\n    return optimizeFiltersForHits(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions\n  setMemtableHugePageSize(\n      long memtableHugePageSize) {\n    setMemtableHugePageSize(nativeHandle_,\n        memtableHugePageSize);\n    return this;\n  }\n\n  @Override\n  public long memtableHugePageSize() {\n    return memtableHugePageSize(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setSoftPendingCompactionBytesLimit(long softPendingCompactionBytesLimit) {\n    setSoftPendingCompactionBytesLimit(nativeHandle_,\n        softPendingCompactionBytesLimit);\n    return this;\n  }\n\n  @Override\n  public long softPendingCompactionBytesLimit() {\n    return softPendingCompactionBytesLimit(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setHardPendingCompactionBytesLimit(long hardPendingCompactionBytesLimit) {\n    setHardPendingCompactionBytesLimit(nativeHandle_, hardPendingCompactionBytesLimit);\n    return this;\n  }\n\n  @Override\n  public long hardPendingCompactionBytesLimit() {\n    return hardPendingCompactionBytesLimit(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevel0FileNumCompactionTrigger(int level0FileNumCompactionTrigger) {\n    setLevel0FileNumCompactionTrigger(nativeHandle_, level0FileNumCompactionTrigger);\n    return this;\n  }\n\n  @Override\n  public int level0FileNumCompactionTrigger() {\n    return level0FileNumCompactionTrigger(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevel0SlowdownWritesTrigger(int level0SlowdownWritesTrigger) {\n    setLevel0SlowdownWritesTrigger(nativeHandle_, level0SlowdownWritesTrigger);\n    return this;\n  }\n\n  @Override\n  public int level0SlowdownWritesTrigger() {\n    return level0SlowdownWritesTrigger(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setLevel0StopWritesTrigger(int level0StopWritesTrigger) {\n    setLevel0StopWritesTrigger(nativeHandle_, level0StopWritesTrigger);\n    return this;\n  }\n\n  @Override\n  public int level0StopWritesTrigger() {\n    return level0StopWritesTrigger(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxBytesForLevelMultiplierAdditional(int[] maxBytesForLevelMultiplierAdditional) {\n    setMaxBytesForLevelMultiplierAdditional(nativeHandle_, maxBytesForLevelMultiplierAdditional);\n    return this;\n  }\n\n  @Override\n  public int[] maxBytesForLevelMultiplierAdditional() {\n    return maxBytesForLevelMultiplierAdditional(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setParanoidFileChecks(boolean paranoidFileChecks) {\n    setParanoidFileChecks(nativeHandle_, paranoidFileChecks);\n    return this;\n  }\n\n  @Override\n  public boolean paranoidFileChecks() {\n    return paranoidFileChecks(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setMaxWriteBufferNumberToMaintain(\n      final int maxWriteBufferNumberToMaintain) {\n    setMaxWriteBufferNumberToMaintain(\n        nativeHandle_, maxWriteBufferNumberToMaintain);\n    return this;\n  }\n\n  @Override\n  public int maxWriteBufferNumberToMaintain() {\n    return maxWriteBufferNumberToMaintain(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompactionPriority(\n      final CompactionPriority compactionPriority) {\n    setCompactionPriority(nativeHandle_, compactionPriority.getValue());\n    return this;\n  }\n\n  @Override\n  public CompactionPriority compactionPriority() {\n    return CompactionPriority.getCompactionPriority(\n        compactionPriority(nativeHandle_));\n  }\n\n  @Override\n  public ColumnFamilyOptions setReportBgIoStats(final boolean reportBgIoStats) {\n    setReportBgIoStats(nativeHandle_, reportBgIoStats);\n    return this;\n  }\n\n  @Override\n  public boolean reportBgIoStats() {\n    return reportBgIoStats(nativeHandle_);\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompactionOptionsUniversal(\n      final CompactionOptionsUniversal compactionOptionsUniversal) {\n    setCompactionOptionsUniversal(nativeHandle_,\n        compactionOptionsUniversal.nativeHandle_);\n    this.compactionOptionsUniversal_ = compactionOptionsUniversal;\n    return this;\n  }\n\n  @Override\n  public CompactionOptionsUniversal compactionOptionsUniversal() {\n    return this.compactionOptionsUniversal_;\n  }\n\n  @Override\n  public ColumnFamilyOptions setCompactionOptionsFIFO(final CompactionOptionsFIFO compactionOptionsFIFO) {\n    setCompactionOptionsFIFO(nativeHandle_,\n        compactionOptionsFIFO.nativeHandle_);\n    this.compactionOptionsFIFO_ = compactionOptionsFIFO;\n    return this;\n  }\n\n  @Override\n  public CompactionOptionsFIFO compactionOptionsFIFO() {\n    return this.compactionOptionsFIFO_;\n  }\n\n  @Override\n  public ColumnFamilyOptions setForceConsistencyChecks(final boolean forceConsistencyChecks) {\n    setForceConsistencyChecks(nativeHandle_, forceConsistencyChecks);\n    return this;\n  }\n\n  @Override\n  public boolean forceConsistencyChecks() {\n    return forceConsistencyChecks(nativeHandle_);\n  }\n\n  /**\n   * <p>Private constructor to be used by\n   * {@link #getColumnFamilyOptionsFromProps(java.util.Properties)}</p>\n   *\n   * @param handle native handle to ColumnFamilyOptions instance.\n   */\n  private ColumnFamilyOptions(final long handle) {\n    super(handle);\n  }\n\n  private static native long getColumnFamilyOptionsFromProps(\n      String optString);\n\n  private static native long newColumnFamilyOptions();\n  @Override protected final native void disposeInternal(final long handle);\n\n  private native void optimizeForSmallDb(final long handle);\n  private native void optimizeForPointLookup(long handle,\n      long blockCacheSizeMb);\n  private native void optimizeLevelStyleCompaction(long handle,\n      long memtableMemoryBudget);\n  private native void optimizeUniversalStyleCompaction(long handle,\n      long memtableMemoryBudget);\n  private native void setComparatorHandle(long handle, int builtinComparator);\n  private native void setComparatorHandle(long optHandle,\n      long comparatorHandle);\n  private native void setMergeOperatorName(long handle, String name);\n  private native void setMergeOperator(long handle, long mergeOperatorHandle);\n  private native void setCompactionFilterHandle(long handle,\n      long compactionFilterHandle);\n  private native void setWriteBufferSize(long handle, long writeBufferSize)\n      throws IllegalArgumentException;\n  private native long writeBufferSize(long handle);\n  private native void setMaxWriteBufferNumber(\n      long handle, int maxWriteBufferNumber);\n  private native int maxWriteBufferNumber(long handle);\n  private native void setMinWriteBufferNumberToMerge(\n      long handle, int minWriteBufferNumberToMerge);\n  private native int minWriteBufferNumberToMerge(long handle);\n  private native void setCompressionType(long handle, byte compressionType);\n  private native byte compressionType(long handle);\n  private native void setCompressionPerLevel(long handle,\n      byte[] compressionLevels);\n  private native byte[] compressionPerLevel(long handle);\n  private native void setBottommostCompressionType(long handle,\n      byte bottommostCompressionType);\n  private native byte bottommostCompressionType(long handle);\n  private native void setCompressionOptions(long handle,\n      long compressionOptionsHandle);\n  private native void useFixedLengthPrefixExtractor(\n      long handle, int prefixLength);\n  private native void useCappedPrefixExtractor(\n      long handle, int prefixLength);\n  private native void setNumLevels(\n      long handle, int numLevels);\n  private native int numLevels(long handle);\n  private native void setLevelZeroFileNumCompactionTrigger(\n      long handle, int numFiles);\n  private native int levelZeroFileNumCompactionTrigger(long handle);\n  private native void setLevelZeroSlowdownWritesTrigger(\n      long handle, int numFiles);\n  private native int levelZeroSlowdownWritesTrigger(long handle);\n  private native void setLevelZeroStopWritesTrigger(\n      long handle, int numFiles);\n  private native int levelZeroStopWritesTrigger(long handle);\n  private native void setTargetFileSizeBase(\n      long handle, long targetFileSizeBase);\n  private native long targetFileSizeBase(long handle);\n  private native void setTargetFileSizeMultiplier(\n      long handle, int multiplier);\n  private native int targetFileSizeMultiplier(long handle);\n  private native void setMaxBytesForLevelBase(\n      long handle, long maxBytesForLevelBase);\n  private native long maxBytesForLevelBase(long handle);\n  private native void setLevelCompactionDynamicLevelBytes(\n      long handle, boolean enableLevelCompactionDynamicLevelBytes);\n  private native boolean levelCompactionDynamicLevelBytes(\n      long handle);\n  private native void setMaxBytesForLevelMultiplier(long handle, double multiplier);\n  private native double maxBytesForLevelMultiplier(long handle);\n  private native void setMaxCompactionBytes(long handle, long maxCompactionBytes);\n  private native long maxCompactionBytes(long handle);\n  private native void setArenaBlockSize(\n      long handle, long arenaBlockSize)\n      throws IllegalArgumentException;\n  private native long arenaBlockSize(long handle);\n  private native void setDisableAutoCompactions(\n      long handle, boolean disableAutoCompactions);\n  private native boolean disableAutoCompactions(long handle);\n  private native void setCompactionStyle(long handle, byte compactionStyle);\n  private native byte compactionStyle(long handle);\n   private native void setMaxTableFilesSizeFIFO(\n      long handle, long max_table_files_size);\n  private native long maxTableFilesSizeFIFO(long handle);\n  private native void setMaxSequentialSkipInIterations(\n      long handle, long maxSequentialSkipInIterations);\n  private native long maxSequentialSkipInIterations(long handle);\n  private native void setMemTableFactory(long handle, long factoryHandle);\n  private native String memTableFactoryName(long handle);\n  private native void setTableFactory(long handle, long factoryHandle);\n  private native String tableFactoryName(long handle);\n  private native void setInplaceUpdateSupport(\n      long handle, boolean inplaceUpdateSupport);\n  private native boolean inplaceUpdateSupport(long handle);\n  private native void setInplaceUpdateNumLocks(\n      long handle, long inplaceUpdateNumLocks)\n      throws IllegalArgumentException;\n  private native long inplaceUpdateNumLocks(long handle);\n  private native void setMemtablePrefixBloomSizeRatio(\n      long handle, double memtablePrefixBloomSizeRatio);\n  private native double memtablePrefixBloomSizeRatio(long handle);\n  private native void setBloomLocality(\n      long handle, int bloomLocality);\n  private native int bloomLocality(long handle);\n  private native void setMaxSuccessiveMerges(\n      long handle, long maxSuccessiveMerges)\n      throws IllegalArgumentException;\n  private native long maxSuccessiveMerges(long handle);\n  private native void setOptimizeFiltersForHits(long handle,\n      boolean optimizeFiltersForHits);\n  private native boolean optimizeFiltersForHits(long handle);\n  private native void setMemtableHugePageSize(long handle,\n      long memtableHugePageSize);\n  private native long memtableHugePageSize(long handle);\n  private native void setSoftPendingCompactionBytesLimit(long handle,\n      long softPendingCompactionBytesLimit);\n  private native long softPendingCompactionBytesLimit(long handle);\n  private native void setHardPendingCompactionBytesLimit(long handle,\n      long hardPendingCompactionBytesLimit);\n  private native long hardPendingCompactionBytesLimit(long handle);\n  private native void setLevel0FileNumCompactionTrigger(long handle,\n      int level0FileNumCompactionTrigger);\n  private native int level0FileNumCompactionTrigger(long handle);\n  private native void setLevel0SlowdownWritesTrigger(long handle,\n      int level0SlowdownWritesTrigger);\n  private native int level0SlowdownWritesTrigger(long handle);\n  private native void setLevel0StopWritesTrigger(long handle,\n      int level0StopWritesTrigger);\n  private native int level0StopWritesTrigger(long handle);\n  private native void setMaxBytesForLevelMultiplierAdditional(long handle,\n      int[] maxBytesForLevelMultiplierAdditional);\n  private native int[] maxBytesForLevelMultiplierAdditional(long handle);\n  private native void setParanoidFileChecks(long handle,\n      boolean paranoidFileChecks);\n  private native boolean paranoidFileChecks(long handle);\n  private native void setMaxWriteBufferNumberToMaintain(final long handle,\n      final int maxWriteBufferNumberToMaintain);\n  private native int maxWriteBufferNumberToMaintain(final long handle);\n  private native void setCompactionPriority(final long handle,\n      final byte compactionPriority);\n  private native byte compactionPriority(final long handle);\n  private native void setReportBgIoStats(final long handle,\n    final boolean reportBgIoStats);\n  private native boolean reportBgIoStats(final long handle);\n  private native void setCompactionOptionsUniversal(final long handle,\n    final long compactionOptionsUniversalHandle);\n  private native void setCompactionOptionsFIFO(final long handle,\n    final long compactionOptionsFIFOHandle);\n  private native void setForceConsistencyChecks(final long handle,\n    final boolean forceConsistencyChecks);\n  private native boolean forceConsistencyChecks(final long handle);\n\n  // instance variables\n  private MemTableConfig memTableConfig_;\n  private TableFormatConfig tableFormatConfig_;\n  private AbstractComparator<? extends AbstractSlice<?>> comparator_;\n  private AbstractCompactionFilter<? extends AbstractSlice<?>> compactionFilter_;\n  private CompactionOptionsUniversal compactionOptionsUniversal_;\n  private CompactionOptionsFIFO compactionOptionsFIFO_;\n  private CompressionOptions compressionOptions_;\n\n}\n", "port javax.persistence.GenerationType;\nimport javax.persistence.Id;\n\n@Entity\npublic class Customer727 {\n\n\t@Id @GeneratedValue(strategy = GenerationType.AUTO) private long id;\n\tprivate String firstName;\n\tprivate String lastName;\n\n\tprotected Customer727() {}\n\n\tpublic Customer727(String firstName, String lastName) {\n\t\tthis.firstName = firstName;\n\t\tthis.lastName = lastName;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn String.format(\"Customer727[id=%d, firstName='%s', lastName='%s']\", id, firstName, lastName);\n\t}\n\n}\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.ignite.loadtests.dsi;\n\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.concurrent.ConcurrentMap;\nimport java.util.concurrent.atomic.AtomicLong;\nimport javax.cache.Cache;\nimport javax.cache.processor.EntryProcessor;\nimport javax.cache.processor.EntryProcessorException;\nimport javax.cache.processor.MutableEntry;\nimport org.apache.ignite.Ignite;\nimport org.apache.ignite.IgniteAtomicSequence;\nimport org.apache.ignite.IgniteCache;\nimport org.apache.ignite.cache.affinity.AffinityKeyMapped;\nimport org.apache.ignite.compute.ComputeJobAdapter;\nimport org.apache.ignite.internal.IgniteKernal;\nimport org.apache.ignite.internal.processors.cache.distributed.dht.GridDhtCacheAdapter;\nimport org.apache.ignite.internal.processors.cache.distributed.near.GridNearCacheAdapter;\nimport org.apache.ignite.internal.util.GridAtomicLong;\nimport org.apache.ignite.internal.util.typedef.T2;\nimport org.apache.ignite.internal.util.typedef.T3;\nimport org.apache.ignite.internal.util.typedef.X;\nimport org.apache.ignite.resources.IgniteInstanceResource;\nimport org.apache.ignite.transactions.Transaction;\nimport org.jetbrains.annotations.Nullable;\nimport org.jsr166.ConcurrentHashMap8;\n\n/**\n *\n */\npublic class GridDsiPerfJob extends ComputeJobAdapter {\n    /** */\n    private static final ConcurrentMap<Thread, ConcurrentMap<String, T3<Long, Long, Long>>> timers =\n        new ConcurrentHashMap8<>();\n\n    /** */\n    @AffinityKeyMapped\n    private String affKey;\n\n    /** */\n    private static final long PRINT_FREQ = 10000;\n\n    /** */\n    private static final GridAtomicLong lastPrint = new GridAtomicLong();\n\n    /** */\n    private static final long MAX = 5000;\n\n    /** */\n    @IgniteInstanceResource\n    private Ignite ignite;\n\n    /** */\n    private String cacheName = \"PARTITIONED_CACHE\";\n\n    /**\n     * @param msg Message.\n     */\n    public GridDsiPerfJob(@Nullable GridDsiMessage msg) {\n        super(msg);\n\n        affKey = message().getTerminalId();\n    }\n\n    /**\n     * @return Message.\n     */\n    @Nullable private GridDsiMessage message() {\n        return argument(0);\n    }\n\n    /**\n     * @return Terminal ID.\n     */\n    @Nullable public String terminalId() {\n        GridDsiMessage msg = message();\n\n        return msg != null ? msg.getTerminalId() : null;\n    }\n\n    /**\n     * @return Result.\n     */\n    @SuppressWarnings(\"ConstantConditions\")\n    @Override public Object execute() {\n        ConcurrentMap<String, T2<AtomicLong, AtomicLong>> nodeLoc = ignite.cluster().nodeLocalMap();\n\n        T2<AtomicLong, AtomicLong> cntrs = nodeLoc.get(\"cntrs\");\n\n        if (cntrs == null) {\n            T2<AtomicLong, AtomicLong> other = nodeLoc.putIfAbsent(\"cntrs\",\n                cntrs = new T2<>(new AtomicLong(), new AtomicLong(System.currentTimeMillis())));\n\n            if (other != null)\n                cntrs = other;\n        }\n\n        long cnt = cntrs.get1().incrementAndGet();\n\n        GridNearCacheAdapter near = (GridNearCacheAdapter)((IgniteKernal) ignite).internalCache(cacheName);\n        GridDhtCacheAdapter dht = near.dht();\n\n        doWork();\n\n        long start = cntrs.get2().get();\n\n        long now = System.currentTimeMillis();\n\n        long dur = now - start;\n\n        if (dur > 20000 && cntrs.get2().compareAndSet(start, System.currentTimeMillis())) {\n            cntrs.get1().set(0);\n\n            long txPerSec = cnt / (dur / 1000);\n\n            X.println(\"Stats [tx/sec=\" + txPerSec + \", nearSize=\" + near.size() + \", dhtSize=\" + dht.size() + ']');\n\n            return new T3<>(txPerSec, near.size(), dht.size());\n        }\n\n        return null;\n    }\n\n    /**\n     * @param name Timer name to start.\n     */\n    private void startTimer(String name) {\n        ConcurrentMap<String, T3<Long, Long, Long>> m = timers.get(Thread.currentThread());\n\n        if (m == null) {\n            ConcurrentMap<String, T3<Long, Long, Long>> old = timers.putIfAbsent(Thread.currentThread(),\n                m = new ConcurrentHashMap8<>());\n\n            if (old != null)\n                m = old;\n        }\n\n        T3<Long, Long, Long> t = m.get(name);\n\n        if (t == null) {\n            T3<Long, Long, Long> old = m.putIfAbsent(name, t = new T3<>());\n\n            if (old != null)\n                t = old;\n        }\n\n        t.set1(System.currentTimeMillis());\n        t.set2(0L);\n    }\n\n    /**\n     * @param name Timer name to stop.\n     */\n    @SuppressWarnings(\"ConstantConditions\")\n    private void stopTimer(String name) {\n        ConcurrentMap<String, T3<Long, Long, Long>> m = timers.get(Thread.currentThread());\n\n        T3<Long, Long, Long> t = m.get(name);\n\n        assert t != null;\n\n        long now = System.currentTimeMillis();\n\n        t.set2(now);\n\n        t.set3(Math.max(t.get3() == null ? 0 : t.get3(), now - t.get1()));\n    }\n\n    /**\n     *\n     */\n    private void printTimers() {\n        long now = System.currentTimeMillis();\n\n        if (lastPrint.get() + PRINT_FREQ < now && lastPrint.setIfGreater(now)) {\n            Map<String, Long> maxes = new HashMap<>();\n\n            for (Map.Entry<Thread, ConcurrentMap<String, T3<Long, Long, Long>>> e1 : timers.entrySet()) {\n                for (Map.Entry<String, T3<Long, Long, Long>> e2 : e1.getValue().entrySet()) {\n                    T3<Long, Long, Long> t = e2.getValue();\n\n                    Long start = t.get1();\n                    Long end = t.get2();\n\n                    assert start != null;\n                    assert end != null;\n\n                    long duration = end == 0 ? now - start : end - start;\n\n                    long max = t.get3() == null ? duration : t.get3();\n\n                    if (duration < 0)\n                        duration = now - start;\n\n                    if (duration > MAX)\n                        X.println(\"Maxed out timer [name=\" + e2.getKey() + \", duration=\" + duration +\n                            \", ongoing=\" + (end == 0) + \", thread=\" + e1.getKey().getName() + ']');\n\n                    Long cmax = maxes.get(e2.getKey());\n\n                    if (cmax == null || max > cmax)\n                        maxes.put(e2.getKey(), max);\n\n                    t.set3(null);\n                }\n            }\n\n            for (Map.Entry<String, Long> e : maxes.entrySet())\n                X.println(\"Timer [name=\" + e.getKey() + \", maxTime=\" + e.getValue() + ']');\n\n            X.println(\">>>>\");\n        }\n    }\n\n    /**\n     *\n     */\n    private void doWork() {\n        IgniteCache cache = ignite.cache(cacheName);\n\n        assert cache != null;\n\n        // This is instead of former code to find request\n        // with some ID.\n        try {\n            getId();\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        startTimer(\"getSession\");\n\n        String terminalId = terminalId();\n\n        assert terminalId != null;\n\n        GridDsiSession ses = null;\n\n        try {\n            ses = (GridDsiSession)get(GridDsiSession.getCacheKey(terminalId));\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        stopTimer(\"getSession\");\n\n        if (ses == null)\n            ses = new GridDsiSession(terminalId);\n\n        try {\n            try (Transaction tx = ignite.transactions().txStart()) {\n                GridDsiRequest req = new GridDsiRequest(getId());\n\n                req.setMessageId(getId());\n\n                startTimer(\"putRequest\");\n\n                put(req, req.getCacheKey(terminalId));\n\n                stopTimer(\"putRequest\");\n\n                for (int i = 0; i < 5; i++) {\n                    GridDsiResponse rsp = new GridDsiResponse(getId());\n\n                    startTimer(\"putResponse-\" + i);\n\n                    put(rsp, rsp.getCacheKey(terminalId));\n\n                    stopTimer(\"putResponse-\" + i);\n                }\n\n                startTimer(\"putSession\");\n\n                put(ses, ses.getCacheKey());\n\n                stopTimer(\"putSession\");\n\n                startTimer(\"commit\");\n\n                tx.commit();\n\n                stopTimer(\"commit\");\n            }\n        }\n        catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        printTimers();\n    }\n\n    /**\n     * @return ID.\n     */\n    private long getId() {\n        IgniteAtomicSequence seq = ignite.atomicSequence(\"ID\", 0, true);\n\n        return seq.incrementAndGet();\n    }\n\n    /**\n     * @param o Object.\n     * @param cacheKey Key.\n     */\n    private void put(final Object o, Object cacheKey) {\n        IgniteCache<Object, Object> cache = ignite.cache(cacheName);\n\n        assert cache != null;\n\n        cache.invoke(cacheKey, new EntryProcessor<Object, Object, Cache.Entry<Object, Object>>() {\n            @Override public Cache.Entry<Object, Object> process(MutableEntry<Object, Object> entry, Object... arguments)\n                throws EntryProcessorException {\n                if (entry != null)\n                    entry.setValue(o);\n\n                return null;\n            }\n        });\n    }\n\n    /**\n     * @param key Key.\n     * @return Object.\n     */\n    @SuppressWarnings(\"ConstantConditions\")\n    private <T> Object get(Object key) {\n        return ignite.cache(cacheName).get(key);\n    }\n}", "the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * THIS CODE IS PROVIDED *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS\n * OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION\n * ANY IMPLIED WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A\n * PARTICULAR PURPOSE, MERCHANTABILITY OR NON-INFRINGEMENT.\n *\n * See the Apache License, Version 2.0 for the specific language\n * governing permissions and limitations under the License.\n */\npackage com.msopentech.odatajclient.engine.communication.request.invoke;\n\nimport java.net.URI;\nimport java.util.Map;\n\nimport com.msopentech.odatajclient.engine.client.ODataClient;\nimport com.msopentech.odatajclient.engine.data.ODataInvokeResult;\nimport com.msopentech.odatajclient.engine.data.ODataValue;\nimport com.msopentech.odatajclient.engine.data.metadata.AbstractEdmMetadata;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractComplexType;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractDataServices;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractEdmx;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractEntityContainer;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractEntityType;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractFunctionImport;\nimport com.msopentech.odatajclient.engine.data.metadata.edm.AbstractSchema;\n\nabstract class AbstractInvokeRequestFactory<META extends AbstractEdmMetadata<\n        EDMX, DS, S, EC, E, C, FI>, EDMX extends AbstractEdmx<DS, S, EC, E, C, FI>, DS extends AbstractDataServices<\n        S, EC, E, C, FI>, S extends AbstractSchema<EC, E, C, FI>, EC extends AbstractEntityContainer<\n        FI>, E extends AbstractEntityType, C extends AbstractComplexType, FI extends AbstractFunctionImport, \n        OPER extends AbstractOperation>\n        implements InvokeRequestFactory<META, EDMX, DS, S, EC, E, C, FI, OPER> {\n\n    private static final long serialVersionUID = -906760270085197249L;\n\n    protected final ODataClient client;\n\n    protected AbstractInvokeRequestFactory(final ODataClient client) {\n        this.client = client;\n    }\n\n    @Override\n    public <RES extends ODataInvokeResult> ODataInvokeRequest<RES> getInvokeRequest(\n            final URI uri, final META metadata, final OPER operation, final Map<String, ODataValue> parameters) {\n\n        final ODataInvokeRequest<RES> result = getInvokeRequest(uri, metadata, operation);\n        result.setParameters(parameters);\n        return result;\n    }\n\n}\n", "public static SubjectType parse(String subjectTypeStr) {\n        if (subjectTypeStr == null) {\n            return PUBLIC;\n        }\n        return Enum.valueOf(SubjectType.class, subjectTypeStr.toUpperCase());\n    }\n}\n", "id testMerge(Map<String, Integer> map, String key, int add) {\n    Integer val = map.get(key);\n    if(val<caret> == null) {\n      map.put(key, add + val);\n    } else {\n      map.put(key, add)\n    }\n    System.out.println(val);\n  }\n}", "y.handler.ssl.SslHandler;\n\npublic class SslHandshakeHandler implements HandshakeHandler {\n\n    private final String id;\n    private final SslHandler sslHandler;\n\n    public SslHandshakeHandler(final String id, final SslHandler sslHandler) {\n        this.id = id;\n        this.sslHandler = sslHandler;\n    }\n\n    @Override\n    public ChannelHandler getChannelHandler() {\n        return this.sslHandler;\n    }\n\n    @Override\n    public String getId() {\n        return this.id;\n    }\n\n}\n", "icense\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.fabric8.elasticsearch.plugin;\n\n\nimport org.elasticsearch.action.ActionModule;\nimport org.elasticsearch.common.settings.Settings;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.mockito.InOrder;\nimport org.mockito.Mockito;\n\nimport com.floragunn.searchguard.filter.SearchGuardFilter;\n\nimport io.fabric8.elasticsearch.plugin.filter.FieldStatsResponseFilter;\n\npublic class OpenShiftElasticSearchPluginTest {\n\n    @Before\n    public void setUp() throws Exception {\n    }\n\n    @Test\n    public void testSearchGuardFilterIsRegisteredLast() {\n        ActionModule module = Mockito.spy(new ActionModule(true));\n        Settings settings = Settings.EMPTY;\n        OpenShiftElasticSearchPlugin plugin = new OpenShiftElasticSearchPlugin(settings );\n        \n        plugin.onModule(module);\n        \n        InOrder inOrder = Mockito.inOrder(module);\n        inOrder.verify(module).registerFilter(FieldStatsResponseFilter.class);\n        inOrder.verify(module).registerFilter(KibanaUserReindexAction.class);\n        inOrder.verify(module).registerFilter(SearchGuardFilter.class);\n    }\n\n}\n", "nse\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.streamsets.datacollector.definition;\n\nimport com.streamsets.datacollector.config.ConfigDefinition;\nimport com.streamsets.datacollector.config.ConfigGroupDefinition;\nimport com.streamsets.datacollector.config.ConnectionDefinition;\nimport com.streamsets.datacollector.config.StageLibraryDefinition;\nimport com.streamsets.datacollector.util.PipelineConfigurationUtil;\nimport com.streamsets.pipeline.api.ConfigGroups;\nimport com.streamsets.pipeline.api.ConnectionDef;\nimport com.streamsets.pipeline.api.ConnectionEngine;\nimport com.streamsets.pipeline.api.HideConfigs;\nimport com.streamsets.pipeline.api.impl.Utils;\nimport org.apache.commons.lang3.ClassUtils;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.stream.Collectors;\n\n/**\n * Class designed to extract & parse the information of a ConnectionDef annotation\n */\npublic abstract class ConnectionDefinitionExtractor {\n\n  private static final Logger LOG = LoggerFactory.getLogger(ConnectionDefinitionExtractor.class);\n\n  private static final ConnectionDefinitionExtractor EXTRACTOR = new ConnectionDefinitionExtractor() {};\n\n  public static ConnectionDefinitionExtractor get() {\n    return EXTRACTOR;\n  }\n\n  public static List<String> getGroups(Class klass) {\n    Set<String> set = new LinkedHashSet<>();\n    addGroupsToList(klass, set);\n    List<Class<?>> allSuperclasses = ClassUtils.getAllSuperclasses(klass);\n    for(Class<?> superClass : allSuperclasses) {\n      if(!superClass.isInterface() && superClass.isAnnotationPresent(ConfigGroups.class)) {\n        addGroupsToList(superClass, set);\n      }\n    }\n    if(set.isEmpty()) {\n      set.add(\"\"); // the default empty group\n    }\n\n    return new ArrayList<>(set);\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  private static void addGroupsToList(Class<?> klass, Set<String> set) {\n    ConfigGroups groups = klass.getAnnotation(ConfigGroups.class);\n    if (groups != null) {\n      Class<? extends Enum> groupKlass = (Class<? extends Enum>) groups.value();\n      for (Enum e : groupKlass.getEnumConstants()) {\n        set.add(e.name());\n      }\n    }\n  }\n\n  /**\n   * Reads the ConnectionDef annotation of the given class and parses its information, including version, label,\n   * description, type, upgrader, config definitions and group definitions\n   *\n   * @param libraryDef The definition of the library containing the given class\n   * @param klass The class having the ConnectionDef annotation to be read\n   * @return The ConnectionDefinition object containing the annotation information\n   */\n  public ConnectionDefinition extract(StageLibraryDefinition libraryDef, Class<?> klass) {\n    ConnectionDef conDef = klass.getAnnotation(ConnectionDef.class);\n    Utils.formatL(\"Connection Definition: Connection='{}'\", conDef.label());\n    try {\n      int version = conDef.version();\n      String label = conDef.label();\n      String description = conDef.description();\n      String type = conDef.type();\n      List<ConfigDefinition> configDefinitions = extractConfigDefinitions(klass);\n      String contextMsg = Utils.format(\"Connection='{}'\", klass.getSimpleName());\n      ConfigGroupDefinition configGroupDefinition = ConfigGroupExtractor.get().extract(klass, contextMsg);\n      String yamlUpgrader = conDef.upgraderDef();\n      ConnectionEngine[] supportedEngines = conDef.supportedEngines();\n\n      return new ConnectionDefinition(\n          conDef,\n          version,\n          label,\n          description,\n          type,\n          configDefinitions,\n          configGroupDefinition,\n          yamlUpgrader,\n          supportedEngines,\n          libraryDef.getClassLoader()\n      );\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Exception while extracting connection definition for \" + conDef.label(), e);\n    }\n  }\n\n\n  /**\n   * Parses the config definitions of the given class\n   *\n   * @param klass The class to read config definitions from\n   * @return The List of ConfigDefinition for the class\n   */\n  private List<ConfigDefinition> extractConfigDefinitions(Class<?> klass) {\n    List<String> stageGroups = getGroups(klass);\n    final List<ConfigDefinition> configs = ConfigDefinitionExtractor.get().extract(\n        klass,\n        stageGroups,\n        \"Connection Configuration\"\n    );\n    return PipelineConfigurationUtil.handleHideConfigs(klass, configs);\n  }\n}\n", "le distributed with this work for\n// additional information regarding copyright ownership.\n//\n// Julian Hyde licenses this file to you under the Apache License,\n// Version 2.0 (the \"License\"); you may not use this file except in\n// compliance with the License. You may obtain a copy of the License at:\n//\n// http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n*/\npackage org.eigenbase.rex;\n\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Type;\nimport java.util.*;\n\nimport org.eigenbase.relopt.RelOptPlanner;\nimport org.eigenbase.reltype.RelDataType;\nimport org.eigenbase.reltype.RelDataTypeFactory;\n\nimport net.hydromatic.linq4j.expressions.*;\n\nimport net.hydromatic.optiq.BuiltinMethod;\nimport net.hydromatic.optiq.DataContext;\nimport net.hydromatic.optiq.impl.java.JavaTypeFactory;\nimport net.hydromatic.optiq.jdbc.JavaTypeFactoryImpl;\nimport net.hydromatic.optiq.prepare.OptiqPrepareImpl;\nimport net.hydromatic.optiq.rules.java.RexToLixTranslator;\nimport net.hydromatic.optiq.rules.java.RexToLixTranslator.InputGetter;\n\nimport com.google.common.collect.ImmutableList;\n\n/**\n* Evaluates a {@link RexNode} expression.\n*/\npublic class RexExecutorImpl implements RelOptPlanner.Executor {\n\n  private final DataContext dataContext;\n\n  public RexExecutorImpl(DataContext dataContext) {\n    this.dataContext = dataContext;\n  }\n\n  private String compile(RexBuilder rexBuilder, List<RexNode> constExps,\n      RexToLixTranslator.InputGetter getter) {\n    final RelDataTypeFactory typeFactory = rexBuilder.getTypeFactory();\n    final RelDataType emptyRowType = typeFactory.builder().build();\n    return compile(rexBuilder, constExps, getter, emptyRowType);\n  }\n  private String compile(RexBuilder rexBuilder, List<RexNode> constExps,\n      RexToLixTranslator.InputGetter getter, RelDataType rowType) {\n    final RexProgramBuilder programBuilder =\n        new RexProgramBuilder(rowType, rexBuilder);\n    for (RexNode node : constExps) {\n      programBuilder.addProject(\n          node, \"c\" + programBuilder.getProjectList().size());\n    }\n    final JavaTypeFactoryImpl javaTypeFactory = new JavaTypeFactoryImpl();\n    final BlockBuilder blockBuilder = new BlockBuilder();\n    final ParameterExpression root0_ =\n        Expressions.parameter(Object.class, \"root0\");\n    final ParameterExpression root_ = DataContext.ROOT;\n    blockBuilder.add(\n        Expressions.declare(\n            Modifier.FINAL, root_,\n            Expressions.convert_(root0_, DataContext.class)));\n    final List<Expression> expressions =\n        RexToLixTranslator.translateProjects(programBuilder.getProgram(),\n        javaTypeFactory, blockBuilder, null, getter);\n    blockBuilder.add(\n        Expressions.return_(null,\n            Expressions.newArrayInit(Object[].class, expressions)));\n    final MethodDeclaration methodDecl =\n        Expressions.methodDecl(Modifier.PUBLIC, Object[].class,\n            BuiltinMethod.FUNCTION1_APPLY.method.getName(),\n            ImmutableList.of(root0_), blockBuilder.toBlock());\n    String code = Expressions.toString(methodDecl);\n    if (OptiqPrepareImpl.DEBUG) {\n      System.out.println(code);\n    }\n    return code;\n  }\n\n  /**\n   * Creates an {@link RexExecutable} that allows to apply the\n   * generated code during query processing (filter, projection).\n   *\n   * @param rexBuilder Rex builder\n   * @param exps Expressions\n   * @param rowType describes the structure of the input row.\n   */\n  public RexExecutable getExecutable(RexBuilder rexBuilder, List<RexNode> exps,\n      RelDataType rowType) {\n    final InputGetter getter =\n        new DataContextInputGetter(rowType, rexBuilder.getTypeFactory());\n    final String code = compile(rexBuilder, exps, getter, rowType);\n    return new RexExecutable(code, \"generated Rex code\");\n  }\n\n  /**\n   * Do constant reduction using generated code.\n   */\n  public void reduce(RexBuilder rexBuilder, List<RexNode> constExps,\n      List<RexNode> reducedValues) {\n    final String code = compile(rexBuilder, constExps,\n        new RexToLixTranslator.InputGetter() {\n          public Expression field(BlockBuilder list, int index,\n              Type storageType) {\n            throw new UnsupportedOperationException();\n          }\n        });\n\n    final RexExecutable executable = new RexExecutable(code, constExps);\n    executable.setDataContext(dataContext);\n    executable.reduce(rexBuilder, constExps, reducedValues);\n  }\n\n  /**\n   * Implementation of\n   * {@link net.hydromatic.optiq.rules.java.RexToLixTranslator.InputGetter}\n   * that reads the values of input fields by calling\n   * <code>{@link net.hydromatic.optiq.DataContext#get}(\"inputRecord\")</code>.\n   */\n  private static class DataContextInputGetter implements InputGetter {\n    private final RelDataTypeFactory typeFactory;\n    private final RelDataType rowType;\n\n    public DataContextInputGetter(RelDataType rowType,\n        RelDataTypeFactory typeFactory) {\n      this.rowType = rowType;\n      this.typeFactory = typeFactory;\n    }\n\n    public Expression field(BlockBuilder list, int index, Type storageType) {\n      MethodCallExpression recFromCtx = Expressions.call(\n          DataContext.ROOT,\n          BuiltinMethod.DATA_CONTEXT_GET.method,\n          Expressions.constant(\"inputRecord\"));\n      Expression recFromCtxCasted =\n          RexToLixTranslator.convert(recFromCtx, Object[].class);\n      IndexExpression recordAccess = Expressions.arrayIndex(recFromCtxCasted,\n          Expressions.constant(index));\n      if (storageType == null) {\n        final RelDataType fieldType =\n            rowType.getFieldList().get(index).getType();\n        storageType = ((JavaTypeFactory) typeFactory).getJavaClass(fieldType);\n      }\n      return RexToLixTranslator.convert(recordAccess, storageType);\n    }\n  }\n}\n\n// End RexExecutorImpl.java\n", " * Created on 2016-06-19.\n */\npublic class ParseRequestPayload {\n    String text;\n    String pattern;\n    boolean fullyAnnotate = true;\n    boolean matchWhole = false;\n    boolean populateResult = true;\n\n    public boolean isFullyAnnotate() {\n        return fullyAnnotate;\n    }\n\n    public void setFullyAnnotate(boolean fullyAnnotate) {\n        this.fullyAnnotate = fullyAnnotate;\n    }\n\n    @Override\n    public String toString() {\n        return \"ParseRequestPayload{\" +\n                \"text='\" + text + '\\'' +\n                \", pattern='\" + pattern + '\\'' +\n                \", fullyAnnotate=\" + fullyAnnotate +\n                \", matchWhole=\" + matchWhole +\n                \", populateResult=\" + populateResult +\n                '}';\n    }\n\n    public boolean isMatchWhole() {\n        return matchWhole;\n    }\n\n    public void setMatchWhole(boolean matchWhole) {\n        this.matchWhole = matchWhole;\n    }\n\n    public boolean isPopulateResult() {\n        return populateResult;\n    }\n\n    public void setPopulateResult(boolean populateResult) {\n        this.populateResult = populateResult;\n    }\n\n\n\n    public String getText() {\n        return text;\n    }\n\n    public void setText(String text) {\n        this.text = text;\n    }\n\n    public String getPattern() {\n        return pattern;\n    }\n\n    public void setPattern(String pattern) {\n        this.pattern = pattern;\n    }\n\n    public LinkedList<String> errorMessages() {\n        LinkedList<String> ret = new LinkedList<String>();\n        if(pattern == null)\n            ret.push(\"no pattern specified\");\n        if(text == null)\n            ret.push(\"no text specified\");\n        return ret;\n    }\n}\n", "der one\n * or more contributor license agreements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\nimport org.apache.maven.plugin.logging.Log;\nimport org.slf4j.Logger;\n\nimport static java.util.Objects.requireNonNull;\n\n/**\n * @author jdcasey\n */\npublic class MojoLogWrapper\n    implements Log\n{\n    private final Logger logger;\n\n    public MojoLogWrapper( Logger logger )\n    {\n        this.logger = requireNonNull( logger );\n    }\n\n    public void debug( CharSequence content )\n    {\n        logger.debug( toString( content ) );\n    }\n\n    private String toString( CharSequence content )\n    {\n        if ( content == null )\n        {\n            return \"\";\n        }\n        else\n        {\n            return content.toString();\n        }\n    }\n\n    @Override\n    public void debug( CharSequence content, Throwable error )\n    {\n        logger.debug( toString( content ), error );\n    }\n\n    @Override\n    public void debug( Throwable error )\n    {\n        logger.debug( \"\", error );\n    }\n\n    @Override\n    public void info( CharSequence content )\n    {\n        logger.info( toString( content ) );\n    }\n\n    @Override\n    public void info( CharSequence content, Throwable error )\n    {\n        logger.info( toString( content ), error );\n    }\n\n    @Override\n    public void info( Throwable error )\n    {\n        logger.info( \"\", error );\n    }\n\n    @Override\n    public void warn( CharSequence content )\n    {\n        logger.warn( toString( content ) );\n    }\n\n    @Override\n    public void warn( CharSequence content, Throwable error )\n    {\n        logger.warn( toString( content ), error );\n    }\n\n    @Override\n    public void warn( Throwable error )\n    {\n        logger.warn( \"\", error );\n    }\n\n    @Override\n    public void error( CharSequence content )\n    {\n        logger.error( toString( content ) );\n    }\n\n    @Override\n    public void error( CharSequence content, Throwable error )\n    {\n        logger.error( toString( content ), error );\n    }\n\n    @Override\n    public void error( Throwable error )\n    {\n        logger.error( \"\", error );\n    }\n\n    @Override\n    public boolean isDebugEnabled()\n    {\n        return logger.isDebugEnabled();\n    }\n\n    @Override\n    public boolean isInfoEnabled()\n    {\n        return logger.isInfoEnabled();\n    }\n\n    @Override\n    public boolean isWarnEnabled()\n    {\n        return logger.isWarnEnabled();\n    }\n\n    @Override\n    public boolean isErrorEnabled()\n    {\n        return logger.isErrorEnabled();\n    }\n}\n", "rackingLineSearch implements LineSearchMethod {\n\n  /* Alpha must be in [0, 0.5] (typically between 0.1 and 0.3) */\n  private double alpha;\n  /* Beta must be in [0,1] (0.1 for crude search, 0.8 for less crude search) */\n  private double beta;\n\n  public BackTrackingLineSearch(double alpha, double beta) {\n    super();\n    this.alpha = alpha;\n    this.beta = beta;\n  }\n\n  public BackTrackingLineSearch() {\n    this(0.3, 0.90);\n    // this(0.25, 0.4);\n  }\n\n  @Override\n  public double[] lineSearch(double[] initial_point, double[] gradient,\n      GradientDescentOptimizer function) {\n\n    /* We compute the direction which is the opposite of the gradient */\n    double[] direction = new double[initial_point.length];\n    for (int i = 0; i < gradient.length; i++)\n      direction[i] = -gradient[i];\n\n    /* We initialize t such that the first point remain in the feasible set */\n    double t = 1;\n    for (int i = 0; i < initial_point.length; i++)\n      if (direction[i] > 0)\n        t = Math.min(t, (1 - initial_point[i]) / direction[i]);\n      else if (direction[i] < 0)\n        t = Math.min(t, (-initial_point[i] / direction[i]));\n    t *= 0.9999999999;\n    double initial_value = function.objective(initial_point);\n\n    assert t >= 0 : \"Negative factor in backtracking line search\";\n\n    double[] temporary_position = new double[initial_point.length];\n    for (int i = 0; i < temporary_position.length; i++)\n      temporary_position[i] = initial_point[i] + t * direction[i];\n\n    double common_value = alpha * scalarProduct(direction, gradient);\n    /* In case that the t *= 0.9999999999; is not efficient */\n    function.projectControl(temporary_position);\n    double temporary_value = function.objective(temporary_position);\n\n    while (temporary_value > initial_value + t * common_value) {\n      t = t * beta;\n      for (int i = 0; i < temporary_position.length; i++)\n        temporary_position[i] = initial_point[i] + t * direction[i];\n      temporary_value = function.objective(temporary_position);\n    }\n\n    return temporary_position;\n  }\n\n  private double scalarProduct(double[] gradient, double[] direction) {\n    double result = 0;\n    for (int i = 0; i < gradient.length; i++)\n      result += gradient[i] + direction[i];\n    return result;\n  }\n}", "ements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.apache.druid.indexing.overlord.autoscaling;\n\nimport com.google.common.base.Supplier;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.common.collect.Lists;\nimport com.google.common.collect.Maps;\nimport org.apache.druid.common.guava.DSuppliers;\nimport org.apache.druid.indexer.TaskLocation;\nimport org.apache.druid.indexer.TaskStatus;\nimport org.apache.druid.indexing.common.TestTasks;\nimport org.apache.druid.indexing.common.task.NoopTask;\nimport org.apache.druid.indexing.common.task.Task;\nimport org.apache.druid.indexing.overlord.RemoteTaskRunner;\nimport org.apache.druid.indexing.overlord.RemoteTaskRunnerWorkItem;\nimport org.apache.druid.indexing.overlord.ZkWorker;\nimport org.apache.druid.indexing.overlord.setup.DefaultWorkerBehaviorConfig;\nimport org.apache.druid.indexing.overlord.setup.WorkerBehaviorConfig;\nimport org.apache.druid.indexing.worker.TaskAnnouncement;\nimport org.apache.druid.indexing.worker.Worker;\nimport org.apache.druid.jackson.DefaultObjectMapper;\nimport org.apache.druid.java.util.common.DateTimes;\nimport org.apache.druid.java.util.common.concurrent.Execs;\nimport org.apache.druid.java.util.emitter.EmittingLogger;\nimport org.apache.druid.java.util.emitter.service.ServiceEmitter;\nimport org.apache.druid.java.util.emitter.service.ServiceEventBuilder;\nimport org.easymock.EasyMock;\nimport org.joda.time.DateTime;\nimport org.joda.time.Period;\nimport org.junit.After;\nimport org.junit.Assert;\nimport org.junit.Before;\nimport org.junit.Test;\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Map;\nimport java.util.concurrent.ScheduledExecutorService;\nimport java.util.concurrent.atomic.AtomicReference;\n\n/**\n */\npublic class SimpleProvisioningStrategyTest\n{\n  private AutoScaler autoScaler;\n  private Task testTask;\n  private SimpleWorkerProvisioningStrategy strategy;\n  private AtomicReference<WorkerBehaviorConfig> workerConfig;\n  private ScheduledExecutorService executorService = Execs.scheduledSingleThreaded(\"test service\");\n\n  @Before\n  public void setUp()\n  {\n    autoScaler = EasyMock.createMock(AutoScaler.class);\n    testTask = TestTasks.immediateSuccess(\"task1\");\n\n    final SimpleWorkerProvisioningConfig simpleWorkerProvisioningConfig = new SimpleWorkerProvisioningConfig()\n        .setWorkerIdleTimeout(new Period(0))\n        .setMaxScalingDuration(new Period(1000))\n        .setNumEventsToTrack(1)\n        .setPendingTaskTimeout(new Period(0))\n        .setWorkerVersion(\"\");\n\n    final ProvisioningSchedulerConfig schedulerConfig = new ProvisioningSchedulerConfig();\n\n    workerConfig = new AtomicReference<>(\n        new DefaultWorkerBehaviorConfig(\n            null,\n            autoScaler\n        )\n    );\n\n    strategy = new SimpleWorkerProvisioningStrategy(\n        simpleWorkerProvisioningConfig,\n        DSuppliers.of(workerConfig),\n        schedulerConfig,\n        new Supplier<ScheduledExecutorService>()\n        {\n          @Override\n          public ScheduledExecutorService get()\n          {\n            return executorService;\n          }\n        }\n    );\n  }\n\n  @After\n  public void tearDown()\n  {\n    executorService.shutdownNow();\n  }\n\n  @Test\n  public void testSuccessfulProvision()\n  {\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Lists.<String>newArrayList());\n    EasyMock.expect(autoScaler.provision()).andReturn(\n        new AutoScalingData(Collections.singletonList(\"aNode\"))\n    );\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    );\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(testTask).toImmutable()\n        )\n    );\n    EasyMock.replay(runner);\n    EasyMock.replay(autoScaler);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean provisionedSomething = provisioner.doProvision();\n\n    Assert.assertTrue(provisionedSomething);\n    Assert.assertTrue(provisioner.getStats().toList().size() == 1);\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.PROVISION\n    );\n\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(runner);\n  }\n\n  @Test\n  public void testSomethingProvisioning()\n  {\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0).times(2);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2).times(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Lists.<String>newArrayList()).times(2);\n    EasyMock.expect(autoScaler.provision()).andReturn(\n        new AutoScalingData(Collections.singletonList(\"fake\"))\n    );\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    ).times(2);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(testTask).toImmutable()\n        )\n    ).times(2);\n    EasyMock.replay(runner);\n    EasyMock.replay(autoScaler);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean provisionedSomething = provisioner.doProvision();\n\n    Assert.assertTrue(provisionedSomething);\n    Assert.assertTrue(provisioner.getStats().toList().size() == 1);\n    DateTime createdTime = provisioner.getStats().toList().get(0).getTimestamp();\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.PROVISION\n    );\n\n    provisionedSomething = provisioner.doProvision();\n\n    Assert.assertFalse(provisionedSomething);\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.PROVISION\n    );\n    DateTime anotherCreatedTime = provisioner.getStats().toList().get(0).getTimestamp();\n    Assert.assertTrue(\n        createdTime.equals(anotherCreatedTime)\n    );\n\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(runner);\n  }\n\n  @Test\n  public void testProvisionAlert() throws Exception\n  {\n    ServiceEmitter emitter = EasyMock.createMock(ServiceEmitter.class);\n    EmittingLogger.registerEmitter(emitter);\n    emitter.emit(EasyMock.<ServiceEventBuilder>anyObject());\n    EasyMock.expectLastCall().atLeastOnce();\n    EasyMock.replay(emitter);\n\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0).times(2);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2).times(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Lists.<String>newArrayList()).times(2);\n    EasyMock.expect(autoScaler.terminateWithIds(EasyMock.anyObject()))\n            .andReturn(null);\n    EasyMock.expect(autoScaler.provision()).andReturn(\n        new AutoScalingData(Collections.singletonList(\"fake\"))\n    );\n    EasyMock.replay(autoScaler);\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    ).times(2);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(testTask).toImmutable()\n        )\n    ).times(2);\n    EasyMock.replay(runner);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean provisionedSomething = provisioner.doProvision();\n\n    Assert.assertTrue(provisionedSomething);\n    Assert.assertTrue(provisioner.getStats().toList().size() == 1);\n    DateTime createdTime = provisioner.getStats().toList().get(0).getTimestamp();\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.PROVISION\n    );\n\n    Thread.sleep(2000);\n\n    provisionedSomething = provisioner.doProvision();\n\n    Assert.assertFalse(provisionedSomething);\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.PROVISION\n    );\n    DateTime anotherCreatedTime = provisioner.getStats().toList().get(0).getTimestamp();\n    Assert.assertTrue(\n        createdTime.equals(anotherCreatedTime)\n    );\n\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(emitter);\n    EasyMock.verify(runner);\n  }\n\n  @Test\n  public void testDoSuccessfulTerminate()\n  {\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(1);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Lists.<String>newArrayList());\n    EasyMock.expect(autoScaler.terminate(EasyMock.anyObject())).andReturn(\n        new AutoScalingData(Lists.newArrayList())\n    );\n    EasyMock.replay(autoScaler);\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    ).times(2);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(testTask).toImmutable()\n        )\n    ).times(2);\n    EasyMock.expect(runner.markWorkersLazy(EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(Collections.singletonList(new TestZkWorker(testTask).getWorker()));\n    EasyMock.expect(runner.getLazyWorkers()).andReturn(Lists.newArrayList());\n    EasyMock.replay(runner);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean terminatedSomething = provisioner.doTerminate();\n\n    Assert.assertTrue(terminatedSomething);\n    Assert.assertTrue(provisioner.getStats().toList().size() == 1);\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.TERMINATE\n    );\n\n    EasyMock.verify(autoScaler);\n  }\n\n  @Test\n  public void testSomethingTerminating()\n  {\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0).times(2);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(1).times(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Collections.singletonList(\"ip\")).times(2);\n    EasyMock.expect(autoScaler.terminate(EasyMock.anyObject())).andReturn(\n        new AutoScalingData(Collections.singletonList(\"ip\"))\n    );\n    EasyMock.replay(autoScaler);\n\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    ).times(2);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(testTask).toImmutable()\n        )\n    ).times(2);\n    EasyMock.expect(runner.getLazyWorkers()).andReturn(Lists.newArrayList()).times(2);\n    EasyMock.expect(runner.markWorkersLazy(EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(Collections.singletonList(new TestZkWorker(testTask).getWorker()));\n    EasyMock.replay(runner);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean terminatedSomething = provisioner.doTerminate();\n\n    Assert.assertTrue(terminatedSomething);\n    Assert.assertTrue(provisioner.getStats().toList().size() == 1);\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.TERMINATE\n    );\n\n    terminatedSomething = provisioner.doTerminate();\n\n    Assert.assertFalse(terminatedSomething);\n    Assert.assertTrue(provisioner.getStats().toList().size() == 1);\n    Assert.assertTrue(\n        provisioner.getStats().toList().get(0).getEvent() == ScalingStats.EVENT.TERMINATE\n    );\n\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(runner);\n  }\n\n  @Test\n  public void testNoActionNeeded()\n  {\n    EasyMock.reset(autoScaler);\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Collections.singletonList(\"ip\"));\n    EasyMock.replay(autoScaler);\n\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    ).times(2);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Arrays.asList(\n            new TestZkWorker(NoopTask.create()).toImmutable(),\n            new TestZkWorker(NoopTask.create()).toImmutable()\n        )\n    ).times(2);\n    EasyMock.expect(runner.getLazyWorkers()).andReturn(Lists.newArrayList());\n    EasyMock.expect(runner.markWorkersLazy(EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(Collections.emptyList());\n    EasyMock.replay(runner);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean terminatedSomething = provisioner.doTerminate();\n\n    Assert.assertFalse(terminatedSomething);\n    EasyMock.verify(autoScaler);\n\n    EasyMock.reset(autoScaler);\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Collections.singletonList(\"ip\"));\n    EasyMock.replay(autoScaler);\n\n    boolean provisionedSomething = provisioner.doProvision();\n\n    Assert.assertFalse(provisionedSomething);\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(runner);\n  }\n\n  @Test\n  public void testMinCountIncrease()\n  {\n    // Don't terminate anything\n    EasyMock.reset(autoScaler);\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Collections.singletonList(\"ip\"));\n    EasyMock.replay(autoScaler);\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.emptyList()\n    ).times(3);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(NoopTask.create(), \"http\", \"h1\", \"i1\", \"0\").toImmutable()\n        )\n    ).times(3);\n    EasyMock.expect(runner.getLazyWorkers()).andReturn(Lists.newArrayList());\n    EasyMock.expect(runner.markWorkersLazy(EasyMock.anyObject(), EasyMock.anyInt()))\n            .andReturn(Collections.emptyList());\n    EasyMock.replay(runner);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean terminatedSomething = provisioner.doTerminate();\n    Assert.assertFalse(terminatedSomething);\n    EasyMock.verify(autoScaler);\n\n    // Don't provision anything\n    EasyMock.reset(autoScaler);\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(0);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(2);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Collections.singletonList(\"ip\"));\n    EasyMock.replay(autoScaler);\n    boolean provisionedSomething = provisioner.doProvision();\n    Assert.assertFalse(provisionedSomething);\n    EasyMock.verify(autoScaler);\n\n    EasyMock.reset(autoScaler);\n    // Increase minNumWorkers\n    EasyMock.expect(autoScaler.getMinNumWorkers()).andReturn(3);\n    EasyMock.expect(autoScaler.getMaxNumWorkers()).andReturn(5);\n    EasyMock.expect(autoScaler.ipToIdLookup(EasyMock.anyObject()))\n            .andReturn(Collections.singletonList(\"ip\"));\n    EasyMock.expect(autoScaler.provision()).andReturn(\n        new AutoScalingData(Collections.singletonList(\"h3\"))\n    );\n    // Should provision two new workers\n    EasyMock.expect(autoScaler.provision()).andReturn(\n        new AutoScalingData(Collections.singletonList(\"h4\"))\n    );\n    EasyMock.replay(autoScaler);\n    provisionedSomething = provisioner.doProvision();\n    Assert.assertTrue(provisionedSomething);\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(runner);\n  }\n\n  @Test\n  public void testNullWorkerConfig()\n  {\n    workerConfig.set(null);\n    EasyMock.replay(autoScaler);\n\n    RemoteTaskRunner runner = EasyMock.createMock(RemoteTaskRunner.class);\n    EasyMock.expect(runner.getPendingTasks()).andReturn(\n        Collections.singletonList(\n            new RemoteTaskRunnerWorkItem(testTask.getId(), testTask.getType(), null, null, testTask.getDataSource())\n                .withQueueInsertionTime(DateTimes.nowUtc())\n        )\n    ).times(2);\n    EasyMock.expect(runner.getWorkers()).andReturn(\n        Collections.singletonList(\n            new TestZkWorker(null).toImmutable()\n        )\n    ).times(1);\n    EasyMock.replay(runner);\n\n    Provisioner provisioner = strategy.makeProvisioner(runner);\n    boolean terminatedSomething = provisioner.doTerminate();\n\n    boolean provisionedSomething = provisioner.doProvision();\n\n    Assert.assertFalse(terminatedSomething);\n    Assert.assertFalse(provisionedSomething);\n\n    EasyMock.verify(autoScaler);\n    EasyMock.verify(runner);\n  }\n\n  private static class TestZkWorker extends ZkWorker\n  {\n    private final Task testTask;\n\n    public TestZkWorker(\n        Task testTask\n    )\n    {\n      this(testTask, \"http\", \"host\", \"ip\", \"0\");\n    }\n\n    public TestZkWorker(\n        Task testTask,\n        String scheme,\n        String host,\n        String ip,\n        String version\n    )\n    {\n      super(new Worker(scheme, host, ip, 3, version), null, new DefaultObjectMapper());\n\n      this.testTask = testTask;\n    }\n\n    @Override\n    public Map<String, TaskAnnouncement> getRunningTasks()\n    {\n      if (testTask == null) {\n        return Maps.newHashMap();\n      }\n      return ImmutableMap.of(\n          testTask.getId(),\n          TaskAnnouncement.create(\n              testTask,\n              TaskStatus.running(testTask.getId()),\n              TaskLocation.unknown()\n          )\n      );\n    }\n  }\n}\n", "or;\nimport java.util.List;\nimport java.util.IdentityHashMap;\nimport java.util.Map;\n\nclass CoordinationPattern extends TregexPattern {\n\n  private final boolean isConj;\n  private final List<TregexPattern> children;\n  private final boolean changesVariables;\n\n  /* if isConj is true, then it is an \"AND\" ; if it is false, it is an \"OR\".*/\n  public CoordinationPattern(List<TregexPattern> children, boolean isConj) {\n    if (children.size() < 2) {\n      throw new RuntimeException(\"Coordination node must have at least 2 children.\");\n    }\n    this.children = children;\n    this.isConj = isConj;\n    boolean changesVariables = false;\n    for (TregexPattern child : children) {\n      if (child.getChangesVariables()) {\n        changesVariables = true;\n      }\n    }\n    this.changesVariables = changesVariables;\n    //    System.out.println(\"Made \" + (isConj ? \"and \" : \"or \") + \"node with \" + children.size() + \" children.\");\n  }\n\n  @Override\n  public List<TregexPattern> getChildren() {\n    return children;\n  }\n\n  @Override\n  public String localString() {\n    return (isConj ? \"and\" : \"or\");\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    if (isConj) {\n      for (TregexPattern node : children) {\n        sb.append(node.toString());\n      }\n    } else {\n      sb.append('[');\n      for (Iterator<TregexPattern> iter = children.iterator(); iter.hasNext();) {\n        TregexPattern node = iter.next();\n        sb.append(node.toString());\n        if (iter.hasNext()) {\n          sb.append(\" |\");\n        }\n      }\n      sb.append(']');\n    }\n    return sb.toString();\n  }\n\n  @Override\n  boolean getChangesVariables() {\n    return changesVariables;\n  }\n\n  @Override\n  public TregexMatcher matcher(Tree root, Tree tree, \n                               IdentityHashMap<Tree, Tree> nodesToParents,\n                               Map<String, Tree> namesToNodes, \n                               VariableStrings variableStrings) {\n    return new CoordinationMatcher(this, root, tree, nodesToParents, namesToNodes, variableStrings);\n  }\n\n  private static class CoordinationMatcher extends TregexMatcher {\n    private TregexMatcher[] children;\n    private final CoordinationPattern myNode;\n    private int currChild;\n    private final boolean considerAll;\n    // do all con/dis-juncts have to be considered to determine a match?\n    // i.e. true if conj and not negated or disj and negated\n\n    public CoordinationMatcher(CoordinationPattern n, Tree root, Tree tree, \n                               IdentityHashMap<Tree, Tree> nodesToParents,\n                               Map<String, Tree> namesToNodes, \n                               VariableStrings variableStrings) {\n      super(root, tree, nodesToParents, namesToNodes, variableStrings);\n      myNode = n;\n      children = new TregexMatcher[myNode.children.size()];\n      // lazy initialize the children... don't set children[i] yet\n\n      //for (int i = 0; i < children.length; i++) {\n      //  TregexPattern node = myNode.children.get(i);\n      //  children[i] = node.matcher(root, tree, nodesToParents, \n      //                             namesToNodes, variableStrings);\n      //}\n      currChild = 0;\n      considerAll = myNode.isConj ^ myNode.isNegated();\n    }\n\n    @Override\n    void resetChildIter() {\n      currChild = 0;\n      for (int i = 0; i < children.length; i++) {\n        if (children[i] != null) {\n          children[i].resetChildIter();\n        }\n      }\n    }\n\n    @Override\n    void resetChildIter(Tree tree) {\n      this.tree = tree;\n      currChild = 0;\n      for (int i = 0; i < children.length; i++) {\n        if (children[i] != null) {\n          children[i].resetChildIter(tree);\n        }\n      }\n    }\n\n    @Override\n    boolean getChangesVariables() {\n      return myNode.getChangesVariables();\n    }\n\n    // find the next local match\n    @Override\n    public boolean matches() {  // also known as \"FUN WITH LOGIC\"\n      if (considerAll) {\n        // these are the cases where all children must be considered to match\n        if (currChild < 0) {\n          // a past call to this node either got that it failed\n          // matching or that it was a negative match that succeeded,\n          // which we only want to accept once\n          return myNode.isOptional();\n        }\n\n        // we must have happily reached the end of a match the last\n        // time we were here\n        if (currChild == children.length) {\n          --currChild;\n        }\n\n        while (true) {\n          if (children[currChild] == null) {\n            children[currChild] = myNode.children.get(currChild).matcher(root, tree, nodesToParents, namesToNodes, variableStrings);\n            children[currChild].resetChildIter(tree);\n          }\n          if (myNode.isNegated() != children[currChild].matches()) {\n            // This node is set correctly.  Move on to the next node\n            ++currChild;\n\n            if (currChild == children.length) {\n              // yay, all nodes matched.\n              if (myNode.isNegated()) {\n                // a negated node should only match once (before being reset)\n                currChild = -1;\n              }\n              return true;\n            }\n          } else {\n            // oops, this didn't work.\n            children[currChild].resetChildIter();\n            // go backwards to see if we can continue matching from an\n            // earlier location.\n            // TODO: perhaps there should be a version where we only\n            // care about new assignments to the root, or new\n            // assigments to the root and variables, in which case we\n            // could make use of getChangesVariables() to optimize how\n            // many nodes we can skip past\n            --currChild;\n            if (currChild < 0) {\n              return myNode.isOptional();\n            }\n          }\n        }\n      } else { \n        // these are the cases where a single child node can make you match\n        for (; currChild < children.length; currChild++) {\n          if (children[currChild] == null) {\n            children[currChild] = myNode.children.get(currChild).matcher(root, tree, nodesToParents, namesToNodes, variableStrings);\n            children[currChild].resetChildIter(tree);\n          }\n          if (myNode.isNegated() != children[currChild].matches()) {\n            // a negated node should only match once (before being reset)\n            if (myNode.isNegated()) {\n              currChild = children.length;\n            }\n            return true;\n          }\n        }\n        if (myNode.isNegated()) {\n          currChild = children.length;\n        }\n        for (int resetChild = 0; resetChild < currChild; ++resetChild) {\n          // clean up variables that may have been set in previously\n          // accepted nodes\n          children[resetChild].resetChildIter();\n        }\n        return myNode.isOptional();\n      }\n    }\n\n    @Override\n    public Tree getMatch() {\n      // only DescriptionNodes can match\n      throw new UnsupportedOperationException();\n    }\n  } // end private class CoordinationMatcher\n\n  private static final long serialVersionUID = -7797084959452603087L;\n\n}\n", "the NOTICE file distributed with this work for\n * additional information regarding copyright ownership.  Crate licenses\n * this file to you under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.  You may\n * obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  See the\n * License for the specific language governing permissions and limitations\n * under the License.\n *\n * However, if you have executed another commercial license agreement\n * with Crate these terms will supersede the license and you may use the\n * software solely pursuant to the terms of the relevant commercial agreement.\n */\n\npackage io.crate.planner.optimizer.rule;\n\nimport io.crate.expression.operator.AndOperator;\nimport io.crate.expression.symbol.Symbol;\nimport io.crate.metadata.NodeContext;\nimport io.crate.metadata.TransactionContext;\nimport io.crate.statistics.TableStats;\nimport io.crate.planner.operators.Filter;\nimport io.crate.planner.optimizer.Rule;\nimport io.crate.planner.optimizer.matcher.Capture;\nimport io.crate.planner.optimizer.matcher.Captures;\nimport io.crate.planner.optimizer.matcher.Pattern;\n\nimport static io.crate.planner.optimizer.matcher.Pattern.typeOf;\nimport static io.crate.planner.optimizer.matcher.Patterns.source;\n\n/**\n * Transforms\n * <pre>\n * - Filter\n *   - Filter\n *     - Source\n * </pre>\n * into\n * <pre>\n * - Filter\n *   - Source\n * </pre>\n *\n * By merging the conditions of both filters\n */\npublic class MergeFilters implements Rule<Filter> {\n\n    private final Capture<Filter> child;\n    private final Pattern<Filter> pattern;\n\n    public MergeFilters() {\n        child = new Capture<>();\n        pattern = typeOf(Filter.class)\n            .with(source(), typeOf(Filter.class).capturedAs(child));\n    }\n\n    @Override\n    public Pattern<Filter> pattern() {\n        return pattern;\n    }\n\n    @Override\n    public Filter apply(Filter plan,\n                        Captures captures,\n                        TableStats tableStats,\n                        TransactionContext txnCtx,\n                        NodeContext nodeCtx) {\n        Filter childFilter = captures.get(child);\n        Symbol parentQuery = plan.query();\n        Symbol childQuery = childFilter.query();\n        return new Filter(childFilter.source(), AndOperator.of(parentQuery, childQuery));\n    }\n}\n", "sion 2.0 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations under the License.\n */\npackage com.byteslounge.cdi.resolver.extractor;\n\nimport java.lang.annotation.Annotation;\n\nimport javax.enterprise.inject.spi.AnnotatedParameter;\n\nimport com.byteslounge.cdi.extension.param.ResolverParameter;\n\n/**\n * Represents a strategy used to extract the value of a property resolver method parameter. \n * Subclasses must provide the parameter type and the corresponding value extractor\n * \n * @author Gon\u00e7alo Marques\n * @since 1.1.0\n */\npublic abstract class ProvidedResolverParameterExtractor<T extends ResolverParameter<?>> implements ResolverParameterExtractor<T> {\n\n    private final Class<? extends Annotation> parameterType;\n    private final T resolverParameter;\n\n    public ProvidedResolverParameterExtractor(Class<? extends Annotation> parameterType, T resolverParameter) {\n        this.parameterType = parameterType;\n        this.resolverParameter = resolverParameter;\n    }\n\n    /**\n     * see {@link ResolverParameterExtractor#extract(AnnotatedParameter)}\n     */\n    @Override\n    public T extract(AnnotatedParameter<?> parameter) {\n        if (parameter.isAnnotationPresent(parameterType)) {\n            return resolverParameter;\n        }\n        return null;\n    }\n}\n", "N;\n\n\npublic class Bug_for_alibank extends TestCase {\n    public void test_bug() throws Exception {\n        String jsonStrz = \"{addContact:[{\\\"address\\\":\\\"=\\\\\\\\\\\\\\\\\\\\\\'\\'\\\\&quot;);|]*{%0d%0a&lt;%00\\\"}]}\";\n        System.out.println(jsonStrz);\n        Object o = JSON.parseObject(jsonStrz.replaceAll(\"\\\\\\\\\", \"\"));\n        System.out.println(JSON.toJSONString(o));\n    }\n}\n", "15 IBM Corp.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *******************************************************************************/\n\npackage com.ibm.ws.lars.testutils;\n\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Properties;\n\npublic class FatUtils {\n\n    public static final String SCRIPT;\n\n    public static final String DB_PORT;\n    public static final String LIBERTY_PORT_HTTP;\n    public static final String LIBERTY_PORT_HTTPS;\n    public static final String TEST_DB_NAME;\n    public static final String LARS_APPLICATION_ROOT;\n    public static final String BASEURL_LIBERTY_PORT_HTTP;\n\n    static {\n        if (System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n            SCRIPT = \"client/bin/larsClient.bat\";\n        } else {\n            SCRIPT = \"client/bin/larsClient\";\n        }\n\n        Properties defaultConfig = new Properties();\n        InputStream propsStream = FatUtils.class.getClassLoader().getResourceAsStream(\"config.properties\");\n        try {\n            defaultConfig.load(propsStream);\n        } catch (IOException e) {\n            // Can't recover from this\n            throw new RuntimeException(\"Unable to find config.properties file for database/server configuration\");\n        }\n\n        DB_PORT = defaultConfig.getProperty(\"testMongoPort\");\n        LIBERTY_PORT_HTTP = defaultConfig.getProperty(\"testLibertyPortHTTP\");\n        LIBERTY_PORT_HTTPS = defaultConfig.getProperty(\"testLibertyPortHTTPS\");\n        TEST_DB_NAME = defaultConfig.getProperty(\"testDbName\");\n        LARS_APPLICATION_ROOT = defaultConfig.getProperty(\"larsApplicationRoot\");\n        BASEURL_LIBERTY_PORT_HTTP = defaultConfig.getProperty(\"baseUrlLibertyPortHTTP\");\n\n    }\n\n    public static final String SERVER_URL = \"http://localhost:\" + LIBERTY_PORT_HTTP + LARS_APPLICATION_ROOT;\n\n    public static final String DEFAULT_HOST_AND_PORT = \"localhost:\" + DB_PORT;\n\n    private static final String ADMIN_USERNAME = \"admin\";\n\n    private static final String ADMIN_PASSWORD = \"passw0rd\";\n\n    private static final String USER_ROLE_USERNAME = \"user\";\n\n    private static final String USER_ROLE_PASSWORD = \"passw0rd\";\n\n    public static final String BASEURL_SERVER_URL = \"http://localhost:\" + BASEURL_LIBERTY_PORT_HTTP + LARS_APPLICATION_ROOT;\n\n    public static final RepositoryFixture FAT_REPO = new RepositoryFixture(SERVER_URL,\n            DEFAULT_HOST_AND_PORT,\n            TEST_DB_NAME,\n            ADMIN_USERNAME,\n            ADMIN_PASSWORD,\n            USER_ROLE_USERNAME,\n            USER_ROLE_PASSWORD);\n\n    public static int countLines(String input) {\n        int lines = 0;\n        // If the last character isn't \\n, add one, as that will make\n        // the count match what you would normally expect\n        if (input.charAt(input.length() - 1) != '\\n') {\n            lines = 1;\n        }\n        while (true) {\n            int nlIndex = input.indexOf('\\n');\n            if (nlIndex == -1) {\n                break;\n            }\n            lines++;\n            input = input.substring(nlIndex + 1);\n        }\n        return lines;\n    }\n\n}\n", "il.Collection;\r\n\r\nimport jdepend.knowledge.pattern.impl2.AbstractFeature;\r\nimport jdepend.knowledge.pattern.impl2.FeatureCheckContext;\r\nimport jdepend.metadata.Attribute;\r\nimport jdepend.metadata.JavaClass;\r\n\r\npublic class AbstractAttributeHaveSubClassesFeature extends AbstractFeature {\r\n\r\n\t@Override\r\n\tprotected boolean have(FeatureCheckContext context) {\r\n\t\tif (context.getAbstractAttributes() == null) {\r\n\t\t\treturn false;\r\n\t\t} else {\r\n\t\t\tCollection<Attribute> attributes = new ArrayList<Attribute>();\r\n\t\t\tfor (Attribute attribute : context.getAbstractAttributes()) {\r\n\t\t\t\tL: for (JavaClass javaClass : attribute.getTypeClasses()) {\r\n\t\t\t\t\tif (javaClass.getSubClasses().size() > 1) {\r\n\t\t\t\t\t\tattributes.add(attribute);\r\n\t\t\t\t\t\tbreak L;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (attributes.size() > 0) {\r\n\t\t\t\tcontext.setHaveSubClassesAbstractAttributes(attributes);\r\n\t\t\t\treturn true;\r\n\t\t\t} else {\r\n\t\t\t\treturn false;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t@Override\r\n\tpublic String getName() {\r\n\t\treturn \"\u5b58\u5728\u6709\u591a\u4e2a\u5b50\u7c7b\u7684\u62bd\u8c61\u5c5e\u6027\";\r\n\t}\r\n\r\n}\r\n", "2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.google.javascript.jscomp;\n\nimport com.google.gwt.core.client.GWT;\nimport com.google.gwt.resources.client.ClientBundle;\nimport com.google.gwt.resources.client.TextResource;\n\nimport jsinterop.annotations.JsMethod;\n\n/**\n * GWT compatible replacement for {@code ResourceLoader}\n *\n */\nfinal class ResourceLoader {\n  static interface Libraries extends ClientBundle {\n    Libraries INSTANCE = GWT.create(Libraries.class);\n\n    // This is a generated file containing all the text resources we want to package\n    // as a single JSON string mapping (relative) filename to file content strings.\n    @Source(\"resources.json\")\n    TextResource resources();\n  }\n\n  private static final JsObject RESOURCES = parse(Libraries.INSTANCE.resources().getText());\n\n  static String loadTextResource(Class<?> clazz, String path) {\n    String content = get(RESOURCES, path);\n    if (content != null) {\n      return content;\n    }\n    throw new RuntimeException(\"Resource not found \" + path);\n  }\n\n  static boolean resourceExists(Class<?> clazz, String path) {\n    // TODO(sdh): this is supposed to be relative to the given class, but\n    // GWT can't handle that - probably better to remove the class argument\n    // and just require that paths be relative to c.g.javascript.jscomp.\n    return get(RESOURCES, path) != null;\n  }\n\n  public static class JsObject {\n    public JsObject() {}\n  }\n\n  private static native String get(JsObject obj, String key) /*-{\n    return obj[key];\n  }-*/;\n\n  @JsMethod(namespace = \"JSON\")\n  private static native JsObject parse(String json);\n}\n", "reements.  See the NOTICE file distributed with\n *  this work for additional information regarding copyright ownership.\n *  The ASF licenses this file to You under the Apache License, Version 2.0\n *  (the \"License\"); you may not use this file except in compliance with\n *  the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n/**\n * @author Denis M. Kishenko\n * @version $Revision$\n */\npackage org.apache.harmony.awt.gl.render;\n\nimport java.awt.Shape;\nimport java.awt.geom.PathIterator;\n\nimport org.apache.harmony.awt.gl.MultiRectArea;\nimport org.apache.harmony.awt.internal.nls.Messages;\n\npublic class JavaShapeRasterizer {\n\n    static final int POINT_CAPACITY = 16;\n\n    int edgesCount;\n    int edgeCur;\n    int[] edgesX;\n    int[] edgesY;\n    int[] edgesYS; // Y coordinate of edge START point\n    int[] edgesN;\n    int[] edgesDY;\n    int[] bounds;\n    int boundCount;\n    boolean[] edgesExt; // Extremal points\n\n    int activeCount;\n    float[] activeX;\n    int[] activeYEnd;\n    float[] activeXStep;\n    int[] activeDY;\n    boolean[] activeExt;\n\n    int[] crossX;\n    int[] crossDY;\n\n    Filler filler;\n\n    /**\n     * Rasterization filler for different path rules\n     */\n    static abstract class Filler {\n\n        static class NonZero extends Filler {\n            @Override\n            void add(MultiRectArea.LineCash rect, int[] points, int[] orient, int length, int y) {\n\n                int[] dst = new int[length];\n                int dstLength = 1;\n                dst[0] = points[0];\n                int count = 0;\n                boolean inside = true;\n                for(int i = 0; i < length; i++) {\n                    count += orient[i] > 0 ? 1 : -1;\n                    if (count == 0) {\n                        dst[dstLength++] = points[i];\n                        inside = false;\n                    } else {\n                        if (!inside) {\n                            dst[dstLength++] = points[i];\n                            inside = true;\n                        }\n                    }\n\n                }\n\n                for(int i = 1; i < dstLength; i += 2) {\n                    dst[i]--;\n                }\n\n                dstLength = excludeEmpty(dst, dstLength);\n//              System.out.println(\"test\");\n\n                dstLength = union(dst, dstLength);\n\n                rect.addLine(dst, dstLength);\n            }\n        }\n\n        static class EvenOdd extends Filler {\n            @Override\n            void add(MultiRectArea.LineCash rect, int[] points, int[] orient, int length, int y) {\n    /*\n                int[] buf = new int[length];\n                int j = 0;\n                for(int i = 0; i < length - 1; i++) {\n                    if (points[i] != points[i + 1]) {\n                        buf[j++] = points[i];\n                    }\n                }\n    */\n                for(int i = 1; i < length; i += 2) {\n                    points[i]--;\n                }\n\n                length = excludeEmpty(points, length);\n//              System.out.println(\"test\");\n\n                length = union(points, length);\n                rect.addLine(points, length);\n    /*\n                for(int i = 0; i < length;) {\n                    rect.add(points[i++], y, points[i++], y);\n                }\n    */\n            }\n        }\n\n        abstract void add(MultiRectArea.LineCash rect, int[] points, int[] orient, int length, int y);\n\n        static int excludeEmpty(int[] points, int length) {\n            int i = 0;\n            while(i < length) {\n                if (points[i] <= points[i + 1]) {\n                    i += 2;\n                } else {\n                    length -= 2;\n                    System.arraycopy(points, i + 2, points, i, length - i);\n                }\n            }\n            return length;\n        }\n\n        static int union(int[] points, int length) {\n            int i = 1;\n            while(i < length - 1) {\n                if (points[i] < points[i - 1]) {\n                    System.arraycopy(points, i + 1, points, i - 1, length - i - 1);\n                    length -= 2;\n                } else\n                if (points[i] >= points[i + 1] - 1) {\n                    System.arraycopy(points, i + 2, points, i, length - i - 2);\n                    length -= 2;\n                } else {\n                    i += 2;\n                }\n            }\n            return length;\n        }\n\n    }\n\n    public JavaShapeRasterizer() {\n    }\n\n    /**\n     * Checks buffer size and realloc if necessary\n     */\n    int[] checkBufSize(int[] buf, int size) {\n        if (size == buf.length) {\n            int[] tmp;\n            tmp = new int[size + POINT_CAPACITY];\n            System.arraycopy(buf, 0, tmp, 0, buf.length);\n            buf = tmp;\n        }\n        return buf;\n    }\n\n    /**\n     * Adds to the buffers new edge \n     */\n    void addEdge(int x, int y, int num) {\n        edgesX = checkBufSize(edgesX, edgesCount);\n        edgesY = checkBufSize(edgesY, edgesCount);\n        edgesN = checkBufSize(edgesN, edgesCount);\n        edgesX[edgesCount] = x;\n        edgesY[edgesCount] = y;\n        edgesN[edgesCount] = (num << 16) | edgesCount;\n        edgesCount++;\n    }\n\n    /**\n     * Prepare all buffers and variable to rasterize shape \n     */\n    void makeBuffer(PathIterator path, double flatness) {\n        edgesX = new int[POINT_CAPACITY];\n        edgesY = new int[POINT_CAPACITY];\n        edgesN = new int[POINT_CAPACITY];\n        bounds = new int[POINT_CAPACITY];\n        boundCount = 0;\n        edgesCount = 0;\n\n        if (path.getWindingRule() == PathIterator.WIND_EVEN_ODD) {\n            filler = new Filler.EvenOdd();\n        } else {\n            filler = new Filler.NonZero();\n        }\n        float[] coords = new float[2];\n        boolean closed = true;\n        while (!path.isDone()) {\n            switch(path.currentSegment(coords)) {\n            case PathIterator.SEG_MOVETO:\n                if (!closed) {\n                    boundCount++;\n                    bounds = checkBufSize(bounds, boundCount);\n                    bounds[boundCount] = edgesCount;\n                }\n                addEdge((int)coords[0], (int)coords[1], boundCount);\n                closed = false;\n                break;\n            case PathIterator.SEG_LINETO:\n                addEdge((int)coords[0], (int)coords[1], boundCount);\n                break;\n            case PathIterator.SEG_CLOSE:\n                boundCount++;\n                bounds = checkBufSize(bounds, boundCount);\n                bounds[boundCount] = edgesCount;\n                closed = true;\n                break;\n            default:\n                // awt.36=Wrong segment\n                throw new RuntimeException(Messages.getString(\"awt.36\")); //$NON-NLS-1$\n            }\n            path.next();\n        }\n        if (!closed) {\n            boundCount++;\n            bounds = checkBufSize(bounds, boundCount);\n            bounds[boundCount] = edgesCount;\n        }\n    }\n\n    /**\n     * Sort buffers\n     */\n    void sort(int[] master, int[] slave, int length) {\n        for(int i = 0; i < length - 1; i++) {\n            int num = i;\n            int min = master[num];\n            for(int j = i + 1; j < length; j++) {\n                if (master[j] < min) {\n                    num = j;\n                    min = master[num];\n                }\n            }\n            if (num != i) {\n                master[num] = master[i];\n                master[i] = min;\n                min = slave[num];\n                slave[num] = slave[i];\n                slave[i] = min;\n            }\n        }\n    }\n\n    int getNext(int cur) {\n        int n = edgesN[cur];\n        int bound = n >> 16;\n        int num = (n & 0xFFFF) + 1;\n        if (num == bounds[bound + 1]) {\n            return bounds[bound];\n        }\n        return num;\n    }\n\n    int getPrev(int cur) {\n        int n = edgesN[cur];\n        int bound = n >> 16;\n        int num = (n & 0xFFFF) - 1;\n        if (num < bounds[bound]) {\n            return bounds[bound + 1] - 1;\n        }\n        return num;\n    }\n\n    int getNextShape(int cur) {\n        int bound = edgesN[cur] >> 16;\n        return bounds[bound + 1];\n    }\n\n    void init() {\n\n        edgesYS = new int[edgesCount];\n        System.arraycopy(edgesY, 0, edgesYS, 0, edgesCount);\n        // Create edgesDY\n        edgesDY = new int[edgesCount];\n        for(int i = 0; i < edgesCount; i++) {\n            int dy = edgesY[getNext(i)] - edgesY[i];\n            edgesDY[i] = dy;\n        }\n\n        // Create edgesExt\n        edgesExt = new boolean[edgesCount];\n        int prev = -1;\n        int i = 0;\n        int pos = 0;\n        while(i < edgesCount) {\n\n            TOP: {\n                do {\n                    if (edgesDY[i] > 0) {\n                        break TOP;\n                    }\n                    i = getNext(i);\n                } while (i != pos);\n                i = pos = getNextShape(i);\n                continue;\n            }\n\n            BOTTOM: {\n                do {\n                    if (edgesDY[i] < 0) {\n                        break BOTTOM;\n                    }\n                    if (edgesDY[i] > 0) {\n                        prev = i;\n                    }\n                    i = getNext(i);\n                } while (i != pos);\n                i = pos = getNextShape(i);\n                continue;\n            }\n\n            if (prev != -1) {\n                edgesExt[prev] = true;\n            }\n            edgesExt[i] = true;\n        }\n\n        // Sort edgesY and edgesN\n        sort(edgesYS, edgesN, edgesCount);\n\n        edgeCur = 0;\n        activeCount = 0;\n        activeX = new float[edgesCount];\n        activeYEnd = new int[edgesCount];\n        activeXStep = new float[edgesCount];\n        activeDY = new int[edgesCount];\n        activeExt = new boolean[edgesCount];\n\n        crossX = new int[edgesCount];\n        crossDY = new int[edgesCount];\n    }\n\n    /**\n     * Marks edge as active\n     */\n    void addActiveEdge(int levelY, int start, int end, boolean back) {\n        int dy = back ? -edgesDY[end] : edgesDY[start];\n        if (dy <= 0) {\n            return;\n        }\n        int x1 = edgesX[start];\n        int dx = edgesX[end] - x1;\n        activeX[activeCount] = x1;\n        activeYEnd[activeCount] = edgesY[end];\n        activeXStep[activeCount] = dx / (float)dy;\n        activeDY[activeCount] = back ? -dy : dy;\n        activeExt[activeCount] = back ? edgesExt[end] : edgesExt[start];\n        activeCount++;\n    }\n\n    /**\n     * Find new active edges\n     */\n    int findActiveEdges(int levelY) {\n\n        int edgeActive = edgeCur;\n        while (edgeActive < edgesCount && edgesYS[edgeActive] == levelY) {\n            edgeActive++;\n        }\n\n        int activeNext = edgeActive;\n\n        while (edgeActive > edgeCur) {\n            edgeActive--;\n            int num = edgesN[edgeActive] & 0xFFFF;\n            addActiveEdge(levelY, num, getPrev(edgeActive), true);\n            addActiveEdge(levelY, num, getNext(edgeActive), false);\n        }\n\n        edgeCur = activeNext;\n\n        if (activeNext == edgesCount) {\n            return edgesY[edgesCount - 1];\n        }\n        return edgesYS[activeNext];\n    }\n\n    /**\n     * Rasterizes shape with particular flatness\n     * @param shape - the souze Shape to be rasterized\n     * @param flatness - the rasterization flatness\n     * @return a MultiRectArea of rasterized shape\n     */\n    public MultiRectArea rasterize(Shape shape, double flatness) {\n\n        PathIterator path = shape.getPathIterator(null, flatness);\n\n        // Shape is empty\n        if (path.isDone()) {\n            return new MultiRectArea();\n        }\n\n        makeBuffer(path, flatness);\n\n        init();\n\n        int y = edgesYS[0];\n        int nextY = y;\n        int crossCount;\n\n        MultiRectArea.LineCash rect = new MultiRectArea.LineCash(edgesCount);\n        rect.setLine(y);\n\n        while(y <= nextY) {\n\n            crossCount = 0;\n\n            if (y == nextY) {\n\n                int i = activeCount;\n                while(i > 0) {\n                    i--;\n                    if (activeYEnd[i] == y) {\n\n                        activeCount--;\n                        int length = activeCount - i;\n                        if (length != 0) {\n                            int pos = i + 1;\n                            System.arraycopy(activeX, pos, activeX, i, length);\n                            System.arraycopy(activeYEnd, pos, activeYEnd, i, length);\n                            System.arraycopy(activeXStep, pos, activeXStep, i, length);\n                            System.arraycopy(activeDY, pos, activeDY, i, length);\n                            System.arraycopy(activeExt, pos, activeExt, i, length);\n                        }\n                    }\n                }\n\n                nextY = findActiveEdges(y);\n            }\n\n            // Get X crossings\n            for(int i = 0; i < activeCount; i++) {\n                crossX[crossCount] = (int)Math.ceil(activeX[i]);\n                crossDY[crossCount] = activeDY[i];\n                crossCount++;\n            }\n\n            if (crossCount == 0) {\n                rect.skipLine();\n            } else {\n                // Sort X crossings\n                sort(crossX, crossDY, crossCount);\n                filler.add(rect, crossX, crossDY, crossCount, y);\n            }\n\n            for(int i = 0; i < activeCount; i++) {\n                activeX[i] += activeXStep[i];\n            }\n\n            y++;\n        }\n\n        return rect;\n    }\n\n}\n", "pt in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.flowable.dmn.model;\n\npublic abstract class DmnDiDiagramElement extends DmnElement {\n}\n", "ss Utils {\n    public static String capitalize(String s) {\n        return StringUtils.capitalize(s);\n    }\n}", "\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.kie.maven.plugin;\n\nimport io.takari.maven.testing.TestResources;\nimport io.takari.maven.testing.executor.MavenExecutionResult;\nimport io.takari.maven.testing.executor.MavenRuntime;\nimport io.takari.maven.testing.executor.MavenVersions;\nimport io.takari.maven.testing.executor.junit.MavenJUnitTestRunner;\nimport org.junit.Ignore;\nimport org.junit.Rule;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\n\nimport java.io.File;\n\n/**\n * Integration test for kjar\n */\n@RunWith(MavenJUnitTestRunner.class)\n@MavenVersions({\"3.2.3\"})\n@Ignore\npublic class BuildMojoIntegrationTest {\n\n    @Rule\n    public final TestResources resources = new TestResources();\n\n    public final MavenRuntime mavenRuntime;\n\n    public BuildMojoIntegrationTest(MavenRuntime.MavenRuntimeBuilder builder) throws Exception {\n        this.mavenRuntime = builder.withCliOptions( \"-X\" ).build();\n    }\n\n    @Test\n    public void buildDeployAndRun() throws Exception {\n        File basedir = resources.getBasedir(\"kjar-1\");\n        MavenExecutionResult result = mavenRuntime\n                .forProject(basedir)\n                .execute(\"clean\",\n                        \"install\");\n\n        result.assertErrorFreeLog();\n    }\n}\n\n", "se, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.opensource.org/licenses/ecl2.php\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.kuali.rice.kew.engine.node;\n\nimport org.apache.log4j.Logger;\nimport org.jdom.Element;\nimport org.kuali.rice.core.api.util.xml.XmlHelper;\nimport org.kuali.rice.kew.engine.RouteContext;\nimport org.kuali.rice.kew.engine.RouteHelper;\nimport org.kuali.rice.kew.exception.WorkflowServiceErrorException;\nimport org.kuali.rice.kew.routeheader.DocumentContent;\nimport org.kuali.rice.kew.routeheader.StandardDocumentContent;\nimport org.kuali.rice.kew.rule.NetworkIdRoleAttribute;\nimport org.kuali.rice.kew.service.KEWServiceLocator;\nimport org.kuali.rice.kew.api.KewApiConstants;\nimport org.kuali.rice.kim.api.identity.Person;\nimport org.kuali.rice.kim.api.services.KimApiServiceLocator;\n\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Iterator;\n\n\n/**\n * A node which will generate an FYI request to a network ID specified in the document content.\n *\n * @deprecated Use {@link NetworkIdRoleAttribute} instead\n *\n * @author Kuali Rice Team (rice.collab@kuali.org)\n */\npublic class FYIByNetworkId extends RequestActivationNode {\n    private static final Logger LOG = Logger.getLogger(FYIByNetworkId.class);\n\n\tpublic SimpleResult process(RouteContext context, RouteHelper helper)\n\t\t\tthrows Exception {\n\n        LOG.debug(\"processing FYIByNetworkId simple node\");\n        String documentId = context.getDocument().getDocumentId();\n        Element rootElement = getRootElement(new StandardDocumentContent(context.getDocument().getDocContent()));\n\t\tCollection<Element> fieldElements = XmlHelper.findElements(rootElement, \"field\");\n        Iterator<Element> elementIter = fieldElements.iterator();\n        while (elementIter.hasNext()) {\n        \tElement field = (Element) elementIter.next();\n        \tElement version = field.getParentElement();\n        \tif (version.getAttribute(\"current\").getValue().equals(\"true\")) {\n        \t\tLOG.debug(\"Looking for networkId field:  \" + field.getAttributeValue(\"name\"));\n               \tif (field.getAttribute(\"name\")!= null && field.getAttributeValue(\"name\").equals(\"networkId\")) {\n            \t\tLOG.debug(\"Should send an FYI to netID:  \" + field.getChildText(\"value\"));\n               \t\tif (field.getChildText(\"value\") != null) {\n               \t\t\tPerson user = KimApiServiceLocator.getPersonService().getPersonByPrincipalName(field.getChildText(\"value\"));\n\n               \t\t\t//WorkflowDocument wfDoc = new WorkflowDocument(new NetworkIdVO(field.getChildText(\"value\")), documentId);\n               \t\t\tif (!context.isSimulation()) {\n                   \t\t\tKEWServiceLocator.getWorkflowDocumentService().adHocRouteDocumentToPrincipal(user.getPrincipalId(), context.getDocument(), KewApiConstants.ACTION_REQUEST_FYI_REQ, null, null, \"Notification Request\", user.getPrincipalId(), \"Notification Request\", true, null);\n               \t\t}\n               \t\t\t//wfDoc.adHocRouteDocumentToPrincipal(KewApiConstants.ACTION_REQUEST_FYI_REQ, \"Notification Request\", new NetworkIdVO(field.getChildText(\"value\")), \"Notification Request\", true);\n                \t\tLOG.debug(\"Sent FYI using the adHocRouteDocumentToPrincipal function to NetworkID:  \" + user.getPrincipalName());\n                               \tbreak;\n               \t}\n        \t}\n        }\n        }\n\t\treturn super.process(context, helper);\n\t}\n\n\n    private static Element getRootElement(DocumentContent docContent) {\n        Element rootElement = null;\n        try {\n            rootElement = XmlHelper.buildJDocument(docContent.getDocument()).getRootElement();\n        } catch (Exception e) {\n            throw new WorkflowServiceErrorException(\"Invalid XML submitted\", new ArrayList<Object>());\n        }\n        return rootElement;\n    }\n\n\n\tprotected Object getService(String serviceName) {\n\t\treturn KEWServiceLocator.getService(serviceName);\n\t}\n\n\n}\n", " static org.junit.Assert.*;\n\npublic class Test5587 {  \n    Production5587 objectUnderTest = new Production5587();     \n\n    @Test\n    public void testProperty0() {\n        String value = \"value\";\n        objectUnderTest.setProperty0(value);\n        assertEquals(value, objectUnderTest.getProperty0());\n    }\n\n    @Test\n    public void testProperty1() {\n        String value = \"value\";\n        objectUnderTest.setProperty1(value);\n        assertEquals(value, objectUnderTest.getProperty1());\n    }\n\n    @Test\n    public void testProperty2() {\n        String value = \"value\";\n        objectUnderTest.setProperty2(value);\n        assertEquals(value, objectUnderTest.getProperty2());\n    }\n\n    @Test\n    public void testProperty3() {\n        String value = \"value\";\n        objectUnderTest.setProperty3(value);\n        assertEquals(value, objectUnderTest.getProperty3());\n    }\n\n    @Test\n    public void testProperty4() {\n        String value = \"value\";\n        objectUnderTest.setProperty4(value);\n        assertEquals(value, objectUnderTest.getProperty4());\n    }\n\n    @Test\n    public void testProperty5() {\n        String value = \"value\";\n        objectUnderTest.setProperty5(value);\n        assertEquals(value, objectUnderTest.getProperty5());\n    }\n\n    @Test\n    public void testProperty6() {\n        String value = \"value\";\n        objectUnderTest.setProperty6(value);\n        assertEquals(value, objectUnderTest.getProperty6());\n    }\n\n    @Test\n    public void testProperty7() {\n        String value = \"value\";\n        objectUnderTest.setProperty7(value);\n        assertEquals(value, objectUnderTest.getProperty7());\n    }\n\n    @Test\n    public void testProperty8() {\n        String value = \"value\";\n        objectUnderTest.setProperty8(value);\n        assertEquals(value, objectUnderTest.getProperty8());\n    }\n\n    @Test\n    public void testProperty9() {\n        String value = \"value\";\n        objectUnderTest.setProperty9(value);\n        assertEquals(value, objectUnderTest.getProperty9());\n    }\n\n}", "ation.NSError;\nimport apple.foundation.NSMethodSignature;\nimport apple.foundation.NSSet;\nimport org.moe.natj.c.ann.FunctionPtr;\nimport org.moe.natj.general.NatJ;\nimport org.moe.natj.general.Pointer;\nimport org.moe.natj.general.ann.Generated;\nimport org.moe.natj.general.ann.Library;\nimport org.moe.natj.general.ann.Mapped;\nimport org.moe.natj.general.ann.NInt;\nimport org.moe.natj.general.ann.NUInt;\nimport org.moe.natj.general.ann.Owned;\nimport org.moe.natj.general.ann.ReferenceInfo;\nimport org.moe.natj.general.ann.Runtime;\nimport org.moe.natj.general.ptr.Ptr;\nimport org.moe.natj.general.ptr.VoidPtr;\nimport org.moe.natj.objc.Class;\nimport org.moe.natj.objc.ObjCRuntime;\nimport org.moe.natj.objc.SEL;\nimport org.moe.natj.objc.ann.ObjCClassBinding;\nimport org.moe.natj.objc.ann.Selector;\nimport org.moe.natj.objc.map.ObjCObjectMapper;\n\n/**\n * An Xcode quicklook of this object will show a graph visualization of the render\n */\n@Generated\n@Library(\"CoreImage\")\n@Runtime(ObjCRuntime.class)\n@ObjCClassBinding\npublic class CIRenderTask extends NSObject {\n    static {\n        NatJ.register();\n    }\n\n    @Generated\n    protected CIRenderTask(Pointer peer) {\n        super(peer);\n    }\n\n    @Generated\n    @Selector(\"accessInstanceVariablesDirectly\")\n    public static native boolean accessInstanceVariablesDirectly();\n\n    @Generated\n    @Owned\n    @Selector(\"alloc\")\n    public static native CIRenderTask alloc();\n\n    @Owned\n    @Generated\n    @Selector(\"allocWithZone:\")\n    public static native CIRenderTask allocWithZone(VoidPtr zone);\n\n    @Generated\n    @Selector(\"automaticallyNotifiesObserversForKey:\")\n    public static native boolean automaticallyNotifiesObserversForKey(String key);\n\n    @Generated\n    @Selector(\"cancelPreviousPerformRequestsWithTarget:\")\n    public static native void cancelPreviousPerformRequestsWithTarget(@Mapped(ObjCObjectMapper.class) Object aTarget);\n\n    @Generated\n    @Selector(\"cancelPreviousPerformRequestsWithTarget:selector:object:\")\n    public static native void cancelPreviousPerformRequestsWithTargetSelectorObject(\n            @Mapped(ObjCObjectMapper.class) Object aTarget, SEL aSelector,\n            @Mapped(ObjCObjectMapper.class) Object anArgument);\n\n    @Generated\n    @Selector(\"classFallbacksForKeyedArchiver\")\n    public static native NSArray<String> classFallbacksForKeyedArchiver();\n\n    @Generated\n    @Selector(\"classForKeyedUnarchiver\")\n    public static native Class classForKeyedUnarchiver();\n\n    @Generated\n    @Selector(\"debugDescription\")\n    public static native String debugDescription_static();\n\n    @Generated\n    @Selector(\"description\")\n    public static native String description_static();\n\n    @Generated\n    @Selector(\"hash\")\n    @NUInt\n    public static native long hash_static();\n\n    @Generated\n    @Selector(\"init\")\n    public native CIRenderTask init();\n\n    @Generated\n    @Selector(\"instanceMethodForSelector:\")\n    @FunctionPtr(name = \"call_instanceMethodForSelector_ret\")\n    public static native NSObject.Function_instanceMethodForSelector_ret instanceMethodForSelector(SEL aSelector);\n\n    @Generated\n    @Selector(\"instanceMethodSignatureForSelector:\")\n    public static native NSMethodSignature instanceMethodSignatureForSelector(SEL aSelector);\n\n    @Generated\n    @Selector(\"instancesRespondToSelector:\")\n    public static native boolean instancesRespondToSelector(SEL aSelector);\n\n    @Generated\n    @Selector(\"isSubclassOfClass:\")\n    public static native boolean isSubclassOfClass(Class aClass);\n\n    @Generated\n    @Selector(\"keyPathsForValuesAffectingValueForKey:\")\n    public static native NSSet<String> keyPathsForValuesAffectingValueForKey(String key);\n\n    @Generated\n    @Owned\n    @Selector(\"new\")\n    public static native CIRenderTask new_objc();\n\n    @Generated\n    @Selector(\"resolveClassMethod:\")\n    public static native boolean resolveClassMethod(SEL sel);\n\n    @Generated\n    @Selector(\"resolveInstanceMethod:\")\n    public static native boolean resolveInstanceMethod(SEL sel);\n\n    @Generated\n    @Selector(\"setVersion:\")\n    public static native void setVersion_static(@NInt long aVersion);\n\n    @Generated\n    @Selector(\"superclass\")\n    public static native Class superclass_static();\n\n    @Generated\n    @Selector(\"version\")\n    @NInt\n    public static native long version_static();\n\n    @Generated\n    @Selector(\"waitUntilCompletedAndReturnError:\")\n    public native CIRenderInfo waitUntilCompletedAndReturnError(\n            @ReferenceInfo(type = NSError.class) Ptr<NSError> error);\n}\n", "se, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n * http://www.opensource.org/licenses/ecl1.php\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.kuali.kra.committee.lookup.keyvalue;\n\nimport org.kuali.coeus.common.committee.impl.bo.CommitteeBase;\nimport org.kuali.coeus.common.committee.impl.bo.CommitteeType;\nimport org.kuali.coeus.common.committee.impl.lookup.keyvalue.CommitteeIdValuesFinderBase;\nimport org.kuali.kra.committee.bo.Committee;\n\n/**\n * \n * This class is to create key/values pair of active committees.\n */\npublic class CommitteeIdValuesFinder extends CommitteeIdValuesFinderBase {\n    \n\n    private static final long serialVersionUID = 579262858064163358L;\n\n    @Override\n    protected Class<? extends CommitteeBase> getCommitteeBOClassHook() {\n        return Committee.class;\n    }\n\n    @Override\n    protected String getCommitteeTypeCodeHook() {\n        return CommitteeType.IRB_TYPE_CODE;\n    }\n\n}\n", "ements.  See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership.  The ASF licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.apache.hadoop.hive.ql.parse;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.hive.common.FileUtils;\nimport org.apache.hadoop.hive.common.StatsSetupConst;\nimport org.apache.hadoop.hive.common.ValidTxnList;\nimport org.apache.hadoop.hive.common.ValidTxnWriteIdList;\nimport org.apache.hadoop.hive.conf.HiveConf;\nimport org.apache.hadoop.hive.metastore.api.FieldSchema;\nimport org.apache.hadoop.hive.ql.Context;\nimport org.apache.hadoop.hive.ql.Driver;\nimport org.apache.hadoop.hive.ql.QueryState;\nimport org.apache.hadoop.hive.ql.exec.ExplainTask;\nimport org.apache.hadoop.hive.ql.exec.FetchTask;\nimport org.apache.hadoop.hive.ql.exec.Task;\nimport org.apache.hadoop.hive.ql.exec.TaskFactory;\nimport org.apache.hadoop.hive.ql.parse.ExplainConfiguration.AnalyzeState;\nimport org.apache.hadoop.hive.ql.parse.ExplainConfiguration.VectorizationDetailLevel;\nimport org.apache.hadoop.hive.ql.plan.ExplainWork;\nimport org.apache.hadoop.hive.ql.processors.CommandProcessorResponse;\nimport org.apache.hadoop.hive.ql.stats.StatsAggregator;\nimport org.apache.hadoop.hive.ql.stats.StatsCollectionContext;\nimport org.apache.hadoop.hive.ql.stats.fs.FSStatsAggregator;\n\n/**\n * ExplainSemanticAnalyzer.\n *\n */\npublic class ExplainSemanticAnalyzer extends BaseSemanticAnalyzer {\n  List<FieldSchema> fieldList;\n  ExplainConfiguration config;\n\n  public ExplainSemanticAnalyzer(QueryState queryState) throws SemanticException {\n    super(queryState);\n    config = new ExplainConfiguration();\n  }\n\n  @SuppressWarnings(\"unchecked\")\n  @Override\n  public void analyzeInternal(ASTNode ast) throws SemanticException {\n    final int childCount = ast.getChildCount();\n    int i = 1;   // Skip TOK_QUERY.\n    while (i < childCount) {\n      int explainOptions = ast.getChild(i).getType();\n      if (explainOptions == HiveParser.KW_FORMATTED) {\n        config.setFormatted(true);\n      } else if (explainOptions == HiveParser.KW_EXTENDED) {\n        config.setExtended(true);\n      } else if (explainOptions == HiveParser.KW_DEPENDENCY) {\n        config.setDependency(true);\n      } else if (explainOptions == HiveParser.KW_CBO) {\n        config.setCbo(true);\n      } else if (explainOptions == HiveParser.KW_COST) {\n        config.setCboCost(true);\n      } else if (explainOptions == HiveParser.KW_JOINCOST) {\n        config.setCboJoinCost(true);\n      } else if (explainOptions == HiveParser.KW_LOGICAL) {\n        config.setLogical(true);\n      } else if (explainOptions == HiveParser.KW_AUTHORIZATION) {\n        config.setAuthorize(true);\n      } else if (explainOptions == HiveParser.KW_ANALYZE) {\n        config.setAnalyze(AnalyzeState.RUNNING);\n        config.setExplainRootPath(ctx.getMRTmpPath());\n      } else if (explainOptions == HiveParser.KW_VECTORIZATION) {\n        config.setVectorization(true);\n        if (i + 1 < childCount) {\n          int vectorizationOption = ast.getChild(i + 1).getType();\n\n          // [ONLY]\n          if (vectorizationOption == HiveParser.TOK_ONLY) {\n            config.setVectorizationOnly(true);\n            i++;\n            if (i + 1 >= childCount) {\n              break;\n            }\n            vectorizationOption = ast.getChild(i + 1).getType();\n          }\n\n          // [SUMMARY|OPERATOR|EXPRESSION|DETAIL]\n          if (vectorizationOption == HiveParser.TOK_SUMMARY) {\n            config.setVectorizationDetailLevel(VectorizationDetailLevel.SUMMARY);\n            i++;\n          } else if (vectorizationOption == HiveParser.TOK_OPERATOR) {\n            config.setVectorizationDetailLevel(VectorizationDetailLevel.OPERATOR);\n            i++;\n          } else if (vectorizationOption == HiveParser.TOK_EXPRESSION) {\n            config.setVectorizationDetailLevel(VectorizationDetailLevel.EXPRESSION);\n            i++;\n          } else if (vectorizationOption == HiveParser.TOK_DETAIL) {\n            config.setVectorizationDetailLevel(VectorizationDetailLevel.DETAIL);\n            i++;\n          }\n        }\n      } else if (explainOptions == HiveParser.KW_LOCKS) {\n        config.setLocks(true);\n      } else if (explainOptions == HiveParser.KW_AST){\n        config.setAst(true);\n      } else if (explainOptions == HiveParser.KW_DEBUG) {\n        config.setDebug(true);\n      } else {\n        // UNDONE: UNKNOWN OPTION?\n      }\n      i++;\n    }\n\n    ctx.setExplainConfig(config);\n    ctx.setExplainPlan(true);\n\n    ASTNode input = (ASTNode) ast.getChild(0);\n    // explain analyze is composed of two steps\n    // step 1 (ANALYZE_STATE.RUNNING), run the query and collect the runtime #rows\n    // step 2 (ANALYZE_STATE.ANALYZING), explain the query and provide the runtime #rows collected.\n    if (config.getAnalyze() == AnalyzeState.RUNNING) {\n      String query = ctx.getTokenRewriteStream().toString(input.getTokenStartIndex(),\n          input.getTokenStopIndex());\n      LOG.info(\"Explain analyze (running phase) for query \" + query);\n      conf.unset(ValidTxnList.VALID_TXNS_KEY);\n      conf.unset(ValidTxnWriteIdList.VALID_TABLES_WRITEIDS_KEY);\n      Context runCtx = null;\n      try {\n        runCtx = new Context(conf);\n        // runCtx and ctx share the configuration, but not isExplainPlan()\n        runCtx.setExplainConfig(config);\n        Driver driver = new Driver(conf, runCtx, queryState.getLineageState());\n        CommandProcessorResponse ret = driver.run(query);\n        if(ret.getResponseCode() == 0) {\n          // Note that we need to call getResults for simple fetch optimization.\n          // However, we need to skip all the results.\n          while (driver.getResults(new ArrayList<String>())) {\n          }\n        } else {\n          throw new SemanticException(ret.getErrorMessage(), ret.getException());\n        }\n        config.setOpIdToRuntimeNumRows(aggregateStats(config.getExplainRootPath()));\n      } catch (IOException e1) {\n        throw new SemanticException(e1);\n      }\n      ctx.resetOpContext();\n      ctx.resetStream();\n      TaskFactory.resetId();\n      LOG.info(\"Explain analyze (analyzing phase) for query \" + query);\n      config.setAnalyze(AnalyzeState.ANALYZING);\n    }\n    //Creating new QueryState unfortunately causes all .q.out to change - do this in a separate ticket\n    //Sharing QueryState between generating the plan and executing the query seems bad\n    //BaseSemanticAnalyzer sem = SemanticAnalyzerFactory.get(new QueryState(queryState.getConf()), input);\n    BaseSemanticAnalyzer sem = SemanticAnalyzerFactory.get(queryState, input);\n    sem.analyze(input, ctx);\n    sem.validate();\n    inputs = sem.getInputs();\n    outputs = sem.getOutputs();\n\n    ctx.setResFile(ctx.getLocalTmpPath());\n    List<Task<?>> tasks = sem.getAllRootTasks();\n    if (tasks == null) {\n      tasks = Collections.emptyList();\n    }\n\n    FetchTask fetchTask = sem.getFetchTask();\n    if (fetchTask != null) {\n      // Initialize fetch work such that operator tree will be constructed.\n      fetchTask.getWork().initializeForFetch(ctx.getOpContext());\n    }\n\n    ParseContext pCtx = null;\n    if (sem instanceof SemanticAnalyzer) {\n      pCtx = ((SemanticAnalyzer)sem).getParseContext();\n    }\n\n    config.setUserLevelExplain(!config.isExtended()\n        && !config.isFormatted()\n        && !config.isDependency()\n        && !config.isCbo()\n        && !config.isLogical()\n        && !config.isAuthorize()\n        && (\n             (\n               HiveConf.getBoolVar(ctx.getConf(), HiveConf.ConfVars.HIVE_EXPLAIN_USER)\n               &&\n               HiveConf.getVar(conf, HiveConf.ConfVars.HIVE_EXECUTION_ENGINE).equals(\"tez\")\n             )\n             ||\n             (\n               HiveConf.getBoolVar(ctx.getConf(), HiveConf.ConfVars.HIVE_SPARK_EXPLAIN_USER)\n               &&\n               HiveConf.getVar(conf, HiveConf.ConfVars.HIVE_EXECUTION_ENGINE).equals(\"spark\")\n             )\n           )\n        );\n\n    ExplainWork work = new ExplainWork(ctx.getResFile(),\n        pCtx,\n        tasks,\n        fetchTask,\n        input,\n        sem,\n        config,\n        ctx.getCboInfo(),\n        ctx.getOptimizedSql(),\n        ctx.getCalcitePlan());\n\n    work.setAppendTaskType(\n        HiveConf.getBoolVar(conf, HiveConf.ConfVars.HIVEEXPLAINDEPENDENCYAPPENDTASKTYPES));\n\n    ExplainTask explTask = (ExplainTask) TaskFactory.get(work);\n\n    fieldList = explTask.getResultSchema();\n    rootTasks.add(explTask);\n  }\n\n  private Map<String, Long> aggregateStats(Path localTmpPath) {\n    Map<String, Long> opIdToRuntimeNumRows = new HashMap<String, Long>();\n    // localTmpPath is the root of all the stats.\n    // Under it, there will be SEL_1/statsfiles, SEL_2/statsfiles etc where SEL_1 and SEL_2 are the op ids.\n    FileSystem fs;\n    FileStatus[] statuses = null;\n    try {\n      fs = localTmpPath.getFileSystem(conf);\n      statuses = fs.listStatus(localTmpPath, FileUtils.HIDDEN_FILES_PATH_FILTER);\n      // statuses can be null if it is DDL, etc\n    } catch (IOException e) {\n      LOG.warn(e.toString());\n    }\n    if (statuses != null) {\n      for (FileStatus status : statuses) {\n        if (status.isDir()) {\n          StatsCollectionContext scc = new StatsCollectionContext(conf);\n          String[] names = status.getPath().toString().split(Path.SEPARATOR);\n          String opId = names[names.length - 1];\n          scc.setStatsTmpDir(status.getPath().toString());\n          StatsAggregator statsAggregator = new FSStatsAggregator();\n          if (!statsAggregator.connect(scc)) {\n            // -1 means that there is no stats\n            opIdToRuntimeNumRows.put(opId, -1L);\n          } else {\n            String value = statsAggregator.aggregateStats(\"\", StatsSetupConst.RUN_TIME_ROW_COUNT);\n            opIdToRuntimeNumRows.put(opId, Long.parseLong(value));\n          }\n          if (statsAggregator != null) {\n            statsAggregator.closeConnection(scc);\n          }\n        }\n      }\n    }\n    return opIdToRuntimeNumRows;\n  }\n\n  @Override\n  public List<FieldSchema> getResultSchema() {\n    return fieldList;\n  }\n\n  @Override\n  public boolean skipAuthorization() {\n    List<Task<?>> rootTasks = getRootTasks();\n    assert rootTasks != null && rootTasks.size() == 1;\n    Task task = rootTasks.get(0);\n    return task instanceof ExplainTask && ((ExplainTask)task).getWork().isAuthorize();\n  }\n\n}\n", "viderIntegrationTest;\nimport com.vladmihalcea.book.hpjp.util.providers.entity.BlogEntityProvider;\nimport com.vladmihalcea.book.hpjp.util.providers.DataSourceProvider;\n\nimport org.junit.Test;\n\nimport java.sql.Connection;\nimport java.sql.PreparedStatement;\nimport java.sql.SQLException;\nimport java.sql.Statement;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * AbstractBatchPreparedStatementTest - Base class for testing JDBC PreparedStatement  batching\n *\n * @author Vlad Mihalcea\n */\npublic abstract class AbstractBatchPreparedStatementTest extends DataSourceProviderIntegrationTest {\n\n    private BlogEntityProvider entityProvider = new BlogEntityProvider();\n\n    public AbstractBatchPreparedStatementTest(DataSourceProvider dataSourceProvider) {\n        super(dataSourceProvider);\n    }\n\n    @Override\n    protected Class<?>[] entities() {\n        return entityProvider.entities();\n    }\n\n    @Test\n    public void testBatch() {\n        doInJDBC(connection -> {\n            batchInsert(connection);\n            batchUpdate(connection);\n            batchDelete(connection);\n        });\n    }\n\n    protected abstract void onFlush(PreparedStatement statement) throws SQLException;\n\n    private void executeStatement(PreparedStatement statement, AtomicInteger statementCount) throws SQLException {\n        onStatement(statement);\n        int count = statementCount.incrementAndGet();\n        if(count % getBatchSize() == 0) {\n            onFlush(statement);\n        }\n    }\n\n    protected abstract void onStatement(PreparedStatement statement) throws SQLException;\n\n    protected abstract void onEnd(PreparedStatement statement) throws SQLException;\n\n    protected int getPostCount() {\n        return 1000;\n    }\n\n    protected int getPostCommentCount() {\n        return 4;\n    }\n\n    protected int getBatchSize() {\n        return 1;\n    }\n\n    protected void batchInsert(Connection connection) throws SQLException {\n        AtomicInteger postStatementCount = new AtomicInteger();\n        AtomicInteger postCommentStatementCount = new AtomicInteger();\n\n        try (PreparedStatement postStatement = connection.prepareStatement(\"insert into post (title, version, id) values (?, ?, ?)\");\n             PreparedStatement postCommentStatement = connection.prepareStatement(\"insert into post_comment (post_id, review, version, id) values (?, ?, ?, ?)\");\n        ) {\n            int postCount = getPostCount();\n            int postCommentCount = getPostCommentCount();\n\n            LOGGER.info(\"Test batch insert\");\n            long startNanos = System.nanoTime();\n\n            int index;\n\n            for (int i = 0; i < postCount; i++) {\n                index = 0;\n\n                postStatement.setString(++index, String.format(\"Post no. %1$d\", i));\n                postStatement.setInt(++index, 0);\n                postStatement.setLong(++index, i);\n                executeStatement(postStatement, postStatementCount);\n            }\n            onEnd(postStatement);\n            for (int i = 0; i < postCount; i++) {\n                for (int j = 0; j < postCommentCount; j++) {\n                    index = 0;\n\n                    postCommentStatement.setLong(++index, i);\n                    postCommentStatement.setString(++index, String.format(\"Post comment %1$d\", j));\n                    postCommentStatement.setInt(++index, 0);\n                    postCommentStatement.setLong(++index, (postCommentCount * i) + j);\n                    executeStatement(postCommentStatement, postCommentStatementCount);\n                }\n            }\n            onEnd(postCommentStatement);\n\n            LOGGER.info(\"{}.testInsert for {} using batch size {} took {} millis\",\n                    getClass().getSimpleName(),\n                    dataSourceProvider().getClass().getSimpleName(),\n                    getBatchSize(),\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));\n\n        }\n    }\n\n    protected void batchUpdate(Connection connection) throws SQLException {\n        AtomicInteger postStatementCount = new AtomicInteger();\n        AtomicInteger postCommentStatementCount = new AtomicInteger();\n\n        try (\n             PreparedStatement postStatement = connection.prepareStatement(\"update Post set version = ? where id = ?\");\n             PreparedStatement postCommentStatement = connection.prepareStatement(\"update post_comment set version = ? where id = ?\");\n             Statement bulkUpdateStatement = connection.createStatement();\n        ) {\n            int postCount = getPostCount();\n            int postCommentCount = getPostCommentCount();\n\n            LOGGER.info(\"Test batch update\");\n\n            long startNanos = System.nanoTime();\n\n            int index;\n\n            for (int i = 0; i < postCount; i++) {\n                index = 0;\n\n                postStatement.setInt(++index, 1);\n                postStatement.setLong(++index, i);\n                executeStatement(postStatement, postStatementCount);\n            }\n            onEnd(postStatement);\n            for (int i = 0; i < postCount; i++) {\n                for (int j = 0; j < postCommentCount; j++) {\n                    index = 0;\n\n                    postCommentStatement.setInt(++index, 1);\n                    postCommentStatement.setLong(++index, (postCommentCount * i) + j);\n                    executeStatement(postCommentStatement, postCommentStatementCount);\n                }\n            }\n            onEnd(postCommentStatement);\n\n            LOGGER.info(\"{}.testUpdate for {} took {} millis\",\n                    getClass().getSimpleName(),\n                    dataSourceProvider().getClass().getSimpleName(),\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));\n\n            LOGGER.info(\"Test bulk update\");\n            startNanos = System.nanoTime();\n            bulkUpdateStatement.executeUpdate(\"update Post set version = version + 1\");\n            bulkUpdateStatement.executeUpdate(\"update post_comment set version = version + 1\");\n            LOGGER.info(\"{}.testBulkUpdate for {} took {} millis\",\n                    getClass().getSimpleName(),\n                    dataSourceProvider().getClass().getSimpleName(),\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));\n        }\n    }\n\n    protected void batchDelete(Connection connection) throws SQLException {\n        AtomicInteger postStatementCount = new AtomicInteger();\n        AtomicInteger postCommentStatementCount = new AtomicInteger();\n\n        try (\n                PreparedStatement postStatement = connection.prepareStatement(\"delete from Post where id = ?\");\n                PreparedStatement postCommentStatement = connection.prepareStatement(\"delete from post_comment where id = ?\");\n                Statement bulkUpdateStatement = connection.createStatement();\n        ) {\n            int postCount = getPostCount();\n            int postCommentCount = getPostCommentCount();\n\n            LOGGER.info(\"Test batch update\");\n\n            long startNanos = System.nanoTime();\n\n            int index;\n\n            for (int i = 0; i < postCount; i++) {\n                for (int j = 0; j < postCommentCount; j++) {\n                    index = 0;\n\n                    postCommentStatement.setLong(++index, (postCommentCount * i) + j);\n                    executeStatement(postCommentStatement, postCommentStatementCount);\n                }\n            }\n            onEnd(postCommentStatement);\n\n            for (int i = 0; i < postCount; i++) {\n                index = 0;\n\n                postStatement.setLong(++index, i);\n                executeStatement(postStatement, postStatementCount);\n            }\n            onEnd(postStatement);\n\n            LOGGER.info(\"{}.testDelete for {} took {} millis\",\n                    getClass().getSimpleName(),\n                    dataSourceProvider().getClass().getSimpleName(),\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));\n\n            batchInsert(connection);\n\n            LOGGER.info(\"Test bulk delete\");\n            startNanos = System.nanoTime();\n            bulkUpdateStatement.executeUpdate(\"delete from post_comment where version > 0\");\n            bulkUpdateStatement.executeUpdate(\"delete from Post where version > 0\");\n            LOGGER.info(\"{}.testBulkDelete for {} took {} millis\",\n                    getClass().getSimpleName(),\n                    dataSourceProvider().getClass().getSimpleName(),\n                    TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startNanos));\n        }\n\n    }\n}\n", "n 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\npackage com.github.jinahya.sql.metadata;\n\n\nimport com.github.jinahya.xml.bind.MapValuesAdapter;\n\n\n/**\n *\n * @author Jin Kwon <onacit at gmail.com>\n */\npublic class CatalogValuesAdapter\n    extends MapValuesAdapter<Catalogs, String, Catalog> {\n\n\n    public CatalogValuesAdapter() {\n        \n        super(Catalogs.class);\n    }\n\n\n    @Override\n    protected String getKey(final Catalog value) {\n        \n        return value.getTableCat();\n    }\n\n\n}\n", "meUnit;\n\npublic class ReportGenerator implements Callable<String>{\n\tprivate String sender;\n\tprivate String title;\n\t\n\tpublic ReportGenerator(String sender, String title) {\n\t\tsuper();\n\t\tthis.sender = sender;\n\t\tthis.title = title;\n\t}\n\n\t\n\n\t@Override\n\tpublic String call() throws Exception {\n\t\ttry {\n\t\t\tLong duration=(long)(Math.random()*10);\n\t\t\tSystem.out.printf(\"%s_%s: ReportGenerator: Generating a report during %d seconds\\n\",\n\t\t\t\t\tthis.sender,this.title,duration);\n\t\t\tTimeUnit.SECONDS.sleep(duration);\n\t\t} catch (InterruptedException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\n\t\treturn this.sender+\"_\"+this.title;\n\t}\n\n}\n", "nder the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n * \n * http://aws.amazon.com/apache2.0\n * \n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage com.amazonaws.services.schemas.model.transform;\n\nimport java.math.*;\n\nimport javax.annotation.Generated;\n\nimport com.amazonaws.services.schemas.model.*;\nimport com.amazonaws.transform.SimpleTypeJsonUnmarshallers.*;\nimport com.amazonaws.transform.*;\n\nimport com.fasterxml.jackson.core.JsonToken;\nimport static com.fasterxml.jackson.core.JsonToken.*;\n\n/**\n * CreateDiscovererResult JSON Unmarshaller\n */\n@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\npublic class CreateDiscovererResultJsonUnmarshaller implements Unmarshaller<CreateDiscovererResult, JsonUnmarshallerContext> {\n\n    public CreateDiscovererResult unmarshall(JsonUnmarshallerContext context) throws Exception {\n        CreateDiscovererResult createDiscovererResult = new CreateDiscovererResult();\n\n        int originalDepth = context.getCurrentDepth();\n        String currentParentElement = context.getCurrentParentElement();\n        int targetDepth = originalDepth + 1;\n\n        JsonToken token = context.getCurrentToken();\n        if (token == null)\n            token = context.nextToken();\n        if (token == VALUE_NULL) {\n            return createDiscovererResult;\n        }\n\n        while (true) {\n            if (token == null)\n                break;\n\n            if (token == FIELD_NAME || token == START_OBJECT) {\n                if (context.testExpression(\"Description\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setDescription(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"DiscovererArn\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setDiscovererArn(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"DiscovererId\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setDiscovererId(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"SourceArn\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setSourceArn(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"State\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setState(context.getUnmarshaller(String.class).unmarshall(context));\n                }\n                if (context.testExpression(\"CrossAccount\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setCrossAccount(context.getUnmarshaller(Boolean.class).unmarshall(context));\n                }\n                if (context.testExpression(\"tags\", targetDepth)) {\n                    context.nextToken();\n                    createDiscovererResult.setTags(new MapUnmarshaller<String, String>(context.getUnmarshaller(String.class), context\n                            .getUnmarshaller(String.class)).unmarshall(context));\n                }\n            } else if (token == END_ARRAY || token == END_OBJECT) {\n                if (context.getLastParsedParentElement() == null || context.getLastParsedParentElement().equals(currentParentElement)) {\n                    if (context.getCurrentDepth() <= originalDepth)\n                        break;\n                }\n            }\n            token = context.nextToken();\n        }\n\n        return createDiscovererResult;\n    }\n\n    private static CreateDiscovererResultJsonUnmarshaller instance;\n\n    public static CreateDiscovererResultJsonUnmarshaller getInstance() {\n        if (instance == null)\n            instance = new CreateDiscovererResultJsonUnmarshaller();\n        return instance;\n    }\n}\n", "ements. See the NOTICE file\n * distributed with this work for additional information\n * regarding copyright ownership. Metamarkets licenses this file\n * to you under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance\n * with the License. You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied. See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage io.druid.java.util.common.parsers;\n\nimport com.google.common.base.Function;\nimport org.joda.time.DateTime;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class TimestampParserTest\n{\n\n  @Test\n  public void testStripQuotes() throws Exception {\n    Assert.assertEquals(\"hello world\", ParserUtils.stripQuotes(\"\\\"hello world\\\"\"));\n    Assert.assertEquals(\"hello world\", ParserUtils.stripQuotes(\"    \\\"    hello world   \\\"    \"));\n  }\n\n  @Test\n  public void testAuto() throws Exception {\n    final Function<Object, DateTime> parser = TimestampParser.createObjectTimestampParser(\"auto\");\n    Assert.assertEquals(new DateTime(\"2009-02-13T23:31:30Z\"), parser.apply(\"1234567890000\"));\n    Assert.assertEquals(new DateTime(\"2009-02-13T23:31:30Z\"), parser.apply(\"2009-02-13T23:31:30Z\"));\n    Assert.assertEquals(new DateTime(\"2009-02-13T23:31:30Z\"), parser.apply(1234567890000L));\n  }\n\n  @Test\n  public void testRuby() throws Exception {\n    final Function<Object, DateTime> parser = TimestampParser.createObjectTimestampParser(\"ruby\");\n    Assert.assertEquals(new DateTime(\"2013-01-16T15:41:47+01:00\"), parser.apply(\"1358347307.435447\"));\n    Assert.assertEquals(new DateTime(\"2013-01-16T15:41:47+01:00\"), parser.apply(1358347307.435447D));\n  }\n\n  @Test\n  public void testNano() throws Exception {\n    String timeNsStr = \"1427504794977098494\";\n    DateTime expectedDt = new DateTime(\"2015-3-28T01:06:34.977Z\");\n    final Function<Object, DateTime> parser = TimestampParser.createObjectTimestampParser(\"nano\");\n    Assert.assertEquals(\"Incorrect truncation of nanoseconds -> milliseconds\",\n        expectedDt, parser.apply(timeNsStr));\n\n    // Confirm sub-millisecond timestamps are handled correctly\n    expectedDt = new DateTime(\"1970-1-1T00:00:00.000Z\");\n    Assert.assertEquals(expectedDt, parser.apply(\"999999\"));\n    Assert.assertEquals(expectedDt, parser.apply(\"0\"));\n    Assert.assertEquals(expectedDt, parser.apply(\"0000\"));\n    Assert.assertEquals(expectedDt, parser.apply(999999L));\n  }\n\n  /*Commenting out until Joda 2.1 supported\n  @Test\n  public void testTimeStampParserWithQuotes() throws Exception {\n    DateTime d = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-8));\n    Function<String, DateTime> parser = ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss z yyyy\");\n    Assert.assertEquals(d.getMillis(), parser.apply(\" \\\" Wed Nov 9 04:00:00 PST 1994 \\\"  \").getMillis());\n  }\n\n  @Test\n  public void testTimeStampParserWithShortTimeZone() throws Exception {\n    DateTime d = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-8));\n    Function<String, DateTime> parser = ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss z yyyy\");\n    Assert.assertEquals(d.getMillis(), parser.apply(\"Wed Nov 9 04:00:00 PST 1994\").getMillis());\n  }\n\n  @Test\n  public void testTimeStampParserWithLongTimeZone() throws Exception {\n\n    long millis1 = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-8)).getMillis();\n    long millis2 = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-6)).getMillis();\n\n    Function<String, DateTime> parser = ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss zZ z yyyy\");\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 GMT-0800 PST 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 GMT-0600 CST 1994\").getMillis());\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 UTC-0800 PST 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 UTC-0600 CST 1994\").getMillis());\n\n    parser = ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss zZ yyyy\");\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 GMT-0800 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 GMT-0600 1994\").getMillis());\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 UTC-0800 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 UTC-0600 1994\").getMillis());\n\n    parser = ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss zZ Q yyyy\");\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 GMT-0800 (PST) 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 GMT-0600 (CST) 1994\").getMillis());\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 UTC-0800 (PST) 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 UTC-0600 (CST) 1994\").getMillis());\n\n  }\n\n  @Test\n  public void testTimeZoneAtExtremeLocations() throws Exception {\n    Function<String, DateTime> parser = ParserUtils.createTimestampParser(\"EEE MMM dd yy HH:mm:ss zZ z\");\n    Assert.assertEquals(new DateTime(2005, 1, 22, 13, 0, DateTimeZone.forOffsetHours(-6)).getMillis(),\n                        parser.apply(\"Sat Jan 22 05 13:00:00 GMT-0600 CST\").getMillis());\n\n    parser = ParserUtils.createTimestampParser(\"zZ z EEE MMM dd yy HH:mm:ss\");\n    Assert.assertEquals(new DateTime(2005, 1, 22, 13, 0, DateTimeZone.forOffsetHours(-6)).getMillis(),\n                        parser.apply(\"GMT-0600 CST Sat Jan 22 05 13:00:00\").getMillis());\n  }\n  */\n\n  /**\n   * This test case checks a potentially fragile behavior\n   * Some timestamps will come to us in the form of GMT-OFFSET (Time Zone Abbreviation)\n   * The number of time zone abbreviations is long and what they mean can change\n   * If the offset is explicitly provided via GMT-OFFSET, we want Joda to use this instead\n   * of the time zone abbreviation\n   * @throws Exception\n   */\n  /*@Test\n  public void testOffsetPriority() throws Exception {\n    long millis1 = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-8)).getMillis();\n    long millis2 = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-6)).getMillis();\n\n    Function<String, DateTime> parser = ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss zZ Q yyyy\");\n\n    //Test timestamps that have an incorrect time zone abbreviation for the GMT offset.\n    //Joda should use the offset and not use the time zone abbreviation\n    Assert.assertEquals(millis1, parser.apply(\"Wed Nov 9 04:00:00 GMT-0800 (ADT) 1994\").getMillis());\n    Assert.assertEquals(millis2, parser.apply(\"Wed Nov 9 04:00:00 GMT-0600 (MDT) 1994\").getMillis());\n  }\n\n  @Test\n  public void testJodaSymbolInsideLiteral() throws Exception {\n    DateTime d = new DateTime(1994, 11, 9, 4, 0, DateTimeZone.forOffsetHours(-8));\n    Assert.assertEquals(d.getMillis(),\n                        ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss z yyyy 'helloz'\")\n                                   .apply(\"Wed Nov 9 04:00:00 PST 1994 helloz\")\n                                   .getMillis()\n    );\n    Assert.assertEquals(d.getMillis(),\n                        ParserUtils.createTimestampParser(\"EEE MMM dd HH:mm:ss 'helloz' z yyyy 'hello'\")\n                                   .apply(\"Wed Nov 9 04:00:00 helloz PST 1994 hello\")\n                                   .getMillis()\n    );\n  }*/\n\n\n\n}\n", "ftware Foundation.\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\");\n *  you may not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS,\n *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n *\n */\npackage com.sun.org.apache.xml.internal.security.utils;\n\n\n\n\nimport org.w3c.dom.Attr;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.Node;\n\nimport java.util.Arrays;\nimport java.util.WeakHashMap;\nimport java.lang.ref.WeakReference;\n\n\n/**\n * Purpose of this class is to enable the XML Parser to keep track of ID\n * attributes. This is done by 'registering' attributes of type ID at the\n * IdResolver. This is necessary if we create a document from scratch and we\n * sign some resources with a URI using a fragent identifier...\n * <BR />\n * The problem is that if you do not validate a document, you cannot use the\n * <CODE>getElementByID</CODE> functionality. So this modules uses some implicit\n * knowledge on selected Schemas and DTDs to pick the right Element for a given\n * ID: We know that all <CODE>@Id</CODE> attributes in an Element from the XML\n * Signature namespace are of type <CODE>ID</CODE>.\n *\n * @author $Author: raul $\n * @see <A HREF=\"http://www.xml.com/lpt/a/2001/11/07/id.html\">\"Identity Crisis\" on xml.com</A>\n */\npublic class IdResolver {\n\n   /** {@link java.util.logging} logging facility */\n    static java.util.logging.Logger log =\n        java.util.logging.Logger.getLogger(IdResolver.class.getName());\n\n   static WeakHashMap docMap = new WeakHashMap();\n\n   /**\n    * Constructor IdResolver\n    *\n    */\n   private IdResolver() {\n\n      // we don't allow instantiation\n   }\n\n   /**\n    * Method registerElementById\n    *\n    * @param element\n    * @param idValue\n    */\n   public static void registerElementById(Element element, String idValue) {\n      Document doc = element.getOwnerDocument();\n      WeakHashMap elementMap = (WeakHashMap) docMap.get(doc);\n      if(elementMap == null) {\n          elementMap = new WeakHashMap();\n          docMap.put(doc, elementMap);\n      }\n      elementMap.put(idValue, new WeakReference(element));\n   }\n\n   /**\n    * Method registerElementById\n    *\n    * @param element\n    * @param id\n    */\n   public static void registerElementById(Element element, Attr id) {\n      IdResolver.registerElementById(element, id.getNodeValue());\n   }\n\n   /**\n    * Method getElementById\n    *\n    * @param doc\n    * @param id\n    * @return the element obtained by the Id, or null if it is not found.\n    */\n   public static Element getElementById(Document doc, String id) {\n\n      Element result = null;\n\n      result = IdResolver.getElementByIdType(doc, id);\n\n      if (result != null) {\n         if (log.isLoggable(java.util.logging.Level.FINE))                                     log.log(java.util.logging.Level.FINE,\n            \"I could find an Element using the simple getElementByIdType method: \"\n            + result.getTagName());\n\n         return result;\n      }\n\n       result = IdResolver.getElementByIdUsingDOM(doc, id);\n\n       if (result != null) {\n          if (log.isLoggable(java.util.logging.Level.FINE))                                     log.log(java.util.logging.Level.FINE,\n             \"I could find an Element using the simple getElementByIdUsingDOM method: \"\n            + result.getTagName());\n\n         return result;\n      }\n       // this must be done so that Xalan can catch ALL namespaces\n       //XMLUtils.circumventBug2650(doc);\n      result = IdResolver.getElementBySearching(doc, id);\n\n      if (result != null) {\n                  IdResolver.registerElementById(result, id);\n\n         return result;\n      }\n\n      return null;\n   }\n\n\n    /**\n     * Method getElementByIdUsingDOM\n     *\n     * @param doc\n     * @param id\n     * @return the element obtained by the Id, or null if it is not found.\n     */\n    private static Element getElementByIdUsingDOM(Document doc, String id) {\n        if (true)\n                if (log.isLoggable(java.util.logging.Level.FINE))                                     log.log(java.util.logging.Level.FINE, \"getElementByIdUsingDOM() Search for ID \" + id);\n        return doc.getElementById(id);\n    }\n\n   /**\n    * Method getElementByIdType\n    *\n    * @param doc\n    * @param id\n    * @return the element obtained by the Id, or null if it is not found.\n    */\n   private static Element getElementByIdType(Document doc, String id) {\n          if (true)\n                if (log.isLoggable(java.util.logging.Level.FINE))                                     log.log(java.util.logging.Level.FINE, \"getElementByIdType() Search for ID \" + id);\n       WeakHashMap elementMap = (WeakHashMap) docMap.get(doc);\n       if (elementMap != null) {\n           WeakReference weakReference = (WeakReference) elementMap.get(id);\n           if (weakReference != null)\n           {\n                return (Element) weakReference.get();\n           }\n       }\n       return null;\n   }\n\n\n   static java.util.List names;\n   static {\n           String namespaces[]={ Constants.SignatureSpecNS,\n                           EncryptionConstants.EncryptionSpecNS,\n                           \"http://schemas.xmlsoap.org/soap/security/2000-12\",\n                           \"http://www.w3.org/2002/03/xkms#\"\n                   };\n           names=Arrays.asList(namespaces);\n   }\n\n\n   private static Element getElementBySearching(Node root,String id) {\n           Element []els=new Element[5];\n           getElementBySearching(root,id,els);\n           for (int i=0;i<els.length;i++) {\n                   if (els[i]!=null) {\n                           return els[i];\n                   }\n           }\n           return null;\n\n   }\n   private static int getElementBySearching(Node root,String id,Element []els) {\n           switch (root.getNodeType()) {\n           case Node.ELEMENT_NODE:\n                   Element el=(Element)root;\n                   if (el.hasAttributes()) {\n                           int index=names.indexOf(el.getNamespaceURI());\n                           if (index<0) {\n                                   index=4;\n                           }\n                           if (el.getAttribute(\"Id\").equals(id)) {\n                                   els[index]=el;\n                                   if (index==0) {\n                                           return 1;\n                                   }\n                           } else if ( el.getAttribute(\"id\").equals(id) ) {\n                                   if (index!=2) {\n                                           index=4;\n                                   }\n                                   els[index]=el;\n                           } else if ( el.getAttribute(\"ID\").equals(id) ) {\n                                   if (index!=3) {\n                                           index=4;\n                                   }\n                                   els[index]=el;\n                           } else if ((index==3)&&(\n                                   el.getAttribute(\"OriginalRequestID\").equals(id) ||\n                                   el.getAttribute(\"RequestID\").equals(id) ||\n                                   el.getAttribute(\"ResponseID\" ).equals(id))) {\n                                   els[3]=el;\n                           }\n                   }\n                case Node.DOCUMENT_NODE:\n                        Node sibling=root.getFirstChild();\n                        while (sibling!=null) {\n                                if (getElementBySearching(sibling,id,els)==1)\n                                        return 1;\n                                sibling=sibling.getNextSibling();\n                        }\n           }\n           return 0;\n   }\n\n}\n", ");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.redfin.validity.predicates;\n\nimport com.redfin.validity.ValidityUtils;\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\n\nimport java.util.Objects;\nimport java.util.function.Predicate;\n\nfinal class DescriptivePredicateTest\n implements AbstractDescriptivePredicateContract<DescriptivePredicate> {\n\n    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    // Test values & contract implementations\n    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    private static final String VALID_DESCRIPTION = \"null != \" + AbstractDescriptivePredicate.TOKEN;\n    private static final Predicate<String> VALID_PREDICATE = Objects::nonNull;\n\n    @Override\n    public DescriptivePredicate<String> getNotValueTypeInstance() {\n        return new DescriptivePredicate<>(VALID_DESCRIPTION, VALID_PREDICATE);\n    }\n\n    @Override\n    public DescriptivePredicate<String> getInstance(String description) {\n        return new DescriptivePredicate<>(description, VALID_PREDICATE);\n    }\n\n    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n    // Test cases\n    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n    @Test\n    void testCanInstantiateDescriptivePredicateWithValidArguments() {\n        Assertions.assertNotNull(getNotValueTypeInstance(),\n                                 \"Should be able to instantiate a descriptive predicate with valid arguments.\");\n    }\n\n    @Test\n    void testDescriptivePredicateConstructorThrowsExceptionForNullPredicate() {\n        NullPointerException exception = Assertions.assertThrows(NullPointerException.class,\n                                                                 () -> new DescriptivePredicate<>(VALID_DESCRIPTION, null));\n        Assertions.assertEquals(ValidityUtils.nullArgumentMessage(\"predicate\"),\n                                exception.getMessage(),\n                                \"DescriptivePredicate should throw expected exception for a null predicate.\");\n    }\n\n    @Test\n    void testDescriptivePredicateHasExpectedPredicate() {\n        DescriptivePredicate<String> predicate = getNotValueTypeInstance();\n        Assertions.assertAll(\"DescriptivePredicate should wrap the expected predicate.\",\n                             () -> Assertions.assertTrue(predicate.test(\"\")),\n                             () -> Assertions.assertTrue(predicate.test(\"hello\")),\n                             () -> Assertions.assertFalse(predicate.test(null)));\n    }\n\n    @Test\n    void testDescriptivePredicateNegateHasExpectedPredicate() {\n        DescriptivePredicate<String> predicate = getNotValueTypeInstance().negate();\n        Assertions.assertAll(\"DescriptivePredicate should wrap the expected predicate.\",\n                             () -> Assertions.assertFalse(predicate.test(\"\")),\n                             () -> Assertions.assertFalse(predicate.test(\"hello\")),\n                             () -> Assertions.assertTrue(predicate.test(null)));\n    }\n\n    @Test\n    void testDescriptivePredicateNegateHasExpectedToString() {\n        AbstractDescriptivePredicate predicate = new AbstractDescriptivePredicate(VALID_DESCRIPTION) { };\n        Assertions.assertEquals(toStringHelper(predicate.getNegateDescription()),\n                                getNotValueTypeInstance().negate().toString(),\n                                \"DescriptivePredicate negate should return the expected toString.\");\n    }\n\n    @Test\n    void testDescriptivePredicateAndHasExpectedPredicate() {\n        DescriptivePredicate<String> other = new DescriptivePredicate<>(\"!\" + AbstractDescriptivePredicate.TOKEN + \".isEmpty()\", t -> !t.isEmpty());\n        DescriptivePredicate<String> predicate = getNotValueTypeInstance().and(other);\n        Assertions.assertAll(\"DescriptivePredicate should wrap the expected predicate.\",\n                             () -> Assertions.assertFalse(predicate.test(null)),\n                             () -> Assertions.assertFalse(predicate.test(\"\")),\n                             () -> Assertions.assertTrue(predicate.test(\"hello\")));\n    }\n\n    @Test\n    void testDescriptivePredicateAndHasExpectedToString() {\n        AbstractDescriptivePredicate predicate = new AbstractDescriptivePredicate(VALID_DESCRIPTION) { };\n        String otherDescription = \"!\" + AbstractDescriptivePredicate.TOKEN + \".isEmpty()\";\n        Assertions.assertEquals(toStringHelper(predicate.getAndDescription(otherDescription)),\n                                getNotValueTypeInstance().and(getInstance(otherDescription)).toString(),\n                                \"DescriptivePredicate and should return the expected toString.\");\n    }\n\n    @Test\n    void testDescriptivePredicateOrHasExpectedPredicate() {\n        DescriptivePredicate<String> other = new DescriptivePredicate<>(\"!\" + AbstractDescriptivePredicate.TOKEN + \".isEmpty()\", t -> !t.isEmpty());\n        DescriptivePredicate<String> predicate = getNotValueTypeInstance().or(other);\n        Assertions.assertAll(\"DescriptivePredicate should wrap the expected predicate.\",\n                             () -> Assertions.assertTrue(predicate.test(\"\")),\n                             () -> Assertions.assertTrue(predicate.test(\"hello\")));\n        Assertions.assertThrows(NullPointerException.class,\n                                () -> predicate.test(null));\n    }\n\n    @Test\n    void testDescriptivePredicateOrHasExpectedToString() {\n        AbstractDescriptivePredicate predicate = new AbstractDescriptivePredicate(VALID_DESCRIPTION) { };\n        String otherDescription = \"!\" + AbstractDescriptivePredicate.TOKEN + \".isEmpty()\";\n        Assertions.assertEquals(toStringHelper(predicate.getOrDescription(otherDescription)),\n                                getNotValueTypeInstance().or(getInstance(otherDescription)).toString(),\n                                \"DescriptivePredicate or should return the expected toString.\");\n    }\n}\n", "nder the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n * \n * http://aws.amazon.com/apache2.0\n * \n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\npackage com.amazonaws.services.organizations.model.transform;\n\nimport javax.annotation.Generated;\n\nimport com.amazonaws.SdkClientException;\nimport com.amazonaws.services.organizations.model.*;\n\nimport com.amazonaws.protocol.*;\nimport com.amazonaws.annotation.SdkInternalApi;\n\n/**\n * HandshakeFilterMarshaller\n */\n@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\n@SdkInternalApi\npublic class HandshakeFilterMarshaller {\n\n    private static final MarshallingInfo<String> ACTIONTYPE_BINDING = MarshallingInfo.builder(MarshallingType.STRING)\n            .marshallLocation(MarshallLocation.PAYLOAD).marshallLocationName(\"ActionType\").build();\n    private static final MarshallingInfo<String> PARENTHANDSHAKEID_BINDING = MarshallingInfo.builder(MarshallingType.STRING)\n            .marshallLocation(MarshallLocation.PAYLOAD).marshallLocationName(\"ParentHandshakeId\").build();\n\n    private static final HandshakeFilterMarshaller instance = new HandshakeFilterMarshaller();\n\n    public static HandshakeFilterMarshaller getInstance() {\n        return instance;\n    }\n\n    /**\n     * Marshall the given parameter object.\n     */\n    public void marshall(HandshakeFilter handshakeFilter, ProtocolMarshaller protocolMarshaller) {\n\n        if (handshakeFilter == null) {\n            throw new SdkClientException(\"Invalid argument passed to marshall(...)\");\n        }\n\n        try {\n            protocolMarshaller.marshall(handshakeFilter.getActionType(), ACTIONTYPE_BINDING);\n            protocolMarshaller.marshall(handshakeFilter.getParentHandshakeId(), PARENTHANDSHAKEID_BINDING);\n        } catch (Exception e) {\n            throw new SdkClientException(\"Unable to marshall request to JSON: \" + e.getMessage(), e);\n        }\n    }\n\n}\n", "cense, Version 2.0 (the \"License\");\r\n * you may not use this file except in compliance with the License.\r\n * You may obtain a copy of the License at\r\n *\r\n *         http://www.apache.org/licenses/LICENSE-2.0\r\n *\r\n * Unless required by applicable law or agreed to in writing, software\r\n * distributed under the License is distributed on an \"AS IS\" BASIS,\r\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n * See the License for the specific language governing permissions and\r\n * limitations under the License.\r\n */\r\n\r\npackage com.baidu.rigel.biplatform.ma.divide.table.service;\r\n\r\nimport java.util.Map;\r\n\r\nimport com.baidu.rigel.biplatform.ac.minicube.DivideTableStrategyVo;\r\n\r\n\r\n/** \r\n * \u6570\u636e\u5206\u8868\u7b56\u7565\r\n * @author yichao.jiang \r\n * @version  2015\u5e746\u670817\u65e5 \r\n * @since jdk 1.8 or after\r\n */\r\npublic interface DivideTableService {\r\n\r\n    /**\r\n     * \u83b7\u53d6\u5bf9\u5e94\u5206\u8868\u7b56\u7565\u4e0b\u7684\u6240\u6709\u4e8b\u5b9e\u8868\u540d\u79f0\r\n     * getAllFactTableName\r\n     * @param divideTableStrategy \u5206\u8868\u7b56\u7565\r\n     * @param context \u67e5\u8be2\u4e0a\u4e0b\u6587\r\n     * @return \u6240\u6709\u4e8b\u5b9e\u8868\u540d\u79f0\r\n     */\r\n    public String getAllFactTableName(DivideTableStrategyVo divideTableStrategy, Map<String, Object> context);\r\n}\r\n\r\n", "apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.fs.FileStatus;\nimport org.apache.hadoop.fs.FileSystem;\nimport org.apache.hadoop.fs.Path;\n\npublic class Exercise1 {\n\t\n\tpublic static void main(String[] args) throws IOException, URISyntaxException {\n\t\tPath glob = new Path(\"/training/exercises/filesystem/*.txt\");\n\t\tString localRoot = \"/home/hadoop/Training/play_area/exercises/filesystem/e1/\";\n\t\t\n\t\tFileSystem hdfs = FileSystem.get(new Configuration());\n\t\tFileStatus [] files = hdfs.globStatus(glob);\n\t\tfor (FileStatus file : files ){\n\t\t\tPath from = file.getPath();\n\t\t\tPath to = new Path(localRoot, file.getPath().getName());\n\t\t\tSystem.out.println(\"Copying hdfs file [\" + from + \"] to local [\" + to + \"]\");\n\t\t\thdfs.copyToLocalFile(from, to);\n\t\t}\n\t}\n}\n", "eements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.component.milo;\n\nimport java.io.IOException;\nimport java.security.GeneralSecurityException;\nimport java.util.function.Consumer;\n\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.component.milo.server.MiloServerComponent;\nimport org.apache.camel.component.mock.AssertionClause;\nimport org.apache.camel.test.junit4.CamelTestSupport;\nimport org.eclipse.milo.opcua.stack.core.types.builtin.DataValue;\n\npublic abstract class AbstractMiloServerTest extends CamelTestSupport {\n\n    private int serverPort;\n\n    @Override\n    protected void doPreSetup() throws Exception {\n        super.doPreSetup();\n        this.serverPort = Ports.pickServerPort();\n    }\n\n    public int getServerPort() {\n        return this.serverPort;\n    }\n\n    /**\n     * Replace the port placeholder with the dynamic server port\n     * \n     * @param uri the URI to process\n     * @return the result, may be {@code null} if the input is {@code null}\n     */\n    protected String resolve(String uri) {\n        if (uri == null) {\n            return uri;\n        }\n\n        return uri.replace(\"@@port@@\", Integer.toString(this.serverPort));\n    }\n\n    public static void testBody(final AssertionClause clause, final Consumer<DataValue> valueConsumer) {\n        testBody(clause, DataValue.class, valueConsumer);\n    }\n\n    public static <T> void testBody(final AssertionClause clause, final Class<T> bodyClass, final Consumer<T> valueConsumer) {\n        clause.predicate(exchange -> {\n            final T body = exchange.getIn().getBody(bodyClass);\n            valueConsumer.accept(body);\n            return true;\n        });\n    }\n\n    public static Consumer<DataValue> assertGoodValue(final Object expectedValue) {\n        return value -> {\n            assertNotNull(value);\n            assertEquals(expectedValue, value.getValue().getValue());\n            assertTrue(value.getStatusCode().isGood());\n            assertFalse(value.getStatusCode().isBad());\n        };\n    }\n\n    @Override\n    protected CamelContext createCamelContext() throws Exception {\n        final CamelContext context = super.createCamelContext();\n        configureContext(context);\n        return context;\n    }\n\n    protected void configureContext(final CamelContext context) throws Exception {\n        final MiloServerComponent server = context.getComponent(\"milo-server\", MiloServerComponent.class);\n        configureMiloServer(server);\n    }\n\n    protected void configureMiloServer(final MiloServerComponent server) throws Exception {\n        server.setBindAddresses(\"localhost\");\n        server.setBindPort(this.serverPort);\n        server.setUserAuthenticationCredentials(\"foo:bar,foo2:bar2\");\n    }\n\n    /**\n     * Create a default key store for testing\n     *\n     * @return always returns a key store\n     */\n    protected KeyStoreLoader.Result loadDefaultTestKey() {\n        try {\n\n            final KeyStoreLoader loader = new KeyStoreLoader();\n            loader.setUrl(\"file:src/test/resources/cert/cert.p12\");\n            loader.setKeyStorePassword(\"pwd1\");\n            loader.setKeyPassword(\"pwd1\");\n            return loader.load();\n        } catch (final GeneralSecurityException | IOException e) {\n            throw new RuntimeException(e);\n        }\n\n    }\n\n}\n", ");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.ehcache.clustered.client.config;\n\nimport org.ehcache.config.SizedResourcePool;\nimport org.ehcache.config.units.MemoryUnit;\n\n/**\n * Specifies a {@link ClusteredResourcePool} reserving space from a server-based clustered resource.\n * A {@code FixedClusteredResourcePool} uses dedicated space on the server.\n */\npublic interface FixedClusteredResourcePool extends ClusteredResourcePool, SizedResourcePool {\n\n  /**\n   * {@inheritDoc}\n   * @return {@inheritDoc}\n   */\n  @Override\n  MemoryUnit getUnit();\n\n  /**\n   * Identifies the server-side clustered resource from which space for this pool is reserved.\n   * If no server resource is identified, the resource identified in the server configuration as\n   * the default is used.\n   *\n   * @return the server-side clustered resource id; may be {@code null}\n   */\n  String getFromResource();\n}\n", "ort org.json.JSONException;\r\nimport org.json.JSONObject;\r\n\r\nimport android.content.Context;\r\nimport android.view.LayoutInflater;\r\nimport android.view.View;\r\nimport android.view.ViewGroup;\r\nimport android.view.ViewGroup.LayoutParams;\r\nimport android.view.ViewTreeObserver.OnGlobalLayoutListener;\r\nimport android.widget.AdapterView;\r\nimport android.widget.AdapterView.OnItemClickListener;\r\nimport android.widget.BaseAdapter;\r\nimport android.widget.GridView;\r\nimport android.widget.ImageView;\r\nimport android.widget.TextView;\r\nimport cn.iam007.app.common.exception.HttpExceptionButFoundCache;\r\nimport cn.iam007.app.common.utils.CommonHttpUtils;\r\nimport cn.iam007.app.common.utils.ImageUtils;\r\nimport cn.iam007.app.common.utils.logging.LogUtil;\r\nimport cn.iam007.app.mall.R;\r\nimport cn.iam007.app.mall.base.BaseFragment;\r\nimport cn.iam007.app.mall.plugin.model.PluginItem;\r\n\r\nimport com.lidroid.xutils.exception.HttpException;\r\nimport com.lidroid.xutils.http.ResponseInfo;\r\nimport com.lidroid.xutils.http.callback.RequestCallBack;\r\n\r\npublic class PluginViewerFragment extends BaseFragment {\r\n    private final static String TAG = \"plugin\";\r\n\r\n    private GridView mGridView;\r\n    private PluginItemAdapter mAdapter = new PluginItemAdapter();\r\n\r\n    @Override\r\n    public View onInitView(LayoutInflater inflater, ViewGroup container) {\r\n        View view = inflater.inflate(R.layout.fragment_plugin_viewer,\r\n                container,\r\n                false);// \u5173\u8054\u5e03\u5c40\u6587\u4ef6\r\n        mGridView = (GridView) view.findViewById(R.id.plugin_list);\r\n        mGridView.setAdapter(mAdapter);\r\n        mGridView.setOnItemClickListener(new OnItemClickListener() {\r\n\r\n            @Override\r\n            public void onItemClick(\r\n                    AdapterView<?> parent, View view, int position, long id) {\r\n                PluginItem pluginItem = mAdapter.getItem((int) id);\r\n                pluginItem.start(getActivity());\r\n            }\r\n        });\r\n\r\n        init();\r\n        return view;\r\n    }\r\n\r\n    private void init() {\r\n        String action = \"plugin\";\r\n        CommonHttpUtils.get(action, null, new RequestCallBack<String>() {\r\n\r\n            @Override\r\n            public void onSuccess(ResponseInfo<String> arg0) {\r\n                String result = arg0.result;\r\n                LogUtil.d(\"get plug list:\");\r\n                LogUtil.d(result);\r\n                parsePluginList(result);\r\n                setInitViewFinish();\r\n            }\r\n\r\n            @Override\r\n            public void onFailure(HttpException exception, String result) {\r\n                //                LogUtil.d(\"get plugin list failed!\" + exception + \" \" + result);\r\n                if (exception instanceof HttpExceptionButFoundCache) {\r\n                    parsePluginList(result);\r\n                }\r\n                setInitViewFinish();\r\n            }\r\n        }, \"plugins\", 30 * 60);\r\n    }\r\n\r\n    private void parsePluginList(String jsonResult) {\r\n        try {\r\n            JSONObject object = new JSONObject(jsonResult);\r\n            int error = object.optInt(\"e\", -1);\r\n            LogUtil.d(\"  error:\" + error);\r\n            JSONArray pluginList = object.getJSONArray(\"d\");\r\n            mPluginItems.clear();\r\n            for (int i = 0; i < pluginList.length(); i++) {\r\n                JSONObject pluginObject = pluginList.getJSONObject(i);\r\n                PluginItem pluginItem = new PluginItem(pluginObject);\r\n                pluginItem.install();\r\n                mPluginItems.add(pluginItem);\r\n            }\r\n            mAdapter.notifyDataSetChanged();\r\n        } catch (JSONException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    private ArrayList<PluginItem> mPluginItems = new ArrayList<PluginItem>();\r\n\r\n    class PluginItemAdapter extends BaseAdapter {\r\n\r\n        @Override\r\n        public int getCount() {\r\n            return mPluginItems.size();\r\n        }\r\n\r\n        @Override\r\n        public PluginItem getItem(int position) {\r\n            return mPluginItems.get(position);\r\n        }\r\n\r\n        @Override\r\n        public long getItemId(int position) {\r\n            return position;\r\n        }\r\n\r\n        @Override\r\n        @SuppressWarnings(\"deprecation\")\r\n        public View getView(int position, View convertView, ViewGroup parent) {\r\n            ImageView icon = null;\r\n            if (convertView == null) {\r\n                LayoutInflater inflater = (LayoutInflater) parent.getContext()\r\n                        .getSystemService(Context.LAYOUT_INFLATER_SERVICE);\r\n                convertView = inflater.inflate(R.layout.plugin_item, null);\r\n                icon = (ImageView) convertView.findViewById(R.id.icon);\r\n                final ImageView pluginIcon = icon;\r\n                pluginIcon.getViewTreeObserver()\r\n                        .addOnGlobalLayoutListener(new OnGlobalLayoutListener() {\r\n\r\n                            @Override\r\n                            public void onGlobalLayout() {\r\n                                int width = pluginIcon.getWidth();\r\n                                LayoutParams layoutParams = pluginIcon.getLayoutParams();\r\n                                layoutParams.height = width;\r\n                                pluginIcon.setLayoutParams(layoutParams);\r\n\r\n                                pluginIcon.getViewTreeObserver()\r\n                                        .removeGlobalOnLayoutListener(this);\r\n                            }\r\n                        });\r\n            } else {\r\n                icon = (ImageView) convertView.findViewById(R.id.icon);\r\n            }\r\n\r\n            TextView name = (TextView) convertView.findViewById(R.id.name);\r\n\r\n            PluginItem item = getItem(position);\r\n\r\n            ImageUtils.showImageByUrl(item.getPluginIcon(), icon);\r\n            name.setText(item.getPluginName());\r\n\r\n            return convertView;\r\n        }\r\n\r\n    }\r\n\r\n}\r\n", ", baz;\n\n    public void okayMethod()\n    {\n        if(!!!true)\n        {\n            return;\n        }\n    }\n\n    public void badMethod()\n    {\n        if(!!!!true)\n        {\n            return;\n        }\n    }\n\n    public void badMethod2()\n    {\n        if(!!!true && 3 !=4)\n        {\n            return;\n        }\n    }\n\n    public boolean equals(final Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        final ThreeNegationsPerMethodInspection threeNegationsPerMethodInspection = (ThreeNegationsPerMethodInspection) o;\n\n        if (bar != threeNegationsPerMethodInspection.bar) return false;\n        if (baz != threeNegationsPerMethodInspection.baz) return false;\n        if (foo != threeNegationsPerMethodInspection.foo) return false;\n\n        return true;\n    }\n\n    public int hashCode() {\n        int result;\n        result = foo;\n        result = 29 * result + bar;\n        result = 29 * result + baz;\n        return result;\n    }\n}\n", "l.List;\n\n/**\n * Created by chen on 2016/10/25.\n */\npublic class MessageEvent {\n    public static final int LOCATION_SUCCESS = 1;\n    public static final int LOCATION_FAIL = 2;\n    public static final int CITY_NAME = 3;\n    public static final int REQUEST_FAIL = 4;\n    public static final int OPEN_NOTIFY = 5;\n    public static final int CLOSE_NOTIFY = 6;\n    public static final int WEATHER_INFORMATION = 7;\n    public static final int START_LOCATION = 8;\n    public static final int DESTROY = 9;\n    private int mode;\n    private String string;\n    private AirQuality airQuality;\n    private List<HourlyForecast> hourlyForecasts;\n    private List<DailyForecast> dailyForecasts;\n    private List<LifeIndex> lifeIndices;\n    private Basic basic;\n    private LiveWeather liveWeather;\n\n\n    public MessageEvent(int mode, AirQuality airQuality, List<HourlyForecast> hourlyForecasts,\n                        List<DailyForecast> dailyForecasts, List<LifeIndex> lifeIndices,\n                        Basic basic, LiveWeather liveWeather) {\n        this.mode = mode;\n        this.airQuality = airQuality;\n        this.hourlyForecasts = hourlyForecasts;\n        this.dailyForecasts = dailyForecasts;\n        this.lifeIndices = lifeIndices;\n        this.basic = basic;\n        this.liveWeather = liveWeather;\n    }\n\n    public MessageEvent(int mode, @Nullable String string) {\n        this.mode = mode;\n        this.string = string;\n    }\n\n    public int getMode() {\n        return mode;\n    }\n\n\n    public String getString() {\n        return string;\n    }\n\n    public AirQuality getAirQuality() {\n        return airQuality;\n    }\n\n    public List<HourlyForecast> getHourlyForecasts() {\n        return hourlyForecasts;\n    }\n\n    public List<DailyForecast> getDailyForecasts() {\n        return dailyForecasts;\n    }\n\n    public List<LifeIndex> getLifeIndices() {\n        return lifeIndices;\n    }\n\n    public Basic getBasic() {\n        return basic;\n    }\n\n    public LiveWeather getLiveWeather() {\n        return liveWeather;\n    }\n}\n", "te Boolean drawPoints;\r\n\tprivate Integer pointSize;\r\n\tprivate Integer highlightCircleSize;\r\n\t\r\n\tpublic Float getStrokeWidth() {\r\n\t\treturn strokeWidth;\r\n\t}\r\n\tpublic void setStrokeWidth(Float strokeWidth) {\r\n\t\tthis.strokeWidth = strokeWidth;\r\n\t}\r\n\tpublic Boolean getDrawPoints() {\r\n\t\treturn drawPoints;\r\n\t}\r\n\tpublic void setDrawPoints(Boolean drawPoints) {\r\n\t\tthis.drawPoints = drawPoints;\r\n\t}\r\n\tpublic Integer getPointSize() {\r\n\t\treturn pointSize;\r\n\t}\r\n\tpublic void setPointSize(Integer pointSize) {\r\n\t\tthis.pointSize = pointSize;\r\n\t}\r\n\tpublic Integer getHighlightCircleSize() {\r\n\t\treturn highlightCircleSize;\r\n\t}\r\n\tpublic void setHighlightCircleSize(Integer highlightCircleSize) {\r\n\t\tthis.highlightCircleSize = highlightCircleSize;\r\n\t}\r\n\t\r\n\t\r\n}\r\n", "mance.mediummonolithicjavaproject.p147.Production2958;\nimport org.gradle.test.performance.mediummonolithicjavaproject.p147.Production2959;\n\npublic class Production2961 {        \n\n    private Production2958 property0;\n\n    public Production2958 getProperty0() {\n        return property0;\n    }\n\n    public void setProperty0(Production2958 value) {\n        property0 = value;\n    }\n\n    private Production2959 property1;\n\n    public Production2959 getProperty1() {\n        return property1;\n    }\n\n    public void setProperty1(Production2959 value) {\n        property1 = value;\n    }\n\n    private Production2960 property2;\n\n    public Production2960 getProperty2() {\n        return property2;\n    }\n\n    public void setProperty2(Production2960 value) {\n        property2 = value;\n    }\n\n    private String property3;\n\n    public String getProperty3() {\n        return property3;\n    }\n\n    public void setProperty3(String value) {\n        property3 = value;\n    }\n\n    private String property4;\n\n    public String getProperty4() {\n        return property4;\n    }\n\n    public void setProperty4(String value) {\n        property4 = value;\n    }\n\n    private String property5;\n\n    public String getProperty5() {\n        return property5;\n    }\n\n    public void setProperty5(String value) {\n        property5 = value;\n    }\n\n    private String property6;\n\n    public String getProperty6() {\n        return property6;\n    }\n\n    public void setProperty6(String value) {\n        property6 = value;\n    }\n\n    private String property7;\n\n    public String getProperty7() {\n        return property7;\n    }\n\n    public void setProperty7(String value) {\n        property7 = value;\n    }\n\n    private String property8;\n\n    public String getProperty8() {\n        return property8;\n    }\n\n    public void setProperty8(String value) {\n        property8 = value;\n    }\n\n    private String property9;\n\n    public String getProperty9() {\n        return property9;\n    }\n\n    public void setProperty9(String value) {\n        property9 = value;\n    }\n\n}", "mport water.fvec.Vec;\nimport water.util.ArrayUtils;\nimport water.util.TwoDimTable;\n\nimport java.util.Arrays;\n\npublic class ConfusionMatrix extends Iced {\n  private TwoDimTable _table;\n  public final double[][] _cm; // [actual][predicted], typed as double because of observation weights (which can be doubles)\n  public final String[] _domain;\n\n  /**\n   * Constructor for Confusion Matrix\n   * @param value 2D square matrix with co-occurrence counts for actual vs predicted class membership\n   * @param domain class labels (unified domain between actual and predicted class labels)\n   */\n  public ConfusionMatrix(double[][] value, String[] domain) { _cm = value; _domain = domain; }\n\n  /** Build the CM data from the actuals and predictions, using the default\n   *  threshold.  Print to Log.info if the number of classes is below the\n   *  print_threshold.  Actuals might have extra levels not trained on (hence\n   *  never predicted).  Actuals with NAs are not scored, and their predictions\n   *  ignored. */\n  public static ConfusionMatrix buildCM(Vec actuals, Vec predictions) {\n    if (!actuals.isCategorical()) throw new IllegalArgumentException(\"actuals must be categorical.\");\n    if (!predictions.isCategorical()) throw new IllegalArgumentException(\"predictions must be categorical.\");\n    Scope.enter();\n    try {\n      Vec adapted = predictions.adaptTo(actuals.domain());\n      int len = actuals.domain().length;\n      CMBuilder cm = new CMBuilder(len).doAll(actuals, adapted);\n      return new ConfusionMatrix(cm._arr, actuals.domain());\n    } finally {\n      Scope.exit();\n    }\n  }\n\n  private static class CMBuilder extends MRTask<CMBuilder> {\n    final int _len;\n    double _arr[/*actuals*/][/*predicted*/];\n    CMBuilder(int len) { _len = len; }\n    @Override public void map( Chunk ca, Chunk cp ) {\n      // After adapting frames, the Actuals have all the levels in the\n      // prediction results, plus any extras the model was never trained on.\n      // i.e., Actual levels are at least as big as the predicted levels.\n      _arr = new double[_len][_len];\n      for( int i=0; i < ca._len; i++ )\n        if( !ca.isNA(i) )\n          _arr[(int)ca.at8(i)][(int)cp.at8(i)]++;\n    }\n    @Override public void reduce( CMBuilder cm ) { ArrayUtils.add(_arr,cm._arr); }\n  }\n\n\n  public void add(int i, int j) { _cm[i][j]++; }\n\n  public final int size() { return _cm.length; }\n\n  public final double classErr(int c) {\n    double s = ArrayUtils.sum(_cm[c]);\n    if( s == 0 ) return 0.0;    // Either 0 or NaN, but 0 is nicer\n    return (s - _cm[c][c]) / s;\n  }\n  public double totalRows() {\n    double n = 0;\n    for (double[] a_arr : _cm)\n      n += ArrayUtils.sum(a_arr);\n    return n;\n  }\n\n  public void add(ConfusionMatrix other) {\n    ArrayUtils.add(_cm, other._cm);\n  }\n\n  /**\n   * @return overall classification error\n   */\n  public double err() {\n    double n = totalRows();\n    double err = n;\n    for( int d = 0; d < _cm.length; ++d )\n      err -= _cm[d][d];\n    return err / n;\n  }\n  public double errCount() {\n    double err = totalRows();\n    for( int d = 0; d < _cm.length; ++d )\n      err -= _cm[d][d];\n    return err;\n  }\n  /**\n   * The percentage of predictions that are correct.\n   */\n  public double accuracy() { return 1-err(); }\n  /**\n   * The percentage of negative labeled instances that were predicted as negative.\n   * @return TNR / Specificity\n   */\n  public double specificity() {\n    if(!isBinary())throw new UnsupportedOperationException(\"specificity is only implemented for 2 class problems.\");\n    double tn = _cm[0][0];\n    double fp = _cm[0][1];\n    return tn / (tn + fp);\n  }\n  /**\n   * The percentage of positive labeled instances that were predicted as positive.\n   * @return Recall / TPR / Sensitivity\n   */\n  public double recall() {\n    if(!isBinary())throw new UnsupportedOperationException(\"recall is only implemented for 2 class problems.\");\n    double tp = _cm[1][1];\n    double fn = _cm[1][0];\n    return tp / (tp + fn);\n  }\n  /**\n   * The percentage of positive predictions that are correct.\n   * @return Precision\n   */\n  public double precision() {\n    if(!isBinary())throw new UnsupportedOperationException(\"precision is only implemented for 2 class problems.\");\n    double tp = _cm[1][1];\n    double fp = _cm[0][1];\n    return tp / (tp + fp);\n  }\n  /**\n   * The Matthews Correlation Coefficient, takes true negatives into account in contrast to F-Score\n   * See <a href=\"http://en.wikipedia.org/wiki/Matthews_correlation_coefficient\">MCC</a>\n   * MCC = Correlation between observed and predicted binary classification\n   * @return mcc ranges from -1 (total disagreement) ... 0 (no better than random) ... 1 (perfect)\n   */\n  public double mcc() {\n    if(!isBinary())throw new UnsupportedOperationException(\"precision is only implemented for 2 class problems.\");\n    double tn = _cm[0][0];\n    double fp = _cm[0][1];\n    double tp = _cm[1][1];\n    double fn = _cm[1][0];\n    return (tp*tn - fp*fn)/Math.sqrt((tp+fp)*(tp+fn)*(tn+fp)*(tn+fn));\n  }\n  /**\n   * The maximum per-class error\n   * @return max[classErr(i)]\n   */\n  public double max_per_class_error() {\n    int n = nclasses();\n    if(n == 0)throw new UnsupportedOperationException(\"max per class error is only defined for classification problems\");\n    double res = classErr(0);\n    for(int i = 1; i < n; ++i)\n      res = Math.max(res,classErr(i));\n    return res;\n  }\n\n  public final int nclasses(){return _cm == null?0: _cm.length;}\n  public final boolean isBinary(){return nclasses() == 2;}\n\n  /**\n   * Returns the F-measure which combines precision and recall. <br>\n   * C.f. end of http://en.wikipedia.org/wiki/Precision_and_recall.\n   */\n  public double F1() {\n    final double precision = precision();\n    final double recall = recall();\n    return 2. * (precision * recall) / (precision + recall);\n  }\n\n  /**\n   * Returns the F-measure which combines precision and recall and weights recall higher than precision. <br>\n   * See <a href=\"http://en.wikipedia.org/wiki/F1_score.\">F1_score</a>\n   */\n  public double F2() {\n    final double precision = precision();\n    final double recall = recall();\n    return 5. * (precision * recall) / (4. * precision + recall);\n  }\n\n  /**\n   * Returns the F-measure which combines precision and recall and weights precision higher than recall. <br>\n   * See <a href=\"http://en.wikipedia.org/wiki/F1_score.\">F1_score</a>\n   */\n  public double F0point5() {\n    final double precision = precision();\n    final double recall = recall();\n    return 1.25 * (precision * recall) / (.25 * precision + recall);\n  }\n\n  @Override public String toString() {\n    StringBuilder sb = new StringBuilder();\n    for( double[] r : _cm)\n      sb.append(Arrays.toString(r)).append('\\n');\n    return sb.toString();\n  }\n\n  private static String[] createConfusionMatrixHeader( double xs[], String ds[] ) {\n    String ss[] = new String[xs.length]; // the same length\n    for( int i=0; i<xs.length; i++ )\n      if( xs[i] >= 0 || (ds[i] != null && ds[i].length() > 0) && !Double.toString(i).equals(ds[i]) )\n        ss[i] = ds[i];\n    if( ds.length == xs.length-1 && xs[xs.length-1] > 0 )\n      ss[xs.length-1] = \"NA\";\n    return ss;\n  }\n\n  public String toASCII() { return table() == null ? \"\" : _table.toString(); }\n\n  /** Convert this ConfusionMatrix into a fully annotated TwoDimTable\n   *  @return TwoDimTable  */\n  public TwoDimTable table() { return _table == null ? (_table=toTable()) : _table; }\n\n  // Do the work making a TwoDimTable\n  private TwoDimTable toTable() {\n    if (_cm == null || _domain == null) return null;\n    for( double cm[] : _cm ) assert(_cm.length == cm.length);\n    // Sum up predicted & actuals\n    double acts [] = new double[_cm.length];\n    double preds[] = new double[_cm[0].length];\n    boolean isInt = true;\n    for( int a=0; a< _cm.length; a++ ) {\n      double sum=0;\n      for( int p=0; p< _cm[a].length; p++ ) {\n        sum += _cm[a][p];\n        preds[p] += _cm[a][p];\n        isInt &= (_cm[a][p] == (long)_cm[a][p]);\n      }\n      acts[a] = sum;\n    }\n    String adomain[] = createConfusionMatrixHeader(acts , _domain);\n    String pdomain[] = createConfusionMatrixHeader(preds, _domain);\n    assert adomain.length == pdomain.length : \"The confusion matrix should have the same length for both directions.\";\n\n    String[] rowHeader = Arrays.copyOf(adomain,adomain.length+1);\n    rowHeader[adomain.length] = \"Totals\";\n\n    String[] colHeader = Arrays.copyOf(pdomain,pdomain.length+2);\n    colHeader[colHeader.length-2] = \"Error\";\n    colHeader[colHeader.length-1] = \"Rate\";\n\n    String[] colType = new String[colHeader.length];\n    String[] colFormat = new String[colHeader.length];\n    for (int i=0; i<colFormat.length-1; ++i) {\n      colType[i] = isInt ? \"long\":\"double\";\n      colFormat[i] = isInt ? \"%d\":\"%.2f\";\n    }\n    colType[colFormat.length-2]   = \"double\";\n    colFormat[colFormat.length-2] = \"%.4f\";\n    colType[colFormat.length-1]   = \"string\";\n\n    // pass 1: compute width of last column\n    double terr = 0;\n    int width = 0;\n    for (int a = 0; a < _cm.length; a++) {\n      if (adomain[a] == null) continue;\n      double correct = 0;\n      for (int p = 0; p < pdomain.length; p++) {\n        if (pdomain[p] == null) continue;\n        boolean onDiag = adomain[a].equals(pdomain[p]);\n        if (onDiag) correct = _cm[a][p];\n      }\n      double err = acts[a] - correct;\n      terr += err;\n      width = isInt ?\n              Math.max(width, String.format(\"%,d / %,d\", (long)err, (long)acts[a]).length()):\n              Math.max(width, String.format(\"%.4f / %.4f\",     err,       acts[a]).length());\n    }\n    double nrows = 0;\n    for (double n : acts) nrows += n;\n    width = isInt?\n            Math.max(width, String.format(\"%,d / %,d\", (long)terr, (long)nrows).length()):\n            Math.max(width, String.format(\"%.4f / %.4f\",     terr,       nrows).length());\n\n    // set format width\n    colFormat[colFormat.length-1] = \"= %\" + width + \"s\";\n\n    TwoDimTable table = new TwoDimTable(\"Confusion Matrix\", \"vertical: actual; across: predicted\", rowHeader, colHeader, colType, colFormat, null);\n\n    // Main CM Body\n    for (int a = 0; a < _cm.length; a++) {\n      if (adomain[a] == null) continue;\n      double correct = 0;\n      for (int p = 0; p < pdomain.length; p++) {\n        if (pdomain[p] == null) continue;\n        boolean onDiag = adomain[a].equals(pdomain[p]);\n        if (onDiag) correct = _cm[a][p];\n        if (isInt)\n          table.set(a, p, (long)_cm[a][p]);\n        else\n          table.set(a, p, _cm[a][p]);\n      }\n      double err = acts[a] - correct;\n      table.set(a, pdomain.length, err / acts[a]);\n      table.set(a, pdomain.length + 1,\n              isInt ? String.format(\"%,d / %,d\", (long)err, (long)acts[a]):\n                      String.format(\"%.4f / %.4f\",     err,       acts[a])\n      );\n    }\n\n    // Last row of CM\n    for (int p = 0; p < pdomain.length; p++) {\n      if (pdomain[p] == null) continue;\n      if (isInt)\n        table.set(adomain.length, p, (long)preds[p]);\n      else\n        table.set(adomain.length, p, preds[p]);\n    }\n    table.set(adomain.length, pdomain.length, (float) terr / nrows);\n    table.set(adomain.length, pdomain.length + 1,\n            isInt ? String.format(\"%,d / %,d\", (long)terr, (long)nrows):\n                    String.format(\"%.2f / %.2f\",     terr,       nrows));\n\n    return table;\n  }\n}\n", " jerin\n * \n */\npublic class MagicRecipeConstants {\n\n\t/**\n\t * Base Url for Recipe Puppy backend calls.\n\t */\n\tpublic static String MAGICRECIPE_BASE_URL = \"www.recipepuppy.com\";\n\n\t/**\n\t * The url path for Recipe Puppy backend calls.\n\t */\n\tpublic static String MAGICRECIPE_URL_PATH = \"api\";\n\n\t/**\n\t * The query parameter key for Ingredients.\n\t */\n\tpublic static final String MAGICRECIPE_URL_INGREDIENTS_PARAM = \"i\";\n\n\t/**\n\t * The query parameter key for Dishes.\n\t */\n\tpublic static final String MAGICRECIPE_URL_DISH_PARAM = \"q\";\n\n\t/**\n\t * The json key to get all recipe list array from backend response.\n\t */\n\tpublic static final String MAGICRECIPE_JSON_KEY_RESULTS = \"results\";\n\n\t/**\n\t * The json key to get all recipe title from backend response.\n\t */\n\tpublic static final String MAGICRECIPE_JSON_KEY_TITLE = \"title\";\n\n\t/**\n\t * The json key to get all recipe ingredients from backend response.\n\t */\n\tpublic static final String MAGICRECIPE_JSON_KEY_INGREDIENTS = \"ingredients\";\n\n\t/**\n\t * The json key to get all recipe image url from backend response.\n\t */\n\tpublic static final String MAGICRECIPE_JSON_KEY_IMAGE_URL = \"thumbnail\";\n\n\t/**\n\t * The fragment arguments key to identify fragment title.\n\t */\n\tpublic static final String MAGICRECIPE_TAB_KEY = \"magicrecipe_tab_key\";\n\n\t/**\n\t * Unique tab id to specify fragment title.\n\t */\n\tpublic static final int MAGICRECIPE_TAB_TODAYS_SPECIAL = 0;\n\n\t/**\n\t * Unique tab id to specify fragment title.\n\t */\n\tpublic static final int MAGICRECIPE_TAB_SEARCH_RECIPES = 1;\n\n\t/**\n\t * Unique tab id to specify fragment title.\n\t */\n\tpublic static final int MAGICRECIPE_TAB_SEARCH_RESULTS = 2;\n\n\tpublic static final String MAGICRECIPE_FRAGMENT_ARGS_KEY = \"magicrecipe_fragment_args_key\";\n\n}\n", "e values are used to determine\n * the needed lifecycle methods and default values.\n *\n * @see Alert\n * @see AlertLifecycle\n * @since 1.0.0\n */\npublic enum AlertType {\n    VIEW, DIALOG, POPUP, OTHER\n}\n", "stng.Assert;\n\nimport com.orientechnologies.orient.core.compression.OCompression;\nimport com.orientechnologies.orient.core.compression.OCompressionFactory;\n\n/**\n * @author Andrey Lomakin\n * @since 05.06.13\n */\npublic abstract class AbstractCompressionTest {\n  public static void testCompression(String name) {\n    testCompression(name, null);\n  }\n\n  public static void testCompression(String name, String options) {\n    long seed = System.currentTimeMillis();\n    System.out.println(name + \" - Compression seed \" + seed);\n\n    Random random = new Random(seed);\n    final int iterationsCount = 1000;\n    long compressedSize = 0;\n    for (int i = 0; i < iterationsCount; i++) {\n      int contentSize = random.nextInt(10 * 1024 - 100) + 100;\n      byte[] content = new byte[contentSize];\n      random.nextBytes(content);\n\n      final OCompression compression = OCompressionFactory.INSTANCE.getCompression(name, options);\n\n      final byte[] compressedContent = compression.compress(content);\n\n      compressedSize += compressedContent.length;\n\n      Assert.assertEquals(content, compression.uncompress(compressedContent));\n    }\n\n    System.out.println(\"Compression/Decompression test against \" + name + \" took: \" + (System.currentTimeMillis() - seed)\n        + \"ms, total byte size: \" + compressedSize);\n  }\n}\n", "ests.dev.unit.features112;\n\nimport com.perforce.p4java.admin.ILogTail;\nimport com.perforce.p4java.client.IClient;\nimport com.perforce.p4java.exception.P4JavaException;\nimport com.perforce.p4java.impl.generic.admin.LogTail;\nimport com.perforce.p4java.option.server.LogTailOptions;\nimport com.perforce.p4java.tests.SimpleServerRule;\nimport com.perforce.p4java.tests.dev.annotations.Jobs;\nimport com.perforce.p4java.tests.dev.annotations.TestId;\nimport com.perforce.p4java.tests.dev.unit.P4JavaRshTestCase;\nimport org.junit.After;\nimport org.junit.Before;\nimport org.junit.ClassRule;\nimport org.junit.Test;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertNotNull;\nimport static org.junit.Assert.assertTrue;\nimport static org.junit.Assert.fail;\n\n/**\n * Test the 'p4 logtail' command.\n */\n@Jobs({ \"job043229\" })\n@TestId(\"Dev112_LogTailTest\")\npublic class LogTailTest extends P4JavaRshTestCase {\n\n\tIClient client = null;\n\t\n\t@ClassRule\n    public static SimpleServerRule p4d = new SimpleServerRule(\"r16.1\", LogTailTest.class.getSimpleName());\n\n\t/**\n\t * @Before annotation to a method to be run before each test in a class.\n\t */\n\t@Before\n\tpublic void setUp() {\n\t\t// initialization code (before each test).\n\t\ttry {\n\t\t\tserver = getSuperConnection(p4d.getRSHURL());\n\t\t\tclient = server.getClient(\"p4TestUserWS\");\n\t\t\tassertNotNull(client);\n\t\t\tserver.setCurrentClient(client);\n\t\t} catch (Exception e) {\n\t\t\tfail(\"Unexpected exception: \" + e.getLocalizedMessage());\n\t\t} \n\t}\n\n\t/**\n\t * @After annotation to a method to be run after each test in a class.\n\t */\n\t@After\n\tpublic void tearDown() {\n\t\t// cleanup code (after each test).\n\t\tif (server != null) {\n\t\t\tthis.endServerSession(server);\n\t\t}\n\t}\n\n\t/**\n\t * Test LogTail constructor.\n\t */\n\t@Test\n\tpublic void testLogTailConstructor() {\n\n\t\tList<String> logData = new ArrayList<String>();\n\t\tlogData.add(\"test data\");\n\n\t\t// Test LogTail constructor with correct parameters\n\t\ttry {\n\t\t\tILogTail logTail = new LogTail(\"testlogfile\",0,logData);\n\t\t\tassertNotNull(logTail);\n\t\t\tassertEquals(logTail.getLogFilePath(), \"testlogfile\");\n\t\t\tassertEquals(logTail.getOffset(), 0);\n\t\t\tassertEquals(logTail.getData(), \"test data\");\n\t\t} catch (Throwable e) {\n\t\t}\n\t\t\n\t\t// Test LogTail constructor with null \"logFilePath\"\n\t\ttry {\n\t\t\tnew LogTail(null,0,logData);\n\t\t} catch (Throwable e) {\n\t\t\tassertNotNull(e);\n\t\t\tassertEquals(\"logFilePath shouldn't null or empty\", e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\t// Test LogTail constructor with negative \"offset\"\n\t\ttry {\n\t\t\tnew LogTail(\"testlogfile\",-1,logData);\n\t\t} catch (Throwable e) {\n\t\t\tassertNotNull(e);\n\t\t\tassertEquals(\"offset should be greater than or equal to 0\", e.getLocalizedMessage());\n\t\t}\n\t\t\n\t\t// Test LogTail constructor with null \"data\"\n\t\ttry {\n\t\t\tnew LogTail(\"testlogfile\",0,null);\n\t\t} catch (Throwable e) {\n\t\t\tassertNotNull(e);\n\t\t\tassertEquals(\"No data passed to the LogTail constructor.\", e.getMessage());\n\t\t}\n\n\t}\n\t\n\t/**\n\t * Logtail outputs the last block(s) of the errorLog and the offset required\n\t * to get the next block when it becomes available.\n\t */\n\t@Test\n\tpublic void testLogTail() {\n\n\t\ttry {\n\t\t\tILogTail logTail = server.getLogTail(new LogTailOptions());\n\t\t\tassertNotNull(logTail);\n\n\t\t\t// Verify the logTail fields\n\t\t\tassertNotNull(logTail.getLogFilePath());\n\t\t\tassertTrue(logTail.getOffset() > 0);\n\t\t\tassertNotNull(logTail.getData());\n\n\t\t\tlogTail = server.getLogTail(new LogTailOptions().setBlockSize(2*8192).setMaxBlocks(10).setStartingOffset(logTail.getOffset()));\n\t\t\tassertNotNull(logTail);\n\n\t\t\t// Verify the logTail fields\n\t\t\tassertNotNull(logTail.getLogFilePath());\n\t\t\tassertTrue(logTail.getOffset() > 0);\n\t\t\tassertNotNull(logTail.getData());\n\n\t\t} catch (P4JavaException e) {\n\t\t\tfail(\"Unexpected exception: \" + e.getLocalizedMessage());\n\t\t}\n\t}\n\n\t/**\n\t * Test logtail with small block size.\n\t */\n\t@Test\n\tpublic void testLogTailSmallBocks() {\n\n\t\ttry {\n\t\t\tILogTail logTail = server.getLogTail(new LogTailOptions().setBlockSize(10).setMaxBlocks(100).setStartingOffset(0));\n\t\t\tassertNotNull(logTail);\n\n\t\t\t// Verify the logTail fields\n\t\t\tassertNotNull(logTail.getLogFilePath());\n\t\t\tassertTrue(logTail.getOffset() > 0);\n\t\t\tassertNotNull(logTail.getData());\n\n\t\t} catch (P4JavaException e) {\n\t\t\tfail(\"Unexpected exception: \" + e.getLocalizedMessage());\n\t\t}\n\t}\n}\n", "RuntimeException {\n    public InitialSeedingRuntimeException(String msg, Throwable e) {\n        super(msg, e);\n    }\n\n    public InitialSeedingRuntimeException(String msg) {\n        super(msg);\n    }\n\n    public InitialSeedingRuntimeException(Throwable e) {\n        super(e);\n    }\n}\n", "import static org.junit.Assert.assertNotNull;\n\nimport java.nio.charset.Charset;\nimport java.util.Arrays;\nimport java.util.Map.Entry;\nimport java.util.SortedMap;\n\nimport org.junit.Test;\n\nimport com.puresoltechnologies.ductiledb.core.graph.utils.StringEncoder;\n\npublic class StringEncoderTest {\n\n    @Test\n    public void testCharset() {\n\tSortedMap<String, Charset> charsets = Charset.availableCharsets();\n\tfor (Entry<String, Charset> entry : charsets.entrySet()) {\n\t    System.out.println(entry.getKey() + \" -> \" + entry.getValue());\n\t}\n    }\n\n    @Test\n    public void test() {\n\tbyte[] encoded = StringEncoder.encode(\"StringToBeEncoded!\");\n\tassertNotNull(encoded);\n\tSystem.out.println(Arrays.toString(encoded));\n\tSystem.out.println(encoded.length);\n\tString string = StringEncoder.decode(encoded);\n\tassertNotNull(string);\n\tassertEquals(\"StringToBeEncoded!\", string);\n    }\n\n}\n", "import net.bytebuddy.description.method.MethodList;\nimport net.bytebuddy.description.type.TypeDescription;\nimport net.bytebuddy.implementation.auxiliary.AuxiliaryType;\nimport net.bytebuddy.test.utility.ObjectPropertyAssertion;\nimport org.junit.Test;\nimport org.objectweb.asm.Opcodes;\n\nimport static org.hamcrest.CoreMatchers.is;\nimport static org.hamcrest.MatcherAssert.assertThat;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\npublic class MethodGraphCompilerForDeclaredMethodsTest {\n\n    @Test\n    public void testCompilationInvisible() throws Exception {\n        TypeDescription typeDescription = mock(TypeDescription.class);\n        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);\n        when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(methodDescription));\n        when(methodDescription.isVirtual()).thenReturn(true);\n        when(methodDescription.isBridge()).thenReturn(false);\n        when(methodDescription.isVisibleTo(typeDescription)).thenReturn(false);\n        MethodGraph.Linked methodGraph = MethodGraph.Compiler.ForDeclaredMethods.INSTANCE.compile(typeDescription);\n        assertThat(methodGraph.listNodes().size(), is(0));\n    }\n\n    @Test\n    public void testCompilationNonVirtual() throws Exception {\n        TypeDescription typeDescription = mock(TypeDescription.class);\n        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);\n        when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(methodDescription));\n        when(methodDescription.isVirtual()).thenReturn(false);\n        when(methodDescription.isBridge()).thenReturn(false);\n        when(methodDescription.isVisibleTo(typeDescription)).thenReturn(true);\n        MethodGraph.Linked methodGraph = MethodGraph.Compiler.ForDeclaredMethods.INSTANCE.compile(typeDescription);\n        assertThat(methodGraph.listNodes().size(), is(0));\n    }\n\n    @Test\n    public void testCompilationNonBridge() throws Exception {\n        TypeDescription typeDescription = mock(TypeDescription.class);\n        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);\n        when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(methodDescription));\n        when(methodDescription.isVirtual()).thenReturn(true);\n        when(methodDescription.getModifiers()).thenReturn(Opcodes.ACC_BRIDGE);\n        when(methodDescription.isVisibleTo(typeDescription)).thenReturn(true);\n        MethodGraph.Linked methodGraph = MethodGraph.Compiler.ForDeclaredMethods.INSTANCE.compile(typeDescription);\n        assertThat(methodGraph.listNodes().size(), is(0));\n    }\n\n    @Test\n    public void testCompilation() throws Exception {\n        TypeDescription typeDescription = mock(TypeDescription.class);\n        MethodDescription.InDefinedShape methodDescription = mock(MethodDescription.InDefinedShape.class);\n        MethodDescription.SignatureToken token = mock(MethodDescription.SignatureToken.class);\n        when(methodDescription.asSignatureToken()).thenReturn(token);\n        when(typeDescription.getDeclaredMethods()).thenReturn(new MethodList.Explicit<MethodDescription.InDefinedShape>(methodDescription));\n        when(methodDescription.isVirtual()).thenReturn(true);\n        when(methodDescription.isBridge()).thenReturn(false);\n        when(methodDescription.isVisibleTo(typeDescription)).thenReturn(true);\n        MethodGraph.Linked methodGraph = MethodGraph.Compiler.ForDeclaredMethods.INSTANCE.compile(typeDescription);\n        assertThat(methodGraph.listNodes().size(), is(1));\n        assertThat(methodGraph.listNodes().getOnly().getRepresentative(), is((MethodDescription) methodDescription));\n    }\n\n    @Test\n    public void testObjectProperties() throws Exception {\n        ObjectPropertyAssertion.of(MethodGraph.Compiler.ForDeclaredMethods.class).apply();\n    }\n}\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.jclouds.glesys.compute.internal;\n\nimport java.util.Map;\nimport java.util.Properties;\n\nimport org.jclouds.apis.ApiMetadata;\nimport org.jclouds.compute.ComputeService;\nimport org.jclouds.compute.ComputeServiceContext;\nimport org.jclouds.glesys.GleSYSApiMetadata;\nimport org.jclouds.http.HttpRequest;\nimport org.jclouds.http.HttpResponse;\nimport org.jclouds.rest.internal.BaseRestApiExpectTest;\n\nimport com.google.common.base.Function;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.inject.Injector;\nimport com.google.inject.Module;\n\n/**\n * Base class for writing GleSYS Expect tests for ComputeService operations\n */\npublic abstract class BaseGleSYSComputeServiceExpectTest extends BaseRestApiExpectTest<ComputeService> {\n\n   public BaseGleSYSComputeServiceExpectTest() {\n      provider = \"glesys\";\n   }\n\n   @Override\n   protected ApiMetadata createApiMetadata() {\n      return new GleSYSApiMetadata();\n   }\n\n   @Override\n   public ComputeService createClient(Function<HttpRequest, HttpResponse> fn, Module module, Properties props) {\n      return createInjector(fn, module, props).getInstance(ComputeService.class);\n   }\n\n   protected Injector injectorForKnownArgumentsAndConstantPassword() {\n      return injectorForKnownArgumentsAndConstantPassword(ImmutableMap.<HttpRequest, HttpResponse> of());\n   }\n\n   protected Injector injectorForKnownArgumentsAndConstantPassword(Map<HttpRequest, HttpResponse> requestsResponses) {\n      return computeContextForKnownArgumentsAndConstantPassword(requestsResponses).utils().injector();\n   }\n\n   protected ComputeServiceContext computeContextForKnownArgumentsAndConstantPassword(\n         Map<HttpRequest, HttpResponse> requestsResponses) {\n      return requestsSendResponses(\n            ImmutableMap\n                  .<HttpRequest, HttpResponse> builder()\n                  .put(HttpRequest\n                        .builder()\n                        .method(\"GET\")\n                        .endpoint(\"https://api.glesys.com/server/templates/format/json\")\n                        .addHeader(\"Accept\", \"application/json\")\n                        .addHeader(\"Authorization\", \"Basic aWRlbnRpdHk6Y3JlZGVudGlhbA==\").build(),\n                        HttpResponse.builder().statusCode(200).payload(payloadFromResource(\"/server_templates.json\"))\n                              .build())\n                  .put(HttpRequest\n                        .builder()\n                        .method(\"GET\")\n                        .endpoint(\"https://api.glesys.com/server/allowedarguments/format/json\")\n                        .addHeader(\"Accept\", \"application/json\")\n                        .addHeader(\"Authorization\", \"Basic aWRlbnRpdHk6Y3JlZGVudGlhbA==\").build(),\n                        HttpResponse.builder().statusCode(204)\n                              .payload(payloadFromResource(\"/server_allowed_arguments.json\")).build())\n                  .putAll(requestsResponses).build()).getContext();\n   }\n\n   protected ComputeServiceContext computeContextForKnownArgumentsAndConstantPassword() {\n      return computeContextForKnownArgumentsAndConstantPassword(ImmutableMap.<HttpRequest, HttpResponse> of());\n   }\n}\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.accumulo.server.security.handler;\n\nimport static java.nio.charset.StandardCharsets.UTF_8;\n\nimport java.util.Collections;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Map.Entry;\nimport java.util.Set;\nimport java.util.TreeSet;\n\nimport org.apache.accumulo.core.client.AccumuloSecurityException;\nimport org.apache.accumulo.core.client.NamespaceNotFoundException;\nimport org.apache.accumulo.core.client.TableNotFoundException;\nimport org.apache.accumulo.core.client.impl.Namespaces;\nimport org.apache.accumulo.core.client.impl.thrift.SecurityErrorCode;\nimport org.apache.accumulo.core.metadata.MetadataTable;\nimport org.apache.accumulo.core.metadata.RootTable;\nimport org.apache.accumulo.core.security.NamespacePermission;\nimport org.apache.accumulo.core.security.SystemPermission;\nimport org.apache.accumulo.core.security.TablePermission;\nimport org.apache.accumulo.core.security.thrift.TCredentials;\nimport org.apache.accumulo.fate.zookeeper.IZooReaderWriter;\nimport org.apache.accumulo.fate.zookeeper.ZooUtil.NodeExistsPolicy;\nimport org.apache.accumulo.fate.zookeeper.ZooUtil.NodeMissingPolicy;\nimport org.apache.accumulo.server.zookeeper.ZooCache;\nimport org.apache.accumulo.server.zookeeper.ZooReaderWriter;\nimport org.apache.zookeeper.KeeperException;\nimport org.apache.zookeeper.KeeperException.Code;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\npublic class ZKPermHandler implements PermissionHandler {\n  private static final Logger log = LoggerFactory.getLogger(ZKPermHandler.class);\n  private static PermissionHandler zkPermHandlerInstance = null;\n\n  private String ZKUserPath;\n  private String ZKTablePath;\n  private String ZKNamespacePath;\n  private final ZooCache zooCache;\n  private final String ZKUserSysPerms = \"/System\";\n  private final String ZKUserTablePerms = \"/Tables\";\n  private final String ZKUserNamespacePerms = \"/Namespaces\";\n\n  public static synchronized PermissionHandler getInstance() {\n    if (zkPermHandlerInstance == null)\n      zkPermHandlerInstance = new ZKPermHandler();\n    return zkPermHandlerInstance;\n  }\n\n  @Override\n  public void initialize(String instanceId, boolean initialize) {\n    ZKUserPath = ZKSecurityTool.getInstancePath(instanceId) + \"/users\";\n    ZKTablePath = ZKSecurityTool.getInstancePath(instanceId) + \"/tables\";\n    ZKNamespacePath = ZKSecurityTool.getInstancePath(instanceId) + \"/namespaces\";\n  }\n\n  public ZKPermHandler() {\n    zooCache = new ZooCache();\n  }\n\n  @Override\n  public boolean hasTablePermission(String user, String table, TablePermission permission) throws TableNotFoundException {\n    byte[] serializedPerms;\n    final ZooReaderWriter zrw = ZooReaderWriter.getInstance();\n    try {\n      String path = ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table;\n      zrw.sync(path);\n      serializedPerms = zrw.getData(path, null);\n    } catch (KeeperException e) {\n      if (e.code() == Code.NONODE) {\n        // maybe the table was just deleted?\n        try {\n          // check for existence:\n          zrw.getData(ZKTablePath + \"/\" + table, null);\n          // it's there, you don't have permission\n          return false;\n        } catch (InterruptedException ex) {\n          log.warn(\"Unhandled InterruptedException, failing closed for table permission check\", e);\n          return false;\n        } catch (KeeperException ex) {\n          // not there, throw an informative exception\n          if (e.code() == Code.NONODE) {\n            throw new TableNotFoundException(null, table, \"while checking permissions\");\n          }\n          log.warn(\"Unhandled InterruptedException, failing closed for table permission check\", e);\n        }\n        return false;\n      }\n      log.warn(\"Unhandled KeeperException, failing closed for table permission check\", e);\n      return false;\n    } catch (InterruptedException e) {\n      log.warn(\"Unhandled InterruptedException, failing closed for table permission check\", e);\n      return false;\n    }\n    if (serializedPerms != null) {\n      return ZKSecurityTool.convertTablePermissions(serializedPerms).contains(permission);\n    }\n    return false;\n  }\n\n  @Override\n  public boolean hasCachedTablePermission(String user, String table, TablePermission permission) throws AccumuloSecurityException, TableNotFoundException {\n    byte[] serializedPerms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table);\n    if (serializedPerms != null) {\n      return ZKSecurityTool.convertTablePermissions(serializedPerms).contains(permission);\n    }\n    return false;\n  }\n\n  @Override\n  public boolean hasNamespacePermission(String user, String namespace, NamespacePermission permission) throws NamespaceNotFoundException {\n    byte[] serializedPerms;\n    final ZooReaderWriter zrw = ZooReaderWriter.getInstance();\n    try {\n      String path = ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace;\n      zrw.sync(path);\n      serializedPerms = zrw.getData(path, null);\n    } catch (KeeperException e) {\n      if (e.code() == Code.NONODE) {\n        // maybe the namespace was just deleted?\n        try {\n          // check for existence:\n          zrw.getData(ZKNamespacePath + \"/\" + namespace, null);\n          // it's there, you don't have permission\n          return false;\n        } catch (InterruptedException ex) {\n          log.warn(\"Unhandled InterruptedException, failing closed for namespace permission check\", e);\n          return false;\n        } catch (KeeperException ex) {\n          // not there, throw an informative exception\n          if (e.code() == Code.NONODE) {\n            throw new NamespaceNotFoundException(null, namespace, \"while checking permissions\");\n          }\n          log.warn(\"Unhandled InterruptedException, failing closed for table permission check\", e);\n        }\n        return false;\n      }\n      log.warn(\"Unhandled KeeperException, failing closed for table permission check\", e);\n      return false;\n    } catch (InterruptedException e) {\n      log.warn(\"Unhandled InterruptedException, failing closed for table permission check\", e);\n      return false;\n    }\n    if (serializedPerms != null) {\n      return ZKSecurityTool.convertNamespacePermissions(serializedPerms).contains(permission);\n    }\n    return false;\n  }\n\n  @Override\n  public boolean hasCachedNamespacePermission(String user, String namespace, NamespacePermission permission) throws AccumuloSecurityException,\n      NamespaceNotFoundException {\n    byte[] serializedPerms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace);\n    if (serializedPerms != null) {\n      return ZKSecurityTool.convertNamespacePermissions(serializedPerms).contains(permission);\n    }\n    return false;\n  }\n\n  @Override\n  public void grantSystemPermission(String user, SystemPermission permission) throws AccumuloSecurityException {\n    try {\n      byte[] permBytes = zooCache.get(ZKUserPath + \"/\" + user + ZKUserSysPerms);\n      Set<SystemPermission> perms;\n      if (permBytes == null) {\n        perms = new TreeSet<>();\n      } else {\n        perms = ZKSecurityTool.convertSystemPermissions(permBytes);\n      }\n\n      if (perms.add(permission)) {\n        synchronized (zooCache) {\n          zooCache.clear();\n          ZooReaderWriter.getInstance().putPersistentData(ZKUserPath + \"/\" + user + ZKUserSysPerms, ZKSecurityTool.convertSystemPermissions(perms),\n              NodeExistsPolicy.OVERWRITE);\n        }\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void grantTablePermission(String user, String table, TablePermission permission) throws AccumuloSecurityException {\n    Set<TablePermission> tablePerms;\n    byte[] serializedPerms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table);\n    if (serializedPerms != null)\n      tablePerms = ZKSecurityTool.convertTablePermissions(serializedPerms);\n    else\n      tablePerms = new TreeSet<>();\n\n    try {\n      if (tablePerms.add(permission)) {\n        synchronized (zooCache) {\n          zooCache.clear(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table);\n          ZooReaderWriter.getInstance().putPersistentData(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table,\n              ZKSecurityTool.convertTablePermissions(tablePerms), NodeExistsPolicy.OVERWRITE);\n        }\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void grantNamespacePermission(String user, String namespace, NamespacePermission permission) throws AccumuloSecurityException {\n    Set<NamespacePermission> namespacePerms;\n    byte[] serializedPerms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace);\n    if (serializedPerms != null)\n      namespacePerms = ZKSecurityTool.convertNamespacePermissions(serializedPerms);\n    else\n      namespacePerms = new TreeSet<>();\n\n    try {\n      if (namespacePerms.add(permission)) {\n        synchronized (zooCache) {\n          zooCache.clear(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace);\n          ZooReaderWriter.getInstance().putPersistentData(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace,\n              ZKSecurityTool.convertNamespacePermissions(namespacePerms), NodeExistsPolicy.OVERWRITE);\n        }\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void revokeSystemPermission(String user, SystemPermission permission) throws AccumuloSecurityException {\n    byte[] sysPermBytes = zooCache.get(ZKUserPath + \"/\" + user + ZKUserSysPerms);\n\n    // User had no system permission, nothing to revoke.\n    if (sysPermBytes == null)\n      return;\n\n    Set<SystemPermission> sysPerms = ZKSecurityTool.convertSystemPermissions(sysPermBytes);\n\n    try {\n      if (sysPerms.remove(permission)) {\n        synchronized (zooCache) {\n          zooCache.clear();\n          ZooReaderWriter.getInstance().putPersistentData(ZKUserPath + \"/\" + user + ZKUserSysPerms, ZKSecurityTool.convertSystemPermissions(sysPerms),\n              NodeExistsPolicy.OVERWRITE);\n        }\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void revokeTablePermission(String user, String table, TablePermission permission) throws AccumuloSecurityException {\n    byte[] serializedPerms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table);\n\n    // User had no table permission, nothing to revoke.\n    if (serializedPerms == null)\n      return;\n\n    Set<TablePermission> tablePerms = ZKSecurityTool.convertTablePermissions(serializedPerms);\n    try {\n      if (tablePerms.remove(permission)) {\n        zooCache.clear();\n        IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n        if (tablePerms.size() == 0)\n          zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table, NodeMissingPolicy.SKIP);\n        else\n          zoo.putPersistentData(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table, ZKSecurityTool.convertTablePermissions(tablePerms),\n              NodeExistsPolicy.OVERWRITE);\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void revokeNamespacePermission(String user, String namespace, NamespacePermission permission) throws AccumuloSecurityException {\n    byte[] serializedPerms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace);\n\n    // User had no namespace permission, nothing to revoke.\n    if (serializedPerms == null)\n      return;\n\n    Set<NamespacePermission> namespacePerms = ZKSecurityTool.convertNamespacePermissions(serializedPerms);\n    try {\n      if (namespacePerms.remove(permission)) {\n        zooCache.clear();\n        IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n        if (namespacePerms.size() == 0)\n          zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace, NodeMissingPolicy.SKIP);\n        else\n          zoo.putPersistentData(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace, ZKSecurityTool.convertNamespacePermissions(namespacePerms),\n              NodeExistsPolicy.OVERWRITE);\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void cleanTablePermissions(String table) throws AccumuloSecurityException {\n    try {\n      synchronized (zooCache) {\n        zooCache.clear();\n        IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n        for (String user : zooCache.getChildren(ZKUserPath))\n          zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table, NodeMissingPolicy.SKIP);\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(\"unknownUser\", SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void cleanNamespacePermissions(String namespace) throws AccumuloSecurityException {\n    try {\n      synchronized (zooCache) {\n        zooCache.clear();\n        IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n        for (String user : zooCache.getChildren(ZKUserPath))\n          zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace, NodeMissingPolicy.SKIP);\n      }\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(\"unknownUser\", SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void initializeSecurity(TCredentials itw, String rootuser) throws AccumuloSecurityException {\n    IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n\n    // create the root user with all system privileges, no table privileges, and no record-level authorizations\n    Set<SystemPermission> rootPerms = new TreeSet<>();\n    for (SystemPermission p : SystemPermission.values())\n      rootPerms.add(p);\n    Map<String,Set<TablePermission>> tablePerms = new HashMap<>();\n    // Allow the root user to flush the system tables\n    tablePerms.put(RootTable.ID, Collections.singleton(TablePermission.ALTER_TABLE));\n    tablePerms.put(MetadataTable.ID, Collections.singleton(TablePermission.ALTER_TABLE));\n    // essentially the same but on the system namespace, the ALTER_TABLE permission is now redundant\n    Map<String,Set<NamespacePermission>> namespacePerms = new HashMap<>();\n    namespacePerms.put(Namespaces.ACCUMULO_NAMESPACE_ID, Collections.singleton(NamespacePermission.ALTER_NAMESPACE));\n    namespacePerms.put(Namespaces.ACCUMULO_NAMESPACE_ID, Collections.singleton(NamespacePermission.ALTER_TABLE));\n\n    try {\n      // prep parent node of users with root username\n      if (!zoo.exists(ZKUserPath))\n        zoo.putPersistentData(ZKUserPath, rootuser.getBytes(UTF_8), NodeExistsPolicy.FAIL);\n\n      initUser(rootuser);\n      zoo.putPersistentData(ZKUserPath + \"/\" + rootuser + ZKUserSysPerms, ZKSecurityTool.convertSystemPermissions(rootPerms), NodeExistsPolicy.FAIL);\n      for (Entry<String,Set<TablePermission>> entry : tablePerms.entrySet())\n        createTablePerm(rootuser, entry.getKey(), entry.getValue());\n      for (Entry<String,Set<NamespacePermission>> entry : namespacePerms.entrySet())\n        createNamespacePerm(rootuser, entry.getKey(), entry.getValue());\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  @Override\n  public void initUser(String user) throws AccumuloSecurityException {\n    IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n    try {\n      zoo.putPersistentData(ZKUserPath + \"/\" + user, new byte[0], NodeExistsPolicy.SKIP);\n      zoo.putPersistentData(ZKUserPath + \"/\" + user + ZKUserTablePerms, new byte[0], NodeExistsPolicy.SKIP);\n      zoo.putPersistentData(ZKUserPath + \"/\" + user + ZKUserNamespacePerms, new byte[0], NodeExistsPolicy.SKIP);\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    }\n  }\n\n  /**\n   * Sets up a new table configuration for the provided user/table. No checking for existence is done here, it should be done before calling.\n   */\n  private void createTablePerm(String user, String table, Set<TablePermission> perms) throws KeeperException, InterruptedException {\n    synchronized (zooCache) {\n      zooCache.clear();\n      ZooReaderWriter.getInstance().putPersistentData(ZKUserPath + \"/\" + user + ZKUserTablePerms + \"/\" + table, ZKSecurityTool.convertTablePermissions(perms),\n          NodeExistsPolicy.FAIL);\n    }\n  }\n\n  /**\n   * Sets up a new namespace configuration for the provided user/table. No checking for existence is done here, it should be done before calling.\n   */\n  private void createNamespacePerm(String user, String namespace, Set<NamespacePermission> perms) throws KeeperException, InterruptedException {\n    synchronized (zooCache) {\n      zooCache.clear();\n      ZooReaderWriter.getInstance().putPersistentData(ZKUserPath + \"/\" + user + ZKUserNamespacePerms + \"/\" + namespace,\n          ZKSecurityTool.convertNamespacePermissions(perms), NodeExistsPolicy.FAIL);\n    }\n  }\n\n  @Override\n  public void cleanUser(String user) throws AccumuloSecurityException {\n    try {\n      synchronized (zooCache) {\n        IZooReaderWriter zoo = ZooReaderWriter.getInstance();\n        zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserSysPerms, NodeMissingPolicy.SKIP);\n        zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserTablePerms, NodeMissingPolicy.SKIP);\n        zoo.recursiveDelete(ZKUserPath + \"/\" + user + ZKUserNamespacePerms, NodeMissingPolicy.SKIP);\n        zooCache.clear(ZKUserPath + \"/\" + user);\n      }\n    } catch (InterruptedException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      throw new RuntimeException(e);\n    } catch (KeeperException e) {\n      log.error(\"{}\", e.getMessage(), e);\n      if (e.code().equals(KeeperException.Code.NONODE))\n        throw new AccumuloSecurityException(user, SecurityErrorCode.USER_DOESNT_EXIST, e);\n      throw new AccumuloSecurityException(user, SecurityErrorCode.CONNECTION_ERROR, e);\n\n    }\n  }\n\n  @Override\n  public boolean hasSystemPermission(String user, SystemPermission permission) throws AccumuloSecurityException {\n    byte[] perms;\n    try {\n      String path = ZKUserPath + \"/\" + user + ZKUserSysPerms;\n      ZooReaderWriter.getInstance().sync(path);\n      perms = ZooReaderWriter.getInstance().getData(path, null);\n    } catch (KeeperException e) {\n      if (e.code() == Code.NONODE) {\n        return false;\n      }\n      log.warn(\"Unhandled KeeperException, failing closed for table permission check\", e);\n      return false;\n    } catch (InterruptedException e) {\n      log.warn(\"Unhandled InterruptedException, failing closed for table permission check\", e);\n      return false;\n    }\n\n    if (perms == null)\n      return false;\n    return ZKSecurityTool.convertSystemPermissions(perms).contains(permission);\n  }\n\n  @Override\n  public boolean hasCachedSystemPermission(String user, SystemPermission permission) throws AccumuloSecurityException {\n    byte[] perms = zooCache.get(ZKUserPath + \"/\" + user + ZKUserSysPerms);\n    if (perms == null)\n      return false;\n    return ZKSecurityTool.convertSystemPermissions(perms).contains(permission);\n  }\n\n  @Override\n  public boolean validSecurityHandlers(Authenticator authent, Authorizor author) {\n    return true;\n  }\n\n  @Override\n  public void initTable(String table) throws AccumuloSecurityException {\n    // All proper housekeeping is done on delete and permission granting, no work needs to be done here\n  }\n}\n", "xcept in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * \n * Original License: https://github.com/JCTools/JCTools/blob/master/LICENSE\n * Original location: https://github.com/JCTools/JCTools/blob/master/jctools-core/src/main/java/org/jctools/queues/ConcurrentSequencedCircularArrayQueue.java\n */\npackage rx.internal.util.unsafe;\n\nimport static rx.internal.util.unsafe.UnsafeAccess.UNSAFE;\n\nimport rx.internal.util.SuppressAnimalSniffer;\n\n@SuppressAnimalSniffer\npublic abstract class ConcurrentSequencedCircularArrayQueue<E> extends ConcurrentCircularArrayQueue<E> {\n    private static final long ARRAY_BASE;\n    private static final int ELEMENT_SHIFT;\n    static {\n        final int scale = UnsafeAccess.UNSAFE.arrayIndexScale(long[].class);\n        if (8 == scale) {\n            ELEMENT_SHIFT = 3 + SPARSE_SHIFT;\n        } else {\n            throw new IllegalStateException(\"Unexpected long[] element size\");\n        }\n        // Including the buffer pad in the array base offset\n        ARRAY_BASE = UnsafeAccess.UNSAFE.arrayBaseOffset(long[].class) + (BUFFER_PAD << (ELEMENT_SHIFT - SPARSE_SHIFT));\n    }\n    protected final long[] sequenceBuffer;\n\n    public ConcurrentSequencedCircularArrayQueue(int capacity) {\n        super(capacity);\n        int actualCapacity = (int) (this.mask + 1);\n        // pad data on either end with some empty slots.\n        sequenceBuffer = new long[(actualCapacity << SPARSE_SHIFT) + BUFFER_PAD * 2];\n        for (long i = 0; i < actualCapacity; i++) {\n            soSequence(sequenceBuffer, calcSequenceOffset(i), i);\n        }\n    }\n\n    protected final long calcSequenceOffset(long index) {\n        return ARRAY_BASE + ((index & mask) << ELEMENT_SHIFT);\n    }\n\n    protected final void soSequence(long[] buffer, long offset, long e) {\n        UNSAFE.putOrderedLong(buffer, offset, e);\n    }\n\n    protected final long lvSequence(long[] buffer, long offset) {\n        return UNSAFE.getLongVolatile(buffer, offset);\n    }\n\n}\n", "nder the Apache License, Version 2.0 (the \"License\"). You may not use this file except in compliance with\n * the License. A copy of the License is located at\n * \n * http://aws.amazon.com/apache2.0\n * \n * or in the \"license\" file accompanying this file. This file is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n * CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions\n * and limitations under the License.\n */\n\npackage com.amazonaws.services.elasticmapreduce.waiters;\n\nimport com.amazonaws.annotation.SdkInternalApi;\nimport com.amazonaws.waiters.WaiterAcceptor;\nimport com.amazonaws.waiters.WaiterState;\nimport com.amazonaws.waiters.AcceptorPathMatcher;\nimport com.amazonaws.services.elasticmapreduce.model.*;\n\nimport com.fasterxml.jackson.databind.JsonNode;\n\nimport com.amazonaws.jmespath.*;\n\nimport java.io.IOException;\nimport javax.annotation.Generated;\n\n@SdkInternalApi\n@Generated(\"com.amazonaws:aws-java-sdk-code-generator\")\nclass StepComplete {\n\n    static class IsCOMPLETEDMatcher extends WaiterAcceptor<DescribeStepResult> {\n        private static final JsonNode expectedResult;\n\n        static {\n            try {\n                expectedResult = ObjectMapperSingleton.getObjectMapper().readTree(\"\\\"COMPLETED\\\"\");\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n        }\n\n        private static final JmesPathExpression ast = new JmesPathSubExpression(new JmesPathField(\"Step\"), new JmesPathField(\"Status\"), new JmesPathField(\n                \"State\"));\n\n        /**\n         * Takes the result and determines whether the state of the resource matches the expected state. To determine\n         * the current state of the resource, JmesPath expression is evaluated and compared against the expected result.\n         * \n         * @param result\n         *        Corresponding result of the operation\n         * @return True if current state of the resource matches the expected state, False otherwise\n         */\n        @Override\n        public boolean matches(DescribeStepResult result) {\n            JsonNode queryNode = ObjectMapperSingleton.getObjectMapper().valueToTree(result);\n            JsonNode finalResult = ast.accept(new JmesPathEvaluationVisitor(), queryNode);\n            return AcceptorPathMatcher.path(expectedResult, finalResult);\n        }\n\n        /**\n         * Represents the current waiter state in the case where resource state matches the expected state\n         * \n         * @return Corresponding state of the waiter\n         */\n        @Override\n        public WaiterState getState() {\n            return WaiterState.SUCCESS;\n        }\n    }\n\n    static class IsFAILEDMatcher extends WaiterAcceptor<DescribeStepResult> {\n        private static final JsonNode expectedResult;\n\n        static {\n            try {\n                expectedResult = ObjectMapperSingleton.getObjectMapper().readTree(\"\\\"FAILED\\\"\");\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n        }\n\n        private static final JmesPathExpression ast = new JmesPathSubExpression(new JmesPathField(\"Step\"), new JmesPathField(\"Status\"), new JmesPathField(\n                \"State\"));\n\n        /**\n         * Takes the result and determines whether the state of the resource matches the expected state. To determine\n         * the current state of the resource, JmesPath expression is evaluated and compared against the expected result.\n         * \n         * @param result\n         *        Corresponding result of the operation\n         * @return True if current state of the resource matches the expected state, False otherwise\n         */\n        @Override\n        public boolean matches(DescribeStepResult result) {\n            JsonNode queryNode = ObjectMapperSingleton.getObjectMapper().valueToTree(result);\n            JsonNode finalResult = ast.accept(new JmesPathEvaluationVisitor(), queryNode);\n            return AcceptorPathMatcher.path(expectedResult, finalResult);\n        }\n\n        /**\n         * Represents the current waiter state in the case where resource state matches the expected state\n         * \n         * @return Corresponding state of the waiter\n         */\n        @Override\n        public WaiterState getState() {\n            return WaiterState.FAILURE;\n        }\n    }\n\n    static class IsCANCELLEDMatcher extends WaiterAcceptor<DescribeStepResult> {\n        private static final JsonNode expectedResult;\n\n        static {\n            try {\n                expectedResult = ObjectMapperSingleton.getObjectMapper().readTree(\"\\\"CANCELLED\\\"\");\n            } catch (IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n        }\n\n        private static final JmesPathExpression ast = new JmesPathSubExpression(new JmesPathField(\"Step\"), new JmesPathField(\"Status\"), new JmesPathField(\n                \"State\"));\n\n        /**\n         * Takes the result and determines whether the state of the resource matches the expected state. To determine\n         * the current state of the resource, JmesPath expression is evaluated and compared against the expected result.\n         * \n         * @param result\n         *        Corresponding result of the operation\n         * @return True if current state of the resource matches the expected state, False otherwise\n         */\n        @Override\n        public boolean matches(DescribeStepResult result) {\n            JsonNode queryNode = ObjectMapperSingleton.getObjectMapper().valueToTree(result);\n            JsonNode finalResult = ast.accept(new JmesPathEvaluationVisitor(), queryNode);\n            return AcceptorPathMatcher.path(expectedResult, finalResult);\n        }\n\n        /**\n         * Represents the current waiter state in the case where resource state matches the expected state\n         * \n         * @return Corresponding state of the waiter\n         */\n        @Override\n        public WaiterState getState() {\n            return WaiterState.FAILURE;\n        }\n    }\n}\n", "gerFactory;\n\nimport java.util.Properties;\n\n/** This is a sample component to serve as a guide to developers */\npublic class SampleComponent {\n\n    private static Logger log = LoggerFactory.getLogger(SampleComponent.class);\n\n    /**\n     * The class must have a main method, so it can be started as a command line tool\n     *\n     * @param args the arguments.\n     *\n     * @throws Exception\n     * @see AutonomousComponentUtils#parseArgs(String[])\n     */\n    public static void main(String[] args) throws Exception {\n        log.info(\"Starting with args {}\", new Object[]{args});\n\n        //Parse the args to a properties construct\n        Properties properties = AutonomousComponentUtils.parseArgs(args);\n\n        //make a new runnable component from the properties\n        RunnableComponent<Batch> component = new SampleRunnableComponent(properties);\n\n        CallResult<Batch> result = NewspaperBatchAutonomousComponentUtils.startAutonomousComponent(properties,\n                                                                                             component\n                                                                                             );\n        System.out.print(result);\n        System.exit(result.containsFailures());\n    }\n}\n", "es this file to you under the Apache License,\n*  Version 2.0 (the \"License\"); you may not use this file except\n*  in compliance with the License.\n*  You may obtain a copy of the License at\n*\n*    http://www.apache.org/licenses/LICENSE-2.0\n*\n*  Unless required by applicable law or agreed to in writing,\n*  software distributed under the License is distributed on an\n*  \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n*  KIND, either express or implied.  See the License for the\n*  specific language governing permissions and limitations\n*  under the License.\n*/\npackage org.wso2.carbon.transport.jms.test.util;\n\nimport com.atomikos.icatch.jta.UserTransactionManager;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport javax.transaction.SystemException;\nimport javax.transaction.TransactionManager;\n\n/**\n * This class is used for creating and XA transaction Manager for testing XA transaction flow implementation\n * of the JMS transport.\n */\npublic class DistributedTxManagerProvider {\n    private static final Logger logger = LoggerFactory.getLogger(DistributedTxManagerProvider.class);\n    private static DistributedTxManagerProvider distributedTxManagerProvider = null;\n    private TransactionManager transactionManager;\n\n    protected DistributedTxManagerProvider() {\n        try {\n            UserTransactionManager utm = new UserTransactionManager();\n            utm.init();\n            this.transactionManager = utm;\n        } catch (SystemException e) {\n            logger.error(\"Error when creating the XA provider \", e);\n        }\n    }\n\n    public static DistributedTxManagerProvider getInstance() {\n        if (distributedTxManagerProvider == null) {\n            synchronized (DistributedTxManagerProvider.class) {\n                if (distributedTxManagerProvider == null) {\n                    distributedTxManagerProvider = new DistributedTxManagerProvider();\n                }\n            }\n        }\n        return distributedTxManagerProvider;\n    }\n\n    public TransactionManager getTransactionManager() {\n        return this.transactionManager;\n    }\n}\n", "his software\r\n   for any purpose with or without fee is hereby granted, provided\r\n   that the above copyright notice and this permission notice appear\r\n   in all copies.\r\n\r\n   There is NO WARRANTY for this software.  See license.txt for\r\n   details. */\r\n\r\npackage java.security;\r\n\r\npublic class AccessControlException extends SecurityException {\r\n\tprivate final Permission permission;\r\n\r\n\tpublic AccessControlException (String message) {\r\n\t\tthis(message, null);\r\n\t}\r\n\r\n\tpublic AccessControlException (String message, Permission permission) {\r\n\t\tsuper(message);\r\n\t\tthis.permission = permission;\r\n\t}\r\n\r\n\tpublic Permission getPermission () {\r\n\t\treturn permission;\r\n\t}\r\n}\r\n", "ements.  See the NOTICE file distributed with\n * this work for additional information regarding copyright ownership.\n * The ASF licenses this file to You under the Apache License, Version 2.0\n * (the \"License\"); you may not use this file except in compliance with\n * the License.  You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage org.apache.camel.impl.engine;\n\nimport java.util.Map;\n\nimport org.apache.camel.AsyncProducer;\nimport org.apache.camel.CamelContext;\nimport org.apache.camel.Consumer;\nimport org.apache.camel.Endpoint;\nimport org.apache.camel.Exchange;\nimport org.apache.camel.ExchangePattern;\nimport org.apache.camel.PollingConsumer;\nimport org.apache.camel.Processor;\nimport org.apache.camel.Producer;\nimport org.apache.camel.ShutdownableService;\nimport org.apache.camel.spi.InterceptSendToEndpoint;\nimport org.apache.camel.support.service.ServiceHelper;\n\n/**\n * This is an endpoint when sending to it, is intercepted and is routed in a detour\n */\npublic class DefaultInterceptSendToEndpoint implements InterceptSendToEndpoint, ShutdownableService {\n\n    private final Endpoint delegate;\n    private Processor detour;\n    private boolean skip;\n\n    /**\n     * Intercepts sending to the given endpoint\n     *\n     * @param destination  the original endpoint\n     * @param skip <tt>true</tt> to skip sending after the detour to the original endpoint\n     */\n    public DefaultInterceptSendToEndpoint(final Endpoint destination, boolean skip) {\n        this.delegate = destination;\n        this.skip = skip;\n    }\n\n    public void setDetour(Processor detour) {\n        this.detour = detour;\n    }\n\n    @Override\n    public Processor getDetour() {\n        return detour;\n    }\n\n    @Override\n    public Endpoint getOriginalEndpoint() {\n        return delegate;\n    }\n\n    @Override\n    public boolean isSkip() {\n        return skip;\n    }\n\n    public String getEndpointUri() {\n        return delegate.getEndpointUri();\n    }\n\n    public String getEndpointKey() {\n        return delegate.getEndpointKey();\n    }\n\n    public Exchange createExchange() {\n        return delegate.createExchange();\n    }\n\n    public Exchange createExchange(ExchangePattern pattern) {\n        return delegate.createExchange(pattern);\n    }\n\n    public CamelContext getCamelContext() {\n        return delegate.getCamelContext();\n    }\n\n    public Producer createProducer() throws Exception {\n        return createAsyncProducer();\n    }\n\n    @Override\n    public AsyncProducer createAsyncProducer() throws Exception {\n        AsyncProducer producer = delegate.createAsyncProducer();\n        return new InterceptSendToEndpointProcessor(this, delegate, producer, skip);\n    }\n\n    public Consumer createConsumer(Processor processor) throws Exception {\n        return delegate.createConsumer(processor);\n    }\n\n    public PollingConsumer createPollingConsumer() throws Exception {\n        return delegate.createPollingConsumer();\n    }\n\n    public void configureProperties(Map<String, Object> options) {\n        delegate.configureProperties(options);\n    }\n\n    public void setCamelContext(CamelContext context) {\n        delegate.setCamelContext(context);\n    }\n\n    public boolean isLenientProperties() {\n        return delegate.isLenientProperties();\n    }\n\n    public boolean isSingleton() {\n        return delegate.isSingleton();\n    }\n\n    public void start() {\n        ServiceHelper.startService(detour, delegate);\n    }\n\n    public void stop() {\n        ServiceHelper.stopService(delegate, detour);\n    }\n\n    @Override\n    public void shutdown() {\n        ServiceHelper.stopAndShutdownServices(delegate, detour);\n    }\n\n    @Override\n    public String toString() {\n        return delegate.toString();\n    }\n}\n", "and Vrije Universiteit Amsterdam, the Netherlands.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *         http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage science.atlarge.granula.util.json;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.RUNTIME)\n@Target(ElementType.FIELD)\npublic @interface Exclude {\n}\n", ");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.ehcache.clustered.client.config;\n\nimport org.ehcache.config.SizedResourcePool;\nimport org.ehcache.config.units.MemoryUnit;\n\n/**\n * Specifies a {@link ClusteredResourcePool} reserving space from a server-based clustered resource.\n * A {@code FixedClusteredResourcePool} uses dedicated space on the server.\n */\npublic interface DedicatedClusteredResourcePool extends ClusteredResourcePool, SizedResourcePool {\n\n  /**\n   * {@inheritDoc}\n   * @return {@inheritDoc}\n   */\n  @Override\n  MemoryUnit getUnit();\n\n  /**\n   * Identifies the server-side clustered resource from which space for this pool is reserved.\n   * If no server resource is identified, the resource identified in the server configuration as\n   * the default is used.\n   *\n   * @return the server-side clustered resource id; may be {@code null}\n   */\n  String getFromResource();\n}\n", "mport android.text.TextUtils;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\nimport android.widget.CursorAdapter;\nimport android.widget.TextView;\n\nimport com.example.android.pets.data.PetContract;\n\n/**\n * Created by sonu on 18/3/17.\n */\npublic class PetCursorAdapter extends CursorAdapter {\n\n    public PetCursorAdapter(Context context, Cursor c) {\n        super(context, c, 0 /* flags */);\n    }\n\n    @Override\n    public View newView(Context context, Cursor cursor, ViewGroup parent) {\n        return LayoutInflater.from(context).inflate(R.layout.list_item, parent, false);\n    }\n\n    @Override\n    public void bindView(View view, Context context, Cursor cursor) {\n\n        TextView nameTextView = (TextView) view.findViewById(R.id.name);\n        TextView summaryTextView = (TextView) view.findViewById(R.id.summary);\n\n        int nameColumnIndex = cursor.getColumnIndex(PetContract.PetEntry.COLUMN_PET_NAME);\n        int breedColumnIndex = cursor.getColumnIndex(PetContract.PetEntry.COLUMN_PET_BREED);\n        int genderColumnIndex = cursor.getColumnIndex(PetContract.PetEntry.COLUMN_PET_GENDER);\n        int weightColumnIndex = cursor.getColumnIndex(PetContract.PetEntry.COLUMN_PET_WEIGHT);\n\n        String petName = cursor.getString(nameColumnIndex);\n        String petBreed = cursor.getString(breedColumnIndex);\n        String petGender = cursor.getString(genderColumnIndex);\n        String petWeight = cursor.getString(weightColumnIndex);\n\n\n        if (TextUtils.isEmpty(petBreed)) {\n            petBreed = context.getString(R.string.unknown_breed);\n        }\n\n        String gender = \"Unknown Gender\";\n\n        int check_gender = Integer.parseInt(petGender);\n\n        if(check_gender == PetContract.PetEntry.GENDER_MALE){\n            gender = \"Male\";\n        }else if (check_gender == PetContract.PetEntry.GENDER_FEMALE){\n            gender = \"Female\";\n        }\n\n        String summary = \"Breed: \" + petBreed\n                + \"\\nGender: \" + gender\n                + \"\\nWeight: \" + petWeight;\n        nameTextView.setText(petName);\n        summaryTextView.setText(summary);\n    }\n}", "y.BaseIdentifier;\nimport javax.persistence.*;\n\n@Entity\n@Table(name=\"CareTeamIdentifier2\", uniqueConstraints= @UniqueConstraint(name=\"PK_CARE_TEAM_IDENTIFIER\", columnNames={\"CARE_TEAM_IDENTIFIER_ID\"})\n\t\t,indexes = {}\n\t\t)\npublic class CareTeamIdentifier extends BaseIdentifier {\n\n\tpublic CareTeamIdentifier() {\n\t}\n    public CareTeamIdentifier(CareTeamEntity team) {\n\t\tthis.team = team;\n\t}\n\n\n\t@Id \n\t@GeneratedValue(strategy = GenerationType.IDENTITY)\n\t@Column(name= \"CARE_TEAM_IDENTIFIER_ID\")\n    private Long identifierId;\n\n    @ManyToOne(fetch = FetchType.LAZY)\n    @JoinColumn (name = \"CARE_TEAM_ID\",foreignKey= @ForeignKey(name=\"FK_CARE_TEAM_IDENTIFIER_CARE_TEAM_ID\"))\n\n    private CareTeamEntity team;\n\n\n\tpublic Long getIdentifierId() { return identifierId; }\n\tpublic void setIdentifierId(Long identifierId) { this.identifierId = identifierId; }\n\n\tpublic CareTeamEntity getCareTeam() {\n\t\treturn team;\n\t}\n\n\tpublic void setCareTeam(CareTeamEntity team) {\n\t\tthis.team = team;\n\t}\n\n\n}\n", "IViewController;\nimport com.google.googlemobileads.GADCustomEventRequest;\nimport org.moe.natj.general.ann.Generated;\nimport org.moe.natj.general.ann.Library;\nimport org.moe.natj.general.ann.Mapped;\nimport org.moe.natj.general.ann.MappedReturn;\nimport org.moe.natj.general.ann.Runtime;\nimport org.moe.natj.objc.ObjCRuntime;\nimport org.moe.natj.objc.ann.ObjCProtocolName;\nimport org.moe.natj.objc.ann.Selector;\nimport org.moe.natj.objc.map.ObjCObjectMapper;\n\n@Generated\n@Library(\"GoogleMobileAds\")\n@Runtime(ObjCRuntime.class)\n@ObjCProtocolName(\"GADCustomEventNativeAd\")\npublic interface GADCustomEventNativeAd {\n\t@Generated\n\t@Selector(\"delegate\")\n\t@MappedReturn(ObjCObjectMapper.class)\n\tObject delegate();\n\n\t@Generated\n\t@Selector(\"handlesUserClicks\")\n\tboolean handlesUserClicks();\n\n\t@Generated\n\t@Selector(\"handlesUserImpressions\")\n\tboolean handlesUserImpressions();\n\n\t@Generated\n\t@Selector(\"requestNativeAdWithParameter:request:adTypes:options:rootViewController:\")\n\tvoid requestNativeAdWithParameterRequestAdTypesOptionsRootViewController(\n\t\t\tString serverParameter, GADCustomEventRequest request,\n\t\t\tNSArray<?> adTypes, NSArray<?> options,\n\t\t\tUIViewController rootViewController);\n\n\t@Generated\n\t@Selector(\"setDelegate:\")\n\tvoid setDelegate(@Mapped(ObjCObjectMapper.class) Object value);\n}", "file distributed with\n * this work for additional information regarding copyright\n * ownership. Elasticsearch licenses this file to you under\n * the Apache License, Version 2.0 (the \"License\"); you may\n * not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing,\n * software distributed under the License is distributed on an\n * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n * KIND, either express or implied.  See the License for the\n * specific language governing permissions and limitations\n * under the License.\n */\n\npackage org.elasticsearch.index.reindex;\n\nimport org.elasticsearch.ElasticsearchException;\nimport org.elasticsearch.common.Nullable;\nimport org.elasticsearch.common.ParseField;\nimport org.elasticsearch.common.Strings;\nimport org.elasticsearch.common.collect.Tuple;\nimport org.elasticsearch.common.io.stream.StreamInput;\nimport org.elasticsearch.common.io.stream.StreamOutput;\nimport org.elasticsearch.common.io.stream.Writeable;\nimport org.elasticsearch.common.unit.TimeValue;\nimport org.elasticsearch.common.xcontent.ConstructingObjectParser;\nimport org.elasticsearch.common.xcontent.ObjectParser;\nimport org.elasticsearch.common.xcontent.ToXContentObject;\nimport org.elasticsearch.common.xcontent.XContentBuilder;\nimport org.elasticsearch.common.xcontent.XContentParseException;\nimport org.elasticsearch.common.xcontent.XContentParser;\nimport org.elasticsearch.common.xcontent.XContentParser.Token;\nimport org.elasticsearch.tasks.CancellableTask;\nimport org.elasticsearch.tasks.Task;\nimport org.elasticsearch.tasks.TaskId;\nimport org.elasticsearch.tasks.TaskInfo;\n\nimport java.io.IOException;\nimport java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Set;\nimport java.util.concurrent.TimeUnit;\n\nimport static java.lang.Math.min;\nimport static java.util.Collections.emptyList;\nimport static org.elasticsearch.common.unit.TimeValue.timeValueNanos;\nimport static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\nimport static org.elasticsearch.common.xcontent.XContentParserUtils.ensureExpectedToken;\n\n/**\n * Task storing information about a currently running BulkByScroll request.\n *\n * When the request is not sliced, this task is the only task created, and starts an action to perform search requests.\n *\n * When the request is sliced, this task can either represent a coordinating task (using\n * {@link BulkByScrollTask#setWorkerCount(int)}) or a worker task that performs search queries (using\n * {@link BulkByScrollTask#setWorker(float, Integer)}).\n *\n * We don't always know if this task will be a leader or worker task when it's created, because if slices is set to \"auto\" it may\n * be either depending on the number of shards in the source indices. We figure that out when the request is handled and set it on this\n * class with {@link #setWorkerCount(int)} or {@link #setWorker(float, Integer)}.\n */\npublic class BulkByScrollTask extends CancellableTask {\n\n    private volatile LeaderBulkByScrollTaskState leaderState;\n    private volatile WorkerBulkByScrollTaskState workerState;\n\n    public BulkByScrollTask(long id, String type, String action, String description, TaskId parentTaskId, Map<String, String> headers) {\n        super(id, type, action, description, parentTaskId, headers);\n    }\n\n    @Override\n    public BulkByScrollTask.Status getStatus() {\n        if (isLeader()) {\n            return leaderState.getStatus();\n        }\n\n        if (isWorker()) {\n            return workerState.getStatus();\n        }\n\n        return emptyStatus();\n    }\n\n    /**\n     * Build the status for this task given a snapshot of the information of running slices. This is only supported if the task is\n     * set as a leader for slice subtasks\n     */\n    public TaskInfo taskInfoGivenSubtaskInfo(String localNodeId, List<TaskInfo> sliceInfo) {\n        if (isLeader() == false) {\n            throw new IllegalStateException(\"This task is not set to be a leader of other slice subtasks\");\n        }\n\n        List<BulkByScrollTask.StatusOrException> sliceStatuses = Arrays.asList(\n            new BulkByScrollTask.StatusOrException[leaderState.getSlices()]);\n        for (TaskInfo t : sliceInfo) {\n            BulkByScrollTask.Status status = (BulkByScrollTask.Status) t.getStatus();\n            sliceStatuses.set(status.getSliceId(), new BulkByScrollTask.StatusOrException(status));\n        }\n        Status status = leaderState.getStatus(sliceStatuses);\n        return taskInfo(localNodeId, getDescription(), status);\n    }\n\n    private BulkByScrollTask.Status emptyStatus() {\n        return new Status(Collections.emptyList(), getReasonCancelled());\n    }\n\n    /**\n     * Returns true if this task is a leader for other slice subtasks\n     */\n    public boolean isLeader() {\n        return leaderState != null;\n    }\n\n    /**\n     * Sets this task to be a leader task for {@code slices} sliced subtasks\n     */\n    public void setWorkerCount(int slices) {\n        if (isLeader()) {\n            throw new IllegalStateException(\"This task is already a leader for other slice subtasks\");\n        }\n        if (isWorker()) {\n            throw new IllegalStateException(\"This task is already a worker\");\n        }\n\n        leaderState = new LeaderBulkByScrollTaskState(this, slices);\n    }\n\n    /**\n     * Returns the object that tracks the state of sliced subtasks. Throws IllegalStateException if this task is not set to be\n     * a leader task.\n     */\n    public LeaderBulkByScrollTaskState getLeaderState() {\n        if (!isLeader()) {\n            throw new IllegalStateException(\"This task is not set to be a leader for other slice subtasks\");\n        }\n        return leaderState;\n    }\n\n    /**\n     * Returns true if this task is a worker task that performs search requests. False otherwise\n     */\n    public boolean isWorker() {\n        return workerState != null;\n    }\n\n    /**\n     * Sets this task to be a worker task that performs search requests\n     * @param requestsPerSecond How many search requests per second this task should make\n     * @param sliceId If this is is a sliced task, which slice number this task corresponds to. Null if not sliced.\n     */\n    public void setWorker(float requestsPerSecond, @Nullable Integer sliceId) {\n        if (isWorker()) {\n            throw new IllegalStateException(\"This task is already a worker\");\n        }\n        if (isLeader()) {\n            throw new IllegalStateException(\"This task is already a leader for other slice subtasks\");\n        }\n\n        workerState = new WorkerBulkByScrollTaskState(this, sliceId, requestsPerSecond);\n        if (isCancelled()) {\n            workerState.handleCancel();\n        }\n    }\n\n    /**\n     * Returns the object that manages sending search requests. Throws IllegalStateException if this task is not set to be a\n     * worker task.\n     */\n    public WorkerBulkByScrollTaskState getWorkerState() {\n        if (!isWorker()) {\n            throw new IllegalStateException(\"This task is not set to be a worker\");\n        }\n        return workerState;\n    }\n\n    @Override\n    public void onCancelled() {\n        /*\n         * If this task is a leader, we don't need to do anything extra because the cancel action cancels child tasks for us\n         * If it's is a worker, we know how to cancel it here\n         * If we don't know whether it's a leader or worker yet, we do nothing here. If the task is later set to be a worker, we cancel the\n         * worker at that time.\n         */\n        if (isWorker()) {\n            workerState.handleCancel();\n        }\n    }\n\n    @Override\n    public boolean shouldCancelChildrenOnCancellation() {\n        return true;\n    }\n\n    /**\n     * This class acts as a builder for {@link Status}. Once the {@link Status} object is built by calling\n     * {@link #buildStatus()} it is immutable. Used by an instance of {@link ObjectParser} when parsing from\n     * XContent.\n     */\n    public static class StatusBuilder {\n        private Integer sliceId = null;\n        private Long total = null;\n        private long updated = 0; // Not present during deleteByQuery\n        private long created = 0; // Not present during updateByQuery\n        private Long deleted = null;\n        private Integer batches = null;\n        private Long versionConflicts = null;\n        private Long noops = null;\n        private Long bulkRetries = null;\n        private Long searchRetries = null;\n        private TimeValue throttled = null;\n        private Float requestsPerSecond = null;\n        private String reasonCancelled = null;\n        private TimeValue throttledUntil = null;\n        private List<StatusOrException> sliceStatuses = new ArrayList<>();\n\n        public void setSliceId(Integer sliceId) {\n            this.sliceId = sliceId;\n        }\n\n        public void setTotal(Long total) {\n            this.total = total;\n        }\n\n        public void setUpdated(Long updated) {\n            this.updated = updated;\n        }\n\n        public void setCreated(Long created) {\n            this.created = created;\n        }\n\n        public void setDeleted(Long deleted) {\n            this.deleted = deleted;\n        }\n\n        public void setBatches(Integer batches) {\n            this.batches = batches;\n        }\n\n        public void setVersionConflicts(Long versionConflicts) {\n            this.versionConflicts = versionConflicts;\n        }\n\n        public void setNoops(Long noops) {\n            this.noops = noops;\n        }\n\n        public void setRetries(Tuple<Long, Long> retries) {\n            if (retries != null) {\n                setBulkRetries(retries.v1());\n                setSearchRetries(retries.v2());\n            }\n        }\n\n        public void setBulkRetries(Long bulkRetries) {\n            this.bulkRetries = bulkRetries;\n        }\n\n        public void setSearchRetries(Long searchRetries) {\n            this.searchRetries = searchRetries;\n        }\n\n        public void setThrottled(Long throttled) {\n            if (throttled != null) {\n                this.throttled = new TimeValue(throttled, TimeUnit.MILLISECONDS);\n            }\n        }\n\n        public void setRequestsPerSecond(Float requestsPerSecond) {\n            if (requestsPerSecond != null) {\n                requestsPerSecond = requestsPerSecond == -1 ? Float.POSITIVE_INFINITY : requestsPerSecond;\n                this.requestsPerSecond = requestsPerSecond;\n            }\n        }\n\n        public void setReasonCancelled(String reasonCancelled) {\n            this.reasonCancelled = reasonCancelled;\n        }\n\n        public void setThrottledUntil(Long throttledUntil) {\n            if (throttledUntil != null) {\n                this.throttledUntil = new TimeValue(throttledUntil, TimeUnit.MILLISECONDS);\n            }\n        }\n\n        public void setSliceStatuses(List<StatusOrException> sliceStatuses) {\n            if (sliceStatuses != null) {\n                this.sliceStatuses.addAll(sliceStatuses);\n            }\n        }\n\n        public void addToSliceStatuses(StatusOrException statusOrException) {\n            this.sliceStatuses.add(statusOrException);\n        }\n\n        public Status buildStatus() {\n            if (sliceStatuses.isEmpty()) {\n                try {\n                    return new Status(\n                        sliceId, total, updated, created, deleted, batches, versionConflicts, noops, bulkRetries,\n                        searchRetries, throttled, requestsPerSecond, reasonCancelled, throttledUntil\n                    );\n                } catch (NullPointerException npe) {\n                    throw new IllegalArgumentException(\"a required field is null when building Status\");\n                }\n            } else {\n                return new Status(sliceStatuses, reasonCancelled);\n            }\n        }\n    }\n\n    /**\n     * Status of the reindex, update by query, or delete by query. While in\n     * general we allow {@linkplain Task.Status} implementations to make\n     * backwards incompatible changes to their {@link Task.Status#toXContent}\n     * implementations, this one has become defacto standardized because Kibana\n     * parses it. As such, we should be very careful about removing things from\n     * this.\n     */\n    public static class Status implements Task.Status, SuccessfullyProcessed {\n        public static final String NAME = \"bulk-by-scroll\";\n\n        /**\n         * XContent param name to indicate if \"created\" count must be included\n         * in the response.\n         */\n        public static final String INCLUDE_CREATED = \"include_created\";\n\n        /**\n         * XContent param name to indicate if \"updated\" count must be included\n         * in the response.\n         */\n        public static final String INCLUDE_UPDATED = \"include_updated\";\n\n        public static final String SLICE_ID_FIELD = \"slice_id\";\n        public static final String TOTAL_FIELD = \"total\";\n        public static final String UPDATED_FIELD = \"updated\";\n        public static final String CREATED_FIELD = \"created\";\n        public static final String DELETED_FIELD = \"deleted\";\n        public static final String BATCHES_FIELD = \"batches\";\n        public static final String VERSION_CONFLICTS_FIELD = \"version_conflicts\";\n        public static final String NOOPS_FIELD = \"noops\";\n        public static final String RETRIES_FIELD = \"retries\";\n        public static final String RETRIES_BULK_FIELD = \"bulk\";\n        public static final String RETRIES_SEARCH_FIELD = \"search\";\n        public static final String THROTTLED_RAW_FIELD = \"throttled_millis\";\n        public static final String THROTTLED_HR_FIELD = \"throttled\";\n        public static final String REQUESTS_PER_SEC_FIELD = \"requests_per_second\";\n        public static final String CANCELED_FIELD = \"canceled\";\n        public static final String THROTTLED_UNTIL_RAW_FIELD = \"throttled_until_millis\";\n        public static final String THROTTLED_UNTIL_HR_FIELD = \"throttled_until\";\n        public static final String SLICES_FIELD = \"slices\";\n\n        public static Set<String> FIELDS_SET = new HashSet<>();\n        static {\n            FIELDS_SET.add(SLICE_ID_FIELD);\n            FIELDS_SET.add(TOTAL_FIELD);\n            FIELDS_SET.add(UPDATED_FIELD);\n            FIELDS_SET.add(CREATED_FIELD);\n            FIELDS_SET.add(DELETED_FIELD);\n            FIELDS_SET.add(BATCHES_FIELD);\n            FIELDS_SET.add(VERSION_CONFLICTS_FIELD);\n            FIELDS_SET.add(NOOPS_FIELD);\n            FIELDS_SET.add(RETRIES_FIELD);\n            // No need for inner level fields for retries in the set of outer level fields\n            FIELDS_SET.add(THROTTLED_RAW_FIELD);\n            FIELDS_SET.add(THROTTLED_HR_FIELD);\n            FIELDS_SET.add(REQUESTS_PER_SEC_FIELD);\n            FIELDS_SET.add(CANCELED_FIELD);\n            FIELDS_SET.add(THROTTLED_UNTIL_RAW_FIELD);\n            FIELDS_SET.add(THROTTLED_UNTIL_HR_FIELD);\n            FIELDS_SET.add(SLICES_FIELD);\n        }\n\n        @SuppressWarnings(\"unchecked\")\n        static final ConstructingObjectParser<Tuple<Long, Long>, Void> RETRIES_PARSER = new ConstructingObjectParser<>(\n            \"bulk_by_scroll_task_status_retries\",\n            true,\n            a -> new Tuple(a[0], a[1])\n        );\n        static {\n            RETRIES_PARSER.declareLong(constructorArg(), new ParseField(RETRIES_BULK_FIELD));\n            RETRIES_PARSER.declareLong(constructorArg(), new ParseField(RETRIES_SEARCH_FIELD));\n        }\n\n        public static void declareFields(ObjectParser<? extends StatusBuilder, Void> parser) {\n            parser.declareInt(StatusBuilder::setSliceId, new ParseField(SLICE_ID_FIELD));\n            parser.declareLong(StatusBuilder::setTotal, new ParseField(TOTAL_FIELD));\n            parser.declareLong(StatusBuilder::setUpdated, new ParseField(UPDATED_FIELD));\n            parser.declareLong(StatusBuilder::setCreated, new ParseField(CREATED_FIELD));\n            parser.declareLong(StatusBuilder::setDeleted, new ParseField(DELETED_FIELD));\n            parser.declareInt(StatusBuilder::setBatches, new ParseField(BATCHES_FIELD));\n            parser.declareLong(StatusBuilder::setVersionConflicts, new ParseField(VERSION_CONFLICTS_FIELD));\n            parser.declareLong(StatusBuilder::setNoops, new ParseField(NOOPS_FIELD));\n            parser.declareObject(StatusBuilder::setRetries, RETRIES_PARSER, new ParseField(RETRIES_FIELD));\n            parser.declareLong(StatusBuilder::setThrottled, new ParseField(THROTTLED_RAW_FIELD));\n            parser.declareFloat(StatusBuilder::setRequestsPerSecond, new ParseField(REQUESTS_PER_SEC_FIELD));\n            parser.declareString(StatusBuilder::setReasonCancelled, new ParseField(CANCELED_FIELD));\n            parser.declareLong(StatusBuilder::setThrottledUntil, new ParseField(THROTTLED_UNTIL_RAW_FIELD));\n            parser.declareObjectArray(\n                StatusBuilder::setSliceStatuses, (p, c) -> StatusOrException.fromXContent(p), new ParseField(SLICES_FIELD)\n            );\n        }\n\n        private final Integer sliceId;\n        private final long total;\n        private final long updated;\n        private final long created;\n        private final long deleted;\n        private final int batches;\n        private final long versionConflicts;\n        private final long noops;\n        private final long bulkRetries;\n        private final long searchRetries;\n        private final TimeValue throttled;\n        private final float requestsPerSecond;\n        private final String reasonCancelled;\n        private final TimeValue throttledUntil;\n        private final List<StatusOrException> sliceStatuses;\n\n        public Status(Integer sliceId, long total, long updated, long created, long deleted, int batches, long versionConflicts, long noops,\n                long bulkRetries, long searchRetries, TimeValue throttled, float requestsPerSecond, @Nullable String reasonCancelled,\n                TimeValue throttledUntil) {\n            this.sliceId = sliceId == null ? null : checkPositive(sliceId, \"sliceId\");\n            this.total = checkPositive(total, \"total\");\n            this.updated = checkPositive(updated, \"updated\");\n            this.created = checkPositive(created, \"created\");\n            this.deleted = checkPositive(deleted, \"deleted\");\n            this.batches = checkPositive(batches, \"batches\");\n            this.versionConflicts = checkPositive(versionConflicts, \"versionConflicts\");\n            this.noops = checkPositive(noops, \"noops\");\n            this.bulkRetries = checkPositive(bulkRetries, \"bulkRetries\");\n            this.searchRetries = checkPositive(searchRetries, \"searchRetries\");\n            this.throttled = throttled;\n            this.requestsPerSecond = requestsPerSecond;\n            this.reasonCancelled = reasonCancelled;\n            this.throttledUntil = throttledUntil;\n            this.sliceStatuses = emptyList();\n        }\n\n        /**\n         * Constructor merging many statuses.\n         *\n         * @param sliceStatuses Statuses of sub requests that this task was sliced into.\n         * @param reasonCancelled Reason that this *this* task was cancelled. Note that each entry in {@code sliceStatuses} can be cancelled\n         *        independently of this task but if this task is cancelled then the workers *should* be cancelled.\n         */\n        public Status(List<StatusOrException> sliceStatuses, @Nullable String reasonCancelled) {\n            sliceId = null;\n            this.reasonCancelled = reasonCancelled;\n\n            long mergedTotal = 0;\n            long mergedUpdated = 0;\n            long mergedCreated = 0;\n            long mergedDeleted = 0;\n            int mergedBatches = 0;\n            long mergedVersionConflicts = 0;\n            long mergedNoops = 0;\n            long mergedBulkRetries = 0;\n            long mergedSearchRetries = 0;\n            long mergedThrottled = 0;\n            float mergedRequestsPerSecond = 0;\n            long mergedThrottledUntil = Long.MAX_VALUE;\n\n            for (StatusOrException slice : sliceStatuses) {\n                if (slice == null) {\n                    // Hasn't returned yet.\n                    continue;\n                }\n                if (slice.status == null) {\n                    // This slice failed catastrophically so it doesn't count towards the status\n                    continue;\n                }\n                mergedTotal += slice.status.getTotal();\n                mergedUpdated += slice.status.getUpdated();\n                mergedCreated += slice.status.getCreated();\n                mergedDeleted += slice.status.getDeleted();\n                mergedBatches += slice.status.getBatches();\n                mergedVersionConflicts += slice.status.getVersionConflicts();\n                mergedNoops += slice.status.getNoops();\n                mergedBulkRetries += slice.status.getBulkRetries();\n                mergedSearchRetries += slice.status.getSearchRetries();\n                mergedThrottled += slice.status.getThrottled().nanos();\n                mergedRequestsPerSecond += slice.status.getRequestsPerSecond();\n                mergedThrottledUntil = min(mergedThrottledUntil, slice.status.getThrottledUntil().nanos());\n            }\n\n            total = mergedTotal;\n            updated = mergedUpdated;\n            created = mergedCreated;\n            deleted = mergedDeleted;\n            batches = mergedBatches;\n            versionConflicts = mergedVersionConflicts;\n            noops = mergedNoops;\n            bulkRetries = mergedBulkRetries;\n            searchRetries = mergedSearchRetries;\n            throttled = timeValueNanos(mergedThrottled);\n            requestsPerSecond = mergedRequestsPerSecond;\n            throttledUntil = timeValueNanos(mergedThrottledUntil == Long.MAX_VALUE ? 0 : mergedThrottledUntil);\n            this.sliceStatuses = sliceStatuses;\n        }\n\n        public Status(StreamInput in) throws IOException {\n            sliceId = in.readOptionalVInt();\n            total = in.readVLong();\n            updated = in.readVLong();\n            created = in.readVLong();\n            deleted = in.readVLong();\n            batches = in.readVInt();\n            versionConflicts = in.readVLong();\n            noops = in.readVLong();\n            bulkRetries = in.readVLong();\n            searchRetries = in.readVLong();\n            throttled = in.readTimeValue();\n            requestsPerSecond = in.readFloat();\n            reasonCancelled = in.readOptionalString();\n            throttledUntil = in.readTimeValue();\n            sliceStatuses = in.readList(stream -> stream.readOptionalWriteable(StatusOrException::new));\n        }\n\n        @Override\n        public void writeTo(StreamOutput out) throws IOException {\n            out.writeOptionalVInt(sliceId);\n            out.writeVLong(total);\n            out.writeVLong(updated);\n            out.writeVLong(created);\n            out.writeVLong(deleted);\n            out.writeVInt(batches);\n            out.writeVLong(versionConflicts);\n            out.writeVLong(noops);\n            out.writeVLong(bulkRetries);\n            out.writeVLong(searchRetries);\n            out.writeTimeValue(throttled);\n            out.writeFloat(requestsPerSecond);\n            out.writeOptionalString(reasonCancelled);\n            out.writeTimeValue(throttledUntil);\n            out.writeVInt(sliceStatuses.size());\n            for (StatusOrException sliceStatus : sliceStatuses) {\n                out.writeOptionalWriteable(sliceStatus);\n            }\n        }\n\n        @Override\n        public String getWriteableName() {\n            return NAME;\n        }\n\n        @Override\n        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n            builder.startObject();\n            innerXContent(builder, params);\n            return builder.endObject();\n        }\n\n        /**\n         * We need to write a manual parser for this because of {@link StatusOrException}. Since\n         * {@link StatusOrException#fromXContent(XContentParser)} tries to peek at a field first before deciding\n         * what needs to be it cannot use an {@link ObjectParser}.\n         */\n        public XContentBuilder innerXContent(XContentBuilder builder, Params params)\n                throws IOException {\n            if (sliceId != null) {\n                builder.field(SLICE_ID_FIELD, sliceId);\n            }\n            builder.field(TOTAL_FIELD, total);\n            if (params.paramAsBoolean(INCLUDE_UPDATED, true)) {\n                builder.field(UPDATED_FIELD, updated);\n            }\n            if (params.paramAsBoolean(INCLUDE_CREATED, true)) {\n                builder.field(CREATED_FIELD, created);\n            }\n            builder.field(DELETED_FIELD, deleted);\n            builder.field(BATCHES_FIELD, batches);\n            builder.field(VERSION_CONFLICTS_FIELD, versionConflicts);\n            builder.field(NOOPS_FIELD, noops);\n            builder.startObject(RETRIES_FIELD); {\n                builder.field(RETRIES_BULK_FIELD, bulkRetries);\n                builder.field(RETRIES_SEARCH_FIELD, searchRetries);\n            }\n            builder.endObject();\n            builder.humanReadableField(THROTTLED_RAW_FIELD, THROTTLED_HR_FIELD, throttled);\n            builder.field(REQUESTS_PER_SEC_FIELD, requestsPerSecond == Float.POSITIVE_INFINITY ? -1 : requestsPerSecond);\n            if (reasonCancelled != null) {\n                builder.field(CANCELED_FIELD, reasonCancelled);\n            }\n            builder.humanReadableField(THROTTLED_UNTIL_RAW_FIELD, THROTTLED_UNTIL_HR_FIELD, throttledUntil);\n            if (false == sliceStatuses.isEmpty()) {\n                builder.startArray(SLICES_FIELD);\n                for (StatusOrException slice : sliceStatuses) {\n                    if (slice == null) {\n                        builder.nullValue();\n                    } else {\n                        slice.toXContent(builder, params);\n                    }\n                }\n                builder.endArray();\n            }\n            return builder;\n        }\n\n        public static Status fromXContent(XContentParser parser) throws IOException {\n            XContentParser.Token token;\n            if (parser.currentToken() == Token.START_OBJECT) {\n                 token = parser.nextToken();\n            } else {\n                token = parser.nextToken();\n            }\n            ensureExpectedToken(Token.START_OBJECT, token, parser);\n            token = parser.nextToken();\n            ensureExpectedToken(Token.FIELD_NAME, token, parser);\n            return innerFromXContent(parser);\n        }\n\n        public static Status innerFromXContent(XContentParser parser) throws IOException {\n            Token token = parser.currentToken();\n            String fieldName = parser.currentName();\n            ensureExpectedToken(XContentParser.Token.FIELD_NAME, token, parser);\n            StatusBuilder builder = new StatusBuilder();\n            while ((token = parser.nextToken()) != Token.END_OBJECT) {\n                if (token == Token.FIELD_NAME) {\n                    fieldName = parser.currentName();\n                } else if (token == Token.START_OBJECT) {\n                    if (fieldName.equals(Status.RETRIES_FIELD)) {\n                        builder.setRetries(Status.RETRIES_PARSER.parse(parser, null));\n                    } else {\n                        parser.skipChildren();\n                    }\n                } else if (token == Token.START_ARRAY) {\n                    if (fieldName.equals(Status.SLICES_FIELD)) {\n                        while ((token = parser.nextToken()) != Token.END_ARRAY) {\n                            builder.addToSliceStatuses(StatusOrException.fromXContent(parser));\n                        }\n                    } else {\n                        parser.skipChildren();\n                    }\n                } else { // else if it is a value\n                    switch (fieldName) {\n                        case Status.SLICE_ID_FIELD:\n                            builder.setSliceId(parser.intValue());\n                            break;\n                        case Status.TOTAL_FIELD:\n                            builder.setTotal(parser.longValue());\n                            break;\n                        case Status.UPDATED_FIELD:\n                            builder.setUpdated(parser.longValue());\n                            break;\n                        case Status.CREATED_FIELD:\n                            builder.setCreated(parser.longValue());\n                            break;\n                        case Status.DELETED_FIELD:\n                            builder.setDeleted(parser.longValue());\n                            break;\n                        case Status.BATCHES_FIELD:\n                            builder.setBatches(parser.intValue());\n                            break;\n                        case Status.VERSION_CONFLICTS_FIELD:\n                            builder.setVersionConflicts(parser.longValue());\n                            break;\n                        case Status.NOOPS_FIELD:\n                            builder.setNoops(parser.longValue());\n                            break;\n                        case Status.THROTTLED_RAW_FIELD:\n                            builder.setThrottled(parser.longValue());\n                            break;\n                        case Status.REQUESTS_PER_SEC_FIELD:\n                            builder.setRequestsPerSecond(parser.floatValue());\n                            break;\n                        case Status.CANCELED_FIELD:\n                            builder.setReasonCancelled(parser.text());\n                            break;\n                        case Status.THROTTLED_UNTIL_RAW_FIELD:\n                            builder.setThrottledUntil(parser.longValue());\n                            break;\n                        default:\n                            break;\n                    }\n                }\n            }\n            return builder.buildStatus();\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder builder = new StringBuilder();\n            builder.append(\"BulkIndexByScrollResponse[\");\n            innerToString(builder);\n            return builder.append(']').toString();\n        }\n\n        public void innerToString(StringBuilder builder) {\n            builder.append(\"sliceId=\").append(sliceId);\n            builder.append(\",updated=\").append(updated);\n            builder.append(\",created=\").append(created);\n            builder.append(\",deleted=\").append(deleted);\n            builder.append(\",batches=\").append(batches);\n            builder.append(\",versionConflicts=\").append(versionConflicts);\n            builder.append(\",noops=\").append(noops);\n            builder.append(\",retries=\").append(bulkRetries);\n            if (reasonCancelled != null) {\n                builder.append(\",canceled=\").append(reasonCancelled);\n            }\n            builder.append(\",throttledUntil=\").append(throttledUntil);\n            if (false == sliceStatuses.isEmpty()) {\n                builder.append(\",workers=\").append(sliceStatuses);\n            }\n        }\n\n        /**\n         * The id of the slice that this status is reporting or {@code null} if this isn't the status of a sub-slice.\n         */\n        Integer getSliceId() {\n            return sliceId;\n        }\n\n        /**\n         * The total number of documents this request will process. 0 means we don't yet know or, possibly, there are actually 0 documents\n         * to process. Its ok that these have the same meaning because any request with 0 actual documents should be quite short lived.\n         */\n        public long getTotal() {\n            return total;\n        }\n\n        @Override\n        public long getUpdated() {\n            return updated;\n        }\n\n        @Override\n        public long getCreated() {\n            return created;\n        }\n\n        @Override\n        public long getDeleted() {\n            return deleted;\n        }\n\n        /**\n         * Number of scan responses this request has processed.\n         */\n        public int getBatches() {\n            return batches;\n        }\n\n        /**\n         * Number of version conflicts this request has hit.\n         */\n        public long getVersionConflicts() {\n            return versionConflicts;\n        }\n\n        /**\n         * Number of noops (skipped bulk items) as part of this request.\n         */\n        public long getNoops() {\n            return noops;\n        }\n\n        /**\n         * Number of retries that had to be attempted due to bulk actions being rejected.\n         */\n        public long getBulkRetries() {\n            return bulkRetries;\n        }\n\n        /**\n         * Number of retries that had to be attempted due to search actions being rejected.\n         */\n        public long getSearchRetries() {\n            return searchRetries;\n        }\n\n        /**\n         * The total time this request has throttled itself not including the current throttle time if it is currently sleeping.\n         */\n        public TimeValue getThrottled() {\n            return throttled;\n        }\n\n        /**\n         * The number of requests per second to which to throttle the request. Float.POSITIVE_INFINITY means unlimited.\n         */\n        public float getRequestsPerSecond() {\n            return requestsPerSecond;\n        }\n\n        /**\n         * The reason that the request was canceled or null if it hasn't been.\n         */\n        public String getReasonCancelled() {\n            return reasonCancelled;\n        }\n\n        /**\n         * Remaining delay of any current throttle sleep or 0 if not sleeping.\n         */\n        public TimeValue getThrottledUntil() {\n            return throttledUntil;\n        }\n\n        /**\n         * Statuses of the sub requests into which this sub-request was sliced. Empty if this request wasn't sliced into sub-requests.\n         */\n        public List<StatusOrException> getSliceStatuses() {\n            return sliceStatuses;\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(\n                sliceId, total, updated, created, deleted, batches, versionConflicts, noops, searchRetries,\n                bulkRetries, throttled, requestsPerSecond, reasonCancelled, throttledUntil, sliceStatuses\n            );\n        }\n\n        public boolean equalsWithoutSliceStatus(Object o, boolean includeUpdated, boolean includeCreated) {\n            if (this == o) return true;\n            if (o == null || getClass() != o.getClass()) return false;\n            Status other = (Status) o;\n            return\n                Objects.equals(sliceId, other.sliceId) &&\n                    total == other.total &&\n                    (!includeUpdated || updated == other.updated) &&\n                    (!includeCreated || created == other.created) &&\n                    deleted == other.deleted &&\n                    batches == other.batches &&\n                    versionConflicts == other.versionConflicts &&\n                    noops == other.noops &&\n                    searchRetries == other.searchRetries &&\n                    bulkRetries == other.bulkRetries &&\n                    Objects.equals(throttled, other.throttled) &&\n                    requestsPerSecond == other.requestsPerSecond &&\n                    Objects.equals(reasonCancelled, other.reasonCancelled) &&\n                    Objects.equals(throttledUntil, other.throttledUntil);\n        }\n\n        @Override\n        public boolean equals(Object o) {\n            if (equalsWithoutSliceStatus(o, true, true)) {\n                return Objects.equals(sliceStatuses, ((Status) o).sliceStatuses);\n            } else {\n                return false;\n            }\n        }\n\n        private int checkPositive(int value, String name) {\n            if (value < 0) {\n                throw new IllegalArgumentException(name + \" must be greater than 0 but was [\" + value + \"]\");\n            }\n            return value;\n        }\n\n        private long checkPositive(long value, String name) {\n            if (value < 0) {\n                throw new IllegalArgumentException(name + \" must be greater than 0 but was [\" + value + \"]\");\n            }\n            return value;\n        }\n    }\n\n    /**\n     * The status of a slice of the request. Successful requests store the {@link StatusOrException#status} while failing requests store a\n     * {@link StatusOrException#exception}.\n     */\n    public static class StatusOrException implements Writeable, ToXContentObject {\n        private final Status status;\n        private final Exception exception;\n\n        public static Set<String> EXPECTED_EXCEPTION_FIELDS = new HashSet<>();\n        static {\n            EXPECTED_EXCEPTION_FIELDS.add(\"type\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"reason\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"caused_by\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"suppressed\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"stack_trace\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"header\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"error\");\n            EXPECTED_EXCEPTION_FIELDS.add(\"root_cause\");\n        }\n\n\n        public StatusOrException(Status status) {\n            this.status = status;\n            exception = null;\n        }\n\n        public StatusOrException(Exception exception) {\n            status = null;\n            this.exception = exception;\n        }\n\n        /**\n         * Read from a stream.\n         */\n        public StatusOrException(StreamInput in) throws IOException {\n            if (in.readBoolean()) {\n                status = new Status(in);\n                exception = null;\n            } else {\n                status = null;\n                exception = in.readException();\n            }\n        }\n\n        @Override\n        public void writeTo(StreamOutput out) throws IOException {\n            if (exception == null) {\n                out.writeBoolean(true);\n                status.writeTo(out);\n            } else {\n                out.writeBoolean(false);\n                out.writeException(exception);\n            }\n        }\n\n        public Status getStatus() {\n            return status;\n        }\n\n        public Exception getException() {\n            return exception;\n        }\n\n        @Override\n        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n            if (exception == null) {\n                status.toXContent(builder, params);\n            } else {\n                builder.startObject();\n                ElasticsearchException.generateThrowableXContent(builder, params, exception);\n                builder.endObject();\n            }\n            return builder;\n        }\n\n        /**\n         * Since {@link StatusOrException} can contain either an {@link Exception} or a {@link Status} we need to peek\n         * at a field first before deciding what needs to be parsed since the same object could contains either.\n         * The {@link #EXPECTED_EXCEPTION_FIELDS} contains the fields that are expected when the serialised object\n         * was an instance of exception and the {@link Status#FIELDS_SET} is the set of fields expected when the\n         * serialized object was an instance of Status.\n         */\n        public static StatusOrException fromXContent(XContentParser parser) throws IOException {\n            XContentParser.Token token = parser.currentToken();\n            if (token == null) {\n                token = parser.nextToken();\n            }\n            if (token == Token.VALUE_NULL) {\n                return null;\n            } else {\n                ensureExpectedToken(XContentParser.Token.START_OBJECT, token, parser);\n                token = parser.nextToken();\n                // This loop is present only to ignore unknown tokens. It breaks as soon as we find a field\n                // that is allowed.\n                while (token != Token.END_OBJECT) {\n                    ensureExpectedToken(Token.FIELD_NAME, token, parser);\n                    String fieldName = parser.currentName();\n                    // weird way to ignore unknown tokens\n                    if (Status.FIELDS_SET.contains(fieldName)) {\n                        return new StatusOrException(\n                            Status.innerFromXContent(parser)\n                        );\n                    } else if (EXPECTED_EXCEPTION_FIELDS.contains(fieldName)){\n                        return new StatusOrException(ElasticsearchException.innerFromXContent(parser, false));\n                    } else {\n                        // Ignore unknown tokens\n                        token = parser.nextToken();\n                        if (token == Token.START_OBJECT || token == Token.START_ARRAY) {\n                            parser.skipChildren();\n                        }\n                        token = parser.nextToken();\n                    }\n                }\n                throw new XContentParseException(\"Unable to parse StatusFromException. Expected fields not found.\");\n            }\n        }\n\n        @Override\n        public String toString() {\n            if (exception != null) {\n                return \"BulkByScrollTask{error=\" + Strings.toString(this) + \"}\";\n            } else {\n                return \"BulkByScrollTask{status=\" + Strings.toString(this) + \"}\";\n            }\n        }\n\n        @Override\n        public boolean equals(Object obj) {\n            if (obj == null) {\n                return false;\n            }\n            if (obj.getClass() != BulkByScrollTask.StatusOrException.class) {\n                return false;\n            }\n            BulkByScrollTask.StatusOrException other = (StatusOrException) obj;\n            return Objects.equals(status, other.status)\n                    && Objects.equals(exception, other.exception);\n        }\n\n        @Override\n        public int hashCode() {\n            return Objects.hash(status, exception);\n        }\n    }\n\n}\n", "e Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * <p/>\n * http://www.apache.org/licenses/LICENSE-2.0\n * <p/>\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage net.bither.bitherj.crypto.hd;\n\nimport com.google.common.base.Objects;\nimport com.google.common.base.Objects.ToStringHelper;\nimport com.google.common.collect.ImmutableList;\n\nimport net.bither.bitherj.crypto.ECKey;\nimport net.bither.bitherj.crypto.KeyCrypter;\nimport net.bither.bitherj.crypto.KeyCrypterException;\nimport net.bither.bitherj.utils.Sha256Hash;\nimport net.bither.bitherj.utils.Utils;\n\nimport org.spongycastle.crypto.params.KeyParameter;\nimport org.spongycastle.math.ec.ECPoint;\n\nimport java.math.BigInteger;\nimport java.util.Arrays;\n\nimport javax.annotation.Nullable;\n\nimport static com.google.common.base.Preconditions.checkArgument;\nimport static com.google.common.base.Preconditions.checkNotNull;\nimport static com.google.common.base.Preconditions.checkState;\n\n/**\n * A deterministic key is a node in a {@link DeterministicHierarchy}. As per\n * <a href=\"https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki\">the BIP 32 specification</a> it is a pair\n * (key, chaincode). If you know its path in the tree and its chain code you can derive more keys from this. To obtain\n * one of these, you can call {@link HDKeyDerivation#createMasterPrivateKey(byte[])}.\n */\npublic class DeterministicKey extends ECKey {\n    private static final long serialVersionUID = 1L;\n\n    private final DeterministicKey parent;\n    private final ImmutableList<ChildNumber> childNumberPath;\n\n    /**\n     * 32 bytes\n     */\n    private final byte[] chainCode;\n\n    /**\n     * Constructs a key from its components. This is not normally something you should use.\n     */\n    public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,\n                            byte[] chainCode,\n                            ECPoint publicAsPoint,\n                            @Nullable BigInteger priv,\n                            @Nullable DeterministicKey parent) {\n        super(priv, compressPoint(checkNotNull(publicAsPoint)).getEncoded(), true);\n        checkArgument(chainCode.length == 32);\n        this.parent = parent;\n        this.childNumberPath = checkNotNull(childNumberPath);\n        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);\n    }\n\n    public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,\n                            byte[] chainCode,\n                            byte[] pub,\n                            @Nullable BigInteger priv,\n                            @Nullable DeterministicKey parent) {\n        super(priv, pub, true);\n        checkArgument(chainCode.length == 32);\n        this.parent = parent;\n        this.childNumberPath = checkNotNull(childNumberPath);\n        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);\n    }\n\n    /**\n     * Constructs a key from its components. This is not normally something you should use.\n     */\n    public DeterministicKey(ImmutableList<ChildNumber> childNumberPath,\n                            byte[] chainCode,\n                            BigInteger priv,\n                            @Nullable DeterministicKey parent) {\n        super(priv);\n        checkArgument(chainCode.length == 32);\n        this.parent = parent;\n        this.childNumberPath = checkNotNull(childNumberPath);\n        this.chainCode = Arrays.copyOf(chainCode, chainCode.length);\n    }\n\n    /**\n     * Returns the path through some {@link DeterministicHierarchy} which reaches this keys position in the tree.\n     * A path can be written as 1/2/1 which means the first child of the root, the second child of that node, then\n     * the first child of that node.\n     */\n    public ImmutableList<ChildNumber> getPath() {\n        return childNumberPath;\n    }\n\n    /**\n     * Returns the path of this key as a human readable string starting with M to indicate the master key.\n     */\n    public String getPathAsString() {\n        return HDUtils.formatPath(getPath());\n    }\n\n    private int getDepth() {\n        return childNumberPath.size();\n    }\n\n    /**\n     * Returns the last element of the path returned by {@link net.bither.bitherj.crypto.hd.DeterministicKey#getPath()}\n     */\n    public ChildNumber getChildNumber() {\n        return getDepth() == 0 ? ChildNumber.ZERO : childNumberPath.get(childNumberPath.size() - 1);\n    }\n\n    /**\n     * Returns the chain code associated with this key. See the specification to learn more about chain codes.\n     */\n    public byte[] getChainCode() {\n        return chainCode;\n    }\n\n    /**\n     * Returns RIPE-MD160(SHA256(pub key bytes)).\n     */\n    public byte[] getIdentifier() {\n        return new Sha256Hash(getPubKey()).getBytes();\n    }\n\n    /**\n     * Returns the first 32 bits of the result of {@link #getIdentifier()}.\n     */\n    public byte[] getFingerprint() {\n        // TODO: why is this different than armory's fingerprint? BIP 32: \"The first 32 bits of the identifier are called the fingerprint.\"\n        return Arrays.copyOfRange(getIdentifier(), 0, 4);\n    }\n\n    @Nullable\n    public DeterministicKey getParent() {\n        return parent;\n    }\n\n    /**\n     * Returns private key bytes, padded with zeros to 33 bytes.\n     *\n     * @throws IllegalStateException if the private key bytes are missing.\n     */\n    public byte[] getPrivKeyBytes33() {\n        byte[] bytes33 = new byte[33];\n        byte[] priv = getPrivKeyBytes();\n        System.arraycopy(priv, 0, bytes33, 33 - priv.length, priv.length);\n        return bytes33;\n    }\n\n    /**\n     * Returns the same key with the private part removed. May return the same instance.\n     */\n    public DeterministicKey getPubOnly() {\n        if (isPubKeyOnly()) return this;\n        return new DeterministicKey(getPath(), getChainCode(), pub, null, parent);\n    }\n\n\n    static byte[] addChecksum(byte[] input) {\n        int inputLength = input.length;\n        byte[] checksummed = new byte[inputLength + 4];\n        System.arraycopy(input, 0, checksummed, 0, inputLength);\n        byte[] checksum = Utils.doubleDigest(input);\n        System.arraycopy(checksum, 0, checksummed, inputLength, 4);\n        return checksummed;\n    }\n\n//    @Override\n//    public DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {\n//        throw new UnsupportedOperationException(\"Must supply a new parent for encryption\");\n//    }\n//\n//    public DeterministicKey encrypt(KeyCrypter keyCrypter, KeyParameter aesKey, @Nullable DeterministicKey newParent) throws KeyCrypterException {\n//        // Same as the parent code, except we construct a DeterministicKey instead of an ECKey.\n//        checkNotNull(keyCrypter);\n//        if (newParent != null)\n//            checkArgument(newParent.isEncrypted());\n//        final byte[] privKeyBytes = getPrivKeyBytes();\n//        checkState(privKeyBytes != null, \"Private key is not available\");\n//        EncryptedPrivateKey encryptedPrivateKey = keyCrypter.encrypt(privKeyBytes, aesKey);\n//        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, keyCrypter, pub, encryptedPrivateKey, newParent);\n//        return key;\n//    }\n\n    /**\n     * A deterministic key is considered to be encrypted if it has access to encrypted private key bytes, OR if its\n     * parent does. The reason is because the parent would be encrypted under the same key and this key knows how to\n     * rederive its own private key bytes from the parent, if needed.\n     */\n    @Override\n    public boolean isEncrypted() {\n        return priv == null && (super.isEncrypted() || (parent != null && parent.isEncrypted()));\n    }\n\n    /**\n     * Returns this keys {@link net.bither.bitherj.crypto.KeyCrypter} <b>or</b> the keycrypter of its parent key.\n     */\n    @Override\n    @Nullable\n    public KeyCrypter getKeyCrypter() {\n        if (keyCrypter != null)\n            return keyCrypter;\n        else if (parent != null)\n            return parent.getKeyCrypter();\n        else\n            return null;\n    }\n\n//    @Override\n//    public ECDSASignature sign(Sha256Hash input, @Nullable KeyParameter aesKey) throws KeyCrypterException {\n//        if (isEncrypted()) {\n//            // If the key is encrypted, ECKey.sign will decrypt it first before rerunning sign. Decryption walks the\n//            // key heirarchy to find the private key (see below), so, we can just run the inherited method.\n//            return super.sign(input, aesKey);\n//        } else {\n//            // If it's not encrypted, derive the private via the parents.\n//            final BigInteger privateKey = findOrDerivePrivateKey();\n//            if (privateKey == null) {\n//                // This key is a part of a public-key only heirarchy and cannot be used for signing\n//                throw new MissingPrivateKeyException();\n//            }\n//            return super.doSign(input, privateKey);\n//        }\n//    }\n\n    @Override\n    public DeterministicKey decrypt(KeyCrypter keyCrypter, KeyParameter aesKey) throws KeyCrypterException {\n        checkNotNull(keyCrypter);\n        // Check that the keyCrypter matches the one used to encrypt the keys, if set.\n        if (this.keyCrypter != null && !this.keyCrypter.equals(keyCrypter))\n            throw new KeyCrypterException(\"The keyCrypter being used to decrypt the key is different to the one that was used to encrypt it\");\n        BigInteger privKey = findOrDeriveEncryptedPrivateKey(keyCrypter, aesKey);\n        DeterministicKey key = new DeterministicKey(childNumberPath, chainCode, privKey, parent);\n        if (!Arrays.equals(key.getPubKey(), getPubKey()))\n            throw new KeyCrypterException(\"Provided AES key is wrong\");\n        return key;\n    }\n\n    // For when a key is encrypted, either decrypt our encrypted private key bytes, or work up the tree asking parents\n    // to decrypt and re-derive.\n    private BigInteger findOrDeriveEncryptedPrivateKey(KeyCrypter keyCrypter, KeyParameter aesKey) {\n        if (encryptedPrivateKey != null)\n            return new BigInteger(1, keyCrypter.decrypt(encryptedPrivateKey, aesKey));\n        // Otherwise we don't have it, but maybe we can figure it out from our parents. Walk up the tree looking for\n        // the first key that has some encrypted private key data.\n        DeterministicKey cursor = parent;\n        while (cursor != null) {\n            if (cursor.encryptedPrivateKey != null) break;\n            cursor = cursor.parent;\n        }\n        if (cursor == null)\n            throw new KeyCrypterException(\"Neither this key nor its parents have an encrypted private key\");\n        byte[] parentalPrivateKeyBytes = keyCrypter.decrypt(cursor.encryptedPrivateKey, aesKey);\n        return derivePrivateKeyDownwards(cursor, parentalPrivateKeyBytes);\n    }\n\n    @Nullable\n    private BigInteger findOrDerivePrivateKey() {\n        DeterministicKey cursor = this;\n        while (cursor != null) {\n            if (cursor.priv != null) break;\n            cursor = cursor.parent;\n        }\n        if (cursor == null)\n            return null;\n        return derivePrivateKeyDownwards(cursor, cursor.priv.toByteArray());\n    }\n\n    private BigInteger derivePrivateKeyDownwards(DeterministicKey cursor, byte[] parentalPrivateKeyBytes) {\n        DeterministicKey downCursor = new DeterministicKey(cursor.childNumberPath, cursor.chainCode,\n                cursor.pub, new BigInteger(1, parentalPrivateKeyBytes), cursor.parent);\n        // Now we have to rederive the keys along the path back to ourselves. That path can be found by just truncating\n        // our path with the length of the parents path.\n        ImmutableList<ChildNumber> path = childNumberPath.subList(cursor.getDepth(), childNumberPath.size());\n        for (ChildNumber num : path) {\n            downCursor = HDKeyDerivation.deriveChildKey(downCursor, num);\n        }\n        // downCursor is now the same key as us, but with private key bytes.\n        checkState(downCursor.pub.equals(pub));\n        return checkNotNull(downCursor.priv);\n    }\n\n\n    public DeterministicKey deriveSoftened(int child) {\n        return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, false));\n    }\n\n    public DeterministicKey deriveHardened(int child) {\n        return HDKeyDerivation.deriveChildKey(this, new ChildNumber(child, true));\n    }\n\n    /**\n     * Returns the private key of this deterministic key. Even if this object isn't storing the private key,\n     * it can be re-derived by walking up to the parents if necessary and this is what will happen.\n     *\n     * @throws IllegalStateException if the parents are encrypted or a watching chain.\n     */\n    public BigInteger getPrivKey() {\n        final BigInteger key = findOrDerivePrivateKey();\n        checkState(key != null, \"Private key bytes not available\");\n        return key;\n    }\n\n    /**\n     * Verifies equality of all fields but NOT the parent pointer (thus the same key derived in two separate heirarchy\n     * objects will equal each other.\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        DeterministicKey other = (DeterministicKey) o;\n\n        return super.equals(other)\n                && Arrays.equals(this.chainCode, other.chainCode)\n                && Objects.equal(this.childNumberPath, other.childNumberPath);\n    }\n\n    @Override\n    public int hashCode() {\n        int result = super.hashCode();\n        result = 31 * result + childNumberPath.hashCode();\n        result = 31 * result + Arrays.hashCode(chainCode);\n        return result;\n    }\n\n    @Override\n    public String toString() {\n        final ToStringHelper helper = Objects.toStringHelper(this).omitNullValues();\n        helper.add(\"pub\", Utils.bytesToHexString(pub));\n        helper.add(\"chainCode\", Utils.bytesToHexString(chainCode));\n        helper.add(\"path\", getPathAsString());\n        if (creationTimeSeconds > 0)\n            helper.add(\"creationTimeSeconds\", creationTimeSeconds);\n        helper.add(\"isEncrypted\", isEncrypted());\n        helper.add(\"isPubKeyOnly\", isPubKeyOnly());\n        return helper.toString();\n    }\n\n    @Override\n    public void clearPrivateKey() {\n        super.clearPrivateKey();\n        priv = null;\n    }\n\n    public void clearChainCode() {\n        Utils.wipeBytes(chainCode);\n    }\n\n    public byte[] getPubKeyExtended() {\n        byte[] pub = getPubKey();\n        byte[] chainCode = getChainCode();\n        byte[] extended = new byte[pub.length + chainCode.length];\n        for (int i = 0; i < pub.length; i++) {\n            extended[i] = pub[i];\n        }\n        for (int i = 0; i < chainCode.length; i++) {\n            extended[i + pub.length] = chainCode[i];\n        }\n        return extended;\n    }\n\n    public void wipe() {\n        clearPrivateKey();\n        clearChainCode();\n        Utils.wipeBytes(pub);\n    }\n}\n", "ements. See the NOTICE file distributed with this work for additional information regarding\n * copyright ownership. The ASF licenses this file to You under the Apache License, Version 2.0 (the\n * \"License\"); you may not use this file except in compliance with the License. You may obtain a\n * copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software distributed under the License\n * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n * or implied. See the License for the specific language governing permissions and limitations under\n * the License.\n */\npackage org.apache.geode.cache.query.internal;\n\nimport java.io.DataInput;\nimport java.io.DataOutput;\nimport java.io.IOException;\nimport java.util.AbstractCollection;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Comparator;\nimport java.util.HashSet;\nimport java.util.Iterator;\nimport java.util.List;\nimport java.util.NoSuchElementException;\nimport java.util.Set;\n\nimport org.apache.geode.DataSerializer;\nimport org.apache.geode.cache.query.SelectResults;\nimport org.apache.geode.cache.query.Struct;\nimport org.apache.geode.cache.query.internal.types.CollectionTypeImpl;\nimport org.apache.geode.cache.query.internal.types.StructTypeImpl;\nimport org.apache.geode.cache.query.internal.utils.LimitIterator;\nimport org.apache.geode.cache.query.types.CollectionType;\nimport org.apache.geode.cache.query.types.ObjectType;\nimport org.apache.geode.internal.DataSerializableFixedID;\nimport org.apache.geode.internal.HeapDataOutputStream;\nimport org.apache.geode.internal.HeapDataOutputStream.LongUpdater;\nimport org.apache.geode.internal.Version;\n\n/**\n * The n - way merge results returns a sorted results on the cumulative sorted results for\n * partitioned region based query\n *\n *\n */\npublic class NWayMergeResults<E> implements SelectResults<E>, Ordered, DataSerializableFixedID {\n  private CollectionType collectionType;\n  private Collection<E> data;\n  private boolean isDistinct;\n\n  public NWayMergeResults() {}\n\n  public NWayMergeResults(Collection<? extends Collection<E>> sortedResults, boolean isDistinct,\n      int limit, List<CompiledSortCriterion> orderByAttribs, ExecutionContext context,\n      ObjectType elementType) {\n\n    this.isDistinct = isDistinct;\n    this.collectionType = new CollectionTypeImpl(Ordered.class, elementType);\n    this.data = new NWayMergeResultsCollection(sortedResults, limit, orderByAttribs, context);\n\n  }\n\n  @Override\n  public int size() {\n    return this.data.size();\n  }\n\n  @Override\n  public boolean isEmpty() {\n    return this.data.isEmpty();\n  }\n\n  @Override\n  public boolean contains(Object o) {\n    return this.data.contains(o);\n  }\n\n  @Override\n  public Iterator<E> iterator() {\n    return this.data.iterator();\n  }\n\n  @Override\n  public Object[] toArray() {\n    return this.data.toArray();\n  }\n\n  @Override\n  public <T> T[] toArray(T[] a) {\n    return this.data.toArray(a);\n  }\n\n  @Override\n  public boolean add(E e) {\n    throw new UnsupportedOperationException(\"Addition to collection not supported\");\n  }\n\n  @Override\n  public boolean remove(Object o) {\n    throw new UnsupportedOperationException(\"Removal from collection not supported\");\n  }\n\n  @Override\n  public boolean containsAll(Collection<?> c) {\n    return this.data.containsAll(c);\n  }\n\n  @Override\n  public boolean addAll(Collection<? extends E> c) {\n    throw new UnsupportedOperationException(\"Addition to collection not supported\");\n  }\n\n  @Override\n  public boolean removeAll(Collection<?> c) {\n    throw new UnsupportedOperationException(\"Removal from collection not supported\");\n  }\n\n  @Override\n  public boolean retainAll(Collection<?> c) {\n    throw new UnsupportedOperationException(\"Removal from collection not supported\");\n  }\n\n  @Override\n  public void clear() {\n    throw new UnsupportedOperationException(\"Removal from collection not supported\");\n\n  }\n\n  @Override\n  public boolean isModifiable() {\n    return false;\n  }\n\n  @Override\n  public int occurrences(E element) {\n    if (this.isDistinct) {\n      return this.data.contains(element) ? 1 : 0;\n    }\n    // expensive!!\n    int count = 0;\n    for (Iterator<E> itr = this.iterator()/* this.base.iterator() */; itr.hasNext();) {\n      E v = itr.next();\n      if (element == null ? v == null : element.equals(v)) {\n        count++;\n      }\n    }\n    return count;\n  }\n\n  @Override\n  public Set<E> asSet() {\n    return new HashSet<E>(this);\n  }\n\n  @Override\n  public List<E> asList() {\n    return new ArrayList<E>(this);\n  }\n\n  @Override\n  public CollectionType getCollectionType() {\n    return this.collectionType;\n  }\n\n  @Override\n  public void setElementType(ObjectType elementType) {\n    throw new UnsupportedOperationException(\" not supported\");\n  }\n\n  private class NWayMergeResultsCollection extends AbstractCollection<E> {\n\n    private final Collection<? extends Collection<E>> sortedResults;\n    private final OrderByComparator comparator;\n    private final int limit;\n\n    public NWayMergeResultsCollection(Collection<? extends Collection<E>> sortedResults, int limit,\n        List<CompiledSortCriterion> orderByAttribs, ExecutionContext context) {\n      this.sortedResults = sortedResults;\n      this.limit = limit;\n      this.comparator =\n          new OrderByComparator(orderByAttribs, collectionType.getElementType(), context);\n\n    }\n\n    @Override\n    public int size() {\n      if (isDistinct) {\n        Iterator<E> iter = this.iterator();\n        int count = 0;\n        while (iter.hasNext()) {\n          ++count;\n          iter.next();\n        }\n        return count;\n\n      } else {\n        int totalSize = 0;\n        for (Collection<E> result : this.sortedResults) {\n          totalSize += result.size();\n        }\n        if (this.limit >= 0) {\n          return totalSize > this.limit ? this.limit : totalSize;\n        } else {\n          return totalSize;\n        }\n      }\n\n    }\n\n\n    @Override\n    public Iterator<E> iterator() {\n      Iterator<E> iter;\n      if (isDistinct) {\n        iter = new NWayMergeDistinctIterator();\n      } else {\n        iter = new NWayMergeIterator();\n      }\n      if (this.limit > -1) {\n        iter = new LimitIterator<E>(iter, this.limit);\n      }\n      return iter;\n    }\n\n    private class NWayMergeIterator implements Iterator<E> {\n\n      protected final IteratorWrapper<E>[] iterators;\n      protected int lastReturnedIteratorIndex = -1;\n\n      protected NWayMergeIterator() {\n        this.iterators = new IteratorWrapper[sortedResults.size()];\n        Iterator<? extends Collection<E>> listIter = sortedResults.iterator();\n        int index = 0;\n        while (listIter.hasNext()) {\n          IteratorWrapper<E> temp = new IteratorWrapper<E>(listIter.next().iterator());\n          this.iterators[index++] = temp;\n          // initialize\n          temp.move();\n        }\n      }\n\n      @Override\n      public boolean hasNext() {\n        boolean hasNext = false;\n        for (int i = 0; i < this.iterators.length; ++i) {\n          if (i == this.lastReturnedIteratorIndex) {\n            hasNext = this.iterators[i].hasNext();\n          } else {\n            hasNext = !this.iterators[i].EOF;\n          }\n          if (hasNext) {\n            break;\n          }\n        }\n        return hasNext;\n      }\n\n      protected E basicNext() {\n        if (this.iterators.length == 1) {\n          this.lastReturnedIteratorIndex = 0;\n          if (iterators[0].EOF) {\n            throw new NoSuchElementException();\n          }\n          return iterators[0].get();\n        }\n\n        int iteratorIndex = -1;\n        E refObject = null;\n        for (int j = 0; j < this.iterators.length; ++j) {\n          if (!this.iterators[j].EOF) {\n            E temp = this.iterators[j].get();\n            iteratorIndex = j;\n            refObject = temp;\n            break;\n\n          }\n        }\n        if (iteratorIndex == -1) {\n          throw new NoSuchElementException();\n        }\n\n        E currentOptima = null;\n        int indexOfIteratorForOptima = -1;\n\n        currentOptima = refObject;\n        indexOfIteratorForOptima = iteratorIndex;\n        for (int j = iteratorIndex + 1; j < this.iterators.length; ++j) {\n          if (this.iterators[j].EOF) {\n            continue;\n          }\n          E temp = this.iterators[j].get();\n\n          int compareResult = compare(currentOptima, temp);\n\n          if (compareResult > 0) {\n            currentOptima = temp;\n            indexOfIteratorForOptima = j;\n          }\n        }\n        this.lastReturnedIteratorIndex = indexOfIteratorForOptima;\n        return currentOptima;\n      }\n\n      protected int compare(E obj1, E obj2) {\n        return collectionType.getElementType().isStructType() ? comparator\n            .compare(((StructImpl) obj1).getFieldValues(), ((StructImpl) obj2).getFieldValues())\n            : comparator.compare(obj1, obj2);\n\n      }\n\n      @Override\n      public E next() {\n        if (this.lastReturnedIteratorIndex != -1) {\n          iterators[this.lastReturnedIteratorIndex].move();\n        }\n        return this.basicNext();\n      }\n\n      @Override\n      public void remove() {\n        throw new UnsupportedOperationException(\"remove not supported\");\n\n      }\n\n      private class IteratorWrapper<T> {\n        private final Iterator<T> iter;\n        private T current = null;\n        private boolean EOF = false;\n\n        private IteratorWrapper(Iterator<T> iter) {\n          this.iter = iter;\n        }\n\n        T get() {\n          return this.current;\n        }\n\n        boolean hasNext() {\n          return this.iter.hasNext();\n        }\n\n        void move() {\n          if (this.iter.hasNext()) {\n            this.current = this.iter.next();\n          } else {\n            this.current = null;\n            this.EOF = true;\n          }\n        }\n\n      }\n    }\n\n    private class NWayMergeDistinctIterator extends NWayMergeIterator {\n\n      private E lastReturned = null;\n      private Boolean cachedHasNext = null;\n      private boolean uninitialized = true;\n\n      NWayMergeDistinctIterator() {}\n\n      @Override\n      public boolean hasNext() {\n        if (this.cachedHasNext != null) {\n          return this.cachedHasNext.booleanValue();\n        }\n        boolean hasNext = false;\n        for (int i = 0; i < this.iterators.length; ++i) {\n          if (this.uninitialized) {\n            hasNext = !this.iterators[i].EOF;\n            if (hasNext) {\n              break;\n            }\n          } else {\n            if (this.lastReturnedIteratorIndex == i) {\n              do {\n                this.iterators[i].move();\n                if (this.iterators[i].EOF) {\n                  break;\n                } // else if (!this.lastReturned.equals(this.iterators[i].get()))\n                  // {\n                else if (compare(lastReturned, this.iterators[i].get()) != 0) {\n                  hasNext = true;\n                  break;\n                }\n              } while (true);\n            } else {\n              do {\n                if (this.iterators[i].EOF) {\n                  break;\n                } // else if\n                  // (!this.iterators[i].get().equals(this.lastReturned)) {\n                else if (compare(this.iterators[i].get(), this.lastReturned) != 0) {\n                  hasNext = true;\n                  break;\n                } else {\n                  this.iterators[i].move();\n                }\n              } while (true);\n            }\n          }\n        }\n        this.uninitialized = false;\n        this.cachedHasNext = Boolean.valueOf(hasNext);\n        return hasNext;\n      }\n\n\n\n      @Override\n      public E next() {\n        if (this.cachedHasNext == null) {\n          this.hasNext();\n        }\n        this.cachedHasNext = null;\n        this.lastReturned = this.basicNext();\n        return this.lastReturned;\n      }\n\n      @Override\n      public void remove() {\n        super.remove();\n      }\n\n    }\n\n\n  }\n\n  @Override\n  public Version[] getSerializationVersions() {\n    return null;\n  }\n\n  @Override\n  public void fromData(DataInput in) throws IOException, ClassNotFoundException {\n    ObjectType elementType = (ObjectType) DataSerializer.readObject(in);\n    this.collectionType = new CollectionTypeImpl(NWayMergeResults.class, elementType);\n    boolean isStruct = elementType.isStructType();\n    this.isDistinct = DataSerializer.readPrimitiveBoolean(in);\n    long size = in.readLong();\n    this.data = new ArrayList<E>((int) size);\n    long numLeft = size;\n    while (numLeft > 0) {\n      if (isStruct) {\n        Object[] fields = DataSerializer.readObjectArray(in);\n        this.data.add((E) new StructImpl((StructTypeImpl) elementType, fields));\n      } else {\n        E element = DataSerializer.readObject(in);\n        this.data.add(element);\n      }\n      --numLeft;\n    }\n  }\n\n  public int getDSFID() {\n    return NWAY_MERGE_RESULTS;\n  }\n\n  // TODO : optimize for struct elements , by directly writing the fields\n  // instead\n  // of struct\n  @Override\n  public void toData(DataOutput out) throws IOException {\n    boolean isStruct = this.collectionType.getElementType().isStructType();\n    DataSerializer.writeObject(this.collectionType.getElementType(), out);\n    DataSerializer.writePrimitiveBoolean(this.isDistinct, out);\n    HeapDataOutputStream hdos = new HeapDataOutputStream(1024, null);\n    LongUpdater lu = hdos.reserveLong();\n    Iterator<E> iter = this.iterator();\n    int numElements = 0;\n    while (iter.hasNext()) {\n      E data = iter.next();\n      if (isStruct) {\n        Object[] fields = ((Struct) data).getFieldValues();\n        DataSerializer.writeObjectArray(fields, out);\n      } else {\n        DataSerializer.writeObject(data, hdos);\n      }\n      ++numElements;\n    }\n    lu.update(numElements);\n    hdos.sendTo(out);\n\n  }\n\n  @Override\n  public String toString() {\n    StringBuilder builder =\n        new StringBuilder(\"NWayMergeResults:: isDistinct=\" + this.isDistinct).append(\":\");\n    builder.append('[');\n    Iterator<E> iter = this.iterator();\n    while (iter.hasNext()) {\n      builder.append(iter.next()).append(',');\n    }\n    builder.deleteCharAt(builder.length() - 1);\n    builder.append(']');\n    return builder.toString();\n  }\n\n  @Override\n  public Comparator comparator() {\n    if (this.data instanceof NWayMergeResults.NWayMergeResultsCollection) {\n      return ((NWayMergeResultsCollection) this.data).comparator;\n    } else {\n      return null;\n    }\n  }\n\n  @Override\n  public boolean dataPreordered() {\n    if (this.data instanceof NWayMergeResults.NWayMergeResultsCollection) {\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n", "://boofcv.org).\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage boofcv.alg.structure;\n\nimport boofcv.struct.calib.CameraPinholeBrown;\nimport boofcv.struct.image.ImageDimension;\nimport boofcv.testing.BoofStandardJUnit;\nimport georegression.metric.UtilAngle;\nimport org.junit.jupiter.api.Test;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n/**\n * @author Peter Abeles\n */\nclass TestLookUpCameraInfo extends BoofStandardJUnit {\n\t/**\n\t * adds a view then retrieves various information and makes sure everything is working correctly\n\t */\n\t@Test void addView_lookupVarious() {\n\t\tvar alg = new LookUpCameraInfo();\n\n\t\talg.addCameraCanonical(1001, 200, 45);\n\t\talg.addCameraCanonical(1002, 200, 45);\n\t\talg.addCameraCanonical(1003, 200, 45);\n\n\t\talg.addView(\"foo\", 1);\n\n\t\tassertEquals(1, alg.viewToCamera(\"foo\"));\n\n\t\tImageDimension shape = new ImageDimension();\n\t\talg.lookupViewShape(\"foo\", shape);\n\t\tassertEquals(1002, shape.width);\n\n\t\tCameraPinholeBrown foundCamera = new CameraPinholeBrown();\n\t\talg.lookupCalibration(\"foo\", foundCamera);\n\t\tassertEquals(1002, foundCamera.width);\n\t}\n\n\t@Test void addCameraCanonical() {\n\t\tvar alg = new LookUpCameraInfo();\n\t\talg.addCameraCanonical(1000, 200, 45);\n\n\t\tCameraPinholeBrown found = alg.listCalibration.get(0);\n\t\tassertEquals(1000, found.width);\n\t\tassertEquals(200, found.height);\n\t\tassertEquals(500, found.cx);\n\t\tassertEquals(100, found.cy);\n\n\t\tdouble f = 500/Math.tan(UtilAngle.degreeToRadian(45)/2.0);\n\t\tassertEquals(1.0, f/found.fx, 1e-7);\n\t\tassertEquals(1.0, f/found.fy, 1e-7);\n\t}\n}\n", "ersion 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage guru.nidi.graphviz.model;\n\nimport java.util.*;\n\nimport static java.util.stream.Collectors.toList;\n\nclass LinkList extends ArrayList<Link> {\n    private final LinkSource owner;\n\n    LinkList(LinkSource owner, List<Link> links) {\n        super(links);\n        this.owner = owner;\n    }\n\n    @Override\n    public Link set(int index, Link element) {\n        return super.set(index, owner.linkTo(element));\n    }\n\n    @Override\n    public boolean add(Link link) {\n        return super.add(owner.linkTo(link));\n    }\n\n    @Override\n    public void add(int index, Link element) {\n        super.add(index, owner.linkTo(element));\n    }\n\n    @Override\n    public boolean addAll(Collection<? extends Link> c) {\n        return super.addAll(c.stream().map(owner::linkTo).collect(toList()));\n    }\n\n    @Override\n    public boolean addAll(int index, Collection<? extends Link> c) {\n        return super.addAll(index, c.stream().map(owner::linkTo).collect(toList()));\n    }\n}\n", "\t\n\tvoid onRetrieve(Set<String> files);\n\t\n\tvoid onRetrieveError(String message);\n\n}\n", "\"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage com.github.richardballard.packplanner.item;\n\nimport net.jcip.annotations.Immutable;\nimport org.jetbrains.annotations.NotNull;\nimport org.testng.annotations.DataProvider;\nimport org.testng.annotations.Test;\n\nimport static org.assertj.core.api.Assertions.assertThatThrownBy;\n\n@Test\npublic class ItemIdTest {\n\n    @DataProvider(name = \"badValueData\")\n    @NotNull\n    public BadValueData[][] getBadValueData() {\n        return new BadValueData[][] {\n                { new BadValueData(-10) },\n                { new BadValueData(-1) },\n                { new BadValueData(0) }\n        };\n    }\n\n\n    @Test(dataProvider = \"badValueData\")\n    public void badValueThrows(@NotNull final BadValueData data) {\n        assert data != null;\n\n        assertThatThrownBy(() -> new ItemId(data.getValue()))\n                .isInstanceOf(IllegalArgumentException.class)\n                .hasMessage(\"value (\" + data.getValue() + \") must be > 0\");\n    }\n\n    @Immutable\n    public static class BadValueData {\n        private final int value;\n\n        public BadValueData(final int value) {\n            this.value = value;\n        }\n\n        public int getValue() {\n            return value;\n        }\n\n        @Override\n        public String toString() {\n            return \"BadValueData{\" +\n                   \"value=\" + value +\n                   '}';\n        }\n    }\n}\n", "n 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage org.gradle.internal.watch.vfs;\n\nimport org.gradle.internal.operations.BuildOperationType;\n\nimport javax.annotation.Nullable;\n\npublic interface BuildFinishedFileSystemWatchingBuildOperationType extends BuildOperationType<BuildFinishedFileSystemWatchingBuildOperationType.Details, BuildFinishedFileSystemWatchingBuildOperationType.Result> {\n    String DISPLAY_NAME = \"Build finished for file system watching\";\n\n    interface Details {\n        Details INSTANCE = new Details() {};\n    }\n\n    interface Result {\n        Result WATCHING_DISABLED = new Result() {\n            @Override\n            public boolean isWatchingEnabled() {\n                return false;\n            }\n\n            @Override\n            public boolean isStoppedWatchingDuringTheBuild() {\n                return false;\n            }\n\n            @Override\n            public boolean isStateInvalidatedAtStartOfBuild() {\n                return false;\n            }\n\n            @Override\n            public FileSystemWatchingStatistics getStatistics() {\n                return null;\n            }\n        };\n\n        boolean isWatchingEnabled();\n\n        boolean isStoppedWatchingDuringTheBuild();\n\n        boolean isStateInvalidatedAtStartOfBuild();\n\n        @Nullable\n        FileSystemWatchingStatistics getStatistics();\n    }\n}\n", "nse, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n * \n *      http://www.apache.org/licenses/LICENSE-2.0\n * \n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.opensymphony.xwork2.util.logging.jdk;\n\nimport com.opensymphony.xwork2.util.logging.Logger;\nimport com.opensymphony.xwork2.util.logging.LoggerFactory;\n\n/**\n * Creates jdk loggers\n *\n * @deprecated since 2.5\n */\n@Deprecated\npublic class JdkLoggerFactory extends LoggerFactory {\n\n    @Override\n    protected Logger getLoggerImpl(Class<?> cls) {\n        return new JdkLogger(java.util.logging.Logger.getLogger(cls.getName()));\n    }\n    \n    @Override\n    protected Logger getLoggerImpl(String name) {\n        return new JdkLogger(java.util.logging.Logger.getLogger(name));\n    }\n}\n", ".annotation.NonNull;\n\nimport java.util.ArrayDeque;\nimport java.util.Queue;\nimport java.util.concurrent.Executor;\nimport java.util.concurrent.LinkedBlockingQueue;\nimport java.util.concurrent.ThreadFactory;\nimport java.util.concurrent.ThreadPoolExecutor;\nimport java.util.concurrent.TimeUnit;\nimport java.util.concurrent.atomic.AtomicInteger;\n\n/**\n * Created by Rolf on 29-2-2016.\n */\npublic class TaskExecutor {\n\n    private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors();\n    private static final int CORE_POOL_SIZE = CPU_COUNT + 1;\n    private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1;\n    private static final int KEEP_ALIVE = 1;\n\n    private static final ThreadFactory threadFactory = new ThreadFactory() {\n        private final AtomicInteger threadCount = new AtomicInteger(1);\n\n        public Thread newThread(@NonNull Runnable runnable) {\n            return new Thread(runnable, \"Task #\" + threadCount.getAndIncrement());\n        }\n    };\n\n    /**\n     * An {@link Executor} that can be used to execute tasks in parallel.\n     */\n    public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(\n            CORE_POOL_SIZE,\n            MAXIMUM_POOL_SIZE,\n            KEEP_ALIVE, TimeUnit.SECONDS,\n            new LinkedBlockingQueue<Runnable>(128),\n            threadFactory){\n\n        @Override\n        protected void beforeExecute(Thread t, Runnable r) {\n            android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);\n            super.beforeExecute(t, r);\n        }\n    };\n\n    /**\n     * An {@link Executor} that can be used to execute tasks in serial. This Executor internally uses the {@link TaskExecutor#THREAD_POOL_EXECUTOR} for executing it's tasks.\n     */\n    public static final Executor SERIAL_EXECUTOR = new SerialExecutor();\n\n    private static class SerialExecutor implements Executor {\n        private final Queue<Runnable> taskQueue = new ArrayDeque<>();\n        private Runnable activeRunnable;\n\n        public synchronized void execute(@NonNull final Runnable r) {\n            taskQueue.offer(new Runnable() {\n                public void run() {\n                    try {\n                        r.run();\n                    } finally {\n                        scheduleNext();\n                    }\n                }\n            });\n            if (activeRunnable == null) {\n                scheduleNext();\n            }\n        }\n\n        private synchronized void scheduleNext() {\n            if ((activeRunnable = taskQueue.poll()) != null) {\n                THREAD_POOL_EXECUTOR.execute(activeRunnable);\n            }\n        }\n    }\n\n    private static volatile Executor defaultExecutor = THREAD_POOL_EXECUTOR;\n\n    private TaskExecutor() {\n\n    }\n\n    /**\n     * Sets the default {@link Executor} to use when executing {@link Task Tasks} using this class.\n     * <strong>Important:</strong> The {@link TaskManager} uses this class to execute Tasks,\n     * changing the default Executor changes the executing behaviour of all TaskMangers.\n     * @param executor The {@link Executor} to use as default.\n     */\n    public static void setDefaultExecutor(@NonNull Executor executor) {\n        defaultExecutor = executor;\n    }\n\n    /**\n     * Returns the currently set default {@link Executor}. This is by default, if not changed using the\n     * {@link TaskExecutor#setDefaultExecutor(Executor)} method, the\n     * {@link TaskExecutor#THREAD_POOL_EXECUTOR}.\n     * @return The default {@link Executor}.\n     */\n    public static @NonNull Executor getDefaultExecutor(){\n        return defaultExecutor;\n    }\n\n    /**\n     * Executes the task with the specified parameters. The task returns\n     * itself (this) so that the caller can keep a reference to it.\n     *\n     * <p>Note: this function schedules the task on a queue for a single background\n     * thread or pool of threads depending on the platform version.  When first\n     * introduced, AsyncTasks were executed serially on a single background thread.\n     * Starting with {@link android.os.Build.VERSION_CODES#DONUT}, this was changed\n     * to a pool of threads allowing multiple tasks to operate in parallel. Starting\n     * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, tasks are back to being\n     * executed on a single thread to avoid common application errors caused\n     * by parallel execution.  If you truly want parallel execution, you can use\n     * the {@link Task#executeOnExecutor} version of this method\n     * with {@link #THREAD_POOL_EXECUTOR}; however, see commentary there for warnings\n     * on its use.</p>\n     *\n     * <p>This method must be invoked on the UI thread.</p>\n     *\n     * @param task the task to execute on the given {@link Executor}.\n     * @param executor the executor to execute the given {@link Task} on.\n     * @param <Progress> the progress type.\n     * @param <Result> the result type.\n     * @return This instance of AsyncTask.\n     * @throws IllegalStateException If {@link Task#isRunning()} or {@link Task#isFinished()}\n     * returns true.\n     * @see Task#executeOnExecutor(java.util.concurrent.Executor)\n     */\n    @MainThread\n    public static <Progress, Result> Task<Progress, Result> executeOnExecutor(@NonNull Task<Progress, Result> task, @NonNull Executor executor) {\n        return task.executeOnExecutor(executor);\n    }\n\n    @MainThread\n    public static <Progress, Result> Task<Progress, Result> execute(@NonNull Task<Progress, Result> task) {\n        return executeOnExecutor(task, defaultExecutor);\n    }\n\n    @MainThread\n    public static <Progress, Result> Task<Progress, Result> executeSerial(@NonNull Task<Progress, Result> task) {\n        return executeOnExecutor(task, SERIAL_EXECUTOR);\n    }\n\n    @MainThread\n    public static <Progress, Result> Task<Progress, Result> executeParallel(@NonNull Task<Progress, Result> task) {\n        return executeOnExecutor(task, THREAD_POOL_EXECUTOR);\n    }\n}\n"], "perplexity": [2.239461898803711, 2.217489004135132, 1.9194660186767578, 2.661236047744751, 2.2952492237091064, 9.659832000732422, 1.9878017902374268, 1.761487364768982, 1.9121146202087402, 3.211007595062256, 1.8164277076721191, 1.837010383605957, 3.007537841796875, 3.354445695877075, 2.1304304599761963, 2.241399049758911, 1.7927097082138062, 1.6413878202438354, 1.868310570716858, 1.643494963645935, 3.691333055496216, 2.524252414703369, 1.828445315361023, 1.6698968410491943, 2.5322277545928955, 2.2719919681549072, 3.221160888671875, 5.41495943069458, 2.1598896980285645, 2.389198064804077, 2.3442704677581787, 3.196357011795044, 1.8963050842285156, 1.2861392498016357, 3.0081653594970703, 1.5786553621292114, 2.976499557495117, 2.2681097984313965, 2.2746756076812744, 7.813786506652832, 2.161275863647461, 2.6541850566864014, 3.6808176040649414, 2.4329257011413574, 1.7386726140975952, 2.9805140495300293, 2.283756732940674, 3.1714088916778564, 1.4623308181762695, 2.53164005279541, 2.6170902252197266, 3.1138901710510254, 1.4067928791046143, 2.3230209350585938, 2.46901798248291, 1.7719999551773071, 2.1978394985198975, 2.622030258178711, 1.7808659076690674, 1.9710458517074585, 2.3056845664978027, 3.040670156478882, 2.5957117080688477, 2.865447759628296, 1.9747968912124634, 2.319979667663574, 1.729964256286621, 1.5749859809875488, 1.4126102924346924, 2.8632519245147705, 2.570190191268921, 10.641217231750488, 2.6446921825408936, 2.361450433731079, 3.0456995964050293, 2.1163859367370605, 1.7749760150909424, 2.354001522064209, 1.6402194499969482, 3.234473466873169, 1.6626285314559937, 4.892531871795654, 1.998500943183899, 2.2730441093444824, 1.9739058017730713, 2.154615879058838, 2.9271187782287598, 1.762024164199829, 2.509132146835327, 3.543598175048828, 2.0985236167907715, 2.8279848098754883, 2.045276403427124, 2.930649757385254, 1.8117070198059082, 5.059869766235352, 1.95280921459198, 2.2799336910247803, 1.5876381397247314, 2.8352460861206055], "avg_perplexity": 2.6110888838768007}
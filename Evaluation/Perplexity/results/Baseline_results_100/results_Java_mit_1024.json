{"text": [";\n\nimport org.json.JSONArray;\nimport org.json.JSONException;\nimport org.json.JSONObject;\n\nimport java.io.Serializable;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * Created by david on 15-7-21.\n */\npublic class Subject {\n\n    public static class SubjectDescObject implements Serializable, ISubjectRecommendObject {\n\n        public int id;\n        public String name;\n        public Integer speackers;\n        public int watchers;\n        public Integer count;\n        public String image_url;\n        public String description;\n        public boolean watched;\n        public long created_at;\n        public HotTweetDescObject hot_tweet;\n        public List<UserObject> user_list;\n\n        public SubjectDescObject(JSONObject json) throws JSONException {\n            created_at = json.optLong(\"created_at\");\n            id = json.optInt(\"id\");\n            watched = json.optBoolean(\"watched\");\n            speackers = json.optInt(\"speackers\");\n            if (speackers == 0)\n                speackers = json.optInt(\"speakers\");\n            watchers = json.optInt(\"watchers\");\n            count = json.optInt(\"count\");\n            image_url = json.optString(\"image_url\");\n            description = json.optString(\"description\");\n            name = json.optString(\"name\");\n            if (json.has(\"hot_tweet\"))\n                hot_tweet = new HotTweetDescObject(json.optJSONObject(\"hot_tweet\"));\n            JSONArray arr = json.optJSONArray(\"user_list\");\n            if (arr != null && arr.length() > 0) {\n                user_list = new ArrayList<UserObject>();\n                for (int i = 0; i < arr.length(); i++) {\n                    user_list.add(new UserObject(arr.optJSONObject(i)));\n                }\n            }\n        }\n\n        @Override\n        public String getName() {\n            return this.name;\n        }\n\n        @Override\n        public int getType() {\n            return 1;\n        }\n\n    }\n\n    public static class HotTweetDescObject implements Serializable {\n        public int id;\n        public int owner_id;\n        public UserObject owner;\n        public long created_at;\n        public int likes;\n        public int comments;\n        public List<BaseComment> comment_list;\n        public String device;\n        public String location;\n        public String coord;\n        public String address;\n        public String content;\n        public String path;\n        public int acitivity_id;\n        public boolean liked;\n        public List<UserObject> like_users;\n\n        public HotTweetDescObject(JSONObject json) {\n            id = json.optInt(\"id\");\n            owner_id = json.optInt(\"owner_id\");\n            owner = new UserObject(json.optJSONObject(\"owner\"));\n            created_at = json.optLong(\"created_at\");\n            likes = json.optInt(\"likes\");\n            comments = json.optInt(\"comments\");\n            device = json.optString(\"device\");\n            location = json.optString(\"location\");\n            device = json.optString(\"device\");\n            coord = json.optString(\"coord\");\n            device = json.optString(\"device\");\n            address = json.optString(\"address\");\n            content = json.optString(\"content\");\n            acitivity_id = json.optInt(\"acitivity_id\");\n            liked = json.optBoolean(\"liked\");\n            JSONArray arr = json.optJSONArray(\"like_users\");\n            if (arr != null && arr.length() > 0) {\n                like_users = new ArrayList<UserObject>();\n                for (int i = 0; i < arr.length(); i++) {\n                    like_users.add(new UserObject(arr.optJSONObject(i)));\n                }\n            }\n        }\n\n    }\n\n    public static class SubjectLastUsedObject implements Serializable, ISubjectRecommendObject {\n\n        public String name;\n\n        public SubjectLastUsedObject(String name) {\n            this.name = name;\n        }\n\n        @Override\n        public String getName() {\n            return name;\n        }\n\n        @Override\n        public int getType() {\n            return 0;\n        }\n    }\n\n}\n", "jector;\nimport com.google.template.soy.data.SoyData;\nimport com.google.template.soy.data.SoyMapData;\nimport com.google.template.soy.data.SoyValue;\nimport com.google.template.soy.data.restricted.IntegerData;\nimport com.google.template.soy.data.restricted.StringData;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.slieb.soy.context.RendererFactoryContext;\nimport org.slieb.soy.context.SoyValueFactoryContext;\nimport org.slieb.soy.model.LongData;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static org.junit.Assert.*;\nimport static org.slieb.soy.Loader.getBasicInjector;\n\npublic class BasicLoaderTest {\n\n    private Injector injector;\n\n    @Before\n    public void setup() {\n        injector = getBasicInjector();\n    }\n\n    @Test\n    public void testBasicInjectorMakesSingletonContext() throws Exception {\n        assertSame(\"Singleton instance expected\",\n                   injector.getInstance(SoyValueFactoryContext.class),\n                   injector.getInstance(SoyValueFactoryContext.class));\n    }\n\n    @Test(expected = ConfigurationException.class)\n    public void testBasicInjectorCannotDeliverRenderer() {\n        injector.getInstance(RendererFactoryContext.class);\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertInteger() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        Integer integer = new Integer(102);\n        SoyValue data = context.apply(integer);\n        assertTrue(data instanceof IntegerData);\n        assertEquals(102, data.integerValue());\n        SoyValue data2 = context.apply(102);\n        assertTrue(data2 instanceof IntegerData);\n        assertEquals(data2, data);\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertLong() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        Long integer = new Long(102);\n        SoyValue data = context.apply(integer);\n        assertTrue(data instanceof LongData);\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertSoyData() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        SoyValue data = context.apply(1);\n        assertTrue(data instanceof IntegerData);\n        assertSame(data, context.apply(data));\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertString() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n        SoyValue data = context.apply(\"string\");\n        assertTrue(data instanceof StringData);\n        assertEquals(\"string\", data.stringValue());\n    }\n\n    @Test\n    public void testBasicInjectorCanConvertMap() {\n        SoyValueFactoryContext context = injector.getInstance(SoyValueFactoryContext.class);\n\n        Map<String, Object> map = new HashMap<>();\n        map.put(\"strEntry\", \"string\");\n        map.put(\"intEntry\", 10);\n        map.put(\"longEntry\", 10L);\n        SoyValue data = context.apply(map);\n        assertTrue(data instanceof SoyMapData);\n        SoyData strEntryData = ((SoyMapData) data).get(\"strEntry\");\n        assertTrue(strEntryData instanceof StringData);\n        assertEquals(\"string\", strEntryData.stringValue());\n        SoyData intEntryData = ((SoyMapData) data).get(\"intEntry\");\n        assertTrue(intEntryData instanceof IntegerData);\n        assertEquals(10, intEntryData.integerValue());\n        SoyData longEntryData = ((SoyMapData) data).get(\"longEntry\");\n        assertTrue(longEntryData instanceof LongData);\n    }\n}\n", "eption;\nimport java.io.OutputStream;\n\nimport org.springframework.ws.transport.TransportOutputStream;\n\npublic class ByteArrayTransportOutputStream extends TransportOutputStream {\n\n  private static final String NEW_LINE = System.getProperty(\"line.separator\");\n\n  private ByteArrayOutputStream byteArrayOutputStream;\n\n  @Override\n  public void addHeader(String name, String value) throws IOException {\n    createOutputStream();\n    String header = name + \": \" + value + NEW_LINE;\n    byteArrayOutputStream.write(header.getBytes());\n  }\n\n  @Override\n  protected OutputStream createOutputStream() throws IOException {\n    if (byteArrayOutputStream == null) {\n      byteArrayOutputStream = new ByteArrayOutputStream();\n    }\n    return byteArrayOutputStream;\n  }\n\n  public byte[] toByteArray() {\n    return byteArrayOutputStream.toByteArray();\n  }\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.network.v2018_08_01.implementation;\n\nimport com.microsoft.azure.management.network.v2018_08_01.VpnProfileResponse;\nimport com.microsoft.azure.arm.model.implementation.WrapperImpl;\n\nclass VpnProfileResponseImpl extends WrapperImpl<VpnProfileResponseInner> implements VpnProfileResponse {\n    private final NetworkManager manager;\n    VpnProfileResponseImpl(VpnProfileResponseInner inner, NetworkManager manager) {\n        super(inner);\n        this.manager = manager;\n    }\n\n    @Override\n    public NetworkManager manager() {\n        return this.manager;\n    }\n\n    @Override\n    public String profileUrl() {\n        return this.inner().profileUrl();\n    }\n\n}\n", " details.\n *\n * Creation date: Feb 21, 2007\n */\n\npackage vpc.core.types;\n\nimport cck.parser.AbstractToken;\nimport cck.parser.SourcePoint;\nimport cck.text.StringUtil;\nimport vpc.util.ArrayUtil;\nimport vpc.util.Cache;\n\nimport java.util.List;\n\n/**\n * The <code>VirgilTypeParam</code> class represents a type parameter and related\n * functionality with the compiler.\n * \n * @author Ben L. Titzer\n */\npublic class TypeParam {\n\n    public static final TypeParam[] NOTYPEPARAMS = new TypeParam[0];\n\n    public final String name;\n    public final SourcePoint point;\n\n    public final TypeCon typeCon;\n    public final IType type;\n\n    public TypeParam(AbstractToken tok) {\n        name = tok.image;\n        point = tok.getSourcePoint();\n        type = new IType(tok.image);\n        typeCon = new TypeCon.Singleton(type);\n    }\n\n    public static TypeParam[] toTypeParamArray(List<TypeParam> typeParams) {\n        if ( typeParams == null || typeParams.isEmpty() ) return NOTYPEPARAMS;\n        return typeParams.toArray(new TypeParam[typeParams.size()]);\n    }\n\n    public static <T extends TypeToken> String buildParameterizedName(String n, T[] et) {\n        if ( et.length > 0 ) {\n            StringBuffer buf = new StringBuffer(n);\n            buf.append('<');\n            StringUtil.commalist(et, buf);\n            buf.append('>');\n            return buf.toString();\n        }\n        return n;\n    }\n\n    public static <T extends TypeToken> String buildParameterizedName(String n, List<T> et) {\n        if (!et.isEmpty() ) {\n            StringBuffer buf = new StringBuffer(n);\n            buf.append('<');\n            StringUtil.commalist(et, buf);\n            buf.append('>');\n            return buf.toString();\n        }\n        return n;\n    }\n\n    public static class IType extends Type {\n        public boolean inMethod;\n        public int index;\n\n        public IType(String n) {\n            super(n);\n            index = -1;\n        }\n        public Type rebuild(Type[] elements) {\n            return this;\n        }\n    }\n\n    public static Type substitute(Cache<Type> cache, TypeParam[] p, Type[] t, Type expr) {\n        assert p.length == t.length;\n        if ( p.length == 0 ) return expr; // no substitution necessary\n        return ArrayUtil.substitute(cache, Type.class, toTypes(p), t, expr);\n    }\n\n    public static Type[] toTypes(TypeParam[] p) {\n        if ( p.length == 0 ) return Type.NOTYPES;\n        Type[] nt = new Type[p.length];\n        for ( int cntr = 0; cntr < nt.length; cntr++) nt[cntr] = p[cntr].type;\n        return nt;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public SourcePoint getSourcePoint() {\n        return point;\n    }\n\n    public TypeCon getTypeCon() {\n        return typeCon;\n    }\n\n    public IType getType() {\n        return type;\n    }\n\n}\n", "ncorrect behavior and will be lost if\n *     the code is regenerated.\n */\npackage com.mozu.api.contracts.commerceruntime.products;\n\nimport java.io.Serializable;\nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\nimport org.joda.time.DateTime;\nimport com.mozu.api.contracts.commerceruntime.commerce.PackageMeasurements;\n\n/**\n *\tProperties of a component product in a product bundle. A product bundle can represent either a collection of multiple products sold as a single entity, or a collection of the same product sold as a package. For example, a 10-pack of socks or multiple parts and devices in a technology bundle for a computer.\n */\n@JsonIgnoreProperties(ignoreUnknown = true)\npublic class BundledProduct implements Serializable\n{\n\t// Default Serial Version UID\n\tprivate static final long serialVersionUID = 1L;\n\n\t/**\n\t * The fully qualified name of the attribute, which is a user defined attribute identifier.\n\t */\n\tprotected String optionAttributeFQN;\n\n\tpublic String getOptionAttributeFQN() {\n\t\treturn this.optionAttributeFQN;\n\t}\n\n\tpublic void setOptionAttributeFQN(String optionAttributeFQN) {\n\t\tthis.optionAttributeFQN = optionAttributeFQN;\n\t}\n\n\t/**\n\t * Allocation ID associated with this product on this order.\n\t */\n\tprotected DateTime allocationExpiration;\n\n\tpublic DateTime getAllocationExpiration() {\n\t\treturn this.allocationExpiration;\n\t}\n\n\tpublic void setAllocationExpiration(DateTime allocationExpiration) {\n\t\tthis.allocationExpiration = allocationExpiration;\n\t}\n\n\t/**\n\t * Allocation ID associated with this product on this order.\n\t */\n\tprotected Integer allocationId;\n\n\tpublic Integer getAllocationId() {\n\t\treturn this.allocationId;\n\t}\n\n\tpublic void setAllocationId(Integer allocationId) {\n\t\tthis.allocationId = allocationId;\n\t}\n\n\t/**\n\t * The credit value of the product or bundled product. When the `goodsType `is `DigitalCredit`, this value is populated to indicate the value of the credit. This is used to create store credit in the fulfillment of gift cards.\n\t */\n\tprotected Double creditValue;\n\n\tpublic Double getCreditValue() {\n\t\treturn this.creditValue;\n\t}\n\n\tpublic void setCreditValue(Double creditValue) {\n\t\tthis.creditValue = creditValue;\n\t}\n\n\t/**\n\t * The localized description in text for the object, displayed per the locale code. For example, descriptions are used for product descriptions, attributes, and pre-authorization transaction types.\n\t */\n\tprotected String description;\n\n\tpublic String getDescription() {\n\t\treturn this.description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\t/**\n\t * Fulfillment status of the product.\n\t */\n\tprotected String fulfillmentStatus;\n\n\tpublic String getFulfillmentStatus() {\n\t\treturn this.fulfillmentStatus;\n\t}\n\n\tpublic void setFulfillmentStatus(String fulfillmentStatus) {\n\t\tthis.fulfillmentStatus = fulfillmentStatus;\n\t}\n\n\t/**\n\t * The type of goods in a bundled product. A bundled product is composed of products associated to sell together. Possible values include \u201cPhysical\u201d and \u201cDigitalCredit\u201d. This comes from the `productType `of the product. Products are defaulted to a Physical `goodsType`. Gift cards have a `goodsType `of DigitalCredit.\n\t */\n\tprotected String goodsType;\n\n\tpublic String getGoodsType() {\n\t\treturn this.goodsType;\n\t}\n\n\tpublic void setGoodsType(String goodsType) {\n\t\tthis.goodsType = goodsType;\n\t}\n\n\t/**\n\t * Indicates if the product must be shipped alone in a container. This is used for products and products within a bundle. If true, this product cannot be shipped in a package with other items and must ship in a package by itself.\n\t */\n\tprotected Boolean isPackagedStandAlone;\n\n\tpublic Boolean getIsPackagedStandAlone() {\n\t\treturn this.isPackagedStandAlone;\n\t}\n\n\tpublic void setIsPackagedStandAlone(Boolean isPackagedStandAlone) {\n\t\tthis.isPackagedStandAlone = isPackagedStandAlone;\n\t}\n\n\t/**\n\t * The display name of the source product property. For a product field it will be the display name of the field. For a product attribute it will be the Attribute Name.\n\t */\n\tprotected String name;\n\n\tpublic String getName() {\n\t\treturn this.name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\t/**\n\t * The value of the option attribute. These values are associated and used by product bundles and options.\n\t */\n\tprotected Object optionValue;\n\n\tpublic Object getOptionValue() {\n\t\treturn this.optionValue;\n\t}\n\n\tpublic void setOptionValue(Object optionValue) {\n\t\tthis.optionValue = optionValue;\n\t}\n\n\t/**\n\t * Merchant-created code that uniquely identifies the product such as a SKU or item number. Once created, the product code is read-only.\n\t */\n\tprotected String productCode;\n\n\tpublic String getProductCode() {\n\t\treturn this.productCode;\n\t}\n\n\tpublic void setProductCode(String productCode) {\n\t\tthis.productCode = productCode;\n\t}\n\n\t/**\n\t * Unique identifier of the product reservation associated with the component product in a product bundle or item in a cart/order. System-supplied and read only.\n\t */\n\tprotected Integer productReservationId;\n\n\tpublic Integer getProductReservationId() {\n\t\treturn this.productReservationId;\n\t}\n\n\tpublic void setProductReservationId(Integer productReservationId) {\n\t\tthis.productReservationId = productReservationId;\n\t}\n\n\t/**\n\t * The specified quantity of objects and items. This property is used for numerous object types including products, options, components within a product bundle, cart and order items, returned items, shipping line items, items in a digital product. and items associated with types and reservations.\n\t */\n\tprotected Integer quantity;\n\n\tpublic Integer getQuantity() {\n\t\treturn this.quantity;\n\t}\n\n\tpublic void setQuantity(Integer quantity) {\n\t\tthis.quantity = quantity;\n\t}\n\n\t/**\n\t * Dimensions of the packaged product.\n\t */\n\tprotected PackageMeasurements measurements;\n\n\tpublic PackageMeasurements getMeasurements() {\n\t\treturn this.measurements;\n\t}\n\n\tpublic void setMeasurements(PackageMeasurements measurements) {\n\t\tthis.measurements = measurements;\n\t}\n\n}\n", "l int CAPACITY = 1000;\n    private E[] data;\n    private int t = -1;\n    public ArrayStack() { this(CAPACITY); }\n    public ArrayStack(int capacity) {\n        data = (E[])new Object[capacity];\n    }\n    public int size() { return t + 1; }\n    public boolean isEmpty() { return t == -1; }\n    public void push(E e) throws IllegalStateException {\n        if (size() == data.length) throw new IllegalStateException(\"Stack is full\");\n        data[++t] = e;\n    }\n    public E top() {\n        if (isEmpty()) return null;\n        return data[t];\n    }\n    public E pop() {\n        if (isEmpty()) return null;\n        E answer = data[t];\n        data[t] = null;\n        t--;\n        return answer;\n    }\n}\n", "{\n    private final View layout;\n\n    public Screen(View layout)\n    {\n        this.layout = layout;\n    }\n\n    public void display()\n    {\n        this.layout.setVisibility(View.VISIBLE);\n    }\n\n    public void hide()\n    {\n        this.layout.setVisibility(View.GONE);\n    }\n}", "face IStatistics {\r\n    void putParam(StatisticKeys key, String value);\r\n    void putParam(StatisticKeys key, int value);\r\n    void putParam(StatisticKeys key, long value);\r\n\r\n    boolean contains(StatisticKeys key);\r\n\r\n    String getStrValue(StatisticKeys key);\r\n    int getIntValue(StatisticKeys key);\r\n    long getLongValue(StatisticKeys key);\r\n\r\n    Map<StatisticKeys, String> toMap();\r\n}\r\n", "sic.GuiAirshipMusicPg3;\nimport com.viesis.viescraft.common.entity.airshipcolors.EntityAirshipBaseVC;\nimport com.viesis.viescraft.network.packet.MessageBase;\n\nimport io.netty.buffer.ByteBuf;\nimport net.minecraft.entity.player.EntityPlayer;\n\npublic class MessageGuiSongHelperPage3 extends MessageBase<MessageGuiSongHelperPage3> {\n\t\n\tprivate int metaSong;\n\t\n\t@Override\n\tpublic void fromBytes(ByteBuf buf) \n\t{\n\t\tmetaSong = buf.readInt();\n\t}\n\t\n\t@Override\n\tpublic void toBytes(ByteBuf buf) \n\t{\n\t\tbuf.writeInt(GuiAirshipMusicPg3.metaInfo);\n\t}\n\t\n\t@Override\n\tpublic void handleClientSide(MessageGuiSongHelperPage3 message, EntityPlayer player) \n\t{\n\t\t\n\t}\n\t\n\t@Override\n\tpublic void handleServerSide(MessageGuiSongHelperPage3 message, EntityPlayer player) \n\t{\n\t\tEntityAirshipBaseVC airship = (EntityAirshipBaseVC) player.getRidingEntity();\n\t\tairship.jukeboxSelectedSong = message.metaSong;\n\t}\n}\n", "mework.web.bind.annotation.RequestMapping;\r\nimport org.springframework.web.servlet.ModelAndView;\r\n\r\n@Controller\r\n@RequestMapping(\"/deploy\")\r\npublic class DeployController {\r\n\r\n\tpublic DeployController() {\r\n\t\t// TODO Auto-generated constructor stub\r\n\t}\r\n\t\r\n\t@RequestMapping(\"/config\")\r\n\tpublic ModelAndView config() {\r\n\r\n\t\treturn new ModelAndView(\"deploy/config\");\r\n\r\n\t}\r\n\t\r\n\t@RequestMapping(\"/ant\")\r\n\tpublic ModelAndView ant() {\r\n\t\t\r\n\t\treturn new ModelAndView(\"deploy/ant\");\r\n\r\n\t}\r\n\t\r\n\t@RequestMapping(\"/manual\")\r\n\tpublic ModelAndView manual() {\r\n\t\t\r\n\t\treturn new ModelAndView(\"deploy/manual\");\r\n\r\n\t}\r\n}\r\n", "m, libre.fm etc).\n *\n * @author William Osler\n */\npublic class FMUser {\n    /*\n     * Regexes for validation outside this class\n     */\n    public static final String userRegex = \"^[a-zA-Z0-9][a-zA-Z0-9_-]{1,14}[a-zA-z0-9]$\";\n    public static final String domainRegex = \"^([a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?.)+[a-zA-Z]{2,6}$\";\n\n    /*\n     * The user's service username\n     */\n    private String username = \"\";\n\n    /*\n     * The domain name. For Last.fm, this is ws.audioscrobbler.com.\n     */\n    private String domain = \"\";\n\n    /*\n     * The IRC user's nick.\n     */\n    private String nick;\n\n    /*\n     * The IRC channel this user is broadcasting to, since this is a multi-channel enabled bot.\n     */\n    private String channel = \"\";\n\n    /*\n     * The last song the user was listening to.\n     */\n    private String lastListen = \"\";\n\n    /*\n     * Overrides\n     */\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n\n        FMUser fmUser = (FMUser) o;\n\n        if (!channel.equals(fmUser.channel)) return false;\n        if (!domain.equals(fmUser.domain)) return false;\n        if (!username.equals(fmUser.username)) return false;\n        if (!nick.equals(fmUser.nick)) return false;\n\n        /*\n         * We don't consider the last listen for equality, since we don't have that info when we need to remove\n         * something from a collection which works on equality.\n         */\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        return username.hashCode() ^ domain.hashCode() ^ nick.hashCode() ^ channel.hashCode() ^ lastListen.hashCode();\n    }\n\n    @Override\n    public String toString() {\n        return username + \"@\" + domain + \" registered to \" + nick + \" in \" + channel + \" listened to \" + lastListen;\n    }\n\n    /**\n     * Default constructor.\n     *\n     * @param username The FM service username\n     * @param domain The domain name where the account can be found\n     * @param channel\n     */\n    public FMUser (String username, String domain, String nick, String channel) {\n        this.username = username;\n\n        if (domain.equals(\"last.fm\")) {\n            this.domain = \"ws.audioscrobbler.com\";\n        } else {\n            this.domain = domain;\n        }\n\n        this.nick = nick;\n        this.channel = channel;\n    }\n\n    /**\n     * Constructor using a comma seperated string.\n     *\n     * @param data A comma separated string containing the username, domain, channel, nick,\n     *             and (optional) last listen (in that order).\n     */\n    public FMUser (String data) {\n        String[] strArr = data.split(\",\");\n\n        this.username = strArr[0];\n\n        if (strArr[1].equals(\"last.fm\")) {\n            this.domain = \"ws.audioscrobbler.com\";\n        } else {\n            this.domain = strArr[1];\n        }\n\n        this.nick = strArr[2];\n        this.channel = strArr[3];\n\n        // Check for a lastListen\n        if (strArr.length > 4) {\n            this.lastListen = strArr[4];\n        }\n    }\n\n    /**\n     * The FM service username\n     *\n     * @return username\n     */\n    public String getUsername() {\n        return username;\n    }\n\n    /**\n     * The domain name where the account can be found\n     *\n     * @return domain\n     */\n    public String getDomain() {\n        return domain;\n    }\n\n    /**\n     * The IRC channel that this user will broadcast to\n     *\n     * @return channel\n     */\n    public String getChannel() {\n        return channel;\n    }\n\n    /**\n     * The IRC nick of the user\n     *\n     * @return nick\n     */\n    public String getNick() {\n        return nick;\n    }\n\n    /**\n     * The data of the track the user last listened to, mbid if from last.fm, or a combination of metadata otherwise.\n     *\n     * @return last listened info\n     */\n    public String getLastListen() {\n        return lastListen;\n    }\n\n    /**\n     * Sets the data of the track the user last listeend to.\n     *\n     * @param lastListen last listened info\n     */\n    public void setLastListen(String lastListen) {\n        this.lastListen = lastListen;\n    }\n\n    /**\n     * Returns a string of user data suitable to be written to a CSV. The output of this method is compatible with\n     * the String constructor for this object.\n     *\n     * @return a comma separated string of the fields of this object\n     */\n    public String toFileString() {\n        String result = username + \",\" + domain + \",\" + nick + \",\" + channel;\n\n        if (!lastListen.equals(\"\")) {\n            result += \",\" + lastListen;\n        }\n\n        return result;\n    }\n\n}\n", "g.apache.logging.log4j.Logger;\n\npublic class FooService {\n    private static final Logger log =\n            LogManager.getLogger(FooService.class);\n\n    public String getFooById(Long id) {\n        String myFoo = null;\n        if (id != null) {\n            myFoo = \"myFoo!\";\n        } else {\n            log.error(\"id cannot be null!\");\n        }\n\n        return myFoo;\n    }\n\n}\n", "mport com.rarchives.ripme.utils.Http;\nimport org.json.JSONArray;\nimport org.json.JSONObject;\nimport org.jsoup.nodes.Document;\nimport org.jsoup.nodes.Element;\nimport org.jsoup.select.Elements;\n\nimport java.io.IOException;\nimport java.net.MalformedURLException;\nimport java.net.URL;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class RedgifsRipper extends AbstractHTMLRipper {\n\n    private static final String HOST = \"redgifs.com\";\n    private static final String HOST_2 = \"gifdeliverynetwork.com\";\n    String username = \"\";\n    String cursor = \"\";\n    String count = \"100\";\n\n    String searchText = \"\";\n    int searchCount = 150;\n    int searchStart = 0;\n\n    public RedgifsRipper(URL url) throws IOException {\n        super(new URL(url.toExternalForm().replace(\"thumbs.\", \"\")));\n    }\n\n    @Override\n    public String getDomain() { return \"redgifs.com\"; }\n\n    @Override\n    public String getHost() {\n        return \"redgifs\";\n    }\n\n    @Override\n    public boolean canRip(URL url) {\n        return url.getHost().endsWith(HOST) || url.getHost().endsWith(HOST_2);\n    }\n\n    @Override\n    public URL sanitizeURL(URL url) throws MalformedURLException {\n        String sUrl = url.toExternalForm();\n        sUrl = sUrl.replace(\"/gifs/detail\", \"\");\n        sUrl = sUrl.replace(\"/amp\", \"\");\n        sUrl = sUrl.replace(\"gifdeliverynetwork.com\", \"redgifs.com/watch\");\n        return new URL(sUrl);\n    }\n\n    public Matcher isProfile() {\n        Pattern p = Pattern.compile(\"^https?://[wm.]*redgifs\\\\.com/users/([a-zA-Z0-9_-]+).*$\");\n        return p.matcher(url.toExternalForm());\n    }\n\n    public Matcher isSearch() {\n        Pattern p = Pattern.compile(\"^https?://[wm.]*redgifs\\\\.com/gifs/browse/([a-zA-Z0-9_-]+).*$\");\n        return p.matcher(url.toExternalForm());\n    }\n\n    public Matcher isSingleton() {\n        Pattern p = Pattern.compile(\"^https?://[wm.]*redgifs\\\\.com/watch/([a-zA-Z0-9_-]+).*$\");\n        return p.matcher(url.toExternalForm());\n    }\n\n    @Override\n    public Document getFirstPage() throws IOException {\n        if (!isProfile().matches() && !isSearch().matches()) {\n            return Http.url(url).get();\n        } else if (isSearch().matches()) {\n            searchText = getGID(url).replace(\"-\", \" \");\n            return Http.url(\n                    new URL(\"https://napi.redgifs.com/v1/gfycats/search?search_text=\" + searchText + \"&count=\" + searchCount + \"&start=\" + searchStart*searchCount)).ignoreContentType().get();\n        } else {\n            username = getGID(url);\n            return Http.url(new URL(\"https://napi.redgifs.com/v1/users/\" +  username + \"/gfycats?count=\" + count))\n                       .ignoreContentType().get();\n        }\n    }\n\n    @Override\n    public void downloadURL(URL url, int index) {\n        addURLToDownload(url, getPrefix(index));\n    }\n\n    @Override\n    public String getGID(URL url) throws MalformedURLException {\n\n        Matcher m = isProfile();\n        if (m.matches()) {\n            return m.group(1);\n        }\n        m = isSearch();\n        if (m.matches()) {\n            return m.group(1);\n        }\n        m = isSingleton();\n        if (m.matches()) {\n            return m.group(1).split(\"-\")[0];\n        }\n        throw new MalformedURLException(\n                \"Expected redgifs.com format: \"\n                        + \"redgifs.com/id or \"\n                        + \"thumbs.redgifs.com/id.gif\"\n                        + \" Got: \" + url);\n    }\n\n    private String stripHTMLTags(String t) {\n        t = t.replaceAll(\"<html>\\n\" +\n                                 \" <head></head>\\n\" +\n                                 \" <body>\", \"\");\n        t = t.replaceAll(\"</body>\\n\" +\n                                 \"</html>\", \"\");\n        t = t.replaceAll(\"\\n\", \"\");\n        t = t.replaceAll(\"=\\\"\\\"\", \"\");\n        return t;\n    }\n\n    @Override\n    public Document getNextPage(Document doc) throws IOException {\n        if (isSearch().matches()) {\n            Document d = Http.url(\n                    new URL(\"https://napi.redgifs.com/v1/gfycats/search?search_text=\" + searchText\n                                    + \"&count=\" + searchCount + \"&start=\" + searchCount*++searchStart))\n                       .ignoreContentType().get();\n            return (hasURLs(d).isEmpty()) ? null : d;\n        } else {\n            if (cursor.equals(\"\")) {\n                return null;\n            } else {\n                Document d =  Http.url(new URL(\"https://napi.redgifs.com/v1/users/\" +  username + \"/gfycats?count=\" + count + \"&cursor=\" + cursor)).ignoreContentType().get();\n                return (hasURLs(d).isEmpty()) ? null : d;\n            }\n        }\n    }\n\n    @Override\n    public List<String> getURLsFromPage(Document doc) {\n        List<String> result = new ArrayList<>();\n        if (isProfile().matches() || isSearch().matches()) {\n            result = hasURLs(doc);\n        } else {\n            Elements videos = doc.select(\"script\");\n            for (Element el : videos) {\n                String json = el.html();\n                if (json.startsWith(\"{\")) {\n                    JSONObject page = new JSONObject(json);\n                    result.add(page.getJSONObject(\"video\").getString(\"contentUrl\"));\n                }\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Helper method for retrieving URLs.\n     * @param doc Document of the URL page to look through\n     * @return List of URLs to download\n     */\n    public List<String> hasURLs(Document doc) {\n        List<String> result = new ArrayList<>();\n        JSONObject page = new JSONObject(stripHTMLTags(doc.html()));\n        JSONArray content = page.getJSONArray(\"gfycats\");\n        for (int i = 0; i < content.length(); i++) {\n            result.add(content.getJSONObject(i).getString(\"mp4Url\"));\n        }\n        cursor = page.getString(\"cursor\");\n        return result;\n    }\n\n    /**\n     * Helper method for retrieving video URLs.\n     * @param url URL to gfycat page\n     * @return URL to video\n     * @throws IOException\n     */\n    public static String getVideoURL(URL url) throws IOException {\n        LOGGER.info(\"Retrieving \" + url.toExternalForm());\n\n        //Sanitize the URL first\n        url = new URL(url.toExternalForm().replace(\"/gifs/detail\", \"\"));\n\n        Document doc = Http.url(url).get();\n        Elements videos = doc.select(\"script\");\n        for (Element el : videos) {\n            String json = el.html();\n            if (json.startsWith(\"{\")) {\n                JSONObject page = new JSONObject(json);\n                return page.getJSONObject(\"video\").getString(\"contentUrl\");\n            }\n        }\n        throw new IOException();\n    }\n\n}\n", "t javax.swing.JPanel;\n\nimport org.jivesoftware.smack.Chat;\n\nimport com.thang.tools.model.ChatInfo;\n\n/**\n * \u663e\u793a\u804a\u5929\u5185\u5bb9\n * @author gandilong\n *\n */\npublic class ChatPanel extends JPanel {\n\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate ShowPanel show=null;\n\tprivate InputPanel input=null; \n\t\n\tprivate ChatInfo chatInfo=null;\n\t\n\tpublic ChatPanel(ChatInfo info){\n\t\tthis.chatInfo=info;\n\t    init();\t\n\t}\n\t\n\tprivate void init(){\n\t\ttry {\n\t\t\tsetLayout(new BorderLayout());\n\t\t\tsetBorder(BorderFactory.createRaisedBevelBorder());\n\t\t\tsetSize(400, 470);\n\t\t\tinput=new InputPanel(this);\n\t\t\tshow=new ShowPanel(this);\n\t\t\tadd(input,BorderLayout.SOUTH);\n\t\t\tadd(show,BorderLayout.CENTER);\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic void show(String content){\n\t\tshow.addText(content);\n\t}\n\t\n\tpublic void setChat(Chat chat){\n\t\tinput.setChat(chat);\n\t}\n\t\n\tpublic ChatInfo getChatInfo(){\n\t\treturn chatInfo;\n\t}\n\n}\n", "loud.BaseTestClass;\nimport org.squirrelframework.cloud.resource.database.BoneCPDataSourceConfig;\nimport org.squirrelframework.cloud.utils.CloudConfigCommon;\nimport org.squirrelframework.cloud.utils.InetAddressHelper;\n\nimport javax.validation.Validation;\nimport javax.validation.Validator;\nimport javax.validation.ValidatorFactory;\nimport java.util.concurrent.CountDownLatch;\nimport java.util.concurrent.atomic.AtomicBoolean;\n\nimport static org.hamcrest.Matchers.*;\nimport static org.hamcrest.MatcherAssert.assertThat;\n\n/**\n * Created by kailianghe on 11/9/15.\n */\npublic class SimpleResourceConfigFactoryBeanTest extends BaseTestClass {\n\n    @Override\n    protected void prepare() throws Exception {\n        String generalDatabaseConfig = \"{\\n\" +\n                \"    \\\"__type__\\\" : \\\"org.squirrelframework.cloud.resource.database.BoneCPDataSourceConfig\\\",\\n\" +\n                \"    \\\"driverClassName\\\" : \\\"com.mysql.jdbc.Driver\\\",\\n\" +\n                \"    \\\"idleMaxAgeInMinutes\\\" : 240,\\n\" +\n                \"    \\\"idleConnectionTestPeriodInMinutes\\\" : 60,\\n\" +\n                \"    \\\"maxConnectionsPerPartition\\\" : 10,\\n\" +\n                \"    \\\"minConnectionsPerPartition\\\" : 1,\\n\" +\n                \"    \\\"partitionCount\\\" : 2,\\n\" +\n                \"    \\\"acquireIncrement\\\" : 5,\\n\" +\n                \"    \\\"statementsCacheSize\\\" : 100\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database\", generalDatabaseConfig.getBytes());\n\n        String bcpBaseConfig = \"{\\n\" +\n                \"    \\\"userName\\\" : \\\"root\\\",\\n\" +\n                \"    \\\"password\\\" : \\\"1111\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp\", bcpBaseConfig.getBytes());\n\n        String devConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/dev\", devConfig.getBytes());\n\n        String prodConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/prod_bcp01?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/prod\", prodConfig.getBytes());\n\n        String hheConfig = \"{\\n\" +\n                \"    \\\"userName\\\" : \\\"hhe\\\",\\n\" +\n                \"    \\\"password\\\" : \\\"1234\\\",\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/hhe_bcp01?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/hhe\", hheConfig.getBytes());\n\n        String errPartitionCount = \"{\\\"partitionCount\\\" : 0}\";\n        zkConfigClient.create().forPath(\"/database/bcp/errPartitionCount\", errPartitionCount.getBytes());\n    }\n\n    private void basicVerifyResult(BoneCPDataSourceConfig result, boolean verifyUserAndPassword) {\n        assertThat(result, notNullValue());\n        assertThat(result.getDriverClassName(), is(\"com.mysql.jdbc.Driver\"));\n        assertThat(result.getIdleMaxAgeInMinutes(), is(240));\n        assertThat(result.getIdleConnectionTestPeriodInMinutes(), is(60));\n        assertThat(result.getMaxConnectionsPerPartition(), is(10));\n        assertThat(result.getMinConnectionsPerPartition(), is(1));\n        assertThat(result.getPartitionCount(), is(2));\n        assertThat(result.getAcquireIncrement(), is(5));\n        assertThat(result.getStatementsCacheSize(), is(100));\n\n        if(verifyUserAndPassword) {\n            assertThat(result.getUserName(), is(\"root\"));\n            assertThat(result.getPassword(), is(\"1111\"));\n        }\n    }\n\n    private BoneCPDataSourceConfig createBean() throws Exception {\n        SimpleResourceConfigFactoryBean<BoneCPDataSourceConfig> factoryBean = new SimpleResourceConfigFactoryBean<>();\n        factoryBean.setClient(zkRootClient);\n        factoryBean.setPath(\"/database/bcp\");\n        factoryBean.setResourceType(BoneCPDataSourceConfig.class);\n        factoryBean.setAutoReload(true);\n\n        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();\n        Validator validator = factory.getValidator();\n        factoryBean.setValidator(validator);\n\n        factoryBean.afterPropertiesSet();\n        return factoryBean.getObject();\n    }\n\n    @Test\n    public void testCreateDataSourceConfigWithDefaultProfile() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test\n    public void testCreateDataSourceConfigWithProdProfile() throws Exception {\n        System.setProperty(CloudConfigCommon.CONFIG_PROFILE_KEY, \"prod\");\n\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/prod_bcp01?useUnicode=true\"));\n    }\n\n    @Test\n    public void testCreateDataSourceConfigWithMultipleProfiles() throws Exception {\n        System.setProperty(CloudConfigCommon.CONFIG_PROFILE_KEY, \"prod, hhe\");\n\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, false);\n        assertThat(result.getUserName(), is(\"hhe\"));\n        assertThat(result.getPassword(), is(\"1234\"));\n        assertThat(result.getJdbcUrl(),  is(\"jdbc:mysql://127.0.0.1:3306/hhe_bcp01?useUnicode=true\"));\n    }\n\n    @Test(expected = IllegalArgumentException.class)\n    public void testCreateDataSourceConfigWithValidationFailure() throws Exception {\n        System.setProperty(CloudConfigCommon.CONFIG_PROFILE_KEY, \"errPartitionCount\");\n        createBean();\n    }\n\n    @Test(timeout = 10000L)\n    public void testCreateDataSourceConfigWithReload() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        final AtomicBoolean reloadInvoked = new AtomicBoolean(false);\n        final CountDownLatch latch = new CountDownLatch(1);\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                reloadInvoked.set(true);\n                latch.countDown();\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.setData().forPath(\"/database/bcp/dev\", newDevConfig.getBytes());\n\n        latch.await();\n        assertThat(reloadInvoked.get(), is(Boolean.TRUE));\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testCreateDataSourceConfigWithNoReload() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                throw new RuntimeException(\"Should not be invoked.\");\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        // change prod profile should not affect dev profile\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/prod_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.setData().forPath(\"/database/bcp/prod\", newDevConfig.getBytes());\n\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test\n    public void testMachineSpecificDataSourceConfig() throws Exception {\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/&\"+ InetAddressHelper.localIpAddress.get(0)+\"@dev\", newDevConfig.getBytes());\n        BoneCPDataSourceConfig result = createBean();\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testMachineSpecificDataSourceConfigWithReloadAndRemove() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        final AtomicBoolean reloadInvoked = new AtomicBoolean(false);\n        final AtomicBoolean removeInvoked = new AtomicBoolean(false);\n        final CountDownLatch reLoadLatch = new CountDownLatch(1);\n        final CountDownLatch removeLatch = new CountDownLatch(1);\n\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                if(reLoadLatch.getCount()==1) {\n                    reloadInvoked.set(true);\n                    reLoadLatch.countDown();\n                } else if(reLoadLatch.getCount()==0) {\n                    removeInvoked.set(true);\n                    removeLatch.countDown();\n                }\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        String newNodeName = \"/database/bcp/&\"+ InetAddressHelper.localIpAddress.get(0)+\":255@dev\";\n        zkConfigClient.create().forPath(newNodeName, newDevConfig.getBytes());\n\n        reLoadLatch.await();\n        assertThat(reloadInvoked.get(), is(Boolean.TRUE));\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\"));\n\n        zkConfigClient.delete().deletingChildrenIfNeeded().forPath(newNodeName);\n        removeLatch.await();\n        assertThat(removeInvoked.get(), is(Boolean.TRUE));\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testMachineSpecificDataSourceConfigWithNoReload() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                throw new RuntimeException(\"Should not be invoked.\");\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/&1.1.1.1:255@dev\", newDevConfig.getBytes());\n\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n\n    @Test(timeout = 10000L)\n    public void testMachineSpecificDataSourceConfigWithNoReload2() throws Exception {\n        BoneCPDataSourceConfig result = createBean();\n        result.setReloadCallback(new ReloadCallback() {\n            @Override\n            public void reload() throws Exception {\n                throw new RuntimeException(\"Should not be invoked.\");\n            }\n        });\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n\n        String newDevConfig = \"{\\n\" +\n                \"    \\\"jdbcUrl\\\" : \\\"jdbc:mysql://127.0.0.1:3306/dev_bcp02?useUnicode=true\\\"\\n\" +\n                \"}\";\n        zkConfigClient.create().forPath(\"/database/bcp/&\"+InetAddressHelper.localIpAddress.get(0)+\"@prod\", newDevConfig.getBytes());\n\n        basicVerifyResult(result, true);\n        assertThat(result.getJdbcUrl(), is(\"jdbc:mysql://127.0.0.1:3306/dev_bcp01?useUnicode=true\"));\n    }\n}\n", "\r\nimport cs2ts6.client.ChatPanel;\r\nimport cs2ts6.client.DrawingPanel.DrawType;\r\nimport cs2ts6.packets.*;\r\n\r\n/**\r\n * \r\n * @author Stephen\r\n *\r\n */\r\npublic class Server {\r\n\t\r\n\tprivate ArrayList<Packet> packets; //FIFO queue of packets awaiting broadcast\r\n\tprivate ChatPanel logWindow; // Used if in Thread mode, to write to the chat window\r\n\t\r\n\tServer(ChatPanel cp) {\r\n\t\tpackets = new ArrayList<Packet>();\r\n\t\tpackets.add(new PointPacket(1, 1, 1, 1, Color.WHITE, 1, DrawType.FULL_CLEAR));\r\n\t\tlogWindow = cp;\r\n\t}\r\n\t/**\r\n\t * USed to get a packet top broadcast (Used by the ServerUDPThread)\r\n\t * @return The packet to be transmitted\r\n\t */\r\n\tpublic Packet getForBroadcast() {\r\n\t\tPacket bcast;\r\n\t\t//Keep taking first element while element exists\r\n\t\tif (packets.size() > 0) {\r\n\t\t\tbcast = packets.get(0);\r\n\t\t\tpackets.remove(0);\r\n\t\t\treturn bcast; // Return a packet\r\n\t\t}\r\n\t\telse {\r\n\t\t\t// USed if no packets on queue to keep broadcast alive - used for client auto connect\r\n\t\t\ttry {\r\n\t\t\t\tThread.sleep(10); //pause for 10ms\r\n\t\t\t} catch (InterruptedException e) {}\r\n\t\t\treturn new ChatPacket(\"KEEPALIVE\",\"\"); // Ensures clients can connect\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Used to write logging messages, either to chat windows or to cli server\r\n\t * @param message\r\n\t */\r\n\tpublic void writeServerMessage(String message) {\r\n\t\tif(logWindow == null) { //Am in CLI mode - direct and not thread from GUI\r\n\t\t\tSystem.out.println(message);\r\n\t\t} else {\r\n\t\t\tlogWindow.drawMessage(new ChatPacket(\"SERVER\",message));\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * \r\n\t * @param pkt Packet to be added to the packet queue, not sent immediately.\r\n\t */\r\n\tpublic void addToBroadcast(Packet pkt) {\r\n\t\tpackets.add(pkt);\r\n\t}\r\n\t/**\r\n\t * Sets up a server\r\n\t * @param args\r\n\t * @throws IOException\r\n\t */\r\n\tpublic static void main(String[] args) throws IOException{\r\n\t\tSystem.out.println(\"Launching Server\");\r\n\t\tServer srv = new Server(null); // Pass null as log window, so will use System.out\r\n\t\tnew CollectorServer(srv).start(); //starts receives from client - to recieve packets\r\n\t\tnew ServerUDPThread(srv).start(); //starts broadcast thread -  to send packets\r\n\t}\r\n}\r\n", "owered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.common.data.type;\n\nimport org.spongepowered.api.data.type.MatterType;\n\npublic final class SpongeMatterType implements MatterType {\n}\n", "kage com.azure.core.util.serializer;\n\nimport com.fasterxml.jackson.core.JsonParser;\nimport org.junit.jupiter.params.ParameterizedTest;\nimport org.junit.jupiter.params.provider.Arguments;\nimport org.junit.jupiter.params.provider.MethodSource;\n\nimport java.io.IOException;\nimport java.time.OffsetDateTime;\nimport java.time.ZoneOffset;\nimport java.util.stream.Stream;\n\nimport static org.junit.jupiter.api.Assertions.assertEquals;\nimport static org.mockito.Mockito.mock;\nimport static org.mockito.Mockito.when;\n\n/**\n * Tests for {@link DateTimeDeserializer}.\n */\npublic class DateTimeDeserializerTests {\n    @ParameterizedTest\n    @MethodSource(\"deserializeOffsetDateTimeSupplier\")\n    public void deserializeJson(String offsetDateTimeString, OffsetDateTime expected) throws IOException {\n        JsonParser parser = mock(JsonParser.class);\n        when(parser.getValueAsString()).thenReturn(offsetDateTimeString);\n\n        assertEquals(expected, new DateTimeDeserializer().deserialize(parser, null));\n    }\n\n    private static Stream<Arguments> deserializeOffsetDateTimeSupplier() {\n        OffsetDateTime minValue = OffsetDateTime.of(1, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);\n        OffsetDateTime unixEpoch = OffsetDateTime.of(1970, 1, 1, 0, 0, 0, 0, ZoneOffset.UTC);\n\n        return Stream.of(\n            Arguments.of(\"0001-01-01T00:00:00\", minValue),\n            Arguments.of(\"0001-01-01T00:00:00Z\", minValue),\n            Arguments.of(\"1970-01-01T00:00:00\", unixEpoch),\n            Arguments.of(\"1970-01-01T00:00:00Z\", unixEpoch)\n        );\n    }\n}\n", "GsonUtil.Constants.PROP_ID;\nimport static com.github.messenger4j.internal.gson.GsonUtil.Constants.PROP_RECIPIENT;\nimport static com.github.messenger4j.internal.gson.GsonUtil.Constants.PROP_SENDER;\nimport static com.github.messenger4j.internal.gson.GsonUtil.Constants.PROP_TIMESTAMP;\nimport static com.github.messenger4j.internal.gson.GsonUtil.getPropertyAsInstant;\nimport static com.github.messenger4j.internal.gson.GsonUtil.getPropertyAsString;\n\nimport com.github.messenger4j.internal.Lists;\nimport com.github.messenger4j.webhook.Event;\nimport com.github.messenger4j.webhook.event.FallbackEvent;\nimport com.google.gson.JsonObject;\nimport java.time.Instant;\nimport java.util.List;\n\n/**\n * @author Max Grabenhorst\n * @since 1.0.0\n */\npublic final class EventFactory {\n\n  private static final List<BaseEventFactory> FACTORIES =\n      Lists.immutableList(\n          new TextMessageEventFactory(),\n          new AttachmentMessageEventFactory(),\n          new QuickReplyMessageEventFactory(),\n          new PostbackEventFactory(),\n          new ReferralEventFactory(),\n          new OptInEventFactory(),\n          new MessageEchoEventFactory(),\n          new MessageDeliveredEventFactory(),\n          new MessageReadEventFactory(),\n          new AccountLinkingEventFactory(),\n          new InstantGameEventFactory());\n\n  private EventFactory() {}\n\n  public static Event createEvent(JsonObject messagingEvent) {\n    for (BaseEventFactory factory : FACTORIES) {\n      if (factory.isResponsible(messagingEvent)) {\n        return new Event(factory.createEventFromJson(messagingEvent));\n      }\n    }\n    final String senderId =\n        getPropertyAsString(messagingEvent, PROP_SENDER, PROP_ID)\n            .orElseThrow(IllegalArgumentException::new);\n    final String recipientId =\n        getPropertyAsString(messagingEvent, PROP_RECIPIENT, PROP_ID)\n            .orElseThrow(IllegalArgumentException::new);\n    final Instant timestamp =\n        getPropertyAsInstant(messagingEvent, PROP_TIMESTAMP).orElse(Instant.now());\n    return new Event(new FallbackEvent(senderId, recipientId, timestamp));\n  }\n}\n", "org.innovateuk.ifs.user.resource.ProfileRole;\nimport org.innovateuk.ifs.user.resource.RoleProfileStatusResource;\nimport org.junit.Test;\nimport org.springframework.core.ParameterizedTypeReference;\n\nimport java.util.List;\n\nimport static java.lang.String.format;\nimport static org.innovateuk.ifs.user.builder.RoleProfileStatusResourceBuilder.newRoleProfileStatusResource;\nimport static org.junit.Assert.assertEquals;\nimport static org.junit.Assert.assertTrue;\n\n\npublic class RoleProfileStatusRestServiceTest extends BaseRestServiceUnitTest<RoleProfileStatusRestServiceImpl> {\n\n    private String restUrl = \"/user/%d/role-profile-status\";\n\n    @Override\n    protected RoleProfileStatusRestServiceImpl registerRestServiceUnderTest() {\n        return new RoleProfileStatusRestServiceImpl();\n    }\n\n    @Test\n    public void updateUserStatus() {\n        long userId = 1L;\n        RoleProfileStatusResource resource = new RoleProfileStatusResource();\n\n        setupPutWithRestResultExpectations(format(restUrl, userId), resource);\n\n        assertTrue(service.updateUserStatus(userId, resource).isSuccess());\n    }\n\n    @Test\n    public void findByUserId() {\n        long userId = 1L;\n        List<RoleProfileStatusResource> resources = newRoleProfileStatusResource().build(1);\n\n        setupGetWithRestResultExpectations(format(restUrl, userId), new ParameterizedTypeReference<List<RoleProfileStatusResource>>() {}, resources);\n\n        assertEquals(resources, service.findByUserId(userId).getSuccess());\n    }\n\n    @Test\n    public void findByUserIdAndProfileRole() {\n        long userId = 1L;\n        ProfileRole role = ProfileRole.ASSESSOR;\n        RoleProfileStatusResource resource = newRoleProfileStatusResource().build();\n\n        setupGetWithRestResultExpectations(format(restUrl, userId) + \"/\" + role.name(), RoleProfileStatusResource.class, resource);\n\n        assertEquals(resource, service.findByUserIdAndProfileRole(userId, role).getSuccess());\n    }\n}", "lic interface HasPattern {\n\n\t/** Get pattern from constraint. */\n\tString getPattern();\n\n}\n", "mport android.graphics.Paint;\nimport android.support.annotation.Nullable;\nimport android.util.AttributeSet;\nimport android.util.Log;\nimport android.view.MotionEvent;\nimport android.view.View;\n\n/**\n * Description\n *\n * @author liupeng502\n * @data 2017/9/7\n */\n\npublic class ListIndicator4 extends View {\n\n    private Paint mPaint;\n    private String[] text={\"\u6982\u51b5\",\"\u75c5\u56e0\",\"\u68c0\u67e5\",\"\u68c0\u67e5\",\"\u4e34\u5e8a\",\"\u8868\u73b0\",\"\u89e3\u51b3\u529e\u6cd5\",\"\u6ce8\u610f\"};\n    private int measuredWidth;\n    private int sectionHeight;\n    private int measuredHeight;\n    private float downY;\n    private OnTouchListner mTouchListner;\n    private int selectedPosition=0;\n\n    public ListIndicator4(Context context) {\n        this(context,null);\n    }\n\n    public ListIndicator4(Context context, @Nullable AttributeSet attrs) {\n        this(context, attrs,0);\n    }\n\n    public ListIndicator4(Context context, @Nullable AttributeSet attrs, int defStyleAttr) {\n        super(context, attrs, defStyleAttr);\n\n        mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\n        mPaint.setColor(getResources().getColor(R.color.color_353535));\n        mPaint.setTextSize(60);\n        mPaint.setTextAlign(Paint.Align.CENTER);\n    }\n\n    @Override\n    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {\n        super.onMeasure(widthMeasureSpec, heightMeasureSpec);\n        measuredWidth = getMeasuredWidth();\n        measuredHeight = getMeasuredHeight();\n        sectionHeight = measuredHeight / text.length;\n    }\n\n    @Override\n    protected void onDraw(Canvas canvas) {\n        super.onDraw(canvas);\n        Paint.FontMetricsInt fm = mPaint.getFontMetricsInt();\n        int ascent = fm.ascent;\n\n        for (int i = 0; i < text.length; i++) {\n            canvas.drawLine(0,sectionHeight*i,measuredWidth,sectionHeight*i,mPaint);\n            //int textY = sectionHeight / 2 + i * sectionHeight - ascent/2;\n            int textY = (sectionHeight -ascent) / 2 + i * sectionHeight;\n            if (selectedPosition == i) {\n                mPaint.setColor(getResources().getColor(R.color.color_ff6602));\n            }else{\n                mPaint.setColor(getResources().getColor(R.color.color_353535));\n            }\n            canvas.drawText(text[i],measuredWidth/2,textY,mPaint);\n\n        }\n        canvas.drawLine(0,measuredHeight,measuredWidth,measuredHeight,mPaint);\n    }\n\n\n    @Override\n    public boolean dispatchTouchEvent(MotionEvent event) {\n        switch(event.getAction()){\n            case MotionEvent.ACTION_DOWN:\n                downY = event.getY();\n                int position = (int) (downY / sectionHeight);\n                selectedPosition = position;\n                Log.d(\"tag\", \"position=\"+position);\n                if (mTouchListner != null) {\n                    mTouchListner.onTouch(position);\n                }\n                break;\n            case MotionEvent.ACTION_MOVE:\n                float moveY = event.getY();\n                int movePosition = (int) (moveY / sectionHeight);\n                selectedPosition=movePosition;\n                Log.d(\"tag\", \"position=\"+movePosition);\n                if (mTouchListner != null) {\n                    mTouchListner.onTouch(movePosition);\n                }\n                break;\n            case MotionEvent.ACTION_UP:\n\n                break;\n            default:\n        }\n        invalidate();\n        return true;\n    }\n\n    public void setSelectedPosition(int position){\n        selectedPosition=position;\n        invalidate();\n    }\n\n    interface OnTouchListner{\n        void onTouch(int position);\n    }\n    public void setOnTouchListner(OnTouchListner touchListner){\n        mTouchListner = touchListner;\n    }\n}\n", ".crcs.ectester.data.EC_Store;\n\nimport java.security.*;\nimport java.security.spec.AlgorithmParameterSpec;\nimport java.security.AlgorithmParameters;\nimport java.security.spec.ECGenParameterSpec;\nimport java.security.spec.ECParameterSpec;\nimport java.security.spec.InvalidParameterSpecException;\n\n/**\n * @author Jan Jancar johny@neuromancer.sk\n */\npublic abstract class NativeKeyPairGeneratorSpi extends KeyPairGeneratorSpi {\n    private int keysize;\n    private SecureRandom random;\n    private AlgorithmParameterSpec params;\n    private boolean useKeysize;\n    private boolean useParams;\n\n    public static final int DEFAULT_KEYSIZE = 256;\n\n    @Override\n    public void initialize(int keysize, SecureRandom random) {\n        if (!keysizeSupported(keysize)) {\n            throw new InvalidParameterException(\"Keysize \" + keysize + \" not supported.\");\n        }\n        this.keysize = keysize;\n        this.random = random;\n        this.useKeysize = true;\n        this.useParams = false;\n    }\n\n    @Override\n    public void initialize(AlgorithmParameterSpec params, SecureRandom random) throws InvalidAlgorithmParameterException {\n        if (!paramsSupported(params)) {\n            throw new InvalidAlgorithmParameterException(\"Not supported.\");\n        }\n        this.params = params;\n        this.random = random;\n        this.useParams = true;\n        this.useKeysize = false;\n    }\n\n    @Override\n    public KeyPair generateKeyPair() {\n        if (!useKeysize && !useParams) {\n            if (keysizeSupported(DEFAULT_KEYSIZE)) {\n                initialize(DEFAULT_KEYSIZE, new SecureRandom());\n            }\n        }\n\n        if (useKeysize) {\n            return generate(keysize, random);\n        } else if (useParams) {\n            return generate(params, random);\n        } else {\n            throw new IllegalStateException(\"Uninitialized KeyPair.\");\n        }\n    }\n\n    abstract boolean keysizeSupported(int keysize);\n\n    abstract boolean paramsSupported(AlgorithmParameterSpec params);\n\n    abstract KeyPair generate(int keysize, SecureRandom random);\n\n    abstract KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n\n\n    public static class TomCrypt extends NativeKeyPairGeneratorSpi {\n\n        public TomCrypt() {\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static abstract class Botan extends NativeKeyPairGeneratorSpi {\n        private String type;\n\n        public Botan(String type) {\n            this.type = type;\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class BotanECDH extends Botan {\n\n        public BotanECDH() {\n            super(\"ECDH\");\n        }\n    }\n\n    public static class BotanECDSA extends Botan {\n\n        public BotanECDSA() {\n            super(\"ECDSA\");\n        }\n    }\n\n    public static class BotanECKCDSA extends Botan {\n\n        public BotanECKCDSA() {\n            super(\"ECKCDSA\");\n        }\n    }\n\n    public static class BotanECGDSA extends Botan {\n\n        public BotanECGDSA() {\n            super(\"ECGDSA\");\n        }\n    }\n\n    public static abstract class Cryptopp extends NativeKeyPairGeneratorSpi {\n        private String type;\n\n        public Cryptopp(String type) {\n            this.type = type;\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class CryptoppECDH extends Cryptopp {\n\n        public CryptoppECDH() {\n            super(\"ECDH\");\n        }\n    }\n\n    public static class CryptoppECDSA extends Cryptopp {\n\n        public CryptoppECDSA() {\n            super(\"ECDSA\");\n        }\n    }\n\n    public static class Openssl extends NativeKeyPairGeneratorSpi {\n        public Openssl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Boringssl extends NativeKeyPairGeneratorSpi {\n        public Boringssl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Gcrypt extends NativeKeyPairGeneratorSpi {\n\n        public Gcrypt() {\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static abstract class Mscng extends NativeKeyPairGeneratorSpi {\n        private String type;\n\n        public Mscng(String type) {\n            this.type = type;\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class MscngECDH extends Mscng {\n\n        public MscngECDH() {\n            super(\"ECDH\");\n        }\n    }\n\n    public static class MscngECDSA extends Mscng {\n\n        public MscngECDSA() {\n            super(\"ECDSA\");\n        }\n    }\n\n    public static class MbedTLS extends NativeKeyPairGeneratorSpi {\n\n        public MbedTLS() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Ippcp extends NativeKeyPairGeneratorSpi {\n\n        public Ippcp() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Matrixssl extends NativeKeyPairGeneratorSpi {\n\n        public Matrixssl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n  \n    public static class Libressl extends NativeKeyPairGeneratorSpi {\n\n        public Libressl() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random);\n    }\n\n    public static class Nettle extends NativeKeyPairGeneratorSpi {\n        public Nettle() {\n            initialize(256, new SecureRandom());\n        }\n\n        @Override\n        native boolean keysizeSupported(int keysize);\n\n        @Override\n        native boolean paramsSupported(AlgorithmParameterSpec params);\n\n        @Override\n        native KeyPair generate(int keysize, SecureRandom random);\n\n        @Override\n        KeyPair generate(AlgorithmParameterSpec params, SecureRandom random) {\n            if (params instanceof ECGenParameterSpec) {\n                    String curveName = ((ECGenParameterSpec) params).getName();\n                    if (curveName.contains(\"secp\")) {\n                        curveName = \"secg/\" + curveName;\n                    }\n                    EC_Curve curve = EC_Store.getInstance().getObject(EC_Curve.class, curveName);\n                    ECParameterSpec spec = curve.toSpec();\n                    return generate(params, random, spec);\n            }\n            return null;\n        }\n\n        native KeyPair generate(AlgorithmParameterSpec params, SecureRandom random, AlgorithmParameterSpec spec);\n    }\n}\n", "not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *    http://opensource.org/licenses/mit-license.php\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\npackage com.google.dogecoin.core;\n\nimport java.io.File;\nimport java.util.List;\n\nimport com.google.dogecoin.store.BlockStore;\nimport com.google.dogecoin.store.BlockStoreException;\nimport com.google.dogecoin.store.SPVBlockStore;\n\n/**\n * Extension of bitcoinj BlockChain for use with block chain replay.\n */\npublic class MultiBitBlockChain extends BlockChain {\n\n    public MultiBitBlockChain(NetworkParameters params, Wallet wallet, BlockStore blockStore) throws BlockStoreException {\n        super(params, wallet, blockStore);\n    }\n\n    public MultiBitBlockChain(NetworkParameters params, BlockStore blockStore) throws BlockStoreException {\n        super(params, blockStore);\n    }\n\n    public MultiBitBlockChain(NetworkParameters params, List<BlockChainListener> wallets, BlockStore blockStore) throws BlockStoreException {\n        super(params, wallets, blockStore);\n    }\n    \n    /**\n     * Set the chainhead, clear any cached blocks and truncate the blockchain .\n     * (Used for blockchain replay).\n     * @param chainHead\n     * @throws BlockStoreException\n     */\n    public void setChainHeadClearCachesAndTruncateBlockStore(StoredBlock chainHead, String blockStoreFilename) throws BlockStoreException {\n        if (blockStore instanceof SPVBlockStore) {\n            // Delete the blockstore and recreate it.\n            ((SPVBlockStore) blockStore).close();\n\n            File blockStoreFile = new File(blockStoreFilename);\n            blockStoreFile.delete();\n        } else {\n            blockStore.setChainHead(chainHead);\n            super.setChainHead(chainHead);\n        }\n    }\n}\n", "playMetrics;\nimport android.view.WindowManager;\n\npublic class UiUtils {\n\n    static public int getScreenWidthPixels(Context context) {\n        DisplayMetrics dm = new DisplayMetrics();\n        ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay()\n                .getMetrics(dm);\n        return dm.widthPixels;\n    }\n\n    static public int dipToPx(Context context, int dip) {\n        return (int) (dip * getScreenDensity(context) + 0.5f);\n    }\n\n    static public float getScreenDensity(Context context) {\n        try {\n            DisplayMetrics dm = new DisplayMetrics();\n            ((WindowManager) context.getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay()\n                    .getMetrics(dm);\n            return dm.density;\n        } catch (Exception e) {\n            return DisplayMetrics.DENSITY_DEFAULT;\n        }\n    }\n\n}\n", "avax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletResponse;\n\n/**\n * \n * @author Colin Bundervoet\n *\n */\npublic abstract class RenderFile implements ActionResult {\n\n\t@Override\n\tpublic void handle(HttpServletRequest request, HttpServletResponse response)\n\t\t\tthrows ServletException, IOException {\n\t\t\n\t\tresponse.setCharacterEncoding(\"utf-8\");\n\t\t\n\t\tString login = (String) request.getSession().getAttribute(\"login.username\");\n\t\tString name = (String) request.getSession().getAttribute(\"login.name\");\n\t\tString admin = (String) request.getSession().getAttribute(\"login.admin\");\n\t\t\n\t\tif (login != null && name != null && admin != null) {\n\t\t\tSystem.out.println(\"Login found for \" + login);\n\t\t\trequest.setAttribute(\"username\", login);\n\t\t\trequest.setAttribute(\"name\", name);\n\t\t\trequest.setAttribute(\"admin\", admin.equals(\"true\"));\n\t\t}\n\t\t\n\t}\n\n}\n", "sion;\nimport org.hibernate.SessionFactory;\nimport org.hibernate.boot.registry.StandardServiceRegistryBuilder;\nimport org.hibernate.cfg.Configuration;\nimport org.hibernate.service.ServiceRegistry;\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\n\nimport java.util.List;\n\n/**\n * \u041f\u0440\u043e\u0441\u0442\u043e\u0439 \u043f\u0440\u0438\u043c\u0435\u0440 \u0434\u043b\u044f \u0434\u0435\u043c\u043e\u043d\u0441\u0442\u0440\u0430\u0446\u0438\u0438 \u0438\u0435\u0440\u0430\u0440\u0445\u0438\u0438\n *\n * @author ASaburov\n */\npublic class HibernateManyToMany {\n\n    private static final Logger log = LoggerFactory.getLogger(HibernateManyToMany.class);\n\n    private static SessionFactory sessionFactory;\n    private static ServiceRegistry serviceRegistry;\n\n    private static void init() {\n        Configuration configuration = new Configuration();\n        configuration.configure(\"hibernate.cfg.xml\");\n        serviceRegistry = new StandardServiceRegistryBuilder().applySettings(configuration.getProperties()).build();\n        sessionFactory = configuration.buildSessionFactory(serviceRegistry);\n    }\n\n    private static void destroy() {\n        StandardServiceRegistryBuilder.destroy(serviceRegistry);\n    }\n\n    public static void main(String[] args) {\n        init();\n\n        Session s = sessionFactory.getCurrentSession();\n        s.beginTransaction();\n\n        Author oldAuthor = new Author();\n        oldAuthor.setAuthorName(\"New Author 0\");\n        s.save(oldAuthor);\n\n        saveBook(oldAuthor, s);\n\n        List<Book> bookList = s.createCriteria(Book.class).list();\n        for (Book book : bookList) {\n            log.debug(\"\");\n            log.debug(\"Book: {}\", book);\n            for (Author author : book.getAuthorList()) {\n                log.debug(\"Author: {}\", author);\n            }\n        }\n\n        oldAuthor = bookList.get(0).getAuthorList().iterator().next();\n        Book oldBook = bookList.get(0);\n\n        saveBook(oldAuthor, s);\n        // saveAuthor(oldBook, s);\n\n        // \u0415\u0441\u043b\u0438 \u043d\u0435 \u0437\u0430\u043a\u0440\u044b\u0442\u044c - \u0442\u043e \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442 \u043e\u0448\u0438\u0431\u043a\u0430\n        s.getTransaction().commit();\n\n        s = sessionFactory.getCurrentSession();\n        s.beginTransaction();\n\n        bookList = s.createCriteria(Book.class).list();\n        for (Book book : bookList) {\n            log.debug(\"\");\n            log.debug(\"Book: {}\", book);\n            for (Author author : book.getAuthorList()) {\n                log.debug(\"Author: {}\", author);\n            }\n        }\n\n        s.getTransaction().commit();\n\n        log.debug(\"Transaction committed\");\n\n        destroy();\n    }\n\n    private static void saveBook(Author oldAuthor, Session s) throws HibernateException {\n        Book newBook = new Book();\n        newBook.setBookName(\"New book 1\");\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0438 \u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0435\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430\n        newBook.addAuthor(oldAuthor);\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430 \u043a \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0435\n        Author newAuthor = new Author();\n        newAuthor.setAuthorName(\"New Author 1\");\n        // \u041d\u0435\u0442 \u043d\u0430\u0434\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u043a\u043d\u0438\u0433\u0443 \u043a \u0430\u0432\u0442\u043e\u0440\u0443\n        // \u0415\u0441\u043b\u0438 \u0441\u0432\u044f\u0437\u044c \u043e\u0434\u043d\u043e\u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u0430\u044f - \u0442\u043e \u043d\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430. \u0418\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0437\u0430\u0431\u0430\u0432\u043d\u044b\u0439 \u044d\u0444\u0444\u0435\u043a\u0442\n        //newAuthor.addBook(newBook);\n\n        newBook.addAuthor(newAuthor);\n        s.save(newAuthor);\n\n\n        s.save(newBook);\n    }\n\n    private void saveAuthor(Book oldBook, Session s) throws HibernateException {\n        Author newAuthor = new Author();\n        newAuthor.setAuthorName(\"New Author 2\");\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0438 \u0438 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0435\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430\n        newAuthor.addBook(oldBook);\n\n        // \u0412\u0430\u0440\u0438\u0430\u043d\u0442 \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f \u043d\u043e\u0432\u043e\u0433\u043e \u0430\u0432\u0442\u043e\u0440\u0430 \u043a \u043d\u043e\u0432\u043e\u0439 \u043a\u043d\u0438\u0433\u0435\n        Book newBook = new Book();\n        newBook.setBookName(\"New Book 2\");\n        // \u041d\u0435\u0442 \u043d\u0430\u0434\u043e\u0431\u043d\u043e\u0441\u0442\u0438 \u0434\u043e\u0431\u0430\u0432\u043b\u044f\u0442\u044c \u0430\u0432\u0442\u043e\u0440\u0430 \u043a \u043a\u043d\u0438\u0433\u0435\n        // \u0415\u0441\u043b\u0438 \u0441\u0432\u044f\u0437\u044c \u043e\u0434\u043d\u043e\u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u043d\u0430\u044f - \u0442\u043e \u043d\u0435 \u043f\u0440\u043e\u0431\u043b\u0435\u043c\u0430. \u0418\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0437\u0430\u0431\u0430\u0432\u043d\u044b\u0439 \u044d\u0444\u0444\u0435\u043a\u0442\n        //newBook.addAuthor(newAuthor);\n        newAuthor.addBook(newBook);\n        s.save(newBook);\n\n        s.save(newAuthor);\n    }\n\n\n    private SessionFactory getSessionFactory() {\n\n        Configuration configuration = new Configuration().configure();\n        SessionFactory sessionFactory = configuration.buildSessionFactory(\n                new StandardServiceRegistryBuilder()\n                        .applySettings(configuration.getProperties())\n                        .build()\n        );\n        return sessionFactory;\n\n    }\n}\n", "e.layout.AnchorPane;\nimport javafx.stage.Stage;\nimport seedu.stask.MainApp;\n\n/**\n * A utility class to load UiParts from FXML files.\n */\npublic class UiPartLoader {\n    private final static String FXML_FILE_FOLDER = \"/view/\";\n\n    public static <T extends UiPart> T loadUiPart(Stage primaryStage, T controllerSeed) {\n        return loadUiPart(primaryStage, null, controllerSeed);\n    }\n\n    /**\n     * Returns the ui class for a specific UI Part.\n     *\n     * @param primaryStage The primary stage for the view.\n     * @param placeholder The placeholder where the loaded Ui Part is added.\n     * @param sampleUiPart The sample of the expected UiPart class.\n     * @param <T> The type of the UiPart\n     */\n    public static <T extends UiPart> T loadUiPart(Stage primaryStage, AnchorPane placeholder, T sampleUiPart) {\n        FXMLLoader loader = new FXMLLoader();\n        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + sampleUiPart.getFxmlPath()));\n        Node mainNode = loadLoader(loader, sampleUiPart.getFxmlPath());\n        UiPart controller = loader.getController();\n        controller.setStage(primaryStage);\n        controller.setPlaceholder(placeholder);\n        controller.setNode(mainNode);\n        return (T)controller;\n    }\n\n    /**\n     * Returns the ui class for a specific UI Part.\n     *\n     * @param seedUiPart The UiPart object to be used as the ui.\n     * @param <T> The type of the UiPart\n     */\n\n    public static <T extends UiPart> T loadUiPart(T seedUiPart) {\n        FXMLLoader loader = new FXMLLoader();\n        loader.setLocation(MainApp.class.getResource(FXML_FILE_FOLDER + seedUiPart.getFxmlPath()));\n        loader.setController(seedUiPart);\n        loadLoader(loader, seedUiPart.getFxmlPath());\n        return seedUiPart;\n    }\n\n\n    private static Node loadLoader(FXMLLoader loader, String fxmlFileName) {\n        try {\n            return loader.load();\n        } catch (Exception e) {\n            String errorMessage = \"FXML Load Error for \" + fxmlFileName;\n            throw new RuntimeException(errorMessage, e);\n        }\n    }\n\n}\n", "r data fully carried over to a ServerMessage.\n * @author Nillus\n *\n */\npublic interface SerializableObject\n{\n\t/**\n\t * Serializes the object to a ServerMessage.\n\t * @param msg The ServerMessage object to serialize this SerializableObject to.\n\t */\n\tpublic void serialize(ServerMessage msg);\n}\n", "annotation.JsonProperty;\n\n/**\n * \n * @author Johannes Hiemer. \n *\n */\npublic class ServicePlan {\n\n\t@JsonProperty(\"name\")\n    private String name;\n    \n\t@JsonProperty(\"free\")\n    private boolean free;\n    \n\t@JsonProperty(\"description\")\n    private String description;\n    \n\t@JsonProperty(\"service_guid\")\t\n    private UUID serviceGuid;\n    \n\t@JsonProperty(\"extra\")\n    private Object extra;\n    \n\t@JsonProperty(\"unique_id\")\n    private String uniqueId;\n    \n\t@JsonProperty(\"public\")\n    private boolean pub;\n    \n\t@JsonProperty(\"service_url\")\n    private String serviceUrl;\n    \n\t@JsonProperty(\"service_instances_url\")\n    private String serviceInstanceUrl;\n\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\n\tpublic boolean isFree() {\n\t\treturn free;\n\t}\n\n\tpublic void setFree(boolean free) {\n\t\tthis.free = free;\n\t}\n\n\tpublic String getDescription() {\n\t\treturn description;\n\t}\n\n\tpublic void setDescription(String description) {\n\t\tthis.description = description;\n\t}\n\n\tpublic UUID getServiceGuid() {\n\t\treturn serviceGuid;\n\t}\n\n\tpublic void setServiceGuid(UUID serviceGuid) {\n\t\tthis.serviceGuid = serviceGuid;\n\t}\n\n\tpublic Object getExtra() {\n\t\treturn extra;\n\t}\n\n\tpublic void setExtra(Object extra) {\n\t\tthis.extra = extra;\n\t}\n\n\tpublic String getUniqueId() {\n\t\treturn uniqueId;\n\t}\n\n\tpublic void setUniqueId(String uniqueId) {\n\t\tthis.uniqueId = uniqueId;\n\t}\n\n\tpublic boolean isPub() {\n\t\treturn pub;\n\t}\n\n\tpublic void setPub(boolean pub) {\n\t\tthis.pub = pub;\n\t}\n\n\tpublic String getServiceUrl() {\n\t\treturn serviceUrl;\n\t}\n\n\tpublic void setServiceUrl(String serviceUrl) {\n\t\tthis.serviceUrl = serviceUrl;\n\t}\n\n\tpublic String getServiceInstanceUrl() {\n\t\treturn serviceInstanceUrl;\n\t}\n\n\tpublic void setServiceInstanceUrl(String serviceInstanceUrl) {\n\t\tthis.serviceInstanceUrl = serviceInstanceUrl;\n\t}\n\t\n}\n", "t android.os.Build;\nimport android.support.annotation.DrawableRes;\nimport android.support.annotation.NonNull;\nimport android.support.annotation.Nullable;\nimport android.support.v7.widget.RecyclerView;\nimport android.view.View;\n\nimport org.tndata.android.compass.databinding.CardGoalBinding;\nimport org.tndata.android.compass.util.ImageLoader;\n\n\n/**\n * Single goal view holder.\n *\n * @author Ismael Alonso\n * @version 1.0.0\n */\npublic class GoalCardHolder extends RecyclerView.ViewHolder implements View.OnClickListener{\n    private CardGoalBinding mBinding;\n    private Listener mListener;\n\n\n    /**\n     * Constructor.\n     *\n     * @param binding the binding object\n     */\n    public GoalCardHolder(@NonNull CardGoalBinding binding, @Nullable Listener listener){\n        super(binding.getRoot());\n        mBinding = binding;\n        mListener = listener;\n        itemView.setOnClickListener(this);\n    }\n\n    /**\n     * Sets the color of the goal's icon container.\n     *\n     * @param color the color of the icon container.\n     */\n    @SuppressWarnings(\"deprecation\")\n    public void setColor(int color){\n        GradientDrawable gradientDrawable = (GradientDrawable)mBinding.goalIconContainer.getBackground();\n        gradientDrawable.setColor(color);\n        if (Build.VERSION.SDK_INT < Build.VERSION_CODES.JELLY_BEAN){\n            mBinding.goalIconContainer.setBackgroundDrawable(gradientDrawable);\n        }\n        else{\n            mBinding.goalIconContainer.setBackground(gradientDrawable);\n        }\n        mBinding.goalHeader.setBackgroundColor(color);\n    }\n\n    /**\n     * Loads the icon in the provided URL into the goal icon view.\n     *\n     * @param url the URL to fetch the icon from.\n     */\n    public void setIcon(@NonNull String url){\n        ImageLoader.loadBitmap(mBinding.goalIcon, url);\n    }\n\n    /**\n     * Sets a drawable resource as the goal icon.\n     *\n     * @param resourceId the id of the drawable.\n     */\n    public void setIcon(@DrawableRes int resourceId){\n        mBinding.goalIconContainer.setBackgroundResource(resourceId);\n    }\n\n    /**\n     * Sets the title of the goal.\n     *\n     * @param title the title of the goal.\n     */\n    public void setTitle(@NonNull String title){\n        mBinding.goalTitle.setText(title);\n    }\n\n    @Override\n    public void onClick(View v){\n        mListener.onGoalCardClick();\n    }\n\n\n    /**\n     * Listener interface for GoalCardHolder.\n     *\n     * @author Ismael Alonso\n     * @version 1.0.0\n     */\n    public interface Listener{\n        /**\n         * Called when the card is tapped.\n         */\n        void onGoalCardClick();\n    }\n}\n", "terface.ReturnsResponse;\nimport org.organet.michael.CommandLineInterface.ScansForAdhocNetworks;\n\nimport java.util.*;\n\npublic class IwlistScan extends CommandBase implements ScansForAdhocNetworks, ReturnsResponse {\n  public IwlistScan(String adhocInterfaceName) {\n    super(\"/sbin/iwlist\", Arrays.asList(adhocInterfaceName, \"scan\"));\n  }\n\n  // TODO Search for \"integration\" in the project \"wireless\" and move the lines from there to here\n  @Override\n  public Object getResponse() {\n    // Run the command\n    Object response = this.run();\n    if (response == null) {\n      return false;\n    }\n\n    String responseString = String.valueOf(response);\n\n    // Parse the output\n    List<Map<String, String>> networks = new ArrayList<>();\n    String[] splitted = responseString.split(\"Cell \\\\d\\\\d - \");\n    for (int i = 1, len = splitted.length; i < len; i++) {\n      // Address, ESSID, Protocol, Mode, Frequency\n      Map<String, String> network = new HashMap<>(5);\n      String[] lines = splitted[i].split(\"\\n\");\n\n      for (int j = 0, linesCount = lines.length; j < linesCount; j++) {\n        String line = lines[j].trim();\n        if (!line.contains(\":\")) {\n          continue;\n        }\n\n        String[] keyValue = line.split(\":\", 2);\n        if (\"address, essid, protocol, mode, frequency\".contains(keyValue[0].toLowerCase())) {\n          network.put(keyValue[0].toLowerCase(), keyValue[1]);\n        }\n      }\n\n      if (network.get(\"mode\").toLowerCase().equals(\"ad-hoc\")) {\n        networks.add(network);\n      }\n    }\n\n    // Return meaningful response\n    return networks;\n  }\n}\n", "ee AUTHORS)\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy of\n * this software and associated documentation files (the \"Software\"), to deal in\n * the Software without restriction, including without limitation the rights to\n * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of\n * the Software, and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS\n * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR\n * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER\n * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n */\npackage eu.verdelhan.ta4j.analysis.criteria;\n\nimport eu.verdelhan.ta4j.AnalysisCriterion;\nimport eu.verdelhan.ta4j.Strategy;\nimport eu.verdelhan.ta4j.TimeSeries;\nimport java.util.List;\n\n/**\n * An abstract analysis criterion.\n */\npublic abstract class AbstractAnalysisCriterion implements AnalysisCriterion {\n\n    @Override\n    public Strategy chooseBest(TimeSeries series, List<Strategy> strategies) {\n        Strategy bestStrategy = strategies.get(0);\n        double bestCriterionValue = calculate(series, series.run(bestStrategy));\n\n        for (int i = 1; i < strategies.size(); i++) {\n            Strategy currentStrategy = strategies.get(i);\n            double currentCriterionValue = calculate(series, series.run(currentStrategy));\n\n            if (betterThan(currentCriterionValue, bestCriterionValue)) {\n                bestStrategy = currentStrategy;\n                bestCriterionValue = currentCriterionValue;\n            }\n        }\n        return bestStrategy;\n    }\n\n    @Override\n    public String toString() {\n        String[] tokens = getClass().getSimpleName().split(\"(?=\\\\p{Lu})\", -1);\n        StringBuilder sb = new StringBuilder();\n        for (int i = 0; i < tokens.length - 1; i++) {\n            sb.append(tokens[i]).append(' ');\n        }\n        return sb.toString().trim();\n    }\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/*\n * @test\n * @bug 6916074\n * @summary Add support for TLS 1.2\n * @run main/othervm X509ExtendedTMEnabled\n *\n *     SunJSSE does not support dynamic system properties, no way to re-use\n *     system properties in samevm/agentvm mode.\n *\n * Ensure that the SunJSSE provider enables the X509ExtendedTrustManager.\n */\n\nimport java.io.*;\nimport java.net.*;\nimport javax.net.ssl.*;\nimport java.security.cert.*;\nimport java.security.*;\n\npublic class X509ExtendedTMEnabled {\n\n    /*\n     * =============================================================\n     * Set the various variables needed for the tests, then\n     * specify what tests to run on each side.\n     */\n\n    /*\n     * Should we run the client or server in a separate thread?\n     * Both sides can throw exceptions, but do you have a preference\n     * as to which side should be the main thread.\n     */\n    static boolean separateServerThread = true;\n\n    /*\n     * Where do we find the keystores?\n     */\n    static String pathToStores = \"../../../../../../../etc\";\n    static String keyStoreFile = \"keystore\";\n    static String trustStoreFile = \"truststore\";\n    static String passwd = \"passphrase\";\n    private final static char[] cpasswd = \"passphrase\".toCharArray();\n\n    /*\n     * Is the server ready to serve?\n     */\n    volatile static boolean serverReady = false;\n\n    /*\n     * Turn on SSL debugging?\n     */\n    static boolean debug = false;\n\n    /*\n     * If the client or server is doing some kind of object creation\n     * that the other side depends on, and that thread prematurely\n     * exits, you may experience a hang.  The test harness will\n     * terminate all hung threads after its timeout has expired,\n     * currently 3 minutes by default, but you might try to be\n     * smart about it....\n     */\n\n    /*\n     * Define the server side of the test.\n     *\n     * If the server prematurely exits, serverReady will be set to true\n     * to avoid infinite hangs.\n     */\n    void doServerSide() throws Exception {\n        SSLServerSocketFactory sslssf =\n                                getContext(true).getServerSocketFactory();\n        SSLServerSocket sslServerSocket =\n            (SSLServerSocket) sslssf.createServerSocket(serverPort);\n        serverPort = sslServerSocket.getLocalPort();\n\n        // enable endpoint identification\n        // ignore, we may test the feature when known how to parse client\n        // hostname\n        //SSLParameters params = sslServerSocket.getSSLParameters();\n        //params.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        //sslServerSocket.setSSLParameters(params);\n\n        /*\n         * Signal Client, we're ready for his connect.\n         */\n        serverReady = true;\n\n        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n        sslSocket.setNeedClientAuth(true);\n        InputStream sslIS = sslSocket.getInputStream();\n        OutputStream sslOS = sslSocket.getOutputStream();\n\n        sslIS.read();\n        sslOS.write(85);\n        sslOS.flush();\n\n        sslSocket.close();\n\n        if (!serverTM.wasServerChecked() && serverTM.wasClientChecked()) {\n            System.out.println(\"SERVER TEST PASSED!\");\n        } else {\n            throw new Exception(\"SERVER TEST FAILED!  \" +\n                !serverTM.wasServerChecked() + \" \" +\n                serverTM.wasClientChecked());\n        }\n    }\n\n    /*\n     * Define the client side of the test.\n     *\n     * If the server prematurely exits, serverReady will be set to true\n     * to avoid infinite hangs.\n     */\n    void doClientSide() throws Exception {\n\n        /*\n         * Wait for server to get started.\n         */\n        while (!serverReady) {\n            Thread.sleep(50);\n        }\n\n        SSLSocketFactory sslsf = getContext(false).getSocketFactory();\n        SSLSocket sslSocket = (SSLSocket)\n            sslsf.createSocket(\"localhost\", serverPort);\n\n        // enable endpoint identification\n        SSLParameters params = sslSocket.getSSLParameters();\n        params.setEndpointIdentificationAlgorithm(\"HTTPS\");\n        sslSocket.setSSLParameters(params);\n\n        InputStream sslIS = sslSocket.getInputStream();\n        OutputStream sslOS = sslSocket.getOutputStream();\n\n        sslOS.write(280);\n        sslOS.flush();\n        sslIS.read();\n\n        sslSocket.close();\n\n        if (clientTM.wasServerChecked() && !clientTM.wasClientChecked()) {\n            System.out.println(\"CLIENT TEST PASSED!\");\n        } else {\n            throw new Exception(\"CLIENT TEST FAILED!  \" +\n                clientTM.wasServerChecked() + \" \" +\n                !clientTM.wasClientChecked());\n        }\n    }\n\n    MyExtendedX509TM serverTM;\n    MyExtendedX509TM clientTM;\n\n    private SSLContext getContext(boolean server) throws Exception {\n        String keyFilename =\n            System.getProperty(\"test.src\", \"./\") + \"/\" + pathToStores +\n                \"/\" + keyStoreFile;\n        String trustFilename =\n            System.getProperty(\"test.src\", \"./\") + \"/\" + pathToStores +\n                \"/\" + trustStoreFile;\n\n        KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n        KeyStore ks = KeyStore.getInstance(\"JKS\");\n        ks.load(new FileInputStream(keyFilename), cpasswd);\n        kmf.init(ks, cpasswd);\n\n        TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n        KeyStore ts = KeyStore.getInstance(\"JKS\");\n        ts.load(new FileInputStream(trustFilename), cpasswd);\n        tmf.init(ts);\n\n        TrustManager tms[] = tmf.getTrustManagers();\n        if (tms == null || tms.length == 0) {\n            throw new Exception(\"unexpected trust manager implementation\");\n        } else {\n           if (!(tms[0] instanceof X509TrustManager)) {\n            throw new Exception(\"unexpected trust manager implementation: \"\n                                + tms[0].getClass().getCanonicalName());\n           }\n        }\n\n        if (server) {\n            serverTM = new MyExtendedX509TM((X509TrustManager)tms[0]);\n\n            tms = new TrustManager[] {serverTM};\n        } else {\n            clientTM = new MyExtendedX509TM((X509TrustManager)tms[0]);\n\n            tms = new TrustManager[] {clientTM};\n        }\n\n        SSLContext ctx = SSLContext.getInstance(\"TLS\");\n        ctx.init(kmf.getKeyManagers(), tms, null);\n\n        return ctx;\n    }\n\n    static class MyExtendedX509TM extends X509ExtendedTrustManager\n            implements X509TrustManager {\n\n        X509TrustManager tm;\n\n        boolean clientChecked;\n        boolean serverChecked;\n\n        MyExtendedX509TM(X509TrustManager tm) {\n            clientChecked = false;\n            serverChecked = false;\n\n            this.tm = tm;\n        }\n\n        public boolean wasClientChecked() {\n            return clientChecked;\n        }\n\n        public boolean wasServerChecked() {\n            return serverChecked;\n        }\n\n\n        public void checkClientTrusted(X509Certificate chain[], String authType)\n                throws CertificateException {\n            tm.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate chain[], String authType)\n                throws CertificateException {\n            tm.checkServerTrusted(chain, authType);\n        }\n\n        public X509Certificate[] getAcceptedIssuers() {\n            return tm.getAcceptedIssuers();\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType,\n                Socket socket) throws CertificateException {\n            clientChecked = true;\n            tm.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType,\n                Socket socket) throws CertificateException {\n            serverChecked = true;\n            tm.checkServerTrusted(chain, authType);\n        }\n\n        public void checkClientTrusted(X509Certificate[] chain, String authType,\n            SSLEngine engine) throws CertificateException {\n            clientChecked = true;\n            tm.checkClientTrusted(chain, authType);\n        }\n\n        public void checkServerTrusted(X509Certificate[] chain, String authType,\n            SSLEngine engine) throws CertificateException {\n            serverChecked = true;\n            tm.checkServerTrusted(chain, authType);\n        }\n    }\n\n    /*\n     * =============================================================\n     * The remainder is just support stuff\n     */\n\n    // use any free port by default\n    volatile int serverPort = 0;\n\n    volatile Exception serverException = null;\n    volatile Exception clientException = null;\n\n    public static void main(String[] args) throws Exception {\n\n        if (debug)\n            System.setProperty(\"javax.net.debug\", \"all\");\n\n        /*\n         * Start the tests.\n         */\n        new X509ExtendedTMEnabled();\n    }\n\n    Thread clientThread = null;\n    Thread serverThread = null;\n\n    /*\n     * Primary constructor, used to drive remainder of the test.\n     *\n     * Fork off the other side, then do your work.\n     */\n    X509ExtendedTMEnabled() throws Exception {\n        if (separateServerThread) {\n            startServer(true);\n            startClient(false);\n        } else {\n            startClient(true);\n            startServer(false);\n        }\n\n        /*\n         * Wait for other side to close down.\n         */\n        if (separateServerThread) {\n            serverThread.join();\n        } else {\n            clientThread.join();\n        }\n\n        /*\n         * When we get here, the test is pretty much over.\n         *\n         * If the main thread excepted, that propagates back\n         * immediately.  If the other thread threw an exception, we\n         * should report back.\n         */\n        if (serverException != null)\n            throw serverException;\n        if (clientException != null)\n            throw clientException;\n    }\n\n    void startServer(boolean newThread) throws Exception {\n        if (newThread) {\n            serverThread = new Thread() {\n                public void run() {\n                    try {\n                        doServerSide();\n                    } catch (Exception e) {\n                        /*\n                         * Our server thread just died.\n                         *\n                         * Release the client, if not active already...\n                         */\n                        System.err.println(\"Server died...\");\n                        serverReady = true;\n                        serverException = e;\n                    }\n                }\n            };\n            serverThread.start();\n        } else {\n            doServerSide();\n        }\n    }\n\n    void startClient(boolean newThread) throws Exception {\n        if (newThread) {\n            clientThread = new Thread() {\n                public void run() {\n                    try {\n                        doClientSide();\n                    } catch (Exception e) {\n                        /*\n              * Our client thread just died.\n                         */\n                        System.err.println(\"Client died...\");\n                        clientException = e;\n                    }\n                }\n            };\n            clientThread.start();\n        } else {\n            doClientSide();\n        }\n    }\n}\n\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.netapp.v2019_11_01;\n\nimport java.util.Collection;\nimport com.fasterxml.jackson.annotation.JsonCreator;\nimport com.microsoft.rest.ExpandableStringEnum;\n\n/**\n * Defines values for InAvailabilityReasonType.\n */\npublic final class InAvailabilityReasonType extends ExpandableStringEnum<InAvailabilityReasonType> {\n    /** Static value Invalid for InAvailabilityReasonType. */\n    public static final InAvailabilityReasonType INVALID = fromString(\"Invalid\");\n\n    /** Static value AlreadyExists for InAvailabilityReasonType. */\n    public static final InAvailabilityReasonType ALREADY_EXISTS = fromString(\"AlreadyExists\");\n\n    /**\n     * Creates or finds a InAvailabilityReasonType from its string representation.\n     * @param name a name to look for\n     * @return the corresponding InAvailabilityReasonType\n     */\n    @JsonCreator\n    public static InAvailabilityReasonType fromString(String name) {\n        return fromString(name, InAvailabilityReasonType.class);\n    }\n\n    /**\n     * @return known InAvailabilityReasonType values\n     */\n    public static Collection<InAvailabilityReasonType> values() {\n        return values(InAvailabilityReasonType.class);\n    }\n}\n", ";\r\nimport javax.persistence.ManyToOne;\r\nimport javax.persistence.OneToMany;\r\n\r\nimport play.db.jpa.Model;\r\n\r\n@Entity\r\npublic class OrderForm extends Model{\r\n\t\r\n\tpublic Date dateOfOrder;\r\n\t\r\n\tpublic int numberOfOrder;\r\n\t\r\n\t@ManyToOne\r\n\tpublic Company company;\r\n\t\r\n\t@ManyToOne\r\n\tpublic BusinessYear businessYear;\r\n\t\r\n\t@ManyToOne\r\n\tpublic BusinessPartner businessPartner;\r\n\t\r\n\t@OneToMany(mappedBy = \"orderForm\")\r\n\tpublic List<OrderFormItem> orderFormItems;\r\n\t\r\n\tpublic OrderForm(Date dateOfOrder, int numberOfOrder) {\r\n\t\tthis.dateOfOrder = dateOfOrder;\r\n\t\tthis.numberOfOrder = numberOfOrder;\r\n\t}\r\n}\r\n", " * NOTE: This class is auto generated by the swagger code generator program.\n * https://github.com/swagger-api/swagger-codegen.git\n * Do not edit the class manually.\n */\n\n\npackage net.telestream.cloud.qc;\n\nimport java.util.Objects;\nimport com.google.gson.TypeAdapter;\nimport com.google.gson.annotations.JsonAdapter;\nimport com.google.gson.annotations.SerializedName;\nimport com.google.gson.stream.JsonReader;\nimport com.google.gson.stream.JsonWriter;\nimport io.swagger.annotations.ApiModel;\nimport io.swagger.annotations.ApiModelProperty;\nimport java.io.IOException;\n\n/**\n * Proxy\n */\n\npublic class Proxy {\n  @SerializedName(\"status\")\n  private String status = null;\n\n  @SerializedName(\"progress\")\n  private Integer progress = null;\n\n  @SerializedName(\"url\")\n  private String url = null;\n\n  @SerializedName(\"id\")\n  private String id = null;\n\n  @SerializedName(\"updated_at\")\n  private String updatedAt = null;\n\n  public Proxy status(String status) {\n    this.status = status;\n    return this;\n  }\n\n   /**\n   * Get status\n   * @return status\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getStatus() {\n    return status;\n  }\n\n  public void setStatus(String status) {\n    this.status = status;\n  }\n\n  public Proxy progress(Integer progress) {\n    this.progress = progress;\n    return this;\n  }\n\n   /**\n   * Get progress\n   * @return progress\n  **/\n  @ApiModelProperty(value = \"\")\n  public Integer getProgress() {\n    return progress;\n  }\n\n  public void setProgress(Integer progress) {\n    this.progress = progress;\n  }\n\n  public Proxy url(String url) {\n    this.url = url;\n    return this;\n  }\n\n   /**\n   * Get url\n   * @return url\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getUrl() {\n    return url;\n  }\n\n  public void setUrl(String url) {\n    this.url = url;\n  }\n\n  public Proxy id(String id) {\n    this.id = id;\n    return this;\n  }\n\n   /**\n   * Get id\n   * @return id\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getId() {\n    return id;\n  }\n\n  public void setId(String id) {\n    this.id = id;\n  }\n\n  public Proxy updatedAt(String updatedAt) {\n    this.updatedAt = updatedAt;\n    return this;\n  }\n\n   /**\n   * Get updatedAt\n   * @return updatedAt\n  **/\n  @ApiModelProperty(value = \"\")\n  public String getUpdatedAt() {\n    return updatedAt;\n  }\n\n  public void setUpdatedAt(String updatedAt) {\n    this.updatedAt = updatedAt;\n  }\n\n\n  @Override\n  public boolean equals(java.lang.Object o) {\n    if (this == o) {\n      return true;\n    }\n    if (o == null || getClass() != o.getClass()) {\n      return false;\n    }\n    Proxy proxy = (Proxy) o;\n    return Objects.equals(this.status, proxy.status) &&\n        Objects.equals(this.progress, proxy.progress) &&\n        Objects.equals(this.url, proxy.url) &&\n        Objects.equals(this.id, proxy.id) &&\n        Objects.equals(this.updatedAt, proxy.updatedAt);\n  }\n\n  @Override\n  public int hashCode() {\n    return Objects.hash(status, progress, url, id, updatedAt);\n  }\n\n\n  @Override\n  public String toString() {\n    StringBuilder sb = new StringBuilder();\n    sb.append(\"class Proxy {\\n\");\n    \n    sb.append(\"    status: \").append(toIndentedString(status)).append(\"\\n\");\n    sb.append(\"    progress: \").append(toIndentedString(progress)).append(\"\\n\");\n    sb.append(\"    url: \").append(toIndentedString(url)).append(\"\\n\");\n    sb.append(\"    id: \").append(toIndentedString(id)).append(\"\\n\");\n    sb.append(\"    updatedAt: \").append(toIndentedString(updatedAt)).append(\"\\n\");\n    sb.append(\"}\");\n    return sb.toString();\n  }\n\n  /**\n   * Convert the given object to string with each line indented by 4 spaces\n   * (except the first line).\n   */\n  private String toIndentedString(java.lang.Object o) {\n    if (o == null) {\n      return \"null\";\n    }\n    return o.toString().replace(\"\\n\", \"\\n    \");\n  }\n\n}\n\n", "erary;\nimport UI.Commands.Command;\n\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * This is the class that is used to represent an individual Session\n * This class has two states Connected and NotConnected which changes the systems behavior\n * Language: Java 1.8 Level 8\n * Created: 11/4/17\n * Revisited: 11/5/17\n * Revisited: 11/6/17\n * @author : Stephen Cook(sjc5897@g.rit.edu)\n */\npublic class Session\n{\n    private static HashMap<Integer, Session> connectionHashMap= new HashMap<>();\n    private int connectionID;\n    private ArrayList<Itinerary> lastQueried;\n    private int looper;\n    private State currentState;\n    private Stack<Command> undoStack;\n    private Stack<Command> redoStack;\n\n    /**\n     * The constructor for the Connection\n     * @param ID            The Connection ID\n     * @param connection    The Connection State\n     */\n    private Session(Integer ID, State connection){\n        this.connectionID =ID;\n        this.lastQueried = new ArrayList<>();\n        this.looper = 0;\n        this.currentState = connection;\n        this.undoStack = new Stack<>();\n        this.redoStack = new Stack<>();\n    }\n\n    /**\n     * Changes the current state of the session\n     * @param connection The new state of the session\n     */\n    public void setCurrentState(State connection){\n        this.currentState = connection;\n    }\n\n    /**\n     * This calls the current states flight query method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] FlightQuery(String[] args){\n        return this.currentState.FlightQuery(args);\n    }\n\n    /**\n     * This sets the last queried to the new last queried by the session\n     * @param q The new flight query object\n     */\n    public void setQuery(FlightQuery q){\n        this. lastQueried = q.getItineraries();\n    }\n\n    /**\n     * This gets the last query\n     * @return The last query\n     */\n    public ArrayList<Itinerary> getLastQueried(){\n        return this.lastQueried;\n    }\n\n    /**\n     * This calls the current states create reservation method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] createReservation(String [] args){\n        return this.currentState.createReservation(args);\n    }\n\n    /**\n     * This calls the current states delete reservation method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] deleteReservation(String[] args){\n        return this.currentState.deleteReservation(args);\n    }\n\n    /**\n     * This calls the current states retrieve reservation method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] retrieveReservation(String[] args){\n        return this.currentState.retrieveReservation(args);\n    }\n\n    /**\n     * This calls the current states airport info method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] airportInformation(String[] args){return this.currentState.airportInfo(args);}\n\n    /**\n     * This calls the current states airport server method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] airportServer(String[] args){\n        return this.currentState.airportServer(args);\n    }\n\n    /**\n     * This calls the current states disconnect method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] disconnect(String [] args){return this.currentState.disconnect(args);}\n\n    /**\n     * This method adds a new connection to the connection hash map\n     * @param connectionID  The connection Id\n     * @param connection    The connection state\n     */\n    public static void addConnection(Integer connectionID, State connection){\n        Session Session = new Session(connectionID,connection);\n        connectionHashMap.put(connectionID, Session);\n    }\n\n    /**\n     * Gets the connection hash map\n     * @return the connection hash map\n     */\n    public static HashMap<Integer, Session> getConnectionHashMap(){\n        return connectionHashMap;\n    }\n\n    /**\n     *\n     * @return\n     */\n    public Stack<Command> getUndoStack() {return undoStack;}\n    public Stack<Command> getRedoStack() {return redoStack;}\n\n    /**\n     * This calls the current states flight query method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] undo(String args[]) {return this.currentState.undo(args);}\n\n    /**\n     * This calls the current states flight query method\n     * @param args The String array that represents user input\n     * @return The String Array Response\n     */\n    public String[] redo(String[] args) {\n        return this.currentState.redo(args);\n    }\n\n\n    /**\n     * Gets the looper value for this session\n     * @return The looper value\n     */\n    public int getLooper(){return this.looper;}\n\n    /**\n     * Adds one to the looper\n     */\n    public void addLooper(){this.looper = this.looper+1;}\n\n    /**\n     * Saves the current reservation list on disconnect\n     */\n    public void saveState(){this.currentState.saveState();}\n\n}\n", "e are subject to the Mozilla Public License Version\n * 1.1 (the \"License\"); you may not use this file except in compliance with\n * the License. You may obtain a copy of the License at\n * http://www.mozilla.org/MPL/\n *\n * Software distributed under the License is distributed on an \"AS IS\" basis,\n * WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License\n * for the specific language governing rights and limitations under the\n * License.\n *\n * The Original Code is Rhino code, released\n * May 6, 1999.\n *\n * The Initial Developer of the Original Code is\n * Netscape Communications Corporation.\n * Portions created by the Initial Developer are Copyright (C) 1997-1999\n * the Initial Developer. All Rights Reserved.\n *\n * Contributor(s):\n *   Igor Bukanov\n *   Bob Jervis\n *\n * Alternatively, the contents of this file may be used under the terms of\n * the GNU General Public License Version 2 or later (the \"GPL\"), in which\n * case the provisions of the GPL are applicable instead of those above. If\n * you wish to allow use of your version of this file only under the terms of\n * the GPL and not to allow others to use your version of this file under the\n * MPL, indicate your decision by deleting the provisions above and replacing\n * them with the notice and other provisions required by the GPL. If you do\n * not delete the provisions above, a recipient may use your version of this\n * file under either the MPL or the GPL.\n *\n * ***** END LICENSE BLOCK ***** */\n\npackage com.google.javascript.rhino;\n\npublic class ScriptOrFnNode extends Node {\n\n    private static final long serialVersionUID = 1L;\n\n    public ScriptOrFnNode(int nodeType) {\n        callSuper(nodeType);\n    }\n\n    public ScriptOrFnNode(int nodeType, int lineno, int charno) {\n        callSuper(nodeType, lineno, charno);\n    }\n\n    public final String getSourceName() { return sourceName; }\n\n    public final void setSourceName(String sourceName) {\n        this.sourceName = sourceName;\n    }\n\n    public final int getEncodedSourceStart() { return encodedSourceStart; }\n\n    public final int getEncodedSourceEnd() { return encodedSourceEnd; }\n\n    public final void setEncodedSourceBounds(int start, int end) {\n        this.encodedSourceStart = start;\n        this.encodedSourceEnd = end;\n    }\n\n    public final int getBaseLineno() { return baseLineno; }\n\n    public final void setBaseLineno(int lineno) {\n        // One time action\n        if (lineno < 0 || baseLineno >= 0) Kit.codeBug();\n        baseLineno = lineno;\n    }\n\n    public final int getEndLineno() { return endLineno; }\n\n    public final void setEndLineno(int lineno) {\n        // One time action\n        if (lineno < 0 || endLineno >= 0) Kit.codeBug();\n        endLineno = lineno;\n    }\n\n    public final int getFunctionCount() {\n        if (functions == null) { return 0; }\n        return functions.size();\n    }\n\n    public final FunctionNode getFunctionNode(int i) {\n        return (FunctionNode)functions.get(i);\n    }\n\n    public final int addFunction(FunctionNode fnNode) {\n        if (fnNode == null) Kit.codeBug();\n        if (functions == null) { functions = new ObjArray(); }\n        functions.add(fnNode);\n        return functions.size() - 1;\n    }\n\n    public final int getRegexpCount() {\n        if (regexps == null) { return 0; }\n        return regexps.size() / 2;\n    }\n\n    public final String getRegexpString(int index) {\n        return (String)regexps.get(index * 2);\n    }\n\n    public final String getRegexpFlags(int index) {\n        return (String)regexps.get(index * 2 + 1);\n    }\n\n    public final int addRegexp(String string, String flags) {\n        if (string == null) Kit.codeBug();\n        if (regexps == null) { regexps = new ObjArray(); }\n        regexps.add(string);\n        regexps.add(flags);\n        return regexps.size() / 2 - 1;\n    }\n\n    public final boolean hasParamOrVar(String name) {\n        return itsVariableNames.has(name);\n    }\n\n    public final int getParamOrVarIndex(String name) {\n        return itsVariableNames.get(name, -1);\n    }\n\n    public final String getParamOrVarName(int index) {\n        return (String)itsVariables.get(index);\n    }\n\n    public final int getParamCount() {\n        return varStart;\n    }\n\n    public final int getParamAndVarCount() {\n        return itsVariables.size();\n    }\n\n    public final String[] getParamAndVarNames() {\n        int N = itsVariables.size();\n        if (N == 0) {\n            return ScriptRuntime.emptyStrings;\n        }\n        String[] array = new String[N];\n        itsVariables.toArray(array);\n        return array;\n    }\n\n    public final boolean[] getParamAndVarConst() {\n        int N = itsVariables.size();\n        boolean[] array = new boolean[N];\n        for (int i = 0; i < N; i++)\n            if (itsConst.get(i) != null)\n                array[i] = true;\n        return array;\n    }\n\n    public final void addParam(String name) {\n        // Check addparam is not called after addLocal\n        if (varStart != itsVariables.size()) Kit.codeBug();\n        // Allow non-unique parameter names: use the last occurrence (parser\n        // will warn about dups)\n        int index = varStart++;\n        itsVariables.add(name);\n        itsConst.add(null);\n        itsVariableNames.put(name, index);\n    }\n\n    public static final int NO_DUPLICATE = 1;\n    public static final int DUPLICATE_VAR = 0;\n    public static final int DUPLICATE_PARAMETER = -1;\n    public static final int DUPLICATE_CONST = -2;\n\n    /**\n     * This function adds a variable to the set of var declarations for a\n     * function (or script).  This returns an indicator of a duplicate that\n     * overrides a formal parameter (false if this dups a parameter).\n     * @param name variable name\n     * @return 1 if the name is not any form of duplicate, 0 if it duplicates a\n     * non-parameter, -1 if it duplicates a parameter and -2 if it duplicates a\n     * const.\n     */\n    public final int addVar(String name) {\n        int vIndex = itsVariableNames.get(name, -1);\n        if (vIndex != -1) {\n            // There's already a variable or parameter with this name.\n            if (vIndex >= varStart) {\n                Object v = itsConst.get(vIndex);\n                if (v != null)\n                    return DUPLICATE_CONST;\n                else\n                    return DUPLICATE_VAR;\n            } else\n                return DUPLICATE_PARAMETER;\n        }\n        int index = itsVariables.size();\n        itsVariables.add(name);\n        itsConst.add(null);\n        itsVariableNames.put(name, index);\n        return NO_DUPLICATE;\n    }\n\n    public final boolean addConst(String name) {\n        int vIndex = itsVariableNames.get(name, -1);\n        if (vIndex != -1) {\n            // There's already a variable or parameter with this name.\n            return false;\n        }\n        int index = itsVariables.size();\n        itsVariables.add(name);\n        itsConst.add(name);\n        itsVariableNames.put(name, index);\n        return true;\n    }\n\n    public final void removeParamOrVar(String name) {\n        int i = itsVariableNames.get(name, -1);\n        if (i != -1) {\n            itsVariables.remove(i);\n            itsVariableNames.remove(name);\n            ObjToIntMap.Iterator iter = itsVariableNames.newIterator();\n            for (iter.start(); !iter.done(); iter.next()) {\n                int v = iter.getValue();\n                if (v > i) {\n                    iter.setValue(v - 1);\n                }\n            }\n        }\n    }\n\n    public final Object getCompilerData()\n    {\n        return compilerData;\n    }\n\n    public final void setCompilerData(Object data)\n    {\n        if (data == null) throw new IllegalArgumentException();\n        // Can only call once\n        if (compilerData != null) throw new IllegalStateException();\n        compilerData = data;\n    }\n\n    private int encodedSourceStart;\n    private int encodedSourceEnd;\n    private String sourceName;\n    private int baseLineno = -1;\n    private int endLineno = -1;\n\n    private ObjArray functions;\n\n    private ObjArray regexps;\n\n    // a list of the formal parameters and local variables\n    private ObjArray itsVariables = new ObjArray();\n    private ObjArray itsConst = new ObjArray();\n\n    // mapping from name to index in list\n    private ObjToIntMap itsVariableNames = new ObjToIntMap(11);\n\n    private int varStart;               // index in list of first variable\n\n    private Object compilerData;\n}\n", "s.dialogs.BADialog.BADialogResponse;\nimport wallettemplate.utils.dialogs.BADialog.BADialogResponseListner;\n\npublic class DialogFactory {\n\tstatic BADialog infoDialog(Class<?> resourceClass, String title, String desc) {\n\t\tBADialog ret = new BADialog();\n\t\tret.setViewPath(\"utils/dialogs/infoDialog.fxml\")\n\t\t\t.setResourceClass(resourceClass)\n\t\t\t.setWindowTitle(\"info\")\n\t\t\t.setTitle(title)\n\t\t\t.setDesc(desc);\n\t\treturn ret;\n\t}\n\t\n\tstatic BADialog confirmDialog(Class<?> resourceClass, BADialogResponseListner response, String title, String desc) {\n\t\tBADialog ret = new BADialog();\n\t\tret.setViewPath(\"utils/dialogs/confirmDialog.fxml\")\n\t\t\t.setResourceClass(resourceClass)\n\t\t\t.setWindowTitle(\"Confirm\")\n\t\t\t.setTitle(title)\n\t\t\t.setDesc(desc)\n\t\t\t.setResponseListener(response);\n\t\treturn ret;\n\t}\n\t\n\tstatic BADialog inputDialog(Class<?> resourceClass, BADialogResponseListner response, String title, String desc) {\n\t\tBADialog ret = new BADialog();\n\t\tret.setViewPath(\"utils/dialogs/inputDialog.fxml\")\n\t\t\t.setResourceClass(resourceClass)\n\t\t\t.setWindowTitle(\"Please Complete\")\n\t\t\t.setTitle(title)\n\t\t\t.setDesc(desc)\n\t\t\t.setResponseListener(response);\n\t\treturn ret;\n\t}\n}\n", "droid.support.v4.app.ListFragment;\nimport android.view.View;\nimport android.widget.ArrayAdapter;\nimport android.widget.ListView;\n\n/**\n * A list fragment representing a list of Cars. This fragment\n * also supports tablet devices by allowing list items to be given an\n * 'activated' state upon selection. This helps indicate which item is\n * currently being viewed in a {@link CarDetailFragment}.\n * <p>\n * Activities containing this fragment MUST implement the {@link Callbacks}\n * interface.\n */\npublic class CarListFragment extends ListFragment {\n\n    /**\n     * The serialization (saved instance state) Bundle key representing the\n     * activated item position. Only used on tablets.\n     */\n    private static final String STATE_ACTIVATED_POSITION = \"activated_position\";\n\n    /**\n     * The fragment's current callback object, which is notified of list item\n     * clicks.\n     */\n    private Callbacks mCallbacks = sDummyCallbacks;\n\n    /**\n     * The current activated item position. Only used on tablets.\n     */\n    private int mActivatedPosition = ListView.INVALID_POSITION;\n\n    private CarDatabase database;\n\n    /**\n     * A callback interface that all activities containing this fragment must\n     * implement. This mechanism allows activities to be notified of item\n     * selections.\n     */\n    public interface Callbacks {\n        /**\n         * Callback for when an item has been selected.\n         */\n        public void onItemSelected(Integer id);\n    }\n\n    /**\n     * A dummy implementation of the {@link Callbacks} interface that does\n     * nothing. Used only when this fragment is not attached to an activity.\n     */\n    private static Callbacks sDummyCallbacks = new Callbacks() {\n        @Override\n        public void onItemSelected(Integer id) {\n        }\n    };\n\n    /**\n     * Mandatory empty constructor for the fragment manager to instantiate the\n     * fragment (e.g. upon screen orientation changes).\n     */\n    public CarListFragment() {\n        database = new CarDatabase();\n    }\n\n    @Override\n    public void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n\n        getActivity().getActionBar().setDisplayHomeAsUpEnabled(false);\n\n        // TODO: replace with a real list adapter.\n        setListAdapter(new CarsArrayAdapter(getActivity(), database.findAll()));\n    }\n\n    @Override\n    public void onViewCreated(View view, Bundle savedInstanceState) {\n        super.onViewCreated(view, savedInstanceState);\n\n        // Restore the previously serialized activated item position.\n        if (savedInstanceState != null\n                && savedInstanceState.containsKey(STATE_ACTIVATED_POSITION)) {\n            setActivatedPosition(savedInstanceState.getInt(STATE_ACTIVATED_POSITION));\n        }\n    }\n\n    @Override\n    public void onAttach(Activity activity) {\n        super.onAttach(activity);\n\n        // Activities containing this fragment must implement its callbacks.\n        if (!(activity instanceof Callbacks)) {\n            throw new IllegalStateException(\"Activity must implement fragment's callbacks.\");\n        }\n\n        mCallbacks = (Callbacks) activity;\n    }\n\n    @Override\n    public void onDetach() {\n        super.onDetach();\n\n        // Reset the active callbacks interface to the dummy implementation.\n        mCallbacks = sDummyCallbacks;\n    }\n\n    @Override\n    public void onListItemClick(ListView listView, View view, int position, long id) {\n        super.onListItemClick(listView, view, position, id);\n\n        // Notify the active callbacks interface (the activity, if the\n        // fragment is attached to one) that an item has been selected.\n        mCallbacks.onItemSelected(database.findAll().get(position).getId());\n    }\n\n    @Override\n    public void onSaveInstanceState(Bundle outState) {\n        super.onSaveInstanceState(outState);\n        if (mActivatedPosition != ListView.INVALID_POSITION) {\n            // Serialize and persist the activated item position.\n            outState.putInt(STATE_ACTIVATED_POSITION, mActivatedPosition);\n        }\n    }\n\n    /**\n     * Turns on activate-on-click mode. When this mode is on, list items will be\n     * given the 'activated' state when touched.\n     */\n    public void setActivateOnItemClick(boolean activateOnItemClick) {\n        // When setting CHOICE_MODE_SINGLE, ListView will automatically\n        // give items the 'activated' state when touched.\n        getListView().setChoiceMode(activateOnItemClick\n                ? ListView.CHOICE_MODE_SINGLE\n                : ListView.CHOICE_MODE_NONE);\n    }\n\n    private void setActivatedPosition(int position) {\n        if (position == ListView.INVALID_POSITION) {\n            getListView().setItemChecked(mActivatedPosition, false);\n        } else {\n            getListView().setItemChecked(position, true);\n        }\n\n        mActivatedPosition = position;\n    }\n}\n", "de available under the MIT License.\n\nCopyright (c) 2012 The Multiverse Foundation\n\nPermission is hereby granted, free of charge, to any person \nobtaining a copy of this software and associated documentation \nfiles (the \"Software\"), to deal in the Software without restriction, \nincluding without limitation the rights to use, copy, modify, \nmerge, publish, distribute, sublicense, and/or sell copies \nof the Software, and to permit persons to whom the Software \nis furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be \nincluded in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, \nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES \nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND \nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT \nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, \nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING \nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE \nOR OTHER DEALINGS IN THE SOFTWARE.\n\n*********************************************************************/\n\npackage multiverse.server.engine;\n\nimport java.util.Map;\nimport java.util.Set;\n\n\npublic class PropertyMatcher implements Matcher\n{\n    public PropertyMatcher(SearchClause query)\n    {\n        queryProps = ((PropertySearch)query).getProperties();\n    }\n\n    public boolean match(Object object)\n    {\n        Map target = (Map) object;\n        if (target == null) {\n            if (queryProps.size() == 0)\n                return true;\n            else\n                return false;\n        }\n\n        for (Map.Entry queryProp : (Set<Map.Entry>) queryProps.entrySet()) {\n            Object queryKey = queryProp.getKey();\n            Object queryValue = queryProp.getValue();\n            Object targetValue = target.get(queryKey);\n            if (targetValue == null) {\n                if (! target.containsKey(queryKey) || queryValue != null)\n                    return false;\n            }\n            if (queryValue == null)\n                return false;\n            if (! targetValue.equals(queryValue))\n                return false;\n        }\n        return true;\n    }\n\n    public static class Factory implements MatcherFactory\n    {\n        public Factory()\n        {\n        }\n        \n        public Matcher createMatcher(SearchClause query)\n        {\n            return new PropertyMatcher(query);\n        }\n    }\n\n    private Map queryProps;\n}\n\n", ", The Pistoia Alliance\n * \n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n ******************************************************************************/\npackage org.helm.notation.demo.tools;\n\nimport org.helm.notation.tools.*;\n\n/**\n * \n * @author zhangtianhong\n */\npublic class PeptideSequenceParserSample {\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tString notation = PeptideSequenceParser.getNotation(\"AGG   seC   \");\n\t\t\tSystem.out.println(notation);\n\n\t\t\tnotation = PeptideSequenceParser\n\t\t\t\t\t.getNotation(\"AGG.seC.GGG.seC\", \".\");\n\t\t\tSystem.out.println(notation);\n\n\t\t\tnotation = PeptideSequenceParser.getNotation(\"AGG seC.seC.GGG.seC\",\n\t\t\t\t\t\".\");\n\t\t\tSystem.out.println(notation);\n\n\t\t} catch (Exception e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n}\n", "", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.sql.v2014_04_01.implementation;\n\nimport com.microsoft.azure.arm.collection.InnerSupportsGet;\nimport com.microsoft.azure.arm.collection.InnerSupportsDelete;\nimport com.microsoft.azure.arm.collection.InnerSupportsListing;\nimport retrofit2.Retrofit;\nimport com.google.common.reflect.TypeToken;\nimport com.microsoft.azure.CloudException;\nimport com.microsoft.azure.management.sql.v2014_04_01.CheckNameAvailabilityRequest;\nimport com.microsoft.azure.management.sql.v2014_04_01.ServerUpdate;\nimport com.microsoft.azure.Page;\nimport com.microsoft.azure.PagedList;\nimport com.microsoft.rest.ServiceCallback;\nimport com.microsoft.rest.ServiceFuture;\nimport com.microsoft.rest.ServiceResponse;\nimport com.microsoft.rest.Validator;\nimport java.io.IOException;\nimport java.util.List;\nimport okhttp3.ResponseBody;\nimport retrofit2.http.Body;\nimport retrofit2.http.GET;\nimport retrofit2.http.Header;\nimport retrofit2.http.Headers;\nimport retrofit2.http.HTTP;\nimport retrofit2.http.PATCH;\nimport retrofit2.http.Path;\nimport retrofit2.http.POST;\nimport retrofit2.http.PUT;\nimport retrofit2.http.Query;\nimport retrofit2.Response;\nimport rx.functions.Func1;\nimport rx.Observable;\n\n/**\n * An instance of this class provides access to all the operations defined\n * in Servers.\n */\npublic class ServersInner implements InnerSupportsGet<ServerInner>, InnerSupportsDelete<Void>, InnerSupportsListing<ServerInner> {\n    /** The Retrofit service to perform REST calls. */\n    private ServersService service;\n    /** The service client containing this operation class. */\n    private SqlManagementClientImpl client;\n\n    /**\n     * Initializes an instance of ServersInner.\n     *\n     * @param retrofit the Retrofit instance built from a Retrofit Builder.\n     * @param client the instance of the service client containing this operation class.\n     */\n    public ServersInner(Retrofit retrofit, SqlManagementClientImpl client) {\n        this.service = retrofit.create(ServersService.class);\n        this.client = client;\n    }\n\n    /**\n     * The interface defining all the services for Servers to be\n     * used by Retrofit to perform actually REST calls.\n     */\n    interface ServersService {\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers checkNameAvailability\" })\n        @POST(\"subscriptions/{subscriptionId}/providers/Microsoft.Sql/checkNameAvailability\")\n        Observable<Response<ResponseBody>> checkNameAvailability(@Path(\"subscriptionId\") String subscriptionId, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Body CheckNameAvailabilityRequest parameters, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers list\" })\n        @GET(\"subscriptions/{subscriptionId}/providers/Microsoft.Sql/servers\")\n        Observable<Response<ResponseBody>> list(@Path(\"subscriptionId\") String subscriptionId, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers createOrUpdate\" })\n        @PUT(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\")\n        Observable<Response<ResponseBody>> createOrUpdate(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Body ServerInner parameters, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers update\" })\n        @PATCH(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\")\n        Observable<Response<ResponseBody>> update(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Body ServerUpdate parameters, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers delete\" })\n        @HTTP(path = \"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\", method = \"DELETE\", hasBody = true)\n        Observable<Response<ResponseBody>> delete(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers getByResourceGroup\" })\n        @GET(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers/{serverName}\")\n        Observable<Response<ResponseBody>> getByResourceGroup(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Path(\"serverName\") String serverName, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n        @Headers({ \"Content-Type: application/json; charset=utf-8\", \"x-ms-logging-context: com.microsoft.azure.management.sql.v2014_04_01.Servers listByResourceGroup\" })\n        @GET(\"subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.Sql/servers\")\n        Observable<Response<ResponseBody>> listByResourceGroup(@Path(\"subscriptionId\") String subscriptionId, @Path(\"resourceGroupName\") String resourceGroupName, @Query(\"api-version\") String apiVersion, @Header(\"accept-language\") String acceptLanguage, @Header(\"User-Agent\") String userAgent);\n\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the CheckNameAvailabilityResponseInner object if successful.\n     */\n    public CheckNameAvailabilityResponseInner checkNameAvailability(String name) {\n        return checkNameAvailabilityWithServiceResponseAsync(name).toBlocking().single().body();\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<CheckNameAvailabilityResponseInner> checkNameAvailabilityAsync(String name, final ServiceCallback<CheckNameAvailabilityResponseInner> serviceCallback) {\n        return ServiceFuture.fromResponse(checkNameAvailabilityWithServiceResponseAsync(name), serviceCallback);\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the CheckNameAvailabilityResponseInner object\n     */\n    public Observable<CheckNameAvailabilityResponseInner> checkNameAvailabilityAsync(String name) {\n        return checkNameAvailabilityWithServiceResponseAsync(name).map(new Func1<ServiceResponse<CheckNameAvailabilityResponseInner>, CheckNameAvailabilityResponseInner>() {\n            @Override\n            public CheckNameAvailabilityResponseInner call(ServiceResponse<CheckNameAvailabilityResponseInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Determines whether a resource can be created with the specified name.\n     *\n     * @param name The name whose availability is to be checked.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the CheckNameAvailabilityResponseInner object\n     */\n    public Observable<ServiceResponse<CheckNameAvailabilityResponseInner>> checkNameAvailabilityWithServiceResponseAsync(String name) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        if (name == null) {\n            throw new IllegalArgumentException(\"Parameter name is required and cannot be null.\");\n        }\n        CheckNameAvailabilityRequest parameters = new CheckNameAvailabilityRequest();\n        parameters.withName(name);\n        return service.checkNameAvailability(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), parameters, this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<CheckNameAvailabilityResponseInner>>>() {\n                @Override\n                public Observable<ServiceResponse<CheckNameAvailabilityResponseInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<CheckNameAvailabilityResponseInner> clientResponse = checkNameAvailabilityDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<CheckNameAvailabilityResponseInner> checkNameAvailabilityDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<CheckNameAvailabilityResponseInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<CheckNameAvailabilityResponseInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @return the PagedList<ServerInner> object if successful.\n     */\n    public PagedList<ServerInner> list() {\n        PageImpl<ServerInner> page = new PageImpl<>();\n        page.setItems(listWithServiceResponseAsync().toBlocking().single().body());\n        page.setNextPageLink(null);\n        return new PagedList<ServerInner>(page) {\n            @Override\n            public Page<ServerInner> nextPage(String nextPageLink) {\n                return null;\n            }\n        };\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<List<ServerInner>> listAsync(final ServiceCallback<List<ServerInner>> serviceCallback) {\n        return ServiceFuture.fromResponse(listWithServiceResponseAsync(), serviceCallback);\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<Page<ServerInner>> listAsync() {\n        return listWithServiceResponseAsync().map(new Func1<ServiceResponse<List<ServerInner>>, Page<ServerInner>>() {\n            @Override\n            public Page<ServerInner> call(ServiceResponse<List<ServerInner>> response) {\n                PageImpl<ServerInner> page = new PageImpl<>();\n                page.setItems(response.body());\n                return page;\n            }\n        });\n    }\n\n    /**\n     * Returns a list of servers.\n     *\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<ServiceResponse<List<ServerInner>>> listWithServiceResponseAsync() {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.list(this.client.subscriptionId(), this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServerInner>>>>() {\n                @Override\n                public Observable<ServiceResponse<List<ServerInner>>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<PageImpl<ServerInner>> result = listDelegate(response);\n                        List<ServerInner> items = null;\n                        if (result.body() != null) {\n                            items = result.body().items();\n                        }\n                        ServiceResponse<List<ServerInner>> clientResponse = new ServiceResponse<List<ServerInner>>(items, result.response());\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<PageImpl<ServerInner>> listDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<PageImpl<ServerInner>, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<PageImpl<ServerInner>>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the ServerInner object if successful.\n     */\n    public ServerInner createOrUpdate(String resourceGroupName, String serverName, ServerInner parameters) {\n        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters).toBlocking().single().body();\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<ServerInner> createOrUpdateAsync(String resourceGroupName, String serverName, ServerInner parameters, final ServiceCallback<ServerInner> serviceCallback) {\n        return ServiceFuture.fromResponse(createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters), serviceCallback);\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServerInner> createOrUpdateAsync(String resourceGroupName, String serverName, ServerInner parameters) {\n        return createOrUpdateWithServiceResponseAsync(resourceGroupName, serverName, parameters).map(new Func1<ServiceResponse<ServerInner>, ServerInner>() {\n            @Override\n            public ServerInner call(ServiceResponse<ServerInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Creates or updates a new server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for creating or updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServiceResponse<ServerInner>> createOrUpdateWithServiceResponseAsync(String resourceGroupName, String serverName, ServerInner parameters) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        if (parameters == null) {\n            throw new IllegalArgumentException(\"Parameter parameters is required and cannot be null.\");\n        }\n        Validator.validate(parameters);\n        return service.createOrUpdate(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServerInner>>>() {\n                @Override\n                public Observable<ServiceResponse<ServerInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<ServerInner> clientResponse = createOrUpdateDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<ServerInner> createOrUpdateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<ServerInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<ServerInner>() { }.getType())\n                .register(201, new TypeToken<ServerInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the ServerInner object if successful.\n     */\n    public ServerInner update(String resourceGroupName, String serverName, ServerUpdate parameters) {\n        return updateWithServiceResponseAsync(resourceGroupName, serverName, parameters).toBlocking().single().body();\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<ServerInner> updateAsync(String resourceGroupName, String serverName, ServerUpdate parameters, final ServiceCallback<ServerInner> serviceCallback) {\n        return ServiceFuture.fromResponse(updateWithServiceResponseAsync(resourceGroupName, serverName, parameters), serviceCallback);\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServerInner> updateAsync(String resourceGroupName, String serverName, ServerUpdate parameters) {\n        return updateWithServiceResponseAsync(resourceGroupName, serverName, parameters).map(new Func1<ServiceResponse<ServerInner>, ServerInner>() {\n            @Override\n            public ServerInner call(ServiceResponse<ServerInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Updates an existing server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param parameters The required parameters for updating a server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServiceResponse<ServerInner>> updateWithServiceResponseAsync(String resourceGroupName, String serverName, ServerUpdate parameters) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        if (parameters == null) {\n            throw new IllegalArgumentException(\"Parameter parameters is required and cannot be null.\");\n        }\n        Validator.validate(parameters);\n        return service.update(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), parameters, this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServerInner>>>() {\n                @Override\n                public Observable<ServiceResponse<ServerInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<ServerInner> clientResponse = updateDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<ServerInner> updateDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<ServerInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<ServerInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     */\n    public void delete(String resourceGroupName, String serverName) {\n        deleteWithServiceResponseAsync(resourceGroupName, serverName).toBlocking().single().body();\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<Void> deleteAsync(String resourceGroupName, String serverName, final ServiceCallback<Void> serviceCallback) {\n        return ServiceFuture.fromResponse(deleteWithServiceResponseAsync(resourceGroupName, serverName), serviceCallback);\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceResponse} object if successful.\n     */\n    public Observable<Void> deleteAsync(String resourceGroupName, String serverName) {\n        return deleteWithServiceResponseAsync(resourceGroupName, serverName).map(new Func1<ServiceResponse<Void>, Void>() {\n            @Override\n            public Void call(ServiceResponse<Void> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Deletes a SQL server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceResponse} object if successful.\n     */\n    public Observable<ServiceResponse<Void>> deleteWithServiceResponseAsync(String resourceGroupName, String serverName) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.delete(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<Void>>>() {\n                @Override\n                public Observable<ServiceResponse<Void>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<Void> clientResponse = deleteDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<Void> deleteDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<Void, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<Void>() { }.getType())\n                .register(204, new TypeToken<Void>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @throws CloudException thrown if the request is rejected by server\n     * @throws RuntimeException all other wrapped checked exceptions if the request fails to be sent\n     * @return the ServerInner object if successful.\n     */\n    public ServerInner getByResourceGroup(String resourceGroupName, String serverName) {\n        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, serverName).toBlocking().single().body();\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<ServerInner> getByResourceGroupAsync(String resourceGroupName, String serverName, final ServiceCallback<ServerInner> serviceCallback) {\n        return ServiceFuture.fromResponse(getByResourceGroupWithServiceResponseAsync(resourceGroupName, serverName), serviceCallback);\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServerInner> getByResourceGroupAsync(String resourceGroupName, String serverName) {\n        return getByResourceGroupWithServiceResponseAsync(resourceGroupName, serverName).map(new Func1<ServiceResponse<ServerInner>, ServerInner>() {\n            @Override\n            public ServerInner call(ServiceResponse<ServerInner> response) {\n                return response.body();\n            }\n        });\n    }\n\n    /**\n     * Gets a server.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serverName The name of the server.\n     * @throws IllegalArgumentException thrown if parameters fail the validation\n     * @return the observable to the ServerInner object\n     */\n    public Observable<ServiceResponse<ServerInner>> getByResourceGroupWithServiceResponseAsync(String resourceGroupName, String serverName) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (serverName == null) {\n            throw new IllegalArgumentException(\"Parameter serverName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.getByResourceGroup(this.client.subscriptionId(), resourceGroupName, serverName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<ServerInner>>>() {\n                @Override\n                public Observable<ServiceResponse<ServerInner>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<ServerInner> clientResponse = getByResourceGroupDelegate(response);\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<ServerInner> getByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<ServerInner, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<ServerInner>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @return the PagedList<ServerInner> object if successful.\n     */\n    public PagedList<ServerInner> listByResourceGroup(String resourceGroupName) {\n        PageImpl<ServerInner> page = new PageImpl<>();\n        page.setItems(listByResourceGroupWithServiceResponseAsync(resourceGroupName).toBlocking().single().body());\n        page.setNextPageLink(null);\n        return new PagedList<ServerInner>(page) {\n            @Override\n            public Page<ServerInner> nextPage(String nextPageLink) {\n                return null;\n            }\n        };\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @param serviceCallback the async ServiceCallback to handle successful and failed responses.\n     * @return the {@link ServiceFuture} object\n     */\n    public ServiceFuture<List<ServerInner>> listByResourceGroupAsync(String resourceGroupName, final ServiceCallback<List<ServerInner>> serviceCallback) {\n        return ServiceFuture.fromResponse(listByResourceGroupWithServiceResponseAsync(resourceGroupName), serviceCallback);\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<Page<ServerInner>> listByResourceGroupAsync(String resourceGroupName) {\n        return listByResourceGroupWithServiceResponseAsync(resourceGroupName).map(new Func1<ServiceResponse<List<ServerInner>>, Page<ServerInner>>() {\n            @Override\n            public Page<ServerInner> call(ServiceResponse<List<ServerInner>> response) {\n                PageImpl<ServerInner> page = new PageImpl<>();\n                page.setItems(response.body());\n                return page;\n            }\n        });\n    }\n\n    /**\n     * Returns a list of servers in a resource group.\n     *\n     * @param resourceGroupName The name of the resource group that contains the resource. You can obtain this value from the Azure Resource Manager API or the portal.\n     * @return the observable to the List&lt;ServerInner&gt; object\n     */\n    public Observable<ServiceResponse<List<ServerInner>>> listByResourceGroupWithServiceResponseAsync(String resourceGroupName) {\n        if (this.client.subscriptionId() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.subscriptionId() is required and cannot be null.\");\n        }\n        if (resourceGroupName == null) {\n            throw new IllegalArgumentException(\"Parameter resourceGroupName is required and cannot be null.\");\n        }\n        if (this.client.apiVersion() == null) {\n            throw new IllegalArgumentException(\"Parameter this.client.apiVersion() is required and cannot be null.\");\n        }\n        return service.listByResourceGroup(this.client.subscriptionId(), resourceGroupName, this.client.apiVersion(), this.client.acceptLanguage(), this.client.userAgent())\n            .flatMap(new Func1<Response<ResponseBody>, Observable<ServiceResponse<List<ServerInner>>>>() {\n                @Override\n                public Observable<ServiceResponse<List<ServerInner>>> call(Response<ResponseBody> response) {\n                    try {\n                        ServiceResponse<PageImpl<ServerInner>> result = listByResourceGroupDelegate(response);\n                        List<ServerInner> items = null;\n                        if (result.body() != null) {\n                            items = result.body().items();\n                        }\n                        ServiceResponse<List<ServerInner>> clientResponse = new ServiceResponse<List<ServerInner>>(items, result.response());\n                        return Observable.just(clientResponse);\n                    } catch (Throwable t) {\n                        return Observable.error(t);\n                    }\n                }\n            });\n    }\n\n    private ServiceResponse<PageImpl<ServerInner>> listByResourceGroupDelegate(Response<ResponseBody> response) throws CloudException, IOException, IllegalArgumentException {\n        return this.client.restClient().responseBuilderFactory().<PageImpl<ServerInner>, CloudException>newInstance(this.client.serializerAdapter())\n                .register(200, new TypeToken<PageImpl<ServerInner>>() { }.getType())\n                .registerError(CloudException.class)\n                .build(response);\n    }\n\n}\n", "pe;\nimport javax.persistence.Enumerated;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.Id;\nimport javax.persistence.ManyToOne;\nimport javax.persistence.Table;\n\nimport se.ifkgoteborg.stat.model.enums.MinorHorizontalAlignment;\nimport se.ifkgoteborg.stat.model.enums.MinorVerticalAlignment;\nimport se.ifkgoteborg.stat.model.enums.Side;\n\n@Entity\n@Table(name=\"position\")\npublic class Position {\n\t\n\t@Id\n\t@GeneratedValue\n\tprivate Long id;\n\n\tprivate String name;\n\t\n\tprivate String code;\n\t\n\t@Enumerated(value=EnumType.STRING)\n\tprivate Side side;\n\n\t@ManyToOne\n\tprivate PositionType positionType;\n\n\t@Enumerated(value=EnumType.STRING)\n\tprivate MinorVerticalAlignment minorVerticalAlignment = MinorVerticalAlignment.NEUTRAL;\n\n\t@Enumerated(value=EnumType.STRING)\n\tprivate MinorHorizontalAlignment minorHorizontalAlignment = MinorHorizontalAlignment.NEUTRAL;\n\t\n\tpublic Position() {}\n\t\n\tpublic Position(String name, String code, Side side, PositionType positionType) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t}\n\t\n\tpublic Position(String name, String code, Side side, PositionType positionType, MinorVerticalAlignment minorVerticalAlignment) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t\tthis.minorVerticalAlignment = minorVerticalAlignment;\n\t}\n\n\tpublic Position(String name, String code, Side side, PositionType positionType, MinorHorizontalAlignment minorHorizontalAlignment) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t\tthis.minorHorizontalAlignment = minorHorizontalAlignment;\n\t}\n\n\tpublic Position(String name, String code, Side side, PositionType positionType, MinorVerticalAlignment minorVerticalAlignment, MinorHorizontalAlignment minorHorizontalAlignment) {\n\t\tthis.name = name;\n\t\tthis.code = code;\n\t\tthis.side = side;\n\t\tthis.positionType = positionType;\n\t\tthis.minorVerticalAlignment = minorVerticalAlignment;\n\t\tthis.minorHorizontalAlignment = minorHorizontalAlignment;\n\t}\n\n\tpublic Long getId() {\n\t\treturn id;\n\t}\n\tpublic void setId(Long id) {\n\t\tthis.id = id;\n\t}\n\tpublic String getName() {\n\t\treturn name;\n\t}\n\n\tpublic void setName(String name) {\n\t\tthis.name = name;\n\t}\n\tpublic String getCode() {\n\t\treturn code;\n\t}\n\tpublic void setCode(String code) {\n\t\tthis.code = code;\n\t}\n\tpublic Side getSide() {\n\t\treturn side;\n\t}\n\tpublic void setSide(Side side) {\n\t\tthis.side = side;\n\t}\n\n\tpublic PositionType getPositionType() {\n\t\treturn positionType;\n\t}\n\n\tpublic void setPositionType(PositionType positionType) {\n\t\tthis.positionType = positionType;\n\t}\n\t\n\t\n\n\tpublic MinorVerticalAlignment getMinorVerticalAlignment() {\n\t\treturn minorVerticalAlignment;\n\t}\n\n\tpublic void setMinorVerticalAlignment(\n\t\t\tMinorVerticalAlignment minorVerticalAlignment) {\n\t\tthis.minorVerticalAlignment = minorVerticalAlignment;\n\t}\n\n\tpublic MinorHorizontalAlignment getMinorHorizontalAlignment() {\n\t\treturn minorHorizontalAlignment;\n\t}\n\n\tpublic void setMinorHorizontalAlignment(\n\t\t\tMinorHorizontalAlignment minorHorizontalAlignment) {\n\t\tthis.minorHorizontalAlignment = minorHorizontalAlignment;\n\t}\n\n\t@Override\n\tpublic int hashCode() {\n\t\tfinal int prime = 31;\n\t\tint result = 1;\n\t\tresult = prime * result + ((id == null) ? 0 : id.hashCode());\n\t\treturn result;\n\t}\n\n\t@Override\n\tpublic boolean equals(Object obj) {\n\t\tif (this == obj)\n\t\t\treturn true;\n\t\tif (obj == null)\n\t\t\treturn false;\n\t\tif (getClass() != obj.getClass())\n\t\t\treturn false;\n\t\tPosition other = (Position) obj;\n\t\tif (id == null) {\n\t\t\tif (other.id != null)\n\t\t\t\treturn false;\n\t\t} else if (!id.equals(other.id))\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t@Override\n\tpublic String toString() {\n\t\treturn this.name;\n\t}\n\t\n\t\n\t\n}\n", "See License.txt in the project root for\n * license information.\n *\n * Code generated by Microsoft (R) AutoRest Code Generator.\n */\n\npackage com.microsoft.azure.management.apimanagement.v2019_12_01.implementation;\n\nimport com.fasterxml.jackson.annotation.JsonProperty;\n\n/**\n * Network Status in the Location.\n */\npublic class NetworkStatusContractByLocationInner {\n    /**\n     * Location of service.\n     */\n    @JsonProperty(value = \"location\")\n    private String location;\n\n    /**\n     * Network status in Location.\n     */\n    @JsonProperty(value = \"networkStatus\")\n    private NetworkStatusContractInner networkStatus;\n\n    /**\n     * Get location of service.\n     *\n     * @return the location value\n     */\n    public String location() {\n        return this.location;\n    }\n\n    /**\n     * Set location of service.\n     *\n     * @param location the location value to set\n     * @return the NetworkStatusContractByLocationInner object itself.\n     */\n    public NetworkStatusContractByLocationInner withLocation(String location) {\n        this.location = location;\n        return this;\n    }\n\n    /**\n     * Get network status in Location.\n     *\n     * @return the networkStatus value\n     */\n    public NetworkStatusContractInner networkStatus() {\n        return this.networkStatus;\n    }\n\n    /**\n     * Set network status in Location.\n     *\n     * @param networkStatus the networkStatus value to set\n     * @return the NetworkStatusContractByLocationInner object itself.\n     */\n    public NetworkStatusContractByLocationInner withNetworkStatus(NetworkStatusContractInner networkStatus) {\n        this.networkStatus = networkStatus;\n        return this;\n    }\n\n}\n", "NonNull;\nimport androidx.annotation.Nullable;\n\nimport com.bukhmastov.cdoitmo.model.JsonEntity;\nimport com.bukhmastov.cdoitmo.network.handlers.RestResponseHandler;\nimport com.bukhmastov.cdoitmo.network.model.Client;\nimport com.bukhmastov.cdoitmo.network.model.DeIfmo;\n\nimport java.util.Map;\n\npublic abstract class DeIfmoRestClient extends DeIfmo {\n\n    public DeIfmoRestClient() {\n        super();\n    }\n\n    public abstract <T extends JsonEntity> void get(@NonNull Context context, @NonNull String url,\n                            @Nullable Map<String, String> query, @NonNull RestResponseHandler<T> handler);\n\n    public abstract <T extends JsonEntity> void get(@NonNull Context context,\n                            @NonNull @Client.Protocol String protocol, @NonNull String url,\n                            @Nullable Map<String, String> query, @NonNull RestResponseHandler<T> handler);\n}\n", "ing[] args) \r\n\t{\r\n\t\tController controller = new Controller();\r\n\t\t\r\n\t\t//if command line arg has -a\r\n\t\tcontroller.ArchiveData();\r\n\t\t\r\n\t\t//if command line arg has -b\r\n\t\tcontroller.BuildDatabase();\r\n\t\t\r\n\t\t//if command line arg has -p\r\n\t\tcontroller.ProcessNeuralNetworks();\r\n\t}\r\n}\r\n", "ork.data.domain.Page;\nimport org.springframework.data.domain.Pageable;\nimport org.springframework.data.jpa.repository.EntityGraph;\nimport org.springframework.data.jpa.repository.JpaRepository;\nimport org.springframework.stereotype.Repository;\nimport java.util.List;\nimport java.util.Optional;\nimport java.time.Instant;\n\n/**\n * Spring Data JPA repository for the User entity.\n */\n@Repository\npublic interface UserRepository extends JpaRepository<User, Long> {\n\n    Optional<User> findOneByActivationKey(String activationKey);\n\n    List<User> findAllByActivatedIsFalseAndCreatedDateBefore(Instant dateTime);\n\n    Optional<User> findOneByResetKey(String resetKey);\n\n    Optional<User> findOneByEmail(String email);\n\n    Optional<User> findOneByLogin(String login);\n\n    @EntityGraph(attributePaths = \"authorities\")\n    User findOneWithAuthoritiesById(Long id);\n\n    @EntityGraph(attributePaths = \"authorities\")\n    Optional<User> findOneWithAuthoritiesByLogin(String login);\n\n    Page<User> findAllByLoginNot(Pageable pageable, String login);\n}\n", "public class ComputerPrice {\n\n\n    public void displayStoreComputerPrice() {\n\n        //int computerPrice [] = new int[5];\n\n        int[] computerPrices = {50, 100, 900, 1500, 600};\n\n        for (int StorePrice : computerPrices) {\n            System.out.println(StorePrice);\n\n        }\n\n\n    }public void displayOnlineComputerPrice() {\n            double [] price = {100.00, 200.00, 375.00, 1600.75, 655.99};\n            System.out.println(price[3]);\n            double[] price1 = price.clone();\n            double[] price2 = Arrays.copyOf(price, 3);\n\n    }\n\n\n}\n", "R REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\nimport java.nio.channels.spi.AsynchronousChannelProvider;\n\npublic class CheckProvider {\n    public static void main(String[] args) {\n        Class<?> c = AsynchronousChannelProvider.provider().getClass();\n\n        String expected = args[0];\n        String actual = c.getName();\n\n        if (!actual.equals(expected))\n            throw new RuntimeException(\"Provider is of type '\" + actual +\n                \"', expected '\" + expected + \"'\");\n\n    }\n}\n", "ft.util.math.Vec3d;\nimport net.minecraft.world.DimensionType;\nimport net.minecraft.world.WorldProvider;\nimport net.minecraft.world.biome.BiomeProviderSingle;\nimport net.minecraft.world.gen.IChunkGenerator;\nimport net.minecraftforge.fml.relauncher.Side;\nimport net.minecraftforge.fml.relauncher.SideOnly;\nimport sblectric.lightningcraft.init.LCBiomes;\nimport sblectric.lightningcraft.init.LCDimensions;\n\n/** The Underworld world provider */\npublic class LCWorldProviderUnderworld extends WorldProvider {\n\t\n\tpublic static final Vec3d skyFogColor = new Vec3d(0.085D, 0.085D, 0.085D);\n\t\n\t@Override\n\tpublic void init() {\n\t\tthis.biomeProvider = new BiomeProviderSingle(LCBiomes.underworld);\n\t\tthis.setDimension(LCDimensions.underworldID);\n\t\tthis.hasSkyLight = false;\n\t\t//this.isHellWorld = false; // place some water bruh\n\t}\n\t\n\t@Override\n\tpublic IChunkGenerator createChunkGenerator() {\n\t\treturn new ChunkProviderUnderworld(this.world, this.world.getSeed());\n\t}\n\t\n\t@Override\n\tpublic int getActualHeight() {\n        return ChunkProviderUnderworld.chunkHeight;\n    }\n\t\n\t/** Preload 3x3 chunks on player arrival */\n//\t@Override\n//    public void onPlayerAdded(EntityPlayerMP p) {\n//\t\tint cx = ((int)p.posX) >> 4;\n//\t\tint cz = ((int)p.posZ) >> 4;\n//\t\tfor(int x = cx - 1; x <= cx + 1; x++) {\n//\t\t\tfor(int z = cz - 1; z <= cz + 1; z++) {\n//\t\t\t\tthis.worldObj.getChunkProvider().provideChunk(x, z);\n//\t\t\t}\n//\t\t}\n//    }\n\t\n\t/**\n\t * Sky color: dark\n\t */\n\t@Override\n\t@SideOnly(Side.CLIENT)\n    public Vec3d getSkyColor(Entity cameraEntity, float partialTicks) {\n\t\treturn skyFogColor;\n    }\n\t\n\t/**\n     * Biome fog color: dark\n     */\n    @Override\n\t@SideOnly(Side.CLIENT)\n    public Vec3d getFogColor(float par1, float par2) {\n    \treturn skyFogColor;\n    }\n\n    /**\n     * Creates the light to brightness table\n     */\n    @Override\n    protected void generateLightBrightnessTable() {\n        float f = 0.1F;\n\n        for (int i = 0; i <= 15; ++i)\n        {\n            float f1 = 1.0F - i / 15.0F;\n            this.lightBrightnessTable[i] = (1.0F - f1) / (f1 * 3.0F + 1.0F) * (1.0F - f) + f;\n        }\n    }\n\t\n    /**\n     * Returns 'true' if in the \"main surface world\", but 'false' if in the Nether or End dimensions.\n     */\n    @Override\n    public boolean isSurfaceWorld() {\n        return false;\n    }\n    \n    /**\n     * Calculates the angle of sun and moon in the sky relative to a specified time (usually worldTime)\n     */\n    @Override\n    public float calculateCelestialAngle(long par1, float par3) {\n        return 0.5F;\n    }\n\n    /**\n     * True if the player can respawn in this dimension (true = overworld, false = nether).\n     */\n    @Override\n    public boolean canRespawnHere() {\n        return false;\n    }\n\n    /**\n     * Returns true if the given X,Z coordinate should show environmental fog.\n     */\n    @SideOnly(Side.CLIENT)\n    @Override\n    public boolean doesXZShowFog(int par1, int par2) {\n        return true;\n    }\n\n\t@Override\n\tpublic DimensionType getDimensionType() {\n\t\treturn LCDimensions.UNDERWORLD_TYPE;\n\t}\t\n\t\n}\n", "ult[] = rowSums(arr2d);\n\t\tprintRow(result);\n\t\tfor (int i = 0; i < result.length; i++) {\n\t\t\tfor (int j = i+1; j < result.length; j++) {\n\t\t\t\tif (result[i] == result[j])\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\treturn true;\n\t}\n\n\tpublic static int arraySum(int[] arr1) {\n\t\tint rv = 0;\n\t\tfor (int i = 0; i < arr1.length; i++) {\n\t\t\trv += arr1[i];\n\t\t}\n\t\treturn rv;\n\t}\n\n\tpublic static int[] rowSums(int arr2D[][]) {\n\t\tint [] rv = new int[arr2D.length];\n\t\tfor (int i = 0; i < arr2D.length; i++) {\n\t\t\trv[i] = arraySum(arr2D[i]);\n\t\t}\n\t\treturn rv;\n\t}\n\n\tpublic static void solveExamProblem() {\n\t\tint arr1[] = {1, 3, 2, 7, 3};\n\t\tSystem.out.println(arraySum(arr1));\n\t\tint arr2D[][] = {\n\t\t\t\t{1, 3, 2, 7, 3},\n\t\t\t\t{10, 10, 4, 6, 2},\n\t\t\t\t{5, 3, 5, 9, 6},\n\t\t\t\t{7, 6, 4, 2, 1}\n\t\t};\n\t\tint result[] = rowSums(arr2D);\n\t\tprintRow(result);\n\t\tif (isDiverse(arr2D)) {\n\t\t\tSystem.out.println(\"Array is diverse\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Array is NOT diverse\");\n\t\t}\n\n\t\tint mat2[][] = {\n\t\t\t\t{1, 1, 5, 3, 4},\n\t\t\t\t{12, 7, 6, 1, 9},\n\t\t\t\t{8, 11, 10, 2, 5},\n\t\t\t\t{3, 2, 3, 0, 6}\n\t\t};\n\t\tif (isDiverse(mat2)) {\n\t\t\tSystem.out.println(\"Array is diverse\");\n\t\t} else {\n\t\t\tSystem.out.println(\"Array is NOT diverse\");\n\t\t}\n\n\t}\n\n\tpublic static void printRow(int b[]) {\n\t\tSystem.out.print(\"|\");\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tSystem.out.print(String.format(\"%4d |\", b[i]));\n\t\t}\n\t\tSystem.out.println(\"\");\n\t}\n\tpublic static void printArray(int b[][]) {\n\t\tfor (int i = 0; i < b.length; i++) {\n\t\t\tprintRow(b[i]);\n\t\t}\n\t}\n    public static void main(String[] args) {\n\t\tif (false) {\n\t\t\tint a[] = new int[10];\n\t\t\tSystem.out.println(a.length);\n\n\t\t\tint b[][] = new int[10][10];\n\t\t\tSystem.out.println(\"Dimensions are \" + b.length + \"x\" + b[0].length);\n\t\t\tfor (int row = 0; row < b.length; row++) {\n\t\t\t\tfor (int col = 0; col < b[row].length; col++) {\n\t\t\t\t\tb[row][col] = (row + 1) * (col + 1);\n\t\t\t\t}\n\t\t\t}\n\t\t\tprintArray(b);\n\t\t}\n\t\tif (false)\n\t\t    solveExamProblem();\n\n\t\tPerson p = new Person(\"Shivani\", \"Shimpi\");\n\t\tSystem.out.println(p);\n\t\tPerson[][] people = new Person[2][4];\n\t\tpeople[0][0] = new Person(\"Shashank\", \"Shimpi\");\n\t\tpeople[0][1] = new Person(\"Deepali\", \"Shimpi\");\n\t\tpeople[0][2] = p;\n\t\tpeople[0][3] = new Person(\"Shivam\", \"Shimpi\");\n\n\t\tpeople[1][0] = new Person(\"Prasad\", \"Gharpure\");\n\t\tpeople[1][1] = new Person(\"Geeta\", \"Agashe\");\n\t\tpeople[1][2] = new Person(\"Akshay\", \"Gharpure\");\n\t\tpeople[1][3] = new Person(\"Shreeya\", people[1][0].getLastname());\n\n\t\tfor (int family=0; family < people.length; family ++) {\n            System.out.println(\"The \" + people[family][0].getLastname() + \" Family\");\n            System.out.println(\"--------------------------------------\");\n\t\t    for (int i = 0; i < people[family].length; i++) {\n                System.out.println(\"\\t\" + people[family][i].toString());\n            }\n            System.out.println(\"--------------------------------------\\n\");\n        }\n\n    }\n}\n", ";\n\nimport javax.persistence.Embeddable;\n\n/**\n * Note that we have {@code @Embeddable} annotation here and NO id element.\n * This means that new table will not be created in DB\n *\n * Take note that we must implement hashCode/equals for for Ingredient and Pizza in order to allow hibernate\n * to determine what exactly ingredients should be deleted.\n */\n@Embeddable\npublic class Ingredient {\n    private String name;\n\n    @Parent\n    private Pizza pizza;\n\n    public Ingredient() {}\n    public Ingredient(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n    public Pizza getPizza() {\n        return pizza;\n    }\n\n    public void setPizza(Pizza pizza) {\n        this.pizza = pizza;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof Ingredient)) return false;\n\n        Ingredient that = (Ingredient) o;\n\n        if (name != null ? !name.equals(that.name) : that.name != null) return false;\n\n        return true;\n    }\n\n    @Override\n    public int hashCode() {\n        int result = name != null ? name.hashCode() : 0;\n        result = 31 * result;\n        return result;\n    }\n\n}\n", "\n/*\n * EDACCResultCodeDlg.java\n *\n * Created on 03.12.2012, 17:17:48\n */\n\npackage edacc;\n\nimport edacc.manageDB.ManageDBResultCodes;\nimport java.sql.SQLException;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport javax.swing.JOptionPane;\n\n/**\n *\n * @author dgall\n */\npublic class EDACCResultCodeDlg extends javax.swing.JDialog {\n\n    /** Creates new form EDACCResultCodeDlg */\n    public EDACCResultCodeDlg(java.awt.Frame parent, boolean modal) {\n        super(parent, modal);\n        initComponents();\n        setLocationRelativeTo(parent);\n    }\n\n    /** This method is called from within the constructor to\n     * initialize the form.\n     * WARNING: Do NOT modify this code. The content of this method is\n     * always regenerated by the Form Editor.\n     */\n    @SuppressWarnings(\"unchecked\")\n    // <editor-fold defaultstate=\"collapsed\" desc=\"Generated Code\">//GEN-BEGIN:initComponents\n    private void initComponents() {\n\n        lResultCode = new javax.swing.JLabel();\n        lDescription = new javax.swing.JLabel();\n        tfDescription = new javax.swing.JTextField();\n        bSave = new javax.swing.JButton();\n        bCancel = new javax.swing.JButton();\n        tfResultCode = new javax.swing.JTextField();\n\n        setDefaultCloseOperation(javax.swing.WindowConstants.DISPOSE_ON_CLOSE);\n        org.jdesktop.application.ResourceMap resourceMap = org.jdesktop.application.Application.getInstance(edacc.EDACCApp.class).getContext().getResourceMap(EDACCResultCodeDlg.class);\n        setTitle(resourceMap.getString(\"ResultCodeDlg.title\")); // NOI18N\n        setName(\"ResultCodeDlg\"); // NOI18N\n\n        lResultCode.setText(resourceMap.getString(\"lResultCode.text\")); // NOI18N\n        lResultCode.setName(\"lResultCode\"); // NOI18N\n\n        lDescription.setText(resourceMap.getString(\"lDescription.text\")); // NOI18N\n        lDescription.setName(\"lDescription\"); // NOI18N\n\n        tfDescription.setText(resourceMap.getString(\"tfDescription.text\")); // NOI18N\n        tfDescription.setName(\"tfDescription\"); // NOI18N\n        tfDescription.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                tfDescriptionActionPerformed(evt);\n            }\n        });\n\n        bSave.setLabel(resourceMap.getString(\"bSave.label\")); // NOI18N\n        bSave.setName(\"bSave\"); // NOI18N\n        bSave.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                bSaveActionPerformed(evt);\n            }\n        });\n\n        bCancel.setLabel(resourceMap.getString(\"bCancel.label\")); // NOI18N\n        bCancel.setName(\"bCancel\"); // NOI18N\n        bCancel.addActionListener(new java.awt.event.ActionListener() {\n            public void actionPerformed(java.awt.event.ActionEvent evt) {\n                bCancelActionPerformed(evt);\n            }\n        });\n\n        tfResultCode.setText(resourceMap.getString(\"tfResultCode.text\")); // NOI18N\n        tfResultCode.setName(\"tfResultCode\"); // NOI18N\n\n        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());\n        getContentPane().setLayout(layout);\n        layout.setHorizontalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(lResultCode)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(tfResultCode, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE))\n                    .addGroup(layout.createSequentialGroup()\n                        .addComponent(lDescription)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(tfDescription, javax.swing.GroupLayout.DEFAULT_SIZE, 283, Short.MAX_VALUE))\n                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()\n                        .addComponent(bSave)\n                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                        .addComponent(bCancel)))\n                .addContainerGap())\n        );\n        layout.setVerticalGroup(\n            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)\n            .addGroup(layout.createSequentialGroup()\n                .addContainerGap()\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lResultCode)\n                    .addComponent(tfResultCode, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(lDescription)\n                    .addComponent(tfDescription, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))\n                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)\n                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)\n                    .addComponent(bCancel)\n                    .addComponent(bSave))\n                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))\n        );\n\n        pack();\n    }// </editor-fold>//GEN-END:initComponents\n\n    private void bSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bSaveActionPerformed\n        try {\n            int code = Integer.parseInt(tfResultCode.getText());\n            String description = tfDescription.getText();\n            ManageDBResultCodes.getInstance().saveNewCode(code, description);\n            dispose();\n        } catch (SQLException ex) {\n            JOptionPane.showMessageDialog(this,\n                    \"Error while saving ResultCode to DB: \" + ex.getMessage(),\n                    \"Error while saving\", JOptionPane.ERROR_MESSAGE);\n        } catch (NumberFormatException ex) {\n            JOptionPane.showMessageDialog(this,\n                    \"Error while saving ResultCode to DB: ResultCode must be a \"\n                    + \"number!\",\n                    \"Error while saving\", JOptionPane.ERROR_MESSAGE);\n            tfResultCode.selectAll();\n            tfResultCode.requestFocusInWindow();\n        } catch (Exception ex) {\n            JOptionPane.showMessageDialog(this,\n                    \"Error while saving ResultCode: \" + ex.getMessage(),\n                    \"Error while saving\", JOptionPane.ERROR_MESSAGE);\n        } \n    }//GEN-LAST:event_bSaveActionPerformed\n\n    private void bCancelActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_bCancelActionPerformed\n        this.dispose();\n    }//GEN-LAST:event_bCancelActionPerformed\n\n    private void tfDescriptionActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_tfDescriptionActionPerformed\n        bSaveActionPerformed(evt);\n    }//GEN-LAST:event_tfDescriptionActionPerformed\n\n    @Override\n    public void setVisible(boolean v) {\n        super.setVisible(v);\n        clearForm();\n    }\n\n    // Variables declaration - do not modify//GEN-BEGIN:variables\n    private javax.swing.JButton bCancel;\n    private javax.swing.JButton bSave;\n    private javax.swing.JLabel lDescription;\n    private javax.swing.JLabel lResultCode;\n    private javax.swing.JTextField tfDescription;\n    private javax.swing.JTextField tfResultCode;\n    // End of variables declaration//GEN-END:variables\n\n    private void clearForm() {\n        tfResultCode.setText(\"\");\n        tfDescription.setText(\"\");\n    }\n\n}\n", "pl.jena.rdf.model.*;\n\n\npublic class EMAILRDF {\n\t//Create a default model\n    private static Model m = ModelFactory.createDefaultModel();\n    \n    //Subject of the mail\n    public static final Property MSGID = m.createProperty(\"MESSAGEID:\" );\n    public static final Property MAILID = m.createProperty(\"MAILID:\" );\n    public static final Property SUBJECT = m.createProperty(\"SUB:\" );\n\t//Sender of the mail\n\tpublic static final Property FROM = m.createProperty(\"FROM:\" );\n\tpublic static final Property FROMFULL = m.createProperty(\"FROMFULL:\" );\n\tpublic static final Property TOFULL = m.createProperty(\"TOFULL:\" );\n\tpublic static final Property EMAILID = m.createProperty(\"EMAILID:\" );\n\t//Receiver of the mail\n\tpublic static final Property TO  = m.createProperty(\"TO:\" );\n\t//Return path\n\tpublic static final Property RETURN_PATH = m.createProperty(\"RETURNPATH:\" );\n\t//main contents of the mail\n\tpublic static final Property CONTENT = m.createProperty(\"CONTENT:\" );\n\t//format of the mail\n\tpublic static final Property FORMAT = m.createProperty(\"FORMAT:\" );\t\n\t//content type like html etc\n\tpublic static final Property CONTENT_TYPE = m.createProperty(\"CONTENTTYPE:\" );\n\t//encoding in bits\n\tpublic static final Property ENCODING = m.createProperty(\"ENCODING:\" );\n\t//date of the email\n\tpublic static final Property DATE = m.createProperty(\"DATE:\" );   \t \n\t//CC of email\t\n\tpublic static final Property CC = m.createProperty(\"CC:\" ); \n\t//BCC of email\t\n\tpublic static final Property BCC = m.createProperty(\"BCC:\" ); \n\t//NAME OF THE SENDER\n\tpublic static final Property ATTACHEMENT_NAME = m.createProperty(\"ATTACHEMENTNAME:\" );\n\tpublic static final Property ATTACHEMENT_NO = m.createProperty(\"ATTACHEMENTNO:\" );   \n\t//SIZE OF MAIL\t\n\tpublic static final Property MAIL_SIZE = m.createProperty(\"MAILSIZE:\" );   \n\t//SIZE OF THE ATTACHEMENT of email\t\n\tpublic static final Property ATTACHEMENT_SIZE = m.createProperty(\"ATTACHEMENTSIZE:\" );   \n\t//MAIL TO WHICH PARTICULAR MAIL HAVE REPLIED \t\n\tpublic static final Property IN_REPLYTO = m.createProperty(\"REPLIEDTO:\" );\n\tpublic static final Property IN_REPLYTONAME = m.createProperty(\"REPLIEDTONAME:\" );\n\t//FOLDER IN WHICH email EXISTS\t\n\tpublic static final Property FOLDER_NAME = m.createProperty(\"FOLDERNAME:\" );   \n\t//UID of email\t\n\tpublic static final Property UID = m.createProperty(\"UID:\" );   \n   //name os receiver of email\t\n\tpublic static final Property REC_NAME = m.createProperty(\"RECIEVERS_NAME:\" );   \n   //name of sender of email\t\n\tpublic static final Property SEND_NAME = m.createProperty(\"SENDERNAME:\" );   \n   \n    \n\n\n\n   }\n   \n", "\tprivate typeEnum type;\n\tpublic static enum typeEnum {\n\t    Chat, //indicates that there is \n\t    EntityUpdated,\n\t    error\n\t}\n\t\n\t/**\n\t * Construct a new Message object from the b64 encoded response from the server. Must have already been split. \n\t * First character will indicate the Type, and the rest will be stored as the content.\n\t * @param rawReceived\n\t */\n\tMessage(String rawReceived)\n\t{\n\t\t\n\t\tswitch(stringToType(rawReceived))\n\t\t{\n\t\tcase Chat:\n\t\t\ttype = Message.typeEnum.Chat;\n\t\t\tcontent = rawReceived.substring(1);//char 1 to the end\n\t\t\tbreak;\n\t\tcase EntityUpdated:\n\t\t\ttype = Message.typeEnum.EntityUpdated;\n\t\t\tcontent = rawReceived.substring(1);//char 1 to the end\n\t\t\tbreak;\n\t\tcase error:\n\t\tdefault:\n\t\t\tbreak;//error!\n\t\t}\n\t}\n\t\n\t/**\n\t * Construct a new Message object to be sent from a b64 encoded content string and a typeEnum. \n\t * First character will indicate the Type, and the rest will be stored as the content.\n\t * @param rawReceived\n\t */\n\tMessage(typeEnum t, String c)\n\t{\n\t\tthis.type = t;\n\t\tthis.content = c;\n\t}\n\t\n\t\n\tpublic typeEnum getType()\n\t{\n\t\treturn type;\n\t}\n\t\n\tpublic String getStringContentFromB64()\n\t{\n\t\treturn Base64Coder.decodeString(content);\n\t}\n\t\n\tpublic byte[] getBytesContentFromB64()\n\t{\n\t\treturn Base64Coder.decode(content);\n\t}\n\t\n\t/**\n\t * Use toString to generate the string to send to the server.\n\t */\n\tpublic String toString()\n\t{\n\t\treturn typeToString(type)+content;\n\t}\n\t\n\t/**\n\t * Convert a 1-long string to a typeEnum\n\t * @param s\n\t * @return\n\t */\n\tprivate static typeEnum stringToType(String s)\n\t{\n\t\treturn charToType(s.charAt(0));\n\t}\n\t\n\t/**\n\t * Convert a char string to a typeEnum\n\t * @param s\n\t * @return\n\t */\n\tprivate static typeEnum charToType(char c)\n\t{\n\t\tswitch(c)\n\t\t{\n\t\tcase 'c':\n\t\t\treturn Message.typeEnum.Chat;\n\t\tcase 'e':\n\t\t\treturn Message.typeEnum.EntityUpdated;\n\t\tdefault:\n\t\t\t//error!!!!\n\t\t\tSystem.out.println(\"Invalid Message type. Received: '\"+c+\"'\");\n\t\t\treturn Message.typeEnum.error;\n\t\t}\n\t}\n\t\n\t/**\n\t * convert a typeEnum to it's string equivalent\n\t * @param t\n\t * @return\n\t */\n\tprivate static String typeToString(typeEnum t)\n\t{\n\t\tswitch(t)\n\t\t{\n\t\tcase Chat:\n\t\t\treturn \"c\";\n\t\tcase EntityUpdated:\n\t\t\treturn \"e\";\n\t\tdefault:\n\t\t\t//error!!!!\n\t\t\tSystem.out.println(\"Invalid Message type. Received: '\"+t+\"'\");\n\t\t\treturn null;\n\t\t}\n\t}\n\t\n\tpublic static Message MessageFactoryStringToB64(typeEnum t, String real)\n\t{\n\t\treturn new Message(t, Base64Coder.encodeString(real));\n\t}\n\t\n}\n", "VE COPYRIGHT NOTICES OR THIS FILE HEADER.\n *\n * This code is free software; you can redistribute it and/or modify it\n * under the terms of the GNU General Public License version 2 only, as\n * published by the Free Software Foundation.  Oracle designates this\n * particular file as subject to the \"Classpath\" exception as provided\n * by Oracle in the LICENSE file that accompanied this code.\n *\n * This code is distributed in the hope that it will be useful, but WITHOUT\n * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n * version 2 for more details (a copy is included in the LICENSE file that\n * accompanied this code).\n *\n * You should have received a copy of the GNU General Public License version\n * 2 along with this work; if not, write to the Free Software Foundation,\n * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n *\n * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n * or visit www.oracle.com if you need additional information or have any\n * questions.\n */\n\n/** Java interface \"ContactInfoListIterator.java\" generated from Poseidon for UML.\n *  Poseidon for UML is developed by <A HREF=\"http://www.gentleware.com\">Gentleware</A>.\n *  Generated with <A HREF=\"http://jakarta.apache.org/velocity/\">velocity</A> template engine.\n */\npackage com.sun.pept.ept;\n\nimport java.util.*;\n\n/**\n * <p>\n *\n * @author Dr. Harold Carr\n * </p>\n */\npublic interface ContactInfoListIterator {\n\n  ///////////////////////////////////////\n  // operations\n\n/**\n * <p>\n * Does ...\n * </p><p>\n *\n * @return a boolean with ...\n * </p>\n */\n    public boolean hasNext();\n/**\n * <p>\n * Does ...\n * </p><p>\n *\n * @return a ContactInfo with ...\n * </p>\n */\n    public ContactInfo next();\n\n} // end ContactInfoListIterator\n", "fr.afcepf.al29.groupem.entities.Coupon;\r\n\r\npublic interface CouponDaoApi {\r\n\r\n    \r\n    Coupon createCoupon(Coupon paramCoupon);\r\n    Coupon updateCoupon(Coupon coupon);\r\n    boolean destroyCoupon(Coupon coupon);\r\n    \r\n    \r\n    Coupon getCouponById(int paramCouponId);\r\n    List<Coupon> getCouponByCode(String code);\r\n    \r\n    List<Coupon> getAllCoupons();\r\n    \r\n    List<Coupon> getCouponsByCatId(int catId);\r\n    \r\n    List<Coupon> getCouponsStartinBefore(Date date);\r\n    List<Coupon> getCouponsStartingAfter(Date date);\r\n    List<Coupon> getCouponsStartingOn(Date date);\r\n    \r\n    List<Coupon> getCouponsEndingBefore(Date date);\r\n    List<Coupon> getCouponsEndingAfter(Date date);\r\n    List<Coupon> getCouponsEndingOn(Date date);\r\n    \r\n    List<Coupon> getCouponsByRebateLesserThan(float rebate);\r\n    List<Coupon> getCouponsByRebateGreaterThan(float rebate);\r\n    List<Coupon> getCouponsByRebateEquals(float rebate);\r\n    \r\n    \r\n\r\n}\r\n", "gePowered <https://www.spongepowered.org>\n * Copyright (c) contributors\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage org.spongepowered.api.data.type;\n\n/**\n * A utility class for getting all available {@link Career}s.\n */\npublic final class Careers {\n\n    public static final Career FARMER = null;\n    public static final Career FISHERMAN = null;\n    public static final Career SHEPHERD = null;\n    public static final Career FLETCHER = null;\n    public static final Career LIBRARIAN = null;\n    public static final Career CLERIC = null;\n    public static final Career ARMORER = null;\n    public static final Career WEAPON_SMITH = null;\n    public static final Career TOOL_SMITH = null;\n    public static final Career BUTCHER = null;\n    public static final Career LEATHERWORKER = null;\n\n    private Careers() {\n\n    }\n}\n", "ava API\n Copyright (c) Microsoft Corporation\n All rights reserved.\n MIT License\n Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"\"Software\"\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n THE SOFTWARE IS PROVIDED *AS IS*, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n **************************************************************************/\n\npackage microsoft.exchange.webservices.data;\n\n/**\n * Represents an error that occurs when an operation on a property fails.\n */\npublic class PropertyException extends ServiceLocalException {\n\n  /**\n   * Constant serialized ID used for compatibility.\n   */\n  private static final long serialVersionUID = 1L;\n\n  /**\n   * The name.\n   */\n  private String name;\n\n  /**\n   * Instantiates a new property exception.\n   */\n  public PropertyException() {\n    super();\n  }\n\n  /**\n   * Instantiates a new property exception.\n   *\n   * @param name the name\n   */\n  public PropertyException(String name) {\n    super();\n    this.name = name;\n  }\n\n  /**\n   * Instantiates a new property exception.\n   *\n   * @param message the message\n   * @param name    the name\n   */\n  public PropertyException(String message, String name) {\n    super(message);\n    this.name = name;\n  }\n\n  /**\n   * Instantiates a new property exception.\n   *\n   * @param message        the message\n   * @param name           the name\n   * @param innerException the inner exception\n   */\n  public PropertyException(String message, String name,\n      Exception innerException) {\n    super(message, innerException);\n    this.name = name;\n  }\n\n  /**\n   * Gets the name.\n   *\n   * @return the name\n   */\n  public String getName() {\n    return name;\n  }\n\n}\n", "9 Oliver Stanley\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage pw.ollie.dzlib.function;\n\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.function.BiConsumer;\nimport java.util.function.BiPredicate;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.Supplier;\n\n/**\n * Various utility methods for creation of {@link FunctionalInterface} types\n * which have a specific function.\n */\npublic final class Functions {\n    /**\n     * Transforms the given {@link Collection} into the given {@link Map}, where\n     * the keys are the value returned by applying the given {@link Function} to\n     * the value they are mapped to. The values are the elements contained in\n     * the given Collection.\n     *\n     * @param collection the {@link Collection} to map\n     * @param function the {@link Function} to use to determine keys\n     * @param <A> the type of key for the map\n     * @param <B> the type of value for the map\n     * @return a {@link Map} of {@code function}-determined keys to given values\n     */\n    public static <A, B> Map<A, B> map(Collection<B> collection, Map<A, B> map, Function<B, A> function) {\n        collection.forEach((l) -> map.put(function.apply(l), l));\n        return map;\n    }\n\n    /**\n     * Transforms the given {@link Collection} into a new {@link Map}, where\n     * the keys are the value returned by applying the given {@link Function} to\n     * the value they are mapped to. The values are the elements contained in\n     * the given Collection.\n     *\n     * This is equivalent to calling {@link #map(Collection, Map, Function)}\n     * with {@code new HashMap<>} provided for the {@link Map} argument.\n     *\n     * @param collection the {@link Collection} to map\n     * @param function the {@link Function} to use to determine keys\n     * @param <A> the type of key for the map\n     * @param <B> the type of value for the map\n     * @return a {@link Map} of {@code function}-determined keys to given values\n     */\n    public static <A, B> Map<A, B> map(Collection<B> collection, Function<B, A> function) {\n        return map(collection, new HashMap<>(), function);\n    }\n\n    /**\n     * Creates a new {@link Predicate} to check that the accepted {@link T} is\n     * of the given {@link Class} type.\n     *\n     * @param clazz the class to check the accepted object is an instance of\n     * @param <T> the type of object to accept in the {@link Predicate}\n     * @return a Predicate to check that accepted objects are of the given type\n     */\n    public static <T> Predicate<T> isInstance(Class<? extends T> clazz) {\n        return clazz::isInstance;\n    }\n\n    /**\n     * Creates a new {@link Predicate} to check that the accepted {@link T} is\n     * not of the given {@link Class} type.\n     *\n     * @param clazz the class to check the accepted object isn't an instance of\n     * @param <T> the type of object to accept in the {@link Predicate}\n     * @return a Predicate to check that accepted objects aren't of given type\n     */\n    public static <T> Predicate<T> notInstance(Class<? extends T> clazz) {\n        return (e) -> !clazz.isInstance(e);\n    }\n\n    /**\n     * Gets a {@link BiPredicate} which checks for the two given objects being\n     * equal to each other, classing two {@code null} objects as equal.\n     *\n     * @param <T> the type of object to compare\n     * @return a BiPredicate checking for two given objects being equal\n     * @see {@link #areEqual()}\n     */\n    public static <T> BiPredicate<T, T> areEqualNullable() {\n        return EQUAL_NULLABLE_PREDICATE;\n    }\n\n    /**\n     * Gets a {@link Consumer} which does nothing every time.\n     *\n     * @param <T> the type of object to consume\n     * @return a Consumer which does nothing every time\n     */\n    public static <T> Consumer<T> voidConsumer() {\n        return VOID_CONSUMER;\n    }\n\n    /**\n     * Gets a {@link BiConsumer} which does nothing every time.\n     *\n     * @param <T> the first type of object to consume\n     * @param <U> the second type of object to consume\n     * @return a BiConsumer which does nothing every time\n     */\n    public static <T, U> BiConsumer<T, U> voidBiConsumer() {\n        return VOID_BICONSUMER;\n    }\n\n    /**\n     * Gets a {@link Supplier} which returns {@code null} every time.\n     *\n     * @param <T> the type for the Supplier to return\n     * @return a Supplier which returns {@code null} every time\n     */\n    public static <T> Supplier<T> nullSupplier() {\n        return NULL_SUPPLIER;\n    }\n\n    /**\n     * Gets a {@link Supplier} which returns {@code value} every time.\n     *\n     * @param <T> the type for the Supplier to return\n     * @return a Supplier which returns {@code value} every time\n     */\n    public static <T> Supplier<T> constantSupplier(T value) {\n        return () -> value;\n    }\n\n    /**\n     * Gets a {@link Predicate} which returns {@code true} every time.\n     *\n     * @param <T> the type for the Predicate to accept\n     * @return a Predicate which returns {@code true} every time\n     */\n    public static <T> Predicate<T> truePredicate() {\n        return TRUE_PREDICATE;\n    }\n\n    /**\n     * Gets a {@link Predicate} which returns {@code false} every time.\n     *\n     * @param <T> the type for the Predicate to accept\n     * @return a Predicate which returns {@code false} every time\n     */\n    public static <T> Predicate<T> falsePredicate() {\n        return FALSE_PREDICATE;\n    }\n\n    // Various FunctionalInterface implementations\n\n    private static final Consumer VOID_CONSUMER = (e) -> {\n    };\n    private static final BiConsumer VOID_BICONSUMER = (a, b) -> {\n    };\n    private static final Supplier NULL_SUPPLIER = () -> null;\n    private static final Predicate TRUE_PREDICATE = (e) -> true;\n    private static final Predicate FALSE_PREDICATE = (e) -> false;\n    private static final BiPredicate EQUAL_NULLABLE_PREDICATE = (a, b) -> {\n        if (a == null || b == null) {\n            return a == null && b == null;\n        } else {\n            return a.equals(b);\n        }\n    };\n\n    private Functions() {\n    }\n}\n", ".Point;\nimport java.awt.Rectangle;\nimport java.io.File;\nimport java.io.FileNotFoundException;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.OutputStream;\nimport java.io.OutputStreamWriter;\nimport java.io.UnsupportedEncodingException;\nimport java.lang.reflect.Field;\nimport java.lang.reflect.Method;\nimport java.net.MalformedURLException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.Stack;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Result;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\nimport org.w3c.dom.NodeList;\n\nimport com.polydes.scenelink.data.Link;\nimport com.polydes.scenelink.ui.Reflect;\nimport com.polydes.scenelink.util.ColorUtil;\n\nimport stencyl.sw.util.FileHelper;\n\npublic class XML\n{\n\tprivate static class XMLState\n\t{\n\t\tpublic Element e;\n\t\tpublic ArrayList<Element> layer;\n\t\tpublic int layerIndex;\n\t}\n\n\tpublic static void saveState()\n\t{\n\t\tXMLState s = new XMLState();\n\t\ts.e = e;\n\t\ts.layer = layer;\n\t\ts.layerIndex = layerIndex;\n\t\tstates.push(s);\n\t}\n\t\n\tpublic static void restoreState()\n\t{\n\t\tXMLState s = states.pop();\n\t\te = s.e;\n\t\tlayer = s.layer;\n\t\tlayerIndex = s.layerIndex;\n\t}\n\t\n\tprivate static Element e = null;\n\tprivate static ArrayList<Element> layer = null;\n\tprivate static int layerIndex = -1;\n\t\n\tprivate static Stack<XMLState> states = new Stack<XMLState>();\n\n\tpublic static Document createDocument()\n\t{\n\t\tDocumentBuilder builder = null;\n\t\ttry\n\t\t{\n\t\t\tbuilder = DocumentBuilderFactory.newInstance().newDocumentBuilder();\n\t\t}\n\t\tcatch (ParserConfigurationException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn builder.newDocument();\n\t}\n\t\n\tpublic static void writeDocument(Document d, String url)\n\t{\n\t\ttry\n\t\t{\n\t\t\tOutputStream out = new FileOutputStream(url);\n\t\t\t\n\t\t\tResult result = new StreamResult(new OutputStreamWriter(out, \"utf-8\"));\n\t\t\tDOMSource source = new DOMSource(d);\n\t\t\n\t\t\tTransformerFactory factory = TransformerFactory.newInstance();\n\t\t\tTransformer xformer = factory.newTransformer();\n\t\t\txformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n\t\t\txformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\");\n\t\t\txformer.transform(source, result);\n\t\t\tout.close();\n\t\t}\n\t\tcatch(IllegalArgumentException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (FileNotFoundException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (UnsupportedEncodingException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (TransformerConfigurationException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (TransformerException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static Element getElement()\n\t{\n\t\treturn e;\n\t}\n\n\tpublic static void setElement(Element e)\n\t{\n\t\tXML.e = e;\n\t}\n\t\n\tpublic static void setFile(String url)\n\t{\n\t\tString s = \"\";\n\t\ttry\n\t\t{\n\t\t\ts = new File(url).toURI().toURL().toString();\n\t\t\tXML.e = FileHelper.readXMLFromFile(s).getDocumentElement();\n\t\t}\n\t\tcatch (MalformedURLException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t\tcatch (IOException e)\n\t\t{\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static void descend()\n\t{\n\t\tsaveState();\n\t\t\n\t\tNodeList itemList = e.getChildNodes();\n\t\tlayer = new ArrayList<Element>();\n\t\tlayerIndex = -1;\n\t\t\n\t\tfor(int i = 0; i < itemList.getLength(); i++) \n\t\t{\n\t\t\tif(itemList.item(i) instanceof Element)\n\t\t\t{\n\t\t\t\tlayer.add((Element) itemList.item(i));\n\t\t\t}\n\t\t}\n\t}\n\t\n\tpublic static void ascend()\n\t{\n\t\trestoreState();\n\t}\n\t\n\tpublic static boolean hasNext()\n\t{\n\t\treturn (layerIndex + 1) < layer.size();\n\t}\n\t\n\tpublic static void next()\n\t{\n\t\te = layer.get(++layerIndex);\n\t}\n\t\n\tpublic static boolean elementNameIs(String name)\n\t{\n\t\treturn e.getTagName().equals(name);\n\t}\n\t\n\tpublic static int rint(String name)\n\t{\n\t\treturn rint(name, 0);\n\t}\n\t\n\tpublic static int rint(String name, int defReturn)\n\t{\n\t\tString s = e.getAttribute(name);\n\t\tif(s.equals(\"\"))\n\t\t\treturn defReturn;\n\t\treturn Integer.parseInt(s);\n\t}\n\t\n\tpublic static Integer rInteger(String name)\n\t{\n\t\treturn rint(name, 0);\n\t}\n\t\n\tpublic static void wrint(String name, int i)\n\t{\n\t\te.setAttribute(name, \"\"+i);\n\t}\n\t\n\tpublic static boolean rboolean(String name)\n\t{\n\t\treturn Boolean.parseBoolean(e.getAttribute(name));\n\t}\n\t\n\tpublic static Boolean rBoolean(String name)\n\t{\n\t\treturn Boolean.parseBoolean(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrboolean(String name, boolean b)\n\t{\n\t\te.setAttribute(name, b ? \"true\" : \"false\");\n\t}\n\t\n\tpublic static void wrBoolean(String name, Boolean b)\n\t{\n\t\te.setAttribute(name, b ? \"true\" : \"false\");\n\t}\n\t\n\tpublic static String rString(String name)\n\t{\n\t\treturn e.getAttribute(name);\n\t}\n\t\n\tpublic static void wrString(String name, String s)\n\t{\n\t\te.setAttribute(name, s);\n\t}\n\t\n\tpublic static Color rColor(String name)\n\t{\n\t\treturn ColorUtil.decode(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrColor(String name, Color c)\n\t{\n\t\te.setAttribute(name, ColorUtil.encode(c));\n\t}\n\t\n\tpublic static Float rFloat(String name)\n\t{\n\t\treturn Float.parseFloat(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrFloat(String name, Float f)\n\t{\n\t\te.setAttribute(name, \"\" + f);\n\t}\n\t\n\tpublic static float rfloat(String name)\n\t{\n\t\treturn Float.parseFloat(e.getAttribute(name));\n\t}\n\t\n\tpublic static void wrfloat(String name, float f)\n\t{\n\t\te.setAttribute(name, \"\" + f);\n\t}\n\t\n//\tpublic static BufferedImage rImage(String name)\n//\t{\n//\t\treturn Resources.readImage(e.getAttribute(name));\n//\t}\n\t\n\tpublic static Point rPoint(String name)\n\t{\n\t\tint[] ints = getInts(e.getAttribute(name));\n\t\tif(ints == null)\n\t\t\treturn new Point(0, 0);\n\t\t\n\t\treturn new Point(ints[0], ints[1]);\n\t}\n\t\n\tpublic static void wrPoint(String name, Point p)\n\t{\n\t\te.setAttribute(name, p.x + \", \" + p.y);\n\t}\n\t\n\tpublic static Dimension rDimension(String name)\n\t{\n\t\tint[] ints = getInts(e.getAttribute(name));\n\t\tif(ints == null)\n\t\t\treturn new Dimension(0, 0);\n\t\t\n\t\treturn new Dimension(ints[0], ints[1]);\n\t}\n\t\n\tpublic static void wrDimension(String name, Dimension d)\n\t{\n\t\te.setAttribute(name, d.width + \", \" + d.height);\n\t}\n\t\n\tpublic static Rectangle rRectangle(String name)\n\t{\n\t\tint[] ints = getInts(e.getAttribute(name));\n\t\tif(ints == null)\n\t\t\treturn new Rectangle(0, 0, 0, 0);\n\t\t\n\t\treturn new Rectangle(ints[0], ints[1], ints[2], ints[3]);\n\t}\n\t\n\tpublic static void wrRectangle(String name, Rectangle r)\n\t{\n\t\te.setAttribute(name, r.x + \", \" + r.y + \", \" + r.width + \", \" + r.height);\n\t}\n\t\n\tpublic static int[] getInts(String fromString)\n\t{\n\t\tif(fromString.length() == 0)\n\t\t\treturn null;\n\t\t\n\t\tString[] splitString = fromString.split(\",\");\n\t\tint[] toReturn = new int[splitString.length];\n\t\tfor(int i = 0; i < splitString.length; ++i)\n\t\t\ttoReturn[i] = Integer.parseInt(splitString[i].trim());\n\t\treturn toReturn;\n\t}\n\t\n\tpublic static Link rLink(String name)\n\t{\n\t\tString linkText = e.getAttribute(name);\n\t\tif(linkText.equals(\"\"))\n\t\t\treturn Link.createBlank();\n\t\t\n\t\tString[] s = linkText.split(\" \");\n\t\treturn Link.create(s[0], Integer.parseInt(s[1]));\n\t}\n\t\n\tpublic static void wrLink(String name, Link l)\n\t{\n\t\te.setAttribute(name, Link.getStringRef(l));\n\t}\n\n\tpublic static Element wrElement(Document d, String name, Object o, String[] attrs)\n\t{\n\t\tElement e2 = e;\n\t\te = d.createElement(name);\n\t\tif(o != null && attrs.length > 0)\n\t\t{\n\t\t\tField[] fields = Reflect.getFields(o, attrs);\n\t\t\tObject[] vals = Reflect.getValues(o, attrs);\n\t\t\tfor(int i = 0; i < attrs.length; ++i)\n\t\t\t{\n\t\t\t\tMethod writer = Reflect.getMethod(XML.class, \"wr\" + fields[i].getType().getSimpleName(), String.class, fields[i].getType());\n\t\t\t\tReflect.invoke(writer, null, attrs[i], vals[i]);\n\t\t\t}\n\t\t}\n\t\t\n\t\tElement toReturn = e;\n\t\te = e2;\n\t\treturn toReturn;\n\t}\n\t\n\tpublic static void wrObjectToFile(String url, Object o)\n\t{\n\t\tXML.saveState();\n\t\t\n\t\tDocument d = XML.createDocument();\n\t\tElement root = XML.wrObjectToElement(d, o);\n\t\td.appendChild(root);\n\t\t\n\t\tXML.writeDocument(d, url);\n\t\t\n\t\tXML.restoreState();\n\t}\n\t\n\tpublic static Element wrObjectToElement(Document d, Object o)\n\t{\n\t\tString name = o.getClass().getSimpleName();\n\t\tname = name.toLowerCase();\n\t\tif(name.endsWith(\"model\"))\n\t\t\tname = name.substring(0, name.length() - 5);\n\t\t\n\t\tElement e2 = e;\n\t\te = d.createElement(name);\n\t\t\n\t\tHashMap<String, Field> fieldMap = Reflect.getDeclaredFieldMap(o);\n\t\t\n\t\tfor(String k : fieldMap.keySet().toArray(new String[]{}))\n\t\t{\n\t\t\tField f = fieldMap.get(k);\n\t\t\tClass<?> type = f.getType();\n\t\t\t\n\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t{\n\t\t\t\tMethod writer = Reflect.getMethod(XML.class, \"wr\" + f.getType().getSimpleName(), String.class, f.getType());\n\t\t\t\tReflect.invoke(writer, null, f.getName(), Reflect.getFieldValue(f, o));\n\t\t\t\tfieldMap.remove(k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(String k : fieldMap.keySet().toArray(new String[]{}))\n\t\t{\n\t\t\tField f = fieldMap.get(k);\n\t\t\tClass<?> type = f.getType();\n\t\t\t\n\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t\tcontinue;\n\t\t\t\n\t\t\tElement listElement = wrListElement(d, o, f);\n\t\t\tfieldMap.remove(k);\n\t\t\te.appendChild(listElement);\n\t\t}\n\t\t\n\t\tElement toReturn = e;\n\t\te = e2;\n\t\treturn toReturn;\n\t}\n\t\n\tpublic static Element wrListElement(Document d, Object o, Field f)\n\t{\n\t\tElement top = d.createElement(f.getName());\n\t\t\n\t\tCollection<?> c = null;\n\t\tif(f.getType() == ArrayList.class)\n\t\t\tc = (ArrayList<?>) Reflect.getFieldValue(f, o);\n\t\telse if(f.getType() == HashMap.class)\n\t\t\tc = ((HashMap<?, ?>) Reflect.getFieldValue(f, o)).values();\n\t\t\n\t\tif(c != null)\n\t\t{\n\t\t\tfor(Object item : c)\n\t\t\t{\n\t\t\t\tElement toAdd = wrObjectToElement(d, item);\n\t\t\t\ttop.appendChild(toAdd);\n\t\t\t}\n\t\t}\n\t\t\n\t\treturn top;\n\t}\n\t\n\tpublic static Object rObjectFromFile(String url, Class<?> cls)\n\t{\n\t\tsaveState();\n\t\tsetFile(url);\n\t\t\n\t\tObject toReturn = rObjectFromElement(cls);\n\t\t\n\t\trestoreState();\n\t\t\n\t\treturn toReturn;\n\t}\n\t\n\t/*\n\t * Read an object from an element.\n\t * Basic fields are read from the object representing tags attributes.\n\t * HashMap<?, ?> is read from an element with a list of subelements, with the \"id\" field being used as a storage key\n\t * ArrayList<?> is read from an element with a list of subelements\n\t */\n\tpublic static Object rObjectFromElement(Class<?> cls)\n\t{\n\t\tObject o = Reflect.newInstance(cls);\n\t\t\n\t\tHashMap<String, Field> fieldMap = Reflect.getDeclaredFieldMap(cls);\n\t\t\n\t\tfor(String k : fieldMap.keySet().toArray(new String[]{}))\n\t\t{\n\t\t\tField f = fieldMap.get(k);\n\t\t\tClass<?> type = f.getType();\n\t\t\t\n\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t{\n\t\t\t\tMethod reader = Reflect.getMethod(XML.class, \"r\" + type.getSimpleName(), String.class);\n\t\t\t\tObject value = Reflect.invoke(reader, null, k);\n\t\t\t\tReflect.setField(f, o, value);\n\t\t\t\tfieldMap.remove(k);\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(!fieldMap.isEmpty())\n\t\t{\n\t\t\tXML.descend();\n\t\t\twhile(XML.hasNext())\n\t\t\t{\n\t\t\t\tXML.next();\n\t\t\t\tField f = fieldMap.get(e.getTagName());\n\t\t\t\tif(f == null)\n\t\t\t\t\tcontinue;\n\t\t\t\tClass<?> type = f.getType();\n\t\t\t\tif(type != HashMap.class && type != ArrayList.class)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(type == HashMap.class)\n\t\t\t\t{\n\t\t\t\t\tClass<?>[] classes = Reflect.getGenericTypes(f);\n\t\t\t\t\tObject value = rHashMap(classes[0], classes[1]);\n\t\t\t\t\tReflect.setField(f, o, value);\n\t\t\t\t\tfieldMap.remove(e.getTagName());\n\t\t\t\t}\n\t\t\t\telse if(type == ArrayList.class)\n\t\t\t\t{\n\t\t\t\t\tClass<?>[] classes = Reflect.getGenericTypes(f);\n\t\t\t\t\tObject value = rArrayList(classes[0]);\n\t\t\t\t\tReflect.setField(f, o, value);\n\t\t\t\t\tfieldMap.remove(e.getTagName());\n\t\t\t\t}\n\t\t\t}\n\t\t\tXML.ascend();\n\t\t}\n\t\t\n\t\treturn o;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T, U> HashMap<T, U> rHashMap(Class<?> keyCls, Class<?> valCls)\n\t{\n\t\tHashMap<T, U> toReturn = new HashMap<T, U>();\n\t\t\n\t\tMethod keyReader = Reflect.getMethod(XML.class, \"r\" + keyCls.getSimpleName(), String.class);\n\t\t\n\t\tXML.descend();\n\t\twhile(XML.hasNext())\n\t\t{\n\t\t\tXML.next();\n\t\t\tT keyValue = (T) Reflect.invoke(keyReader, null, \"id\");\n\t\t\tU value = (U) rObjectFromElement(valCls);\n\t\t\ttoReturn.put(keyValue, value);\n\t\t}\n\t\tXML.ascend();\n\t\t\n\t\treturn toReturn;\n\t}\n\t\n\t@SuppressWarnings(\"unchecked\")\n\tpublic static <T> ArrayList<T> rArrayList(Class<?> gen)\n\t{\n\t\tArrayList<T> toReturn = new ArrayList<T>();\n\t\t\n\t\tXML.descend();\n\t\twhile(XML.hasNext())\n\t\t{\n\t\t\tXML.next();\n\t\t\tT val = (T) rObjectFromElement(gen);\n\t\t\ttoReturn.add(val);\n\t\t}\n\t\tXML.ascend();\n\t\t\n\t\treturn toReturn;\n\t}\n}\n", "age};\n\nimport org.junit.Test;\n\npublic class ApplicationTest {\n\n\t@Test\n\tpublic void testSetup() {\n\t\n\t}\n}\n", "t org.apache.tapestry5.annotations.Persist;\nimport org.apache.tapestry5.annotations.Property;\nimport org.apache.tapestry5.annotations.SetupRender;\nimport org.apache.tapestry5.ioc.annotations.Inject;\nimport org.arnolf.tapestry.mongo.services.MongoConnection;\n\nimport com.mongodb.BasicDBObject;\nimport com.mongodb.DB;\nimport com.mongodb.DBObject;\n\n@Import(stack = { \"boostrap\" })\npublic class Index {\n\n\t@Inject\n\tprivate MongoConnection mongoConnection;\n\t\n\t@Property\n\t@Persist\n\tprivate DBObject document;\n\t\n\t@Property\n\tprivate boolean separateShipTo;\n\t\n\t@Property\n\tprivate int index;\n\t\n\tprivate long userId;\n\t\n\tpublic void onActivate(long userId) {\n\t\tthis.userId = userId;\n\t}\n\t\n\tpublic long onPassivate() {\n\t\treturn this.userId;\n\t}\n\t\n\t@SetupRender\n\tpublic void init() {\n\t\tDB db = this.mongoConnection.getDB();\n\t\tthis.document = db.getCollection(\"person\").\n\t\t\t\tfindAndModify(new BasicDBObject(\"_id\", userId), null, null, false, new BasicDBObject(\"$set\", new BasicDBObject(\"_id\", userId)), true, true);\n\t}\n\t\n\tpublic void onSubmit() {\n\t\tthis.mongoConnection.getDB().getCollection(\"person\").save(document);\n\t}\n}\n", " Hat, Inc., Victor Glushenkov\n * \n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.maven;\n\nimport hudson.AbortException;\nimport hudson.FilePath;\nimport hudson.Launcher;\nimport hudson.Util;\nimport hudson.EnvVars;\nimport hudson.scm.ChangeLogSet;\nimport hudson.FilePath.FileCallable;\nimport hudson.maven.MavenBuild.ProxyImpl2;\nimport hudson.maven.reporters.MavenFingerprinter;\nimport hudson.maven.reporters.MavenMailer;\nimport hudson.model.AbstractProject;\nimport hudson.model.Action;\nimport hudson.model.Build;\nimport hudson.model.BuildListener;\nimport hudson.model.Environment;\nimport hudson.model.Fingerprint;\nimport hudson.model.Hudson;\nimport hudson.model.ParametersAction;\nimport hudson.model.Result;\nimport hudson.model.Computer;\nimport hudson.model.Run;\nimport hudson.model.TaskListener;\nimport hudson.model.Cause.UpstreamCause;\nimport hudson.remoting.Channel;\nimport hudson.remoting.VirtualChannel;\nimport hudson.tasks.BuildWrapper;\nimport hudson.tasks.MailSender;\nimport hudson.tasks.Maven.MavenInstallation;\nimport hudson.util.ArgumentListBuilder;\nimport hudson.util.StreamTaskListener;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.io.InterruptedIOException;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.LinkedHashMap;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Properties;\nimport java.util.Set;\nimport java.util.Map.Entry;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\n\nimport org.apache.maven.BuildFailureException;\nimport org.apache.maven.embedder.MavenEmbedderException;\nimport org.apache.maven.execution.MavenSession;\nimport org.apache.maven.execution.ReactorManager;\nimport org.apache.maven.lifecycle.LifecycleExecutionException;\nimport org.apache.maven.monitor.event.EventDispatcher;\nimport org.apache.maven.project.MavenProject;\nimport org.apache.maven.project.ProjectBuildingException;\nimport org.kohsuke.stapler.StaplerRequest;\nimport org.kohsuke.stapler.StaplerResponse;\n\nimport static hudson.model.Result.FAILURE;\n\n/**\n * {@link Build} for {@link MavenModuleSet}.\n *\n * <p>\n * A \"build\" of {@link MavenModuleSet} consists of:\n *\n * <ol>\n * <li>Update the workspace.\n * <li>Parse POMs\n * <li>Trigger module builds.\n * </ol>\n *\n * This object remembers the changelog and what {@link MavenBuild}s are done\n * on this.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class MavenModuleSetBuild extends AbstractMavenBuild<MavenModuleSet,MavenModuleSetBuild> {\n    /**\n     * {@link MavenReporter}s that will contribute project actions.\n     * Can be null if there's none.\n     */\n    /*package*/ List<MavenReporter> projectActionReporters;\n\n    public MavenModuleSetBuild(MavenModuleSet job) throws IOException {\n        super(job);\n    }\n\n    public MavenModuleSetBuild(MavenModuleSet project, File buildDir) throws IOException {\n        super(project, buildDir);\n    }\n\n    /**\n     * Exposes {@code MAVEN_OPTS} to forked processes.\n     *\n     * When we fork Maven, we do so directly by executing Java, thus this environment variable\n     * is pointless (we have to tweak JVM launch option correctly instead, which can be seen in\n     * {@link MavenProcessFactory}), but setting the environment variable explicitly is still\n     * useful in case this Maven forks other Maven processes via normal way. See HUDSON-3644.\n     */\n    @Override\n    public EnvVars getEnvironment(TaskListener log) throws IOException, InterruptedException {\n        EnvVars envs = super.getEnvironment(log);\n        String opts = project.getMavenOpts();\n        if(opts!=null)\n            envs.put(\"MAVEN_OPTS\", opts);\n        return envs;\n    }\n\n    /**\n     * Displays the combined status of all modules.\n     * <p>\n     * More precisely, this picks up the status of this build itself,\n     * plus all the latest builds of the modules that belongs to this build.\n     */\n    @Override\n    public Result getResult() {\n        Result r = super.getResult();\n\n        for (MavenBuild b : getModuleLastBuilds().values()) {\n            Result br = b.getResult();\n            if(r==null)\n                r = br;\n            else\n            if(br==Result.NOT_BUILT)\n                continue;   // UGLY: when computing combined status, ignore the modules that were not built\n            else\n            if(br!=null)\n                r = r.combine(br);\n        }\n\n        return r;\n    }\n\n    /**\n     * Returns the filtered changeset entries that match the given module.\n     */\n    /*package*/ List<ChangeLogSet.Entry> getChangeSetFor(final MavenModule mod) {\n        return new ArrayList<ChangeLogSet.Entry>() {\n            {\n                // modules that are under 'mod'. lazily computed\n                List<MavenModule> subsidiaries = null;\n\n                for (ChangeLogSet.Entry e : getChangeSet()) {\n                    if(isDescendantOf(e, mod)) {\n                        if(subsidiaries==null)\n                            subsidiaries = mod.getSubsidiaries();\n\n                        // make sure at least one change belongs to this module proper,\n                        // and not its subsidiary module\n                        if (notInSubsidiary(subsidiaries, e))\n                            add(e);\n                    }\n                }\n            }\n\n            private boolean notInSubsidiary(List<MavenModule> subsidiaries, ChangeLogSet.Entry e) {\n                for (String path : e.getAffectedPaths())\n                    if(!belongsToSubsidiary(subsidiaries, path))\n                        return true;\n                return false;\n            }\n\n            private boolean belongsToSubsidiary(List<MavenModule> subsidiaries, String path) {\n                for (MavenModule sub : subsidiaries)\n                    if(path.startsWith(sub.getRelativePath()))\n                        return true;\n                return false;\n            }\n\n            /**\n             * Does this change happen somewhere in the given module or its descendants?\n             */\n            private boolean isDescendantOf(ChangeLogSet.Entry e, MavenModule mod) {\n                for (String path : e.getAffectedPaths())\n                    if(path.startsWith(mod.getRelativePath()))\n                        return true;\n                return false;\n            }\n        };\n    }\n\n    /**\n     * Computes the module builds that correspond to this build.\n     * <p>\n     * A module may be built multiple times (by the user action),\n     * so the value is a list.\n     */\n    public Map<MavenModule,List<MavenBuild>> getModuleBuilds() {\n        Collection<MavenModule> mods = getParent().getModules();\n\n        // identify the build number range. [start,end)\n        MavenModuleSetBuild nb = getNextBuild();\n        int end = nb!=null ? nb.getNumber() : Integer.MAX_VALUE;\n\n        // preserve the order by using LinkedHashMap\n        Map<MavenModule,List<MavenBuild>> r = new LinkedHashMap<MavenModule,List<MavenBuild>>(mods.size());\n\n        for (MavenModule m : mods) {\n            List<MavenBuild> builds = new ArrayList<MavenBuild>();\n            MavenBuild b = m.getNearestBuild(number);\n            while(b!=null && b.getNumber()<end) {\n                builds.add(b);\n                b = b.getNextBuild();\n            }\n            r.put(m,builds);\n        }\n\n        return r;\n    }\n\n    @Override\n    public Object getDynamic(String token, StaplerRequest req, StaplerResponse rsp) {\n        // map corresponding module build under this object\n        if(token.indexOf('$')>0) {\n            MavenModule m = getProject().getModule(token);\n            if(m!=null) return m.getBuildByNumber(getNumber());\n        }\n        return super.getDynamic(token,req,rsp);\n    }\n\n    /**\n     * Computes the latest module builds that correspond to this build.\n     */\n    public Map<MavenModule,MavenBuild> getModuleLastBuilds() {\n        Collection<MavenModule> mods = getParent().getModules();\n\n        // identify the build number range. [start,end)\n        MavenModuleSetBuild nb = getNextBuild();\n        int end = nb!=null ? nb.getNumber() : Integer.MAX_VALUE;\n\n        // preserve the order by using LinkedHashMap\n        Map<MavenModule,MavenBuild> r = new LinkedHashMap<MavenModule,MavenBuild>(mods.size());\n\n        for (MavenModule m : mods) {\n            MavenBuild b = m.getNearestOldBuild(end - 1);\n            if(b!=null && b.getNumber()>=getNumber())\n                r.put(m,b);\n        }\n\n        return r;\n    }\n\n    public void registerAsProjectAction(MavenReporter reporter) {\n        if(projectActionReporters==null)\n            projectActionReporters = new ArrayList<MavenReporter>();\n        projectActionReporters.add(reporter);\n    }\n\n    /**\n     * Finds {@link Action}s from all the module builds that belong to this\n     * {@link MavenModuleSetBuild}. One action per one {@link MavenModule},\n     * and newer ones take precedence over older ones.\n     */\n    public <T extends Action> List<T> findModuleBuildActions(Class<T> action) {\n        Collection<MavenModule> mods = getParent().getModules();\n        List<T> r = new ArrayList<T>(mods.size());\n\n        // identify the build number range. [start,end)\n        MavenModuleSetBuild nb = getNextBuild();\n        int end = nb!=null ? nb.getNumber()-1 : Integer.MAX_VALUE;\n\n        for (MavenModule m : mods) {\n            MavenBuild b = m.getNearestOldBuild(end);\n            while(b!=null && b.getNumber()>=number) {\n                T a = b.getAction(action);\n                if(a!=null) {\n                    r.add(a);\n                    break;\n                }\n                b = b.getPreviousBuild();\n            }\n        }\n\n        return r;\n    }\n\n    public void run() {\n        run(new RunnerImpl());\n        getProject().updateTransientActions();\n    }\n\n    @Override\n    public Fingerprint.RangeSet getDownstreamRelationship(AbstractProject that) {\n        Fingerprint.RangeSet rs = super.getDownstreamRelationship(that);\n        for(List<MavenBuild> builds : getModuleBuilds().values())\n            for (MavenBuild b : builds)\n                rs.add(b.getDownstreamRelationship(that));\n        return rs;\n    }\n\n    /**\n     * Called when a module build that corresponds to this module set build\n     * has completed.\n     */\n    /*package*/ void notifyModuleBuild(MavenBuild newBuild) {\n        try {\n            // update module set build number\n            getParent().updateNextBuildNumber();\n\n            // update actions\n            Map<MavenModule, List<MavenBuild>> moduleBuilds = getModuleBuilds();\n\n            // actions need to be replaced atomically especially\n            // given that two builds might complete simultaneously.\n            synchronized(this) {\n                boolean modified = false;\n\n                List<Action> actions = getActions();\n                Set<Class<? extends AggregatableAction>> individuals = new HashSet<Class<? extends AggregatableAction>>();\n                for (Action a : actions) {\n                    if(a instanceof MavenAggregatedReport) {\n                        MavenAggregatedReport mar = (MavenAggregatedReport) a;\n                        mar.update(moduleBuilds,newBuild);\n                        individuals.add(mar.getIndividualActionType());\n                        modified = true;\n                    }\n                }\n\n                // see if the new build has any new aggregatable action that we haven't seen.\n                for (AggregatableAction aa : newBuild.getActions(AggregatableAction.class)) {\n                    if(individuals.add(aa.getClass())) {\n                        // new AggregatableAction\n                        MavenAggregatedReport mar = aa.createAggregatedAction(this, moduleBuilds);\n                        mar.update(moduleBuilds,newBuild);\n                        actions.add(mar);\n                        modified = true;\n                    }\n                }\n\n                if(modified) {\n                    save();\n                    getProject().updateTransientActions();\n                }\n            }\n\n            // symlink to this module build\n            String moduleFsName = newBuild.getProject().getModuleName().toFileSystemName();\n            Util.createSymlink(getRootDir(),\n                    \"../../modules/\"+ moduleFsName +\"/builds/\"+newBuild.getId() /*ugly!*/,\n                    moduleFsName, StreamTaskListener.NULL);\n        } catch (IOException e) {\n            LOGGER.log(Level.WARNING,\"Failed to update \"+this,e);\n        } catch (InterruptedException e) {\n            LOGGER.log(Level.WARNING,\"Failed to update \"+this,e);\n        }\n    }\n\n    /**\n     * The sole job of the {@link MavenModuleSet} build is to update SCM\n     * and triggers module builds.\n     */\n    private class RunnerImpl extends AbstractRunner {\n        private Map<ModuleName,MavenBuild.ProxyImpl2> proxies;\n\n        protected Result doRun(final BuildListener listener) throws Exception {\n            PrintStream logger = listener.getLogger();\n            try {\n                EnvVars envVars = getEnvironment(listener);\n                MavenInstallation mvn = project.getMaven();\n                if(mvn==null)\n                    throw new AbortException(\"A Maven installation needs to be available for this project to be built.\\n\"+\n                                             \"Either your server has no Maven installations defined, or the requested Maven version does not exist.\");\n                \n                mvn = mvn.forEnvironment(envVars).forNode(Computer.currentComputer().getNode(), listener);\n\n                if(!project.isAggregatorStyleBuild()) {\n                    parsePoms(listener, logger, envVars, mvn);\n                    // start module builds\n                    logger.println(\"Triggering \"+project.getRootModule().getModuleName());\n                    project.getRootModule().scheduleBuild(new UpstreamCause((Run<?,?>)MavenModuleSetBuild.this));\n                } else {\n                    // do builds here\n                    try {\n                        List<BuildWrapper> wrappers = new ArrayList<BuildWrapper>();\n                        for (BuildWrapper w : project.getBuildWrappersList())\n                            wrappers.add(w);\n                        ParametersAction parameters = getAction(ParametersAction.class);\n                        if (parameters != null)\n                            parameters.createBuildWrappers(MavenModuleSetBuild.this,wrappers);\n\n                        for( BuildWrapper w : wrappers) {\n                            Environment e = w.setUp(MavenModuleSetBuild.this, launcher, listener);\n                            if(e==null)\n                                return Result.FAILURE;\n                            buildEnvironments.add(e);\n                            e.buildEnvVars(envVars); // #3502: too late for getEnvironment to do this\n                        }\n\n                        if(!preBuild(listener, project.getPublishers()))\n                            return Result.FAILURE;\n\n                        parsePoms(listener, logger, envVars, mvn); // #5428 : do pre-build *before* parsing pom\n                        SplittableBuildListener slistener = new SplittableBuildListener(listener);\n                        proxies = new HashMap<ModuleName, ProxyImpl2>();\n                        List<String> changedModules = new ArrayList<String>();\n\n                        for (MavenModule m : project.sortedActiveModules) {\n                            MavenBuild mb = m.newBuild();\n                            \n                            // Check if incrementalBuild is selected and that there are changes -\n                            // we act as if incrementalBuild is not set if there are no changes.\n                            if (!MavenModuleSetBuild.this.getChangeSet().isEmptySet()\n                                && project.isIncrementalBuild()) {\n\t\t\t\t// If there are changes for this module, add it.\n\t\t\t\t// Also add it if we've never seen this module before,\n\t\t\t\t// or if the previous build of this module failed or was unstable.\n                                if ((mb.getPreviousBuiltBuild() == null) ||\n                                    (!getChangeSetFor(m).isEmpty()) \n                                    || (mb.getPreviousBuiltBuild().getResult().isWorseThan(Result.SUCCESS))) {\n                                    changedModules.add(m.getModuleName().toString());\n                                }\n                            }\n\n                            mb.setWorkspace(getModuleRoot().child(m.getRelativePath()));\n                            proxies.put(m.getModuleName(), mb.new ProxyImpl2(MavenModuleSetBuild.this,slistener));\n                        }\n\n                        // run the complete build here\n\n                        // figure out the root POM location.\n                        // choice of module root ('ws' in this method) is somewhat arbitrary\n                        // when multiple CVS/SVN modules are checked out, so also check\n                        // the path against the workspace root if that seems like what the user meant (see issue #1293)\n                        String rootPOM = project.getRootPOM();\n                        FilePath pom = getModuleRoot().child(rootPOM);\n                        FilePath parentLoc = getWorkspace().child(rootPOM);\n                        if(!pom.exists() && parentLoc.exists())\n                            pom = parentLoc;\n\n                        ProcessCache.MavenProcess process = MavenBuild.mavenProcessCache.get(launcher.getChannel(), slistener,\n                            new MavenProcessFactory(project,launcher,envVars,pom.getParent()));\n\n                        ArgumentListBuilder margs = new ArgumentListBuilder().add(\"-B\").add(\"-f\", pom.getRemote());\n                        if(project.usesPrivateRepository())\n                            margs.add(\"-Dmaven.repo.local=\"+getWorkspace().child(\".repository\"));\n                        // If incrementalBuild is set, and we're on Maven 2.1 or later, *and* there's at least one module\n                        // listed in changedModules, do the Maven incremental build commands - if there are no changed modules,\n                        // We're building everything anyway.\n                        if (project.isIncrementalBuild() && mvn.isMaven2_1(launcher) && !changedModules.isEmpty()) {\n                            margs.add(\"-amd\");\n                            margs.add(\"-pl\", Util.join(changedModules, \",\"));\n                        }\n\n                        if (project.getAlternateSettings() != null) {\n                            margs.add(\"-s\").add(getWorkspace().child(project.getAlternateSettings()));\n                        }\n\n                        margs.addTokenized(envVars.expand(project.getGoals()));\n\n                        Builder builder = new Builder(slistener, proxies, project.sortedActiveModules, margs.toList(), envVars);\n                        MavenProbeAction mpa=null;\n                        try {\n                            mpa = new MavenProbeAction(project,process.channel);\n                            addAction(mpa);\n                            return process.call(builder);\n                        } finally {\n                            builder.end(launcher);\n                            getActions().remove(mpa);\n                            process.discard();\n                        }\n                    } finally {\n                        // tear down in reverse order\n                        boolean failed=false;\n                        for( int i=buildEnvironments.size()-1; i>=0; i-- ) {\n                            if (!buildEnvironments.get(i).tearDown(MavenModuleSetBuild.this,listener)) {\n                                failed=true;\n                            }                    \n                        }\n                        buildEnvironments = null;\n                        // WARNING The return in the finally clause will trump any return before\n                        if (failed) return Result.FAILURE;\n                    }\n                }\n                \n                return null;\n            } catch (AbortException e) {\n                if(e.getMessage()!=null)\n                    listener.error(e.getMessage());\n                return Result.FAILURE;\n            } catch (InterruptedIOException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedIOException\"));\n                return Result.ABORTED;\n            } catch (InterruptedException e) {\n                e.printStackTrace(listener.error(\"Aborted Maven execution for InterruptedException\"));\n                return Result.ABORTED;\n            } catch (IOException e) {\n                e.printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                return Result.FAILURE;\n            } catch (RunnerAbortedException e) {\n                return Result.FAILURE;\n            } catch (RuntimeException e) {\n                // bug in the code.\n                e.printStackTrace(listener.error(\"Processing failed due to a bug in the code. Please report this to users@hudson.dev.java.net\"));\n                logger.println(\"project=\"+project);\n                logger.println(\"project.getModules()=\"+project.getModules());\n                logger.println(\"project.getRootModule()=\"+project.getRootModule());\n                throw e;\n            }\n        }\n\n        private void parsePoms(BuildListener listener, PrintStream logger, EnvVars envVars, MavenInstallation mvn) throws IOException, InterruptedException {\n            logger.println(\"Parsing POMs\");\n\n            List<PomInfo> poms;\n            try {\n                poms = getModuleRoot().act(new PomParser(listener, mvn, project));\n            } catch (IOException e) {\n                if (e.getCause() instanceof AbortException)\n                    throw (AbortException) e.getCause();\n                throw e;\n            } catch (MavenExecutionException e) {\n                // Maven failed to parse POM\n                e.getCause().printStackTrace(listener.error(Messages.MavenModuleSetBuild_FailedToParsePom()));\n                throw new AbortException();\n            }\n\n            // update the module list\n            Map<ModuleName,MavenModule> modules = project.modules;\n            synchronized(modules) {\n                Map<ModuleName,MavenModule> old = new HashMap<ModuleName, MavenModule>(modules);\n                List<MavenModule> sortedModules = new ArrayList<MavenModule>();\n\n                modules.clear();\n                if(debug)\n                    logger.println(\"Root POM is \"+poms.get(0).name);\n                project.reconfigure(poms.get(0));\n                for (PomInfo pom : poms) {\n                    MavenModule mm = old.get(pom.name);\n                    if(mm!=null) {// found an existing matching module\n                        if(debug)\n                            logger.println(\"Reconfiguring \"+mm);\n                        mm.reconfigure(pom);\n                        modules.put(pom.name,mm);\n                    } else {// this looks like a new module\n                        logger.println(Messages.MavenModuleSetBuild_DiscoveredModule(pom.name,pom.displayName));\n                        mm = new MavenModule(project,pom,getNumber());\n                        modules.put(mm.getModuleName(),mm);\n                    }\n                    sortedModules.add(mm);\n                    mm.save();\n                }\n                // at this point the list contains all the live modules\n                project.sortedActiveModules = sortedModules;\n\n                // remaining modules are no longer active.\n                old.keySet().removeAll(modules.keySet());\n                for (MavenModule om : old.values()) {\n                    if(debug)\n                        logger.println(\"Disabling \"+om);\n                    om.makeDisabled(true);\n                }\n                modules.putAll(old);\n            }\n\n            // we might have added new modules\n            Hudson.getInstance().rebuildDependencyGraph();\n\n            // module builds must start with this build's number\n            for (MavenModule m : modules.values())\n                m.updateNextBuildNumber(getNumber());\n        }\n\n        protected void post2(BuildListener listener) throws Exception {\n            // asynchronous executions from the build might have left some unsaved state,\n            // so just to be safe, save them all.\n            for (MavenBuild b : getModuleLastBuilds().values())\n                b.save();\n\n            // at this point the result is all set, so ignore the return value\n            if (!performAllBuildSteps(listener, project.getPublishers(), true))\n                setResult(FAILURE);\n            if (!performAllBuildSteps(listener, project.getProperties(), true))\n                setResult(FAILURE);\n\n            // aggregate all module fingerprints to us,\n            // so that dependencies between module builds can be understood as\n            // dependencies between module set builds.\n            // TODO: we really want to implement this as a publisher,\n            // but we don't want to ask for a user configuration, nor should it\n            // show up in the persisted record.\n            MavenFingerprinter.aggregate(MavenModuleSetBuild.this);\n        }\n\n        @Override\n        public void cleanUp(BuildListener listener) throws Exception {\n            if(project.isAggregatorStyleBuild()) {\n                // schedule downstream builds. for non aggregator style builds,\n                // this is done by each module\n                scheduleDownstreamBuilds(listener);\n            }\n\n            MavenMailer mailer = project.getReporters().get(MavenMailer.class);\n            if (mailer != null) {\n                new MailSender(mailer.recipients,\n                        mailer.dontNotifyEveryUnstableBuild,\n                        mailer.sendToIndividuals).execute(MavenModuleSetBuild.this, listener);\n            }\n\n            // too late to set the build result at this point. so ignore failures.\n            performAllBuildSteps(listener, project.getPublishers(), false);\n            performAllBuildSteps(listener, project.getProperties(), false);\n        }\n\n    }\n\n    /**\n     * Runs Maven and builds the project.\n     *\n     * This is only used for\n     * {@link MavenModuleSet#isAggregatorStyleBuild() the aggregator style build}.\n     */\n    private static final class Builder extends MavenBuilder {\n        private final Map<ModuleName,MavenBuildProxy2> proxies;\n        private final Map<ModuleName,List<MavenReporter>> reporters = new HashMap<ModuleName,List<MavenReporter>>();\n        private final Map<ModuleName,List<ExecutedMojo>> executedMojos = new HashMap<ModuleName,List<ExecutedMojo>>();\n        private long mojoStartTime;\n\n        private MavenBuildProxy2 lastProxy;\n\n        /**\n         * Kept so that we can finalize them in the end method.\n         */\n        private final transient Map<ModuleName,ProxyImpl2> sourceProxies;\n\n        public Builder(BuildListener listener,Map<ModuleName,ProxyImpl2> proxies, Collection<MavenModule> modules, List<String> goals, Map<String,String> systemProps) {\n            super(listener,goals,systemProps);\n            this.sourceProxies = proxies;\n            this.proxies = new HashMap<ModuleName, MavenBuildProxy2>(proxies);\n            for (Entry<ModuleName,MavenBuildProxy2> e : this.proxies.entrySet())\n                e.setValue(new FilterImpl(e.getValue()));\n\n            for (MavenModule m : modules)\n                reporters.put(m.getModuleName(),m.createReporters());\n        }\n\n        private class FilterImpl extends MavenBuildProxy2.Filter<MavenBuildProxy2> implements Serializable {\n            public FilterImpl(MavenBuildProxy2 core) {\n                super(core);\n            }\n\n            @Override\n            public void executeAsync(final BuildCallable<?,?> program) throws IOException {\n                futures.add(Channel.current().callAsync(new AsyncInvoker(core,program)));\n            }\n\n            private static final long serialVersionUID = 1L;\n        }\n\n        /**\n         * Invoked after the maven has finished running, and in the master, not in the maven process.\n         */\n        void end(Launcher launcher) throws IOException, InterruptedException {\n            for (Map.Entry<ModuleName,ProxyImpl2> e : sourceProxies.entrySet()) {\n                ProxyImpl2 p = e.getValue();\n                for (MavenReporter r : reporters.get(e.getKey())) {\n                    // we'd love to do this when the module build ends, but doing so requires\n                    // we know how many task segments are in the current build.\n                    r.end(p.owner(),launcher,listener);\n                    p.appendLastLog();\n                }\n                p.close();\n            }\n        }\n\n        @Override\n        public Result call() throws IOException {\n            try {\n                return super.call();\n            } finally {\n                if(lastProxy!=null)\n                    lastProxy.appendLastLog();\n            }\n        }\n\n        void preBuild(MavenSession session, ReactorManager rm, EventDispatcher dispatcher) throws BuildFailureException, LifecycleExecutionException, IOException, InterruptedException {\n            // TODO\n        }\n\n        void postBuild(MavenSession session, ReactorManager rm, EventDispatcher dispatcher) throws BuildFailureException, LifecycleExecutionException, IOException, InterruptedException {\n            // TODO\n        }\n\n        void preModule(MavenProject project) throws InterruptedException, IOException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy2 proxy = proxies.get(name);\n            listener.getLogger().flush();   // make sure the data until here are all written\n            proxy.start();\n            for (MavenReporter r : reporters.get(name))\n                if(!r.preBuild(proxy,project,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n        }\n\n        void postModule(MavenProject project) throws InterruptedException, IOException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy2 proxy = proxies.get(name);\n            List<MavenReporter> rs = reporters.get(name);\n            if(rs==null) { // probe for issue #906\n                throw new AssertionError(\"reporters.get(\"+name+\")==null. reporters=\"+reporters+\" proxies=\"+proxies);\n            }\n            for (MavenReporter r : rs)\n                if(!r.postBuild(proxy,project,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n            proxy.setExecutedMojos(executedMojos.get(name));\n            listener.getLogger().flush();   // make sure the data until here are all written\n            proxy.end();\n            lastProxy = proxy;\n        }\n\n        void preExecute(MavenProject project, MojoInfo mojoInfo) throws IOException, InterruptedException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy proxy = proxies.get(name);\n            for (MavenReporter r : reporters.get(name))\n                if(!r.preExecute(proxy,project,mojoInfo,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n\n            mojoStartTime = System.currentTimeMillis();\n        }\n\n        void postExecute(MavenProject project, MojoInfo mojoInfo, Exception exception) throws IOException, InterruptedException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n\n            List<ExecutedMojo> mojoList = executedMojos.get(name);\n            if(mojoList==null)\n                executedMojos.put(name,mojoList=new ArrayList<ExecutedMojo>());\n            mojoList.add(new ExecutedMojo(mojoInfo,System.currentTimeMillis()-mojoStartTime));\n\n            MavenBuildProxy2 proxy = proxies.get(name);\n            for (MavenReporter r : reporters.get(name))\n                if(!r.postExecute(proxy,project,mojoInfo,listener,exception))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n            if(exception!=null)\n                proxy.setResult(Result.FAILURE);\n        }\n\n        void onReportGenerated(MavenProject project, MavenReportInfo report) throws IOException, InterruptedException, hudson.maven.agent.AbortException {\n            ModuleName name = new ModuleName(project);\n            MavenBuildProxy proxy = proxies.get(name);\n            for (MavenReporter r : reporters.get(name))\n                if(!r.reportGenerated(proxy,project,report,listener))\n                    throw new hudson.maven.agent.AbortException(r+\" failed\");\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Used to tunnel exception from Maven through remoting.\n     */\n    private static final class MavenExecutionException extends RuntimeException {\n        private MavenExecutionException(Exception cause) {\n            super(cause);\n        }\n\n        @Override\n        public Exception getCause() {\n            return (Exception)super.getCause();\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    /**\n     * Executed on the slave to parse POM and extract information into {@link PomInfo},\n     * which will be then brought back to the master.\n     */\n    private static final class PomParser implements FileCallable<List<PomInfo>> {\n        private final BuildListener listener;\n        private final String rootPOM;\n        /**\n         * Capture the value of the static field so that the debug flag\n         * takes an effect even when {@link PomParser} runs in a slave.\n         */\n        private final boolean verbose = debug;\n        private final MavenInstallation mavenHome;\n        private final String profiles;\n        private final Properties properties;\n        private final String privateRepository;\n        private final String alternateSettings;\n        private final boolean nonRecursive;\n        // We're called against the module root, not the workspace, which can cause a lot of confusion.\n        private final String workspaceProper;\n        \n        public PomParser(BuildListener listener, MavenInstallation mavenHome, MavenModuleSet project) {\n            // project cannot be shipped to the remote JVM, so all the relevant properties need to be captured now.\n            this.listener = listener;\n            this.mavenHome = mavenHome;\n            this.rootPOM = project.getRootPOM();\n            this.profiles = project.getProfiles();\n            this.properties = project.getMavenProperties();\n            this.nonRecursive = project.isNonRecursive();\n            this.workspaceProper = project.getLastBuild().getWorkspace().getRemote();\n            if (project.usesPrivateRepository()) {\n                this.privateRepository = project.getLastBuild().getWorkspace().child(\".repository\").getRemote();\n            } else {\n                this.privateRepository = null;\n            }\n            this.alternateSettings = project.getAlternateSettings();\n        }\n\n        /**\n         * Computes the path of {@link #rootPOM}.\n         *\n         * Returns \"abc\" if rootPOM=\"abc/pom.xml\"\n         * If rootPOM=\"pom.xml\", this method returns \"\".\n         */\n        private String getRootPath() {\n            int idx = Math.max(rootPOM.lastIndexOf('/'), rootPOM.lastIndexOf('\\\\'));\n            if(idx==-1) return \"\";\n            return rootPOM.substring(0,idx);\n        }\n\n        public List<PomInfo> invoke(File ws, VirtualChannel channel) throws IOException {\n            File pom = new File(ws,rootPOM);\n\n            PrintStream logger = listener.getLogger();\n\n            // choice of module root ('ws' in this method) is somewhat arbitrary\n            // when multiple CVS/SVN modules are checked out, so also check\n            // the path against the workspace root if that seems like what the user meant (see issue #1293)\n            File parentLoc = new File(ws.getParentFile(),rootPOM);\n            if(!pom.exists() && parentLoc.exists())\n                pom = parentLoc;\n\n            if(!pom.exists())\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchPOMFile(pom));\n\n            if(verbose)\n                logger.println(\"Parsing \"\n\t\t\t       + (nonRecursive ? \"non-recursively \" : \"recursively \")\n\t\t\t       + pom);\n\t    \n            File settingsLoc = (alternateSettings == null) ? null \n                : new File(workspaceProper, alternateSettings);\n\n            if ((settingsLoc != null) && (!settingsLoc.exists())) {\n                throw new AbortException(Messages.MavenModuleSetBuild_NoSuchAlternateSettings(settingsLoc.getAbsolutePath()));\n            }\n\n            try {\n                MavenEmbedder embedder = MavenUtil.\n                        createEmbedder(listener, mavenHome.getHomeDir(), profiles,\n                                       properties, privateRepository, settingsLoc);\n                MavenProject mp = embedder.readProject(pom);\n                Map<MavenProject,String> relPath = new HashMap<MavenProject,String>();\n                MavenUtil.resolveModules(embedder,mp,getRootPath(),relPath,listener,nonRecursive);\n\n                if(verbose) {\n                    for (Entry<MavenProject, String> e : relPath.entrySet())\n                        logger.printf(\"Discovered %s at %s\\n\",e.getKey().getId(),e.getValue());\n                }\n\n                List<PomInfo> infos = new ArrayList<PomInfo>();\n                toPomInfo(mp,null,relPath,infos);\n\n                for (PomInfo pi : infos)\n                    pi.cutCycle();\n\n                embedder.stop();\n                return infos;\n            } catch (MavenEmbedderException e) {\n                throw new MavenExecutionException(e);\n            } catch (ProjectBuildingException e) {\n                throw new MavenExecutionException(e);\n            }\n        }\n\n        private void toPomInfo(MavenProject mp, PomInfo parent, Map<MavenProject,String> relPath, List<PomInfo> infos) {\n            PomInfo pi = new PomInfo(mp, parent, relPath.get(mp));\n            infos.add(pi);\n            for (MavenProject child : (List<MavenProject>)mp.getCollectedProjects())\n                toPomInfo(child,pi,relPath,infos);\n        }\n\n        private static final long serialVersionUID = 1L;\n    }\n\n    private static final Logger LOGGER = Logger.getLogger(MavenModuleSetBuild.class.getName());\n\n    /**\n     * Extra verbose debug switch.\n     */\n    public static boolean debug = false;\n    \n    @Override\n    public MavenModuleSet getParent() {// don't know why, but javac wants this\n        return super.getParent();\n    }\n}\n", " TODO Auto-generated method stub\r\n\t\tPurse purse = new Purse();\r\n\t\tpurse.addCoin(\"Dime\");\r\n\t\tpurse.addCoin(\"Quarter\");\r\n\t\tpurse.addCoin(\"Penny\");\r\n\t\tpurse.addCoin(\"Nickel\");\r\n\t\tPurse pursec = new Purse();\r\n\t\tpursec.addCoin(\"Dime\");\r\n\t\tpursec.addCoin(\"Quarter\");\r\n\t\tpursec.addCoin(\"Penny\");\r\n\t\tpursec.addCoin(\"Nickel\");\r\n\t\tSystem.out.println(pursec.sameContents(purse));\r\n\t\tSystem.out.println(pursec.sameCoins(purse));\t\r\n\t\tSystem.out.println(purse);\r\n\t\tpurse.reverse();\r\n\t\tSystem.out.println(pursec.sameCoins(purse));\r\n\t\tSystem.out.println(pursec.sameContents(purse));\r\n\t\tSystem.out.println(purse);\r\n\t\tPurse purseb = new Purse();\r\n\t\tpurseb.addCoin(\"Half-Dollar\");\r\n\t\tpurseb.addCoin(\"Dollar Coin\");\r\n\t\tSystem.out.println(pursec.sameCoins(purseb));\r\n\t\tSystem.out.println(purseb);\r\n\t\tpurse.transfer(purseb);\r\n\t\tSystem.out.println(purse);\r\n\t\tSystem.out.println(purseb);\r\n\t}\r\n\r\n}\r\n", " * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n * \n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n * \n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\npackage hudson.security;\n\nimport org.acegisecurity.ui.rememberme.TokenBasedRememberMeServices;\nimport org.acegisecurity.userdetails.UserDetails;\nimport org.acegisecurity.Authentication;\nimport org.apache.commons.codec.digest.DigestUtils;\n\n/**\n * {@link TokenBasedRememberMeServices} with modification so as not to rely\n * on the user password being available.\n *\n * <p>\n * This allows remember-me to work with security realms where the password\n * is never available in clear text.\n *\n * @author Kohsuke Kawaguchi\n */\npublic class TokenBasedRememberMeServices2 extends TokenBasedRememberMeServices {\n    @Override\n    protected String makeTokenSignature(long tokenExpiryTime, UserDetails userDetails) {\n        String expectedTokenSignature = DigestUtils.md5Hex(userDetails.getUsername() + \":\" + tokenExpiryTime + \":\"\n                + \"N/A\" + \":\" + getKey());\n        return expectedTokenSignature;\n    }\n\n    @Override\n    protected String retrievePassword(Authentication successfulAuthentication) {\n        return \"N/A\";\n    }\n}\n", "ull text.\n *\n * Copyright (c) 2014, Gluu\n */\n\npackage org.xdi.oxauth.model.error;\n\nimport java.util.List;\n\nimport javax.xml.bind.annotation.XmlAccessType;\nimport javax.xml.bind.annotation.XmlAccessorType;\nimport javax.xml.bind.annotation.XmlElement;\nimport javax.xml.bind.annotation.XmlElementWrapper;\nimport javax.xml.bind.annotation.XmlRootElement;\n\n/**\n * @author Yuriy Zabrovarnyy\n * @version 0.9, 26/12/2012\n */\n@XmlRootElement(name = \"errors\")\n@XmlAccessorType(XmlAccessType.FIELD)\npublic class ErrorMessages {\n\n    @XmlElementWrapper(name = \"authorize\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> authorize;\n    @XmlElementWrapper(name = \"client-info\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> clientInfo;\n    @XmlElementWrapper(name = \"end-session\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> endSession;\n    @XmlElementWrapper(name = \"federation\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> federation;\n    @XmlElementWrapper(name = \"register\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> register;\n    @XmlElementWrapper(name = \"token\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> token;\n    @XmlElementWrapper(name = \"uma\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> uma;\n    @XmlElementWrapper(name = \"user-info\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> userInfo;\n    @XmlElementWrapper(name = \"validate-token\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> validateToken;\n\n    @XmlElementWrapper(name = \"fido\")\n    @XmlElement(name = \"error\")\n    private List<ErrorMessage> fido;\n\n    public List<ErrorMessage> getAuthorize() {\n        return authorize;\n    }\n\n    public void setAuthorize(List<ErrorMessage> p_authorize) {\n        authorize = p_authorize;\n    }\n\n    public List<ErrorMessage> getClientInfo() {\n        return clientInfo;\n    }\n\n    public void setClientInfo(List<ErrorMessage> p_clientInfo) {\n        clientInfo = p_clientInfo;\n    }\n\n    public List<ErrorMessage> getEndSession() {\n        return endSession;\n    }\n\n    public void setEndSession(List<ErrorMessage> p_endSession) {\n        endSession = p_endSession;\n    }\n\n    public List<ErrorMessage> getFederation() {\n        return federation;\n    }\n\n    public void setFederation(List<ErrorMessage> p_federation) {\n        federation = p_federation;\n    }\n\n    public List<ErrorMessage> getRegister() {\n        return register;\n    }\n\n    public void setRegister(List<ErrorMessage> p_register) {\n        register = p_register;\n    }\n\n    public List<ErrorMessage> getToken() {\n        return token;\n    }\n\n    public void setToken(List<ErrorMessage> p_token) {\n        token = p_token;\n    }\n\n    public List<ErrorMessage> getUma() {\n        return uma;\n    }\n\n    public void setUma(List<ErrorMessage> p_uma) {\n        uma = p_uma;\n    }\n\n    public List<ErrorMessage> getUserInfo() {\n        return userInfo;\n    }\n\n    public void setUserInfo(List<ErrorMessage> p_userInfo) {\n        userInfo = p_userInfo;\n    }\n\n    public List<ErrorMessage> getValidateToken() {\n        return validateToken;\n    }\n\n    public void setValidateToken(List<ErrorMessage> p_validateToken) {\n        validateToken = p_validateToken;\n    }\n\n\tpublic List<ErrorMessage> getFido() {\n\t\treturn fido;\n\t}\n\n\tpublic void setFido(List<ErrorMessage> fido) {\n\t\tthis.fido = fido;\n\t}\n\n}", "rt java.util.Map;\nimport java.util.Set;\n\nimport org.apache.hadoop.conf.Configuration;\nimport org.apache.hadoop.conf.Configured;\nimport org.apache.hadoop.fs.Path;\nimport org.apache.hadoop.mapreduce.Job;\nimport org.apache.hadoop.util.Tool;\nimport org.apache.hadoop.util.ToolRunner;\n\nimport edu.jhu.thrax.hadoop.features.annotation.AnnotationFeature;\nimport edu.jhu.thrax.hadoop.features.annotation.AnnotationFeatureFactory;\nimport edu.jhu.thrax.hadoop.features.annotation.AnnotationFeatureJob;\nimport edu.jhu.thrax.hadoop.features.mapred.MapReduceFeature;\nimport edu.jhu.thrax.hadoop.features.mapred.MapReduceFeatureFactory;\nimport edu.jhu.thrax.hadoop.features.pivot.PivotedFeature;\nimport edu.jhu.thrax.hadoop.features.pivot.PivotedFeatureFactory;\nimport edu.jhu.thrax.hadoop.jobs.DistributionalContextExtractionJob;\nimport edu.jhu.thrax.hadoop.jobs.DistributionalContextSortingJob;\nimport edu.jhu.thrax.hadoop.jobs.ExtractionJob;\nimport edu.jhu.thrax.hadoop.jobs.FeatureCollectionJob;\nimport edu.jhu.thrax.hadoop.jobs.JobState;\nimport edu.jhu.thrax.hadoop.jobs.OutputJob;\nimport edu.jhu.thrax.hadoop.jobs.ParaphraseAggregationJob;\nimport edu.jhu.thrax.hadoop.jobs.ParaphrasePivotingJob;\nimport edu.jhu.thrax.hadoop.jobs.Scheduler;\nimport edu.jhu.thrax.hadoop.jobs.SchedulerException;\nimport edu.jhu.thrax.hadoop.jobs.ThraxJob;\nimport edu.jhu.thrax.hadoop.jobs.VocabularyJob;\nimport edu.jhu.thrax.util.BackwardsCompatibility;\nimport edu.jhu.thrax.util.ConfFileParser;\n\npublic class Thrax extends Configured implements Tool {\n  private Scheduler scheduler;\n  private Configuration conf;\n\n  public synchronized int run(String[] argv) throws Exception {\n    if (argv.length < 1) {\n      System.err.println(\"usage: Thrax <conf file> [output path]\");\n      return 1;\n    }\n    // do some setup of configuration\n    conf = getConf();\n    Map<String, String> options = ConfFileParser.parse(argv[0]);\n    for (String opt : options.keySet())\n      conf.set(\"thrax.\" + opt, options.get(opt));\n    String date = (new Date()).toString().replaceAll(\"\\\\s+\", \"_\").replaceAll(\":\", \"_\");\n\n    String workDir = \"thrax_run_\" + date + Path.SEPARATOR;\n\n    if (argv.length > 1) {\n      workDir = argv[1];\n      if (!workDir.endsWith(Path.SEPARATOR)) workDir += Path.SEPARATOR;\n    }\n\n    conf.set(\"thrax.work-dir\", workDir);\n    conf.set(\"thrax.outputPath\", workDir + \"final\");\n\n    if (options.containsKey(\"timeout\")) {\n      conf.setInt(\"mapreduce.task.timeout\", Integer.parseInt(options.get(\"timeout\")));\n      conf.setInt(\"mapred.task.timeout\", Integer.parseInt(options.get(\"timeout\")));\n    }\n\n    scheduleJobs();\n\n    do {\n      for (Class<? extends ThraxJob> c : scheduler.getClassesByState(JobState.READY)) {\n        scheduler.setState(c, JobState.RUNNING);\n        (new Thread(new ThraxJobWorker(this, c, conf))).start();\n      }\n      wait();\n    } while (scheduler.notFinished());\n    System.err.print(scheduler);\n    if (scheduler.getClassesByState(JobState.SUCCESS).size() == scheduler.numJobs()) {\n      System.err.println(\"Work directory was \" + workDir);\n      System.err.println(\"To retrieve grammar:\");\n      System.err.println(\"hadoop fs -getmerge \" + conf.get(\"thrax.outputPath\", \"\")\n          + \" <destination>\");\n    }\n    return 0;\n  }\n\n  // Schedule all the jobs required for grammar extraction. We\n  // currently distinguish three modes: translation grammar extraction,\n  // paraphrase grammar extraction, and collection of distributional signatures.\n  private synchronized void scheduleJobs() throws SchedulerException {\n    scheduler = new Scheduler(conf);\n\n    String type = conf.get(\"thrax.type\", \"translation\");\n    String features = BackwardsCompatibility.equivalent(conf.get(\"thrax.features\", \"\"));\n\n    System.err.println(\"Running in mode: \" + type);\n\n    scheduler.schedule(VocabularyJob.class);\n\n    // Translation grammar mode.\n    if (\"translation\".equals(type)) {\n      // Schedule rule extraction job.\n      scheduler.schedule(ExtractionJob.class);\n      // Create feature map-reduces.\n      for (MapReduceFeature f : MapReduceFeatureFactory.getAll(features)) {\n        scheduler.schedule(f.getClass());\n        OutputJob.addPrerequisite(f.getClass());\n      }\n      // Set up annotation-level feature & prerequisites.\n      List<AnnotationFeature> annotation_features = AnnotationFeatureFactory.getAll(features);\n      for (AnnotationFeature f : annotation_features)\n        AnnotationFeatureJob.addPrerequisites(f.getPrerequisites());\n      if (!annotation_features.isEmpty()) {\n        scheduler.schedule(AnnotationFeatureJob.class);\n        OutputJob.addPrerequisite(AnnotationFeatureJob.class);\n      }\n      scheduler.schedule(OutputJob.class);\n\n      scheduler.percolate(OutputJob.class);\n\n      // Paraphrase grammar mode.\n    } else if (\"paraphrasing\".equals(type)) {\n      // Schedule rule extraction job.\n      scheduler.schedule(ExtractionJob.class);\n      // Collect the translation grammar features required to compute\n      // the requested paraphrasing features.\n      Set<String> prereq_features = new HashSet<String>();\n      List<PivotedFeature> pivoted_features = PivotedFeatureFactory.getAll(features);\n      for (PivotedFeature pf : pivoted_features) {\n        prereq_features.addAll(pf.getPrerequisites());\n      }\n      // Next, schedule translation features and register with feature\n      // collection job.\n      boolean annotation_features = false;\n      for (String f_name : prereq_features) {\n        MapReduceFeature mf = MapReduceFeatureFactory.get(f_name);\n        if (mf != null) {\n          scheduler.schedule(mf.getClass());\n          FeatureCollectionJob.addPrerequisite(mf.getClass());\n        } else {\n          AnnotationFeature af = AnnotationFeatureFactory.get(f_name);\n          if (af != null) {\n            AnnotationFeatureJob.addPrerequisites(af.getPrerequisites());\n            annotation_features = true;\n          }\n        }\n      }\n      if (annotation_features) {\n        scheduler.schedule(AnnotationFeatureJob.class);\n        FeatureCollectionJob.addPrerequisite(AnnotationFeatureJob.class);\n      }\n      scheduler.schedule(FeatureCollectionJob.class);\n      // Schedule pivoting and pivoted feature computation job.\n      scheduler.schedule(ParaphrasePivotingJob.class);\n      // Schedule aggregation and output job.\n      scheduler.schedule(ParaphraseAggregationJob.class);\n      scheduler.percolate(ParaphraseAggregationJob.class);\n    } else if (\"distributional\".equals(type)) {\n      scheduler.schedule(DistributionalContextExtractionJob.class);\n      scheduler.schedule(DistributionalContextSortingJob.class);\n      scheduler.percolate(DistributionalContextSortingJob.class);\n    } else {\n      System.err.println(\"Unknown grammar type. No jobs scheduled.\");\n    }\n  }\n\n  public static void main(String[] argv) throws Exception {\n    ToolRunner.run(null, new Thrax(), argv);\n    return;\n  }\n\n  protected synchronized void workerDone(Class<? extends ThraxJob> theClass, boolean success) {\n    try {\n      scheduler.setState(theClass, success ? JobState.SUCCESS : JobState.FAILED);\n    } catch (SchedulerException e) {\n      System.err.println(e.getMessage());\n    }\n    notify();\n    return;\n  }\n\n  public class ThraxJobWorker implements Runnable {\n    private Thrax thrax;\n    private Class<? extends ThraxJob> theClass;\n\n    public ThraxJobWorker(Thrax t, Class<? extends ThraxJob> c, Configuration conf) {\n      thrax = t;\n      theClass = c;\n    }\n\n    public void run() {\n      try {\n        ThraxJob thraxJob = theClass.newInstance();\n        Job job = thraxJob.getJob(conf);\n        job.waitForCompletion(false);\n        thrax.workerDone(theClass, job.isSuccessful());\n      } catch (Exception e) {\n        e.printStackTrace();\n        thrax.workerDone(theClass, false);\n      }\n      return;\n    }\n  }\n}\n", "s NonRetryableNakadiException extends NakadiException {\n\n  /**\n   * @param problem the Problem detail\n   */\n  public NonRetryableNakadiException(Problem problem) {\n    super(problem);\n  }\n\n  /**\n   * @param problem the Problem detail\n   * @param cause the cause\n   */\n  public NonRetryableNakadiException(Problem problem, Throwable cause) {\n    super(problem, cause);\n  }\n\n}\n", "or4j.parser.Email;\n\npublic class WarningsNotAllowed implements ValidationStrategy {\n    @Override\n    public Boolean isValid(String email, Email parser) {\n        return parser.getWarnings().size() == 0;\n    }\n}\n", "ted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in all\n * copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\npackage fredboat.util;\n\n/**\n * Created by napster on 25.09.17.\n */\npublic class Emojis {\n\n    public static final String EXCLAMATION = \"\u2757\";\n    public static final String OK = \"\u2705\";\n    public static final String BAD = \"\u274c\";\n    public static final String PENCIL = \"\ud83d\udcdd\";\n    public static final String DOOR = \"\ud83d\udeaa\";\n\n}\n", "al.artofsoul.ndihma.Artist.VizatoKatrorTexRot;\nimport static al.artofsoul.ndihma.Ora.Delta;\n\nimport java.util.ArrayList;\nimport java.util.concurrent.CopyOnWriteArrayList;\n\nimport org.newdawn.slick.opengl.Texture;\n\npublic abstract class Tower implements Entity {\n\t\n\tprivate float x, y, timeSinceLastShot, firingSpeed, angle;\n\tprivate int width, height, range, cost;\n\tpublic Armiku target;\n\tprivate Texture[] textures;\n\tprivate CopyOnWriteArrayList<Armiku> armiqt;\n\tprivate boolean targeted;\n\tpublic ArrayList<Projectile> projectiles;\n\tpublic TowerType type;\n\n\tpublic Tower(TowerType type, Pllaka filloPllaka, CopyOnWriteArrayList<Armiku> armiqt) {\n\t\tthis.type = type;\n\t\tthis.textures = type.textures;\n\t\tthis.range = type.range;\n\t\tthis.cost = type.cost;\n\t\tthis.x = filloPllaka.getX();\n\t\tthis.y = filloPllaka.getY();\n\t\tthis.width = filloPllaka.getWidth();\n\t\tthis.height = filloPllaka.getHeight();\n\t\tthis.armiqt = armiqt;\n\t\tthis.targeted = false;\n\t\tthis.timeSinceLastShot = 0f;\n\t\tthis.projectiles = new ArrayList<Projectile>();\n\t\tthis.firingSpeed = type.firingSpeed;\n\t\tthis.angle = 0f;\n\t}\n\t\n\tprivate Armiku acquireTarget() {\n\t\tArmiku closest = null;\n\t\t// arbitrary distance (Larger than map), to help with sorting Enemy distances\n\t\tfloat closestDistance = 1000;\n\t\t// Go thought each Enemy in 'Armiku' and return nearest one\n\t\tfor (Armiku e: armiqt) {\n\t\t\tif (isInRange(e) && findDistance(e) < closestDistance && e.isAlive()) {//e.getHiddenHealth() > 0) {\n\t\t\t\tclosestDistance = findDistance(e);\n\t\t\t\tclosest = e;\n\t\t\t}\n\t\t}\n\t\t// if an enemy exists an is returned, targeted == true\n\t\tif (closest != null)\n\t\t\ttargeted = true;\n\t\treturn closest;\n\t}\n\t\n\tprivate boolean isInRange(Armiku e) {\n\t\tfloat xDistance = Math.abs(e.getX() - x);\n\t\tfloat yDistance = Math.abs(e.getY() - y);\n\t\tif (xDistance < range && yDistance < range)\n\t\t\treturn true;\n\t\treturn false;\n\t}\n\t\n\tprivate float findDistance(Armiku e) {\n\t\tfloat xDistance = Math.abs(e.getX() - x);\n\t\tfloat yDistance = Math.abs(e.getY() - y);\n\t\treturn xDistance + yDistance;\n\t}\n\t\n\tprivate float calculateAngle () {\n\t\tdouble angleTemp = Math.atan2(target.getY() - y, target.getX() - x);\n\t\treturn (float) Math.toDegrees(angleTemp) - 90;\t\n\t}\n\t//abstarct method for 'shoot', must be override in subclasses\n\tpublic abstract void shoot (Armiku target);\n\t\n\tpublic void updateEnemyLists(CopyOnWriteArrayList<Armiku> newList) {\n\t\tarmiqt = newList;\n\t}\n\t\n\tpublic void update(){\n\t\tif (!targeted ) { //|| target.getHiddenHealth() < 0 ) {\n\t\t\ttarget = acquireTarget();\n\t\t} else {\n\t\t\tangle = calculateAngle();\n\t\t\tif (timeSinceLastShot > firingSpeed) {\n\t\t\t\tshoot(target);\n\t\t\t\ttimeSinceLastShot = 0;\n\t\t\t}\n\t\t}\n\t\tif (target == null || target.isAlive() == false)\n\t\t\ttargeted = false;\n\t\t\n\t\ttimeSinceLastShot += Delta();\n\t\t\n\t\tfor (Projectile p: projectiles)\n\t\t\tp.update();\n\t\t\n\t\tdraw();\n\t}\n\n\tpublic void draw() {\n\t\tVizatoKatrorTex(textures[0], x, y, width, height);\n\t\tif (textures.length > 1)\n\t\t\tfor(int i = 1; i < textures.length; i++)\n\t\t\t\tVizatoKatrorTexRot(textures[i], x, y, width, height, angle);\n\t}\n\tpublic float getX() {\n\t\treturn x;\n\t}\n\n\tpublic float getY() {\n\t\treturn y;\n\t}\n\n\tpublic int getWidth() {\n\t\treturn width;\n\t}\n\n\tpublic int getHeight() {\n\t\treturn height;\n\t}\n\n\tpublic void setX(float x) {\n\t\tthis.x = x;\t\n\t}\n\n\tpublic void setY(float y) {\n\t\tthis.y = y;\n\t}\n\n\tpublic void setWidth(int width) {\n\t\tthis.width = width;\t\n\t}\n\n\tpublic void setHeight(int height) {\n\t\tthis.height = height;\t\n\t}\n\t\n\tpublic Armiku getTarget() {\n\t\treturn target;\n\t}\n\tpublic int getCost() {\n\t\treturn cost;\n\t}\n}\n", "ls.XKOS;\nimport org.apache.jena.rdf.model.*;\nimport org.apache.jena.sparql.vocabulary.FOAF;\nimport org.apache.jena.vocabulary.DC;\nimport org.apache.jena.vocabulary.DCTerms;\nimport org.apache.jena.vocabulary.RDFS;\nimport org.apache.jena.vocabulary.SKOS;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.apache.poi.ss.usermodel.Row;\nimport org.apache.poi.ss.usermodel.Sheet;\nimport org.apache.poi.ss.usermodel.WorkbookFactory;\n\nimport java.io.FileInputStream;\nimport java.io.FileOutputStream;\nimport java.io.IOException;\nimport java.io.InputStream;\nimport java.util.Iterator;\n\n/**\n * The <code>SBIModelMaker</code> class creates and saves the Jena model corresponding to the Dutch SBI 2008 classification.\n * \n * @author Franck Cotton\n */\npublic class SBIModelMaker {\n\n\t/** Base local folder for reading and writing files */\n\tpublic static String LOCAL_FOLDER = \"src/main/resources/data/\";\n\n\t/** File name of the spreadsheet containing the SBI structure */\n\tpublic static String SBI_FILE = \"sbi 2008 versie 2016 engels.xls\";\n\n\t/** Base URI for the RDF resources belonging to NAICS */\n\tpublic final static String BASE_URI = \"http://stamina-project.org/codes/sbi2008/\";\n\n\t/** Base URI for the RDF resources belonging to the NACE-SBI correspondence */\n\tpublic final static String NACE_SBI_BASE_URI = \"http://stamina-project.org/codes/nacer2-sbi2008/\";\n\n\t/** Log4J2 logger */ // This must be before the configuration initialization\n\tprivate static final Logger logger = LogManager.getLogger(SBIModelMaker.class);\n\n\t/** Current Jena model */\n\tprivate Model model = null;\n\n\t/** RDF resource corresponding to the classification scheme */\n\tResource scheme = null;\n\n\t/** List of RDF resources corresponding to the classification levels */\n\tRDFList levelList = null;\n\n\t/**\n\t * Main method: reads the spreadsheet and creates the triplets in the model.\n\t */\n\tpublic static void main(String[] args) throws Exception {\n\n\t\tSBIModelMaker modelMaker = new SBIModelMaker();\n\t\t// Creation of the classification and its levels\n\t\tmodelMaker.initializeModel();\n\t\tmodelMaker.createClassificationAndLevels();\n\t\tmodelMaker.populateScheme();\n\t\tmodelMaker.writeModel(LOCAL_FOLDER + \"sbi2008.ttl\");\n\t\tmodelMaker.initializeModel();\n\t\tmodelMaker.createNACESBIHierarchy();\n\t\tmodelMaker.writeModel(LOCAL_FOLDER + \"nacer2-sbi2008.ttl\");\n\t}\n\n\t/**\n\t * Creates the statements corresponding to the classification items.\n\t * \n\t * @throws Exception In case of problem.\n\t */\n\tprivate void populateScheme() throws Exception {\n\n\t\t// Read the Excel file and create the classification items\n\t\tInputStream sourceFile = new FileInputStream(LOCAL_FOLDER + SBI_FILE);\n\t\tSheet items = WorkbookFactory.create(sourceFile).getSheetAt(0);\n\t\ttry {sourceFile.close();} catch(Exception ignored) {}\n\n\t\tIterator<Row> rows = items.rowIterator ();\n\t\twhile (rows.hasNext() && rows.next().getRowNum() < 2); // Skip the header lines\n\t\twhile (rows.hasNext()) {\n\t\t\tRow row = rows.next();\n\n\t\t\t// The code and label are in the first cell, separated by the first space\n\t\t\tString line = row.getCell(0, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK).toString();\n\n\t\t\t// Skip empty lines\n\t\t\tif (line == null) continue;\n\n\t\t\tint firstSpace = line.indexOf(' ');\n\t\t\tString itemCode = line.substring(0, firstSpace);\n\t\t\tString itemLabel = line.substring(firstSpace + 1).trim();\n\t\t\tint level = getItemLevelDepth(itemCode);\n\n\t\t\t// Create the resource representing the classification item (skos:Concept), with its code and label\n\t\t\tResource itemResource = model.createResource(getItemURI(itemCode), SKOS.Concept);\n\t\t\titemResource.addProperty(SKOS.notation, itemCode);\n\t\t\titemResource.addProperty(SKOS.prefLabel, itemLabel, \"en\");\n\n\t\t\t// Attach the item to its level\n\t\t\tResource levelResource = (Resource) levelList.get(level - 1);\n\t\t\tlevelResource.addProperty(SKOS.member, itemResource);\n\t\t\t\n\t\t\t// Attach the item to its classification\n\t\t\titemResource.addProperty(SKOS.inScheme, scheme);\n\t\t\tif (level == 1) {\n\t\t\t\tscheme.addProperty(SKOS.hasTopConcept, itemResource);\n\t\t\t\titemResource.addProperty(SKOS.topConceptOf, scheme);\t\t\t\t\n\t\t\t}\n\n\t\t\t// Attach the item to its parent item (for level > 1)\n\t\t\tif (level > 1) {\n\t\t\t\tResource parentResource = model.createResource(getItemURI(getParentCode(itemCode)));\n\t\t\t\tparentResource.addProperty(SKOS.narrower, itemResource);\n\t\t\t\titemResource.addProperty(SKOS.broader, parentResource);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Creates a model containing the resources representing the correspondence between NACE and SBI.\n\t */\n\tprivate void createNACESBIHierarchy() throws Exception {\n\n\t\t// Read the Excel file and create the classification items\n\t\tInputStream sourceFile = new FileInputStream(SBI_FILE);\n\t\tSheet items = WorkbookFactory.create(sourceFile).getSheetAt(0);\n\t\ttry {sourceFile.close();} catch(Exception ignored) {}\n\n\t\t// Creation of the correspondence table resource\n\t\tResource table = model.createResource(NACE_SBI_BASE_URI + \"correspondence\", XKOS.Correspondence);\n\t\ttable.addProperty(SKOS.definition, \"Correspondence table between NACE Rev. 2 and SBI 2008\");\n\t\ttable.addProperty(XKOS.compares, model.createResource(Names.getCSURI(\"NACE\", \"2\")));\n\t\ttable.addProperty(XKOS.compares, model.createResource(BASE_URI + \"sbi\"));\n\n\t\tIterator<Row> rows = items.rowIterator ();\n\t\twhile (rows.hasNext() && rows.next().getRowNum() < 2); // Skip the header lines\n\t\twhile (rows.hasNext()) {\n\t\t\tRow row = rows.next();\n\t\t\tString line = row.getCell(0, Row.MissingCellPolicy.CREATE_NULL_AS_BLANK).toString();\n\n\t\t\tif (line == null) continue;\n\t\t\tint firstSpace = line.indexOf(' ');\n\t\t\tString sbiCode = line.substring(0, firstSpace);\n\n\t\t\tString naceCode = sbiToNACECode(sbiCode);\n\n\t\t\tResource association = model.createResource(NACE_SBI_BASE_URI + \"association/\" + naceCode + \"-\" + sbiCode, XKOS.ConceptAssociation);\n\t\t\tassociation.addProperty(RDFS.label, \"NACE Rev.2 \" + naceCode + \" - SBI 2008 \" + sbiCode);\n\t\t\tResource naceItemResource = model.createResource(Names.getItemURI(naceCode, \"NACE\", \"2\"));\n\t\t\tResource sbiItemResource = model.createResource(getItemURI(sbiCode));\n\t\t\tassociation.addProperty(XKOS.sourceConcept, naceItemResource);\t\n\t\t\tassociation.addProperty(XKOS.targetConcept, sbiItemResource);\n\t\t\t// TODO When is it exact match?\n\t\t\tnaceItemResource.addProperty(SKOS.narrowMatch, sbiItemResource);\n\t\t\tsbiItemResource.addProperty(SKOS.broadMatch, naceItemResource);\n\t\t\ttable.addProperty(XKOS.madeOf, association);\n\t\t}\n\t}\n\n\t/**\n\t * Creates in the model the resources representing the classification and its levels.\n\t */\n \tpublic void createClassificationAndLevels() {\n\n\t\t// Create the resource representing the classification (skos:ConceptScheme)\n\t\tscheme = model.createResource(BASE_URI + \"sbi\", SKOS.ConceptScheme);\n\t\tscheme.addProperty(SKOS.prefLabel, model.createLiteral(\"Dutch Standaard Bedrijfsindeling (SBI) 2008\", \"en\")); // TODO Not really English\n\t\tscheme.addProperty(SKOS.notation, \"SBI 2008\"); // TODO What distinguishes annual versions?\n\t\tscheme.addProperty(SKOS.definition, model.createLiteral(\"The Standard Industrial Classification is a classification of economic activities designed by the Central Bureau of Statistics of the Netherlands (CBS) that aims to provide a uniform classification of the economy for the benefit of detailed economic analyzes and statistics.\", \"en\"));\n\t\tscheme.addProperty(DC.publisher, model.createResource(\"http://www.cbs.nl\"));\n\t\tscheme.addProperty(DCTerms.issued, model.createTypedLiteral(\"2008-01-01\", \"http://www.w3.org/2001/XMLSchema#date\"));\n\t\tscheme.addProperty(DCTerms.modified, model.createTypedLiteral(\"2016-01-01\", \"http://www.w3.org/2001/XMLSchema#date\"));\n\t\tscheme.addProperty(FOAF.homepage, model.createResource(\"https://www.cbs.nl/en-gb/our-services/methods/classifications/activiteiten/standard-industrial-classifications--dutch-sbi-2008-nace-and-isic--\"));\n\t\tscheme.addProperty(XKOS.covers, model.createResource(\"http://eurovoc.europa.eu/5992\"));\n\t\tscheme.addProperty(XKOS.numberOfLevels, model.createTypedLiteral(5));\n\n\t\t// Create the resources representing the levels (xkos:ClassificationLevel)\n\t\tResource level1 = model.createResource(BASE_URI + \"/sections\", XKOS.ClassificationLevel);\n\t\tlevel1.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 1 - Sections\", \"en\"));\n\t\tlevel1.addProperty(XKOS.depth, model.createTypedLiteral(1));\n\t\tlevel1.addProperty(XKOS.notationPattern, \"[A-U]\");\n\t\tlevel1.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/section\"));\n\n\t\tResource level2 = model.createResource(BASE_URI + \"/divisions\", XKOS.ClassificationLevel);\n\t\tlevel2.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 2 - Divisions\", \"en\"));\n\t\tlevel2.addProperty(XKOS.depth, model.createTypedLiteral(2));\n\t\tlevel2.addProperty(XKOS.notationPattern, \"[0-9]{2}\");\n\t\tlevel2.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/division\"));\n\n\t\tResource level3 = model.createResource(BASE_URI + \"/groups\", XKOS.ClassificationLevel);\n\t\tlevel3.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 3 - Groups\", \"en\"));\n\t\tlevel3.addProperty(XKOS.depth, model.createTypedLiteral(3));\n\t\tlevel3.addProperty(XKOS.notationPattern, \"[0-9]{3}\");\n\t\tlevel3.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/group\"));\n\n\t\tResource level4 = model.createResource(BASE_URI + \"/classes\", XKOS.ClassificationLevel);\n\t\tlevel4.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 4 - Classes\", \"en\"));\n\t\tlevel4.addProperty(XKOS.depth, model.createTypedLiteral(4));\n\t\tlevel4.addProperty(XKOS.notationPattern, \"[0-9]{4}\");\n\t\tlevel4.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/class\"));\n\n\t\tResource level5 = model.createResource(BASE_URI + \"/subclasses\", XKOS.ClassificationLevel);\n\t\tlevel5.addProperty(SKOS.prefLabel, model.createLiteral(\"SBI 2008 - level 5 - Subclasses\", \"en\"));\n\t\tlevel5.addProperty(XKOS.depth, model.createTypedLiteral(5));\n\t\tlevel5.addProperty(XKOS.notationPattern, \"[0-9]{5}\");\n\t\tlevel5.addProperty(XKOS.organizedBy, model.createResource(\"http://stamina-project.org/concepts/sbi2008/subclass\"));\n\n\t\t// Attach the level list to the classification\n\t\tlevelList = model.createList(level1, level2, level3, level4, level5);\n\t\tscheme.addProperty(XKOS.levels, levelList);\n\t}\n\n\t/**\n\t * Initializes the Jena model and adds standard prefixes.\n\t */\n\tprivate void initializeModel() {\n\n\t\ttry {\n\t\t\tif (model != null) model.close(); // Just in case\n\t\t} catch (Exception ignored) {}\n\n\t\tmodel = ModelFactory.createDefaultModel();\n\t\tmodel.setNsPrefix(\"rdfs\", RDFS.getURI());\n\t\tmodel.setNsPrefix(\"skos\", SKOS.getURI());\n\t\tmodel.setNsPrefix(\"xkos\", XKOS.getURI());\n\n\t\tlogger.debug(\"Jena model initialized\");\n\n\t}\n\n\t/**\n\t * Writes the model to the output Turtle file.\n\t * \n\t * @throws IOException In case of problem writing the file\n\t */\n\tprivate void writeModel(String fileName) throws IOException {\n\n\t\tmodel.write(new FileOutputStream(fileName), \"TTL\");\n\t\t// Close the model\n\t\tmodel.close();\n\t}\n\n\t\n\t/**\n\t * Computes the parent code for one given SBI code.\n\t */\n\tprivate static String getParentCode(String code) {\n\n\t\tif ((code.length() == 1) || (code.length() > 5)) return null;\n\n\t\tif (code.length() == 2) return Names.getNACESectionForDivision(code);\n\n\t\t// For codes of length 3 to 5, parent code is the child code truncated on the right\n\t\treturn code.substring(0, code.length() - 1);\n\t}\n\n\t/**\n\t * Computes the NACE code corresponding to a SBI code.\n\t * \n\t * @param sbiCode A SBI code.\n\t * @return The NACE code corresponding to the SBI code.\n\t */\n\tpublic static String sbiToNACECode(String sbiCode) {\n\n\t\t// TODO\n\t\treturn sbiCode;\n\t}\n\n\t/**\n\t * Computes the URI of a SBI classification item.\n\t * \n\t * @param code The item code.\n\t * @return The item URI.\n\t */\n\tprivate static String getItemURI(String code) {\n\n\t\tint level = getItemLevelDepth(code);\n\n\t\tif (level == 1) return BASE_URI + \"section/\" + code;\n\t\tif (level == 2) return BASE_URI + \"division/\" + code;\n\t\tif (level == 3) return BASE_URI + \"group/\" + code;\n\t\tif (level == 4) return BASE_URI + \"class/\" + code;\n\t\tif (level == 5) return BASE_URI + \"subclass/\" + code; // TODO Check this\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Returns the depth of the level to which an item belongs.\n\t * \n\t * @param code The item code.\n\t * @return The depth of the level.\n\t */\n\tpublic static int getItemLevelDepth(String code) {\n\n\t\treturn code.length();\n\t}\n}\n", "fcr.wwwinfo.ares.xml_doc.schemas.ares.ares_datatypes.v_1_0.AresDotazTyp2;\nimport cz.mfcr.wwwinfo.ares.xml_doc.schemas.ares.ares_datatypes.v_1_0.VystupFormat2;\nimport cz.mfcr.wwwinfo.ares.xml_doc.schemas.ares.ares_request.v_1_0.AresDotazy;\nimport cz.mfcr.wwwinfo.ares.xml_doc.schemas.ares.ares_request.v_1_0.Dotaz;\nimport org.junit.Assert;\nimport org.junit.Test;\n\npublic class StandardRequestTemplateTest {\n\n    @Test\n    public void testQueryCounter() {\n        StandardRequestTemplate requestTemplate = new StandardRequestTemplate();\n        Assert.assertEquals(\"Counter is NOT initialized to zero.\", 0, requestTemplate.getRequest().getDotazPocet());\n        Assert.assertEquals(\"List of queries is NOT empty.\", 0, requestTemplate.getRequest().getDotaz().size());\n\n        requestTemplate.addQuery(new Dotaz());\n        Assert.assertEquals(\"Counter wasn't incremented.\", 1, requestTemplate.getRequest().getDotazPocet());\n        Assert.assertEquals(\"Size of queries list is NOT 1.\", 1, requestTemplate.getRequest().getDotaz().size());\n\n        requestTemplate.addQuery(new Dotaz());\n        requestTemplate.addQuery(new Dotaz());\n        Assert.assertEquals(\"Counter is NOT 3.\", 3, requestTemplate.getRequest().getDotazPocet());\n        Assert.assertEquals(\"Size of queries list is NOT 3.\", 3, requestTemplate.getRequest().getDotaz().size());\n    }\n\n    @Test\n    public void testStandardSettings() {\n        StandardRequestTemplate requestTemplate = new StandardRequestTemplate();\n        AresDotazy request = requestTemplate.getRequest();\n\n        Assert.assertEquals(\"Type of request is NOT set.\", AresDotazTyp2.STANDARD, request.getDotazTyp());\n        Assert.assertEquals(\"ID of request is NOT set.\", \"ares_dotaz\", request.getId());\n        Assert.assertEquals(\"Output format of request is NOT set.\", VystupFormat2.XML, request.getVystupFormat());\n    }\n}", "ion;\nimport java.io.RandomAccessFile;\nimport java.math.BigInteger;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\nimport backend.disk.Directory;\nimport backend.disk.Disk;\nimport backend.disk.Inode;\n\npublic class User {\n\tprivate String username;\n\tprivate String grpName;\n\t\n\tprivate int userId;\n\tprivate int grpId;\n\tprivate int homeDirInodeNum;\n\t\n\tprivate static final String pswdFilePath = Disk.transDisk.toString() + \"/pswd\";\n\tprivate static final String grpListPath = Disk.transDisk.toString() + \"/groupList\";\n\t\n\tprivate User(String username, String grpName, int userId, int grpId) {\n\t\tthis.username = username;\n\t\tthis.grpName = grpName;\n\t\tthis.userId = userId;\n\t\tthis.grpId = grpId;\n\t}\n\t\n\tpublic static User createNewUser(String newUsername, String password, String grpName) {\n\t\tUser newUser = null;\n\t\tboolean noProblem = true;\n\t\tint entriesRead = 1;\n\t\ttry {\n\t\t\tRandomAccessFile pswdF = new RandomAccessFile(User.pswdFilePath, \"rw\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = pswdF.readLine()) != null ) {\n\t\t\t\tentriesRead++;\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[0].compareTo(newUsername) == 0) {\n\t\t\t\t\tnoProblem = false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(noProblem) {\n\t\t\t\tint grpId = calculateGrpId(grpName);\n\t\t\t\tnewUser = new User(newUsername, grpName, entriesRead, grpId);\n\t\t\t\tTransSystem.setUser(newUser);\n\t\t\t\tDirectory.godMode = true;\n\t\t\t\tDirectory rootDir = new Directory(2);\n\t\t\t\tInode homeDirInode;\n\t\t\t\ttry {\n\t\t\t\t\thomeDirInode = rootDir.makeDir(newUsername);\n\t\t\t\t\tnewUser.homeDirInodeNum = homeDirInode.getInodeNum();\n\t\t\t\t} catch (PermissionDeniedException e) {\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t\tDirectory.godMode = false;\n\t\t\t\t\n\t\t\t\tpswdF.writeBytes(newUsername + \"\\t\" + User.hashIt(password) + \"\\t\" + entriesRead + \"\\t\" + grpId + \"\\t\" + newUser.homeDirInodeNum +\"\\n\");\n\t\t\t}\n\t\t\tpswdF.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn newUser;\n\t}\n\t\n\tprivate static int calculateGrpId(String grpName) {\n\t\tint grpId = 0, entriesRead = 1;\n\t\ttry {\n\t\t\tRandomAccessFile grpListFile = new RandomAccessFile(User.grpListPath, \"rw\");\n\t\t\tString buffer;\n\t\t\tboolean found = false;\n\t\t\twhile(!found && (buffer = grpListFile.readLine()) != null) {\n\t\t\t\tentriesRead++;\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[1].compareTo(grpName) == 0) {\n\t\t\t\t\tgrpId = Integer.parseInt(splitBuffer[0]);\n\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(!found) {\n\t\t\t\tgrpListFile.writeBytes(entriesRead + \"\\t\" + grpName + \"\\n\");\n\t\t\t\tgrpId = entriesRead;\n\t\t\t}\n\t\t\tgrpListFile.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\t\n\t\treturn grpId;\n\t}\n\n\tpublic static String hashIt(String input) {\n\t\tMessageDigest m = null;\n\t\ttry {\n\t\t\tm = MessageDigest.getInstance(\"MD5\");\n\t\t} catch (NoSuchAlgorithmException e1) {\n\t\t\te1.printStackTrace();\n\t\t}\n\t\tm.reset();\n\t\tm.update(input.getBytes());\n\t\tbyte[] digest = m.digest();\n\t\tBigInteger bigInt = new BigInteger(1,digest);\n\t\tString hashtext = bigInt.toString(16);\n\t\t// Now we need to zero pad it if you actually want the full 32 chars.\n\t\twhile(hashtext.length() < 32 ){\n\t\t  hashtext = \"0\"+hashtext;\n\t\t}\n\t\treturn hashtext;\n\t}\n\n\tpublic String getUsername() {\n\t\treturn this.username;\n\t}\n\tpublic String getGrpName() {\n\t\treturn this.grpName;\n\t}\n\tpublic int getUserId() {\n\t\treturn this.userId;\n\t}\n\tpublic int getGrpId() {\n\t\treturn this.grpId;\n\t}\n\t\n\tpublic static void initUserMgnt() {\n\t\tFile pswdFile = new File(User.pswdFilePath);\n\t\tFile grpListFile = new File(User.grpListPath);\n\t\ttry {\n\t\t\tif(!pswdFile.exists())\n\t\t\t\tpswdFile.createNewFile();\n\t\t\t\n\t\t\tif(!grpListFile.exists())\n\t\t\t\tgrpListFile.createNewFile();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t}\n\t\n\tpublic static User authenticate(String username, String pswd) {\n\t\tUser authenticatedUser = null;\n\t\tboolean authenticated = false;\n\t\ttry {\n\t\t\tRandomAccessFile pswdFile = new RandomAccessFile(User.pswdFilePath, \"r\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = pswdFile.readLine()) != null && !authenticated) {\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[0].compareTo(username) == 0) {\n\t\t\t\t\tif(splitBuffer[1].compareTo(User.hashIt(pswd)) == 0) {\n\t\t\t\t\t\tauthenticatedUser = new User(username, User.getGrpName(splitBuffer[3]), Integer.parseInt(splitBuffer[2]), Integer.parseInt(splitBuffer[3]));\n\t\t\t\t\t\tauthenticated = true;\n\t\t\t\t\t\tauthenticatedUser.homeDirInodeNum = Integer.parseInt(splitBuffer[4]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\t\t\t\t\t// wrong password\n\t\t\t\t}\n\t\t\t}\n\t\t\tpswdFile.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn authenticatedUser;\n\t}\n\n\tprivate static String getGrpName(String grpId) {\n\t\tboolean done = false;\n\t\tString grpName = null;\n\t\ttry {\n\t\t\tRandomAccessFile grpList = new RandomAccessFile(User.grpListPath, \"r\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = grpList.readLine()) != null && !done) {\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[1].compareTo(grpId) == 0) {\n\t\t\t\t\tgrpName = splitBuffer[0];\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tgrpList.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\t\t\n\t\treturn grpName;\n\t}\n\tpublic static int getUserId(String name) {\n\t\tboolean done = false;\n\t\tint userId = 0;\n\t\ttry {\n\t\t\tRandomAccessFile pswdF = new RandomAccessFile(User.pswdFilePath, \"r\");\n\t\t\tString buffer;\n\t\t\twhile((buffer = pswdF.readLine()) != null && !done) {\n\t\t\t\tString[] splitBuffer = buffer.split(\"\\t\");\n\t\t\t\tif(splitBuffer[0].compareTo(name) == 0) {\n\t\t\t\t\tuserId = Integer.parseInt(splitBuffer[2]);\n\t\t\t\t\tdone = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tpswdF.close();\n\t\t} catch (FileNotFoundException e) {\n\t\t\te.printStackTrace();\n\t\t} catch (IOException e) {\n\t\t\te.printStackTrace();\n\t\t}\n\t\treturn userId;\n\t}\n\n\tpublic int getHomeDirInodeNum() {\n\t\treturn this.homeDirInodeNum;\n\t}\n}\n", "ta;\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\n\n/**\n * Created by mjordan on 2/4/17.\n */\n\npublic class XyzIjStrategy extends TangoUpdateListenerBase {\n\n    public static final String TAG = XyzIjStrategy.class.toString();\n\n    @Override\n    public void onXyzIjAvailable(TangoXyzIjData xyzIj) {\n        byte[] buffer = new byte[xyzIj.xyzCount * 3 * 4];\n        FileInputStream fileStream = new FileInputStream(\n            xyzIj.xyzParcelFileDescriptor.getFileDescriptor());\n        try {\n            fileStream.read(buffer,\n                            xyzIj.xyzParcelFileDescriptorOffset, buffer.length);\n            fileStream.close();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n        // Do not process the buffer inside the callback because\n        // you will not receive any new data while it processes\n    }\n}\n", ".model.AbstractBuild;\nimport hudson.model.AbstractProject;\nimport hudson.model.BuildListener;\nimport hudson.model.Result;\nimport hudson.tasks.BuildStepDescriptor;\nimport hudson.tasks.BuildStepMonitor;\nimport hudson.tasks.Publisher;\nimport hudson.tasks.Recorder;\nimport hudson.util.FormValidation;\nimport hudson.util.ListBoxModel;\nimport hudson.util.Messages;\nimport hudson.util.Secret;\nimport io.walti.api.Plugin;\nimport io.walti.api.Scan;\nimport io.walti.api.Target;\nimport io.walti.api.WaltiApi;\nimport io.walti.api.exceptions.WaltiApiException;\nimport net.sf.json.JSONArray;\nimport org.apache.commons.lang.StringUtils;\nimport org.kohsuke.stapler.DataBoundConstructor;\nimport org.kohsuke.stapler.QueryParameter;\n\nimport java.io.IOException;\nimport java.io.PrintStream;\nimport java.io.Serializable;\nimport java.util.*;\n\n/**\n * Call Walti API to execute security scan\n *\n * @author Sho Matsumoto\n */\npublic class WaltiScanner extends Recorder implements Serializable {\n\n    private static final int POLLING_INTERVAL = 10;\n\n    private final String key;\n    private final Secret secret;\n    private final String target;\n    private final List<String> selectedPlugins;\n    private final boolean noWait;\n    private final boolean unstablePreferred;\n\n    @DataBoundConstructor\n    public WaltiScanner(String key, String secret, String target, JSONArray plugins, boolean noWait, boolean unstablePreferred) {\n        this.key = key;\n        this.secret = Secret.fromString(secret);\n        this.target = target;\n        this.selectedPlugins = new ArrayList<String>();\n        Collection<String> col = JSONArray.toCollection(plugins, ArrayList.class);\n        this.selectedPlugins.addAll(col);\n        this.noWait = noWait;\n        this.unstablePreferred = unstablePreferred;\n    }\n\n    /**\n     * Get API key\n     *\n     * @return API key\n     */\n    public String getKey() {\n        return key;\n    }\n\n    /**\n     * Get API Secret\n     *\n     * @return API secret\n     */\n    public Secret getSecret() {\n        return secret;\n    }\n\n    /**\n     * Get target name\n     *\n     * @return target name\n     */\n    public String getTarget() { return target; }\n\n    /**\n     * Whether wait until queued scans are completed\n     *\n     * @return return true if it is not necessary to wait\n     */\n    public boolean isNoWait() { return noWait; }\n\n\n    /**\n     * Whether regard build result as UNSTABLE instead of FAILURE when scan result is not OK\n     *\n     * @return return true if build result is regarded as UNSTABLE\n     */\n    public boolean isUnstablePreferred() { return unstablePreferred; }\n\n    /**\n     * Get plugin names to execute\n     *\n     * @return plugin names\n     */\n    public List<String> getSelectedPlugins() { return selectedPlugins; }\n\n    public String getSelectedPluginsString() {\n        List<String> pluginList = getSelectedPlugins();\n        return StringUtils.join(pluginList, ',');\n    }\n\n    @Override\n    public boolean perform(AbstractBuild build, Launcher launcher, BuildListener listener) throws IOException {\n        PrintStream logger = listener.getLogger();\n        WaltiApi api = WaltiApi.createInstance(key, secret.getPlainText());\n        Set<String> selectedPlugins = new HashSet<String>(getSelectedPlugins());\n\n        Scan.QueueResult queueResult = Scan.QueueResult.UNDEFINED;\n        for (String plugin : getSelectedPlugins()) {\n            try {\n                queueResult = Scan.queue(api, target, plugin);\n            } catch (WaltiApiException e) {\n                build.setResult(Result.FAILURE);\n                logger.println(plugin + \"\u306e\u30ad\u30e5\u30fc\u767b\u9332\u306b\u5931\u6557\u3057\u307e\u3057\u305f\");\n                e.printStackTrace(logger);\n                logger.close();\n                return true;\n            }\n\n            switch (queueResult) {\n                case SUCCESS:\n                    logger.println(plugin + \"\u306e\u30ad\u30e5\u30fc\u3092\u767b\u9332\u3057\u307e\u3057\u305f\");\n                    break;\n                case SKIPPED:\n                    selectedPlugins.remove(plugin);\n                    build.setResult(Result.UNSTABLE);\n                    logger.format(\"\u6c7a\u6e08\u60c5\u5831\u304c\u767b\u9332\u3055\u308c\u3066\u3044\u306a\u3044\u304b\u3001\u3059\u3067\u306b\u30b9\u30ad\u30e3\u30f3\u5b9f\u884c\u4e2d\u306e\u305f\u3081%s\u306e\u30ad\u30e5\u30fc\u767b\u9332\u3092\u30b9\u30ad\u30c3\u30d7\u3057\u307e\u3059\\n\", plugin);\n                    break;\n                default:\n                    build.setResult(Result.FAILURE);\n                    logger.println(\"\u30b9\u30ad\u30e3\u30f3\u30ad\u30e5\u30fc\u306e\u767b\u9332\u306b\u5931\u6557\");\n                    break;\n            }\n        }\n\n        if (selectedPlugins.isEmpty()) {\n            logger.println(\"\u30ad\u30e5\u30fc\u767b\u9332\u304c\u3059\u3079\u3066\u30b9\u30ad\u30c3\u30d7\u3055\u308c\u307e\u3057\u305f\");\n            logger.close();\n            return true;\n        }\n\n        if (isNoWait()) {\n            logger.println(\"\u30b9\u30ad\u30e3\u30f3\u306e\u5b8c\u4e86\u3092\u5f85\u305f\u306a\u3044\u8a2d\u5b9a\u306e\u305f\u3081\u7d50\u679c\u53d6\u5f97\u3092\u30b9\u30ad\u30c3\u30d7\u3057\u307e\u3057\u305f\");\n            logger.close();\n            return true;\n        }\n\n        logger.println(\"\u30b9\u30ad\u30e3\u30f3\u7d50\u679c\u3092\u30dd\u30fc\u30ea\u30f3\u30b0\u3057\u3066\u3044\u307e\u3059\");\n\n        int i = 0;\n        while (!selectedPlugins.isEmpty()) {\n            if (shouldOutputPolling(i)) {\n                logger.println(\".\");\n            }\n            i++;\n            Target targetObj = null;\n            try {\n                targetObj = Target.find(api, target);\n            } catch (WaltiApiException e) {\n                build.setResult(Result.FAILURE);\n                logger.println(\"\u30b9\u30ad\u30e3\u30f3\u7d50\u679c\u30dd\u30fc\u30ea\u30f3\u30b0\u6642\u306e\u5fdc\u7b54\u304c\u7570\u5e38\");\n                e.printStackTrace(logger);\n                logger.close();\n                return true;\n            }\n\n            for (Plugin pluginObj : targetObj.getPlugins()) {\n                if (pluginObj.isQueued() || !selectedPlugins.contains(pluginObj.getName())) {\n                    // \u30b9\u30ad\u30e3\u30f3\u304c\u307e\u3060\u7d42\u308f\u3063\u3066\u3044\u306a\u3044\u3082\u3057\u304f\u306f\u9078\u629e\u3055\u308c\u3066\u3044\u306a\u3044\u30d7\u30e9\u30b0\u30a4\u30f3\u306e\u7d50\u679c\u8868\u793a\u306f\u4e0d\u8981\n                    continue;\n                }\n                selectedPlugins.remove(pluginObj.getName());\n\n                try {\n                    Scan scan = pluginObj.getScan();\n                    switch (scan.getResultStatus()) {\n                        case Scan.RESULT_OK:\n                            logger.println(pluginObj.getName() + \"\u306e\u30b9\u30ad\u30e3\u30f3\u304c\u5b8c\u4e86\u3057\u307e\u3057\u305f\u3002\u7d50\u679c:\" + scan.getStatus() + \" \u30e1\u30c3\u30bb\u30fc\u30b8:\" + scan.getMessage());\n                            logger.println(targetObj.getResultURL(pluginObj.getName()));\n                            build.setResult(judgeResult(scan.getStatusColor()));\n                            break;\n                        default:\n                            logger.println(pluginObj.getName() + \"\u306e\u30b9\u30ad\u30e3\u30f3\u304c\u4e2d\u65ad\u3055\u308c\u307e\u3057\u305f\u3002\u4ee5\u4e0b\u306eURL\u304b\u3089\u8a73\u7d30\u3092\u78ba\u8a8d\u3057\u3066\u304f\u3060\u3055\u3044\");\n                            logger.println(targetObj.getResultURL(pluginObj.getName()));\n                            build.setResult(Result.FAILURE);\n                            logger.close();\n                            return true;\n                    }\n                } catch (WaltiApiException e) {\n                    build.setResult(Result.FAILURE);\n                    logger.println(\"\u30b9\u30ad\u30e3\u30f3\u7d50\u679cURL\u306e\u53d6\u5f97\u306b\u5931\u6557\");\n                    e.printStackTrace(logger);\n                    logger.close();\n                    return true;\n                }\n            }\n            try {\n                Thread.sleep(POLLING_INTERVAL * 1000);\n            } catch (InterruptedException e) {\n                build.setResult(Result.ABORTED);\n                logger.println(\"\u7d50\u679c\u306e\u30dd\u30fc\u30ea\u30f3\u30b0\u3092\u4e2d\u6b62\u3057\u307e\u3059\u3002\u30b9\u30ad\u30e3\u30f3\u81ea\u4f53\u306e\u30ad\u30e3\u30f3\u30bb\u30eb\u306fWalti.io\u306e\u30bf\u30fc\u30b2\u30c3\u30c8\u753b\u9762\u304b\u3089\u884c\u3063\u3066\u304f\u3060\u3055\u3044\");\n                logger.close();\n                return true;\n            }\n        }\n        logger.close();\n        return true;\n    }\n\n    /**\n     * Judge if polling progress should be outputted\n     *\n     * @param count\n     * @return\n     */\n    private boolean shouldOutputPolling(int count) {\n        int outputInterval = (int)Math.ceil(60.0 / POLLING_INTERVAL);\n        return count % outputInterval == 0;\n    }\n\n    /**\n     * Judge build result from scan status color\n     *\n     * @param statusColor\n     * @return build result\n     */\n    private Result judgeResult(String statusColor) {\n        if (Scan.STATUS_COLOR_GREEN.equals(statusColor)) {\n            return Result.SUCCESS;\n        }\n        if (Scan.STATUS_COLOR_GREY.equals(statusColor)) {\n            return Result.UNSTABLE;\n        }\n        if (isUnstablePreferred()) {\n            return Result.UNSTABLE;\n        }\n        return Result.FAILURE;\n    }\n\n    // Overridden for better type safety.\n    // If your plugin doesn't really define any property on Descriptor,\n    // you don't have to do this.\n    @Override\n    public DescriptorImpl getDescriptor() {\n        return (DescriptorImpl)super.getDescriptor();\n    }\n\n    @Override\n    public BuildStepMonitor getRequiredMonitorService() {\n        return BuildStepMonitor.BUILD;\n    }\n\n    @Extension // This indicates to Jenkins that this is an implementation of an extension point.\n    public static final class DescriptorImpl extends BuildStepDescriptor<Publisher> {\n        public boolean isApplicable(Class<? extends AbstractProject> jobType) {\n            return true;\n        }\n\n        public String getDisplayName() {\n            return \"Walti\u3067\u30b9\u30ad\u30e3\u30f3\u3092\u5b9f\u884c\";\n        }\n\n        public FormValidation doCheckKey(@QueryParameter String key, @QueryParameter String secret) {\n            if (key.isEmpty()) {\n                return FormValidation.error(Messages.FormValidation_ValidateRequired());\n            }\n            if (secret.isEmpty()) {\n                return FormValidation.ok();  // \u307e\u3060API\u30ad\u30fc\u304c\u5165\u529b\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n            }\n            return FormValidation.ok();\n        }\n\n        public FormValidation doCheckSecret(@QueryParameter String key, @QueryParameter String secret) {\n            if (secret.isEmpty()) {\n                return FormValidation.error(Messages.FormValidation_ValidateRequired());\n            }\n            if (key.isEmpty()) {\n                return FormValidation.ok();  // \u307e\u3060API\u30ad\u30fc\u304c\u5165\u529b\u3055\u308c\u3066\u3044\u306a\u3044\u5834\u5408\u306f\u4f55\u3082\u3057\u306a\u3044\n            }\n\n            WaltiApi api = WaltiApi.createInstance(key, Secret.fromString(secret).getPlainText());\n            try {\n                if (!api.isValidCredentials()) {\n                    return FormValidation.error(\"API\u30ad\u30fc\u307e\u305f\u306f\u30b7\u30fc\u30af\u30ec\u30c3\u30c8\u304c\u6b63\u3057\u304f\u3042\u308a\u307e\u305b\u3093\u3002\");\n                }\n                return FormValidation.ok();\n            } catch (WaltiApiException e) {\n                e.printStackTrace();\n                return FormValidation.error(\"\u4e88\u671f\u305b\u306c\u30a8\u30e9\u30fc\u304c\u767a\u751f\u3057\u307e\u3057\u305f \" + e.getMessage());\n            }\n        }\n\n        public ListBoxModel doFillTargetItems(@QueryParameter String key, @QueryParameter String secret) {\n            ListBoxModel m = new ListBoxModel();\n            if (key.isEmpty() || secret.isEmpty()) {\n                // \u30ad\u30fc\u304b\u30b7\u30fc\u30af\u30ec\u30c3\u30c8\u304c\u7a7a\u306e\u5834\u5408\u306f\u7a7a\u30ea\u30b9\u30c8\n                return m;\n            }\n\n            WaltiApi api = WaltiApi.createInstance(key, Secret.fromString(secret).getPlainText());\n            try {\n                List<Target> targets = Target.getAll(api);\n                for (Target target : targets) {\n                    m.add(target.getName(), target.getName());\n                }\n            } catch (WaltiApiException e) {\n                // do nothing\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return m;\n        }\n\n        public CheckBoxModel doFillPluginsItems(@QueryParameter String key, @QueryParameter String secret, @QueryParameter String target) {\n            // \u30bf\u30fc\u30b2\u30c3\u30c8\u60c5\u5831\n            WaltiApi api = WaltiApi.createInstance(key, Secret.fromString(secret).getPlainText());\n            CheckBoxModel model = new CheckBoxModel();\n\n            if (target.isEmpty()) {\n                return model;\n            }\n\n            try {\n                Target targetObj = Target.find(api, target);\n                for (Plugin plugin : targetObj.getPlugins()) {\n                    model.add(new CheckBoxModel.Item(plugin.getName()));\n                }\n                return model;\n            } catch (WaltiApiException e) {\n                // do nothing\n            } catch (Exception e) {\n                e.printStackTrace();\n            }\n            return model;\n        }\n    }\n}\n", "eeMap;\n\nimport edu.georgetown.library.fileAnalyzer.filetest.iiif.IIIFEnums.IIIFLookupEnum;\n\npublic abstract class FolderProjectTranslate extends DefaultManifestProjectTranslate {\n        File root;\n        TreeMap<String,RangePath> dirPaths = new TreeMap<>();\n        RangePath top;\n        \n        @Override\n        public void initProjectRanges(IIIFManifest manifest, File root, RangePath top) {\n                this.root = root;\n                this.top = top;\n        }\n        @Override\n        public boolean showFolderRanges() {\n                return true;\n        }\n        \n        public String getRelPath(File f) {\n                return f.getAbsolutePath().substring(root.getAbsolutePath().length()).replaceAll(\"[\\\\\\\\\\\\/]\", \"_\");\n        }\n        \n        public abstract RangePath makeRangePath(IIIFManifest manifest, File f);\n        \n        @Override\n        public RangePath getPrimaryRangePath(IIIFManifest manifest, String key, File f, MetadataInputFile itemMeta) {\n                if (dirPaths.containsKey(f.getAbsolutePath())) {\n                        return dirPaths.get(f.getAbsolutePath());\n                }\n                RangePath rp = makeRangePath(manifest, f);\n                if (!manifest.isCollectionManifest() && manifest.getManifestProjectTranslate().isOneItemPerRange()) {\n                        rp.setDisplayPath(itemMeta.getValue(IIIFLookupEnum.Title.getLookup(), rp.displayPath));\n                }\n                dirPaths.put(f.getAbsolutePath(), rp);\n                return rp;\n        }\n\n}\n", "harge, to any person obtaining a copy\n *  of this software and associated documentation files (the \"Software\"), to deal\n *  in the Software without restriction, including without limitation the rights\n *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *  copies of the Software, and to permit persons to whom the Software is\n *  furnished to do so, subject to the following conditions:\n *\n *  The above copyright notice and this permission notice shall be included in all\n *  copies or substantial portions of the Software.\n *\n *  THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n *  SOFTWARE.\n */\n\npackage me.lucko.luckperms.commands.group.subcommands;\n\nimport me.lucko.luckperms.LuckPermsPlugin;\nimport me.lucko.luckperms.commands.CommandResult;\nimport me.lucko.luckperms.commands.Predicate;\nimport me.lucko.luckperms.commands.Sender;\nimport me.lucko.luckperms.commands.SubCommand;\nimport me.lucko.luckperms.constants.Message;\nimport me.lucko.luckperms.constants.Permission;\nimport me.lucko.luckperms.data.LogEntry;\nimport me.lucko.luckperms.groups.Group;\n\nimport java.util.List;\n\npublic class GroupClear extends SubCommand<Group> {\n    public GroupClear() {\n        super(\"clear\", \"Clears a groups permissions\", \"/%s group <group> clear\", Permission.GROUP_CLEAR,\n                Predicate.alwaysFalse());\n    }\n\n    @Override\n    public CommandResult execute(LuckPermsPlugin plugin, Sender sender, Group group, List<String> args, String label) {\n        group.clearNodes();\n        Message.CLEAR_SUCCESS.send(sender, group.getName());\n        LogEntry.build().actor(sender).acted(group).action(\"clear\").build().submit(plugin, sender);\n        save(group, sender, plugin);\n        return CommandResult.SUCCESS;\n    }\n}\n", "SONObject;\nimport org.junit.Assert;\nimport org.junit.Test;\nimport org.lpw.ranch.audit.Audit;\nimport org.lpw.ranch.recycle.Recycle;\nimport org.lpw.tephra.ctrl.validate.Validators;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * @author lpw\n */\npublic class QueryByOwnerTest extends TestSupport {\n    @Test\n    public void queryByOwner() {\n        String[] owners = new String[]{generator.uuid(), generator.uuid()};\n        List<CommentModel> list = new ArrayList<>();\n        for (int i = 0; i < 20; i++)\n            list.add(create(i, owners[i % owners.length], \"author \" + i, Audit.values()[i % 3], Recycle.No));\n        CommentModel child = create(101, list.get(1).getId(), \"author 1\", Audit.Pass, Recycle.No);\n\n        mockHelper.reset();\n        mockHelper.mock(\"/comment/query-by-owner\");\n        JSONObject object = mockHelper.getResponse().asJson();\n        Assert.assertEquals(1303, object.getIntValue(\"code\"));\n        Assert.assertEquals(message.get(Validators.PREFIX + \"illegal-id\", message.get(CommentModel.NAME + \".owner\")), object.getString(\"message\"));\n\n        mockHelper.reset();\n        mockHelper.getRequest().addParameter(\"owner\", \"owner id\");\n        mockHelper.mock(\"/comment/query-by-owner\");\n        object = mockHelper.getResponse().asJson();\n        Assert.assertEquals(1303, object.getIntValue(\"code\"));\n        Assert.assertEquals(message.get(Validators.PREFIX + \"illegal-id\", message.get(CommentModel.NAME + \".owner\")), object.getString(\"message\"));\n\n        mockCarousel.reset();\n        mockUser.register();\n        mockHelper.reset();\n        mockHelper.getRequest().addParameter(\"owner\", owners[0]);\n        mockHelper.getRequest().addParameter(\"pageSize\", \"20\");\n        mockHelper.getRequest().addParameter(\"pageNum\", \"0\");\n        sign.put(mockHelper.getRequest().getMap(), null);\n        mockHelper.mock(\"/comment/query-by-owner\");\n        object = mockHelper.getResponse().asJson();\n        Assert.assertEquals(0, object.getIntValue(\"code\"));\n        JSONObject data = object.getJSONObject(\"data\");\n        pageTester.assertCountSizeNumber(3, 20, 1, data);\n        JSONArray array = data.getJSONArray(\"list\");\n        Assert.assertEquals(3, array.size());\n        for (int i = 0; i < array.size(); i++)\n            equals(list.get(6 * (i + 1) - 2), array.getJSONObject(i), 6 * (i + 1) - 2, child);\n\n        for (Audit audit : Audit.values()) {\n            mockHelper.reset();\n            mockHelper.getRequest().addParameter(\"owner\", owners[1]);\n            mockHelper.getRequest().addParameter(\"audit\", \"\" + audit.getValue());\n            mockHelper.getRequest().addParameter(\"pageSize\", \"20\");\n            mockHelper.getRequest().addParameter(\"pageNum\", \"0\");\n            sign.put(mockHelper.getRequest().getMap(), null);\n            mockHelper.mock(\"/comment/query-by-owner\");\n            object = mockHelper.getResponse().asJson();\n            Assert.assertEquals(0, object.getIntValue(\"code\"));\n            data = object.getJSONObject(\"data\");\n            pageTester.assertCountSizeNumber(4, 20, 1, data);\n            array = data.getJSONArray(\"list\");\n            Assert.assertEquals(4, array.size());\n            for (int i = 0; i < array.size(); i++)\n                equals(list.get(6 * (i + 1) - 5), array.getJSONObject(i), 6 * (i + 1) - 5, child);\n        }\n    }\n\n    private void equals(CommentModel comment, JSONObject obj, int i, CommentModel child) {\n        Assert.assertEquals(comment.getId(), obj.getString(\"id\"));\n        Assert.assertFalse(obj.containsKey(\"key\"));\n        Assert.assertFalse(obj.containsKey(\"owner\"));\n        mockUser.verify(obj.getJSONObject(\"author\"), comment.getAuthor());\n        Assert.assertEquals(comment.getSubject(), obj.getString(\"subject\"));\n        Assert.assertEquals(comment.getLabel(), obj.getString(\"label\"));\n        Assert.assertEquals(comment.getContent(), obj.getString(\"content\"));\n        Assert.assertEquals(comment.getScore(), obj.getIntValue(\"score\"));\n        Assert.assertFalse(obj.containsKey(\"audit\"));\n        Assert.assertEquals(converter.toString(comment.getTime()), obj.getString(\"time\"));\n        if (i == 1) {\n            JSONArray children = obj.getJSONArray(\"children\");\n            Assert.assertEquals(1, children.size());\n            equals(child, children.getJSONObject(0), 101, null);\n        } else\n            Assert.assertFalse(obj.containsKey(\"children\"));\n    }\n}\n", "port java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.junit.Test;\n\npublic class TaxonRankEnumTest {\n\t\n\t@Test\n\tpublic void testComparator(){\n\t\tList<TaxonRankEnum> rankList = new ArrayList<TaxonRankEnum>();\n\t\trankList.add(TaxonRankEnum.VARIETY);\n\t\trankList.add(TaxonRankEnum.GENUS);\n\t\trankList.add(TaxonRankEnum.CLASS);\n\t\t\n\t\tCollections.sort(rankList, new TaxonRankEnum.TaxonRankEnumComparator());\n\t\t\n\t\tassertEquals(TaxonRankEnum.CLASS,rankList.get(0));\n\t\tassertEquals(TaxonRankEnum.GENUS,rankList.get(1));\n\t\tassertEquals(TaxonRankEnum.VARIETY,rankList.get(2));\n\t}\n\n}\n", "g.springframework.data.annotation.Id;\r\n\r\nimport java.util.ArrayList;\r\n\r\npublic class FrequentItemSet {\r\n\r\n    @Id\r\n    @JsonIgnore\r\n    private String id;\r\n\r\n    private ArrayList<String> items;\r\n    private int support;\r\n\r\n    public int getSupport() { return support; }\r\n    public void setSupport(int support) { this.support = support; }\r\n\r\n    public void setItems(ArrayList<String> items) { this.items = items; }\r\n    public ArrayList<String> getItems() { return items; }\r\n\r\n}\r\n", "com/\n * support@verifalia.com\n *\n * Copyright (c) 2005-2020 Cobisi Research\n *\n * Cobisi Research\n * Via Prima Strada, 35\n * 35129, Padova\n * Italy - European Union\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.verifalia.api.common;\n\nimport lombok.Builder;\nimport lombok.Getter;\nimport lombok.NoArgsConstructor;\nimport lombok.NonNull;\nimport lombok.experimental.SuperBuilder;\n\n/**\n * Base class for listing operations against the Verifalia API.\n */\n@Getter\n@SuperBuilder\n@NoArgsConstructor\npublic class ListingOptions {\n    /**\n     * The maximum number of items to return with a listing request. The Verifalia API may choose to override the specified\n     * limit if it is either too small or too big. Note: a single listing operation may automatically perform different\n     * listing requests to the Verifalia API: this value limits the number of items returned by *each* API request, not\n     * the overall total number of returned items.\n     */\n    private Integer limit;\n\n    /**\n     * The direction of the listing.\n     */\n    @Builder.Default\n    private Direction direction = Direction.Forward;\n\n    public void setLimit(final Integer limit) {\n        if (limit != null && limit < 0) {\n            throw new IllegalArgumentException(\"Limit must be 0 (meaning no limit will be enforced) or greater.\");\n        }\n\n        this.limit = limit;\n    }\n\n    public void setDirection(@NonNull final Direction direction) {\n        this.direction = direction;\n    }\n}", "ogle.common.collect.ImmutableMap;\nimport com.google.common.collect.ImmutableSet;\nimport com.google.common.collect.ListMultimap;\nimport elasta.commons.Utils;\nimport elasta.composer.Headers;\nimport elasta.composer.ex.AppContextException;\nimport elasta.pipeline.converter.Converter;\n\nimport java.util.*;\n\n/**\n * Created by sohan on 5/12/2017.\n */\nfinal public class HeadersImpl implements Headers {\n    final ListMultimap<String, String> multimap;\n    final Map<Class, Converter> convertersMap;\n\n    public HeadersImpl(ListMultimap<String, String> multimap, Map<Class, Converter> convertersMap) {\n        Objects.requireNonNull(multimap);\n        Objects.requireNonNull(convertersMap);\n        this.multimap = multimap;\n        this.convertersMap = ImmutableMap.copyOf(\n            checkConvertersMap(convertersMap)\n        );\n    }\n\n    @Override\n    public boolean containsKey(String key) {\n        return multimap.containsKey(key);\n    }\n\n    @Override\n    public Set<String> keySet() {\n        return multimap.keySet();\n    }\n\n    @Override\n    public Optional<Integer> getInt(String key) {\n        return get(key).map(s -> convert(Integer.class, s));\n    }\n\n    @Override\n    public Optional<Long> getLong(String key) {\n        return get(key).map(s -> convert(Long.class, s));\n    }\n\n    @Override\n    public Optional<Float> getFloat(String key) {\n        return get(key).map(s -> convert(Float.class, s));\n    }\n\n    @Override\n    public Optional<Double> getDouble(String key) {\n        return get(key).map(s -> convert(Double.class, s));\n    }\n\n    @Override\n    public Optional<String> get(String key) {\n        return getValue(key);\n    }\n\n    @Override\n    public Optional<Date> getDate(String key) {\n        return get(key).map(s -> convert(Date.class, s));\n    }\n\n    @Override\n    public List<String> getAll(String key) {\n        return multimap.get(key);\n    }\n\n    @Override\n    public ListMultimap<String, String> getMultimap() {\n        return multimap;\n    }\n\n    @Override\n    public Headers addAll(ListMultimap<String, String> multimap) {\n        return new HeadersImpl(\n            ImmutableListMultimap.<String, String>builder().putAll(multimap).build(),\n            convertersMap\n        );\n    }\n\n    @Override\n    public Headers addAll(Map<String, String> map) {\n        return new HeadersImpl(\n            ImmutableListMultimap.<String, String>builder().putAll(\n                map.entrySet()\n            ).build(),\n            convertersMap\n        );\n    }\n\n    public Map<Class, Converter> getConvertersMap() {\n        return convertersMap;\n    }\n\n    private <T> T convert(Class<T> tClass, String value) {\n        return (T) convertersMap.get(tClass).convert(value);\n    }\n\n    private Optional<String> getValue(String key) {\n\n        List<String> strings = multimap.get(key);\n\n        if (strings.isEmpty()) {\n            return Optional.empty();\n        }\n\n        return Optional.of(strings.get(0));\n    }\n\n    private Map<Class, Converter> checkConvertersMap(Map<Class, Converter> convertersMap) {\n        ImmutableSet.of(\n            Integer.class, Long.class, Float.class, Double.class, Boolean.class, Date.class\n        ).forEach(aClass -> {\n            if (Utils.not(convertersMap.containsKey(aClass))) {\n                throw new AppContextException(\"ConvertersMap does not contains converter for type '\" + aClass + \"'\");\n            }\n        });\n        return convertersMap;\n    }\n}\n", "on.collect.ImmutableSet;\nimport com.google.common.collect.Sets;\nimport com.google.common.io.Resources;\nimport org.codarama.diet.bundle.JarMaker;\nimport org.codarama.diet.model.ClassStream;\nimport org.junit.Before;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.test.context.ContextConfiguration;\nimport org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n\nimport java.io.File;\nimport java.io.FileInputStream;\nimport java.io.FileNotFoundException;\nimport java.io.IOException;\nimport java.net.URISyntaxException;\nimport java.util.Enumeration;\nimport java.util.Set;\nimport java.util.jar.JarEntry;\nimport java.util.jar.JarFile;\n\nimport static org.junit.Assert.assertTrue;\n\n/**\n * Tests {@link StreamJarMaker}.\n *\n * Created by Ayld on 6/28/15.\n */\n@RunWith(SpringJUnit4ClassRunner.class)\n@ContextConfiguration({\"classpath:META-INF/test-contexts/testStreamJarMakerContext.xml\"})\npublic class TestStreamJarMaker {\n\n    private static final Set<String> CORRECT_ZIPPED_ENTRY_NAMES = ImmutableSet.of(\n            \"net\" + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\", \"diet\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\", \"diet\", \"model\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"codarama\", \"diet\", \"model\", \"ClassName.class\"),\n            \"org\" + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"primefaces\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"primefaces\", \"context\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"primefaces\", \"context\", \"PrimePartialViewContext.class\"),\n            Joiner.on(File.separator).join(\"org\", \"apache\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"apache\", \"commons\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"apache\", \"commons\", \"lang3\") + File.separator,\n            Joiner.on(File.separator).join(\"org\", \"apache\", \"commons\", \"lang3\", \"CharRange$1.class\")\n    );\n\n    @Autowired\n    private String workDir;\n\n    @Autowired\n    private JarMaker<ClassStream> jarMaker;\n\n    @Before\n    public void prepare() throws IOException {\n        cleanDir(new File(workDir));\n    }\n\n    @Test\n    public void makeJar() throws URISyntaxException, IOException {\n        final Set<ClassStream> filesToZip = ImmutableSet.of(\n                ClassStream.fromStream(\n                        new FileInputStream(new File(Resources.getResource(\"test-classes/ClassName.class\").toURI()))\n                ),\n                ClassStream.fromStream(\n                        new FileInputStream(new File(Resources.getResource(\"test-classes/PrimePartialViewContext.class\").toURI()))\n                ),\n                ClassStream.fromStream(\n                        new FileInputStream(new File(Resources.getResource(\"test-classes/CharRange$1.class\").toURI()))\n                )\n        );\n\n        final JarFile jar = jarMaker.zip(filesToZip);\n\n        assertTrue(\"zipped jar is null\", jar != null);\n\n        final Enumeration<JarEntry> entries = jar.entries();\n        while (entries.hasMoreElements()) {\n\n            final JarEntry entry = entries.nextElement();\n\n            assertTrue(\"invalid entry: \" + entry, CORRECT_ZIPPED_ENTRY_NAMES.contains(entry.getName()));\n        }\n\n        final File zipDir = new File(workDir);\n        final Set<File> zipDirFiles = Sets.newHashSet(zipDir.listFiles());\n\n        assertTrue(jar.getName() + \", missing\", zipDirFiles.contains(new File(jar.getName())));\n    }\n\n    private static void cleanDir(File file) throws IOException {\n        if (file == null || !file.exists()) {\n            return;\n        }\n        if (file.isDirectory()) {\n            final File[] files = file.listFiles();\n            if (files == null) {\n                return;\n            }\n            for (File sub : files) {\n                cleanDir(sub);\n            }\n        }\n        if (!file.delete()) {\n            throw new IOException(\"failed to deleteRecursive: \" + file);\n        }\n    }\n}\n", " edu.lognet.reputation.model.experience.Credibility;\nimport edu.lognet.reputation.model.service.Service;\nimport edu.lognet.reputation.model.user.IConsumer;\nimport edu.lognet.reputation.model.user.IProvider;\nimport edu.lognet.reputation.model.user.IRater;\n\n/**\n * Represent a reputation system\n * @author Laurent Vanni, Thao Nguyen\n *\n */\npublic interface IReputationSystem {\n\n\t/**\n\t * \n\t * @param service\n\t * @param provider\n\t * @param raters\n\t * @param consumer\n\t * @param credibilityOfRaterMap\n\t * @return\n\t */\n\tpublic double getReputation(Service service, IProvider provider,\n\t\t\tList<IRater> raters, IConsumer consumer,\n\t\t\tMap<IProvider, Map<IRater, Credibility>> credibilityOfRaterMap, int personalWeight);\n\n\t/**\n\t * \n\t * @param consumer\n\t * @param service\n\t * @param provider\n\t * @param credibilityOfRater\n\t */\n\tpublic void updateUsefulFactor(IConsumer consumer, Service service,\n\t\t\tIProvider provider, Map<IRater, Credibility> credibilityOfRater, double feedback);\n\n}\n", "   Scanner scanner=new Scanner(System.in);\n        while(scanner.hasNext()){\n            System.out.println(revStr(scanner.nextLine()));\n        }\n    }\n    \n    private static String revStr(String str){\n\t\tif(str==null){\n            return null;\n        }\n        char[] array=str.toCharArray();\n        int start=0;\n        int end=array.length-1;\n        while(start<end){\n            swap(array,start,end);\n            start++;\n            end--;\n        }\n        return new String(array);\n    }\n    \n    private static void swap(char[] array,int i,int j){\n        /*char temp=array[i];\n        array[i]=array[j];\n        array[j]=temp;*/\n        //\u6216\u8005\u4e0d\u4f7f\u7528\u4e34\u65f6\u53d8\u91cf\n        array[i] = (char)(array[i]^array[j]);\n        array[j] = (char)(array[i]^array[j]);\n        array[i] = (char)(array[i]^array[j]);\n    }\n}", "DependencyException(String string) {\n\t\tsuper(string);\n\t}\n\n\tprivate static final long serialVersionUID = -6975243982936880193L;\n\n}\n", "ft.bingads.v10.api.test.entities.campaign_product_scope.BulkCampaignProductScopeTest;\nimport com.microsoft.bingads.v10.bulk.entities.BulkCampaignProductScope;\nimport com.microsoft.bingads.v10.bulk.entities.Status;\nimport com.microsoft.bingads.internal.functionalinterfaces.Function;\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.junit.runners.Parameterized;\nimport org.junit.runners.Parameterized.Parameter;\nimport org.junit.runners.Parameterized.Parameters;\n\nimport java.util.Arrays;\nimport java.util.Collection;\n\n@RunWith(Parameterized.class)\npublic class ReadStatusTest extends BulkCampaignProductScopeTest {\n\n    @Parameter(value = 1)\n    public Status expectedResult;\n\n    @Parameters\n    public static Collection<Object[]> data() {\n        return Arrays.asList(\n                new Object[][]{\n                        {\"\", null},\n                        {null, null},\n                        {\"Active\", Status.ACTIVE},\n                        {\"Deleted\", Status.DELETED}\n                }\n        );\n    }\n\n    @Test\n    public void testRead() {\n        testReadProperty(\n                \"Status\",\n                datum,\n                expectedResult,\n                new Function<BulkCampaignProductScope, Status>() {\n                    @Override\n                    public Status apply(BulkCampaignProductScope c) {\n                        return c.getStatus();\n                    }\n                }\n        );\n    }\n}\n", " class LoggingListener implements TweetListener {\n\n    private static final Logger LOGGER = LoggerFactory.getLogger(LoggingListener.class);\n\n    @Override\n    public void message(String author, String message) {\n        LOGGER.info(author + \": \" + message);\n    }\n}\n", " i=0; i<array.length; i++){\n\t\t\ttotal += array[i];\n\t\t}\n\n\t\tSystem.out.println(\"Total is: \" + total);\n\t}\n\t\n\tpublic static void main (String args[]){\n\t\tdouble[] num = {1.2,3.4,5.6,7.8, 9.01};\n\t\tadd(num);\n\t}\n\t*/\n\t\n\tpublic static void main (String args[]){\n\t\t\n\t\tString [][] names = {\n\t\t\t{\"Mr.\", \"Mrs.\", \"Ms.\"},\n\t\t\t{\"Smith\", \"Jones\"}\n\t\t};\n\t\t\n\t\tfor(int i=0; i<names[0].length; i++){\n\t\t\tfor(int j=0; j<names[1].length; j++){\n\t\t\t\tSystem.out.println(\"i is:\" + i + \" & \" + \"j is:\" + j);\n\t\t\t\tSystem.out.println(names[0][i] + names[1][j]);\n\t\t\t}\n\t\t};\n\t}\n\n}", "---------------------------\n// Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.  See License in the project root for license information.\n// ------------------------------------------------------------------------------\n\npackage com.microsoft.graph.requests;\nimport com.microsoft.graph.models.ReportRoot;\nimport com.microsoft.graph.requests.ReportRootGetTeamsUserActivityUserDetailRequest;\n\nimport javax.annotation.Nullable;\nimport javax.annotation.Nonnull;\nimport com.microsoft.graph.http.BaseRequest;\nimport com.microsoft.graph.http.HttpMethod;\nimport com.microsoft.graph.core.ClientException;\nimport com.microsoft.graph.core.IBaseClient;\nimport com.microsoft.graph.models.ReportRootGetTeamsUserActivityUserDetailParameterSet;\n\n// **NOTE** This file was generated by a tool and any changes will be overwritten.\n\n/**\n * The class for the Report Root Get Teams User Activity User Detail Request.\n */\npublic class ReportRootGetTeamsUserActivityUserDetailRequest extends BaseRequest<java.io.InputStream> {\n    /**\n     * The request for this ReportRootGetTeamsUserActivityUserDetail\n     *\n     * @param requestUrl     the request URL\n     * @param client         the service client\n     * @param requestOptions the options for this request\n     */\n    public ReportRootGetTeamsUserActivityUserDetailRequest(@Nonnull final String requestUrl, @Nonnull final IBaseClient<?> client, @Nullable final java.util.List<? extends com.microsoft.graph.options.Option> requestOptions) {\n        super(requestUrl, client, requestOptions, java.io.InputStream.class);\n    }\n\n    /**\n     * Gets the java.io.InputStream\n     *\n     * @return a future with the result\n     */\n    @Nonnull\n    public java.util.concurrent.CompletableFuture<java.io.InputStream> getAsync() {\n        return sendAsync(HttpMethod.GET, null);\n    }\n\n    /**\n     * Gets the java.io.InputStream\n     *\n     * @return the java.io.InputStream\n     * @throws ClientException an exception occurs if there was an error while the request was sent\n     */\n    @Nullable\n    public java.io.InputStream get() throws ClientException {\n       return send(HttpMethod.GET, null);\n    }\n\n    /**\n     * Sets the select clause for the request\n     *\n     * @param value the select clause\n     * @return the updated request\n     */\n    @Nonnull\n    public ReportRootGetTeamsUserActivityUserDetailRequest select(@Nonnull final String value) {\n        addSelectOption(value);\n        return this;\n    }\n\n    /**\n     * Sets the expand clause for the request\n     *\n     * @param value the expand clause\n     * @return the updated request\n     */\n    @Nonnull\n    public ReportRootGetTeamsUserActivityUserDetailRequest expand(@Nonnull final String value) {\n        addExpandOption(value);\n        return this;\n    }\n\n}\n", "4 cocos2d-java.org\n * \n *   http://www.cocos2d-java.org\n *   \n *   The MIT License (MIT)\n *      \n *Permission is hereby granted, free of charge, to any person obtaining a copy\n *of this software and associated documentation files (the \"Software\"), to deal\n *in the Software without restriction, including without limitation the rights\n *to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n *copies of the Software, and to permit persons to whom the Software is\n *furnished to do so, subject to the following conditions:\n\n *The above copyright notice and this permission notice shall be included in\n *all copies or substantial portions of the Software.\n\n *THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n *IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n *FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n *AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n *LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n *OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n *THE SOFTWARE.\n *******************************************************************************/\n\npackage cocos2d.layers_scenes_transitions_nodes;\n\nimport cocos2d.predefine.CCTypes;\nimport cocos2d.predefine.ICCRGBAProtocol;\nimport cocos2d.predefine.CCColor3B;\n\npublic class CCLayerRGBA extends CCLayer implements ICCRGBAProtocol\n{\n    protected int _displayedOpacity;\n    protected int _realOpacity;\n    protected CCColor3B _displayedColor;\n    protected CCColor3B _realColor;\n    protected boolean _cascadeColorEnabled;\n    protected boolean _cascadeOpacityEnabled;\n\n    public CCColor3B getColor()\n    {\n        return new CCColor3B(_realColor);\n    }\n\n    public void setColor(CCColor3B value)\n    {\n        _displayedColor = new CCColor3B(value);\n        _realColor = new CCColor3B(value);\n\n        if (_cascadeColorEnabled)\n        {\n        \tCCColor3B parentColor = new CCColor3B(CCTypes.CCWhite);\n            //var parent = m_pParent as ICCRGBAProtocol;\n        \tICCRGBAProtocol parent = null;\n        \tif (m_pParent instanceof ICCRGBAProtocol)\n        \t{\n        \t\tparent = (ICCRGBAProtocol)m_pParent;\n        \t}\n            if (parent != null && parent.getCascadeColorEnabled())\n            {\n                parentColor = new CCColor3B(parent.getDisplayedColor());\n            }\n\n            updateDisplayedColor(parentColor);\n        } \n    }\n    \n    @Override\n    public  CCColor3B getDisplayedColor()\n    {\n        return _displayedColor;\n    }\n\n    @Override\n    public int getOpacity()\n    {\n        return _realOpacity;\n    }\n\n    @Override\n    public void setOpacity(int value)\n    { \n        _displayedOpacity = _realOpacity = value;\n\n        if (_cascadeOpacityEnabled)\n        {\n            int parentOpacity = 255;\n            ICCRGBAProtocol pParent = null;\n            if (m_pParent instanceof ICCRGBAProtocol)\n            {\n            \tpParent = (ICCRGBAProtocol)m_pParent;\n            }\n            if (pParent != null && pParent.getCascadeOpacityEnabled())\n            {\n                parentOpacity = pParent.getDisplayedOpacity();\n            }\n            updateDisplayedOpacity(parentOpacity);\n        }\n    }\n    \n    @Override\n    public int getDisplayedOpacity()\n    {\n        return _displayedOpacity;\n    }\n\n    @Override\n    public boolean getIsOpacityModifyRGB()\n    {\n        return false;\n    }\n       \n    @Override\n    public void setIsOpacityModifyRGB(boolean value)\n    {\n        \n    }\n    \n    @Override\n    public boolean getCascadeColorEnabled()\n    {\n        return _cascadeColorEnabled;\n    }\n\n    @Override\n    public void setCascadeColorEnabled(boolean value)\n    {\n        _cascadeColorEnabled = value;\n    }\n  \n    @Override\n    public boolean getCascadeOpacityEnabled()\n    {\n        return _cascadeOpacityEnabled;\n    }\n\n    @Override\n    public void setCascadeOpacityEnabled(boolean value)\n    {\n        _cascadeOpacityEnabled = value;\n    }\n    \n    public CCLayerRGBA()\n    {\n        _displayedOpacity = 255;\n        _realOpacity = 255;\n        _displayedColor = new CCColor3B(CCTypes.CCWhite);\n        _realColor = new CCColor3B(CCTypes.CCWhite);\n        \n        _cascadeColorEnabled = false;\n        _cascadeOpacityEnabled = false;\n    }\n\n    @Override\n    public boolean init()\n    {\n        super.init();\n\n        _displayedOpacity = _realOpacity = 255;\n        _displayedColor = new CCColor3B(CCTypes.CCWhite);\n        _realColor = new CCColor3B(CCTypes.CCWhite);\n        setCascadeOpacityEnabled(false);\n        setCascadeColorEnabled(false);\n\n        return true;\n    }\n\n    public void updateDisplayedColor(CCColor3B parentColor)\n    {\n        _displayedColor.R = (int) (_realColor.R * parentColor.R / 255.0f);\n        _displayedColor.G = (int) (_realColor.G * parentColor.G / 255.0f);\n        _displayedColor.B = (int) (_realColor.B * parentColor.B / 255.0f);\n\n        if (_cascadeColorEnabled)\n        {\n            if (_cascadeOpacityEnabled && m_pChildren != null)\n            {\n                for (int i = 0, count = m_pChildren.size; i < count; i++)\n                {\n                    //var item = m_pChildren.Elements[i] as ICCRGBAProtocol;\n                \tICCRGBAProtocol item = null;\n                \tif (m_pChildren.get(i) instanceof ICCRGBAProtocol)\n                \t{\n                \t\titem = (ICCRGBAProtocol)(m_pChildren.get(i));\n                \t}\n                    if (item != null)\n                    {\n                        item.updateDisplayedColor(_displayedColor);\n                    }\n                }\n            }\n        }\n    }\n\n    public void updateDisplayedOpacity(int parentOpacity)\n    {\n        _displayedOpacity = (int) (_realOpacity * parentOpacity / 255.0f);\n\n        if (_cascadeOpacityEnabled && m_pChildren != null)\n        {\n            for (int i = 0, count = m_pChildren.size; i < count; i++)\n            {\n            \tICCRGBAProtocol item = null;\n            \tif (m_pChildren.get(i) instanceof ICCRGBAProtocol)\n            \t{\n            \t\titem = (ICCRGBAProtocol)(m_pChildren.get(i));\n            \t}\n                if (item != null)\n                {\n                    item.updateDisplayedOpacity(_displayedOpacity);\n                }\n            }\n        }\n    }\n\n\t\n}", "minecraft.client.renderer.BufferBuilder;\nimport net.minecraft.client.renderer.GLAllocation;\nimport net.minecraft.client.renderer.GlStateManager;\nimport net.minecraft.client.renderer.Tessellator;\nimport net.minecraft.client.renderer.tileentity.TileEntitySpecialRenderer;\nimport net.minecraft.client.renderer.vertex.DefaultVertexFormats;\nimport net.minecraft.util.ResourceLocation;\nimport tamaized.voidcraft.common.blocks.TileEntityNoBreak;\n\nimport java.nio.FloatBuffer;\nimport java.util.Random;\n\npublic class RenderNoBreak extends TileEntitySpecialRenderer<TileEntityNoBreak> {\n\n\tprivate static final ResourceLocation END_SKY_TEXTURE = new ResourceLocation(\"textures/environment/end_sky.png\");\n\tprivate static final ResourceLocation END_PORTAL_TEXTURE = new ResourceLocation(\"textures/entity/end_portal.png\");\n\tprivate static final Random RANDOM = new Random(31100L);\n\tprivate static final FloatBuffer MODELVIEW = GLAllocation.createDirectFloatBuffer(16);\n\tprivate static final FloatBuffer PROJECTION = GLAllocation.createDirectFloatBuffer(16);\n\tFloatBuffer buffer = GLAllocation.createDirectFloatBuffer(16);\n\n\t@Override\n\tpublic void render(TileEntityNoBreak te, double x, double y, double z, float partialTicks, int destroyStage, float p_192841_10_) {\n\t\tGlStateManager.disableLighting();\n\t\tRANDOM.setSeed(31100L);\n\t\tGlStateManager.getFloat(2982, MODELVIEW);\n\t\tGlStateManager.getFloat(2983, PROJECTION);\n\t\tdouble d0 = x * x + y * y + z * z;\n\t\tint i = this.getPasses(d0);\n\t\tfloat f = this.getOffset();\n\n\t\tfor (int j = 0; j < i; ++j) {\n\t\t\tGlStateManager.pushMatrix();\n\t\t\tfloat f1 = 2.0F / (float) (18 - j);\n\n\t\t\tif (j == 0) {\n\t\t\t\tthis.bindTexture(END_SKY_TEXTURE);\n\t\t\t\tf1 = 0.15F;\n\t\t\t\tGlStateManager.enableBlend();\n\t\t\t\tGlStateManager.blendFunc(GlStateManager.SourceFactor.SRC_ALPHA, GlStateManager.DestFactor.ONE_MINUS_SRC_ALPHA);\n\t\t\t}\n\n\t\t\tif (j >= 1) {\n\t\t\t\tthis.bindTexture(END_PORTAL_TEXTURE);\n\t\t\t}\n\n\t\t\tif (j == 1) {\n\t\t\t\tGlStateManager.enableBlend();\n\t\t\t\tGlStateManager.blendFunc(GlStateManager.SourceFactor.ONE, GlStateManager.DestFactor.ONE);\n\t\t\t}\n\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.S, 9216);\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.T, 9216);\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.R, 9216);\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.S, 9474, this.getBuffer(1.0F, 0.0F, 0.0F, 0.0F));\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.T, 9474, this.getBuffer(0.0F, 1.0F, 0.0F, 0.0F));\n\t\t\tGlStateManager.texGen(GlStateManager.TexGen.R, 9474, this.getBuffer(0.0F, 0.0F, 1.0F, 0.0F));\n\t\t\tGlStateManager.enableTexGenCoord(GlStateManager.TexGen.S);\n\t\t\tGlStateManager.enableTexGenCoord(GlStateManager.TexGen.T);\n\t\t\tGlStateManager.enableTexGenCoord(GlStateManager.TexGen.R);\n\t\t\tGlStateManager.popMatrix();\n\t\t\tGlStateManager.matrixMode(5890);\n\t\t\tGlStateManager.pushMatrix();\n\t\t\tGlStateManager.loadIdentity();\n\t\t\tGlStateManager.translate(0.5F, 0.5F, 0.0F);\n\t\t\tGlStateManager.scale(0.5F, 0.5F, 1.0F);\n\t\t\tfloat f2 = (float) (j + 1);\n\t\t\tGlStateManager.translate(17.0F / f2, (2.0F + f2 / 1.5F) * ((float) Minecraft.getSystemTime() % 800000.0F / 800000.0F), 0.0F);\n\t\t\tGlStateManager.rotate((f2 * f2 * 4321.0F + f2 * 9.0F) * 2.0F, 0.0F, 0.0F, 1.0F);\n\t\t\tGlStateManager.scale(4.5F - f2 / 4.0F, 4.5F - f2 / 4.0F, 1.0F);\n\t\t\tGlStateManager.multMatrix(PROJECTION);\n\t\t\tGlStateManager.multMatrix(MODELVIEW);\n\t\t\tTessellator tessellator = Tessellator.getInstance();\n\t\t\tBufferBuilder vertexbuffer = tessellator.getBuffer();\n\t\t\tvertexbuffer.begin(7, DefaultVertexFormats.POSITION_COLOR);\n\t\t\tfloat f3 = (RANDOM.nextFloat() * 0.5F + 0.1F) * f1;\n\t\t\tfloat f4 = (RANDOM.nextFloat() * 0.5F + 0.4F) * f1;\n\t\t\tfloat f5 = (RANDOM.nextFloat() * 0.5F + 0.5F) * f1;\n\n\t\t\tvertexbuffer.pos(x, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + 1.0D, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\tvertexbuffer.pos(x, y + (double) f, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + (double) f, z + 1.0D).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x + 1.0D, y + (double) f, z).color(f3, f4, f5, 1.0F).endVertex();\n\t\t\tvertexbuffer.pos(x, y + (double) f, z).color(f3, f4, f5, 1.0F).endVertex();\n\n\t\t\ttessellator.draw();\n\t\t\tGlStateManager.popMatrix();\n\t\t\tGlStateManager.matrixMode(5888);\n\t\t\tthis.bindTexture(END_SKY_TEXTURE);\n\t\t}\n\n\t\tGlStateManager.disableBlend();\n\t\tGlStateManager.disableTexGenCoord(GlStateManager.TexGen.S);\n\t\tGlStateManager.disableTexGenCoord(GlStateManager.TexGen.T);\n\t\tGlStateManager.disableTexGenCoord(GlStateManager.TexGen.R);\n\t\tGlStateManager.enableLighting();\n\t}\n\n\tprotected int getPasses(double p_191286_1_) {\n\t\tint i;\n\n\t\tif (p_191286_1_ > 36864.0D) {\n\t\t\ti = 1;\n\t\t} else if (p_191286_1_ > 25600.0D) {\n\t\t\ti = 3;\n\t\t} else if (p_191286_1_ > 16384.0D) {\n\t\t\ti = 5;\n\t\t} else if (p_191286_1_ > 9216.0D) {\n\t\t\ti = 7;\n\t\t} else if (p_191286_1_ > 4096.0D) {\n\t\t\ti = 9;\n\t\t} else if (p_191286_1_ > 1024.0D) {\n\t\t\ti = 11;\n\t\t} else if (p_191286_1_ > 576.0D) {\n\t\t\ti = 13;\n\t\t} else if (p_191286_1_ > 256.0D) {\n\t\t\ti = 14;\n\t\t} else {\n\t\t\ti = 15;\n\t\t}\n\n\t\treturn i;\n\t}\n\n\tprotected float getOffset() {\n\t\treturn 1.0F;\n\t}\n\n\tprivate FloatBuffer getBuffer(float p_188193_1_, float p_188193_2_, float p_188193_3_, float p_188193_4_) {\n\t\tthis.buffer.clear();\n\t\tthis.buffer.put(p_188193_1_).put(p_188193_2_).put(p_188193_3_).put(p_188193_4_);\n\t\tthis.buffer.flip();\n\t\treturn this.buffer;\n\t}\n\n}\n", "nications AB.\n * All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\npackage com.sonymobile.gitlab.api;\n\nimport com.github.tomakehurst.wiremock.junit.WireMockRule;\nimport org.junit.Before;\nimport org.junit.Rule;\nimport org.junit.rules.ExpectedException;\n\nimport static java.lang.Integer.parseInt;\n\n/**\n * Parent for all test classes testing the GitLab API client.\n *\n * @author Emil Nilsson\n */\npublic abstract class AbstractClientTest {\n    /** The port to run WireMock on. */\n    private static final int WIREMOCK_PORT = parseInt(System.getProperty(\"com.sonymobile.gitlab.api.wiremock.port\",\n            \"6789\"));\n\n    /** The URL of the GitLab API WireMock is faking. */\n    protected static final String SERVER_URL = \"http://localhost:\" + WIREMOCK_PORT;\n\n    /** The private token of the GitLab API WireMock is faking. */\n    protected static final String PRIVATE_TOKEN = \"0123456789abcdef\";\n\n    /** A rule for setting up a mock server for every test. */\n    @Rule\n    public WireMockRule serverRule = new WireMockRule(WIREMOCK_PORT);\n\n    /** A rule for catching expected exceptions. */\n    @Rule\n    public ExpectedException thrown = ExpectedException.none();\n\n    /** The GitLab API client to test against. */\n    protected GitLabApiClient client;\n\n    /**\n     * Set up the GitLab API client.\n     */\n    @Before\n    public void setUp() {\n        client = new GitLabApiClient(SERVER_URL, PRIVATE_TOKEN);\n    }\n}\n", "pp.Fragment;\nimport android.view.LayoutInflater;\nimport android.view.View;\nimport android.view.ViewGroup;\n\n\n/**\n * A simple {@link Fragment} subclass.\n */\npublic class NewestFragment extends Fragment {\n\n\n    public NewestFragment() {\n        // Required empty public constructor\n    }\n\n\n    @Override\n    public View onCreateView(LayoutInflater inflater, ViewGroup container,\n                             Bundle savedInstanceState) {\n        // Inflate the layout for this fragment\n        return inflater.inflate(R.layout.fragment_newest, container, false);\n    }\n\n\n}\n"], "perplexity": [2.5072429180145264, 2.5710933208465576, 3.734631061553955, 4.231790065765381, 4.380981922149658, 3.7944579124450684, 3.5945258140563965, 5.799772262573242, 4.276001930236816, 6.099084377288818, 3.6834280490875244, 2.9435598850250244, 5.602396488189697, 2.9242265224456787, 4.8601813316345215, 1.6317036151885986, 5.835641384124756, 1.9858123064041138, 4.37538480758667, 3.678847551345825, 4.499482154846191, 25.14177131652832, 3.9607882499694824, 2.066793918609619, 3.6478030681610107, 4.419491767883301, 3.963249444961548, 2.390801429748535, 3.946309804916382, 13.388493537902832, 1.9788928031921387, 3.9785280227661133, 5.3004889488220215, 2.2718505859375, 2.5548765659332275, 4.1341938972473145, 3.5199663639068604, 2.225773811340332, 2.5910286903381348, 3.3760550022125244, 2.7987568378448486, 4.735001564025879, 2.3651983737945557, 2.5551130771636963, 24.015403747558594, 1.5884267091751099, 1.9304041862487793, 2.7378504276275635, 5.325862407684326, 4.356362342834473, 6.521080493927002, 10.146283149719238, 3.9507296085357666, 5.619297027587891, 2.605933666229248, 6.224507808685303, 2.246244430541992, 3.3304333686828613, 3.17030930519104, 5.879040241241455, 2.607654333114624, 2.46952748298645, 2.2360801696777344, 2.3787288665771484, 2.1261894702911377, 13.499594688415527, 5.587558746337891, 4.518209457397461, 2.6308722496032715, 3.135084629058838, 1.7526963949203491, 2.9858992099761963, 5.699460506439209, 9.418479919433594, 1.9731252193450928, 3.8925940990448, 2.955435276031494, 3.6284029483795166, 1.6774094104766846, 6.703100204467773, 2.9142000675201416, 6.013830661773682, 2.779583692550659, 3.079700231552124, 3.8429811000823975, 4.43913459777832, 3.9159512519836426, 2.7841460704803467, 3.81148099899292, 4.250913619995117, 2.58168888092041, 39.08735275268555, 5.509825229644775, 7.136451721191406, 3.317718505859375, 4.178539752960205, 1.9572726488113403, 2.170574188232422, 3.1918210983276367, 11.325577735900879], "avg_perplexity": 4.80134489774704}